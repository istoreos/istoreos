From c10a0c4ee2e5780620b26340bdfe327f8624093a Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Fri, 28 Oct 2022 10:50:37 +0800
Subject: [PATCH 05/46] clk

---
 drivers/clk/Kconfig                     |   24 +-
 drivers/clk/clk-bulk.c                  |  106 +-
 drivers/clk/clk-composite.c             |   26 +-
 drivers/clk/clk-conf.c                  |    5 +-
 drivers/clk/clk-devres.c                |   57 +-
 drivers/clk/clk-divider.c               |    2 +-
 drivers/clk/clk-fixed-factor.c          |    2 +-
 drivers/clk/clk-fixed-rate.c            |    2 +-
 drivers/clk/clk-fractional-divider.c    |   38 +-
 drivers/clk/clk-gate.c                  |    2 +-
 drivers/clk/clk-mux.c                   |    2 +-
 drivers/clk/clk-pwm.c                   |    4 +-
 drivers/clk/clk-rk808.c                 |   64 +-
 drivers/clk/clk-scmi.c                  |   16 +-
 drivers/clk/clk-scpi.c                  |    2 +-
 drivers/clk/clk-xgene.c                 |    6 +-
 drivers/clk/clk.c                       | 1407 +++++++++++++++++++-
 drivers/clk/clk.h                       |   10 +-
 drivers/clk/clkdev.c                    |    4 +-
 drivers/clk/rockchip/Makefile           |   17 +-
 drivers/clk/rockchip/clk-cpu.c          |  132 +-
 drivers/clk/rockchip/clk-ddr.c          |  257 +++-
 drivers/clk/rockchip/clk-half-divider.c |   35 +-
 drivers/clk/rockchip/clk-inverter.c     |    2 +-
 drivers/clk/rockchip/clk-mmc-phase.c    |    2 +-
 drivers/clk/rockchip/clk-muxgrf.c       |    2 +-
 drivers/clk/rockchip/clk-pll.c          |  862 +++++++++++-
 drivers/clk/rockchip/clk-px30.c         |  194 ++-
 drivers/clk/rockchip/clk-rk3036.c       |  493 -------
 drivers/clk/rockchip/clk-rk3128.c       |  655 ---------
 drivers/clk/rockchip/clk-rk3188.c       |  879 ------------
 drivers/clk/rockchip/clk-rk3228.c       |  727 ----------
 drivers/clk/rockchip/clk-rk3288.c       |  951 -------------
 drivers/clk/rockchip/clk-rk3328.c       |  923 -------------
 drivers/clk/rockchip/clk-rk3368.c       |  921 -------------
 drivers/clk/rockchip/clk-rk3399.c       | 1616 -----------------------
 drivers/clk/rockchip/clk-rv1108.c       |  831 ------------
 drivers/clk/rockchip/clk.c              |  199 ++-
 drivers/clk/rockchip/clk.h              |  380 +++++-
 drivers/clocksource/arm_arch_timer.c    |   21 +
 drivers/clocksource/arm_global_timer.c  |   93 +-
 include/clocksource/arm_arch_timer.h    |    5 +
 include/linux/clk-provider.h            |  126 +-
 include/linux/clk.h                     |  146 ++
 44 files changed, 3907 insertions(+), 8341 deletions(-)
 delete mode 100644 drivers/clk/rockchip/clk-rk3036.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3128.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3188.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3228.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3288.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3328.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3368.c
 delete mode 100644 drivers/clk/rockchip/clk-rk3399.c
 delete mode 100644 drivers/clk/rockchip/clk-rv1108.c

diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 292056bbb..33c4db06c 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -22,6 +22,20 @@ config COMMON_CLK
 menu "Common Clock Framework"
 	depends on COMMON_CLK
 
+config COMMON_CLK_DEBUGFS
+	bool "Common Clock DebugFS interface"
+	depends on COMMON_CLK && DEBUG_FS
+	default y
+	help
+	  Turns on the DebugFS interface for clock.
+
+config COMMON_CLK_PROCFS
+	bool "Common Clock PROCFS interface"
+	depends on COMMON_CLK && PROC_FS
+	default n
+	help
+	  Turns on the PROCFS interface for clock.
+
 config COMMON_CLK_WM831X
 	tristate "Clock driver for WM831x/2x PMICs"
 	depends on MFD_WM831X
@@ -52,13 +66,12 @@ config COMMON_CLK_MAX9485
 	  This driver supports Maxim 9485 Programmable Audio Clock Generator
 
 config COMMON_CLK_RK808
-	tristate "Clock driver for RK805/RK808/RK818"
+	tristate "Clock driver for RK805/RK808/RK809/RK817/RK818"
 	depends on MFD_RK808
 	---help---
-	  This driver supports RK805, RK808 and RK818 crystal oscillator clock. These
-	  multi-function devices have two fixed-rate oscillators,
-	  clocked at 32KHz each. Clkout1 is always on, Clkout2 can off
-	  by control register.
+	  This driver supports RK805, RK809 and RK817, RK808 and RK818 crystal oscillator clock.
+	  These multi-function devices have two fixed-rate oscillators, clocked at 32KHz each.
+	  Clkout1 is always on, Clkout2 can off by control register.
 
 config COMMON_CLK_HI655X
 	tristate "Clock driver for Hi655x" if EXPERT
@@ -293,6 +306,7 @@ source "drivers/clk/meson/Kconfig"
 source "drivers/clk/mvebu/Kconfig"
 source "drivers/clk/qcom/Kconfig"
 source "drivers/clk/renesas/Kconfig"
+source "drivers/clk/rockchip/Kconfig"
 source "drivers/clk/samsung/Kconfig"
 source "drivers/clk/sprd/Kconfig"
 source "drivers/clk/sunxi-ng/Kconfig"
diff --git a/drivers/clk/clk-bulk.c b/drivers/clk/clk-bulk.c
index 6904ed6da..c232d0d51 100644
--- a/drivers/clk/clk-bulk.c
+++ b/drivers/clk/clk-bulk.c
@@ -17,8 +17,68 @@
  */
 
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/device.h>
 #include <linux/export.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+
+static int __must_check of_clk_bulk_get(struct device_node *np, int num_clks,
+					struct clk_bulk_data *clks)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		clks[i].id = NULL;
+		clks[i].clk = NULL;
+	}
+
+	for (i = 0; i < num_clks; i++) {
+		of_property_read_string_index(np, "clock-names", i, &clks[i].id);
+		clks[i].clk = of_clk_get(np, i);
+		if (IS_ERR(clks[i].clk)) {
+			ret = PTR_ERR(clks[i].clk);
+			pr_err("%pOF: Failed to get clk index: %d ret: %d\n",
+			       np, i, ret);
+			clks[i].clk = NULL;
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	clk_bulk_put(i, clks);
+
+	return ret;
+}
+
+static int __must_check of_clk_bulk_get_all(struct device_node *np,
+					    struct clk_bulk_data **clks)
+{
+	struct clk_bulk_data *clk_bulk;
+	int num_clks;
+	int ret;
+
+	num_clks = of_clk_get_parent_count(np);
+	if (!num_clks)
+		return 0;
+
+	clk_bulk = kmalloc_array(num_clks, sizeof(*clk_bulk), GFP_KERNEL);
+	if (!clk_bulk)
+		return -ENOMEM;
+
+	ret = of_clk_bulk_get(np, num_clks, clk_bulk);
+	if (ret) {
+		kfree(clk_bulk);
+		return ret;
+	}
+
+	*clks = clk_bulk;
+
+	return num_clks;
+}
 
 void clk_bulk_put(int num_clks, struct clk_bulk_data *clks)
 {
@@ -29,8 +89,8 @@ void clk_bulk_put(int num_clks, struct clk_bulk_data *clks)
 }
 EXPORT_SYMBOL_GPL(clk_bulk_put);
 
-int __must_check clk_bulk_get(struct device *dev, int num_clks,
-			      struct clk_bulk_data *clks)
+static int __clk_bulk_get(struct device *dev, int num_clks,
+			  struct clk_bulk_data *clks, bool optional)
 {
 	int ret;
 	int i;
@@ -42,10 +102,14 @@ int __must_check clk_bulk_get(struct device *dev, int num_clks,
 		clks[i].clk = clk_get(dev, clks[i].id);
 		if (IS_ERR(clks[i].clk)) {
 			ret = PTR_ERR(clks[i].clk);
+			clks[i].clk = NULL;
+
+			if (ret == -ENOENT && optional)
+				continue;
+
 			if (ret != -EPROBE_DEFER)
 				dev_err(dev, "Failed to get clk '%s': %d\n",
 					clks[i].id, ret);
-			clks[i].clk = NULL;
 			goto err;
 		}
 	}
@@ -57,8 +121,44 @@ int __must_check clk_bulk_get(struct device *dev, int num_clks,
 
 	return ret;
 }
+
+int __must_check clk_bulk_get(struct device *dev, int num_clks,
+			      struct clk_bulk_data *clks)
+{
+	return __clk_bulk_get(dev, num_clks, clks, false);
+}
 EXPORT_SYMBOL(clk_bulk_get);
 
+int __must_check clk_bulk_get_optional(struct device *dev, int num_clks,
+				       struct clk_bulk_data *clks)
+{
+	return __clk_bulk_get(dev, num_clks, clks, true);
+}
+EXPORT_SYMBOL_GPL(clk_bulk_get_optional);
+
+void clk_bulk_put_all(int num_clks, struct clk_bulk_data *clks)
+{
+	if (IS_ERR_OR_NULL(clks))
+		return;
+
+	clk_bulk_put(num_clks, clks);
+
+	kfree(clks);
+}
+EXPORT_SYMBOL(clk_bulk_put_all);
+
+int __must_check clk_bulk_get_all(struct device *dev,
+				  struct clk_bulk_data **clks)
+{
+	struct device_node *np = dev_of_node(dev);
+
+	if (!np)
+		return 0;
+
+	return of_clk_bulk_get_all(np, clks);
+}
+EXPORT_SYMBOL(clk_bulk_get_all);
+
 #ifdef CONFIG_HAVE_CLK_PREPARE
 
 /**
diff --git a/drivers/clk/clk-composite.c b/drivers/clk/clk-composite.c
index 00269de2f..182a390c9 100644
--- a/drivers/clk/clk-composite.c
+++ b/drivers/clk/clk-composite.c
@@ -161,8 +161,32 @@ static int clk_composite_set_rate_and_parent(struct clk_hw *hw,
 	const struct clk_ops *mux_ops = composite->mux_ops;
 	struct clk_hw *rate_hw = composite->rate_hw;
 	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_hw *brother_hw = composite->brother_hw;
 	unsigned long temp_rate;
 
+	if (brother_hw) {
+		struct clk_composite *bcomposite = to_clk_composite(brother_hw);
+		const struct clk_ops *brate_ops = bcomposite->rate_ops;
+		struct clk_hw *brate_hw = bcomposite->rate_hw;
+		struct clk_hw *parent_hw = clk_hw_get_parent(brother_hw);
+		struct clk_hw *new_parent_hw = clk_hw_get_parent(hw);
+
+		__clk_hw_set_clk(brate_hw, brother_hw);
+
+		temp_rate = brate_ops->recalc_rate(brate_hw, parent_rate);
+		if (temp_rate > rate)
+			brate_ops->set_rate(brate_hw, rate, parent_rate);
+		if (clk_hw_is_prepared(brother_hw)) {
+			clk_prepare_enable(new_parent_hw->clk);
+			clk_enable(brother_hw->clk);
+		}
+		clk_hw_reparent(brother_hw, new_parent_hw);
+		if (clk_hw_is_prepared(brother_hw)) {
+			clk_disable(brother_hw->clk);
+			clk_disable_unprepare(parent_hw->clk);
+		}
+	}
+
 	__clk_hw_set_clk(rate_hw, hw);
 	__clk_hw_set_clk(mux_hw, hw);
 
@@ -219,7 +243,7 @@ struct clk_hw *clk_hw_register_composite(struct device *dev, const char *name,
 			unsigned long flags)
 {
 	struct clk_hw *hw;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk_composite *composite;
 	struct clk_ops *clk_composite_ops;
 	int ret;
diff --git a/drivers/clk/clk-conf.c b/drivers/clk/clk-conf.c
index 49819b546..c7405a2e6 100644
--- a/drivers/clk/clk-conf.c
+++ b/drivers/clk/clk-conf.c
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/of.h>
 #include <linux/printk.h>
+#include "clk.h"
 
 static int __set_clk_parents(struct device_node *node, bool clk_supplier)
 {
@@ -38,7 +39,7 @@ static int __set_clk_parents(struct device_node *node, bool clk_supplier)
 		}
 		if (clkspec.np == node && !clk_supplier)
 			return 0;
-		pclk = of_clk_get_from_provider(&clkspec);
+		pclk = of_clk_get_from_provider_with_orphans(&clkspec);
 		if (IS_ERR(pclk)) {
 			if (PTR_ERR(pclk) != -EPROBE_DEFER)
 				pr_warn("clk: couldn't get parent clock %d for %pOF\n",
@@ -54,7 +55,7 @@ static int __set_clk_parents(struct device_node *node, bool clk_supplier)
 			rc = 0;
 			goto err;
 		}
-		clk = of_clk_get_from_provider(&clkspec);
+		clk = of_clk_get_from_provider_with_orphans(&clkspec);
 		if (IS_ERR(clk)) {
 			if (PTR_ERR(clk) != -EPROBE_DEFER)
 				pr_warn("clk: couldn't get assigned clock %d for %pOF\n",
diff --git a/drivers/clk/clk-devres.c b/drivers/clk/clk-devres.c
index d854e26a8..e9b02d7c3 100644
--- a/drivers/clk/clk-devres.c
+++ b/drivers/clk/clk-devres.c
@@ -34,6 +34,17 @@ struct clk *devm_clk_get(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL(devm_clk_get);
 
+struct clk *devm_clk_get_optional(struct device *dev, const char *id)
+{
+	struct clk *clk = devm_clk_get(dev, id);
+
+	if (clk == ERR_PTR(-ENOENT))
+		return NULL;
+
+	return clk;
+}
+EXPORT_SYMBOL(devm_clk_get_optional);
+
 struct clk_bulk_devres {
 	struct clk_bulk_data *clks;
 	int num_clks;
@@ -46,8 +57,8 @@ static void devm_clk_bulk_release(struct device *dev, void *res)
 	clk_bulk_put(devres->num_clks, devres->clks);
 }
 
-int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
-		      struct clk_bulk_data *clks)
+static int __devm_clk_bulk_get(struct device *dev, int num_clks,
+			       struct clk_bulk_data *clks, bool optional)
 {
 	struct clk_bulk_devres *devres;
 	int ret;
@@ -57,7 +68,10 @@ int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
 	if (!devres)
 		return -ENOMEM;
 
-	ret = clk_bulk_get(dev, num_clks, clks);
+	if (optional)
+		ret = clk_bulk_get_optional(dev, num_clks, clks);
+	else
+		ret = clk_bulk_get(dev, num_clks, clks);
 	if (!ret) {
 		devres->clks = clks;
 		devres->num_clks = num_clks;
@@ -68,8 +82,45 @@ int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
 
 	return ret;
 }
+
+int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
+		      struct clk_bulk_data *clks)
+{
+	return __devm_clk_bulk_get(dev, num_clks, clks, false);
+}
 EXPORT_SYMBOL_GPL(devm_clk_bulk_get);
 
+int __must_check devm_clk_bulk_get_optional(struct device *dev, int num_clks,
+		      struct clk_bulk_data *clks)
+{
+	return __devm_clk_bulk_get(dev, num_clks, clks, true);
+}
+EXPORT_SYMBOL_GPL(devm_clk_bulk_get_optional);
+
+int __must_check devm_clk_bulk_get_all(struct device *dev,
+				       struct clk_bulk_data **clks)
+{
+	struct clk_bulk_devres *devres;
+	int ret;
+
+	devres = devres_alloc(devm_clk_bulk_release,
+			      sizeof(*devres), GFP_KERNEL);
+	if (!devres)
+		return -ENOMEM;
+
+	ret = clk_bulk_get_all(dev, &devres->clks);
+	if (ret > 0) {
+		*clks = devres->clks;
+		devres->num_clks = ret;
+		devres_add(dev, devres);
+	} else {
+		devres_free(devres);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_clk_bulk_get_all);
+
 static int devm_clk_match(struct device *dev, void *res, void *data)
 {
 	struct clk **c = res;
diff --git a/drivers/clk/clk-divider.c b/drivers/clk/clk-divider.c
index b6234a5da..c1296b524 100644
--- a/drivers/clk/clk-divider.c
+++ b/drivers/clk/clk-divider.c
@@ -458,7 +458,7 @@ static struct clk_hw *_register_divider(struct device *dev, const char *name,
 {
 	struct clk_divider *div;
 	struct clk_hw *hw;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	int ret;
 
 	if (clk_divider_flags & CLK_DIVIDER_HIWORD_MASK) {
diff --git a/drivers/clk/clk-fixed-factor.c b/drivers/clk/clk-fixed-factor.c
index 7df6b5b1e..88a9d9468 100644
--- a/drivers/clk/clk-fixed-factor.c
+++ b/drivers/clk/clk-fixed-factor.c
@@ -74,7 +74,7 @@ struct clk_hw *clk_hw_register_fixed_factor(struct device *dev,
 		unsigned int mult, unsigned int div)
 {
 	struct clk_fixed_factor *fix;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk_hw *hw;
 	int ret;
 
diff --git a/drivers/clk/clk-fixed-rate.c b/drivers/clk/clk-fixed-rate.c
index 6d6475c32..d176d2d84 100644
--- a/drivers/clk/clk-fixed-rate.c
+++ b/drivers/clk/clk-fixed-rate.c
@@ -61,7 +61,7 @@ struct clk_hw *clk_hw_register_fixed_rate_with_accuracy(struct device *dev,
 {
 	struct clk_fixed_rate *fixed;
 	struct clk_hw *hw;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	int ret;
 
 	/* allocate fixed-rate clock */
diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 083daa293..bf62cb108 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -77,13 +77,16 @@ static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
 	unsigned long m, n;
 	u64 ret;
 
-	if (!rate || (!clk_hw_can_set_rate_parent(hw) && rate >= *parent_rate))
+	if (!rate)
 		return *parent_rate;
 
-	if (fd->approximation)
+	if (fd->approximation) {
 		fd->approximation(hw, rate, parent_rate, &m, &n);
-	else
+	} else {
+		if (rate >= *parent_rate)
+			return *parent_rate;
 		clk_fd_general_approximation(hw, rate, parent_rate, &m, &n);
+	}
 
 	ret = (u64)*parent_rate * m;
 	do_div(ret, n);
@@ -103,6 +106,33 @@ static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
 			GENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),
 			&m, &n);
 
+	/*
+	 * When compensation the fractional divider,
+	 * the [1:0] bits of the numerator register are omitted,
+	 * which will lead to a large deviation in the result.
+	 * Therefore, it is required that the numerator must
+	 * be greater than 4.
+	 *
+	 * Note that there are some exceptions here:
+	 * If there is an even frac div, we need to keep the original
+	 * numerator(<4) and denominator. Otherwise, it may cause the
+	 * issue that the duty ratio is not 50%.
+	 */
+	if (m < 4 && m != 0) {
+		if (n % 2 == 0)
+			val = 1;
+		else
+			val = DIV_ROUND_UP(4, m);
+
+		n *= val;
+		m *= val;
+		if (n > fd->nmask) {
+			pr_debug("%s n(%ld) is overflow, use mask value\n",
+				 __func__, n);
+			n = fd->nmask;
+		}
+	}
+
 	if (fd->lock)
 		spin_lock_irqsave(fd->lock, flags);
 	else
@@ -134,7 +164,7 @@ struct clk_hw *clk_hw_register_fractional_divider(struct device *dev,
 		u8 clk_divider_flags, spinlock_t *lock)
 {
 	struct clk_fractional_divider *fd;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk_hw *hw;
 	int ret;
 
diff --git a/drivers/clk/clk-gate.c b/drivers/clk/clk-gate.c
index dd82485e0..5a0d5b23a 100644
--- a/drivers/clk/clk-gate.c
+++ b/drivers/clk/clk-gate.c
@@ -128,7 +128,7 @@ struct clk_hw *clk_hw_register_gate(struct device *dev, const char *name,
 {
 	struct clk_gate *gate;
 	struct clk_hw *hw;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	int ret;
 
 	if (clk_gate_flags & CLK_GATE_HIWORD_MASK) {
diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 1628b9365..8239d2fb7 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -140,7 +140,7 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 {
 	struct clk_mux *mux;
 	struct clk_hw *hw;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	u8 width = 0;
 	int ret;
 
diff --git a/drivers/clk/clk-pwm.c b/drivers/clk/clk-pwm.c
index 8cb9d117f..4c486c05c 100644
--- a/drivers/clk/clk-pwm.c
+++ b/drivers/clk/clk-pwm.c
@@ -56,7 +56,7 @@ static const struct clk_ops clk_pwm_ops = {
 static int clk_pwm_probe(struct platform_device *pdev)
 {
 	struct device_node *node = pdev->dev.of_node;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk_pwm *clk_pwm;
 	struct pwm_device *pwm;
 	struct pwm_args pargs;
@@ -78,7 +78,7 @@ static int clk_pwm_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_u32(node, "clock-frequency", &clk_pwm->fixed_rate))
-		clk_pwm->fixed_rate = NSEC_PER_SEC / pargs.period;
+		clk_pwm->fixed_rate = div64_u64(NSEC_PER_SEC, pargs.period);
 
 	if (pargs.period != NSEC_PER_SEC / clk_pwm->fixed_rate &&
 	    pargs.period != DIV_ROUND_UP(NSEC_PER_SEC, clk_pwm->fixed_rate)) {
diff --git a/drivers/clk/clk-rk808.c b/drivers/clk/clk-rk808.c
index 6461f2820..7f9a56ba1 100644
--- a/drivers/clk/clk-rk808.c
+++ b/drivers/clk/clk-rk808.c
@@ -96,6 +96,68 @@ of_clk_rk808_get(struct of_phandle_args *clkspec, void *data)
 	return idx ? &rk808_clkout->clkout2_hw : &rk808_clkout->clkout1_hw;
 }
 
+static int rk817_clkout2_enable(struct clk_hw *hw, bool enable)
+{
+	struct rk808_clkout *rk808_clkout = container_of(hw,
+							 struct rk808_clkout,
+							 clkout2_hw);
+	struct rk808 *rk808 = rk808_clkout->rk808;
+
+	return regmap_update_bits(rk808->regmap, RK817_SYS_CFG(1),
+				  RK817_CLK32KOUT2_EN,
+				  enable ? RK817_CLK32KOUT2_EN : 0);
+}
+
+static int rk817_clkout2_prepare(struct clk_hw *hw)
+{
+	return rk817_clkout2_enable(hw, true);
+}
+
+static void rk817_clkout2_unprepare(struct clk_hw *hw)
+{
+	rk817_clkout2_enable(hw, false);
+}
+
+static int rk817_clkout2_is_prepared(struct clk_hw *hw)
+{
+	struct rk808_clkout *rk808_clkout = container_of(hw,
+							 struct rk808_clkout,
+							 clkout2_hw);
+	struct rk808 *rk808 = rk808_clkout->rk808;
+	unsigned int val;
+
+	int ret = regmap_read(rk808->regmap, RK817_SYS_CFG(1), &val);
+
+	if (ret < 0)
+		return 0;
+
+	return (val & RK817_CLK32KOUT2_EN) ? 1 : 0;
+}
+
+static const struct clk_ops rk817_clkout2_ops = {
+	.prepare = rk817_clkout2_prepare,
+	.unprepare = rk817_clkout2_unprepare,
+	.is_prepared = rk817_clkout2_is_prepared,
+	.recalc_rate = rk808_clkout_recalc_rate,
+};
+
+static const struct clk_ops *rkpmic_get_ops(long variant)
+{
+	switch (variant) {
+	case RK809_ID:
+	case RK817_ID:
+		return &rk817_clkout2_ops;
+	/*
+	 * For the default case, it match the following PMIC type.
+	 * RK805_ID
+	 * RK808_ID
+	 * RK818_ID
+	 */
+	default:
+		return &rk808_clkout2_ops;
+	}
+}
+
 static int rk808_clkout_probe(struct platform_device *pdev)
 {
 	struct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);
@@ -127,7 +189,7 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 		return ret;
 
 	init.name = "rk808-clkout2";
-	init.ops = &rk808_clkout2_ops;
+	init.ops = rkpmic_get_ops(rk808->variant);
 	rk808_clkout->clkout2_hw.init = &init;
 
 	/* optional override of the clockname */
diff --git a/drivers/clk/clk-scmi.c b/drivers/clk/clk-scmi.c
index c65d30bba..7da2c01c4 100644
--- a/drivers/clk/clk-scmi.c
+++ b/drivers/clk/clk-scmi.c
@@ -69,7 +69,7 @@ static int scmi_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 {
 	struct scmi_clk *clk = to_scmi_clk(hw);
 
-	return clk->handle->clk_ops->rate_set(clk->handle, clk->id, 0, rate);
+	return clk->handle->clk_ops->rate_set(clk->handle, clk->id, rate);
 }
 
 static int scmi_clk_enable(struct clk_hw *hw)
@@ -202,7 +202,21 @@ static struct scmi_driver scmi_clocks_driver = {
 	.probe = scmi_clocks_probe,
 	.id_table = scmi_id_table,
 };
+#ifdef CONFIG_ARCH_ROCKCHIP
+static int __init scmi_clocks_driver_init(void)
+{
+	return scmi_register(&scmi_clocks_driver);
+}
+subsys_initcall_sync(scmi_clocks_driver_init);
+
+static void __exit scmi_clocks_driver_exit(void)
+{
+	scmi_unregister(&scmi_clocks_driver);
+}
+module_exit(scmi_clocks_driver_exit);
+#else
 module_scmi_driver(scmi_clocks_driver);
+#endif
 
 MODULE_AUTHOR("Sudeep Holla <sudeep.holla@arm.com>");
 MODULE_DESCRIPTION("ARM SCMI clock driver");
diff --git a/drivers/clk/clk-scpi.c b/drivers/clk/clk-scpi.c
index 258547228..44b76a1ab 100644
--- a/drivers/clk/clk-scpi.c
+++ b/drivers/clk/clk-scpi.c
@@ -150,7 +150,7 @@ static int
 scpi_clk_ops_init(struct device *dev, const struct of_device_id *match,
 		  struct scpi_clk *sclk, const char *name)
 {
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	unsigned long min = 0, max = 0;
 	int ret;
 
diff --git a/drivers/clk/clk-xgene.c b/drivers/clk/clk-xgene.c
index 531b030d4..43295d768 100644
--- a/drivers/clk/clk-xgene.c
+++ b/drivers/clk/clk-xgene.c
@@ -142,7 +142,7 @@ static struct clk *xgene_register_clk_pll(struct device *dev,
 {
 	struct xgene_clk_pll *apmclk;
 	struct clk *clk;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 
 	/* allocate the APM clock structure */
 	apmclk = kzalloc(sizeof(*apmclk), GFP_KERNEL);
@@ -359,7 +359,7 @@ xgene_register_clk_pmd(struct device *dev,
 		       u8 width, u64 denom, u32 clk_flags, spinlock_t *lock)
 {
 	struct xgene_clk_pmd *fd;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk *clk;
 
 	fd = kzalloc(sizeof(*fd), GFP_KERNEL);
@@ -643,7 +643,7 @@ static struct clk *xgene_register_clk(struct device *dev,
 {
 	struct xgene_clk *apmclk;
 	struct clk *clk;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	int rc;
 
 	/* allocate the APM clock structure */
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 32606d109..0a024225a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1,6 +1,7 @@
 /*
  * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
  * Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -24,6 +25,10 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/clkdev.h>
+#include <linux/uaccess.h>
+#include <linux/of_platform.h>
+#include <linux/pm_opp.h>
+#include <linux/regulator/consumer.h>
 
 #include "clk.h"
 
@@ -46,6 +51,16 @@ static struct hlist_head *all_lists[] = {
 	NULL,
 };
 
+/*
+ * clk_rate_change_list is used during clk_core_set_rate_nolock() calls to
+ * handle vdd_class vote tracking.  core->rate_change_node is added to
+ * clk_rate_change_list when core->new_rate requires a different voltage level
+ * (core->new_vdd_class_vote) than core->vdd_class_vote.  Elements are removed
+ * from the list after unvoting core->vdd_class_vote immediately before
+ * returning from clk_core_set_rate_nolock().
+ */
+static LIST_HEAD(clk_rate_change_list);
+
 /***    private data structures    ***/
 
 struct clk_core {
@@ -57,8 +72,8 @@ struct clk_core {
 	struct clk_core		*parent;
 	const char		**parent_names;
 	struct clk_core		**parents;
-	u8			num_parents;
-	u8			new_parent_index;
+	unsigned int		num_parents;
+	unsigned int		new_parent_index;
 	unsigned long		rate;
 	unsigned long		req_rate;
 	unsigned long		new_rate;
@@ -66,9 +81,14 @@ struct clk_core {
 	struct clk_core		*new_child;
 	unsigned long		flags;
 	bool			orphan;
+	bool			rpm_enabled;
+	bool			need_sync;
+	bool			boot_enabled;
 	unsigned int		enable_count;
 	unsigned int		prepare_count;
 	unsigned int		protect_count;
+	bool			need_handoff_enable;
+	bool			need_handoff_prepare;
 	unsigned long		min_rate;
 	unsigned long		max_rate;
 	unsigned long		accuracy;
@@ -78,11 +98,17 @@ struct clk_core {
 	struct hlist_node	child_node;
 	struct hlist_head	clks;
 	unsigned int		notifier_count;
-#ifdef CONFIG_DEBUG_FS
+#ifdef CONFIG_COMMON_CLK_DEBUGFS
 	struct dentry		*dentry;
 	struct hlist_node	debug_node;
 #endif
 	struct kref		ref;
+	struct clk_vdd_class	*vdd_class;
+	int			vdd_class_vote;
+	int			new_vdd_class_vote;
+	struct list_head	rate_change_node;
+	unsigned long		*rate_max;
+	int			num_rate_max;
 };
 
 #define CREATE_TRACE_POINTS
@@ -101,9 +127,9 @@ struct clk {
 /***           runtime pm          ***/
 static int clk_pm_runtime_get(struct clk_core *core)
 {
-	int ret = 0;
+	int ret;
 
-	if (!core->dev)
+	if (!core->rpm_enabled)
 		return 0;
 
 	ret = pm_runtime_get_sync(core->dev);
@@ -116,7 +142,7 @@ static int clk_pm_runtime_get(struct clk_core *core)
 
 static void clk_pm_runtime_put(struct clk_core *core)
 {
-	if (!core->dev)
+	if (!core->rpm_enabled)
 		return;
 
 	pm_runtime_put_sync(core->dev);
@@ -236,7 +262,7 @@ static bool clk_core_is_enabled(struct clk_core *core)
 	 * taking enable spinlock, but the below check is needed if one tries
 	 * to call it from other places.
 	 */
-	if (core->dev) {
+	if (core->rpm_enabled) {
 		pm_runtime_get_noresume(core->dev);
 		if (!pm_runtime_active(core->dev)) {
 			ret = false;
@@ -246,7 +272,7 @@ static bool clk_core_is_enabled(struct clk_core *core)
 
 	ret = core->ops->is_enabled(core->hw);
 done:
-	if (core->dev)
+	if (core->rpm_enabled)
 		pm_runtime_put(core->dev);
 
 	return ret;
@@ -407,6 +433,7 @@ bool clk_hw_is_prepared(const struct clk_hw *hw)
 {
 	return clk_core_is_prepared(hw->core);
 }
+EXPORT_SYMBOL_GPL(clk_hw_is_prepared);
 
 bool clk_hw_rate_is_protected(const struct clk_hw *hw)
 {
@@ -417,6 +444,7 @@ bool clk_hw_is_enabled(const struct clk_hw *hw)
 {
 	return clk_core_is_enabled(hw->core);
 }
+EXPORT_SYMBOL_GPL(clk_hw_is_enabled);
 
 bool __clk_is_enabled(struct clk *clk)
 {
@@ -549,6 +577,26 @@ void clk_hw_set_rate_range(struct clk_hw *hw, unsigned long min_rate,
 }
 EXPORT_SYMBOL_GPL(clk_hw_set_rate_range);
 
+/*
+ * Aggregate the rate of all the enabled child nodes and exclude that
+ * of the child node for which this request was made.
+ */
+unsigned long clk_aggregate_rate(struct clk_hw *hw,
+					const struct clk_core *parent)
+{
+	struct clk_core *child;
+	unsigned long aggre_rate = 0;
+
+	hlist_for_each_entry(child, &parent->children, child_node) {
+		if (child->enable_count &&
+				strcmp(child->name, hw->init->name))
+			aggre_rate = max(child->rate, aggre_rate);
+	}
+
+	return aggre_rate;
+}
+EXPORT_SYMBOL_GPL(clk_aggregate_rate);
+
 /*
  * Helper for finding best parent to provide a given frequency. This can be used
  * directly as a determine_rate callback (e.g. for a mux), or from a more
@@ -568,6 +616,201 @@ int __clk_mux_determine_rate_closest(struct clk_hw *hw,
 }
 EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
+/*
+ *  Find the voltage level required for a given clock rate.
+ */
+static int clk_find_vdd_level(struct clk_core *clk, unsigned long rate)
+{
+	int level;
+
+	/*
+	 * For certain PLLs, due to the limitation in the bits allocated for
+	 * programming the fractional divider, the actual rate of the PLL will
+	 * be slightly higher than the requested rate (in the order of several
+	 * Hz). To accommodate this difference, convert the FMAX rate and the
+	 * clock frequency to KHz and use that for deriving the voltage level.
+	 */
+	for (level = 0; level < clk->num_rate_max; level++)
+		if (DIV_ROUND_CLOSEST(rate, 1000) <=
+				DIV_ROUND_CLOSEST(clk->rate_max[level], 1000) &&
+		    clk->rate_max[level] > 0)
+			break;
+
+	if (level == clk->num_rate_max) {
+		pr_err("Rate %lu for %s is greater than highest Fmax\n", rate,
+				clk->name);
+		return -EINVAL;
+	}
+
+	return level;
+}
+
+/*
+ * Update voltage level given the current votes.
+ */
+static int clk_update_vdd(struct clk_vdd_class *vdd_class)
+{
+	int level, rc = 0, i, ignore;
+	struct regulator **r = vdd_class->regulator;
+	int *uv = vdd_class->vdd_uv;
+	int n_reg = vdd_class->num_regulators;
+	int cur_lvl = vdd_class->cur_level;
+	int max_lvl = vdd_class->num_levels - 1;
+	int cur_base = cur_lvl * n_reg;
+	int new_base;
+
+	/* aggregate votes */
+	for (level = max_lvl; level > 0; level--)
+		if (vdd_class->level_votes[level])
+			break;
+
+	if (level == cur_lvl)
+		return 0;
+
+	max_lvl = max_lvl * n_reg;
+	new_base = level * n_reg;
+
+	for (i = 0; i < vdd_class->num_regulators; i++) {
+		pr_debug("Set Voltage level Min %d, Max %d\n", uv[new_base + i],
+				uv[max_lvl + i]);
+		rc = regulator_set_voltage(r[i], uv[new_base + i], INT_MAX);
+		if (rc)
+			goto set_voltage_fail;
+
+		if (cur_lvl == 0 || cur_lvl == vdd_class->num_levels)
+			rc = regulator_enable(r[i]);
+		else if (level == 0)
+			rc = regulator_disable(r[i]);
+		if (rc)
+			goto enable_disable_fail;
+	}
+
+	if (vdd_class->set_vdd && !vdd_class->num_regulators)
+		rc = vdd_class->set_vdd(vdd_class, level);
+
+	if (!rc)
+		vdd_class->cur_level = level;
+
+	return rc;
+
+enable_disable_fail:
+	regulator_set_voltage(r[i], uv[cur_base + i], INT_MAX);
+
+set_voltage_fail:
+	for (i--; i >= 0; i--) {
+		regulator_set_voltage(r[i], uv[cur_base + i], INT_MAX);
+		if (cur_lvl == 0 || cur_lvl == vdd_class->num_levels)
+			regulator_disable(r[i]);
+		else if (level == 0)
+			ignore = regulator_enable(r[i]);
+	}
+
+	return rc;
+}
+
+/*
+ *  Vote for a voltage level.
+ */
+int clk_vote_vdd_level(struct clk_vdd_class *vdd_class, int level)
+{
+	int rc = 0;
+
+	if (level >= vdd_class->num_levels)
+		return -EINVAL;
+
+	mutex_lock(&vdd_class->lock);
+
+	vdd_class->level_votes[level]++;
+
+	rc = clk_update_vdd(vdd_class);
+	if (rc)
+		vdd_class->level_votes[level]--;
+
+	mutex_unlock(&vdd_class->lock);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(clk_vote_vdd_level);
+
+/*
+ * Remove vote for a voltage level.
+ */
+int clk_unvote_vdd_level(struct clk_vdd_class *vdd_class, int level)
+{
+	int rc = 0;
+
+	if (level >= vdd_class->num_levels)
+		return -EINVAL;
+
+	mutex_lock(&vdd_class->lock);
+
+	if (WARN(!vdd_class->level_votes[level],
+			"Reference counts are incorrect for %s level %d\n",
+			vdd_class->class_name, level)) {
+		rc = -EINVAL;
+		goto out;
+	}
+
+	vdd_class->level_votes[level]--;
+
+	rc = clk_update_vdd(vdd_class);
+	if (rc)
+		vdd_class->level_votes[level]++;
+
+out:
+	mutex_unlock(&vdd_class->lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(clk_unvote_vdd_level);
+
+/*
+ * Vote for a voltage level corresponding to a clock's rate.
+ */
+int clk_vote_rate_vdd(struct clk_core *core, unsigned long rate)
+{
+	int level;
+
+	if (!core->vdd_class)
+		return 0;
+
+	level = clk_find_vdd_level(core, rate);
+	if (level < 0)
+		return level;
+
+	return clk_vote_vdd_level(core->vdd_class, level);
+}
+EXPORT_SYMBOL_GPL(clk_vote_rate_vdd);
+
+/*
+ * Remove vote for a voltage level corresponding to a clock's rate.
+ */
+void clk_unvote_rate_vdd(struct clk_core *core, unsigned long rate)
+{
+	int level;
+
+	if (!core->vdd_class)
+		return;
+
+	level = clk_find_vdd_level(core, rate);
+	if (level < 0)
+		return;
+
+	clk_unvote_vdd_level(core->vdd_class, level);
+}
+EXPORT_SYMBOL_GPL(clk_unvote_rate_vdd);
+
+static bool clk_is_rate_level_valid(struct clk_core *core, unsigned long rate)
+{
+	int level;
+
+	if (!core->vdd_class)
+		return true;
+
+	level = clk_find_vdd_level(core, rate);
+
+	return level >= 0;
+}
+
 /***        clk api        ***/
 
 static void clk_core_rate_unprotect(struct clk_core *core)
@@ -735,6 +978,13 @@ static void clk_core_unprepare(struct clk_core *core)
 	clk_pm_runtime_put(core);
 
 	trace_clk_unprepare_complete(core);
+
+	if (core->vdd_class) {
+		clk_unvote_vdd_level(core->vdd_class, core->vdd_class_vote);
+		core->vdd_class_vote = 0;
+		core->new_vdd_class_vote = 0;
+	}
+
 	clk_core_unprepare(core->parent);
 }
 
@@ -785,13 +1035,28 @@ static int clk_core_prepare(struct clk_core *core)
 
 		trace_clk_prepare(core);
 
+		ret = clk_vote_rate_vdd(core, core->rate);
+		if (ret) {
+			clk_core_unprepare(core->parent);
+			return ret;
+		}
+		if (core->vdd_class) {
+			core->vdd_class_vote
+				= clk_find_vdd_level(core, core->rate);
+			core->new_vdd_class_vote = core->vdd_class_vote;
+		}
+
 		if (core->ops->prepare)
 			ret = core->ops->prepare(core->hw);
 
 		trace_clk_prepare_complete(core);
 
-		if (ret)
+		if (ret) {
+			clk_unvote_rate_vdd(core, core->rate);
+			core->vdd_class_vote = 0;
+			core->new_vdd_class_vote = 0;
 			goto unprepare;
+		}
 	}
 
 	core->prepare_count++;
@@ -1003,6 +1268,23 @@ static void clk_unprepare_unused_subtree(struct clk_core *core)
 	hlist_for_each_entry(child, &core->children, child_node)
 		clk_unprepare_unused_subtree(child);
 
+	if (dev_has_sync_state(core->dev) &&
+	    !(core->flags & CLK_DONT_HOLD_STATE))
+		return;
+
+	/*
+	 * setting CLK_ENABLE_HAND_OFF flag triggers this conditional
+	 *
+	 * need_handoff_prepare implies this clk was already prepared by
+	 * __clk_init. now we have a proper user, so unset the flag in our
+	 * internal bookkeeping. See CLK_ENABLE_HAND_OFF flag in clk-provider.h
+	 * for details.
+	 */
+	if (core->need_handoff_prepare) {
+		core->need_handoff_prepare = false;
+		clk_core_unprepare(core);
+	}
+
 	if (core->prepare_count)
 		return;
 
@@ -1034,6 +1316,25 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 	hlist_for_each_entry(child, &core->children, child_node)
 		clk_disable_unused_subtree(child);
 
+	if (dev_has_sync_state(core->dev) &&
+	    !(core->flags & CLK_DONT_HOLD_STATE))
+		return;
+
+	/*
+	 * setting CLK_ENABLE_HAND_OFF flag triggers this conditional
+	 *
+	 * need_handoff_enable implies this clk was already enabled by
+	 * __clk_init. now we have a proper user, so unset the flag in our
+	 * internal bookkeeping. See CLK_ENABLE_HAND_OFF flag in clk-provider.h
+	 * for details.
+	 */
+	if (core->need_handoff_enable) {
+		core->need_handoff_enable = false;
+		flags = clk_enable_lock();
+		clk_core_disable(core);
+		clk_enable_unlock(flags);
+	}
+
 	if (core->flags & CLK_OPS_PARENT_ENABLE)
 		clk_core_prepare_enable(core->parent);
 
@@ -1107,6 +1408,38 @@ static int clk_disable_unused(void)
 }
 late_initcall_sync(clk_disable_unused);
 
+static void clk_unprepare_disable_dev_subtree(struct clk_core *core,
+					      struct device *dev)
+{
+	struct clk_core *child;
+
+	lockdep_assert_held(&prepare_lock);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_unprepare_disable_dev_subtree(child, dev);
+
+	if (core->dev != dev || !core->need_sync)
+		return;
+
+	clk_core_disable_unprepare(core);
+}
+
+void clk_sync_state(struct device *dev)
+{
+	struct clk_core *core;
+
+	clk_prepare_lock();
+
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_unprepare_disable_dev_subtree(core, dev);
+
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_unprepare_disable_dev_subtree(core, dev);
+
+	clk_prepare_unlock();
+}
+EXPORT_SYMBOL_GPL(clk_sync_state);
+
 static int clk_core_determine_round_nolock(struct clk_core *core,
 					   struct clk_rate_request *req)
 {
@@ -1456,6 +1789,33 @@ static int clk_fetch_parent_index(struct clk_core *core,
 	return -EINVAL;
 }
 
+static void clk_core_hold_state(struct clk_core *core)
+{
+	if (core->need_sync || !core->boot_enabled)
+		return;
+
+	if (core->orphan || !dev_has_sync_state(core->dev))
+		return;
+
+	if (core->flags & CLK_DONT_HOLD_STATE)
+		return;
+
+	core->need_sync = !clk_core_prepare_enable(core);
+}
+
+static void __clk_core_update_orphan_hold_state(struct clk_core *core)
+{
+	struct clk_core *child;
+
+	if (core->orphan)
+		return;
+
+	clk_core_hold_state(core);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		__clk_core_update_orphan_hold_state(child);
+}
+
 /*
  * Update the orphan status of @core and all its children.
  */
@@ -1637,12 +1997,59 @@ static int __clk_speculate_rates(struct clk_core *core,
 	return ret;
 }
 
-static void clk_calc_subtree(struct clk_core *core, unsigned long new_rate,
+/*
+ * Vote for the voltage level required for core->new_rate.  Keep track of all
+ * clocks with a changed voltage level in clk_rate_change_list.
+ */
+static int clk_vote_new_rate_vdd(struct clk_core *core)
+{
+	int cur_level, next_level;
+	int ret;
+
+	if (IS_ERR_OR_NULL(core) || !core->vdd_class)
+		return 0;
+
+	if (!clk_core_is_prepared(core))
+		return 0;
+
+	cur_level = core->new_vdd_class_vote;
+	next_level = clk_find_vdd_level(core, core->new_rate);
+	if (cur_level == next_level)
+		return 0;
+
+	ret = clk_vote_vdd_level(core->vdd_class, next_level);
+	if (ret)
+		return ret;
+
+	core->new_vdd_class_vote = next_level;
+
+	if (list_empty(&core->rate_change_node)) {
+		list_add(&core->rate_change_node, &clk_rate_change_list);
+	} else {
+		/*
+		 * A different new_rate has been determined for a clock that
+		 * was already encountered in the clock tree traversal so the
+		 * level that was previously voted for it should be removed.
+		 */
+		ret = clk_unvote_vdd_level(core->vdd_class, cur_level);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int clk_calc_subtree(struct clk_core *core, unsigned long new_rate,
 			     struct clk_core *new_parent, u8 p_index)
 {
 	struct clk_core *child;
+	int ret;
 
 	core->new_rate = new_rate;
+	ret = clk_vote_new_rate_vdd(core);
+	if (ret)
+		return ret;
+
 	core->new_parent = new_parent;
 	core->new_parent_index = p_index;
 	/* include clk in new parent's PRE_RATE_CHANGE notifications */
@@ -1652,8 +2059,12 @@ static void clk_calc_subtree(struct clk_core *core, unsigned long new_rate,
 
 	hlist_for_each_entry(child, &core->children, child_node) {
 		child->new_rate = clk_recalc(child, new_rate);
-		clk_calc_subtree(child, child->new_rate, NULL, 0);
+		ret = clk_calc_subtree(child, child->new_rate, NULL, 0);
+		if (ret)
+			return ret;
 	}
+
+	return 0;
 }
 
 /*
@@ -1732,12 +2143,23 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *core,
 		}
 	}
 
+	/*
+	 * Certain PLLs only have 16 bits to program the fractional divider.
+	 * Hence the programmed rate might be slightly different than the
+	 * requested one.
+	 */
 	if ((core->flags & CLK_SET_RATE_PARENT) && parent &&
-	    best_parent_rate != parent->rate)
+		(DIV_ROUND_CLOSEST(best_parent_rate, 1000) !=
+			DIV_ROUND_CLOSEST(parent->rate, 1000)))
 		top = clk_calc_new_rates(parent, best_parent_rate);
 
 out:
-	clk_calc_subtree(core, new_rate, parent, p_index);
+	if (!clk_is_rate_level_valid(core, rate))
+		return NULL;
+
+	ret = clk_calc_subtree(core, new_rate, parent, p_index);
+	if (ret)
+		return NULL;
 
 	return top;
 }
@@ -1781,11 +2203,14 @@ static struct clk_core *clk_propagate_rate_change(struct clk_core *core,
 	return fail_clk;
 }
 
+static int clk_core_set_rate_nolock(struct clk_core *core,
+				    unsigned long req_rate);
+
 /*
  * walk down a subtree and set the new rates notifying the rate
  * change on the way
  */
-static void clk_change_rate(struct clk_core *core)
+static int clk_change_rate(struct clk_core *core)
 {
 	struct clk_core *child;
 	struct hlist_node *tmp;
@@ -1794,6 +2219,7 @@ static void clk_change_rate(struct clk_core *core)
 	bool skip_set_rate = false;
 	struct clk_core *old_parent;
 	struct clk_core *parent = NULL;
+	int rc = 0;
 
 	old_rate = core->rate;
 
@@ -1805,8 +2231,9 @@ static void clk_change_rate(struct clk_core *core)
 		best_parent_rate = core->parent->rate;
 	}
 
-	if (clk_pm_runtime_get(core))
-		return;
+	rc = clk_pm_runtime_get(core);
+	if (rc)
+		return rc;
 
 	if (core->flags & CLK_SET_RATE_UNGATE) {
 		unsigned long flags;
@@ -1817,6 +2244,8 @@ static void clk_change_rate(struct clk_core *core)
 		clk_enable_unlock(flags);
 	}
 
+	trace_clk_set_rate(core, core->new_rate);
+
 	if (core->new_parent && core->new_parent != core->parent) {
 		old_parent = __clk_set_parent_before(core, core->new_parent);
 		trace_clk_set_parent(core, core->new_parent);
@@ -1837,10 +2266,14 @@ static void clk_change_rate(struct clk_core *core)
 	if (core->flags & CLK_OPS_PARENT_ENABLE)
 		clk_core_prepare_enable(parent);
 
-	trace_clk_set_rate(core, core->new_rate);
-
-	if (!skip_set_rate && core->ops->set_rate)
-		core->ops->set_rate(core->hw, core->new_rate, best_parent_rate);
+	if (!skip_set_rate && core->ops->set_rate) {
+		rc = core->ops->set_rate(core->hw, core->new_rate,
+						best_parent_rate);
+		if (rc) {
+			trace_clk_set_rate_complete(core, core->new_rate);
+			goto err_set_rate;
+		}
+	}
 
 	trace_clk_set_rate_complete(core, core->new_rate);
 
@@ -1872,14 +2305,24 @@ static void clk_change_rate(struct clk_core *core)
 		/* Skip children who will be reparented to another clock */
 		if (child->new_parent && child->new_parent != core)
 			continue;
-		clk_change_rate(child);
+		rc = clk_change_rate(child);
+		if (rc)
+			goto err_set_rate;
 	}
 
 	/* handle the new child who might not be in core->children yet */
 	if (core->new_child)
-		clk_change_rate(core->new_child);
+		rc = clk_change_rate(core->new_child);
 
+	/* handle a changed clock that needs to readjust its rate */
+	if (core->flags & CLK_KEEP_REQ_RATE && core->req_rate
+					    && core->new_rate != old_rate
+					    && core->new_rate != core->req_rate)
+		clk_core_set_rate_nolock(core, core->req_rate);
+
+err_set_rate:
 	clk_pm_runtime_put(core);
+	return rc;
 }
 
 static unsigned long clk_core_req_round_rate_nolock(struct clk_core *core,
@@ -1909,12 +2352,85 @@ static unsigned long clk_core_req_round_rate_nolock(struct clk_core *core,
 	return ret ? 0 : req.rate;
 }
 
+/*
+ * Unvote for the voltage level required for each core->new_vdd_class_vote in
+ * clk_rate_change_list.  This is used when undoing voltage requests after an
+ * error is encountered before any physical rate changing.
+ */
+static void clk_unvote_new_rate_vdd(void)
+{
+	struct clk_core *core;
+
+	list_for_each_entry(core, &clk_rate_change_list, rate_change_node) {
+		clk_unvote_vdd_level(core->vdd_class, core->new_vdd_class_vote);
+		core->new_vdd_class_vote = core->vdd_class_vote;
+	}
+}
+
+/*
+ * Unvote for the voltage level required for each core->vdd_class_vote in
+ * clk_rate_change_list.
+ */
+static int clk_unvote_old_rate_vdd(void)
+{
+	struct clk_core *core;
+	int ret;
+
+	list_for_each_entry(core, &clk_rate_change_list, rate_change_node) {
+		ret = clk_unvote_vdd_level(core->vdd_class,
+					   core->vdd_class_vote);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * In the case that rate setting fails, apply the max voltage level needed
+ * by either the old or new rate for each changed clock.
+ */
+static void clk_vote_safe_vdd(void)
+{
+	struct clk_core *core;
+
+	list_for_each_entry(core, &clk_rate_change_list, rate_change_node) {
+		if (core->vdd_class_vote > core->new_vdd_class_vote) {
+			clk_vote_vdd_level(core->vdd_class,
+						core->vdd_class_vote);
+			clk_unvote_vdd_level(core->vdd_class,
+						core->new_vdd_class_vote);
+			core->new_vdd_class_vote = core->vdd_class_vote;
+		}
+	}
+}
+
+static void clk_cleanup_vdd_votes(void)
+{
+	struct clk_core *core, *temp;
+
+	list_for_each_entry_safe(core, temp, &clk_rate_change_list,
+				 rate_change_node) {
+		core->vdd_class_vote = core->new_vdd_class_vote;
+		list_del_init(&core->rate_change_node);
+	}
+}
+
 static int clk_core_set_rate_nolock(struct clk_core *core,
 				    unsigned long req_rate)
 {
 	struct clk_core *top, *fail_clk;
 	unsigned long rate;
 	int ret = 0;
+	/*
+	 * The prepare lock ensures mutual exclusion with other tasks.
+	 * set_rate_nesting_count is a static so that it can be incremented in
+	 * the case of reentrancy caused by a set_rate() ops callback itself
+	 * calling clk_set_rate().  That way, the voltage level votes for the
+	 * old rates are safely removed when the original invocation of this
+	 * function completes.
+	 */
+	static unsigned int set_rate_nesting_count;
 
 	if (!core)
 		return 0;
@@ -1929,32 +2445,64 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 	if (clk_core_rate_is_protected(core))
 		return -EBUSY;
 
+	set_rate_nesting_count++;
+
 	/* calculate new rates and get the topmost changed clock */
 	top = clk_calc_new_rates(core, req_rate);
-	if (!top)
-		return -EINVAL;
+	if (!top) {
+		ret = -EINVAL;
+		goto pre_rate_change_err;
+	}
 
 	ret = clk_pm_runtime_get(core);
 	if (ret)
-		return ret;
+		goto pre_rate_change_err;
 
 	/* notify that we are about to change rates */
 	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
 	if (fail_clk) {
-		pr_debug("%s: failed to set %s rate\n", __func__,
-				fail_clk->name);
+		pr_debug("%s: failed to set %s clock to run at %lu\n", __func__,
+				fail_clk->name, req_rate);
 		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
 		ret = -EBUSY;
-		goto err;
+		clk_pm_runtime_put(core);
+		goto pre_rate_change_err;
 	}
 
+	core->req_rate = req_rate;
+
 	/* change the rates */
-	clk_change_rate(top);
+	ret = clk_change_rate(top);
+	set_rate_nesting_count--;
+	if (ret) {
+		pr_err("%s: failed to set %s clock to run at %lu\n", __func__,
+				top->name, req_rate);
+		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
+		clk_vote_safe_vdd();
+		goto post_rate_change_err;
+	}
+
+post_rate_change_err:
+	/*
+	 * Only remove vdd_class level votes for old clock rates after all
+	 * nested clk_set_rate() calls have completed.
+	 */
+	if (set_rate_nesting_count == 0) {
+		ret |= clk_unvote_old_rate_vdd();
+		clk_cleanup_vdd_votes();
+	}
 
-	core->req_rate = req_rate;
-err:
 	clk_pm_runtime_put(core);
 
+	return ret;
+
+pre_rate_change_err:
+	set_rate_nesting_count--;
+	if (set_rate_nesting_count == 0) {
+		clk_unvote_new_rate_vdd();
+		clk_cleanup_vdd_votes();
+	}
+
 	return ret;
 }
 
@@ -2249,7 +2797,7 @@ static int clk_core_set_parent_nolock(struct clk_core *core,
 	if (!core)
 		return 0;
 
-	if (core->parent == parent)
+	if (core->parent == parent && !(core->flags & CLK_IS_MEASURE))
 		return 0;
 
 	/* verify ops for for multi-parent clks */
@@ -2638,9 +3186,26 @@ bool clk_is_match(const struct clk *p, const struct clk *q)
 }
 EXPORT_SYMBOL_GPL(clk_is_match);
 
+int clk_set_flags(struct clk *clk, unsigned long flags)
+{
+	if (!clk)
+		return 0;
+
+	if (!clk->core->ops->set_flags)
+		return -EINVAL;
+
+	return clk->core->ops->set_flags(clk->core->hw, flags);
+}
+EXPORT_SYMBOL_GPL(clk_set_flags);
+
+void clk_debug_print_hw(struct clk_core *clk, struct seq_file *f)
+{
+}
+EXPORT_SYMBOL(clk_debug_print_hw);
+
 /***        debugfs support        ***/
 
-#ifdef CONFIG_DEBUG_FS
+#ifdef CONFIG_COMMON_CLK_DEBUGFS
 #include <linux/debugfs.h>
 
 static struct dentry *rootdir;
@@ -2780,6 +3345,8 @@ static const struct {
 	ENTRY(CLK_IS_CRITICAL),
 	ENTRY(CLK_OPS_PARENT_ENABLE),
 	ENTRY(CLK_DUTY_CYCLE_PARENT),
+	ENTRY(CLK_DONT_HOLD_STATE),
+	ENTRY(CLK_KEEP_REQ_RATE),
 #undef ENTRY
 };
 
@@ -2829,6 +3396,211 @@ static int clk_duty_cycle_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(clk_duty_cycle);
 
+static int clock_debug_rate_set(void *data, u64 val)
+{
+	struct clk_core *core = data;
+	int ret;
+
+	ret = clk_set_rate(core->hw->clk, val);
+	if (ret)
+		pr_err("clk_set_rate(%lu) failed (%d)\n",
+		       (unsigned long)val, ret);
+
+	return ret;
+}
+
+static int clock_debug_rate_get(void *data, u64 *val)
+{
+	struct clk_core *core = data;
+
+	*val = core->hw->core->rate;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(clock_rate_fops, clock_debug_rate_get,
+			clock_debug_rate_set, "%llu\n");
+
+static int clock_available_parent_show(struct seq_file *s, void *data)
+{
+	struct clk_core *core = (struct clk_core *)s->private;
+	int i;
+
+	for (i = 0; i < core->num_parents; i++) {
+		if (!core->parents[i])
+			continue;
+		seq_printf(s, "%s ", core->parents[i]->name);
+	}
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static int clock_available_parent_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clock_available_parent_show, inode->i_private);
+}
+
+static const struct file_operations clock_available_parent_fops = {
+	.open		= clock_available_parent_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t clock_parent_read(struct file *filp, char __user *ubuf,
+				 size_t cnt, loff_t *ppos)
+{
+	char name[256] = {0};
+	struct clk_core *core = filp->private_data;
+	struct clk_core *p = core->parent;
+
+	snprintf(name, sizeof(name), "%s\n", p ? p->name : "None\n");
+
+	return simple_read_from_buffer(ubuf, cnt, ppos, name, strlen(name));
+}
+
+static ssize_t clock_parent_write(struct file *filp, const char __user *buf,
+				  size_t cnt, loff_t *ppos)
+{
+	char temp[256] = {0};
+	char name[256] = {0};
+	struct clk_core *core = filp->private_data;
+	unsigned int ret, i;
+
+	if (copy_from_user(temp, buf, cnt))
+		return -EINVAL;
+
+	ret = sscanf(temp, "%s", name);
+	if (ret != 1)
+		return -EINVAL;
+
+	for (i = 0; i < core->num_parents; i++) {
+		if (!core->parents[i])
+			continue;
+		if (!strcmp(core->parents[i]->name, name)) {
+			if (core->parents[i] != core->parent)
+				clk_core_set_parent_nolock(core,
+							   core->parents[i]);
+			break;
+		}
+	}
+
+	return cnt;
+}
+
+static const struct file_operations clock_parent_fops = {
+	.open	= simple_open,
+	.read	= clock_parent_read,
+	.write	= clock_parent_write,
+};
+
+static int clock_debug_enable_set(void *data, u64 val)
+{
+	struct clk_core *core = data;
+	int rc = 0;
+
+	if (val)
+		rc = clk_prepare_enable(core->hw->clk);
+	else
+		clk_disable_unprepare(core->hw->clk);
+
+	return rc;
+}
+
+static int clock_debug_enable_get(void *data, u64 *val)
+{
+	struct clk_core *core = data;
+	int enabled = 0;
+
+	enabled = core->enable_count;
+
+	*val = enabled;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(clock_enable_fops, clock_debug_enable_get,
+			 clock_debug_enable_set, "%lld\n");
+
+#define clock_debug_output(m, c, fmt, ...)		\
+do {							\
+	if (m)						\
+		seq_printf(m, fmt, ##__VA_ARGS__);	\
+	else if (c)					\
+		pr_cont(fmt, ##__VA_ARGS__);		\
+	else						\
+		pr_info(fmt, ##__VA_ARGS__);		\
+} while (0)
+
+static int clock_debug_print_clock(struct clk_core *c, struct seq_file *s)
+{
+	char *start = "";
+	struct clk *clk;
+
+	if (!c || !c->prepare_count)
+		return 0;
+
+	clk = c->hw->clk;
+
+	clock_debug_output(s, 0, "\t");
+
+	do {
+		clock_debug_output(s, 1, "%s%s:%u:%u [%ld]", start,
+				   clk->core->name,
+				   clk->core->prepare_count,
+				   clk->core->enable_count,
+				   clk->core->rate);
+		start = " -> ";
+	} while ((clk = clk_get_parent(clk)));
+
+	clock_debug_output(s, 1, "\n");
+
+	return 1;
+}
+
+/*
+ * clock_debug_print_enabled_clocks() - Print names of enabled clocks
+ */
+static void clock_debug_print_enabled_clocks(struct seq_file *s)
+{
+	struct clk_core *core;
+	int cnt = 0;
+
+	clock_debug_output(s, 0, "Enabled clocks:\n");
+
+	mutex_lock(&clk_debug_lock);
+
+	hlist_for_each_entry(core, &clk_debug_list, debug_node)
+		cnt += clock_debug_print_clock(core, s);
+
+	mutex_unlock(&clk_debug_lock);
+
+	if (cnt)
+		clock_debug_output(s, 0, "Enabled clock count: %d\n", cnt);
+	else
+		clock_debug_output(s, 0, "No clocks enabled.\n");
+}
+
+static int enabled_clocks_show(struct seq_file *s, void *unused)
+{
+	clock_debug_print_enabled_clocks(s);
+
+	return 0;
+}
+
+static int enabled_clocks_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, enabled_clocks_show, inode->i_private);
+}
+
+static const struct file_operations clk_enabled_list_fops = {
+	.open		= enabled_clocks_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
 static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *root;
@@ -2839,16 +3611,22 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	root = debugfs_create_dir(core->name, pdentry);
 	core->dentry = root;
 
-	debugfs_create_ulong("clk_rate", 0444, root, &core->rate);
+	debugfs_create_file("clk_rate", 0444, root, core,
+			    &clock_rate_fops);
 	debugfs_create_ulong("clk_accuracy", 0444, root, &core->accuracy);
 	debugfs_create_u32("clk_phase", 0444, root, &core->phase);
 	debugfs_create_file("clk_flags", 0444, root, core, &clk_flags_fops);
 	debugfs_create_u32("clk_prepare_count", 0444, root, &core->prepare_count);
-	debugfs_create_u32("clk_enable_count", 0444, root, &core->enable_count);
+	debugfs_create_file("clk_enable_count", 0444, root, core,
+			    &clock_enable_fops);
 	debugfs_create_u32("clk_protect_count", 0444, root, &core->protect_count);
 	debugfs_create_u32("clk_notifier_count", 0444, root, &core->notifier_count);
 	debugfs_create_file("clk_duty_cycle", 0444, root, core,
 			    &clk_duty_cycle_fops);
+	debugfs_create_file("clk_available_parent", 0444, root, core,
+			    &clock_available_parent_fops);
+	debugfs_create_file("clk_parent", 0444, root, core,
+			    &clock_parent_fops);
 
 	if (core->num_parents > 1)
 		debugfs_create_file("clk_possible_parents", 0444, root, core,
@@ -2916,6 +3694,9 @@ static int __init clk_debug_init(void)
 	debugfs_create_file("clk_orphan_dump", 0444, rootdir, &orphan_list,
 			    &clk_dump_fops);
 
+	debugfs_create_file("clk_enabled_list", 0444, rootdir,
+			    &clk_debug_list, &clk_enabled_list_fops);
+
 	mutex_lock(&clk_debug_lock);
 	hlist_for_each_entry(core, &clk_debug_list, debug_node)
 		clk_debug_create_one(core, rootdir);
@@ -3086,6 +3867,8 @@ static int __clk_core_init(struct clk_core *core)
 		rate = 0;
 	core->rate = core->req_rate = rate;
 
+	core->boot_enabled = clk_core_is_enabled(core);
+
 	/*
 	 * Enable CLK_IS_CRITICAL clocks so newly added critical clocks
 	 * don't get accidentally disabled when walking the orphan tree and
@@ -3094,19 +3877,15 @@ static int __clk_core_init(struct clk_core *core)
 	if (core->flags & CLK_IS_CRITICAL) {
 		unsigned long flags;
 
-		ret = clk_core_prepare(core);
-		if (ret)
-			goto out;
+		clk_core_prepare(core);
 
 		flags = clk_enable_lock();
-		ret = clk_core_enable(core);
+		clk_core_enable(core);
 		clk_enable_unlock(flags);
-		if (ret) {
-			clk_core_unprepare(core);
-			goto out;
-		}
 	}
 
+	clk_core_hold_state(core);
+
 	/*
 	 * walk the list of orphan clocks and reparent any that newly finds a
 	 * parent.
@@ -3126,6 +3905,59 @@ static int __clk_core_init(struct clk_core *core)
 			__clk_set_parent_after(orphan, parent, NULL);
 			__clk_recalc_accuracies(orphan);
 			__clk_recalc_rates(orphan, 0);
+			__clk_core_update_orphan_hold_state(orphan);
+		}
+	}
+
+	/*
+	 * optional platform-specific magic
+	 *
+	 * The .init callback is not used by any of the basic clock types, but
+	 * exists for weird hardware that must perform initialization magic.
+	 * Please consider other ways of solving initialization problems before
+	 * using this callback, as its use is discouraged.
+	 */
+	if (core->ops->init)
+		core->ops->init(core->hw);
+
+	if (core->flags & CLK_IS_CRITICAL) {
+		unsigned long flags;
+
+		clk_core_prepare(core);
+
+		flags = clk_enable_lock();
+		clk_core_enable(core);
+		clk_enable_unlock(flags);
+	}
+
+	/*
+	 * enable clocks with the CLK_ENABLE_HAND_OFF flag set
+	 *
+	 * This flag causes the framework to enable the clock at registration
+	 * time, which is sometimes necessary for clocks that would cause a
+	 * system crash when gated (e.g. cpu, memory, etc). The prepare_count
+	 * is migrated over to the first clk consumer to call clk_prepare().
+	 * Similarly the clk's enable_count is migrated to the first consumer
+	 * to call clk_enable().
+	 */
+	if (core->flags & CLK_ENABLE_HAND_OFF) {
+		unsigned long flags;
+
+		/*
+		 * Few clocks might have hardware gating which would be
+		 * required to be ON before prepare/enabling the clocks. So
+		 * check if the clock has been turned ON earlier and we should
+		 * prepare/enable those clocks.
+		 */
+		if (clk_core_is_enabled(core)) {
+			core->need_handoff_prepare = true;
+			core->need_handoff_enable = true;
+			ret = clk_core_prepare(core);
+			if (ret)
+				goto out;
+			flags = clk_enable_lock();
+			clk_core_enable(core);
+			clk_enable_unlock(flags);
 		}
 	}
 
@@ -3144,15 +3976,11 @@ static int __clk_core_init(struct clk_core *core)
 	return ret;
 }
 
-struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
-			     const char *con_id)
+static struct clk *clk_hw_create_clk(struct clk_hw *hw, const char *dev_id,
+				     const char *con_id)
 {
 	struct clk *clk;
 
-	/* This is to allow this function to be chained to others */
-	if (IS_ERR_OR_NULL(hw))
-		return ERR_CAST(hw);
-
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 	if (!clk)
 		return ERR_PTR(-ENOMEM);
@@ -3169,7 +3997,19 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 	return clk;
 }
 
-/* keep in sync with __clk_put */
+struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
+			     const char *con_id, bool with_orphans)
+{
+	/* This is to allow this function to be chained to others */
+	if (!hw || IS_ERR(hw))
+		return (struct clk *) hw;
+
+	if (hw->core->orphan && !with_orphans)
+		return ERR_PTR(-EPROBE_DEFER);
+
+	return clk_hw_create_clk(hw, dev_id, con_id);
+}
+
 void __clk_free_clk(struct clk *clk)
 {
 	clk_prepare_lock();
@@ -3215,7 +4055,8 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	core->ops = hw->init->ops;
 
 	if (dev && pm_runtime_enabled(dev))
-		core->dev = dev;
+		core->rpm_enabled = true;
+	core->dev = dev;
 	if (dev && dev->driver)
 		core->owner = dev->driver->owner;
 	core->hw = hw;
@@ -3223,6 +4064,9 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	core->num_parents = hw->init->num_parents;
 	core->min_rate = 0;
 	core->max_rate = ULONG_MAX;
+	core->vdd_class = hw->init->vdd_class;
+	core->rate_max = hw->init->rate_max;
+	core->num_rate_max = hw->init->num_rate_max;
 	hw->core = core;
 
 	/* allocate local copy in case parent_names is __initdata */
@@ -3254,8 +4098,9 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	};
 
 	INIT_HLIST_HEAD(&core->clks);
+	INIT_LIST_HEAD(&core->rate_change_node);
 
-	hw->clk = __clk_create_clk(hw, NULL, NULL);
+	hw->clk = clk_hw_create_clk(hw, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
 		ret = PTR_ERR(hw->clk);
 		goto fail_parents;
@@ -3456,6 +4301,166 @@ static void devm_clk_hw_release(struct device *dev, void *res)
 	clk_hw_unregister(*(struct clk_hw **)res);
 }
 
+#define MAX_LEN_OPP_HANDLE	50
+#define LEN_OPP_HANDLE		16
+
+static int derive_device_list(struct device **device_list,
+				struct clk_core *core,
+				struct device_node *np,
+				char *clk_handle_name, int count)
+{
+	int j;
+	struct platform_device *pdev;
+	struct device_node *dev_node;
+
+	for (j = 0; j < count; j++) {
+		device_list[j] = NULL;
+		dev_node = of_parse_phandle(np, clk_handle_name, j);
+		if (!dev_node) {
+			pr_err("Unable to get device_node pointer for %s opp-handle (%s)\n",
+					core->name, clk_handle_name);
+			return -ENODEV;
+		}
+
+		pdev = of_find_device_by_node(dev_node);
+		if (!pdev) {
+			pr_err("Unable to find platform_device node for %s opp-handle\n",
+						core->name);
+			return -ENODEV;
+		}
+		device_list[j] = &pdev->dev;
+	}
+	return 0;
+}
+
+static int clk_get_voltage(struct clk_core *core, unsigned long rate, int n)
+{
+	struct clk_vdd_class *vdd;
+	int level, corner;
+
+	/* Use the first regulator in the vdd class for the OPP table. */
+	vdd = core->vdd_class;
+	if (vdd->num_regulators > 1) {
+		corner = vdd->vdd_uv[vdd->num_regulators * n];
+	} else {
+		level = clk_find_vdd_level(core, rate);
+		if (level < 0) {
+			pr_err("Could not find vdd level\n");
+			return -EINVAL;
+		}
+		corner = vdd->vdd_uv[level];
+	}
+
+	if (!corner) {
+		pr_err("%s: Unable to find vdd level for rate %lu\n",
+					core->name, rate);
+		return -EINVAL;
+	}
+
+	return corner;
+}
+
+static int clk_add_and_print_opp(struct clk_hw *hw,
+				struct device **device_list, int count,
+				unsigned long rate, int uv, int n)
+{
+	struct clk_core *core = hw->core;
+	int j, ret = 0;
+
+	for (j = 0; j < count; j++) {
+		ret = dev_pm_opp_add(device_list[j], rate, uv);
+		if (ret) {
+			pr_err("%s: couldn't add OPP for %lu - err: %d\n",
+						core->name, rate, ret);
+			return ret;
+		}
+
+		if (n == 0 || n == core->num_rate_max - 1 ||
+					rate == clk_hw_round_rate(hw, INT_MAX))
+			pr_info("%s: set OPP pair(%lu Hz: %u uV) on %s\n",
+						core->name, rate, uv,
+						dev_name(device_list[j]));
+	}
+	return ret;
+}
+
+static void clk_populate_clock_opp_table(struct device_node *np,
+						struct clk_hw *hw)
+{
+	struct device **device_list;
+	struct clk_core *core = hw->core;
+	char clk_handle_name[MAX_LEN_OPP_HANDLE];
+	int n, len, count, uv, ret;
+	unsigned long rate = 0, rrate = 0;
+
+	if (!core || !core->num_rate_max)
+		return;
+
+	if (strlen(core->name) + LEN_OPP_HANDLE < MAX_LEN_OPP_HANDLE) {
+		ret = snprintf(clk_handle_name, ARRAY_SIZE(clk_handle_name),
+				"qcom,%s-opp-handle", core->name);
+		if (ret < strlen(core->name) + LEN_OPP_HANDLE) {
+			pr_err("%s: Failed to hold clk_handle_name\n",
+							core->name);
+			return;
+		}
+	} else {
+		pr_err("clk name (%s) too large to fit in clk_handle_name\n",
+							core->name);
+		return;
+	}
+
+	if (of_find_property(np, clk_handle_name, &len)) {
+		count = len/sizeof(u32);
+
+		device_list = kmalloc_array(count, sizeof(struct device *),
+							GFP_KERNEL);
+		if (!device_list)
+			return;
+
+		ret = derive_device_list(device_list, core, np,
+					clk_handle_name, count);
+		if (ret < 0) {
+			pr_err("Failed to fill device_list for %s\n",
+						clk_handle_name);
+			goto err_derive_device_list;
+		}
+	} else {
+		pr_debug("Unable to find %s\n", clk_handle_name);
+		return;
+	}
+
+	for (n = 0; ; n++) {
+		rrate = clk_hw_round_rate(hw, rate + 1);
+		if (!rrate) {
+			pr_err("clk_round_rate failed for %s\n",
+							core->name);
+			goto err_derive_device_list;
+		}
+
+		/*
+		 * If clk_hw_round_rate gives the same value on consecutive
+		 * iterations, exit the loop since we're at the maximum clock
+		 * frequency.
+		 */
+		if (rate == rrate)
+			break;
+		rate = rrate;
+
+		uv = clk_get_voltage(core, rate, n);
+		if (uv < 0)
+			goto err_derive_device_list;
+
+		ret = clk_add_and_print_opp(hw, device_list, count,
+							rate, uv, n);
+		if (ret)
+			goto err_derive_device_list;
+	}
+
+err_derive_device_list:
+	kfree(device_list);
+}
+
 /**
  * devm_clk_register - resource managed clk_register()
  * @dev: device that is registering this clock
@@ -3482,6 +4487,7 @@ struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw)
 		devres_free(clkp);
 	}
 
+	clk_populate_clock_opp_table(dev->of_node, hw);
 	return clk;
 }
 EXPORT_SYMBOL_GPL(devm_clk_register);
@@ -3512,6 +4518,7 @@ int devm_clk_hw_register(struct device *dev, struct clk_hw *hw)
 		devres_free(hwp);
 	}
 
+	clk_populate_clock_opp_table(dev->of_node, hw);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(devm_clk_hw_register);
@@ -3944,7 +4951,8 @@ __of_clk_get_hw_from_provider(struct of_clk_provider *provider,
 }
 
 struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
-				       const char *dev_id, const char *con_id)
+				       const char *dev_id, const char *con_id,
+				       bool with_orphans)
 {
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
@@ -3958,7 +4966,8 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np) {
 			hw = __of_clk_get_hw_from_provider(provider, clkspec);
-			clk = __clk_create_clk(hw, dev_id, con_id);
+			clk = __clk_create_clk(hw, dev_id, con_id,
+					       with_orphans);
 		}
 
 		if (!IS_ERR(clk)) {
@@ -3985,7 +4994,25 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
  */
 struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
-	return __of_clk_get_from_provider(clkspec, NULL, __func__);
+	return __of_clk_get_from_provider(clkspec, NULL, __func__, false);
+}
+
+/**
+ * of_clk_get_from_provider_with_orphans() - Lookup clock from a clock provider
+ * @clkspec: pointer to a clock specifier data structure
+ *
+ * This function looks up a struct clk from the registered list of clock
+ * providers, an input is a clock specifier data structure as returned
+ * from the of_parse_phandle_with_args() function call.
+ *
+ * The difference to of_clk_get_from_provider() is that this function will
+ * also successfully lookup orphan-clocks, as it in some cases may be
+ * necessary to access such orphan-clocks as well.
+ */
+struct clk *
+of_clk_get_from_provider_with_orphans(struct of_phandle_args *clkspec)
+{
+	return __of_clk_get_from_provider(clkspec, NULL, __func__, true);
 }
 EXPORT_SYMBOL_GPL(of_clk_get_from_provider);
 
@@ -4239,3 +5266,273 @@ void __init of_clk_init(const struct of_device_id *matches)
 	}
 }
 #endif
+
+#ifdef CONFIG_COMMON_CLK_PROCFS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static int clk_rate_show(struct seq_file *s, void *v)
+{
+	seq_puts(s, "set clk rate:\n");
+	seq_puts(s, "	echo [clk_name] [rate(Hz)] > /proc/clk/rate\n");
+
+	return 0;
+}
+
+static int clk_rate_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_rate_show, NULL);
+}
+
+static ssize_t clk_rate_write(struct file *filp, const char __user *buf,
+			      size_t cnt, loff_t *ppos)
+{
+	char clk_name[40], input[55];
+	struct clk_core *core;
+	int argc, ret, val;
+
+	if (cnt >= sizeof(input))
+		return -EINVAL;
+
+	if (copy_from_user(input, buf, cnt))
+		return -EFAULT;
+
+	input[cnt] = '\0';
+
+	argc = sscanf(input, "%38s %10d", clk_name, &val);
+	if (argc != 2)
+		return -EINVAL;
+
+	core = clk_core_lookup(clk_name);
+	if (IS_ERR_OR_NULL(core)) {
+		pr_err("get %s error\n", clk_name);
+		return -EINVAL;
+	}
+
+	clk_prepare_lock();
+	ret = clk_core_set_rate_nolock(core, val);
+	clk_prepare_unlock();
+	if (ret) {
+		pr_err("set %s rate %d error\n", clk_name, val);
+		return ret;
+	}
+
+	return cnt;
+}
+
+static const struct file_operations clk_rate_fops = {
+	.open		= clk_rate_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= clk_rate_write,
+};
+
+static int clk_enable_show(struct seq_file *s, void *v)
+{
+	seq_puts(s, "enable clk:\n");
+	seq_puts(s, "	echo enable [clk_name] > /proc/clk/enable\n");
+	seq_puts(s, "disable clk:\n");
+	seq_puts(s, "	echo disable [clk_name] > /proc/clk/enable\n");
+
+	return 0;
+}
+
+static int clk_enable_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_enable_show, NULL);
+}
+
+static ssize_t clk_enable_write(struct file *filp, const char __user *buf,
+				size_t cnt, loff_t *ppos)
+{
+	char cmd[10], clk_name[40], input[50];
+	struct clk_core *core;
+	int argc, ret;
+
+	if (cnt >= sizeof(input))
+		return -EINVAL;
+
+	if (copy_from_user(input, buf, cnt))
+		return -EFAULT;
+
+	input[cnt] = '\0';
+
+	argc = sscanf(input, "%8s %38s", cmd, clk_name);
+	if (argc != 2)
+		return -EINVAL;
+
+	core = clk_core_lookup(clk_name);
+	if (IS_ERR_OR_NULL(core)) {
+		pr_err("get %s error\n", clk_name);
+		return -EINVAL;
+	}
+
+	if (!strncmp(cmd, "enable", strlen("enable"))) {
+		ret = clk_core_prepare_enable(core);
+		if (ret)
+			pr_err("enable %s err\n", clk_name);
+	} else if (!strncmp(cmd, "disable", strlen("disable"))) {
+		clk_core_disable_unprepare(core);
+	} else {
+		pr_err("unsupported cmd(%s)\n", cmd);
+	}
+
+	return cnt;
+}
+
+static const struct file_operations clk_enable_fops = {
+	.open		= clk_enable_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= clk_enable_write,
+};
+
+static int clk_parent_show(struct seq_file *s, void *v)
+{
+	seq_puts(s, "echo [clk_name] [parent_name] > /proc/clk/parent\n");
+
+	return 0;
+}
+
+static int clk_parent_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_parent_show, NULL);
+}
+
+static ssize_t clk_parent_write(struct file *filp, const char __user *buf,
+				size_t cnt, loff_t *ppos)
+{
+	char clk_name[40], p_name[40];
+	char input[80];
+	struct clk_core *core, *p;
+	int argc, ret;
+
+	if (cnt >= sizeof(input))
+		return -EINVAL;
+
+	if (copy_from_user(input, buf, cnt))
+		return -EFAULT;
+
+	input[cnt] = '\0';
+
+	argc = sscanf(input, "%38s %38s", clk_name, p_name);
+	if (argc != 2)
+		return -EINVAL;
+
+	core = clk_core_lookup(clk_name);
+	if (IS_ERR_OR_NULL(core)) {
+		pr_err("get %s error\n", clk_name);
+		return -EINVAL;
+	}
+	p = clk_core_lookup(p_name);
+	if (IS_ERR_OR_NULL(p)) {
+		pr_err("get %s error\n", p_name);
+		return -EINVAL;
+	}
+	clk_prepare_lock();
+	ret = clk_core_set_parent_nolock(core, p);
+	clk_prepare_unlock();
+	if (ret < 0)
+		pr_err("set clk(%s)'s parent(%s) error\n", clk_name, p_name);
+
+	return cnt;
+}
+
+static const struct file_operations clk_parent_fops = {
+	.open		= clk_parent_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= clk_parent_write,
+};
+
+static void clk_proc_summary_show_one(struct seq_file *s, struct clk_core *c,
+				      int level)
+{
+	if (!c)
+		return;
+
+	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu %5d %6d\n",
+		   level * 3 + 1, "",
+		   30 - level * 3, c->name,
+		   c->enable_count, c->prepare_count, c->protect_count,
+		   clk_core_get_rate(c), clk_core_get_accuracy(c),
+		   clk_core_get_phase(c),
+		   clk_core_get_scaled_duty_cycle(c, 100000));
+}
+
+static void clk_proc_summary_show_subtree(struct seq_file *s,
+					  struct clk_core *c, int level)
+{
+	struct clk_core *child;
+
+	if (!c)
+		return;
+
+	clk_proc_summary_show_one(s, c, level);
+
+	hlist_for_each_entry(child, &c->children, child_node)
+		clk_proc_summary_show_subtree(s, child, level + 1);
+}
+
+static int clk_proc_summary_show(struct seq_file *s, void *v)
+{
+	struct clk_core *c;
+	struct hlist_head *all_lists[] = {
+		&clk_root_list,
+		&clk_orphan_list,
+		NULL,
+	};
+	struct hlist_head **lists = all_lists;
+
+	seq_puts(s, "                                 enable  prepare  protect                                duty\n");
+	seq_puts(s, "   clock                          count    count    count        rate   accuracy phase  cycle\n");
+	seq_puts(s, "---------------------------------------------------------------------------------------------\n");
+
+	clk_prepare_lock();
+
+	for (; *lists; lists++)
+		hlist_for_each_entry(c, *lists, child_node)
+			clk_proc_summary_show_subtree(s, c, 0);
+
+	clk_prepare_unlock();
+
+	return 0;
+}
+
+static int __init clk_create_procfs(void)
+{
+	struct proc_dir_entry *proc_clk_root;
+	struct proc_dir_entry *ent;
+
+	proc_clk_root = proc_mkdir("clk", NULL);
+	if (!proc_clk_root)
+		return -EINVAL;
+
+	ent = proc_create("rate", 0644, proc_clk_root, &clk_rate_fops);
+	if (!ent)
+		goto fail;
+
+	ent = proc_create("enable", 0644, proc_clk_root, &clk_enable_fops);
+	if (!ent)
+		goto fail;
+
+	ent = proc_create("parent", 0644, proc_clk_root, &clk_parent_fops);
+	if (!ent)
+		goto fail;
+
+	ent = proc_create_single("summary", 0444, proc_clk_root,
+				 clk_proc_summary_show);
+	if (!ent)
+		goto fail;
+
+	return 0;
+
+fail:
+	proc_remove(proc_clk_root);
+	return -EINVAL;
+}
+late_initcall_sync(clk_create_procfs);
+#endif
diff --git a/drivers/clk/clk.h b/drivers/clk/clk.h
index 70c0ba633..6aea188e3 100644
--- a/drivers/clk/clk.h
+++ b/drivers/clk/clk.h
@@ -13,19 +13,23 @@ struct clk_hw;
 
 #if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
 struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
-				       const char *dev_id, const char *con_id);
+				       const char *dev_id, const char *con_id,
+				       bool with_orphans);
+struct clk *
+of_clk_get_from_provider_with_orphans(struct of_phandle_args *clkspec);
 #endif
 
 #ifdef CONFIG_COMMON_CLK
 struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
-			     const char *con_id);
+			     const char *con_id, bool with_orphans);
 void __clk_free_clk(struct clk *clk);
 int __clk_get(struct clk *clk);
 void __clk_put(struct clk *clk);
 #else
 /* All these casts to avoid ifdefs in clkdev... */
 static inline struct clk *
-__clk_create_clk(struct clk_hw *hw, const char *dev_id, const char *con_id)
+__clk_create_clk(struct clk_hw *hw, const char *dev_id, const char *con_id,
+		 bool with_orphans)
 {
 	return (struct clk *)hw;
 }
diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 9ab3db8b3..063ffc637 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -40,7 +40,7 @@ static struct clk *__of_clk_get(struct device_node *np, int index,
 	if (rc)
 		return ERR_PTR(rc);
 
-	clk = __of_clk_get_from_provider(&clkspec, dev_id, con_id);
+	clk = __of_clk_get_from_provider(&clkspec, dev_id, con_id, true);
 	of_node_put(clkspec.np);
 
 	return clk;
@@ -174,7 +174,7 @@ struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 	if (!cl)
 		goto out;
 
-	clk = __clk_create_clk(cl->clk_hw, dev_id, con_id);
+	clk = __clk_create_clk(cl->clk_hw, dev_id, con_id, false);
 	if (IS_ERR(clk))
 		goto out;
 
diff --git a/drivers/clk/rockchip/Makefile b/drivers/clk/rockchip/Makefile
index ff35ab463..43877d059 100644
--- a/drivers/clk/rockchip/Makefile
+++ b/drivers/clk/rockchip/Makefile
@@ -7,19 +7,14 @@ obj-y	+= clk.o
 obj-y	+= clk-pll.o
 obj-y	+= clk-cpu.o
 obj-y	+= clk-half-divider.o
-obj-y	+= clk-inverter.o
 obj-y	+= clk-mmc-phase.o
 obj-y	+= clk-muxgrf.o
 obj-y	+= clk-ddr.o
+obj-$(CONFIG_ROCKCHIP_CLK_INV)	+= clk-inverter.o
+obj-$(CONFIG_ROCKCHIP_CLK_PVTM)	+= clk-pvtm.o
+obj-$(CONFIG_ROCKCHIP_DCLK_DIV)	+= clk-dclk-divider.o
 obj-$(CONFIG_RESET_CONTROLLER)	+= softrst.o
 
-obj-y	+= clk-px30.o
-obj-y	+= clk-rv1108.o
-obj-y	+= clk-rk3036.o
-obj-y	+= clk-rk3128.o
-obj-y	+= clk-rk3188.o
-obj-y	+= clk-rk3228.o
-obj-y	+= clk-rk3288.o
-obj-y	+= clk-rk3328.o
-obj-y	+= clk-rk3368.o
-obj-y	+= clk-rk3399.o
+obj-$(CONFIG_CPU_RK3568)	+= clk-rk3568.o
+
+obj-$(CONFIG_COMMON_CLK_ROCKCHIP_REGMAP)	+= regmap/
diff --git a/drivers/clk/rockchip/clk-cpu.c b/drivers/clk/rockchip/clk-cpu.c
index 32c19c0f1..81f35c0d6 100644
--- a/drivers/clk/rockchip/clk-cpu.c
+++ b/drivers/clk/rockchip/clk-cpu.c
@@ -54,6 +54,7 @@
  */
 struct rockchip_cpuclk {
 	struct clk_hw				hw;
+	struct clk_hw				*pll_hw;
 
 	struct clk_mux				cpu_mux;
 	const struct clk_ops			*cpu_mux_ops;
@@ -91,10 +92,10 @@ static unsigned long rockchip_cpuclk_recalc_rate(struct clk_hw *hw,
 {
 	struct rockchip_cpuclk *cpuclk = to_rockchip_cpuclk_hw(hw);
 	const struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;
-	u32 clksel0 = readl_relaxed(cpuclk->reg_base + reg_data->core_reg);
+	u32 clksel0 = readl_relaxed(cpuclk->reg_base + reg_data->core_reg[0]);
 
-	clksel0 >>= reg_data->div_core_shift;
-	clksel0 &= reg_data->div_core_mask;
+	clksel0 >>= reg_data->div_core_shift[0];
+	clksel0 &= reg_data->div_core_mask[0];
 	return parent_rate / (clksel0 + 1);
 }
 
@@ -120,6 +121,42 @@ static void rockchip_cpuclk_set_dividers(struct rockchip_cpuclk *cpuclk,
 	}
 }
 
+static void rockchip_cpuclk_set_pre_muxs(struct rockchip_cpuclk *cpuclk,
+					 const struct rockchip_cpuclk_rate_table *rate)
+{
+	int i;
+
+	/* alternate parent is active now. set the pre_muxs */
+	for (i = 0; i < ARRAY_SIZE(rate->pre_muxs); i++) {
+		const struct rockchip_cpuclk_clksel *clksel = &rate->pre_muxs[i];
+
+		if (!clksel->reg)
+			break;
+
+		pr_debug("%s: setting reg 0x%x to 0x%x\n",
+			 __func__, clksel->reg, clksel->val);
+		writel(clksel->val, cpuclk->reg_base + clksel->reg);
+	}
+}
+
+static void rockchip_cpuclk_set_post_muxs(struct rockchip_cpuclk *cpuclk,
+					  const struct rockchip_cpuclk_rate_table *rate)
+{
+	int i;
+
+	/* alternate parent is active now. set the muxs */
+	for (i = 0; i < ARRAY_SIZE(rate->post_muxs); i++) {
+		const struct rockchip_cpuclk_clksel *clksel = &rate->post_muxs[i];
+
+		if (!clksel->reg)
+			break;
+
+		pr_debug("%s: setting reg 0x%x to 0x%x\n",
+			 __func__, clksel->reg, clksel->val);
+		writel(clksel->val, cpuclk->reg_base + clksel->reg);
+	}
+}
+
 static int rockchip_cpuclk_pre_rate_change(struct rockchip_cpuclk *cpuclk,
 					   struct clk_notifier_data *ndata)
 {
@@ -127,6 +164,7 @@ static int rockchip_cpuclk_pre_rate_change(struct rockchip_cpuclk *cpuclk,
 	const struct rockchip_cpuclk_rate_table *rate;
 	unsigned long alt_prate, alt_div;
 	unsigned long flags;
+	int i = 0;
 
 	/* check validity of the new rate */
 	rate = rockchip_get_cpuclk_settings(cpuclk, ndata->new_rate);
@@ -136,6 +174,9 @@ static int rockchip_cpuclk_pre_rate_change(struct rockchip_cpuclk *cpuclk,
 		return -EINVAL;
 	}
 
+	if (IS_ENABLED(CONFIG_ROCKCHIP_CLK_BOOST))
+		rockchip_boost_enable_recovery_sw_low(cpuclk->pll_hw);
+
 	alt_prate = clk_get_rate(cpuclk->alt_parent);
 
 	spin_lock_irqsave(cpuclk->lock, flags);
@@ -149,36 +190,33 @@ static int rockchip_cpuclk_pre_rate_change(struct rockchip_cpuclk *cpuclk,
 	if (alt_prate > ndata->old_rate) {
 		/* calculate dividers */
 		alt_div =  DIV_ROUND_UP(alt_prate, ndata->old_rate) - 1;
-		if (alt_div > reg_data->div_core_mask) {
+		if (alt_div > reg_data->div_core_mask[0]) {
 			pr_warn("%s: limiting alt-divider %lu to %d\n",
-				__func__, alt_div, reg_data->div_core_mask);
-			alt_div = reg_data->div_core_mask;
+				__func__, alt_div, reg_data->div_core_mask[0]);
+			alt_div = reg_data->div_core_mask[0];
 		}
 
-		/*
-		 * Change parents and add dividers in a single transaction.
-		 *
-		 * NOTE: we do this in a single transaction so we're never
-		 * dividing the primary parent by the extra dividers that were
-		 * needed for the alt.
-		 */
 		pr_debug("%s: setting div %lu as alt-rate %lu > old-rate %lu\n",
 			 __func__, alt_div, alt_prate, ndata->old_rate);
 
-		writel(HIWORD_UPDATE(alt_div, reg_data->div_core_mask,
-					      reg_data->div_core_shift) |
-		       HIWORD_UPDATE(reg_data->mux_core_alt,
-				     reg_data->mux_core_mask,
-				     reg_data->mux_core_shift),
-		       cpuclk->reg_base + reg_data->core_reg);
-	} else {
-		/* select alternate parent */
-		writel(HIWORD_UPDATE(reg_data->mux_core_alt,
-				     reg_data->mux_core_mask,
-				     reg_data->mux_core_shift),
-		       cpuclk->reg_base + reg_data->core_reg);
+		for (i = 0; i < reg_data->num_cores; i++) {
+			writel(HIWORD_UPDATE(alt_div, reg_data->div_core_mask[i],
+					     reg_data->div_core_shift[i]),
+			       cpuclk->reg_base + reg_data->core_reg[i]);
+		}
 	}
 
+	if (IS_ENABLED(CONFIG_ROCKCHIP_CLK_BOOST))
+		rockchip_boost_add_core_div(cpuclk->pll_hw, alt_prate);
+
+	/* select alternate parent */
+	writel(HIWORD_UPDATE(reg_data->mux_core_alt,
+			     reg_data->mux_core_mask,
+			     reg_data->mux_core_shift),
+	       cpuclk->reg_base + reg_data->core_reg[0]);
+
+	rockchip_cpuclk_set_pre_muxs(cpuclk, rate);
+
 	spin_unlock_irqrestore(cpuclk->lock, flags);
 	return 0;
 }
@@ -189,6 +227,7 @@ static int rockchip_cpuclk_post_rate_change(struct rockchip_cpuclk *cpuclk,
 	const struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;
 	const struct rockchip_cpuclk_rate_table *rate;
 	unsigned long flags;
+	int i = 0;
 
 	rate = rockchip_get_cpuclk_settings(cpuclk, ndata->new_rate);
 	if (!rate) {
@@ -202,23 +241,27 @@ static int rockchip_cpuclk_post_rate_change(struct rockchip_cpuclk *cpuclk,
 	if (ndata->old_rate < ndata->new_rate)
 		rockchip_cpuclk_set_dividers(cpuclk, rate);
 
-	/*
-	 * post-rate change event, re-mux to primary parent and remove dividers.
-	 *
-	 * NOTE: we do this in a single transaction so we're never dividing the
-	 * primary parent by the extra dividers that were needed for the alt.
-	 */
+	/* re-mux to primary parent  */
+	writel(HIWORD_UPDATE(reg_data->mux_core_main,
+			     reg_data->mux_core_mask,
+			     reg_data->mux_core_shift),
+	       cpuclk->reg_base + reg_data->core_reg[0]);
 
-	writel(HIWORD_UPDATE(0, reg_data->div_core_mask,
-				reg_data->div_core_shift) |
-	       HIWORD_UPDATE(reg_data->mux_core_main,
-				reg_data->mux_core_mask,
-				reg_data->mux_core_shift),
-	       cpuclk->reg_base + reg_data->core_reg);
+	rockchip_cpuclk_set_post_muxs(cpuclk, rate);
+
+	/* remove dividers */
+	for (i = 0; i < reg_data->num_cores; i++) {
+		writel(HIWORD_UPDATE(0, reg_data->div_core_mask[i],
+				     reg_data->div_core_shift[i]),
+		       cpuclk->reg_base + reg_data->core_reg[i]);
+	}
 
 	if (ndata->old_rate > ndata->new_rate)
 		rockchip_cpuclk_set_dividers(cpuclk, rate);
 
+	if (IS_ENABLED(CONFIG_ROCKCHIP_CLK_BOOST))
+		rockchip_boost_disable_recovery_sw(cpuclk->pll_hw);
+
 	spin_unlock_irqrestore(cpuclk->lock, flags);
 	return 0;
 }
@@ -253,8 +296,8 @@ struct clk *rockchip_clk_register_cpuclk(const char *name,
 			int nrates, void __iomem *reg_base, spinlock_t *lock)
 {
 	struct rockchip_cpuclk *cpuclk;
-	struct clk_init_data init;
-	struct clk *clk, *cclk;
+	struct clk_init_data init = {};
+	struct clk *clk, *cclk, *pll_clk;
 	int ret;
 
 	if (num_parents < 2) {
@@ -284,6 +327,17 @@ struct clk *rockchip_clk_register_cpuclk(const char *name,
 	cpuclk->reg_data = reg_data;
 	cpuclk->clk_nb.notifier_call = rockchip_cpuclk_notifier_cb;
 	cpuclk->hw.init = &init;
+	if (IS_ENABLED(CONFIG_ROCKCHIP_CLK_BOOST) && reg_data->pll_name) {
+		pll_clk = __clk_lookup(reg_data->pll_name);
+		if (!pll_clk) {
+			pr_err("%s: could not lookup pll clock: (%s)\n",
+			       __func__, reg_data->pll_name);
+			ret = -EINVAL;
+			goto free_cpuclk;
+		}
+		cpuclk->pll_hw = __clk_get_hw(pll_clk);
+		rockchip_boost_init(cpuclk->pll_hw);
+	}
 
 	cpuclk->alt_parent = __clk_lookup(parent_names[reg_data->mux_core_alt]);
 	if (!cpuclk->alt_parent) {
diff --git a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
index ebce52600..33d22e3fa 100644
--- a/drivers/clk/rockchip/clk-ddr.c
+++ b/drivers/clk/rockchip/clk-ddr.c
@@ -13,14 +13,26 @@
  * GNU General Public License for more details.
  */
 
+#include <drm/drmP.h>
 #include <linux/arm-smccc.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/rockchip/rockchip_sip.h>
 #include <linux/slab.h>
+#include <soc/rockchip/rockchip_dmc.h>
 #include <soc/rockchip/rockchip_sip.h>
+#include <soc/rockchip/scpi.h>
+#include <uapi/drm/drm_mode.h>
+#ifdef CONFIG_ARM
+#include <asm/psci.h>
+#endif
+
 #include "clk.h"
 
+#define MHZ		(1000000)
+
 struct rockchip_ddrclk {
 	struct clk_hw	hw;
 	void __iomem	*reg_base;
@@ -30,25 +42,70 @@ struct rockchip_ddrclk {
 	int		div_shift;
 	int		div_width;
 	int		ddr_flag;
-	spinlock_t	*lock;
 };
 
 #define to_rockchip_ddrclk_hw(hw) container_of(hw, struct rockchip_ddrclk, hw)
 
+static int rk_drm_get_lcdc_type(void)
+{
+	struct drm_device *drm;
+	u32 lcdc_type = 0;
+
+	drm = drm_device_get_by_name("rockchip");
+	if (drm) {
+		struct drm_connector *conn;
+
+		list_for_each_entry(conn, &drm->mode_config.connector_list,
+				    head) {
+			if (conn->encoder) {
+				lcdc_type = conn->connector_type;
+				break;
+			}
+		}
+	}
+
+	switch (lcdc_type) {
+	case DRM_MODE_CONNECTOR_DPI:
+	case DRM_MODE_CONNECTOR_LVDS:
+		lcdc_type = SCREEN_LVDS;
+		break;
+	case DRM_MODE_CONNECTOR_DisplayPort:
+		lcdc_type = SCREEN_DP;
+		break;
+	case DRM_MODE_CONNECTOR_HDMIA:
+	case DRM_MODE_CONNECTOR_HDMIB:
+		lcdc_type = SCREEN_HDMI;
+		break;
+	case DRM_MODE_CONNECTOR_TV:
+		lcdc_type = SCREEN_TVOUT;
+		break;
+	case DRM_MODE_CONNECTOR_eDP:
+		lcdc_type = SCREEN_EDP;
+		break;
+	case DRM_MODE_CONNECTOR_DSI:
+		lcdc_type = SCREEN_MIPI;
+		break;
+	default:
+		lcdc_type = SCREEN_NULL;
+		break;
+	}
+
+	return lcdc_type;
+}
+
 static int rockchip_ddrclk_sip_set_rate(struct clk_hw *hw, unsigned long drate,
 					unsigned long prate)
 {
-	struct rockchip_ddrclk *ddrclk = to_rockchip_ddrclk_hw(hw);
-	unsigned long flags;
 	struct arm_smccc_res res;
 
-	spin_lock_irqsave(ddrclk->lock, flags);
 	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, drate, 0,
 		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
 		      0, 0, 0, 0, &res);
-	spin_unlock_irqrestore(ddrclk->lock, flags);
 
-	return res.a0;
+	if (res.a0)
+		return 0;
+	else
+		return -EPERM;
 }
 
 static unsigned long
@@ -96,18 +153,179 @@ static const struct clk_ops rockchip_ddrclk_sip_ops = {
 	.get_parent = rockchip_ddrclk_get_parent,
 };
 
-struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
-					 const char *const *parent_names,
-					 u8 num_parents, int mux_offset,
-					 int mux_shift, int mux_width,
-					 int div_shift, int div_width,
-					 int ddr_flag, void __iomem *reg_base,
-					 spinlock_t *lock)
+static u32 ddr_clk_cached;
+
+static int rockchip_ddrclk_scpi_set_rate(struct clk_hw *hw, unsigned long drate,
+					 unsigned long prate)
+{
+	u32 ret;
+	u32 lcdc_type;
+
+	lcdc_type = rk_drm_get_lcdc_type();
+
+	ret = scpi_ddr_set_clk_rate(drate / MHZ, lcdc_type);
+	if (ret) {
+		ddr_clk_cached = ret;
+		ret = 0;
+	} else {
+		ddr_clk_cached = 0;
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static unsigned long rockchip_ddrclk_scpi_recalc_rate(struct clk_hw *hw,
+						      unsigned long parent_rate)
+{
+	if (ddr_clk_cached)
+		return (MHZ * ddr_clk_cached);
+	else
+		return (MHZ * scpi_ddr_get_clk_rate());
+}
+
+static long rockchip_ddrclk_scpi_round_rate(struct clk_hw *hw,
+					    unsigned long rate,
+					    unsigned long *prate)
+{
+	rate = rate / MHZ;
+	rate = (rate / 12) * 12;
+
+	return (rate * MHZ);
+}
+
+static const struct clk_ops rockchip_ddrclk_scpi_ops = {
+	.recalc_rate = rockchip_ddrclk_scpi_recalc_rate,
+	.set_rate = rockchip_ddrclk_scpi_set_rate,
+	.round_rate = rockchip_ddrclk_scpi_round_rate,
+	.get_parent = rockchip_ddrclk_get_parent,
+};
+
+struct share_params {
+	u32 hz;
+	u32 lcdc_type;
+	u32 vop;
+	u32 vop_dclk_mode;
+	u32 sr_idle_en;
+	u32 addr_mcu_el3;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag1;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag0;
+	u32 complt_hwirq;
+	 /* if need, add parameter after */
+};
+
+struct rockchip_ddrclk_data {
+	u32 inited_flag;
+	void __iomem *share_memory;
+};
+
+static struct rockchip_ddrclk_data ddr_data;
+
+static void rockchip_ddrclk_data_init(void)
+{
+	struct arm_smccc_res res;
+
+	res = sip_smc_request_share_mem(1, SHARE_PAGE_TYPE_DDR);
+
+	if (!res.a0) {
+		ddr_data.share_memory =  (void __iomem *)res.a1;
+		ddr_data.inited_flag = 1;
+	}
+}
+
+static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
+					   unsigned long drate,
+					   unsigned long prate)
+{
+	struct share_params *p;
+	struct arm_smccc_res res;
+
+	if (!ddr_data.inited_flag)
+		rockchip_ddrclk_data_init();
+
+	p = (struct share_params *)ddr_data.share_memory;
+
+	p->hz = drate;
+	p->lcdc_type = rk_drm_get_lcdc_type();
+	p->wait_flag1 = 1;
+	p->wait_flag0 = 1;
+
+	res = sip_smc_dram(SHARE_PAGE_TYPE_DDR, 0,
+			   ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE);
+
+	if ((int)res.a1 == SIP_RET_SET_RATE_TIMEOUT)
+		rockchip_dmcfreq_wait_complete();
+
+	return res.a0;
+}
+
+static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
+			(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+
+	res = sip_smc_dram(SHARE_PAGE_TYPE_DDR, 0,
+			   ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE);
+	if (!res.a0)
+		return res.a1;
+	else
+		return 0;
+}
+
+static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
+					      unsigned long rate,
+					      unsigned long *prate)
+{
+	struct share_params *p;
+	struct arm_smccc_res res;
+
+	if (!ddr_data.inited_flag)
+		rockchip_ddrclk_data_init();
+
+	p = (struct share_params *)ddr_data.share_memory;
+
+	p->hz = rate;
+
+	res = sip_smc_dram(SHARE_PAGE_TYPE_DDR, 0,
+			   ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE);
+	if (!res.a0)
+		return res.a1;
+	else
+		return 0;
+}
+
+static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
+	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
+	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
+	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
+	.get_parent = rockchip_ddrclk_get_parent,
+};
+
+struct clk * __init
+rockchip_clk_register_ddrclk(const char *name, int flags,
+			     const char *const *parent_names,
+			     u8 num_parents, int mux_offset,
+			     int mux_shift, int mux_width,
+			     int div_shift, int div_width,
+			     int ddr_flag, void __iomem *reg_base)
 {
 	struct rockchip_ddrclk *ddrclk;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk *clk;
 
+#ifdef CONFIG_ARM
+	if (!psci_smp_available())
+		return NULL;
+#endif
+
 	ddrclk = kzalloc(sizeof(*ddrclk), GFP_KERNEL);
 	if (!ddrclk)
 		return ERR_PTR(-ENOMEM);
@@ -120,9 +338,19 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 	init.flags |= CLK_SET_RATE_NO_REPARENT;
 
 	switch (ddr_flag) {
+#ifdef CONFIG_ROCKCHIP_DDRCLK_SIP
 	case ROCKCHIP_DDRCLK_SIP:
 		init.ops = &rockchip_ddrclk_sip_ops;
 		break;
+#endif
+#ifdef CONFIG_ROCKCHIP_DDRCLK_SCPI
+	case ROCKCHIP_DDRCLK_SCPI:
+		init.ops = &rockchip_ddrclk_scpi_ops;
+		break;
+#endif
+	case ROCKCHIP_DDRCLK_SIP_V2:
+		init.ops = &rockchip_ddrclk_sip_ops_v2;
+		break;
 	default:
 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
 		kfree(ddrclk);
@@ -130,7 +358,6 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 	}
 
 	ddrclk->reg_base = reg_base;
-	ddrclk->lock = lock;
 	ddrclk->hw.init = &init;
 	ddrclk->mux_offset = mux_offset;
 	ddrclk->mux_shift = mux_shift;
diff --git a/drivers/clk/rockchip/clk-half-divider.c b/drivers/clk/rockchip/clk-half-divider.c
index 6a371d052..fbdaff1d1 100644
--- a/drivers/clk/rockchip/clk-half-divider.c
+++ b/drivers/clk/rockchip/clk-half-divider.c
@@ -13,9 +13,9 @@ static bool _is_best_half_div(unsigned long rate, unsigned long now,
 			      unsigned long best, unsigned long flags)
 {
 	if (flags & CLK_DIVIDER_ROUND_CLOSEST)
-		return abs(rate - now) < abs(rate - best);
+		return abs(rate - now) <= abs(rate - best);
 
-	return now <= rate && now > best;
+	return now <= rate && now >= best;
 }
 
 static unsigned long clk_half_divider_recalc_rate(struct clk_hw *hw,
@@ -37,7 +37,7 @@ static int clk_half_divider_bestdiv(struct clk_hw *hw, unsigned long rate,
 {
 	unsigned int i, bestdiv = 0;
 	unsigned long parent_rate, best = 0, now, maxdiv;
-	unsigned long parent_rate_saved = *best_parent_rate;
+	bool is_bestdiv = false;
 
 	if (!rate)
 		rate = 1;
@@ -50,7 +50,7 @@ static int clk_half_divider_bestdiv(struct clk_hw *hw, unsigned long rate,
 		if (bestdiv < 3)
 			bestdiv = 0;
 		else
-			bestdiv = (bestdiv - 3) / 2;
+			bestdiv = DIV_ROUND_UP(bestdiv - 3, 2);
 		bestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;
 		return bestdiv;
 	}
@@ -62,28 +62,20 @@ static int clk_half_divider_bestdiv(struct clk_hw *hw, unsigned long rate,
 	maxdiv = min(ULONG_MAX / rate, maxdiv);
 
 	for (i = 0; i <= maxdiv; i++) {
-		if (((u64)rate * (i * 2 + 3)) == ((u64)parent_rate_saved * 2)) {
-			/*
-			 * It's the most ideal case if the requested rate can be
-			 * divided from parent clock without needing to change
-			 * parent rate, so return the divider immediately.
-			 */
-			*best_parent_rate = parent_rate_saved;
-			return i;
-		}
 		parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),
 						((u64)rate * (i * 2 + 3)) / 2);
 		now = DIV_ROUND_UP_ULL(((u64)parent_rate * 2),
 				       (i * 2 + 3));
 
 		if (_is_best_half_div(rate, now, best, flags)) {
+			is_bestdiv = true;
 			bestdiv = i;
 			best = now;
 			*best_parent_rate = parent_rate;
 		}
 	}
 
-	if (!bestdiv) {
+	if (!is_bestdiv) {
 		bestdiv = div_mask(width);
 		*best_parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw), 1);
 	}
@@ -113,7 +105,7 @@ static int clk_half_divider_set_rate(struct clk_hw *hw, unsigned long rate,
 	u32 val;
 
 	value = DIV_ROUND_UP_ULL(((u64)parent_rate * 2), rate);
-	value = (value - 3) / 2;
+	value = DIV_ROUND_UP(value - 3, 2);
 	value =  min_t(unsigned int, value, div_mask(divider->width));
 
 	if (divider->lock)
@@ -160,10 +152,10 @@ struct clk *rockchip_clk_register_halfdiv(const char *name,
 					  u8 num_parents, void __iomem *base,
 					  int muxdiv_offset, u8 mux_shift,
 					  u8 mux_width, u8 mux_flags,
-					  u8 div_shift, u8 div_width,
-					  u8 div_flags, int gate_offset,
-					  u8 gate_shift, u8 gate_flags,
-					  unsigned long flags,
+					  int div_offset, u8 div_shift,
+					  u8 div_width, u8 div_flags,
+					  int gate_offset, u8 gate_shift,
+					  u8 gate_flags, unsigned long flags,
 					  spinlock_t *lock)
 {
 	struct clk *clk = ERR_PTR(-ENOMEM);
@@ -205,7 +197,10 @@ struct clk *rockchip_clk_register_halfdiv(const char *name,
 			goto err_div;
 
 		div->flags = div_flags;
-		div->reg = base + muxdiv_offset;
+		if (div_offset)
+			div->reg = base + div_offset;
+		else
+			div->reg = base + muxdiv_offset;
 		div->shift = div_shift;
 		div->width = div_width;
 		div->lock = lock;
diff --git a/drivers/clk/rockchip/clk-inverter.c b/drivers/clk/rockchip/clk-inverter.c
index dcb6e37f3..269da99a7 100644
--- a/drivers/clk/rockchip/clk-inverter.c
+++ b/drivers/clk/rockchip/clk-inverter.c
@@ -84,7 +84,7 @@ struct clk *rockchip_clk_register_inverter(const char *name,
 				void __iomem *reg, int shift, int flags,
 				spinlock_t *lock)
 {
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct rockchip_inv_clock *inv_clock;
 	struct clk *clk;
 
diff --git a/drivers/clk/rockchip/clk-mmc-phase.c b/drivers/clk/rockchip/clk-mmc-phase.c
index dbec84238..f06d12ea5 100644
--- a/drivers/clk/rockchip/clk-mmc-phase.c
+++ b/drivers/clk/rockchip/clk-mmc-phase.c
@@ -201,7 +201,7 @@ struct clk *rockchip_clk_register_mmc(const char *name,
 				const char *const *parent_names, u8 num_parents,
 				void __iomem *reg, int shift)
 {
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct rockchip_mmc_clock *mmc_clock;
 	struct clk *clk;
 	int ret;
diff --git a/drivers/clk/rockchip/clk-muxgrf.c b/drivers/clk/rockchip/clk-muxgrf.c
index 4f291180a..2ecc62ec2 100644
--- a/drivers/clk/rockchip/clk-muxgrf.c
+++ b/drivers/clk/rockchip/clk-muxgrf.c
@@ -69,7 +69,7 @@ struct clk *rockchip_clk_register_muxgrf(const char *name,
 				int shift, int width, int mux_flags)
 {
 	struct rockchip_muxgrf_clock *muxgrf_clock;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct clk *clk;
 
 	if (IS_ERR(regmap)) {
diff --git a/drivers/clk/rockchip/clk-pll.c b/drivers/clk/rockchip/clk-pll.c
index dd0433d47..311d60c44 100644
--- a/drivers/clk/rockchip/clk-pll.c
+++ b/drivers/clk/rockchip/clk-pll.c
@@ -21,8 +21,12 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/clk-provider.h>
+#include <linux/iopoll.h>
 #include <linux/regmap.h>
 #include <linux/clk.h>
+#include <linux/gcd.h>
+#include <linux/clk/rockchip.h>
+#include <linux/mfd/syscon.h>
 #include "clk.h"
 
 #define PLL_MODE_MASK		0x3
@@ -46,15 +50,294 @@ struct rockchip_clk_pll {
 	u8			flags;
 	const struct rockchip_pll_rate_table *rate_table;
 	unsigned int		rate_count;
+	int			sel;
+	unsigned long		scaling;
 	spinlock_t		*lock;
 
 	struct rockchip_clk_provider *ctx;
+
+#ifdef CONFIG_ROCKCHIP_CLK_BOOST
+	bool			boost_enabled;
+	u32			boost_backup_pll_usage;
+	unsigned long		boost_backup_pll_rate;
+	unsigned long		boost_low_rate;
+	unsigned long		boost_high_rate;
+	struct regmap		*boost;
+#endif
+#ifdef CONFIG_DEBUG_FS
+	struct hlist_node	debug_node;
+#endif
 };
 
 #define to_rockchip_clk_pll(_hw) container_of(_hw, struct rockchip_clk_pll, hw)
 #define to_rockchip_clk_pll_nb(nb) \
 			container_of(nb, struct rockchip_clk_pll, clk_nb)
 
+#ifdef CONFIG_ROCKCHIP_CLK_BOOST
+static void rockchip_boost_disable_low(struct rockchip_clk_pll *pll);
+#ifdef CONFIG_DEBUG_FS
+static HLIST_HEAD(clk_boost_list);
+static DEFINE_MUTEX(clk_boost_lock);
+#endif
+#else
+static inline void rockchip_boost_disable_low(struct rockchip_clk_pll *pll) {}
+#endif
+
+#define MHZ			(1000UL * 1000UL)
+#define KHZ			(1000UL)
+
+/* CLK_PLL_TYPE_RK3066_AUTO type ops */
+#define PLL_FREF_MIN		(269 * KHZ)
+#define PLL_FREF_MAX		(2200 * MHZ)
+
+#define PLL_FVCO_MIN		(440 * MHZ)
+#define PLL_FVCO_MAX		(2200 * MHZ)
+
+#define PLL_FOUT_MIN		(27500 * KHZ)
+#define PLL_FOUT_MAX		(2200 * MHZ)
+
+#define PLL_NF_MAX		(4096)
+#define PLL_NR_MAX		(64)
+#define PLL_NO_MAX		(16)
+
+/* CLK_PLL_TYPE_RK3036/3366/3399_AUTO type ops */
+#define MIN_FOUTVCO_FREQ	(800 * MHZ)
+#define MAX_FOUTVCO_FREQ	(2000 * MHZ)
+
+static struct rockchip_pll_rate_table auto_table;
+
+int rockchip_pll_clk_adaptive_scaling(struct clk *clk, int sel)
+{
+	struct clk *parent = clk_get_parent(clk);
+	struct rockchip_clk_pll *pll;
+
+	if (IS_ERR_OR_NULL(parent))
+		return -EINVAL;
+
+	pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+	if (!pll)
+		return -EINVAL;
+
+	pll->sel = sel;
+
+	return 0;
+}
+
+int rockchip_pll_clk_rate_to_scale(struct clk *clk, unsigned long rate)
+{
+	const struct rockchip_pll_rate_table *rate_table;
+	struct clk *parent = clk_get_parent(clk);
+	struct rockchip_clk_pll *pll;
+	unsigned int i;
+
+	if (IS_ERR_OR_NULL(parent))
+		return -EINVAL;
+
+	pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+	if (!pll)
+		return -EINVAL;
+
+	rate_table = pll->rate_table;
+	for (i = 0; i < pll->rate_count; i++) {
+		if (rate >= rate_table[i].rate)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+int rockchip_pll_clk_scale_to_rate(struct clk *clk, unsigned int scale)
+{
+	const struct rockchip_pll_rate_table *rate_table;
+	struct clk *parent = clk_get_parent(clk);
+	struct rockchip_clk_pll *pll;
+	unsigned int i;
+
+	if (IS_ERR_OR_NULL(parent))
+		return -EINVAL;
+
+	pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+	if (!pll)
+		return -EINVAL;
+
+	rate_table = pll->rate_table;
+	for (i = 0; i < pll->rate_count; i++) {
+		if (i == scale)
+			return rate_table[i].rate;
+	}
+
+	return -EINVAL;
+}
+
+static struct rockchip_pll_rate_table *rk_pll_rate_table_get(void)
+{
+	return &auto_table;
+}
+
+static int rockchip_pll_clk_set_postdiv(unsigned long fout_hz,
+					u32 *postdiv1,
+					u32 *postdiv2,
+					u32 *foutvco)
+{
+	unsigned long freq;
+
+	if (fout_hz < MIN_FOUTVCO_FREQ) {
+		for (*postdiv1 = 1; *postdiv1 <= 7; (*postdiv1)++) {
+			for (*postdiv2 = 1; *postdiv2 <= 7; (*postdiv2)++) {
+				freq = fout_hz * (*postdiv1) * (*postdiv2);
+				if (freq >= MIN_FOUTVCO_FREQ &&
+				    freq <= MAX_FOUTVCO_FREQ) {
+					*foutvco = freq;
+					return 0;
+				}
+			}
+		}
+		pr_err("CANNOT FIND postdiv1/2 to make fout in range from 800M to 2000M,fout = %lu\n",
+		       fout_hz);
+	} else {
+		*postdiv1 = 1;
+		*postdiv2 = 1;
+	}
+	return 0;
+}
+
+static struct rockchip_pll_rate_table *
+rockchip_pll_clk_set_by_auto(struct rockchip_clk_pll *pll,
+			     unsigned long fin_hz,
+			     unsigned long fout_hz)
+{
+	struct rockchip_pll_rate_table *rate_table = rk_pll_rate_table_get();
+	/* FIXME set postdiv1/2 always 1*/
+	u32 foutvco = fout_hz;
+	u64 fin_64, frac_64;
+	u32 f_frac, postdiv1, postdiv2;
+	unsigned long clk_gcd = 0;
+
+	if (fin_hz == 0 || fout_hz == 0 || fout_hz == fin_hz)
+		return NULL;
+
+	rockchip_pll_clk_set_postdiv(fout_hz, &postdiv1, &postdiv2, &foutvco);
+	rate_table->postdiv1 = postdiv1;
+	rate_table->postdiv2 = postdiv2;
+	rate_table->dsmpd = 1;
+
+	if (fin_hz / MHZ * MHZ == fin_hz && fout_hz / MHZ * MHZ == fout_hz) {
+		fin_hz /= MHZ;
+		foutvco /= MHZ;
+		clk_gcd = gcd(fin_hz, foutvco);
+		rate_table->refdiv = fin_hz / clk_gcd;
+		rate_table->fbdiv = foutvco / clk_gcd;
+
+		rate_table->frac = 0;
+
+		pr_debug("fin = %lu, fout = %lu, clk_gcd = %lu, refdiv = %u, fbdiv = %u, postdiv1 = %u, postdiv2 = %u, frac = %u\n",
+			 fin_hz, fout_hz, clk_gcd, rate_table->refdiv,
+			 rate_table->fbdiv, rate_table->postdiv1,
+			 rate_table->postdiv2, rate_table->frac);
+	} else {
+		pr_debug("frac div running, fin_hz = %lu, fout_hz = %lu, fin_INT_mhz = %lu, fout_INT_mhz = %lu\n",
+			 fin_hz, fout_hz,
+			 fin_hz / MHZ * MHZ,
+			 fout_hz / MHZ * MHZ);
+		pr_debug("frac get postdiv1 = %u,  postdiv2 = %u, foutvco = %u\n",
+			 rate_table->postdiv1, rate_table->postdiv2, foutvco);
+		clk_gcd = gcd(fin_hz / MHZ, foutvco / MHZ);
+		rate_table->refdiv = fin_hz / MHZ / clk_gcd;
+		rate_table->fbdiv = foutvco / MHZ / clk_gcd;
+		pr_debug("frac get refdiv = %u,  fbdiv = %u\n",
+			 rate_table->refdiv, rate_table->fbdiv);
+
+		rate_table->frac = 0;
+
+		f_frac = (foutvco % MHZ);
+		fin_64 = fin_hz;
+		do_div(fin_64, (u64)rate_table->refdiv);
+		frac_64 = (u64)f_frac << 24;
+		do_div(frac_64, fin_64);
+		rate_table->frac = (u32)frac_64;
+		if (rate_table->frac > 0)
+			rate_table->dsmpd = 0;
+		pr_debug("frac = %x\n", rate_table->frac);
+	}
+	return rate_table;
+}
+
+static struct rockchip_pll_rate_table *
+rockchip_rk3066_pll_clk_set_by_auto(struct rockchip_clk_pll *pll,
+				    unsigned long fin_hz,
+				    unsigned long fout_hz)
+{
+	struct rockchip_pll_rate_table *rate_table = rk_pll_rate_table_get();
+	u32 nr, nf, no, nonr;
+	u32 nr_out, nf_out, no_out;
+	u32 n;
+	u32 numerator, denominator;
+	u64 fref, fvco, fout;
+	unsigned long clk_gcd = 0;
+
+	nr_out = PLL_NR_MAX + 1;
+	no_out = 0;
+	nf_out = 0;
+
+	if (fin_hz == 0 || fout_hz == 0 || fout_hz == fin_hz)
+		return NULL;
+
+	clk_gcd = gcd(fin_hz, fout_hz);
+
+	numerator = fout_hz / clk_gcd;
+	denominator = fin_hz / clk_gcd;
+
+	for (n = 1;; n++) {
+		nf = numerator * n;
+		nonr = denominator * n;
+		if (nf > PLL_NF_MAX || nonr > (PLL_NO_MAX * PLL_NR_MAX))
+			break;
+
+		for (no = 1; no <= PLL_NO_MAX; no++) {
+			if (!(no == 1 || !(no % 2)))
+				continue;
+
+			if (nonr % no)
+				continue;
+			nr = nonr / no;
+
+			if (nr > PLL_NR_MAX)
+				continue;
+
+			fref = fin_hz / nr;
+			if (fref < PLL_FREF_MIN || fref > PLL_FREF_MAX)
+				continue;
+
+			fvco = fref * nf;
+			if (fvco < PLL_FVCO_MIN || fvco > PLL_FVCO_MAX)
+				continue;
+
+			fout = fvco / no;
+			if (fout < PLL_FOUT_MIN || fout > PLL_FOUT_MAX)
+				continue;
+
+			/* select the best from all available PLL settings */
+			if ((no > no_out) ||
+			    ((no == no_out) && (nr < nr_out))) {
+				nr_out = nr;
+				nf_out = nf;
+				no_out = no;
+			}
+		}
+	}
+
+	/* output the best PLL setting */
+	if ((nr_out <= PLL_NR_MAX) && (no_out > 0)) {
+		rate_table->nr = nr_out;
+		rate_table->nf = nf_out;
+		rate_table->no = no_out;
+	} else {
+		return NULL;
+	}
+
+	return rate_table;
+}
+
 static const struct rockchip_pll_rate_table *rockchip_get_pll_settings(
 			    struct rockchip_clk_pll *pll, unsigned long rate)
 {
@@ -62,28 +345,27 @@ static const struct rockchip_pll_rate_table *rockchip_get_pll_settings(
 	int i;
 
 	for (i = 0; i < pll->rate_count; i++) {
-		if (rate == rate_table[i].rate)
+		if (rate == rate_table[i].rate) {
+			if (i < pll->sel) {
+				pll->scaling = rate;
+				return &rate_table[pll->sel];
+			}
+			pll->scaling = 0;
 			return &rate_table[i];
+		}
 	}
+	pll->scaling = 0;
 
-	return NULL;
+	if (pll->type == pll_rk3066)
+		return rockchip_rk3066_pll_clk_set_by_auto(pll, 24 * MHZ, rate);
+	else
+		return rockchip_pll_clk_set_by_auto(pll, 24 * MHZ, rate);
 }
 
 static long rockchip_pll_round_rate(struct clk_hw *hw,
 			    unsigned long drate, unsigned long *prate)
 {
-	struct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);
-	const struct rockchip_pll_rate_table *rate_table = pll->rate_table;
-	int i;
-
-	/* Assumming rate_table is in descending order */
-	for (i = 0; i < pll->rate_count; i++) {
-		if (drate >= rate_table[i].rate)
-			return rate_table[i].rate;
-	}
-
-	/* return minimum supported value */
-	return rate_table[i - 1].rate;
+	return drate;
 }
 
 /*
@@ -95,23 +377,14 @@ static int rockchip_pll_wait_lock(struct rockchip_clk_pll *pll)
 {
 	struct regmap *grf = pll->ctx->grf;
 	unsigned int val;
-	int delay = 24000000, ret;
-
-	while (delay > 0) {
-		ret = regmap_read(grf, pll->lock_offset, &val);
-		if (ret) {
-			pr_err("%s: failed to read pll lock status: %d\n",
-			       __func__, ret);
-			return ret;
-		}
+	int ret;
 
-		if (val & BIT(pll->lock_shift))
-			return 0;
-		delay--;
-	}
+	ret = regmap_read_poll_timeout(grf, pll->lock_offset, val,
+				       val & BIT(pll->lock_shift), 0, 1000);
+	if (ret)
+		pr_err("%s: timeout waiting for pll to lock\n", __func__);
 
-	pr_err("%s: timeout waiting for pll to lock\n", __func__);
-	return -ETIMEDOUT;
+	return ret;
 }
 
 /**
@@ -127,12 +400,56 @@ static int rockchip_pll_wait_lock(struct rockchip_clk_pll *pll)
 #define RK3036_PLLCON1_REFDIV_SHIFT		0
 #define RK3036_PLLCON1_POSTDIV2_MASK		0x7
 #define RK3036_PLLCON1_POSTDIV2_SHIFT		6
+#define RK3036_PLLCON1_LOCK_STATUS		BIT(10)
 #define RK3036_PLLCON1_DSMPD_MASK		0x1
 #define RK3036_PLLCON1_DSMPD_SHIFT		12
+#define RK3036_PLLCON1_PWRDOWN			BIT(13)
+#define RK3036_PLLCON1_PLLPDSEL			BIT(15)
 #define RK3036_PLLCON2_FRAC_MASK		0xffffff
 #define RK3036_PLLCON2_FRAC_SHIFT		0
 
-#define RK3036_PLLCON1_PWRDOWN			(1 << 13)
+static int rockchip_rk3036_pll_wait_lock(struct rockchip_clk_pll *pll)
+{
+	u32 pllcon;
+	int ret;
+
+	/*
+	 * Lock time typical 250, max 500 input clock cycles @24MHz
+	 * So define a very safe maximum of 1000us, meaning 24000 cycles.
+	 */
+	ret = readl_relaxed_poll_timeout(pll->reg_base + RK3036_PLLCON(1),
+					 pllcon,
+					 pllcon & RK3036_PLLCON1_LOCK_STATUS,
+					 0, 1000);
+	if (ret)
+		pr_err("%s: timeout waiting for pll to lock\n", __func__);
+
+	return ret;
+}
+
+static unsigned long __maybe_unused
+rockchip_rk3036_pll_con_to_rate(struct rockchip_clk_pll *pll,
+				u32 con0, u32 con1)
+{
+	unsigned int fbdiv, postdiv1, refdiv, postdiv2;
+	u64 rate64 = 24000000;
+
+	fbdiv = ((con0 >> RK3036_PLLCON0_FBDIV_SHIFT) &
+		  RK3036_PLLCON0_FBDIV_MASK);
+	postdiv1 = ((con0 >> RK3036_PLLCON0_POSTDIV1_SHIFT) &
+		     RK3036_PLLCON0_POSTDIV1_MASK);
+	refdiv = ((con1 >> RK3036_PLLCON1_REFDIV_SHIFT) &
+		   RK3036_PLLCON1_REFDIV_MASK);
+	postdiv2 = ((con1 >> RK3036_PLLCON1_POSTDIV2_SHIFT) &
+		     RK3036_PLLCON1_POSTDIV2_MASK);
+
+	rate64 *= fbdiv;
+	do_div(rate64, refdiv);
+	do_div(rate64, postdiv1);
+	do_div(rate64, postdiv2);
+
+	return (unsigned long)rate64;
+}
 
 static void rockchip_rk3036_pll_get_params(struct rockchip_clk_pll *pll,
 					struct rockchip_pll_rate_table *rate)
@@ -163,7 +480,10 @@ static unsigned long rockchip_rk3036_pll_recalc_rate(struct clk_hw *hw,
 {
 	struct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);
 	struct rockchip_pll_rate_table cur;
-	u64 rate64 = prate;
+	u64 rate64 = prate, frac_rate64 = prate;
+
+	if (pll->sel && pll->scaling)
+		return pll->scaling;
 
 	rockchip_rk3036_pll_get_params(pll, &cur);
 
@@ -172,7 +492,7 @@ static unsigned long rockchip_rk3036_pll_recalc_rate(struct clk_hw *hw,
 
 	if (cur.dsmpd == 0) {
 		/* fractional mode */
-		u64 frac_rate64 = prate * cur.frac;
+		frac_rate64 *= cur.frac;
 
 		do_div(frac_rate64, cur.refdiv);
 		rate64 += frac_rate64 >> 24;
@@ -229,8 +549,11 @@ static int rockchip_rk3036_pll_set_params(struct rockchip_clk_pll *pll,
 	pllcon |= rate->frac << RK3036_PLLCON2_FRAC_SHIFT;
 	writel_relaxed(pllcon, pll->reg_base + RK3036_PLLCON(2));
 
+	if (IS_ENABLED(CONFIG_ROCKCHIP_CLK_BOOST))
+		rockchip_boost_disable_low(pll);
+
 	/* wait for the pll to lock */
-	ret = rockchip_pll_wait_lock(pll);
+	ret = rockchip_rk3036_pll_wait_lock(pll);
 	if (ret) {
 		pr_warn("%s: pll update unsuccessful, trying to restore old params\n",
 			__func__);
@@ -269,7 +592,7 @@ static int rockchip_rk3036_pll_enable(struct clk_hw *hw)
 
 	writel(HIWORD_UPDATE(0, RK3036_PLLCON1_PWRDOWN, 0),
 	       pll->reg_base + RK3036_PLLCON(1));
-	rockchip_pll_wait_lock(pll);
+	rockchip_rk3036_pll_wait_lock(pll);
 
 	return 0;
 }
@@ -408,6 +731,9 @@ static unsigned long rockchip_rk3066_pll_recalc_rate(struct clk_hw *hw,
 		return prate;
 	}
 
+	if (pll->sel && pll->scaling)
+		return pll->scaling;
+
 	rockchip_rk3066_pll_get_params(pll, &cur);
 
 	rate64 *= cur.nf;
@@ -481,9 +807,18 @@ static int rockchip_rk3066_pll_set_rate(struct clk_hw *hw, unsigned long drate,
 {
 	struct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);
 	const struct rockchip_pll_rate_table *rate;
+	unsigned long old_rate = rockchip_rk3066_pll_recalc_rate(hw, prate);
+	struct regmap *grf = pll->ctx->grf;
+	int ret;
 
-	pr_debug("%s: changing %s to %lu with a parent rate of %lu\n",
-		 __func__, clk_hw_get_name(hw), drate, prate);
+	if (IS_ERR(grf)) {
+		pr_debug("%s: grf regmap not available, aborting rate change\n",
+			 __func__);
+		return PTR_ERR(grf);
+	}
+
+	pr_debug("%s: changing %s from %lu to %lu with a parent rate of %lu\n",
+		 __func__, clk_hw_get_name(hw), old_rate, drate, prate);
 
 	/* Get required rate settings from table */
 	rate = rockchip_get_pll_settings(pll, drate);
@@ -493,7 +828,11 @@ static int rockchip_rk3066_pll_set_rate(struct clk_hw *hw, unsigned long drate,
 		return -EINVAL;
 	}
 
-	return rockchip_rk3066_pll_set_params(pll, rate);
+	ret = rockchip_rk3066_pll_set_params(pll, rate);
+	if (ret)
+		pll->scaling = 0;
+
+	return ret;
 }
 
 static int rockchip_rk3066_pll_enable(struct clk_hw *hw)
@@ -594,19 +933,20 @@ static const struct clk_ops rockchip_rk3066_pll_clk_ops = {
 static int rockchip_rk3399_pll_wait_lock(struct rockchip_clk_pll *pll)
 {
 	u32 pllcon;
-	int delay = 24000000;
-
-	/* poll check the lock status in rk3399 xPLLCON2 */
-	while (delay > 0) {
-		pllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(2));
-		if (pllcon & RK3399_PLLCON2_LOCK_STATUS)
-			return 0;
+	int ret;
 
-		delay--;
-	}
+	/*
+	 * Lock time typical 250, max 500 input clock cycles @24MHz
+	 * So define a very safe maximum of 1000us, meaning 24000 cycles.
+	 */
+	ret = readl_relaxed_poll_timeout(pll->reg_base + RK3399_PLLCON(2),
+					 pllcon,
+					 pllcon & RK3399_PLLCON2_LOCK_STATUS,
+					 0, 1000);
+	if (ret)
+		pr_err("%s: timeout waiting for pll to lock\n", __func__);
 
-	pr_err("%s: timeout waiting for pll to lock\n", __func__);
-	return -ETIMEDOUT;
+	return ret;
 }
 
 static void rockchip_rk3399_pll_get_params(struct rockchip_clk_pll *pll,
@@ -642,6 +982,9 @@ static unsigned long rockchip_rk3399_pll_recalc_rate(struct clk_hw *hw,
 	struct rockchip_pll_rate_table cur;
 	u64 rate64 = prate;
 
+	if (pll->sel && pll->scaling)
+		return pll->scaling;
+
 	rockchip_rk3399_pll_get_params(pll, &cur);
 
 	rate64 *= cur.fbdiv;
@@ -685,6 +1028,11 @@ static int rockchip_rk3399_pll_set_params(struct rockchip_clk_pll *pll,
 		rate_change_remuxed = 1;
 	}
 
+	/* set pll power down */
+	writel(HIWORD_UPDATE(RK3399_PLLCON3_PWRDOWN,
+			     RK3399_PLLCON3_PWRDOWN, 0),
+	       pll->reg_base + RK3399_PLLCON(3));
+
 	/* update pll values */
 	writel_relaxed(HIWORD_UPDATE(rate->fbdiv, RK3399_PLLCON0_FBDIV_MASK,
 						  RK3399_PLLCON0_FBDIV_SHIFT),
@@ -708,6 +1056,11 @@ static int rockchip_rk3399_pll_set_params(struct rockchip_clk_pll *pll,
 					    RK3399_PLLCON3_DSMPD_SHIFT),
 		       pll->reg_base + RK3399_PLLCON(3));
 
+	/* set pll power up */
+	writel(HIWORD_UPDATE(0,
+			     RK3399_PLLCON3_PWRDOWN, 0),
+	       pll->reg_base + RK3399_PLLCON(3));
+
 	/* wait for the pll to lock */
 	ret = rockchip_rk3399_pll_wait_lock(pll);
 	if (ret) {
@@ -727,9 +1080,11 @@ static int rockchip_rk3399_pll_set_rate(struct clk_hw *hw, unsigned long drate,
 {
 	struct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);
 	const struct rockchip_pll_rate_table *rate;
+	unsigned long old_rate = rockchip_rk3399_pll_recalc_rate(hw, prate);
+	int ret;
 
-	pr_debug("%s: changing %s to %lu with a parent rate of %lu\n",
-		 __func__, __clk_get_name(hw->clk), drate, prate);
+	pr_debug("%s: changing %s from %lu to %lu with a parent rate of %lu\n",
+		 __func__, __clk_get_name(hw->clk), old_rate, drate, prate);
 
 	/* Get required rate settings from table */
 	rate = rockchip_get_pll_settings(pll, drate);
@@ -739,7 +1094,11 @@ static int rockchip_rk3399_pll_set_rate(struct clk_hw *hw, unsigned long drate,
 		return -EINVAL;
 	}
 
-	return rockchip_rk3399_pll_set_params(pll, rate);
+	ret = rockchip_rk3399_pll_set_params(pll, rate);
+	if (ret)
+		pll->scaling = 0;
+
+	return ret;
 }
 
 static int rockchip_rk3399_pll_enable(struct clk_hw *hw)
@@ -833,6 +1192,84 @@ static const struct clk_ops rockchip_rk3399_pll_clk_ops = {
 	.init = rockchip_rk3399_pll_init,
 };
 
+#ifdef CONFIG_ROCKCHIP_CLK_COMPENSATION
+int rockchip_pll_clk_compensation(struct clk *clk, int ppm)
+{
+	struct clk *parent = clk_get_parent(clk);
+	struct rockchip_clk_pll *pll;
+	static u32 frac, fbdiv;
+	bool negative;
+	u32 pllcon, pllcon0, pllcon2, fbdiv_mask, frac_mask, frac_shift;
+	u64 fracdiv, m, n;
+
+	if ((ppm > 1000) || (ppm < -1000))
+		return -EINVAL;
+
+	if (IS_ERR_OR_NULL(parent))
+		return -EINVAL;
+
+	pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+	if (!pll)
+		return -EINVAL;
+
+	switch (pll->type) {
+	case pll_rk3036:
+	case pll_rk3328:
+		pllcon0 = RK3036_PLLCON(0);
+		pllcon2 = RK3036_PLLCON(2);
+		fbdiv_mask = RK3036_PLLCON0_FBDIV_MASK;
+		frac_mask = RK3036_PLLCON2_FRAC_MASK;
+		frac_shift = RK3036_PLLCON2_FRAC_SHIFT;
+		if (!frac)
+			writel(HIWORD_UPDATE(RK3036_PLLCON1_PLLPDSEL,
+					     RK3036_PLLCON1_PLLPDSEL, 0),
+			       pll->reg_base + RK3036_PLLCON(1));
+		break;
+	case pll_rk3066:
+		return -EINVAL;
+	case pll_rk3399:
+		pllcon0 = RK3399_PLLCON(0);
+		pllcon2 = RK3399_PLLCON(2);
+		fbdiv_mask = RK3399_PLLCON0_FBDIV_MASK;
+		frac_mask = RK3399_PLLCON2_FRAC_MASK;
+		frac_shift = RK3399_PLLCON2_FRAC_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	negative = !!(ppm & BIT(31));
+	ppm = negative ? ~ppm + 1 : ppm;
+
+	if (!frac) {
+		frac = readl_relaxed(pll->reg_base + pllcon2) & frac_mask;
+		fbdiv = readl_relaxed(pll->reg_base + pllcon0) & fbdiv_mask;
+	}
+
+	/*
+	 *   delta frac                 frac          ppm
+	 * -------------- = (fbdiv + ----------) * ---------
+	 *    1 << 24                 1 << 24       1000000
+	 *
+	 */
+	m = div64_u64((uint64_t)frac * ppm, 1000000);
+	n = div64_u64((uint64_t)ppm << 24, 1000000) * fbdiv;
+
+	fracdiv = negative ? frac - (m + n) : frac + (m + n);
+
+	if (!frac || fracdiv > frac_mask)
+		return -EINVAL;
+
+	pllcon = readl_relaxed(pll->reg_base + pllcon2);
+	pllcon &= ~(frac_mask << frac_shift);
+	pllcon |= fracdiv << frac_shift;
+	writel_relaxed(pllcon, pll->reg_base + pllcon2);
+
+	return  0;
+}
+EXPORT_SYMBOL(rockchip_pll_clk_compensation);
+#endif
+
 /*
  * Common registering of pll clocks
  */
@@ -846,7 +1283,7 @@ struct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,
 		unsigned long flags, u8 clk_pll_flags)
 {
 	const char *pll_parents[3];
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	struct rockchip_clk_pll *pll;
 	struct clk_mux *pll_mux;
 	struct clk *pll_clk, *mux_clk;
@@ -905,8 +1342,12 @@ struct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,
 	/* now create the actual pll */
 	init.name = pll_name;
 
+#ifndef CONFIG_ROCKCHIP_LOW_PERFORMANCE
 	/* keep all plls untouched for now */
 	init.flags = flags | CLK_IGNORE_UNUSED;
+#else
+	init.flags = flags;
+#endif
 
 	init.parent_names = &parent_names[0];
 	init.num_parents = 1;
@@ -936,18 +1377,22 @@ struct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,
 		else
 			init.ops = &rockchip_rk3036_pll_clk_ops;
 		break;
+#ifdef CONFIG_ROCKCHIP_PLL_RK3066
 	case pll_rk3066:
 		if (!pll->rate_table || IS_ERR(ctx->grf))
 			init.ops = &rockchip_rk3066_pll_clk_norate_ops;
 		else
 			init.ops = &rockchip_rk3066_pll_clk_ops;
 		break;
+#endif
+#ifdef CONFIG_ROCKCHIP_PLL_RK3399
 	case pll_rk3399:
 		if (!pll->rate_table)
 			init.ops = &rockchip_rk3399_pll_clk_norate_ops;
 		else
 			init.ops = &rockchip_rk3399_pll_clk_ops;
 		break;
+#endif
 	default:
 		pr_warn("%s: Unknown pll type for pll clk %s\n",
 			__func__, name);
@@ -978,3 +1423,316 @@ struct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,
 	kfree(pll);
 	return mux_clk;
 }
+
+#ifdef CONFIG_ROCKCHIP_CLK_BOOST
+static unsigned long rockchip_pll_con_to_rate(struct rockchip_clk_pll *pll,
+					      u32 con0, u32 con1)
+{
+	switch (pll->type) {
+	case pll_rk3036:
+	case pll_rk3328:
+		return rockchip_rk3036_pll_con_to_rate(pll, con0, con1);
+	case pll_rk3066:
+		break;
+	case pll_rk3399:
+		break;
+	default:
+		pr_warn("%s: Unknown pll type\n", __func__);
+	}
+
+	return 0;
+}
+
+void rockchip_boost_init(struct clk_hw *hw)
+{
+	struct rockchip_clk_pll *pll;
+	struct device_node *np;
+	u32 value, con0, con1;
+
+	if (!hw)
+		return;
+	pll = to_rockchip_clk_pll(hw);
+	np = of_parse_phandle(pll->ctx->cru_node, "rockchip,boost", 0);
+	if (!np) {
+		pr_debug("%s: failed to get boost np\n", __func__);
+		return;
+	}
+	pll->boost = syscon_node_to_regmap(np);
+	if (IS_ERR(pll->boost)) {
+		pr_debug("%s: failed to get boost regmap\n", __func__);
+		return;
+	}
+
+	if (!of_property_read_u32(np, "rockchip,boost-low-con0", &con0) &&
+	    !of_property_read_u32(np, "rockchip,boost-low-con1", &con1)) {
+		pr_debug("boost-low-con=0x%x 0x%x\n", con0, con1);
+		regmap_write(pll->boost, BOOST_PLL_L_CON(0),
+			     HIWORD_UPDATE(con0, BOOST_PLL_CON_MASK, 0));
+		regmap_write(pll->boost, BOOST_PLL_L_CON(1),
+			     HIWORD_UPDATE(con1, BOOST_PLL_CON_MASK, 0));
+		pll->boost_low_rate = rockchip_pll_con_to_rate(pll, con0,
+							       con1);
+		pr_debug("boost-low-rate=%lu\n", pll->boost_low_rate);
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-high-con0", &con0) &&
+	    !of_property_read_u32(np, "rockchip,boost-high-con1", &con1)) {
+		pr_debug("boost-high-con=0x%x 0x%x\n", con0, con1);
+		regmap_write(pll->boost, BOOST_PLL_H_CON(0),
+			     HIWORD_UPDATE(con0, BOOST_PLL_CON_MASK, 0));
+		regmap_write(pll->boost, BOOST_PLL_H_CON(1),
+			     HIWORD_UPDATE(con1, BOOST_PLL_CON_MASK, 0));
+		pll->boost_high_rate = rockchip_pll_con_to_rate(pll, con0,
+								con1);
+		pr_debug("boost-high-rate=%lu\n", pll->boost_high_rate);
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-backup-pll", &value)) {
+		pr_debug("boost-backup-pll=0x%x\n", value);
+		regmap_write(pll->boost, BOOST_CLK_CON,
+			     HIWORD_UPDATE(value, BOOST_BACKUP_PLL_MASK,
+					   BOOST_BACKUP_PLL_SHIFT));
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-backup-pll-usage",
+				  &pll->boost_backup_pll_usage)) {
+		pr_debug("boost-backup-pll-usage=0x%x\n",
+			 pll->boost_backup_pll_usage);
+		regmap_write(pll->boost, BOOST_CLK_CON,
+			     HIWORD_UPDATE(pll->boost_backup_pll_usage,
+					   BOOST_BACKUP_PLL_USAGE_MASK,
+					   BOOST_BACKUP_PLL_USAGE_SHIFT));
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-switch-threshold",
+				  &value)) {
+		pr_debug("boost-switch-threshold=0x%x\n", value);
+		regmap_write(pll->boost, BOOST_SWITCH_THRESHOLD, value);
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-statis-threshold",
+				  &value)) {
+		pr_debug("boost-statis-threshold=0x%x\n", value);
+		regmap_write(pll->boost, BOOST_STATIS_THRESHOLD, value);
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-statis-enable",
+				  &value)) {
+		pr_debug("boost-statis-enable=0x%x\n", value);
+		regmap_write(pll->boost, BOOST_BOOST_CON,
+			     HIWORD_UPDATE(value, BOOST_STATIS_ENABLE_MASK,
+					   BOOST_STATIS_ENABLE_SHIFT));
+	}
+	if (!of_property_read_u32(np, "rockchip,boost-enable", &value)) {
+		pr_debug("boost-enable=0x%x\n", value);
+		regmap_write(pll->boost, BOOST_BOOST_CON,
+			     HIWORD_UPDATE(value, BOOST_ENABLE_MASK,
+					   BOOST_ENABLE_SHIFT));
+		if (value)
+			pll->boost_enabled = true;
+	}
+#ifdef CONFIG_DEBUG_FS
+	if (pll->boost_enabled) {
+		mutex_lock(&clk_boost_lock);
+		hlist_add_head(&pll->debug_node, &clk_boost_list);
+		mutex_unlock(&clk_boost_lock);
+	}
+#endif
+}
+
+void rockchip_boost_enable_recovery_sw_low(struct clk_hw *hw)
+{
+	struct rockchip_clk_pll *pll;
+	unsigned int val;
+
+	if (!hw)
+		return;
+	pll = to_rockchip_clk_pll(hw);
+	if (!pll->boost_enabled)
+		return;
+
+	regmap_write(pll->boost, BOOST_BOOST_CON,
+		     HIWORD_UPDATE(1, BOOST_RECOVERY_MASK,
+				   BOOST_RECOVERY_SHIFT));
+	do {
+		regmap_read(pll->boost, BOOST_FSM_STATUS, &val);
+	} while (!(val & BOOST_BUSY_STATE));
+
+	regmap_write(pll->boost, BOOST_BOOST_CON,
+		     HIWORD_UPDATE(1, BOOST_SW_CTRL_MASK,
+				   BOOST_SW_CTRL_SHIFT) |
+		     HIWORD_UPDATE(1, BOOST_LOW_FREQ_EN_MASK,
+				   BOOST_LOW_FREQ_EN_SHIFT));
+}
+
+static void rockchip_boost_disable_low(struct rockchip_clk_pll *pll)
+{
+	if (!pll->boost_enabled)
+		return;
+
+	regmap_write(pll->boost, BOOST_BOOST_CON,
+		     HIWORD_UPDATE(0, BOOST_LOW_FREQ_EN_MASK,
+				   BOOST_LOW_FREQ_EN_SHIFT));
+}
+
+void rockchip_boost_disable_recovery_sw(struct clk_hw *hw)
+{
+	struct rockchip_clk_pll *pll;
+
+	if (!hw)
+		return;
+	pll = to_rockchip_clk_pll(hw);
+	if (!pll->boost_enabled)
+		return;
+
+	regmap_write(pll->boost, BOOST_BOOST_CON,
+		     HIWORD_UPDATE(0, BOOST_RECOVERY_MASK,
+				   BOOST_RECOVERY_SHIFT));
+	regmap_write(pll->boost, BOOST_BOOST_CON,
+		     HIWORD_UPDATE(0, BOOST_SW_CTRL_MASK,
+				   BOOST_SW_CTRL_SHIFT));
+}
+
+void rockchip_boost_add_core_div(struct clk_hw *hw, unsigned long prate)
+{
+	struct rockchip_clk_pll *pll;
+	unsigned int div;
+
+	if (!hw)
+		return;
+	pll = to_rockchip_clk_pll(hw);
+	if (!pll->boost_enabled || pll->boost_backup_pll_rate == prate)
+		return;
+
+	/* todo */
+	if (pll->boost_backup_pll_usage == BOOST_BACKUP_PLL_USAGE_TARGET)
+		return;
+	/*
+	 * cpu clock rate should be less than or equal to
+	 * low rate when change pll rate in boost module
+	 */
+	if (pll->boost_low_rate && prate > pll->boost_low_rate) {
+		div =  DIV_ROUND_UP(prate, pll->boost_low_rate) - 1;
+		regmap_write(pll->boost, BOOST_CLK_CON,
+			     HIWORD_UPDATE(div, BOOST_CORE_DIV_MASK,
+					   BOOST_CORE_DIV_SHIFT));
+		pll->boost_backup_pll_rate = prate;
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+
+static int boost_summary_show(struct seq_file *s, void *data)
+{
+	struct rockchip_clk_pll *pll = (struct rockchip_clk_pll *)s->private;
+	u32 boost_count = 0;
+	u32 freq_cnt0 = 0, freq_cnt1 = 0;
+	u64 freq_cnt = 0, high_freq_time = 0;
+	u32 short_count = 0, short_threshold = 0;
+	u32 interval_time = 0;
+
+	seq_puts(s, " device    boost_count   high_freq_count  high_freq_time  short_count  short_threshold  interval_count\n");
+	seq_puts(s, "------------------------------------------------------------------------------------------------------\n");
+	seq_printf(s, " %s\n", clk_hw_get_name(&pll->hw));
+
+	regmap_read(pll->boost, BOOST_SWITCH_CNT, &boost_count);
+
+	regmap_read(pll->boost, BOOST_HIGH_PERF_CNT0, &freq_cnt0);
+	regmap_read(pll->boost, BOOST_HIGH_PERF_CNT1, &freq_cnt1);
+	freq_cnt = ((u64)freq_cnt1 << 32) + (u64)freq_cnt0;
+	high_freq_time = freq_cnt;
+	do_div(high_freq_time, 24);
+
+	regmap_read(pll->boost, BOOST_SHORT_SWITCH_CNT, &short_count);
+	regmap_read(pll->boost, BOOST_STATIS_THRESHOLD, &short_threshold);
+	regmap_read(pll->boost, BOOST_SWITCH_THRESHOLD, &interval_time);
+
+	seq_printf(s, "%22u %17llu %15llu %12u %16u %15u\n",
+		   boost_count, freq_cnt, high_freq_time, short_count,
+		   short_threshold, interval_time);
+
+	return 0;
+}
+
+static int boost_summary_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, boost_summary_show, inode->i_private);
+}
+
+static const struct file_operations boost_summary_fops = {
+	.open		= boost_summary_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int boost_config_show(struct seq_file *s, void *data)
+{
+	struct rockchip_clk_pll *pll = (struct rockchip_clk_pll *)s->private;
+
+	seq_printf(s, "boost_enabled:   %d\n", pll->boost_enabled);
+	seq_printf(s, "boost_low_rate:  %lu\n", pll->boost_low_rate);
+	seq_printf(s, "boost_high_rate: %lu\n", pll->boost_high_rate);
+
+	return 0;
+}
+
+static int boost_config_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, boost_config_show, inode->i_private);
+}
+
+static const struct file_operations boost_config_fops = {
+	.open		= boost_config_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int boost_debug_create_one(struct rockchip_clk_pll *pll,
+				  struct dentry *rootdir)
+{
+	struct dentry *pdentry, *d;
+
+	pdentry = debugfs_lookup(clk_hw_get_name(&pll->hw), rootdir);
+	if (!pdentry) {
+		pr_err("%s: failed to lookup %s dentry\n", __func__,
+		       clk_hw_get_name(&pll->hw));
+		return -ENOMEM;
+	}
+
+	d = debugfs_create_file("boost_summary", 0444, pdentry,
+				pll, &boost_summary_fops);
+	if (!d) {
+		pr_err("%s: failed to create boost_summary file\n", __func__);
+		return -ENOMEM;
+	}
+
+	d = debugfs_create_file("boost_config", 0444, pdentry,
+				pll, &boost_config_fops);
+	if (!d) {
+		pr_err("%s: failed to create boost config file\n", __func__);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int __init boost_debug_init(void)
+{
+	struct rockchip_clk_pll *pll;
+	struct dentry *rootdir;
+
+	rootdir = debugfs_lookup("clk", NULL);
+	if (!rootdir) {
+		pr_err("%s: failed to lookup clk dentry\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_lock(&clk_boost_lock);
+
+	hlist_for_each_entry(pll, &clk_boost_list, debug_node)
+		boost_debug_create_one(pll, rootdir);
+
+	mutex_unlock(&clk_boost_lock);
+
+	return 0;
+}
+late_initcall(boost_debug_init);
+#endif /* CONFIG_DEBUG_FS */
+#endif /* CONFIG_ROCKCHIP_CLK_BOOST */
diff --git a/drivers/clk/rockchip/clk-px30.c b/drivers/clk/rockchip/clk-px30.c
index 601a77f1a..ceb3fb7bc 100644
--- a/drivers/clk/rockchip/clk-px30.c
+++ b/drivers/clk/rockchip/clk-px30.c
@@ -16,11 +16,13 @@
 #include <linux/clk-provider.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/rockchip/cpu.h>
 #include <linux/syscore_ops.h>
 #include <dt-bindings/clock/px30-cru.h>
 #include "clk.h"
 
 #define PX30_GRF_SOC_STATUS0		0x480
+#define PX30_FRAC_MAX_PRATE		600000000
 
 enum px30_plls {
 	apll, dpll, cpll, npll, apll_b_h, apll_b_l,
@@ -132,13 +134,15 @@ static struct rockchip_cpuclk_rate_table px30_cpuclk_rates[] __initdata = {
 };
 
 static const struct rockchip_cpuclk_reg_data px30_cpuclk_data = {
-	.core_reg = PX30_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0xf,
+	.core_reg[0] = PX30_CLKSEL_CON(0),
+	.div_core_shift[0] = 0,
+	.div_core_mask[0] = 0xf,
+	.num_cores = 1,
 	.mux_core_alt = 1,
 	.mux_core_main = 0,
 	.mux_core_shift = 7,
 	.mux_core_mask = 0x1,
+	.pll_name = "pll_apll",
 };
 
 PNAME(mux_pll_p)		= { "xin24m"};
@@ -146,15 +150,17 @@ PNAME(mux_usb480m_p)		= { "xin24m", "usb480m_phy", "clk_rtc32k_pmu" };
 PNAME(mux_armclk_p)		= { "apll_core", "gpll_core" };
 PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr" };
 PNAME(mux_ddrstdby_p)		= { "clk_ddrphy1x", "clk_stdby_2wrap" };
-PNAME(mux_4plls_p)		= { "gpll", "dummy_cpll", "usb480m", "npll" };
+PNAME(mux_gpll_dmycpll_usb480m_npll_p)		= { "gpll", "dummy_cpll", "usb480m", "npll" };
+PNAME(mux_gpll_dmycpll_usb480m_dmynpll_p)	= { "gpll", "dummy_cpll", "usb480m", "dummy_npll" };
 PNAME(mux_cpll_npll_p)		= { "cpll", "npll" };
 PNAME(mux_npll_cpll_p)		= { "npll", "cpll" };
 PNAME(mux_gpll_cpll_p)		= { "gpll", "dummy_cpll" };
-PNAME(mux_gpll_npll_p)		= { "gpll", "npll" };
+PNAME(mux_gpll_npll_p)		= { "gpll", "dummy_npll" };
 PNAME(mux_gpll_xin24m_p)		= { "gpll", "xin24m"};
-PNAME(mux_gpll_cpll_npll_p)		= { "gpll", "dummy_cpll", "npll" };
-PNAME(mux_gpll_cpll_npll_xin24m_p)	= { "gpll", "dummy_cpll", "npll", "xin24m" };
-PNAME(mux_gpll_xin24m_npll_p)		= { "gpll", "xin24m", "npll"};
+PNAME(mux_xin24m_gpll_p)		= { "xin24m", "gpll"};
+PNAME(mux_gpll_cpll_npll_p)		= { "gpll", "dummy_cpll", "dummy_npll" };
+PNAME(mux_gpll_cpll_npll_xin24m_p)	= { "gpll", "dummy_cpll", "dummy_npll", "xin24m" };
+PNAME(mux_gpll_xin24m_npll_p)		= { "gpll", "xin24m", "dummy_npll"};
 PNAME(mux_pdm_p)		= { "clk_pdm_src", "clk_pdm_frac" };
 PNAME(mux_i2s0_tx_p)		= { "clk_i2s0_tx_src", "clk_i2s0_tx_frac", "mclk_i2s0_tx_in", "xin12m"};
 PNAME(mux_i2s0_rx_p)		= { "clk_i2s0_rx_src", "clk_i2s0_rx_frac", "mclk_i2s0_rx_in", "xin12m"};
@@ -166,15 +172,19 @@ PNAME(mux_i2s1_out_p)		= { "clk_i2s1", "xin12m"};
 PNAME(mux_i2s2_out_p)		= { "clk_i2s2", "xin12m"};
 PNAME(mux_i2s0_tx_rx_p)		= { "clk_i2s0_tx_mux", "clk_i2s0_rx_mux"};
 PNAME(mux_i2s0_rx_tx_p)		= { "clk_i2s0_rx_mux", "clk_i2s0_tx_mux"};
-PNAME(mux_uart_src_p)		= { "gpll", "xin24m", "usb480m", "npll" };
+PNAME(mux_uart_src_p)		= { "gpll", "xin24m", "usb480m", "dummy_npll" };
 PNAME(mux_uart1_p)		= { "clk_uart1_src", "clk_uart1_np5", "clk_uart1_frac" };
 PNAME(mux_uart2_p)		= { "clk_uart2_src", "clk_uart2_np5", "clk_uart2_frac" };
 PNAME(mux_uart3_p)		= { "clk_uart3_src", "clk_uart3_np5", "clk_uart3_frac" };
 PNAME(mux_uart4_p)		= { "clk_uart4_src", "clk_uart4_np5", "clk_uart4_frac" };
 PNAME(mux_uart5_p)		= { "clk_uart5_src", "clk_uart5_np5", "clk_uart5_frac" };
-PNAME(mux_cif_out_p)		= { "xin24m", "dummy_cpll", "npll", "usb480m" };
+PNAME(mux_cif_out_p)		= { "xin24m", "dummy_cpll", "dummy_npll", "usb480m" };
 PNAME(mux_dclk_vopb_p)		= { "dclk_vopb_src", "dclk_vopb_frac", "xin24m" };
 PNAME(mux_dclk_vopl_p)		= { "dclk_vopl_src", "dclk_vopl_frac", "xin24m" };
+PNAME(mux_nandc_p)		= { "clk_nandc_div", "clk_nandc_div50" };
+PNAME(mux_sdio_p)		= { "clk_sdio_div", "clk_sdio_div50" };
+PNAME(mux_emmc_p)		= { "clk_emmc_div", "clk_emmc_div50" };
+PNAME(mux_sdmmc_p)		= { "clk_sdmmc_div", "clk_sdmmc_div50" };
 PNAME(mux_gmac_p)		= { "clk_gmac_src", "gmac_clkin" };
 PNAME(mux_gmac_rmii_sel_p)	= { "clk_gmac_rx_tx_div20", "clk_gmac_rx_tx_div2" };
 PNAME(mux_rtc32k_pmu_p)		= { "xin32k", "pmu_pvtm_32k", "clk_rtc32k_frac", };
@@ -213,11 +223,11 @@ static struct rockchip_clk_branch px30_pdm_fracmux __initdata =
 			PX30_CLKSEL_CON(26), 15, 1, MFLAGS);
 
 static struct rockchip_clk_branch px30_i2s0_tx_fracmux __initdata =
-	MUX(0, "clk_i2s0_tx_mux", mux_i2s0_tx_p, CLK_SET_RATE_PARENT,
+	MUX(SCLK_I2S0_TX_MUX, "clk_i2s0_tx_mux", mux_i2s0_tx_p, CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(28), 10, 2, MFLAGS);
 
 static struct rockchip_clk_branch px30_i2s0_rx_fracmux __initdata =
-	MUX(0, "clk_i2s0_rx_mux", mux_i2s0_rx_p, CLK_SET_RATE_PARENT,
+	MUX(SCLK_I2S0_RX_MUX, "clk_i2s0_rx_mux", mux_i2s0_rx_p, CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(58), 10, 2, MFLAGS);
 
 static struct rockchip_clk_branch px30_i2s1_fracmux __initdata =
@@ -305,17 +315,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 			PX30_CLKGATE_CON(17), 4, GFLAGS),
 
 	/* PD_GPU */
-	COMPOSITE_NODIV(0, "clk_gpu_src", mux_4plls_p, 0,
-			PX30_CLKSEL_CON(1), 6, 2, MFLAGS,
-			PX30_CLKGATE_CON(0), 8, GFLAGS),
-	COMPOSITE_NOMUX(0, "clk_gpu_div", "clk_gpu_src", 0,
-			PX30_CLKSEL_CON(1), 0, 4, DFLAGS,
-			PX30_CLKGATE_CON(0), 12, GFLAGS),
-	COMPOSITE_NOMUX_HALFDIV(0, "clk_gpu_np5", "clk_gpu_src", 0,
-			PX30_CLKSEL_CON(1), 8, 4, DFLAGS,
-			PX30_CLKGATE_CON(0), 9, GFLAGS),
-	COMPOSITE_NODIV(SCLK_GPU, "clk_gpu", mux_gpu_p, CLK_SET_RATE_PARENT,
-			PX30_CLKSEL_CON(1), 15, 1, MFLAGS,
+	GATE(SCLK_GPU, "clk_gpu", "clk_gpu_src", 0,
 			PX30_CLKGATE_CON(0), 10, GFLAGS),
 	COMPOSITE_NOMUX(0, "aclk_gpu", "clk_gpu", CLK_IGNORE_UNUSED,
 			PX30_CLKSEL_CON(1), 13, 2, DFLAGS,
@@ -336,14 +336,9 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 			PX30_CLKGATE_CON(0), 7, GFLAGS),
 	GATE(0, "gpll_ddr", "gpll", CLK_IGNORE_UNUSED,
 			PX30_CLKGATE_CON(0), 13, GFLAGS),
-	COMPOSITE_NOGATE(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			PX30_CLKSEL_CON(2), 7, 1, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	COMPOSITE_NOGATE(0, "clk_ddrphy4x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			PX30_CLKSEL_CON(2), 7, 1, MFLAGS, 0, 3, DFLAGS),
-	FACTOR_GATE(0, "clk_ddrphy1x", "clk_ddrphy4x", CLK_IGNORE_UNUSED, 1, 4,
-			PX30_CLKGATE_CON(0), 14, GFLAGS),
-	FACTOR_GATE(0, "clk_stdby_2wrap", "clk_ddrphy4x", CLK_IGNORE_UNUSED, 1, 4,
-			PX30_CLKGATE_CON(1), 0, GFLAGS),
+	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p,
+			 CLK_IGNORE_UNUSED, PX30_CLKSEL_CON(2), 7, 1, 0, 3,
+			 ROCKCHIP_DDRCLK_SIP_V2),
 	COMPOSITE_NODIV(0, "clk_ddrstdby", mux_ddrstdby_p, CLK_IGNORE_UNUSED,
 			PX30_CLKSEL_CON(2), 4, 1, MFLAGS,
 			PX30_CLKGATE_CON(1), 13, GFLAGS),
@@ -428,16 +423,16 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "dclk_vopb_frac", "dclk_vopb_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(6), 0,
 			PX30_CLKGATE_CON(2), 3, GFLAGS,
-			&px30_dclk_vopb_fracmux),
+			&px30_dclk_vopb_fracmux, 0),
 	GATE(DCLK_VOPB, "dclk_vopb", "dclk_vopb_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(2), 4, GFLAGS),
-	COMPOSITE(0, "dclk_vopl_src", mux_npll_cpll_p, 0,
+	COMPOSITE(0, "dclk_vopl_src", mux_npll_cpll_p, CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
 			PX30_CLKSEL_CON(8), 11, 1, MFLAGS, 0, 8, DFLAGS,
 			PX30_CLKGATE_CON(2), 6, GFLAGS),
 	COMPOSITE_FRACMUX(0, "dclk_vopl_frac", "dclk_vopl_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(9), 0,
 			PX30_CLKGATE_CON(2), 7, GFLAGS,
-			&px30_dclk_vopl_fracmux),
+			&px30_dclk_vopl_fracmux, 0),
 	GATE(DCLK_VOPL, "dclk_vopl", "dclk_vopl_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(2), 8, GFLAGS),
 
@@ -468,16 +463,40 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	/* PD_MMC_NAND */
 	GATE(HCLK_MMC_NAND, "hclk_mmc_nand", "hclk_peri_pre", 0,
 			PX30_CLKGATE_CON(6), 0, GFLAGS),
-	COMPOSITE(SCLK_NANDC, "clk_nandc", mux_gpll_cpll_npll_p, 0,
+	COMPOSITE(SCLK_NANDC_DIV, "clk_nandc_div", mux_gpll_cpll_npll_p, 0,
 			PX30_CLKSEL_CON(15), 6, 2, MFLAGS, 0, 5, DFLAGS,
+			PX30_CLKGATE_CON(5), 11, GFLAGS),
+	COMPOSITE(SCLK_NANDC_DIV50, "clk_nandc_div50", mux_gpll_cpll_npll_p, 0,
+			PX30_CLKSEL_CON(15), 6, 2, MFLAGS, 8, 5, DFLAGS,
+			PX30_CLKGATE_CON(5), 12, GFLAGS),
+	COMPOSITE_NODIV(SCLK_NANDC, "clk_nandc", mux_nandc_p,
+			CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+			PX30_CLKSEL_CON(15), 15, 1, MFLAGS,
 			PX30_CLKGATE_CON(5), 13, GFLAGS),
 
-	COMPOSITE(SCLK_SDIO, "clk_sdio", mux_gpll_cpll_npll_xin24m_p, 0,
+	COMPOSITE(SCLK_SDIO_DIV, "clk_sdio_div", mux_gpll_cpll_npll_xin24m_p, 0,
 			PX30_CLKSEL_CON(18), 14, 2, MFLAGS, 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(6), 1, GFLAGS),
+	COMPOSITE_DIV_OFFSET(SCLK_SDIO_DIV50, "clk_sdio_div50",
+			mux_gpll_cpll_npll_xin24m_p, 0,
+			PX30_CLKSEL_CON(18), 14, 2, MFLAGS,
+			PX30_CLKSEL_CON(19), 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(6), 2, GFLAGS),
+	COMPOSITE_NODIV(SCLK_SDIO, "clk_sdio", mux_sdio_p,
+			CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+			PX30_CLKSEL_CON(19), 15, 1, MFLAGS,
 			PX30_CLKGATE_CON(6), 3, GFLAGS),
 
-	COMPOSITE(SCLK_EMMC, "clk_emmc", mux_gpll_cpll_npll_xin24m_p, 0,
+	COMPOSITE(SCLK_EMMC_DIV, "clk_emmc_div", mux_gpll_cpll_npll_xin24m_p, 0,
 			PX30_CLKSEL_CON(20), 14, 2, MFLAGS, 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(6), 4, GFLAGS),
+	COMPOSITE_DIV_OFFSET(SCLK_EMMC_DIV50, "clk_emmc_div50", mux_gpll_cpll_npll_xin24m_p, 0,
+			PX30_CLKSEL_CON(20), 14, 2, MFLAGS,
+			PX30_CLKSEL_CON(21), 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(6), 5, GFLAGS),
+	COMPOSITE_NODIV(SCLK_EMMC, "clk_emmc", mux_emmc_p,
+			CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+			PX30_CLKSEL_CON(21), 15, 1, MFLAGS,
 			PX30_CLKGATE_CON(6), 6, GFLAGS),
 
 	COMPOSITE(SCLK_SFC, "clk_sfc", mux_gpll_cpll_p, 0,
@@ -502,8 +521,16 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	/* PD_SDCARD */
 	GATE(0, "hclk_sdmmc_pre", "hclk_peri_pre", 0,
 			PX30_CLKGATE_CON(6), 12, GFLAGS),
-	COMPOSITE(SCLK_SDMMC, "clk_sdmmc", mux_gpll_cpll_npll_xin24m_p, 0,
+	COMPOSITE(SCLK_SDMMC_DIV, "clk_sdmmc_div", mux_gpll_cpll_npll_xin24m_p, 0,
 			PX30_CLKSEL_CON(16), 14, 2, MFLAGS, 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(6), 13, GFLAGS),
+	COMPOSITE_DIV_OFFSET(SCLK_SDMMC_DIV50, "clk_sdmmc_div50", mux_gpll_cpll_npll_xin24m_p, 0,
+			PX30_CLKSEL_CON(16), 14, 2, MFLAGS,
+			PX30_CLKSEL_CON(17), 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(6), 14, GFLAGS),
+	COMPOSITE_NODIV(SCLK_SDMMC, "clk_sdmmc", mux_sdmmc_p,
+			CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+			PX30_CLKSEL_CON(17), 15, 1, MFLAGS,
 			PX30_CLKGATE_CON(6), 15, GFLAGS),
 
 	/* PD_USB */
@@ -563,7 +590,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_pdm_frac", "clk_pdm_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(27), 0,
 			PX30_CLKGATE_CON(9), 10, GFLAGS,
-			&px30_pdm_fracmux),
+			&px30_pdm_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_PDM, "clk_pdm", "clk_pdm_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(9), 11, GFLAGS),
 
@@ -573,11 +600,11 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_i2s0_tx_frac", "clk_i2s0_tx_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(29), 0,
 			PX30_CLKGATE_CON(9), 13, GFLAGS,
-			&px30_i2s0_tx_fracmux),
+			&px30_i2s0_tx_fracmux, PX30_FRAC_MAX_PRATE),
 	COMPOSITE_NODIV(SCLK_I2S0_TX, "clk_i2s0_tx", mux_i2s0_tx_rx_p, CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(28), 12, 1, MFLAGS,
 			PX30_CLKGATE_CON(9), 14, GFLAGS),
-	COMPOSITE_NODIV(0, "clk_i2s0_tx_out_pre", mux_i2s0_tx_out_p, 0,
+	COMPOSITE_NODIV(0, "clk_i2s0_tx_out_pre", mux_i2s0_tx_out_p, CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(28), 14, 2, MFLAGS,
 			PX30_CLKGATE_CON(9), 15, GFLAGS),
 	GATE(SCLK_I2S0_TX_OUT, "clk_i2s0_tx_out", "clk_i2s0_tx_out_pre", CLK_SET_RATE_PARENT,
@@ -589,7 +616,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_i2s0_rx_frac", "clk_i2s0_rx_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(59), 0,
 			PX30_CLKGATE_CON(17), 1, GFLAGS,
-			&px30_i2s0_rx_fracmux),
+			&px30_i2s0_rx_fracmux, PX30_FRAC_MAX_PRATE),
 	COMPOSITE_NODIV(SCLK_I2S0_RX, "clk_i2s0_rx", mux_i2s0_rx_tx_p, CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(58), 12, 1, MFLAGS,
 			PX30_CLKGATE_CON(17), 2, GFLAGS),
@@ -605,10 +632,10 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_i2s1_frac", "clk_i2s1_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(31), 0,
 			PX30_CLKGATE_CON(10), 1, GFLAGS,
-			&px30_i2s1_fracmux),
+			&px30_i2s1_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_I2S1, "clk_i2s1", "clk_i2s1_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(10), 2, GFLAGS),
-	COMPOSITE_NODIV(0, "clk_i2s1_out_pre", mux_i2s1_out_p, 0,
+	COMPOSITE_NODIV(0, "clk_i2s1_out_pre", mux_i2s1_out_p, CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(30), 15, 1, MFLAGS,
 			PX30_CLKGATE_CON(10), 3, GFLAGS),
 	GATE(SCLK_I2S1_OUT, "clk_i2s1_out", "clk_i2s1_out_pre", CLK_SET_RATE_PARENT,
@@ -620,7 +647,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_i2s2_frac", "clk_i2s2_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(33), 0,
 			PX30_CLKGATE_CON(10), 5, GFLAGS,
-			&px30_i2s2_fracmux),
+			&px30_i2s2_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_I2S2, "clk_i2s2", "clk_i2s2_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(10), 6, GFLAGS),
 	COMPOSITE_NODIV(0, "clk_i2s2_out_pre", mux_i2s2_out_p, 0,
@@ -638,7 +665,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_uart1_frac", "clk_uart1_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(36), 0,
 			PX30_CLKGATE_CON(10), 14, GFLAGS,
-			&px30_uart1_fracmux),
+			&px30_uart1_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_UART1, "clk_uart1", "clk_uart1_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(10), 15, GFLAGS),
 
@@ -651,7 +678,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_uart2_frac", "clk_uart2_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(39), 0,
 			PX30_CLKGATE_CON(11), 2, GFLAGS,
-			&px30_uart2_fracmux),
+			&px30_uart2_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_UART2, "clk_uart2", "clk_uart2_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(11), 3, GFLAGS),
 
@@ -664,7 +691,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_uart3_frac", "clk_uart3_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(42), 0,
 			PX30_CLKGATE_CON(11), 6, GFLAGS,
-			&px30_uart3_fracmux),
+			&px30_uart3_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_UART3, "clk_uart3", "clk_uart3_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(11), 7, GFLAGS),
 
@@ -677,7 +704,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_uart4_frac", "clk_uart4_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(45), 0,
 			PX30_CLKGATE_CON(11), 10, GFLAGS,
-			&px30_uart4_fracmux),
+			&px30_uart4_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_UART4, "clk_uart4", "clk_uart4_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(11), 11, GFLAGS),
 
@@ -690,7 +717,7 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_uart5_frac", "clk_uart5_src", CLK_SET_RATE_PARENT,
 			PX30_CLKSEL_CON(48), 0,
 			PX30_CLKGATE_CON(11), 14, GFLAGS,
-			&px30_uart5_fracmux),
+			&px30_uart5_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_UART5, "clk_uart5", "clk_uart5_mux", CLK_SET_RATE_PARENT,
 			PX30_CLKGATE_CON(11), 15, GFLAGS),
 
@@ -738,12 +765,6 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 	COMPOSITE_NOMUX(SCLK_SARADC, "clk_saradc", "xin24m", 0,
 			PX30_CLKSEL_CON(55), 0, 11, DFLAGS,
 			PX30_CLKGATE_CON(12), 10, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_OTP, "clk_otp", "xin24m", 0,
-			PX30_CLKSEL_CON(56), 0, 3, DFLAGS,
-			PX30_CLKGATE_CON(12), 11, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_OTP_USR, "clk_otp_usr", "clk_otp", 0,
-			PX30_CLKSEL_CON(56), 4, 2, DFLAGS,
-			PX30_CLKGATE_CON(13), 6, GFLAGS),
 
 	GATE(0, "clk_cpu_boost", "xin24m", CLK_IGNORE_UNUSED,
 			PX30_CLKGATE_CON(12), 12, GFLAGS),
@@ -879,6 +900,18 @@ static struct rockchip_clk_branch px30_clk_branches[] __initdata = {
 			PX30_CLKGATE_CON(8), 3, GFLAGS),
 };
 
+static struct rockchip_clk_branch px30_gpu_src_clk[] __initdata = {
+	COMPOSITE(0, "clk_gpu_src", mux_gpll_dmycpll_usb480m_dmynpll_p, 0,
+			PX30_CLKSEL_CON(1), 6, 2, MFLAGS, 0, 4, DFLAGS,
+			PX30_CLKGATE_CON(0), 8, GFLAGS),
+};
+
+static struct rockchip_clk_branch rk3326_gpu_src_clk[] __initdata = {
+	COMPOSITE(0, "clk_gpu_src", mux_gpll_dmycpll_usb480m_npll_p, 0,
+			PX30_CLKSEL_CON(1), 6, 2, MFLAGS, 0, 4, DFLAGS,
+			PX30_CLKGATE_CON(0), 8, GFLAGS),
+};
+
 static struct rockchip_clk_branch px30_clk_pmu_branches[] __initdata = {
 	/*
 	 * Clock-Architecture Diagram 2
@@ -887,7 +920,7 @@ static struct rockchip_clk_branch px30_clk_pmu_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_rtc32k_frac", "xin24m", CLK_IGNORE_UNUSED,
 			PX30_PMU_CLKSEL_CON(1), 0,
 			PX30_PMU_CLKGATE_CON(0), 13, GFLAGS,
-			&px30_rtc32k_pmu_fracmux),
+			&px30_rtc32k_pmu_fracmux, 0),
 
 	COMPOSITE_NOMUX(XIN24M_DIV, "xin24m_div", "xin24m", CLK_IGNORE_UNUSED,
 			PX30_PMU_CLKSEL_CON(0), 8, 5, DFLAGS,
@@ -909,7 +942,7 @@ static struct rockchip_clk_branch px30_clk_pmu_branches[] __initdata = {
 	COMPOSITE_FRACMUX(0, "clk_uart0_frac", "clk_uart0_pmu_src", CLK_SET_RATE_PARENT,
 			PX30_PMU_CLKSEL_CON(5), 0,
 			PX30_PMU_CLKGATE_CON(1), 2, GFLAGS,
-			&px30_uart0_pmu_fracmux),
+			&px30_uart0_pmu_fracmux, PX30_FRAC_MAX_PRATE),
 	GATE(SCLK_UART0_PMU, "clk_uart0_pmu", "clk_uart0_pmu_mux", CLK_SET_RATE_PARENT,
 			PX30_PMU_CLKGATE_CON(1), 3, GFLAGS),
 
@@ -959,6 +992,37 @@ static const char *const px30_pmucru_critical_clocks[] __initconst = {
 	"usb480m",
 	"clk_uart2",
 	"pclk_uart2",
+	"clk_rtc32k_pmu",
+};
+
+static struct rockchip_clk_branch px30_clk_ddrphy_otp[] __initdata = {
+	COMPOSITE_NOGATE(0, "clk_ddrphy4x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+			PX30_CLKSEL_CON(2), 7, 1, MFLAGS, 0, 3, DFLAGS),
+	FACTOR_GATE(0, "clk_ddrphy1x", "clk_ddrphy4x", CLK_IGNORE_UNUSED, 1, 4,
+			PX30_CLKGATE_CON(0), 14, GFLAGS),
+	FACTOR_GATE(0, "clk_stdby_2wrap", "clk_ddrphy4x",
+			CLK_IGNORE_UNUSED, 1, 4,
+			PX30_CLKGATE_CON(1), 0, GFLAGS),
+
+	COMPOSITE_NOMUX(SCLK_OTP, "clk_otp", "xin24m", 0,
+			PX30_CLKSEL_CON(56), 0, 3, DFLAGS,
+			PX30_CLKGATE_CON(12), 11, GFLAGS),
+	COMPOSITE_NOMUX(SCLK_OTP_USR, "clk_otp_usr", "clk_otp", 0,
+			PX30_CLKSEL_CON(56), 4, 2, DFLAGS,
+			PX30_CLKGATE_CON(13), 6, GFLAGS),
+};
+
+static struct rockchip_clk_branch px30s_clk_ddrphy_otp[] __initdata = {
+	COMPOSITE(0, "clk_ddrphy1x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+			PX30_CLKSEL_CON(2), 7, 1, MFLAGS, 0, 3, DFLAGS,
+			PX30_CLKGATE_CON(0), 14, GFLAGS),
+	FACTOR_GATE(0, "clk_stdby_2wrap", "clk_ddrphy1x",
+			CLK_IGNORE_UNUSED, 1, 4,
+			PX30_CLKGATE_CON(1), 0, GFLAGS),
+
+	COMPOSITE(SCLK_OTP_USR, "clk_otp_usr", mux_xin24m_gpll_p, 0,
+			PX30_CLKSEL_CON(56), 8, 1, MFLAGS, 0, 8, DFLAGS,
+			PX30_CLKGATE_CON(12), 11, GFLAGS),
 };
 
 static void __init px30_clk_init(struct device_node *np)
@@ -993,6 +1057,20 @@ static void __init px30_clk_init(struct device_node *np)
 				   PX30_GRF_SOC_STATUS0);
 	rockchip_clk_register_branches(ctx, px30_clk_branches,
 				       ARRAY_SIZE(px30_clk_branches));
+	if (of_machine_is_compatible("rockchip,px30"))
+		rockchip_clk_register_branches(ctx, px30_gpu_src_clk,
+				       ARRAY_SIZE(px30_gpu_src_clk));
+	else
+		rockchip_clk_register_branches(ctx, rk3326_gpu_src_clk,
+				       ARRAY_SIZE(rk3326_gpu_src_clk));
+
+	rockchip_soc_id_init();
+	if (soc_is_px30s())
+		rockchip_clk_register_branches(ctx, px30s_clk_ddrphy_otp,
+					       ARRAY_SIZE(px30s_clk_ddrphy_otp));
+	else
+		rockchip_clk_register_branches(ctx, px30_clk_ddrphy_otp,
+					       ARRAY_SIZE(px30_clk_ddrphy_otp));
 
 	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
 				     mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
diff --git a/drivers/clk/rockchip/clk-rk3036.c b/drivers/clk/rockchip/clk-rk3036.c
deleted file mode 100644
index c3001980d..000000000
--- a/drivers/clk/rockchip/clk-rk3036.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/*
- * Copyright (c) 2014 MundoReader S.L.
- * Author: Heiko Stuebner <heiko@sntech.de>
- *
- * Copyright (c) 2015 Rockchip Electronics Co. Ltd.
- * Author: Xing Zheng <zhengxing@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/syscore_ops.h>
-#include <dt-bindings/clock/rk3036-cru.h>
-#include "clk.h"
-
-#define RK3036_GRF_SOC_STATUS0	0x14c
-
-enum rk3036_plls {
-	apll, dpll, gpll,
-};
-
-static struct rockchip_pll_rate_table rk3036_pll_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1584000000, 1, 66, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1560000000, 1, 65, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1536000000, 1, 64, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1488000000, 1, 62, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1464000000, 1, 61, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1440000000, 1, 60, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1392000000, 1, 58, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1368000000, 1, 57, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1344000000, 1, 56, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1320000000, 1, 55, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1272000000, 1, 53, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1248000000, 1, 52, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1188000000, 2, 99, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1104000000, 1, 46, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1100000000, 12, 550, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
-	RK3036_PLL_RATE(1000000000, 6, 500, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 984000000, 1, 82, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 960000000, 1, 80, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 936000000, 1, 78, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 912000000, 1, 76, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 900000000, 4, 300, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 888000000, 1, 74, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 864000000, 1, 72, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 840000000, 1, 70, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 816000000, 1, 68, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 800000000, 6, 400, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 700000000, 6, 350, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 696000000, 1, 58, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 600000000, 1, 75, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 594000000, 2, 99, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 504000000, 1, 63, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 500000000, 6, 250, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 408000000, 1, 68, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 312000000, 1, 52, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 216000000, 1, 72, 4, 2, 1, 0),
-	RK3036_PLL_RATE(  96000000, 1, 64, 4, 4, 1, 0),
-	{ /* sentinel */ },
-};
-
-#define RK3036_DIV_CPU_MASK		0x1f
-#define RK3036_DIV_CPU_SHIFT		8
-
-#define RK3036_DIV_PERI_MASK		0xf
-#define RK3036_DIV_PERI_SHIFT		0
-#define RK3036_DIV_ACLK_MASK		0x7
-#define RK3036_DIV_ACLK_SHIFT		4
-#define RK3036_DIV_HCLK_MASK		0x3
-#define RK3036_DIV_HCLK_SHIFT		8
-#define RK3036_DIV_PCLK_MASK		0x7
-#define RK3036_DIV_PCLK_SHIFT		12
-
-#define RK3036_CLKSEL1(_core_periph_div)					\
-	{									\
-		.reg = RK2928_CLKSEL_CON(1),					\
-		.val = HIWORD_UPDATE(_core_periph_div, RK3036_DIV_PERI_MASK,	\
-				RK3036_DIV_PERI_SHIFT)				\
-	}
-
-#define RK3036_CPUCLK_RATE(_prate, _core_periph_div)			\
-	{								\
-		.prate = _prate,					\
-		.divs = {						\
-			RK3036_CLKSEL1(_core_periph_div),		\
-		},							\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3036_cpuclk_rates[] __initdata = {
-	RK3036_CPUCLK_RATE(816000000, 4),
-	RK3036_CPUCLK_RATE(600000000, 4),
-	RK3036_CPUCLK_RATE(312000000, 4),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3036_cpuclk_data = {
-	.core_reg = RK2928_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 7,
-	.mux_core_mask = 0x1,
-};
-
-PNAME(mux_pll_p)		= { "xin24m", "xin24m" };
-
-PNAME(mux_armclk_p)		= { "apll", "gpll_armclk" };
-PNAME(mux_busclk_p)		= { "apll", "dpll_cpu", "gpll_cpu" };
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr" };
-PNAME(mux_pll_src_3plls_p)	= { "apll", "dpll", "gpll" };
-PNAME(mux_timer_p)		= { "xin24m", "pclk_peri_src" };
-
-PNAME(mux_pll_src_apll_dpll_gpll_usb480m_p)	= { "apll", "dpll", "gpll", "usb480m" };
-
-PNAME(mux_mmc_src_p)	= { "apll", "dpll", "gpll", "xin24m" };
-PNAME(mux_i2s_pre_p)	= { "i2s_src", "i2s_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s_clkout_p)	= { "i2s_pre", "xin12m" };
-PNAME(mux_spdif_p)	= { "spdif_src", "spdif_frac", "xin12m" };
-PNAME(mux_uart0_p)	= { "uart0_src", "uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)	= { "uart1_src", "uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)	= { "uart2_src", "uart2_frac", "xin24m" };
-PNAME(mux_mac_p)	= { "mac_pll_src", "rmii_clkin" };
-PNAME(mux_dclk_p)	= { "dclk_lcdc", "dclk_cru" };
-
-static struct rockchip_pll_clock rk3036_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3036, PLL_APLL, "apll", mux_pll_p, 0, RK2928_PLL_CON(0),
-		     RK2928_MODE_CON, 0, 5, 0, rk3036_pll_rates),
-	[dpll] = PLL(pll_rk3036, PLL_DPLL, "dpll", mux_pll_p, 0, RK2928_PLL_CON(4),
-		     RK2928_MODE_CON, 4, 4, 0, NULL),
-	[gpll] = PLL(pll_rk3036, PLL_GPLL, "gpll", mux_pll_p, 0, RK2928_PLL_CON(12),
-		     RK2928_MODE_CON, 12, 6, ROCKCHIP_PLL_SYNC_RATE, rk3036_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-
-static struct rockchip_clk_branch rk3036_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(13), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3036_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3036_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(15), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3036_i2s_fracmux __initdata =
-	MUX(0, "i2s_pre", mux_i2s_pre_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(3), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3036_spdif_fracmux __initdata =
-	MUX(SCLK_SPDIF, "sclk_spdif", mux_spdif_p, 0,
-			RK2928_CLKSEL_CON(5), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3036_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 1
-	 */
-
-	GATE(0, "gpll_armclk", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "gpll_ddr", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 8, GFLAGS),
-	COMPOSITE_NOGATE(0, "ddrphy2x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(26), 8, 1, MFLAGS, 0, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	FACTOR(0, "ddrphy", "ddrphy2x", 0, 1, 2),
-
-	COMPOSITE_NOMUX(0, "pclk_dbg", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 0, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(0), 7, GFLAGS),
-	COMPOSITE_NOMUX(0, "aclk_core_pre", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 4, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(0), 7, GFLAGS),
-
-	GATE(0, "dpll_cpu", "dpll", 0, RK2928_CLKGATE_CON(10), 8, GFLAGS),
-	GATE(0, "gpll_cpu", "gpll", 0, RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_cpu_src", mux_busclk_p, 0,
-			RK2928_CLKSEL_CON(0), 14, 2, MFLAGS, 8, 5, DFLAGS),
-	GATE(ACLK_CPU, "aclk_cpu", "aclk_cpu_src", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 3, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_CPU, "pclk_cpu", "aclk_cpu_src", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 12, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(0), 5, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_CPU, "hclk_cpu", "aclk_cpu_src", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 8, 2, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(0), 4, GFLAGS),
-
-	COMPOSITE(0, "aclk_peri_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(10), 14, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKGATE_CON(2), 1, GFLAGS),
-	DIV(0, "pclk_peri_src", "aclk_peri_src", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(10), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	GATE(PCLK_PERI, "pclk_peri", "pclk_peri_src", 0,
-			RK2928_CLKGATE_CON(2), 3, GFLAGS),
-	DIV(0, "hclk_peri_src", "aclk_peri_src", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(10), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	GATE(HCLK_PERI, "hclk_peri", "hclk_peri_src", 0,
-			RK2928_CLKGATE_CON(2), 2, GFLAGS),
-
-	COMPOSITE_NODIV(SCLK_TIMER0, "sclk_timer0", mux_timer_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(2), 4, 1, MFLAGS,
-			RK2928_CLKGATE_CON(1), 0, GFLAGS),
-	COMPOSITE_NODIV(SCLK_TIMER1, "sclk_timer1", mux_timer_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(2), 5, 1, MFLAGS,
-			RK2928_CLKGATE_CON(1), 1, GFLAGS),
-	COMPOSITE_NODIV(SCLK_TIMER2, "sclk_timer2", mux_timer_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(2), 6, 1, MFLAGS,
-			RK2928_CLKGATE_CON(2), 4, GFLAGS),
-	COMPOSITE_NODIV(SCLK_TIMER3, "sclk_timer3", mux_timer_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(2), 7, 1, MFLAGS,
-			RK2928_CLKGATE_CON(2), 5, GFLAGS),
-
-	MUX(0, "uart_pll_clk", mux_pll_src_apll_dpll_gpll_usb480m_p, 0,
-			RK2928_CLKSEL_CON(13), 10, 2, MFLAGS),
-	COMPOSITE_NOMUX(0, "uart0_src", "uart_pll_clk", 0,
-			RK2928_CLKSEL_CON(13), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 8, GFLAGS),
-	COMPOSITE_NOMUX(0, "uart1_src", "uart_pll_clk", 0,
-			RK2928_CLKSEL_CON(14), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 10, GFLAGS),
-	COMPOSITE_NOMUX(0, "uart2_src", "uart_pll_clk", 0,
-			RK2928_CLKSEL_CON(15), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 12, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(17), 0,
-			RK2928_CLKGATE_CON(1), 9, GFLAGS,
-			&rk3036_uart0_fracmux),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(18), 0,
-			RK2928_CLKGATE_CON(1), 11, GFLAGS,
-			&rk3036_uart1_fracmux),
-	COMPOSITE_FRACMUX(0, "uart2_frac", "uart2_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(19), 0,
-			RK2928_CLKGATE_CON(1), 13, GFLAGS,
-			&rk3036_uart2_fracmux),
-
-	COMPOSITE(0, "aclk_vcodec", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(32), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 11, GFLAGS),
-	FACTOR_GATE(HCLK_VCODEC, "hclk_vcodec", "aclk_vcodec", 0, 1, 4,
-			RK2928_CLKGATE_CON(3), 12, GFLAGS),
-
-	COMPOSITE(0, "aclk_hvec", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(20), 0, 2, MFLAGS, 2, 5, DFLAGS,
-			RK2928_CLKGATE_CON(10), 6, GFLAGS),
-
-	COMPOSITE(0, "aclk_disp1_pre", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(31), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 4, GFLAGS),
-	COMPOSITE(0, "hclk_disp_pre", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(30), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(0), 11, GFLAGS),
-	COMPOSITE(SCLK_LCDC, "dclk_lcdc", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(28), 0, 2, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 2, GFLAGS),
-
-	COMPOSITE_NODIV(0, "sclk_sdmmc_src", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(12), 8, 2, MFLAGS,
-			RK2928_CLKGATE_CON(2), 11, GFLAGS),
-	DIV(SCLK_SDMMC, "sclk_sdmmc", "sclk_sdmmc_src", 0,
-			RK2928_CLKSEL_CON(11), 0, 7, DFLAGS),
-
-	COMPOSITE_NODIV(0, "sclk_sdio_src", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(12), 10, 2, MFLAGS,
-			RK2928_CLKGATE_CON(2), 13, GFLAGS),
-	DIV(SCLK_SDIO, "sclk_sdio", "sclk_sdio_src", 0,
-			RK2928_CLKSEL_CON(11), 8, 7, DFLAGS),
-
-	COMPOSITE(SCLK_EMMC, "sclk_emmc", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(12), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 14, GFLAGS),
-
-	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RK3036_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3036_SDMMC_CON1, 0),
-
-	MMC(SCLK_SDIO_DRV,     "sdio_drv",     "sclk_sdio",  RK3036_SDIO_CON0, 1),
-	MMC(SCLK_SDIO_SAMPLE,  "sdio_sample",  "sclk_sdio",  RK3036_SDIO_CON1, 0),
-
-	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RK3036_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3036_EMMC_CON1,  0),
-
-	COMPOSITE(0, "i2s_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(3), 14, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 9, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s_frac", "i2s_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(7), 0,
-			RK2928_CLKGATE_CON(0), 10, GFLAGS,
-			&rk3036_i2s_fracmux),
-	COMPOSITE_NODIV(SCLK_I2S_OUT, "i2s_clkout", mux_i2s_clkout_p, 0,
-			RK2928_CLKSEL_CON(3), 12, 1, MFLAGS,
-			RK2928_CLKGATE_CON(0), 13, GFLAGS),
-	GATE(SCLK_I2S, "sclk_i2s", "i2s_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKGATE_CON(0), 14, GFLAGS),
-
-	COMPOSITE(0, "spdif_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(5), 10, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 10, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_frac", "spdif_src", 0,
-			RK2928_CLKSEL_CON(9), 0,
-			RK2928_CLKGATE_CON(2), 12, GFLAGS,
-			&rk3036_spdif_fracmux),
-
-	GATE(SCLK_OTGPHY0, "sclk_otgphy0", "xin12m", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(1), 5, GFLAGS),
-
-	COMPOSITE(SCLK_GPU, "sclk_gpu", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(34), 8, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 13, GFLAGS),
-
-	COMPOSITE(SCLK_SPI, "sclk_spi", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(25), 8, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 9, GFLAGS),
-
-	COMPOSITE(SCLK_NANDC, "sclk_nandc", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(16), 8, 2, MFLAGS, 10, 5, DFLAGS,
-			RK2928_CLKGATE_CON(10), 4, GFLAGS),
-
-	COMPOSITE(SCLK_SFC, "sclk_sfc", mux_pll_src_apll_dpll_gpll_usb480m_p, 0,
-			RK2928_CLKSEL_CON(16), 0, 2, MFLAGS, 2, 5, DFLAGS,
-			RK2928_CLKGATE_CON(10), 5, GFLAGS),
-
-	COMPOSITE_NOGATE(SCLK_MACPLL, "mac_pll_src", mux_pll_src_3plls_p, CLK_SET_RATE_NO_REPARENT,
-			RK2928_CLKSEL_CON(21), 0, 2, MFLAGS, 9, 5, DFLAGS),
-	MUX(SCLK_MACREF, "mac_clk_ref", mux_mac_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(21), 3, 1, MFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_MAC, "mac_clk", "mac_clk_ref", 0,
-			RK2928_CLKSEL_CON(21), 4, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 6, GFLAGS),
-	FACTOR(0, "sclk_macref_out", "hclk_peri_src", 0, 1, 2),
-
-	MUX(SCLK_HDMI, "dclk_hdmi", mux_dclk_p, 0,
-			RK2928_CLKSEL_CON(31), 0, 1, MFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-
-	/* aclk_cpu gates */
-	GATE(0, "sclk_intmem", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 12, GFLAGS),
-	GATE(0, "aclk_strc_sys", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 10, GFLAGS),
-
-	/* hclk_cpu gates */
-	GATE(HCLK_ROM, "hclk_rom", "hclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 6, GFLAGS),
-
-	/* pclk_cpu gates */
-	GATE(PCLK_GRF, "pclk_grf", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 4, GFLAGS),
-	GATE(PCLK_DDRUPCTL, "pclk_ddrupctl", "pclk_cpu", 0, RK2928_CLKGATE_CON(5), 7, GFLAGS),
-	GATE(PCLK_ACODEC, "pclk_acodec", "pclk_cpu", 0, RK2928_CLKGATE_CON(5), 14, GFLAGS),
-	GATE(PCLK_HDMI, "pclk_hdmi", "pclk_cpu", 0, RK2928_CLKGATE_CON(3), 8, GFLAGS),
-
-	/* aclk_vio gates */
-	GATE(ACLK_VIO, "aclk_vio", "aclk_disp1_pre", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(6), 13, GFLAGS),
-	GATE(ACLK_LCDC, "aclk_lcdc", "aclk_disp1_pre", 0, RK2928_CLKGATE_CON(9), 6, GFLAGS),
-
-	GATE(HCLK_VIO_BUS, "hclk_vio_bus", "hclk_disp_pre", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(6), 12, GFLAGS),
-	GATE(HCLK_LCDC, "hclk_lcdc", "hclk_disp_pre", 0, RK2928_CLKGATE_CON(9), 5, GFLAGS),
-
-
-	/* xin24m gates */
-	GATE(SCLK_PVTM_CORE, "sclk_pvtm_core", "xin24m", 0, RK2928_CLKGATE_CON(10), 0, GFLAGS),
-	GATE(SCLK_PVTM_GPU, "sclk_pvtm_gpu", "xin24m", 0, RK2928_CLKGATE_CON(10), 1, GFLAGS),
-
-	/* aclk_peri gates */
-	GATE(0, "aclk_peri_axi_matrix", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 3, GFLAGS),
-	GATE(0, "aclk_cpu_peri", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 2, GFLAGS),
-	GATE(ACLK_DMAC2, "aclk_dmac2", "aclk_peri", 0, RK2928_CLKGATE_CON(5), 1, GFLAGS),
-	GATE(0, "aclk_peri_niu", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 15, GFLAGS),
-
-	/* hclk_peri gates */
-	GATE(0, "hclk_peri_matrix", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 0, GFLAGS),
-	GATE(0, "hclk_usb_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 13, GFLAGS),
-	GATE(0, "hclk_peri_arbi", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 14, GFLAGS),
-	GATE(HCLK_NANDC, "hclk_nandc", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 9, GFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 10, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 11, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 0, GFLAGS),
-	GATE(HCLK_OTG0, "hclk_otg0", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 13, GFLAGS),
-	GATE(HCLK_OTG1, "hclk_otg1", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(7), 3, GFLAGS),
-	GATE(HCLK_I2S, "hclk_i2s", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 2, GFLAGS),
-	GATE(0, "hclk_sfc", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(3), 14, GFLAGS),
-	GATE(HCLK_MAC, "hclk_mac", "hclk_peri", 0, RK2928_CLKGATE_CON(3), 5, GFLAGS),
-
-	/* pclk_peri gates */
-	GATE(0, "pclk_peri_matrix", "pclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 1, GFLAGS),
-	GATE(0, "pclk_efuse", "pclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 2, GFLAGS),
-	GATE(PCLK_TIMER, "pclk_timer", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 7, GFLAGS),
-	GATE(PCLK_PWM, "pclk_pwm", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 10, GFLAGS),
-	GATE(PCLK_SPI, "pclk_spi", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 12, GFLAGS),
-	GATE(PCLK_WDT, "pclk_wdt", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 15, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 0, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 1, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 2, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 4, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 5, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 6, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 9, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 10, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 11, GFLAGS),
-};
-
-static const char *const rk3036_critical_clocks[] __initconst = {
-	"aclk_cpu",
-	"aclk_peri",
-	"hclk_peri",
-	"pclk_peri",
-	"pclk_ddrupctl",
-};
-
-static void __init rk3036_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-	struct clk *clk;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	/*
-	 * Make uart_pll_clk a child of the gpll, as all other sources are
-	 * not that usable / stable.
-	 */
-	writel_relaxed(HIWORD_UPDATE(0x2, 0x3, 10),
-		       reg_base + RK2928_CLKSEL_CON(13));
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	clk = clk_register_fixed_factor(NULL, "usb480m", "xin24m", 0, 20, 1);
-	if (IS_ERR(clk))
-		pr_warn("%s: could not register clock usb480m: %ld\n",
-			__func__, PTR_ERR(clk));
-
-	rockchip_clk_register_plls(ctx, rk3036_pll_clks,
-				   ARRAY_SIZE(rk3036_pll_clks),
-				   RK3036_GRF_SOC_STATUS0);
-	rockchip_clk_register_branches(ctx, rk3036_clk_branches,
-				  ARRAY_SIZE(rk3036_clk_branches));
-	rockchip_clk_protect_critical(rk3036_critical_clocks,
-				      ARRAY_SIZE(rk3036_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-			mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-			&rk3036_cpuclk_data, rk3036_cpuclk_rates,
-			ARRAY_SIZE(rk3036_cpuclk_rates));
-
-	rockchip_register_softrst(np, 9, reg_base + RK2928_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK2928_GLB_SRST_FST, NULL);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3036_cru, "rockchip,rk3036-cru", rk3036_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3128.c b/drivers/clk/rockchip/clk-rk3128.c
deleted file mode 100644
index 5970a5067..000000000
--- a/drivers/clk/rockchip/clk-rk3128.c
+++ /dev/null
@@ -1,655 +0,0 @@
-/*
- * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
- * Author: Elaine <zhangqing@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/syscore_ops.h>
-#include <dt-bindings/clock/rk3128-cru.h>
-#include "clk.h"
-
-#define RK3128_GRF_SOC_STATUS0	0x14c
-
-enum rk3128_plls {
-	apll, dpll, cpll, gpll,
-};
-
-static struct rockchip_pll_rate_table rk3128_pll_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1584000000, 1, 66, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1560000000, 1, 65, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1536000000, 1, 64, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1488000000, 1, 62, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1464000000, 1, 61, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1440000000, 1, 60, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1392000000, 1, 58, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1368000000, 1, 57, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1344000000, 1, 56, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1320000000, 1, 55, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1272000000, 1, 53, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1248000000, 1, 52, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1188000000, 2, 99, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1104000000, 1, 46, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1100000000, 12, 550, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
-	RK3036_PLL_RATE(1000000000, 6, 500, 2, 1, 1, 0),
-	RK3036_PLL_RATE(984000000, 1, 82, 2, 1, 1, 0),
-	RK3036_PLL_RATE(960000000, 1, 80, 2, 1, 1, 0),
-	RK3036_PLL_RATE(936000000, 1, 78, 2, 1, 1, 0),
-	RK3036_PLL_RATE(912000000, 1, 76, 2, 1, 1, 0),
-	RK3036_PLL_RATE(900000000, 4, 300, 2, 1, 1, 0),
-	RK3036_PLL_RATE(888000000, 1, 74, 2, 1, 1, 0),
-	RK3036_PLL_RATE(864000000, 1, 72, 2, 1, 1, 0),
-	RK3036_PLL_RATE(840000000, 1, 70, 2, 1, 1, 0),
-	RK3036_PLL_RATE(816000000, 1, 68, 2, 1, 1, 0),
-	RK3036_PLL_RATE(800000000, 6, 400, 2, 1, 1, 0),
-	RK3036_PLL_RATE(700000000, 6, 350, 2, 1, 1, 0),
-	RK3036_PLL_RATE(696000000, 1, 58, 2, 1, 1, 0),
-	RK3036_PLL_RATE(600000000, 1, 75, 3, 1, 1, 0),
-	RK3036_PLL_RATE(594000000, 2, 99, 2, 1, 1, 0),
-	RK3036_PLL_RATE(504000000, 1, 63, 3, 1, 1, 0),
-	RK3036_PLL_RATE(500000000, 6, 250, 2, 1, 1, 0),
-	RK3036_PLL_RATE(408000000, 1, 68, 2, 2, 1, 0),
-	RK3036_PLL_RATE(312000000, 1, 52, 2, 2, 1, 0),
-	RK3036_PLL_RATE(216000000, 1, 72, 4, 2, 1, 0),
-	RK3036_PLL_RATE(96000000, 1, 64, 4, 4, 1, 0),
-	{ /* sentinel */ },
-};
-
-#define RK3128_DIV_CPU_MASK		0x1f
-#define RK3128_DIV_CPU_SHIFT		8
-
-#define RK3128_DIV_PERI_MASK		0xf
-#define RK3128_DIV_PERI_SHIFT		0
-#define RK3128_DIV_ACLK_MASK		0x7
-#define RK3128_DIV_ACLK_SHIFT		4
-#define RK3128_DIV_HCLK_MASK		0x3
-#define RK3128_DIV_HCLK_SHIFT		8
-#define RK3128_DIV_PCLK_MASK		0x7
-#define RK3128_DIV_PCLK_SHIFT		12
-
-#define RK3128_CLKSEL1(_core_aclk_div, _pclk_dbg_div)			\
-{									\
-	.reg = RK2928_CLKSEL_CON(1),					\
-	.val = HIWORD_UPDATE(_pclk_dbg_div, RK3128_DIV_PERI_MASK,	\
-			     RK3128_DIV_PERI_SHIFT) |			\
-	       HIWORD_UPDATE(_core_aclk_div, RK3128_DIV_ACLK_MASK,	\
-			     RK3128_DIV_ACLK_SHIFT),			\
-}
-
-#define RK3128_CPUCLK_RATE(_prate, _core_aclk_div, _pclk_dbg_div)	\
-{									\
-	.prate = _prate,						\
-	.divs = {							\
-		RK3128_CLKSEL1(_core_aclk_div, _pclk_dbg_div),		\
-	},								\
-}
-
-static struct rockchip_cpuclk_rate_table rk3128_cpuclk_rates[] __initdata = {
-	RK3128_CPUCLK_RATE(1800000000, 1, 7),
-	RK3128_CPUCLK_RATE(1704000000, 1, 7),
-	RK3128_CPUCLK_RATE(1608000000, 1, 7),
-	RK3128_CPUCLK_RATE(1512000000, 1, 7),
-	RK3128_CPUCLK_RATE(1488000000, 1, 5),
-	RK3128_CPUCLK_RATE(1416000000, 1, 5),
-	RK3128_CPUCLK_RATE(1392000000, 1, 5),
-	RK3128_CPUCLK_RATE(1296000000, 1, 5),
-	RK3128_CPUCLK_RATE(1200000000, 1, 5),
-	RK3128_CPUCLK_RATE(1104000000, 1, 5),
-	RK3128_CPUCLK_RATE(1008000000, 1, 5),
-	RK3128_CPUCLK_RATE(912000000, 1, 5),
-	RK3128_CPUCLK_RATE(816000000, 1, 3),
-	RK3128_CPUCLK_RATE(696000000, 1, 3),
-	RK3128_CPUCLK_RATE(600000000, 1, 3),
-	RK3128_CPUCLK_RATE(408000000, 1, 1),
-	RK3128_CPUCLK_RATE(312000000, 1, 1),
-	RK3128_CPUCLK_RATE(216000000,  1, 1),
-	RK3128_CPUCLK_RATE(96000000, 1, 1),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3128_cpuclk_data = {
-	.core_reg = RK2928_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 7,
-	.mux_core_mask = 0x1,
-};
-
-PNAME(mux_pll_p)		= { "clk_24m", "xin24m" };
-
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_div2_ddr" };
-PNAME(mux_armclk_p)		= { "apll_core", "gpll_div2_core" };
-PNAME(mux_usb480m_p)		= { "usb480m_phy", "xin24m" };
-PNAME(mux_aclk_cpu_src_p)	= { "cpll", "gpll", "gpll_div2", "gpll_div3" };
-
-PNAME(mux_pll_src_5plls_p)	= { "cpll", "gpll", "gpll_div2", "gpll_div3", "usb480m" };
-PNAME(mux_pll_src_4plls_p)	= { "cpll", "gpll", "gpll_div2", "usb480m" };
-PNAME(mux_pll_src_3plls_p)	= { "cpll", "gpll", "gpll_div2" };
-
-PNAME(mux_aclk_peri_src_p)	= { "gpll_peri", "cpll_peri", "gpll_div2_peri", "gpll_div3_peri" };
-PNAME(mux_mmc_src_p)		= { "cpll", "gpll", "gpll_div2", "xin24m" };
-PNAME(mux_clk_cif_out_src_p)		= { "clk_cif_src", "xin24m" };
-PNAME(mux_sclk_vop_src_p)	= { "cpll", "gpll", "gpll_div2", "gpll_div3" };
-
-PNAME(mux_i2s0_p)		= { "i2s0_src", "i2s0_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s1_pre_p)		= { "i2s1_src", "i2s1_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s_out_p)		= { "i2s1_pre", "xin12m" };
-PNAME(mux_sclk_spdif_p)		= { "sclk_spdif_src", "spdif_frac", "xin12m" };
-
-PNAME(mux_uart0_p)		= { "uart0_src", "uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)		= { "uart1_src", "uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)		= { "uart2_src", "uart2_frac", "xin24m" };
-
-PNAME(mux_sclk_gmac_p)	= { "sclk_gmac_src", "gmac_clkin" };
-PNAME(mux_sclk_sfc_src_p)	= { "cpll", "gpll", "gpll_div2", "xin24m" };
-
-static struct rockchip_pll_clock rk3128_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3036, PLL_APLL, "apll", mux_pll_p, 0, RK2928_PLL_CON(0),
-		     RK2928_MODE_CON, 0, 1, 0, rk3128_pll_rates),
-	[dpll] = PLL(pll_rk3036, PLL_DPLL, "dpll", mux_pll_p, 0, RK2928_PLL_CON(4),
-		     RK2928_MODE_CON, 4, 0, 0, NULL),
-	[cpll] = PLL(pll_rk3036, PLL_CPLL, "cpll", mux_pll_p, 0, RK2928_PLL_CON(8),
-		     RK2928_MODE_CON, 8, 2, 0, rk3128_pll_rates),
-	[gpll] = PLL(pll_rk3036, PLL_GPLL, "gpll", mux_pll_p, 0, RK2928_PLL_CON(12),
-		     RK2928_MODE_CON, 12, 3, ROCKCHIP_PLL_SYNC_RATE, rk3128_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-
-static struct rockchip_clk_branch rk3128_i2s0_fracmux __initdata =
-	MUX(0, "i2s0_pre", mux_i2s0_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(9), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3128_i2s1_fracmux __initdata =
-	MUX(0, "i2s1_pre", mux_i2s1_pre_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(3), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3128_spdif_fracmux __initdata =
-	MUX(SCLK_SPDIF, "sclk_spdif", mux_sclk_spdif_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(6), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3128_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(13), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3128_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3128_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(15), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 1
-	 */
-
-	FACTOR(PLL_GPLL_DIV2, "gpll_div2", "gpll", 0, 1, 2),
-	FACTOR(PLL_GPLL_DIV3, "gpll_div3", "gpll", 0, 1, 3),
-
-	DIV(0, "clk_24m", "xin24m", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(4), 8, 5, DFLAGS),
-
-	/* PD_DDR */
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "gpll_div2_ddr", "gpll_div2", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	COMPOSITE_NOGATE(0, "ddrphy2x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(26), 8, 2, MFLAGS, 0, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	FACTOR(SCLK_DDRC, "clk_ddrc", "ddrphy2x", 0, 1, 2),
-	FACTOR(0, "clk_ddrphy", "ddrphy2x", 0, 1, 2),
-
-	/* PD_CORE */
-	GATE(0, "apll_core", "apll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-	GATE(0, "gpll_div2_core", "gpll_div2", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_dbg", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 0, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(0), 0, GFLAGS),
-	COMPOSITE_NOMUX(0, "armcore", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 4, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(0), 7, GFLAGS),
-
-	/* PD_MISC */
-	MUX(SCLK_USB480M, "usb480m", mux_usb480m_p, CLK_SET_RATE_PARENT,
-			RK2928_MISC_CON, 15, 1, MFLAGS),
-
-	/* PD_CPU */
-	COMPOSITE(0, "aclk_cpu_src", mux_aclk_cpu_src_p, 0,
-			RK2928_CLKSEL_CON(0), 13, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(ACLK_CPU, "aclk_cpu", "aclk_cpu_src", 0,
-			RK2928_CLKGATE_CON(0), 3, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_CPU, "hclk_cpu", "aclk_cpu_src", 0,
-			RK2928_CLKSEL_CON(1), 8, 2, DFLAGS,
-			RK2928_CLKGATE_CON(0), 4, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_CPU, "pclk_cpu", "aclk_cpu_src", 0,
-			RK2928_CLKSEL_CON(1), 12, 2, DFLAGS,
-			RK2928_CLKGATE_CON(0), 5, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_CRYPTO, "clk_crypto", "aclk_cpu_src", 0,
-			RK2928_CLKSEL_CON(24), 0, 2, DFLAGS,
-			RK2928_CLKGATE_CON(0), 12, GFLAGS),
-
-	/* PD_VIDEO */
-	COMPOSITE(ACLK_VEPU, "aclk_vepu", mux_pll_src_5plls_p, 0,
-			RK2928_CLKSEL_CON(32), 5, 3, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 9, GFLAGS),
-	FACTOR(HCLK_VEPU, "hclk_vepu", "aclk_vepu", 0, 1, 4),
-
-	COMPOSITE(ACLK_VDPU, "aclk_vdpu", mux_pll_src_5plls_p, 0,
-			RK2928_CLKSEL_CON(32), 13, 3, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 11, GFLAGS),
-	FACTOR_GATE(HCLK_VDPU, "hclk_vdpu", "aclk_vdpu", 0, 1, 4,
-			RK2928_CLKGATE_CON(3), 12, GFLAGS),
-
-	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_5plls_p, 0,
-			RK2928_CLKSEL_CON(34), 13, 3, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 10, GFLAGS),
-
-	/* PD_VIO */
-	COMPOSITE(ACLK_VIO0, "aclk_vio0", mux_pll_src_5plls_p, 0,
-			RK2928_CLKSEL_CON(31), 5, 3, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 0, GFLAGS),
-	COMPOSITE(ACLK_VIO1, "aclk_vio1", mux_pll_src_5plls_p, 0,
-			RK2928_CLKSEL_CON(31), 13, 3, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 4, GFLAGS),
-	COMPOSITE(HCLK_VIO, "hclk_vio", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(30), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(0), 11, GFLAGS),
-
-	/* PD_PERI */
-	GATE(0, "gpll_peri", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "cpll_peri", "cpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "gpll_div2_peri", "gpll_div2", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "gpll_div3_peri", "gpll_div3", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_peri_src", mux_aclk_peri_src_p, 0,
-			RK2928_CLKSEL_CON(10), 14, 2, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKSEL_CON(10), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(2), 3, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERI, "hclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKSEL_CON(10), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(2), 2, GFLAGS),
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKGATE_CON(2), 1, GFLAGS),
-
-	GATE(SCLK_TIMER0, "sclk_timer0", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 3, GFLAGS),
-	GATE(SCLK_TIMER1, "sclk_timer1", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 4, GFLAGS),
-	GATE(SCLK_TIMER2, "sclk_timer2", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 5, GFLAGS),
-	GATE(SCLK_TIMER3, "sclk_timer3", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 6, GFLAGS),
-	GATE(SCLK_TIMER4, "sclk_timer4", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 7, GFLAGS),
-	GATE(SCLK_TIMER5, "sclk_timer5", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 8, GFLAGS),
-
-	GATE(SCLK_PVTM_CORE, "clk_pvtm_core", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 0, GFLAGS),
-	GATE(SCLK_PVTM_GPU, "clk_pvtm_gpu", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 1, GFLAGS),
-	GATE(SCLK_PVTM_FUNC, "clk_pvtm_func", "xin24m", 0,
-			RK2928_CLKGATE_CON(10), 2, GFLAGS),
-	GATE(SCLK_MIPI_24M, "clk_mipi_24m", "xin24m", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 15, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC, "sclk_sdmmc0", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(11), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 11, GFLAGS),
-
-	COMPOSITE(SCLK_SDIO, "sclk_sdio", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(12), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 13, GFLAGS),
-
-	COMPOSITE(SCLK_EMMC, "sclk_emmc", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(12), 14, 2, MFLAGS, 8, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 14, GFLAGS),
-
-	DIV(SCLK_PVTM, "clk_pvtm", "clk_pvtm_func", 0,
-			RK2928_CLKSEL_CON(2), 0, 7, DFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-	COMPOSITE(DCLK_VOP, "dclk_vop", mux_sclk_vop_src_p, 0,
-			RK2928_CLKSEL_CON(27), 0, 2, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	COMPOSITE(SCLK_VOP, "sclk_vop", mux_sclk_vop_src_p, 0,
-			RK2928_CLKSEL_CON(28), 0, 2, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 2, GFLAGS),
-	COMPOSITE(DCLK_EBC, "dclk_ebc", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(23), 0, 2, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 4, GFLAGS),
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	COMPOSITE_NODIV(SCLK_CIF_SRC, "sclk_cif_src", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(29), 0, 2, MFLAGS,
-			RK2928_CLKGATE_CON(3), 7, GFLAGS),
-	MUX(SCLK_CIF_OUT_SRC, "sclk_cif_out_src", mux_clk_cif_out_src_p, 0,
-			RK2928_CLKSEL_CON(13), 14, 2, MFLAGS),
-	DIV(SCLK_CIF_OUT, "sclk_cif_out", "sclk_cif_out_src", 0,
-			RK2928_CLKSEL_CON(29), 2, 5, DFLAGS),
-
-	COMPOSITE(0, "i2s0_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(9), 14, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(4), 4, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s0_frac", "i2s0_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(8), 0,
-			RK2928_CLKGATE_CON(4), 5, GFLAGS,
-			&rk3128_i2s0_fracmux),
-	GATE(SCLK_I2S0, "sclk_i2s0", "i2s0_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKGATE_CON(4), 6, GFLAGS),
-
-	COMPOSITE(0, "i2s1_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(3), 14, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 9, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s1_frac", "i2s1_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(7), 0,
-			RK2928_CLKGATE_CON(0), 10, GFLAGS,
-			&rk3128_i2s1_fracmux),
-	GATE(SCLK_I2S1, "sclk_i2s1", "i2s1_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKGATE_CON(0), 14, GFLAGS),
-	COMPOSITE_NODIV(SCLK_I2S_OUT, "i2s_out", mux_i2s_out_p, 0,
-			RK2928_CLKSEL_CON(3), 12, 1, MFLAGS,
-			RK2928_CLKGATE_CON(0), 13, GFLAGS),
-
-	COMPOSITE(0, "sclk_spdif_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(6), 14, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 10, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_frac", "sclk_spdif_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(20), 0,
-			RK2928_CLKGATE_CON(2), 12, GFLAGS,
-			&rk3128_spdif_fracmux),
-
-	GATE(0, "jtag", "ext_jtag", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(1), 3, GFLAGS),
-
-	GATE(SCLK_OTGPHY0, "sclk_otgphy0", "xin12m", 0,
-			RK2928_CLKGATE_CON(1), 5, GFLAGS),
-	GATE(SCLK_OTGPHY1, "sclk_otgphy1", "xin12m", 0,
-			RK2928_CLKGATE_CON(1), 6, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_SARADC, "sclk_saradc", "xin24m", 0,
-			RK2928_CLKSEL_CON(24), 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(2), 8, GFLAGS),
-
-	COMPOSITE(ACLK_GPU, "aclk_gpu", mux_pll_src_5plls_p, 0,
-			RK2928_CLKSEL_CON(34), 5, 3, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 13, GFLAGS),
-
-	COMPOSITE(SCLK_SPI0, "sclk_spi0", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(25), 8, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 9, GFLAGS),
-
-	/* PD_UART */
-	COMPOSITE(0, "uart0_src", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(13), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 8, GFLAGS),
-	MUX(0, "uart12_src", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(13), 14, 2, MFLAGS),
-	COMPOSITE_NOMUX(0, "uart1_src", "uart12_src", 0,
-			RK2928_CLKSEL_CON(14), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 10, GFLAGS),
-	COMPOSITE_NOMUX(0, "uart2_src", "uart12_src", 0,
-			RK2928_CLKSEL_CON(15), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 13, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(17), 0,
-			RK2928_CLKGATE_CON(1), 9, GFLAGS,
-			&rk3128_uart0_fracmux),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(18), 0,
-			RK2928_CLKGATE_CON(1), 11, GFLAGS,
-			&rk3128_uart1_fracmux),
-	COMPOSITE_FRACMUX(0, "uart2_frac", "uart2_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(19), 0,
-			RK2928_CLKGATE_CON(1), 13, GFLAGS,
-			&rk3128_uart2_fracmux),
-
-	COMPOSITE(SCLK_MAC_SRC, "sclk_gmac_src", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(5), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 7, GFLAGS),
-	MUX(SCLK_MAC, "sclk_gmac", mux_sclk_gmac_p, 0,
-			RK2928_CLKSEL_CON(5), 15, 1, MFLAGS),
-	GATE(SCLK_MAC_REFOUT, "sclk_mac_refout", "sclk_gmac", 0,
-			RK2928_CLKGATE_CON(2), 5, GFLAGS),
-	GATE(SCLK_MAC_REF, "sclk_mac_ref", "sclk_gmac", 0,
-			RK2928_CLKGATE_CON(2), 4, GFLAGS),
-	GATE(SCLK_MAC_RX, "sclk_mac_rx", "sclk_gmac", 0,
-			RK2928_CLKGATE_CON(2), 6, GFLAGS),
-	GATE(SCLK_MAC_TX, "sclk_mac_tx", "sclk_gmac", 0,
-			RK2928_CLKGATE_CON(2), 7, GFLAGS),
-
-	COMPOSITE(SCLK_TSP, "sclk_tsp", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(4), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 14, GFLAGS),
-
-	COMPOSITE(SCLK_NANDC, "sclk_nandc", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(2), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(10), 15, GFLAGS),
-
-	COMPOSITE_NOMUX(PCLK_PMU_PRE, "pclk_pmu_pre", "cpll", 0,
-			RK2928_CLKSEL_CON(29), 8, 6, DFLAGS,
-			RK2928_CLKGATE_CON(1), 0, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-
-	/* PD_VOP */
-	GATE(ACLK_LCDC0, "aclk_lcdc0", "aclk_vio0", 0, RK2928_CLKGATE_CON(6), 0, GFLAGS),
-	GATE(ACLK_CIF, "aclk_cif", "aclk_vio0", 0, RK2928_CLKGATE_CON(6), 5, GFLAGS),
-	GATE(ACLK_RGA, "aclk_rga", "aclk_vio0", 0, RK2928_CLKGATE_CON(6), 11, GFLAGS),
-	GATE(0, "aclk_vio0_niu", "aclk_vio0", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(6), 13, GFLAGS),
-
-	GATE(ACLK_IEP, "aclk_iep", "aclk_vio1", 0, RK2928_CLKGATE_CON(9), 8, GFLAGS),
-	GATE(0, "aclk_vio1_niu", "aclk_vio1", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 10, GFLAGS),
-
-	GATE(HCLK_VIO_H2P, "hclk_vio_h2p", "hclk_vio", 0, RK2928_CLKGATE_CON(9), 5, GFLAGS),
-	GATE(PCLK_MIPI, "pclk_mipi", "hclk_vio", 0, RK2928_CLKGATE_CON(9), 6, GFLAGS),
-	GATE(HCLK_RGA, "hclk_rga", "hclk_vio", 0, RK2928_CLKGATE_CON(6), 10, GFLAGS),
-	GATE(HCLK_LCDC0, "hclk_lcdc0", "hclk_vio", 0, RK2928_CLKGATE_CON(6), 1, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_vio", 0, RK2928_CLKGATE_CON(9), 7, GFLAGS),
-	GATE(0, "hclk_vio_niu", "hclk_vio", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(6), 12, GFLAGS),
-	GATE(HCLK_CIF, "hclk_cif", "hclk_vio", 0, RK2928_CLKGATE_CON(6), 4, GFLAGS),
-	GATE(HCLK_EBC, "hclk_ebc", "hclk_vio", 0, RK2928_CLKGATE_CON(9), 9, GFLAGS),
-
-	/* PD_PERI */
-	GATE(0, "aclk_peri_axi", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 3, GFLAGS),
-	GATE(ACLK_GMAC, "aclk_gmac", "aclk_peri", 0, RK2928_CLKGATE_CON(10), 10, GFLAGS),
-	GATE(ACLK_DMAC, "aclk_dmac", "aclk_peri", 0, RK2928_CLKGATE_CON(5), 1, GFLAGS),
-	GATE(0, "aclk_peri_niu", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 15, GFLAGS),
-	GATE(0, "aclk_cpu_to_peri", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 2, GFLAGS),
-
-	GATE(HCLK_I2S_8CH, "hclk_i2s_8ch", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 4, GFLAGS),
-	GATE(0, "hclk_peri_matrix", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 0, GFLAGS),
-	GATE(HCLK_I2S_2CH, "hclk_i2s_2ch", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 2, GFLAGS),
-	GATE(0, "hclk_usb_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 13, GFLAGS),
-	GATE(HCLK_HOST2, "hclk_host2", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 3, GFLAGS),
-	GATE(HCLK_OTG, "hclk_otg", "hclk_peri", 0, RK2928_CLKGATE_CON(3), 13, GFLAGS),
-	GATE(0, "hclk_peri_ahb", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 14, GFLAGS),
-	GATE(HCLK_SPDIF, "hclk_spdif", "hclk_peri", 0, RK2928_CLKGATE_CON(10), 9, GFLAGS),
-	GATE(HCLK_TSP, "hclk_tsp", "hclk_peri", 0, RK2928_CLKGATE_CON(10), 12, GFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 10, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 11, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 0, GFLAGS),
-	GATE(0, "hclk_emmc_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(3), 6, GFLAGS),
-	GATE(HCLK_NANDC, "hclk_nandc", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 9, GFLAGS),
-	GATE(HCLK_USBHOST, "hclk_usbhost", "hclk_peri", 0, RK2928_CLKGATE_CON(10), 14, GFLAGS),
-
-	GATE(PCLK_SIM_CARD, "pclk_sim_card", "pclk_peri", 0, RK2928_CLKGATE_CON(9), 12, GFLAGS),
-	GATE(PCLK_GMAC, "pclk_gmac", "pclk_peri", 0, RK2928_CLKGATE_CON(10), 11, GFLAGS),
-	GATE(0, "pclk_peri_axi", "pclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 1, GFLAGS),
-	GATE(PCLK_SPI0, "pclk_spi0", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 12, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 0, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 1, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 2, GFLAGS),
-	GATE(PCLK_PWM, "pclk_pwm", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 10, GFLAGS),
-	GATE(PCLK_WDT, "pclk_wdt", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 15, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 4, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 5, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 6, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 7, GFLAGS),
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 14, GFLAGS),
-	GATE(PCLK_EFUSE, "pclk_efuse", "pclk_peri", 0, RK2928_CLKGATE_CON(5), 2, GFLAGS),
-	GATE(PCLK_TIMER, "pclk_timer", "pclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(7), 7, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 9, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 10, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 11, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 12, GFLAGS),
-
-	/* PD_BUS */
-	GATE(0, "aclk_initmem", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 12, GFLAGS),
-	GATE(0, "aclk_strc_sys", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 10, GFLAGS),
-
-	GATE(0, "hclk_rom", "hclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 6, GFLAGS),
-	GATE(HCLK_CRYPTO, "hclk_crypto", "hclk_cpu", 0, RK2928_CLKGATE_CON(3), 5, GFLAGS),
-
-	GATE(PCLK_ACODEC, "pclk_acodec", "pclk_cpu", 0, RK2928_CLKGATE_CON(5), 14, GFLAGS),
-	GATE(0, "pclk_ddrupctl", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 7, GFLAGS),
-	GATE(0, "pclk_grf", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 4, GFLAGS),
-	GATE(0, "pclk_mipiphy", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 0, GFLAGS),
-
-	GATE(0, "pclk_pmu", "pclk_pmu_pre", 0, RK2928_CLKGATE_CON(9), 2, GFLAGS),
-	GATE(0, "pclk_pmu_niu", "pclk_pmu_pre", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 3, GFLAGS),
-
-	/* PD_MMC */
-	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RK3228_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3228_SDMMC_CON1, 0),
-
-	MMC(SCLK_SDIO_DRV,     "sdio_drv",     "sclk_sdio",  RK3228_SDIO_CON0,  1),
-	MMC(SCLK_SDIO_SAMPLE,  "sdio_sample",  "sclk_sdio",  RK3228_SDIO_CON1,  0),
-
-	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RK3228_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3228_EMMC_CON1,  0),
-};
-
-static struct rockchip_clk_branch rk3126_clk_branches[] __initdata = {
-	GATE(0, "pclk_stimer", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(3), 15, GFLAGS),
-	GATE(0, "pclk_s_efuse", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(3), 14, GFLAGS),
-	GATE(0, "pclk_sgrf", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(3), 8, GFLAGS),
-};
-
-static struct rockchip_clk_branch rk3128_clk_branches[] __initdata = {
-	COMPOSITE(SCLK_SFC, "sclk_sfc", mux_sclk_sfc_src_p, 0,
-			RK2928_CLKSEL_CON(11), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 15, GFLAGS),
-
-	GATE(HCLK_GPS, "hclk_gps", "aclk_peri", 0, RK2928_CLKGATE_CON(3), 14, GFLAGS),
-	GATE(PCLK_HDMI, "pclk_hdmi", "pclk_cpu", 0, RK2928_CLKGATE_CON(3), 8, GFLAGS),
-};
-
-static const char *const rk3128_critical_clocks[] __initconst = {
-	"aclk_cpu",
-	"hclk_cpu",
-	"pclk_cpu",
-	"aclk_peri",
-	"hclk_peri",
-	"pclk_peri",
-	"pclk_pmu",
-	"sclk_timer5",
-};
-
-static struct rockchip_clk_provider *__init rk3128_common_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	rockchip_clk_register_plls(ctx, rk3128_pll_clks,
-				   ARRAY_SIZE(rk3128_pll_clks),
-				   RK3128_GRF_SOC_STATUS0);
-	rockchip_clk_register_branches(ctx, common_clk_branches,
-				  ARRAY_SIZE(common_clk_branches));
-
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-			mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-			&rk3128_cpuclk_data, rk3128_cpuclk_rates,
-			ARRAY_SIZE(rk3128_cpuclk_rates));
-
-	rockchip_register_softrst(np, 9, reg_base + RK2928_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK2928_GLB_SRST_FST, NULL);
-
-	return ctx;
-}
-
-static void __init rk3126_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-
-	ctx = rk3128_common_clk_init(np);
-	if (IS_ERR(ctx))
-		return;
-
-	rockchip_clk_register_branches(ctx, rk3126_clk_branches,
-				       ARRAY_SIZE(rk3126_clk_branches));
-	rockchip_clk_protect_critical(rk3128_critical_clocks,
-				      ARRAY_SIZE(rk3128_critical_clocks));
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-
-CLK_OF_DECLARE(rk3126_cru, "rockchip,rk3126-cru", rk3126_clk_init);
-
-static void __init rk3128_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-
-	ctx = rk3128_common_clk_init(np);
-	if (IS_ERR(ctx))
-		return;
-
-	rockchip_clk_register_branches(ctx, rk3128_clk_branches,
-				       ARRAY_SIZE(rk3128_clk_branches));
-	rockchip_clk_protect_critical(rk3128_critical_clocks,
-				      ARRAY_SIZE(rk3128_critical_clocks));
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-
-CLK_OF_DECLARE(rk3128_cru, "rockchip,rk3128-cru", rk3128_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3188.c b/drivers/clk/rockchip/clk-rk3188.c
deleted file mode 100644
index 2ca7e2be2..000000000
--- a/drivers/clk/rockchip/clk-rk3188.c
+++ /dev/null
@@ -1,879 +0,0 @@
-/*
- * Copyright (c) 2014 MundoReader S.L.
- * Author: Heiko Stuebner <heiko@sntech.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <dt-bindings/clock/rk3188-cru-common.h>
-#include "clk.h"
-
-#define RK3066_GRF_SOC_STATUS	0x15c
-#define RK3188_GRF_SOC_STATUS	0xac
-
-enum rk3188_plls {
-	apll, cpll, dpll, gpll,
-};
-
-static struct rockchip_pll_rate_table rk3188_pll_rates[] = {
-	RK3066_PLL_RATE(2208000000, 1, 92, 1),
-	RK3066_PLL_RATE(2184000000, 1, 91, 1),
-	RK3066_PLL_RATE(2160000000, 1, 90, 1),
-	RK3066_PLL_RATE(2136000000, 1, 89, 1),
-	RK3066_PLL_RATE(2112000000, 1, 88, 1),
-	RK3066_PLL_RATE(2088000000, 1, 87, 1),
-	RK3066_PLL_RATE(2064000000, 1, 86, 1),
-	RK3066_PLL_RATE(2040000000, 1, 85, 1),
-	RK3066_PLL_RATE(2016000000, 1, 84, 1),
-	RK3066_PLL_RATE(1992000000, 1, 83, 1),
-	RK3066_PLL_RATE(1968000000, 1, 82, 1),
-	RK3066_PLL_RATE(1944000000, 1, 81, 1),
-	RK3066_PLL_RATE(1920000000, 1, 80, 1),
-	RK3066_PLL_RATE(1896000000, 1, 79, 1),
-	RK3066_PLL_RATE(1872000000, 1, 78, 1),
-	RK3066_PLL_RATE(1848000000, 1, 77, 1),
-	RK3066_PLL_RATE(1824000000, 1, 76, 1),
-	RK3066_PLL_RATE(1800000000, 1, 75, 1),
-	RK3066_PLL_RATE(1776000000, 1, 74, 1),
-	RK3066_PLL_RATE(1752000000, 1, 73, 1),
-	RK3066_PLL_RATE(1728000000, 1, 72, 1),
-	RK3066_PLL_RATE(1704000000, 1, 71, 1),
-	RK3066_PLL_RATE(1680000000, 1, 70, 1),
-	RK3066_PLL_RATE(1656000000, 1, 69, 1),
-	RK3066_PLL_RATE(1632000000, 1, 68, 1),
-	RK3066_PLL_RATE(1608000000, 1, 67, 1),
-	RK3066_PLL_RATE(1560000000, 1, 65, 1),
-	RK3066_PLL_RATE(1512000000, 1, 63, 1),
-	RK3066_PLL_RATE(1488000000, 1, 62, 1),
-	RK3066_PLL_RATE(1464000000, 1, 61, 1),
-	RK3066_PLL_RATE(1440000000, 1, 60, 1),
-	RK3066_PLL_RATE(1416000000, 1, 59, 1),
-	RK3066_PLL_RATE(1392000000, 1, 58, 1),
-	RK3066_PLL_RATE(1368000000, 1, 57, 1),
-	RK3066_PLL_RATE(1344000000, 1, 56, 1),
-	RK3066_PLL_RATE(1320000000, 1, 55, 1),
-	RK3066_PLL_RATE(1296000000, 1, 54, 1),
-	RK3066_PLL_RATE(1272000000, 1, 53, 1),
-	RK3066_PLL_RATE(1248000000, 1, 52, 1),
-	RK3066_PLL_RATE(1224000000, 1, 51, 1),
-	RK3066_PLL_RATE(1200000000, 1, 50, 1),
-	RK3066_PLL_RATE(1188000000, 2, 99, 1),
-	RK3066_PLL_RATE(1176000000, 1, 49, 1),
-	RK3066_PLL_RATE(1128000000, 1, 47, 1),
-	RK3066_PLL_RATE(1104000000, 1, 46, 1),
-	RK3066_PLL_RATE(1008000000, 1, 84, 2),
-	RK3066_PLL_RATE( 912000000, 1, 76, 2),
-	RK3066_PLL_RATE( 891000000, 8, 594, 2),
-	RK3066_PLL_RATE( 888000000, 1, 74, 2),
-	RK3066_PLL_RATE( 816000000, 1, 68, 2),
-	RK3066_PLL_RATE( 798000000, 2, 133, 2),
-	RK3066_PLL_RATE( 792000000, 1, 66, 2),
-	RK3066_PLL_RATE( 768000000, 1, 64, 2),
-	RK3066_PLL_RATE( 742500000, 8, 495, 2),
-	RK3066_PLL_RATE( 696000000, 1, 58, 2),
-	RK3066_PLL_RATE( 600000000, 1, 50, 2),
-	RK3066_PLL_RATE( 594000000, 2, 198, 4),
-	RK3066_PLL_RATE( 552000000, 1, 46, 2),
-	RK3066_PLL_RATE( 504000000, 1, 84, 4),
-	RK3066_PLL_RATE( 456000000, 1, 76, 4),
-	RK3066_PLL_RATE( 408000000, 1, 68, 4),
-	RK3066_PLL_RATE( 400000000, 3, 100, 2),
-	RK3066_PLL_RATE( 384000000, 2, 128, 4),
-	RK3066_PLL_RATE( 360000000, 1, 60, 4),
-	RK3066_PLL_RATE( 312000000, 1, 52, 4),
-	RK3066_PLL_RATE( 300000000, 1, 50, 4),
-	RK3066_PLL_RATE( 297000000, 2, 198, 8),
-	RK3066_PLL_RATE( 252000000, 1, 84, 8),
-	RK3066_PLL_RATE( 216000000, 1, 72, 8),
-	RK3066_PLL_RATE( 148500000, 2, 99, 8),
-	RK3066_PLL_RATE( 126000000, 1, 84, 16),
-	RK3066_PLL_RATE(  48000000, 1, 64, 32),
-	{ /* sentinel */ },
-};
-
-#define RK3066_DIV_CORE_PERIPH_MASK	0x3
-#define RK3066_DIV_CORE_PERIPH_SHIFT	6
-#define RK3066_DIV_ACLK_CORE_MASK	0x7
-#define RK3066_DIV_ACLK_CORE_SHIFT	0
-#define RK3066_DIV_ACLK_HCLK_MASK	0x3
-#define RK3066_DIV_ACLK_HCLK_SHIFT	8
-#define RK3066_DIV_ACLK_PCLK_MASK	0x3
-#define RK3066_DIV_ACLK_PCLK_SHIFT	12
-#define RK3066_DIV_AHB2APB_MASK		0x3
-#define RK3066_DIV_AHB2APB_SHIFT	14
-
-#define RK3066_CLKSEL0(_core_peri)					\
-	{								\
-		.reg = RK2928_CLKSEL_CON(0),				\
-		.val = HIWORD_UPDATE(_core_peri, RK3066_DIV_CORE_PERIPH_MASK, \
-				RK3066_DIV_CORE_PERIPH_SHIFT)		\
-	}
-#define RK3066_CLKSEL1(_aclk_core, _aclk_hclk, _aclk_pclk, _ahb2apb)	\
-	{								\
-		.reg = RK2928_CLKSEL_CON(1),				\
-		.val = HIWORD_UPDATE(_aclk_core, RK3066_DIV_ACLK_CORE_MASK, \
-				RK3066_DIV_ACLK_CORE_SHIFT) |		\
-		       HIWORD_UPDATE(_aclk_hclk, RK3066_DIV_ACLK_HCLK_MASK, \
-				RK3066_DIV_ACLK_HCLK_SHIFT) |		\
-		       HIWORD_UPDATE(_aclk_pclk, RK3066_DIV_ACLK_PCLK_MASK, \
-				RK3066_DIV_ACLK_PCLK_SHIFT) |		\
-		       HIWORD_UPDATE(_ahb2apb, RK3066_DIV_AHB2APB_MASK,	\
-				RK3066_DIV_AHB2APB_SHIFT),		\
-	}
-
-#define RK3066_CPUCLK_RATE(_prate, _core_peri, _acore, _ahclk, _apclk, _h2p) \
-	{								\
-		.prate = _prate,					\
-		.divs = {						\
-			RK3066_CLKSEL0(_core_peri),			\
-			RK3066_CLKSEL1(_acore, _ahclk, _apclk, _h2p),	\
-		},							\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3066_cpuclk_rates[] __initdata = {
-	RK3066_CPUCLK_RATE(1416000000, 2, 3, 1, 2, 1),
-	RK3066_CPUCLK_RATE(1200000000, 2, 3, 1, 2, 1),
-	RK3066_CPUCLK_RATE(1008000000, 2, 2, 1, 2, 1),
-	RK3066_CPUCLK_RATE( 816000000, 2, 2, 1, 2, 1),
-	RK3066_CPUCLK_RATE( 600000000, 1, 2, 1, 2, 1),
-	RK3066_CPUCLK_RATE( 504000000, 1, 1, 1, 2, 1),
-	RK3066_CPUCLK_RATE( 312000000, 0, 1, 1, 1, 0),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3066_cpuclk_data = {
-	.core_reg = RK2928_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 8,
-	.mux_core_mask = 0x1,
-};
-
-#define RK3188_DIV_ACLK_CORE_MASK	0x7
-#define RK3188_DIV_ACLK_CORE_SHIFT	3
-
-#define RK3188_CLKSEL1(_aclk_core)		\
-	{					\
-		.reg = RK2928_CLKSEL_CON(1),	\
-		.val = HIWORD_UPDATE(_aclk_core, RK3188_DIV_ACLK_CORE_MASK,\
-				 RK3188_DIV_ACLK_CORE_SHIFT) \
-	}
-#define RK3188_CPUCLK_RATE(_prate, _core_peri, _aclk_core)	\
-	{							\
-		.prate = _prate,				\
-		.divs = {					\
-			RK3066_CLKSEL0(_core_peri),		\
-			RK3188_CLKSEL1(_aclk_core),		\
-		},						\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3188_cpuclk_rates[] __initdata = {
-	RK3188_CPUCLK_RATE(1608000000, 2, 3),
-	RK3188_CPUCLK_RATE(1416000000, 2, 3),
-	RK3188_CPUCLK_RATE(1200000000, 2, 3),
-	RK3188_CPUCLK_RATE(1008000000, 2, 3),
-	RK3188_CPUCLK_RATE( 816000000, 2, 3),
-	RK3188_CPUCLK_RATE( 600000000, 1, 3),
-	RK3188_CPUCLK_RATE( 504000000, 1, 3),
-	RK3188_CPUCLK_RATE( 312000000, 0, 1),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3188_cpuclk_data = {
-	.core_reg = RK2928_CLKSEL_CON(0),
-	.div_core_shift = 9,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 8,
-	.mux_core_mask = 0x1,
-};
-
-PNAME(mux_pll_p)		= { "xin24m", "xin32k" };
-PNAME(mux_armclk_p)		= { "apll", "gpll_armclk" };
-PNAME(mux_ddrphy_p)		= { "dpll", "gpll_ddr" };
-PNAME(mux_pll_src_gpll_cpll_p)	= { "gpll", "cpll" };
-PNAME(mux_pll_src_cpll_gpll_p)	= { "cpll", "gpll" };
-PNAME(mux_aclk_cpu_p)		= { "apll", "gpll" };
-PNAME(mux_sclk_cif0_p)		= { "cif0_pre", "xin24m" };
-PNAME(mux_sclk_i2s0_p)		= { "i2s0_pre", "i2s0_frac", "xin12m" };
-PNAME(mux_sclk_spdif_p)		= { "spdif_pre", "spdif_frac", "xin12m" };
-PNAME(mux_sclk_uart0_p)		= { "uart0_pre", "uart0_frac", "xin24m" };
-PNAME(mux_sclk_uart1_p)		= { "uart1_pre", "uart1_frac", "xin24m" };
-PNAME(mux_sclk_uart2_p)		= { "uart2_pre", "uart2_frac", "xin24m" };
-PNAME(mux_sclk_uart3_p)		= { "uart3_pre", "uart3_frac", "xin24m" };
-PNAME(mux_sclk_hsadc_p)		= { "hsadc_src", "hsadc_frac", "ext_hsadc" };
-PNAME(mux_mac_p)		= { "gpll", "dpll" };
-PNAME(mux_sclk_macref_p)	= { "mac_src", "ext_rmii" };
-
-static struct rockchip_pll_clock rk3066_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3066, PLL_APLL, "apll", mux_pll_p, 0, RK2928_PLL_CON(0),
-		     RK2928_MODE_CON, 0, 5, 0, rk3188_pll_rates),
-	[dpll] = PLL(pll_rk3066, PLL_DPLL, "dpll", mux_pll_p, 0, RK2928_PLL_CON(4),
-		     RK2928_MODE_CON, 4, 4, 0, NULL),
-	[cpll] = PLL(pll_rk3066, PLL_CPLL, "cpll", mux_pll_p, 0, RK2928_PLL_CON(8),
-		     RK2928_MODE_CON, 8, 6, ROCKCHIP_PLL_SYNC_RATE, rk3188_pll_rates),
-	[gpll] = PLL(pll_rk3066, PLL_GPLL, "gpll", mux_pll_p, 0, RK2928_PLL_CON(12),
-		     RK2928_MODE_CON, 12, 7, ROCKCHIP_PLL_SYNC_RATE, rk3188_pll_rates),
-};
-
-static struct rockchip_pll_clock rk3188_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3066, PLL_APLL, "apll", mux_pll_p, 0, RK2928_PLL_CON(0),
-		     RK2928_MODE_CON, 0, 6, 0, rk3188_pll_rates),
-	[dpll] = PLL(pll_rk3066, PLL_DPLL, "dpll", mux_pll_p, 0, RK2928_PLL_CON(4),
-		     RK2928_MODE_CON, 4, 5, 0, NULL),
-	[cpll] = PLL(pll_rk3066, PLL_CPLL, "cpll", mux_pll_p, 0, RK2928_PLL_CON(8),
-		     RK2928_MODE_CON, 8, 7, ROCKCHIP_PLL_SYNC_RATE, rk3188_pll_rates),
-	[gpll] = PLL(pll_rk3066, PLL_GPLL, "gpll", mux_pll_p, 0, RK2928_PLL_CON(12),
-		     RK2928_MODE_CON, 12, 8, ROCKCHIP_PLL_SYNC_RATE, rk3188_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-#define IFLAGS ROCKCHIP_INVERTER_HIWORD_MASK
-
-/* 2 ^ (val + 1) */
-static struct clk_div_table div_core_peri_t[] = {
-	{ .val = 0, .div = 2 },
-	{ .val = 1, .div = 4 },
-	{ .val = 2, .div = 8 },
-	{ .val = 3, .div = 16 },
-	{ /* sentinel */ },
-};
-
-static struct rockchip_clk_branch common_hsadc_out_fracmux __initdata =
-	MUX(0, "sclk_hsadc_out", mux_sclk_hsadc_p, 0,
-			RK2928_CLKSEL_CON(22), 4, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_spdif_fracmux __initdata =
-	MUX(SCLK_SPDIF, "sclk_spdif", mux_sclk_spdif_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(5), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_sclk_uart0_p, 0,
-			RK2928_CLKSEL_CON(13), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_sclk_uart1_p, 0,
-			RK2928_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_sclk_uart2_p, 0,
-			RK2928_CLKSEL_CON(15), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_uart3_fracmux __initdata =
-	MUX(SCLK_UART3, "sclk_uart3", mux_sclk_uart3_p, 0,
-			RK2928_CLKSEL_CON(16), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch common_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	GATE(0, "gpll_armclk", "gpll", 0, RK2928_CLKGATE_CON(0), 1, GFLAGS),
-
-	/* these two are set by the cpuclk and should not be changed */
-	COMPOSITE_NOMUX_DIVTBL(CORE_PERI, "core_peri", "armclk", 0,
-			RK2928_CLKSEL_CON(0), 6, 2, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			div_core_peri_t, RK2928_CLKGATE_CON(0), 0, GFLAGS),
-
-	COMPOSITE(ACLK_VEPU, "aclk_vepu", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(32), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 9, GFLAGS),
-	GATE(HCLK_VEPU, "hclk_vepu", "aclk_vepu", 0,
-			RK2928_CLKGATE_CON(3), 10, GFLAGS),
-	COMPOSITE(ACLK_VDPU, "aclk_vdpu", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(32), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 11, GFLAGS),
-	GATE(HCLK_VDPU, "hclk_vdpu", "aclk_vdpu", 0,
-			RK2928_CLKGATE_CON(3), 12, GFLAGS),
-
-	GATE(0, "gpll_ddr", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(1), 7, GFLAGS),
-	COMPOSITE(0, "ddrphy", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(26), 8, 1, MFLAGS, 0, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-
-	GATE(ACLK_CPU, "aclk_cpu", "aclk_cpu_pre", 0,
-			RK2928_CLKGATE_CON(0), 3, GFLAGS),
-
-	GATE(0, "atclk_cpu", "pclk_cpu_pre", 0,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-	GATE(PCLK_CPU, "pclk_cpu", "pclk_cpu_pre", 0,
-			RK2928_CLKGATE_CON(0), 5, GFLAGS),
-	GATE(HCLK_CPU, "hclk_cpu", "hclk_cpu_pre", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 4, GFLAGS),
-
-	COMPOSITE(0, "aclk_lcdc0_pre", mux_pll_src_cpll_gpll_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(31), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 0, GFLAGS),
-	COMPOSITE(0, "aclk_lcdc1_pre", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(31), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 4, GFLAGS),
-
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_pre", 0,
-			RK2928_CLKGATE_CON(2), 1, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERI, "hclk_peri", "aclk_peri_pre", 0,
-			RK2928_CLKSEL_CON(10), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(2), 2, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_pre", 0,
-			RK2928_CLKSEL_CON(10), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(2), 3, GFLAGS),
-
-	MUX(0, "cif_src", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(29), 0, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "cif0_pre", "cif_src", 0,
-			RK2928_CLKSEL_CON(29), 1, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 7, GFLAGS),
-	MUX(SCLK_CIF0, "sclk_cif0", mux_sclk_cif0_p, 0,
-			RK2928_CLKSEL_CON(29), 7, 1, MFLAGS),
-
-	GATE(0, "pclkin_cif0", "ext_cif0", 0,
-			RK2928_CLKGATE_CON(3), 3, GFLAGS),
-	INVERTER(0, "pclk_cif0", "pclkin_cif0",
-			RK2928_CLKSEL_CON(30), 8, IFLAGS),
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	/*
-	 * the 480m are generated inside the usb block from these clocks,
-	 * but they are also a source for the hsicphy clock.
-	 */
-	GATE(SCLK_OTGPHY0, "sclk_otgphy0", "xin24m", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(1), 5, GFLAGS),
-	GATE(SCLK_OTGPHY1, "sclk_otgphy1", "xin24m", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(1), 6, GFLAGS),
-
-	COMPOSITE(0, "mac_src", mux_mac_p, 0,
-			RK2928_CLKSEL_CON(21), 0, 1, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 5, GFLAGS),
-	MUX(SCLK_MAC, "sclk_macref", mux_sclk_macref_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(21), 4, 1, MFLAGS),
-	GATE(0, "sclk_mac_lbtest", "sclk_macref", 0,
-			RK2928_CLKGATE_CON(2), 12, GFLAGS),
-
-	COMPOSITE(0, "hsadc_src", mux_pll_src_gpll_cpll_p, 0,
-			RK2928_CLKSEL_CON(22), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(2), 6, GFLAGS),
-	COMPOSITE_FRACMUX(0, "hsadc_frac", "hsadc_src", 0,
-			RK2928_CLKSEL_CON(23), 0,
-			RK2928_CLKGATE_CON(2), 7, GFLAGS,
-			&common_hsadc_out_fracmux),
-	INVERTER(SCLK_HSADC, "sclk_hsadc", "sclk_hsadc_out",
-			RK2928_CLKSEL_CON(22), 7, IFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_SARADC, "sclk_saradc", "xin24m", 0,
-			RK2928_CLKSEL_CON(24), 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(2), 8, GFLAGS),
-
-	COMPOSITE_NOMUX(0, "spdif_pre", "i2s_src", 0,
-			RK2928_CLKSEL_CON(5), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 13, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_frac", "spdif_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(9), 0,
-			RK2928_CLKGATE_CON(0), 14, GFLAGS,
-			&common_spdif_fracmux),
-
-	/*
-	 * Clock-Architecture Diagram 4
-	 */
-
-	GATE(SCLK_SMC, "sclk_smc", "hclk_peri", 0,
-			RK2928_CLKGATE_CON(2), 4, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_SPI0, "sclk_spi0", "pclk_peri", 0,
-			RK2928_CLKSEL_CON(25), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 9, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_SPI1, "sclk_spi1", "pclk_peri", 0,
-			RK2928_CLKSEL_CON(25), 8, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 10, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_SDMMC, "sclk_sdmmc", "hclk_peri", 0,
-			RK2928_CLKSEL_CON(11), 0, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 11, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_SDIO, "sclk_sdio", "hclk_peri", 0,
-			RK2928_CLKSEL_CON(12), 0, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 13, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_EMMC, "sclk_emmc", "hclk_peri", 0,
-			RK2928_CLKSEL_CON(12), 8, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 14, GFLAGS),
-
-	MUX(0, "uart_src", mux_pll_src_gpll_cpll_p, 0,
-			RK2928_CLKSEL_CON(12), 15, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "uart0_pre", "uart_src", 0,
-			RK2928_CLKSEL_CON(13), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 8, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_pre", 0,
-			RK2928_CLKSEL_CON(17), 0,
-			RK2928_CLKGATE_CON(1), 9, GFLAGS,
-			&common_uart0_fracmux),
-	COMPOSITE_NOMUX(0, "uart1_pre", "uart_src", 0,
-			RK2928_CLKSEL_CON(14), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 10, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_pre", 0,
-			RK2928_CLKSEL_CON(18), 0,
-			RK2928_CLKGATE_CON(1), 11, GFLAGS,
-			&common_uart1_fracmux),
-	COMPOSITE_NOMUX(0, "uart2_pre", "uart_src", 0,
-			RK2928_CLKSEL_CON(15), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 12, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart2_frac", "uart2_pre", 0,
-			RK2928_CLKSEL_CON(19), 0,
-			RK2928_CLKGATE_CON(1), 13, GFLAGS,
-			&common_uart2_fracmux),
-	COMPOSITE_NOMUX(0, "uart3_pre", "uart_src", 0,
-			RK2928_CLKSEL_CON(16), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 14, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart3_frac", "uart3_pre", 0,
-			RK2928_CLKSEL_CON(20), 0,
-			RK2928_CLKGATE_CON(1), 15, GFLAGS,
-			&common_uart3_fracmux),
-
-	GATE(SCLK_JTAG, "jtag", "ext_jtag", 0, RK2928_CLKGATE_CON(1), 3, GFLAGS),
-
-	GATE(SCLK_TIMER0, "timer0", "xin24m", 0, RK2928_CLKGATE_CON(1), 0, GFLAGS),
-	GATE(SCLK_TIMER1, "timer1", "xin24m", 0, RK2928_CLKGATE_CON(1), 1, GFLAGS),
-
-	/* clk_core_pre gates */
-	GATE(0, "core_dbg", "armclk", 0, RK2928_CLKGATE_CON(9), 0, GFLAGS),
-
-	/* aclk_cpu gates */
-	GATE(ACLK_DMA1, "aclk_dma1", "aclk_cpu", 0, RK2928_CLKGATE_CON(5), 0, GFLAGS),
-	GATE(0, "aclk_intmem", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 12, GFLAGS),
-	GATE(0, "aclk_strc_sys", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 10, GFLAGS),
-
-	/* hclk_cpu gates */
-	GATE(HCLK_ROM, "hclk_rom", "hclk_cpu", 0, RK2928_CLKGATE_CON(5), 6, GFLAGS),
-	GATE(HCLK_I2S0, "hclk_i2s0", "hclk_cpu", 0, RK2928_CLKGATE_CON(7), 2, GFLAGS),
-	GATE(HCLK_SPDIF, "hclk_spdif", "hclk_cpu", 0, RK2928_CLKGATE_CON(7), 1, GFLAGS),
-	GATE(0, "hclk_cpubus", "hclk_cpu", 0, RK2928_CLKGATE_CON(4), 8, GFLAGS),
-	/* hclk_ahb2apb is part of a clk branch */
-	GATE(0, "hclk_vio_bus", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 12, GFLAGS),
-	GATE(HCLK_LCDC0, "hclk_lcdc0", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 1, GFLAGS),
-	GATE(HCLK_LCDC1, "hclk_lcdc1", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 2, GFLAGS),
-	GATE(HCLK_CIF0, "hclk_cif0", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 4, GFLAGS),
-	GATE(HCLK_IPP, "hclk_ipp", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 9, GFLAGS),
-	GATE(HCLK_RGA, "hclk_rga", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 10, GFLAGS),
-
-	/* hclk_peri gates */
-	GATE(0, "hclk_peri_axi_matrix", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 0, GFLAGS),
-	GATE(0, "hclk_peri_ahb_arbi", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 6, GFLAGS),
-	GATE(0, "hclk_emem_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 7, GFLAGS),
-	GATE(HCLK_EMAC, "hclk_emac", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 0, GFLAGS),
-	GATE(HCLK_NANDC0, "hclk_nandc0", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 9, GFLAGS),
-	GATE(0, "hclk_usb_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 5, GFLAGS),
-	GATE(HCLK_OTG0, "hclk_usbotg0", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 13, GFLAGS),
-	GATE(HCLK_HSADC, "hclk_hsadc", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 5, GFLAGS),
-	GATE(HCLK_PIDF, "hclk_pidfilter", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 6, GFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 10, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 11, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 12, GFLAGS),
-
-	/* aclk_lcdc0_pre gates */
-	GATE(0, "aclk_vio0", "aclk_lcdc0_pre", 0, RK2928_CLKGATE_CON(6), 13, GFLAGS),
-	GATE(ACLK_LCDC0, "aclk_lcdc0", "aclk_vio0", 0, RK2928_CLKGATE_CON(6), 0, GFLAGS),
-	GATE(ACLK_CIF0, "aclk_cif0", "aclk_vio0", 0, RK2928_CLKGATE_CON(6), 5, GFLAGS),
-	GATE(ACLK_IPP, "aclk_ipp", "aclk_vio0", 0, RK2928_CLKGATE_CON(6), 8, GFLAGS),
-
-	/* aclk_lcdc1_pre gates */
-	GATE(0, "aclk_vio1", "aclk_lcdc1_pre", 0, RK2928_CLKGATE_CON(9), 5, GFLAGS),
-	GATE(ACLK_LCDC1, "aclk_lcdc1", "aclk_vio1", 0, RK2928_CLKGATE_CON(6), 3, GFLAGS),
-	GATE(ACLK_RGA, "aclk_rga", "aclk_vio1", 0, RK2928_CLKGATE_CON(6), 11, GFLAGS),
-
-	/* atclk_cpu gates */
-	GATE(0, "atclk", "atclk_cpu", 0, RK2928_CLKGATE_CON(9), 3, GFLAGS),
-	GATE(0, "trace", "atclk_cpu", 0, RK2928_CLKGATE_CON(9), 2, GFLAGS),
-
-	/* pclk_cpu gates */
-	GATE(PCLK_PWM01, "pclk_pwm01", "pclk_cpu", 0, RK2928_CLKGATE_CON(7), 10, GFLAGS),
-	GATE(PCLK_TIMER0, "pclk_timer0", "pclk_cpu", 0, RK2928_CLKGATE_CON(7), 7, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 4, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 5, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 9, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 10, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 11, GFLAGS),
-	GATE(PCLK_EFUSE, "pclk_efuse", "pclk_cpu", 0, RK2928_CLKGATE_CON(5), 2, GFLAGS),
-	GATE(PCLK_TZPC, "pclk_tzpc", "pclk_cpu", 0, RK2928_CLKGATE_CON(5), 3, GFLAGS),
-	GATE(PCLK_DDRUPCTL, "pclk_ddrupctl", "pclk_cpu", 0, RK2928_CLKGATE_CON(5), 7, GFLAGS),
-	GATE(PCLK_PUBL, "pclk_ddrpubl", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 6, GFLAGS),
-	GATE(0, "pclk_dbg", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 1, GFLAGS),
-	GATE(PCLK_GRF, "pclk_grf", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 4, GFLAGS),
-	GATE(PCLK_PMU, "pclk_pmu", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(5), 5, GFLAGS),
-
-	/* aclk_peri */
-	GATE(ACLK_DMA2, "aclk_dma2", "aclk_peri", 0, RK2928_CLKGATE_CON(5), 1, GFLAGS),
-	GATE(ACLK_SMC, "aclk_smc", "aclk_peri", 0, RK2928_CLKGATE_CON(5), 8, GFLAGS),
-	GATE(0, "aclk_peri_niu", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 4, GFLAGS),
-	GATE(0, "aclk_cpu_peri", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 2, GFLAGS),
-	GATE(0, "aclk_peri_axi_matrix", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 3, GFLAGS),
-
-	/* pclk_peri gates */
-	GATE(0, "pclk_peri_axi_matrix", "pclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(4), 1, GFLAGS),
-	GATE(PCLK_PWM23, "pclk_pwm23", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 11, GFLAGS),
-	GATE(PCLK_WDT, "pclk_wdt", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 15, GFLAGS),
-	GATE(PCLK_SPI0, "pclk_spi0", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 12, GFLAGS),
-	GATE(PCLK_SPI1, "pclk_spi1", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 13, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 2, GFLAGS),
-	GATE(PCLK_UART3, "pclk_uart3", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 3, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 6, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 7, GFLAGS),
-	GATE(PCLK_I2C4, "pclk_i2c4", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 8, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 12, GFLAGS),
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_peri", 0, RK2928_CLKGATE_CON(7), 14, GFLAGS),
-};
-
-PNAME(mux_rk3066_lcdc0_p)	= { "dclk_lcdc0_src", "xin27m" };
-PNAME(mux_rk3066_lcdc1_p)	= { "dclk_lcdc1_src", "xin27m" };
-PNAME(mux_sclk_cif1_p)		= { "cif1_pre", "xin24m" };
-PNAME(mux_sclk_i2s1_p)		= { "i2s1_pre", "i2s1_frac", "xin12m" };
-PNAME(mux_sclk_i2s2_p)		= { "i2s2_pre", "i2s2_frac", "xin12m" };
-
-static struct clk_div_table div_aclk_cpu_t[] = {
-	{ .val = 0, .div = 1 },
-	{ .val = 1, .div = 2 },
-	{ .val = 2, .div = 3 },
-	{ .val = 3, .div = 4 },
-	{ .val = 4, .div = 8 },
-	{ /* sentinel */ },
-};
-
-static struct rockchip_clk_branch rk3066a_i2s0_fracmux __initdata =
-	MUX(SCLK_I2S0, "sclk_i2s0", mux_sclk_i2s0_p, 0,
-			RK2928_CLKSEL_CON(2), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3066a_i2s1_fracmux __initdata =
-	MUX(SCLK_I2S1, "sclk_i2s1", mux_sclk_i2s1_p, 0,
-			RK2928_CLKSEL_CON(3), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3066a_i2s2_fracmux __initdata =
-	MUX(SCLK_I2S2, "sclk_i2s2", mux_sclk_i2s2_p, 0,
-			RK2928_CLKSEL_CON(4), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3066a_clk_branches[] __initdata = {
-	DIVTBL(0, "aclk_cpu_pre", "armclk", 0,
-			RK2928_CLKSEL_CON(1), 0, 3, DFLAGS | CLK_DIVIDER_READ_ONLY, div_aclk_cpu_t),
-	DIV(0, "pclk_cpu_pre", "aclk_cpu_pre", 0,
-			RK2928_CLKSEL_CON(1), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO
-							    | CLK_DIVIDER_READ_ONLY),
-	DIV(0, "hclk_cpu_pre", "aclk_cpu_pre", 0,
-			RK2928_CLKSEL_CON(1), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO
-							   | CLK_DIVIDER_READ_ONLY),
-	COMPOSITE_NOMUX(0, "hclk_ahb2apb", "hclk_cpu_pre", 0,
-			RK2928_CLKSEL_CON(1), 14, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO
-							    | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(4), 9, GFLAGS),
-
-	GATE(CORE_L2C, "core_l2c", "aclk_cpu", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(9), 4, GFLAGS),
-
-	COMPOSITE(0, "aclk_peri_pre", mux_pll_src_gpll_cpll_p, 0,
-			RK2928_CLKSEL_CON(10), 15, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-
-	COMPOSITE(0, "dclk_lcdc0_src", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(27), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	MUX(DCLK_LCDC0, "dclk_lcdc0", mux_rk3066_lcdc0_p, 0,
-			RK2928_CLKSEL_CON(27), 4, 1, MFLAGS),
-	COMPOSITE(0, "dclk_lcdc1_src", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(28), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 2, GFLAGS),
-	MUX(DCLK_LCDC1, "dclk_lcdc1", mux_rk3066_lcdc1_p, 0,
-			RK2928_CLKSEL_CON(28), 4, 1, MFLAGS),
-
-	COMPOSITE_NOMUX(0, "cif1_pre", "cif_src", 0,
-			RK2928_CLKSEL_CON(29), 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 8, GFLAGS),
-	MUX(SCLK_CIF1, "sclk_cif1", mux_sclk_cif1_p, 0,
-			RK2928_CLKSEL_CON(29), 15, 1, MFLAGS),
-
-	GATE(0, "pclkin_cif1", "ext_cif1", 0,
-			RK2928_CLKGATE_CON(3), 4, GFLAGS),
-	INVERTER(0, "pclk_cif1", "pclkin_cif1",
-			RK2928_CLKSEL_CON(30), 12, IFLAGS),
-
-	COMPOSITE(0, "aclk_gpu_src", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(33), 8, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 13, GFLAGS),
-	GATE(ACLK_GPU, "aclk_gpu", "aclk_gpu_src", 0,
-			RK2928_CLKGATE_CON(5), 15, GFLAGS),
-
-	GATE(SCLK_TIMER2, "timer2", "xin24m", 0,
-			RK2928_CLKGATE_CON(3), 2, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_TSADC, "sclk_tsadc", "xin24m", 0,
-			RK2928_CLKSEL_CON(34), 0, 16, DFLAGS,
-			RK2928_CLKGATE_CON(2), 15, GFLAGS),
-
-	MUX(0, "i2s_src", mux_pll_src_gpll_cpll_p, 0,
-			RK2928_CLKSEL_CON(2), 15, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "i2s0_pre", "i2s_src", 0,
-			RK2928_CLKSEL_CON(2), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 7, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s0_frac", "i2s0_pre", 0,
-			RK2928_CLKSEL_CON(6), 0,
-			RK2928_CLKGATE_CON(0), 8, GFLAGS,
-			&rk3066a_i2s0_fracmux),
-	COMPOSITE_NOMUX(0, "i2s1_pre", "i2s_src", 0,
-			RK2928_CLKSEL_CON(3), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 9, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s1_frac", "i2s1_pre", 0,
-			RK2928_CLKSEL_CON(7), 0,
-			RK2928_CLKGATE_CON(0), 10, GFLAGS,
-			&rk3066a_i2s1_fracmux),
-	COMPOSITE_NOMUX(0, "i2s2_pre", "i2s_src", 0,
-			RK2928_CLKSEL_CON(4), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 11, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s2_frac", "i2s2_pre", 0,
-			RK2928_CLKSEL_CON(8), 0,
-			RK2928_CLKGATE_CON(0), 12, GFLAGS,
-			&rk3066a_i2s2_fracmux),
-
-	GATE(HCLK_I2S1, "hclk_i2s1", "hclk_cpu", 0, RK2928_CLKGATE_CON(7), 3, GFLAGS),
-	GATE(HCLK_I2S2, "hclk_i2s2", "hclk_cpu", 0, RK2928_CLKGATE_CON(7), 4, GFLAGS),
-	GATE(HCLK_CIF1, "hclk_cif1", "hclk_cpu", 0, RK2928_CLKGATE_CON(6), 6, GFLAGS),
-	GATE(0, "hclk_hdmi", "hclk_cpu", 0, RK2928_CLKGATE_CON(4), 14, GFLAGS),
-
-	GATE(HCLK_OTG1, "hclk_usbotg1", "hclk_peri", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(5), 14, GFLAGS),
-
-	GATE(ACLK_CIF1, "aclk_cif1", "aclk_vio1", 0, RK2928_CLKGATE_CON(6), 7, GFLAGS),
-
-	GATE(PCLK_TIMER1, "pclk_timer1", "pclk_cpu", 0, RK2928_CLKGATE_CON(7), 8, GFLAGS),
-	GATE(PCLK_TIMER2, "pclk_timer2", "pclk_cpu", 0, RK2928_CLKGATE_CON(7), 9, GFLAGS),
-	GATE(PCLK_GPIO6, "pclk_gpio6", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 15, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 0, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 1, GFLAGS),
-
-	GATE(PCLK_GPIO4, "pclk_gpio4", "pclk_peri", 0, RK2928_CLKGATE_CON(8), 13, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_peri", 0, RK2928_CLKGATE_CON(4), 13, GFLAGS),
-};
-
-static struct clk_div_table div_rk3188_aclk_core_t[] = {
-	{ .val = 0, .div = 1 },
-	{ .val = 1, .div = 2 },
-	{ .val = 2, .div = 3 },
-	{ .val = 3, .div = 4 },
-	{ .val = 4, .div = 8 },
-	{ /* sentinel */ },
-};
-
-PNAME(mux_hsicphy_p)		= { "sclk_otgphy0_480m", "sclk_otgphy1_480m",
-				    "gpll", "cpll" };
-
-static struct rockchip_clk_branch rk3188_i2s0_fracmux __initdata =
-	MUX(SCLK_I2S0, "sclk_i2s0", mux_sclk_i2s0_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(3), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3188_clk_branches[] __initdata = {
-	COMPOSITE_NOMUX_DIVTBL(0, "aclk_core", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 3, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			div_rk3188_aclk_core_t, RK2928_CLKGATE_CON(0), 7, GFLAGS),
-
-	/* do not source aclk_cpu_pre from the apll, to keep complexity down */
-	COMPOSITE_NOGATE(0, "aclk_cpu_pre", mux_aclk_cpu_p, CLK_SET_RATE_NO_REPARENT,
-			RK2928_CLKSEL_CON(0), 5, 1, MFLAGS, 0, 5, DFLAGS),
-	DIV(0, "pclk_cpu_pre", "aclk_cpu_pre", 0,
-			RK2928_CLKSEL_CON(1), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	DIV(0, "hclk_cpu_pre", "aclk_cpu_pre", 0,
-			RK2928_CLKSEL_CON(1), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	COMPOSITE_NOMUX(0, "hclk_ahb2apb", "hclk_cpu_pre", 0,
-			RK2928_CLKSEL_CON(1), 14, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(4), 9, GFLAGS),
-
-	GATE(CORE_L2C, "core_l2c", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(9), 4, GFLAGS),
-
-	COMPOSITE(0, "aclk_peri_pre", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(10), 15, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-
-	COMPOSITE(DCLK_LCDC0, "dclk_lcdc0", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(27), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	COMPOSITE(DCLK_LCDC1, "dclk_lcdc1", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(28), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK2928_CLKGATE_CON(3), 2, GFLAGS),
-
-	COMPOSITE(0, "aclk_gpu_src", mux_pll_src_cpll_gpll_p, 0,
-			RK2928_CLKSEL_CON(34), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 15, GFLAGS),
-	GATE(ACLK_GPU, "aclk_gpu", "aclk_gpu_src", 0,
-			RK2928_CLKGATE_CON(9), 7, GFLAGS),
-
-	GATE(SCLK_TIMER2, "timer2", "xin24m", 0, RK2928_CLKGATE_CON(3), 4, GFLAGS),
-	GATE(SCLK_TIMER3, "timer3", "xin24m", 0, RK2928_CLKGATE_CON(1), 2, GFLAGS),
-	GATE(SCLK_TIMER4, "timer4", "xin24m", 0, RK2928_CLKGATE_CON(3), 5, GFLAGS),
-	GATE(SCLK_TIMER5, "timer5", "xin24m", 0, RK2928_CLKGATE_CON(3), 8, GFLAGS),
-	GATE(SCLK_TIMER6, "timer6", "xin24m", 0, RK2928_CLKGATE_CON(3), 14, GFLAGS),
-
-	COMPOSITE_NODIV(0, "sclk_hsicphy_480m", mux_hsicphy_p, 0,
-			RK2928_CLKSEL_CON(30), 0, 2, DFLAGS,
-			RK2928_CLKGATE_CON(3), 6, GFLAGS),
-	DIV(0, "sclk_hsicphy_12m", "sclk_hsicphy_480m", 0,
-			RK2928_CLKSEL_CON(11), 8, 6, DFLAGS),
-
-	MUX(0, "i2s_src", mux_pll_src_gpll_cpll_p, 0,
-			RK2928_CLKSEL_CON(2), 15, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "i2s0_pre", "i2s_src", 0,
-			RK2928_CLKSEL_CON(3), 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 9, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s0_frac", "i2s0_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(7), 0,
-			RK2928_CLKGATE_CON(0), 10, GFLAGS,
-			&rk3188_i2s0_fracmux),
-
-	GATE(0, "hclk_imem0", "hclk_cpu", 0, RK2928_CLKGATE_CON(4), 14, GFLAGS),
-	GATE(0, "hclk_imem1", "hclk_cpu", 0, RK2928_CLKGATE_CON(4), 15, GFLAGS),
-
-	GATE(HCLK_OTG1, "hclk_usbotg1", "hclk_peri", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(7), 3, GFLAGS),
-	GATE(HCLK_HSIC, "hclk_hsic", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 4, GFLAGS),
-
-	GATE(PCLK_TIMER3, "pclk_timer3", "pclk_cpu", 0, RK2928_CLKGATE_CON(7), 9, GFLAGS),
-
-	GATE(PCLK_UART0, "pclk_uart0", "hclk_ahb2apb", 0, RK2928_CLKGATE_CON(8), 0, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "hclk_ahb2apb", 0, RK2928_CLKGATE_CON(8), 1, GFLAGS),
-
-	GATE(ACLK_GPS, "aclk_gps", "aclk_peri", 0, RK2928_CLKGATE_CON(8), 13, GFLAGS),
-};
-
-static const char *const rk3188_critical_clocks[] __initconst = {
-	"aclk_cpu",
-	"aclk_peri",
-	"hclk_peri",
-	"pclk_cpu",
-	"pclk_peri",
-	"hclk_cpubus"
-};
-
-static struct rockchip_clk_provider *__init rk3188_common_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	rockchip_clk_register_branches(ctx, common_clk_branches,
-				  ARRAY_SIZE(common_clk_branches));
-
-	rockchip_register_softrst(np, 9, reg_base + RK2928_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK2928_GLB_SRST_FST, NULL);
-
-	return ctx;
-}
-
-static void __init rk3066a_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-
-	ctx = rk3188_common_clk_init(np);
-	if (IS_ERR(ctx))
-		return;
-
-	rockchip_clk_register_plls(ctx, rk3066_pll_clks,
-				   ARRAY_SIZE(rk3066_pll_clks),
-				   RK3066_GRF_SOC_STATUS);
-	rockchip_clk_register_branches(ctx, rk3066a_clk_branches,
-				  ARRAY_SIZE(rk3066a_clk_branches));
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-			mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-			&rk3066_cpuclk_data, rk3066_cpuclk_rates,
-			ARRAY_SIZE(rk3066_cpuclk_rates));
-	rockchip_clk_protect_critical(rk3188_critical_clocks,
-				      ARRAY_SIZE(rk3188_critical_clocks));
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3066a_cru, "rockchip,rk3066a-cru", rk3066a_clk_init);
-
-static void __init rk3188a_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	struct clk *clk1, *clk2;
-	unsigned long rate;
-	int ret;
-
-	ctx = rk3188_common_clk_init(np);
-	if (IS_ERR(ctx))
-		return;
-
-	rockchip_clk_register_plls(ctx, rk3188_pll_clks,
-				   ARRAY_SIZE(rk3188_pll_clks),
-				   RK3188_GRF_SOC_STATUS);
-	rockchip_clk_register_branches(ctx, rk3188_clk_branches,
-				  ARRAY_SIZE(rk3188_clk_branches));
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-				  mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-				  &rk3188_cpuclk_data, rk3188_cpuclk_rates,
-				  ARRAY_SIZE(rk3188_cpuclk_rates));
-
-	/* reparent aclk_cpu_pre from apll */
-	clk1 = __clk_lookup("aclk_cpu_pre");
-	clk2 = __clk_lookup("gpll");
-	if (clk1 && clk2) {
-		rate = clk_get_rate(clk1);
-
-		ret = clk_set_parent(clk1, clk2);
-		if (ret < 0)
-			pr_warn("%s: could not reparent aclk_cpu_pre to gpll\n",
-				__func__);
-
-		clk_set_rate(clk1, rate);
-	} else {
-		pr_warn("%s: missing clocks to reparent aclk_cpu_pre to gpll\n",
-			__func__);
-	}
-
-	rockchip_clk_protect_critical(rk3188_critical_clocks,
-				      ARRAY_SIZE(rk3188_critical_clocks));
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3188a_cru, "rockchip,rk3188a-cru", rk3188a_clk_init);
-
-static void __init rk3188_clk_init(struct device_node *np)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(rk3188_pll_clks); i++) {
-		struct rockchip_pll_clock *pll = &rk3188_pll_clks[i];
-		struct rockchip_pll_rate_table *rate;
-
-		if (!pll->rate_table)
-			continue;
-
-		rate = pll->rate_table;
-		while (rate->rate > 0) {
-			rate->nb = 1;
-			rate++;
-		}
-	}
-
-	rk3188a_clk_init(np);
-}
-CLK_OF_DECLARE(rk3188_cru, "rockchip,rk3188-cru", rk3188_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3228.c b/drivers/clk/rockchip/clk-rk3228.c
deleted file mode 100644
index 8d11d76e1..000000000
--- a/drivers/clk/rockchip/clk-rk3228.c
+++ /dev/null
@@ -1,727 +0,0 @@
-/*
- * Copyright (c) 2015 Rockchip Electronics Co. Ltd.
- * Author: Xing Zheng <zhengxing@rock-chips.com>
- *         Jeffy Chen <jeffy.chen@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/syscore_ops.h>
-#include <dt-bindings/clock/rk3228-cru.h>
-#include "clk.h"
-
-#define RK3228_GRF_SOC_STATUS0	0x480
-
-enum rk3228_plls {
-	apll, dpll, cpll, gpll,
-};
-
-static struct rockchip_pll_rate_table rk3228_pll_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1584000000, 1, 66, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1560000000, 1, 65, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1536000000, 1, 64, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1488000000, 1, 62, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1464000000, 1, 61, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1440000000, 1, 60, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1392000000, 1, 58, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1368000000, 1, 57, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1344000000, 1, 56, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1320000000, 1, 55, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1272000000, 1, 53, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1248000000, 1, 52, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1188000000, 2, 99, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1104000000, 1, 46, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1100000000, 12, 550, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
-	RK3036_PLL_RATE(1000000000, 6, 500, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 984000000, 1, 82, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 960000000, 1, 80, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 936000000, 1, 78, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 912000000, 1, 76, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 900000000, 4, 300, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 888000000, 1, 74, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 864000000, 1, 72, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 840000000, 1, 70, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 816000000, 1, 68, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 800000000, 6, 400, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 700000000, 6, 350, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 696000000, 1, 58, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 600000000, 1, 75, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 594000000, 2, 99, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 504000000, 1, 63, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 500000000, 6, 250, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 408000000, 1, 68, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 312000000, 1, 52, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 216000000, 1, 72, 4, 2, 1, 0),
-	RK3036_PLL_RATE(  96000000, 1, 64, 4, 4, 1, 0),
-	{ /* sentinel */ },
-};
-
-#define RK3228_DIV_CPU_MASK		0x1f
-#define RK3228_DIV_CPU_SHIFT		8
-
-#define RK3228_DIV_PERI_MASK		0xf
-#define RK3228_DIV_PERI_SHIFT		0
-#define RK3228_DIV_ACLK_MASK		0x7
-#define RK3228_DIV_ACLK_SHIFT		4
-#define RK3228_DIV_HCLK_MASK		0x3
-#define RK3228_DIV_HCLK_SHIFT		8
-#define RK3228_DIV_PCLK_MASK		0x7
-#define RK3228_DIV_PCLK_SHIFT		12
-
-#define RK3228_CLKSEL1(_core_aclk_div, _core_peri_div)				\
-	{									\
-		.reg = RK2928_CLKSEL_CON(1),					\
-		.val = HIWORD_UPDATE(_core_peri_div, RK3228_DIV_PERI_MASK,	\
-				     RK3228_DIV_PERI_SHIFT) |			\
-		       HIWORD_UPDATE(_core_aclk_div, RK3228_DIV_ACLK_MASK,	\
-				     RK3228_DIV_ACLK_SHIFT),			\
-}
-
-#define RK3228_CPUCLK_RATE(_prate, _core_aclk_div, _core_peri_div)		\
-	{									\
-		.prate = _prate,						\
-		.divs = {							\
-			RK3228_CLKSEL1(_core_aclk_div, _core_peri_div),		\
-		},								\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3228_cpuclk_rates[] __initdata = {
-	RK3228_CPUCLK_RATE(1800000000, 1, 7),
-	RK3228_CPUCLK_RATE(1704000000, 1, 7),
-	RK3228_CPUCLK_RATE(1608000000, 1, 7),
-	RK3228_CPUCLK_RATE(1512000000, 1, 7),
-	RK3228_CPUCLK_RATE(1488000000, 1, 5),
-	RK3228_CPUCLK_RATE(1416000000, 1, 5),
-	RK3228_CPUCLK_RATE(1392000000, 1, 5),
-	RK3228_CPUCLK_RATE(1296000000, 1, 5),
-	RK3228_CPUCLK_RATE(1200000000, 1, 5),
-	RK3228_CPUCLK_RATE(1104000000, 1, 5),
-	RK3228_CPUCLK_RATE(1008000000, 1, 5),
-	RK3228_CPUCLK_RATE(912000000, 1, 5),
-	RK3228_CPUCLK_RATE(816000000, 1, 3),
-	RK3228_CPUCLK_RATE(696000000, 1, 3),
-	RK3228_CPUCLK_RATE(600000000, 1, 3),
-	RK3228_CPUCLK_RATE(408000000, 1, 1),
-	RK3228_CPUCLK_RATE(312000000, 1, 1),
-	RK3228_CPUCLK_RATE(216000000,  1, 1),
-	RK3228_CPUCLK_RATE(96000000, 1, 1),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3228_cpuclk_data = {
-	.core_reg = RK2928_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 6,
-	.mux_core_mask = 0x1,
-};
-
-PNAME(mux_pll_p)		= { "clk_24m", "xin24m" };
-
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr", "apll_ddr" };
-PNAME(mux_armclk_p)		= { "apll_core", "gpll_core", "dpll_core" };
-PNAME(mux_usb480m_phy_p)	= { "usb480m_phy0", "usb480m_phy1" };
-PNAME(mux_usb480m_p)		= { "usb480m_phy", "xin24m" };
-PNAME(mux_hdmiphy_p)		= { "hdmiphy_phy", "xin24m" };
-PNAME(mux_aclk_cpu_src_p)	= { "cpll_aclk_cpu", "gpll_aclk_cpu", "hdmiphy_aclk_cpu" };
-
-PNAME(mux_pll_src_4plls_p)	= { "cpll", "gpll", "hdmiphy", "usb480m" };
-PNAME(mux_pll_src_3plls_p)	= { "cpll", "gpll", "hdmiphy" };
-PNAME(mux_pll_src_2plls_p)	= { "cpll", "gpll" };
-PNAME(mux_sclk_hdmi_cec_p)	= { "cpll", "gpll", "xin24m" };
-PNAME(mux_aclk_peri_src_p)	= { "cpll_peri", "gpll_peri", "hdmiphy_peri" };
-PNAME(mux_mmc_src_p)		= { "cpll", "gpll", "xin24m", "usb480m" };
-PNAME(mux_pll_src_cpll_gpll_usb480m_p)	= { "cpll", "gpll", "usb480m" };
-
-PNAME(mux_sclk_rga_p)		= { "gpll", "cpll", "sclk_rga_src" };
-
-PNAME(mux_sclk_vop_src_p)	= { "gpll_vop", "cpll_vop" };
-PNAME(mux_dclk_vop_p)		= { "hdmiphy", "sclk_vop_pre" };
-
-PNAME(mux_i2s0_p)		= { "i2s0_src", "i2s0_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s1_pre_p)		= { "i2s1_src", "i2s1_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s_out_p)		= { "i2s1_pre", "xin12m" };
-PNAME(mux_i2s2_p)		= { "i2s2_src", "i2s2_frac", "xin12m" };
-PNAME(mux_sclk_spdif_p)		= { "sclk_spdif_src", "spdif_frac", "xin12m" };
-
-PNAME(mux_uart0_p)		= { "uart0_src", "uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)		= { "uart1_src", "uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)		= { "uart2_src", "uart2_frac", "xin24m" };
-
-PNAME(mux_sclk_mac_extclk_p)	= { "ext_gmac", "phy_50m_out" };
-PNAME(mux_sclk_gmac_pre_p)	= { "sclk_gmac_src", "sclk_mac_extclk" };
-PNAME(mux_sclk_macphy_p)	= { "sclk_gmac_src", "ext_gmac" };
-
-static struct rockchip_pll_clock rk3228_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3036, PLL_APLL, "apll", mux_pll_p, 0, RK2928_PLL_CON(0),
-		     RK2928_MODE_CON, 0, 7, 0, rk3228_pll_rates),
-	[dpll] = PLL(pll_rk3036, PLL_DPLL, "dpll", mux_pll_p, 0, RK2928_PLL_CON(3),
-		     RK2928_MODE_CON, 4, 6, 0, NULL),
-	[cpll] = PLL(pll_rk3036, PLL_CPLL, "cpll", mux_pll_p, 0, RK2928_PLL_CON(6),
-		     RK2928_MODE_CON, 8, 8, 0, NULL),
-	[gpll] = PLL(pll_rk3036, PLL_GPLL, "gpll", mux_pll_p, 0, RK2928_PLL_CON(9),
-		     RK2928_MODE_CON, 12, 9, ROCKCHIP_PLL_SYNC_RATE, rk3228_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-
-static struct rockchip_clk_branch rk3228_i2s0_fracmux __initdata =
-	MUX(0, "i2s0_pre", mux_i2s0_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(9), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_i2s1_fracmux __initdata =
-	MUX(0, "i2s1_pre", mux_i2s1_pre_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(3), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_i2s2_fracmux __initdata =
-	MUX(0, "i2s2_pre", mux_i2s2_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(16), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_spdif_fracmux __initdata =
-	MUX(SCLK_SPDIF, "sclk_spdif", mux_sclk_spdif_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(6), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(13), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(15), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 1
-	 */
-
-	DIV(0, "clk_24m", "xin24m", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(4), 8, 5, DFLAGS),
-
-	/* PD_DDR */
-	GATE(0, "apll_ddr", "apll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "gpll_ddr", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	COMPOSITE(0, "ddrphy4x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(26), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK2928_CLKGATE_CON(7), 1, GFLAGS),
-	GATE(0, "ddrc", "ddrphy_pre", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(8), 5, GFLAGS),
-	FACTOR_GATE(0, "ddrphy", "ddrphy4x", CLK_IGNORE_UNUSED, 1, 4,
-			RK2928_CLKGATE_CON(7), 0, GFLAGS),
-
-	/* PD_CORE */
-	GATE(0, "dpll_core", "dpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-	GATE(0, "apll_core", "apll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-	GATE(0, "gpll_core", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_dbg", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 0, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(4), 1, GFLAGS),
-	COMPOSITE_NOMUX(0, "armcore", "armclk", CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(1), 4, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK2928_CLKGATE_CON(4), 0, GFLAGS),
-
-	/* PD_MISC */
-	MUX(0, "hdmiphy", mux_hdmiphy_p, CLK_SET_RATE_PARENT,
-			RK2928_MISC_CON, 13, 1, MFLAGS),
-	MUX(0, "usb480m_phy", mux_usb480m_phy_p, CLK_SET_RATE_PARENT,
-			RK2928_MISC_CON, 14, 1, MFLAGS),
-	MUX(0, "usb480m", mux_usb480m_p, CLK_SET_RATE_PARENT,
-			RK2928_MISC_CON, 15, 1, MFLAGS),
-
-	/* PD_BUS */
-	GATE(0, "hdmiphy_aclk_cpu", "hdmiphy", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "gpll_aclk_cpu", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "cpll_aclk_cpu", "cpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_cpu_src", mux_aclk_cpu_src_p, 0,
-			RK2928_CLKSEL_CON(0), 13, 2, MFLAGS, 8, 5, DFLAGS),
-	GATE(ACLK_CPU, "aclk_cpu", "aclk_cpu_src", 0,
-			RK2928_CLKGATE_CON(6), 0, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_CPU, "hclk_cpu", "aclk_cpu_src", 0,
-			RK2928_CLKSEL_CON(1), 8, 2, DFLAGS,
-			RK2928_CLKGATE_CON(6), 1, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_bus_src", "aclk_cpu_src", 0,
-			RK2928_CLKSEL_CON(1), 12, 3, DFLAGS,
-			RK2928_CLKGATE_CON(6), 2, GFLAGS),
-	GATE(PCLK_CPU, "pclk_cpu", "pclk_bus_src", 0,
-			RK2928_CLKGATE_CON(6), 3, GFLAGS),
-	GATE(0, "pclk_phy_pre", "pclk_bus_src", 0,
-			RK2928_CLKGATE_CON(6), 4, GFLAGS),
-	GATE(0, "pclk_ddr_pre", "pclk_bus_src", 0,
-			RK2928_CLKGATE_CON(6), 13, GFLAGS),
-
-	/* PD_VIDEO */
-	COMPOSITE(ACLK_VPU_PRE, "aclk_vpu_pre", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(32), 5, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 11, GFLAGS),
-	FACTOR_GATE(HCLK_VPU_PRE, "hclk_vpu_pre", "aclk_vpu_pre", 0, 1, 4,
-			RK2928_CLKGATE_CON(4), 4, GFLAGS),
-
-	COMPOSITE(ACLK_RKVDEC_PRE, "aclk_rkvdec_pre", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(28), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 2, GFLAGS),
-	FACTOR_GATE(HCLK_RKVDEC_PRE, "hclk_rkvdec_pre", "aclk_rkvdec_pre", 0, 1, 4,
-			RK2928_CLKGATE_CON(4), 5, GFLAGS),
-
-	COMPOSITE(SCLK_VDEC_CABAC, "sclk_vdec_cabac", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(28), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 3, GFLAGS),
-
-	COMPOSITE(SCLK_VDEC_CORE, "sclk_vdec_core", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(34), 13, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 4, GFLAGS),
-
-	/* PD_VIO */
-	COMPOSITE(ACLK_IEP_PRE, "aclk_iep_pre", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(31), 5, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 0, GFLAGS),
-	DIV(HCLK_VIO_PRE, "hclk_vio_pre", "aclk_iep_pre", 0,
-			RK2928_CLKSEL_CON(2), 0, 5, DFLAGS),
-
-	COMPOSITE(ACLK_HDCP_PRE, "aclk_hdcp_pre", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(31), 13, 2, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 4, GFLAGS),
-
-	MUX(0, "sclk_rga_src", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(33), 13, 2, MFLAGS),
-	COMPOSITE_NOMUX(ACLK_RGA_PRE, "aclk_rga_pre", "sclk_rga_src", 0,
-			RK2928_CLKSEL_CON(33), 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 2, GFLAGS),
-	COMPOSITE(SCLK_RGA, "sclk_rga", mux_sclk_rga_p, 0,
-			RK2928_CLKSEL_CON(22), 5, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 6, GFLAGS),
-
-	COMPOSITE(ACLK_VOP_PRE, "aclk_vop_pre", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(33), 5, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 1, GFLAGS),
-
-	COMPOSITE(SCLK_HDCP, "sclk_hdcp", mux_pll_src_3plls_p, 0,
-			RK2928_CLKSEL_CON(23), 14, 2, MFLAGS, 8, 6, DFLAGS,
-			RK2928_CLKGATE_CON(3), 5, GFLAGS),
-
-	GATE(SCLK_HDMI_HDCP, "sclk_hdmi_hdcp", "xin24m", 0,
-			RK2928_CLKGATE_CON(3), 7, GFLAGS),
-
-	COMPOSITE(SCLK_HDMI_CEC, "sclk_hdmi_cec", mux_sclk_hdmi_cec_p, 0,
-			RK2928_CLKSEL_CON(21), 14, 2, MFLAGS, 0, 14, DFLAGS,
-			RK2928_CLKGATE_CON(3), 8, GFLAGS),
-
-	/* PD_PERI */
-	GATE(0, "cpll_peri", "cpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "gpll_peri", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "hdmiphy_peri", "hdmiphy", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_peri_src", mux_aclk_peri_src_p, 0,
-			RK2928_CLKSEL_CON(10), 10, 2, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKSEL_CON(10), 12, 3, DFLAGS,
-			RK2928_CLKGATE_CON(5), 2, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERI, "hclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKSEL_CON(10), 8, 2, DFLAGS,
-			RK2928_CLKGATE_CON(5), 1, GFLAGS),
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_src", 0,
-			RK2928_CLKGATE_CON(5), 0, GFLAGS),
-
-	GATE(SCLK_TIMER0, "sclk_timer0", "xin24m", 0,
-			RK2928_CLKGATE_CON(6), 5, GFLAGS),
-	GATE(SCLK_TIMER1, "sclk_timer1", "xin24m", 0,
-			RK2928_CLKGATE_CON(6), 6, GFLAGS),
-	GATE(SCLK_TIMER2, "sclk_timer2", "xin24m", 0,
-			RK2928_CLKGATE_CON(6), 7, GFLAGS),
-	GATE(SCLK_TIMER3, "sclk_timer3", "xin24m", 0,
-			RK2928_CLKGATE_CON(6), 8, GFLAGS),
-	GATE(SCLK_TIMER4, "sclk_timer4", "xin24m", 0,
-			RK2928_CLKGATE_CON(6), 9, GFLAGS),
-	GATE(SCLK_TIMER5, "sclk_timer5", "xin24m", 0,
-			RK2928_CLKGATE_CON(6), 10, GFLAGS),
-
-	COMPOSITE(SCLK_CRYPTO, "sclk_crypto", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(24), 5, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 7, GFLAGS),
-
-	COMPOSITE(SCLK_TSP, "sclk_tsp", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(22), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 6, GFLAGS),
-
-	GATE(SCLK_HSADC, "sclk_hsadc", "ext_hsadc", 0,
-			RK2928_CLKGATE_CON(10), 12, GFLAGS),
-
-	COMPOSITE(SCLK_WIFI, "sclk_wifi", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK2928_CLKSEL_CON(23), 5, 2, MFLAGS, 0, 6, DFLAGS,
-			RK2928_CLKGATE_CON(2), 15, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC, "sclk_sdmmc", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(11), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK2928_CLKGATE_CON(2), 11, GFLAGS),
-
-	COMPOSITE_NODIV(SCLK_SDIO_SRC, "sclk_sdio_src", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(11), 10, 2, MFLAGS,
-			RK2928_CLKGATE_CON(2), 13, GFLAGS),
-	DIV(SCLK_SDIO, "sclk_sdio", "sclk_sdio_src", 0,
-			RK2928_CLKSEL_CON(12), 0, 8, DFLAGS),
-
-	COMPOSITE_NODIV(0, "sclk_emmc_src", mux_mmc_src_p, 0,
-			RK2928_CLKSEL_CON(11), 12, 2, MFLAGS,
-			RK2928_CLKGATE_CON(2), 14, GFLAGS),
-	DIV(SCLK_EMMC, "sclk_emmc", "sclk_emmc_src", 0,
-			RK2928_CLKSEL_CON(12), 8, 8, DFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	GATE(0, "gpll_vop", "gpll", 0,
-			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	GATE(0, "cpll_vop", "cpll", 0,
-			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	MUX(0, "sclk_vop_src", mux_sclk_vop_src_p, 0,
-			RK2928_CLKSEL_CON(27), 0, 1, MFLAGS),
-	DIV(DCLK_HDMI_PHY, "dclk_hdmiphy", "sclk_vop_src", 0,
-			RK2928_CLKSEL_CON(29), 0, 3, DFLAGS),
-	DIV(0, "sclk_vop_pre", "sclk_vop_src", 0,
-			RK2928_CLKSEL_CON(27), 8, 8, DFLAGS),
-	MUX(DCLK_VOP, "dclk_vop", mux_dclk_vop_p, 0,
-			RK2928_CLKSEL_CON(27), 1, 1, MFLAGS),
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	COMPOSITE(0, "i2s0_src", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(9), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 3, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s0_frac", "i2s0_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(8), 0,
-			RK2928_CLKGATE_CON(0), 4, GFLAGS,
-			&rk3228_i2s0_fracmux),
-	GATE(SCLK_I2S0, "sclk_i2s0", "i2s0_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKGATE_CON(0), 5, GFLAGS),
-
-	COMPOSITE(0, "i2s1_src", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(3), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 10, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s1_frac", "i2s1_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(7), 0,
-			RK2928_CLKGATE_CON(0), 11, GFLAGS,
-			&rk3228_i2s1_fracmux),
-	GATE(SCLK_I2S1, "sclk_i2s1", "i2s1_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKGATE_CON(0), 14, GFLAGS),
-	COMPOSITE_NODIV(SCLK_I2S_OUT, "i2s_out", mux_i2s_out_p, 0,
-			RK2928_CLKSEL_CON(3), 12, 1, MFLAGS,
-			RK2928_CLKGATE_CON(0), 13, GFLAGS),
-
-	COMPOSITE(0, "i2s2_src", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(16), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(0), 7, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s2_frac", "i2s2_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(30), 0,
-			RK2928_CLKGATE_CON(0), 8, GFLAGS,
-			&rk3228_i2s2_fracmux),
-	GATE(SCLK_I2S2, "sclk_i2s2", "i2s2_pre", CLK_SET_RATE_PARENT,
-			RK2928_CLKGATE_CON(0), 9, GFLAGS),
-
-	COMPOSITE(0, "sclk_spdif_src", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(6), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 10, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_frac", "sclk_spdif_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(20), 0,
-			RK2928_CLKGATE_CON(2), 12, GFLAGS,
-			&rk3228_spdif_fracmux),
-
-	GATE(0, "jtag", "ext_jtag", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(1), 3, GFLAGS),
-
-	GATE(SCLK_OTGPHY0, "sclk_otgphy0", "xin24m", 0,
-			RK2928_CLKGATE_CON(1), 5, GFLAGS),
-	GATE(SCLK_OTGPHY1, "sclk_otgphy1", "xin24m", 0,
-			RK2928_CLKGATE_CON(1), 6, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_TSADC, "sclk_tsadc", "xin24m", 0,
-			RK2928_CLKSEL_CON(24), 6, 10, DFLAGS,
-			RK2928_CLKGATE_CON(2), 8, GFLAGS),
-
-	COMPOSITE(0, "aclk_gpu_pre", mux_pll_src_4plls_p, 0,
-			RK2928_CLKSEL_CON(34), 5, 2, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(3), 13, GFLAGS),
-
-	COMPOSITE(SCLK_SPI0, "sclk_spi0", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(25), 8, 1, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(2), 9, GFLAGS),
-
-	/* PD_UART */
-	COMPOSITE(0, "uart0_src", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK2928_CLKSEL_CON(13), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 8, GFLAGS),
-	COMPOSITE(0, "uart1_src", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK2928_CLKSEL_CON(14), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK2928_CLKGATE_CON(1), 10, GFLAGS),
-	COMPOSITE(0, "uart2_src", mux_pll_src_cpll_gpll_usb480m_p,
-			0, RK2928_CLKSEL_CON(15), 12, 2,
-			MFLAGS, 0, 7, DFLAGS, RK2928_CLKGATE_CON(1), 12, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(17), 0,
-			RK2928_CLKGATE_CON(1), 9, GFLAGS,
-			&rk3228_uart0_fracmux),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(18), 0,
-			RK2928_CLKGATE_CON(1), 11, GFLAGS,
-			&rk3228_uart1_fracmux),
-	COMPOSITE_FRACMUX(0, "uart2_frac", "uart2_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(19), 0,
-			RK2928_CLKGATE_CON(1), 13, GFLAGS,
-			&rk3228_uart2_fracmux),
-
-	COMPOSITE(SCLK_NANDC, "sclk_nandc", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(2), 14, 1, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 0, GFLAGS),
-
-	COMPOSITE(SCLK_MAC_SRC, "sclk_gmac_src", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(5), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK2928_CLKGATE_CON(1), 7, GFLAGS),
-	MUX(SCLK_MAC_EXTCLK, "sclk_mac_extclk", mux_sclk_mac_extclk_p, 0,
-			RK2928_CLKSEL_CON(29), 10, 1, MFLAGS),
-	MUX(SCLK_MAC, "sclk_gmac_pre", mux_sclk_gmac_pre_p, 0,
-			RK2928_CLKSEL_CON(5), 5, 1, MFLAGS),
-	GATE(SCLK_MAC_REFOUT, "sclk_mac_refout", "sclk_gmac_pre", 0,
-			RK2928_CLKGATE_CON(5), 4, GFLAGS),
-	GATE(SCLK_MAC_REF, "sclk_mac_ref", "sclk_gmac_pre", 0,
-			RK2928_CLKGATE_CON(5), 3, GFLAGS),
-	GATE(SCLK_MAC_RX, "sclk_mac_rx", "sclk_gmac_pre", 0,
-			RK2928_CLKGATE_CON(5), 5, GFLAGS),
-	GATE(SCLK_MAC_TX, "sclk_mac_tx", "sclk_gmac_pre", 0,
-			RK2928_CLKGATE_CON(5), 6, GFLAGS),
-	COMPOSITE(SCLK_MAC_PHY, "sclk_macphy", mux_sclk_macphy_p, 0,
-			RK2928_CLKSEL_CON(29), 12, 1, MFLAGS, 8, 2, DFLAGS,
-			RK2928_CLKGATE_CON(5), 7, GFLAGS),
-	COMPOSITE(SCLK_MAC_OUT, "sclk_gmac_out", mux_pll_src_2plls_p, 0,
-			RK2928_CLKSEL_CON(5), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK2928_CLKGATE_CON(2), 2, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-
-	/* PD_VOP */
-	GATE(ACLK_RGA, "aclk_rga", "aclk_rga_pre", 0, RK2928_CLKGATE_CON(13), 0, GFLAGS),
-	GATE(0, "aclk_rga_noc", "aclk_rga_pre", 0, RK2928_CLKGATE_CON(13), 11, GFLAGS),
-	GATE(ACLK_IEP, "aclk_iep", "aclk_iep_pre", 0, RK2928_CLKGATE_CON(13), 2, GFLAGS),
-	GATE(0, "aclk_iep_noc", "aclk_iep_pre", 0, RK2928_CLKGATE_CON(13), 9, GFLAGS),
-
-	GATE(ACLK_VOP, "aclk_vop", "aclk_vop_pre", 0, RK2928_CLKGATE_CON(13), 5, GFLAGS),
-	GATE(0, "aclk_vop_noc", "aclk_vop_pre", 0, RK2928_CLKGATE_CON(13), 12, GFLAGS),
-
-	GATE(ACLK_HDCP, "aclk_hdcp", "aclk_hdcp_pre", 0, RK2928_CLKGATE_CON(14), 10, GFLAGS),
-	GATE(0, "aclk_hdcp_noc", "aclk_hdcp_pre", 0, RK2928_CLKGATE_CON(13), 10, GFLAGS),
-
-	GATE(HCLK_RGA, "hclk_rga", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(13), 1, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(13), 3, GFLAGS),
-	GATE(HCLK_VOP, "hclk_vop", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(13), 6, GFLAGS),
-	GATE(0, "hclk_vio_ahb_arbi", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(13), 7, GFLAGS),
-	GATE(0, "hclk_vio_noc", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(13), 8, GFLAGS),
-	GATE(0, "hclk_vop_noc", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(13), 13, GFLAGS),
-	GATE(HCLK_VIO_H2P, "hclk_vio_h2p", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(14), 7, GFLAGS),
-	GATE(HCLK_HDCP_MMU, "hclk_hdcp_mmu", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(14), 12, GFLAGS),
-	GATE(PCLK_HDMI_CTRL, "pclk_hdmi_ctrl", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(14), 6, GFLAGS),
-	GATE(PCLK_VIO_H2P, "pclk_vio_h2p", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(14), 8, GFLAGS),
-	GATE(PCLK_HDCP, "pclk_hdcp", "hclk_vio_pre", 0, RK2928_CLKGATE_CON(14), 11, GFLAGS),
-
-	/* PD_PERI */
-	GATE(0, "aclk_peri_noc", "aclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(12), 0, GFLAGS),
-	GATE(ACLK_GMAC, "aclk_gmac", "aclk_peri", 0, RK2928_CLKGATE_CON(11), 4, GFLAGS),
-
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 0, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 1, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 2, GFLAGS),
-	GATE(HCLK_NANDC, "hclk_nandc", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 3, GFLAGS),
-	GATE(HCLK_HOST0, "hclk_host0", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 6, GFLAGS),
-	GATE(0, "hclk_host0_arb", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 7, GFLAGS),
-	GATE(HCLK_HOST1, "hclk_host1", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 8, GFLAGS),
-	GATE(0, "hclk_host1_arb", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 9, GFLAGS),
-	GATE(HCLK_HOST2, "hclk_host2", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 10, GFLAGS),
-	GATE(HCLK_OTG, "hclk_otg", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 12, GFLAGS),
-	GATE(0, "hclk_otg_pmu", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 13, GFLAGS),
-	GATE(0, "hclk_host2_arb", "hclk_peri", 0, RK2928_CLKGATE_CON(11), 14, GFLAGS),
-	GATE(0, "hclk_peri_noc", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(12), 1, GFLAGS),
-
-	GATE(PCLK_GMAC, "pclk_gmac", "pclk_peri", 0, RK2928_CLKGATE_CON(11), 5, GFLAGS),
-	GATE(0, "pclk_peri_noc", "pclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(12), 2, GFLAGS),
-
-	/* PD_GPU */
-	GATE(ACLK_GPU, "aclk_gpu", "aclk_gpu_pre", 0, RK2928_CLKGATE_CON(7), 14, GFLAGS),
-	GATE(0, "aclk_gpu_noc", "aclk_gpu_pre", 0, RK2928_CLKGATE_CON(7), 15, GFLAGS),
-
-	/* PD_BUS */
-	GATE(0, "sclk_initmem_mbist", "aclk_cpu", 0, RK2928_CLKGATE_CON(8), 1, GFLAGS),
-	GATE(0, "aclk_initmem", "aclk_cpu", 0, RK2928_CLKGATE_CON(8), 0, GFLAGS),
-	GATE(ACLK_DMAC, "aclk_dmac_bus", "aclk_cpu", 0, RK2928_CLKGATE_CON(8), 2, GFLAGS),
-	GATE(0, "aclk_bus_noc", "aclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(10), 1, GFLAGS),
-
-	GATE(0, "hclk_rom", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 3, GFLAGS),
-	GATE(HCLK_I2S0_8CH, "hclk_i2s0_8ch", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 7, GFLAGS),
-	GATE(HCLK_I2S1_8CH, "hclk_i2s1_8ch", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 8, GFLAGS),
-	GATE(HCLK_I2S2_2CH, "hclk_i2s2_2ch", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 9, GFLAGS),
-	GATE(HCLK_SPDIF_8CH, "hclk_spdif_8ch", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 10, GFLAGS),
-	GATE(HCLK_TSP, "hclk_tsp", "hclk_cpu", 0, RK2928_CLKGATE_CON(10), 11, GFLAGS),
-	GATE(HCLK_M_CRYPTO, "hclk_crypto_mst", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 11, GFLAGS),
-	GATE(HCLK_S_CRYPTO, "hclk_crypto_slv", "hclk_cpu", 0, RK2928_CLKGATE_CON(8), 12, GFLAGS),
-
-	GATE(0, "pclk_ddrupctl", "pclk_ddr_pre", 0, RK2928_CLKGATE_CON(8), 4, GFLAGS),
-	GATE(0, "pclk_ddrmon", "pclk_ddr_pre", 0, RK2928_CLKGATE_CON(8), 6, GFLAGS),
-	GATE(0, "pclk_msch_noc", "pclk_ddr_pre", 0, RK2928_CLKGATE_CON(10), 2, GFLAGS),
-
-	GATE(PCLK_EFUSE_1024, "pclk_efuse_1024", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 13, GFLAGS),
-	GATE(PCLK_EFUSE_256, "pclk_efuse_256", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 14, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_cpu", 0, RK2928_CLKGATE_CON(8), 15, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 0, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 1, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 2, GFLAGS),
-	GATE(PCLK_TIMER, "pclk_timer0", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 4, GFLAGS),
-	GATE(0, "pclk_stimer", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 5, GFLAGS),
-	GATE(PCLK_SPI0, "pclk_spi0", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 6, GFLAGS),
-	GATE(PCLK_PWM, "pclk_rk_pwm", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 7, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 8, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 9, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 10, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 11, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 12, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 13, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 14, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_cpu", 0, RK2928_CLKGATE_CON(9), 15, GFLAGS),
-	GATE(PCLK_GRF, "pclk_grf", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(10), 0, GFLAGS),
-	GATE(0, "pclk_cru", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(10), 1, GFLAGS),
-	GATE(0, "pclk_sgrf", "pclk_cpu", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(10), 2, GFLAGS),
-	GATE(0, "pclk_sim", "pclk_cpu", 0, RK2928_CLKGATE_CON(10), 3, GFLAGS),
-
-	GATE(0, "pclk_ddrphy", "pclk_phy_pre", 0, RK2928_CLKGATE_CON(10), 3, GFLAGS),
-	GATE(0, "pclk_acodecphy", "pclk_phy_pre", 0, RK2928_CLKGATE_CON(10), 5, GFLAGS),
-	GATE(PCLK_HDMI_PHY, "pclk_hdmiphy", "pclk_phy_pre", 0, RK2928_CLKGATE_CON(10), 7, GFLAGS),
-	GATE(0, "pclk_vdacphy", "pclk_phy_pre", 0, RK2928_CLKGATE_CON(10), 8, GFLAGS),
-	GATE(0, "pclk_phy_noc", "pclk_phy_pre", 0, RK2928_CLKGATE_CON(10), 9, GFLAGS),
-
-	GATE(ACLK_VPU, "aclk_vpu", "aclk_vpu_pre", 0, RK2928_CLKGATE_CON(15), 0, GFLAGS),
-	GATE(0, "aclk_vpu_noc", "aclk_vpu_pre", 0, RK2928_CLKGATE_CON(15), 4, GFLAGS),
-	GATE(ACLK_RKVDEC, "aclk_rkvdec", "aclk_rkvdec_pre", 0, RK2928_CLKGATE_CON(15), 2, GFLAGS),
-	GATE(0, "aclk_rkvdec_noc", "aclk_rkvdec_pre", 0, RK2928_CLKGATE_CON(15), 6, GFLAGS),
-	GATE(HCLK_VPU, "hclk_vpu", "hclk_vpu_pre", 0, RK2928_CLKGATE_CON(15), 1, GFLAGS),
-	GATE(0, "hclk_vpu_noc", "hclk_vpu_pre", 0, RK2928_CLKGATE_CON(15), 5, GFLAGS),
-	GATE(HCLK_RKVDEC, "hclk_rkvdec", "hclk_rkvdec_pre", 0, RK2928_CLKGATE_CON(15), 3, GFLAGS),
-	GATE(0, "hclk_rkvdec_noc", "hclk_rkvdec_pre", 0, RK2928_CLKGATE_CON(15), 7, GFLAGS),
-
-	/* PD_MMC */
-	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RK3228_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3228_SDMMC_CON1, 0),
-
-	MMC(SCLK_SDIO_DRV,     "sdio_drv",     "sclk_sdio",  RK3228_SDIO_CON0,  1),
-	MMC(SCLK_SDIO_SAMPLE,  "sdio_sample",  "sclk_sdio",  RK3228_SDIO_CON1,  0),
-
-	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RK3228_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3228_EMMC_CON1,  0),
-};
-
-static const char *const rk3228_critical_clocks[] __initconst = {
-	"aclk_cpu",
-	"pclk_cpu",
-	"hclk_cpu",
-	"aclk_peri",
-	"hclk_peri",
-	"pclk_peri",
-	"aclk_rga_noc",
-	"aclk_iep_noc",
-	"aclk_vop_noc",
-	"aclk_hdcp_noc",
-	"hclk_vio_ahb_arbi",
-	"hclk_vio_noc",
-	"hclk_vop_noc",
-	"hclk_host0_arb",
-	"hclk_host1_arb",
-	"hclk_host2_arb",
-	"hclk_otg_pmu",
-	"aclk_gpu_noc",
-	"sclk_initmem_mbist",
-	"aclk_initmem",
-	"hclk_rom",
-	"pclk_ddrupctl",
-	"pclk_ddrmon",
-	"pclk_msch_noc",
-	"pclk_stimer",
-	"pclk_ddrphy",
-	"pclk_acodecphy",
-	"pclk_phy_noc",
-	"aclk_vpu_noc",
-	"aclk_rkvdec_noc",
-	"hclk_vpu_noc",
-	"hclk_rkvdec_noc",
-};
-
-static void __init rk3228_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	rockchip_clk_register_plls(ctx, rk3228_pll_clks,
-				   ARRAY_SIZE(rk3228_pll_clks),
-				   RK3228_GRF_SOC_STATUS0);
-	rockchip_clk_register_branches(ctx, rk3228_clk_branches,
-				  ARRAY_SIZE(rk3228_clk_branches));
-	rockchip_clk_protect_critical(rk3228_critical_clocks,
-				      ARRAY_SIZE(rk3228_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-			mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-			&rk3228_cpuclk_data, rk3228_cpuclk_rates,
-			ARRAY_SIZE(rk3228_cpuclk_rates));
-
-	rockchip_register_softrst(np, 9, reg_base + RK2928_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK3228_GLB_SRST_FST, NULL);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3228_cru, "rockchip,rk3228-cru", rk3228_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3288.c b/drivers/clk/rockchip/clk-rk3288.c
deleted file mode 100644
index 9cfdbea49..000000000
--- a/drivers/clk/rockchip/clk-rk3288.c
+++ /dev/null
@@ -1,951 +0,0 @@
-/*
- * Copyright (c) 2014 MundoReader S.L.
- * Author: Heiko Stuebner <heiko@sntech.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/syscore_ops.h>
-#include <dt-bindings/clock/rk3288-cru.h>
-#include "clk.h"
-
-#define RK3288_GRF_SOC_CON(x)	(0x244 + x * 4)
-#define RK3288_GRF_SOC_STATUS1	0x284
-
-enum rk3288_plls {
-	apll, dpll, cpll, gpll, npll,
-};
-
-static struct rockchip_pll_rate_table rk3288_pll_rates[] = {
-	RK3066_PLL_RATE(2208000000, 1, 92, 1),
-	RK3066_PLL_RATE(2184000000, 1, 91, 1),
-	RK3066_PLL_RATE(2160000000, 1, 90, 1),
-	RK3066_PLL_RATE(2136000000, 1, 89, 1),
-	RK3066_PLL_RATE(2112000000, 1, 88, 1),
-	RK3066_PLL_RATE(2088000000, 1, 87, 1),
-	RK3066_PLL_RATE(2064000000, 1, 86, 1),
-	RK3066_PLL_RATE(2040000000, 1, 85, 1),
-	RK3066_PLL_RATE(2016000000, 1, 84, 1),
-	RK3066_PLL_RATE(1992000000, 1, 83, 1),
-	RK3066_PLL_RATE(1968000000, 1, 82, 1),
-	RK3066_PLL_RATE(1944000000, 1, 81, 1),
-	RK3066_PLL_RATE(1920000000, 1, 80, 1),
-	RK3066_PLL_RATE(1896000000, 1, 79, 1),
-	RK3066_PLL_RATE(1872000000, 1, 78, 1),
-	RK3066_PLL_RATE(1848000000, 1, 77, 1),
-	RK3066_PLL_RATE(1824000000, 1, 76, 1),
-	RK3066_PLL_RATE(1800000000, 1, 75, 1),
-	RK3066_PLL_RATE(1776000000, 1, 74, 1),
-	RK3066_PLL_RATE(1752000000, 1, 73, 1),
-	RK3066_PLL_RATE(1728000000, 1, 72, 1),
-	RK3066_PLL_RATE(1704000000, 1, 71, 1),
-	RK3066_PLL_RATE(1680000000, 1, 70, 1),
-	RK3066_PLL_RATE(1656000000, 1, 69, 1),
-	RK3066_PLL_RATE(1632000000, 1, 68, 1),
-	RK3066_PLL_RATE(1608000000, 1, 67, 1),
-	RK3066_PLL_RATE(1560000000, 1, 65, 1),
-	RK3066_PLL_RATE(1512000000, 1, 63, 1),
-	RK3066_PLL_RATE(1488000000, 1, 62, 1),
-	RK3066_PLL_RATE(1464000000, 1, 61, 1),
-	RK3066_PLL_RATE(1440000000, 1, 60, 1),
-	RK3066_PLL_RATE(1416000000, 1, 59, 1),
-	RK3066_PLL_RATE(1392000000, 1, 58, 1),
-	RK3066_PLL_RATE(1368000000, 1, 57, 1),
-	RK3066_PLL_RATE(1344000000, 1, 56, 1),
-	RK3066_PLL_RATE(1320000000, 1, 55, 1),
-	RK3066_PLL_RATE(1296000000, 1, 54, 1),
-	RK3066_PLL_RATE(1272000000, 1, 53, 1),
-	RK3066_PLL_RATE(1248000000, 1, 52, 1),
-	RK3066_PLL_RATE(1224000000, 1, 51, 1),
-	RK3066_PLL_RATE(1200000000, 1, 50, 1),
-	RK3066_PLL_RATE(1188000000, 2, 99, 1),
-	RK3066_PLL_RATE(1176000000, 1, 49, 1),
-	RK3066_PLL_RATE(1128000000, 1, 47, 1),
-	RK3066_PLL_RATE(1104000000, 1, 46, 1),
-	RK3066_PLL_RATE(1008000000, 1, 84, 2),
-	RK3066_PLL_RATE( 912000000, 1, 76, 2),
-	RK3066_PLL_RATE( 891000000, 8, 594, 2),
-	RK3066_PLL_RATE( 888000000, 1, 74, 2),
-	RK3066_PLL_RATE( 816000000, 1, 68, 2),
-	RK3066_PLL_RATE( 798000000, 2, 133, 2),
-	RK3066_PLL_RATE( 792000000, 1, 66, 2),
-	RK3066_PLL_RATE( 768000000, 1, 64, 2),
-	RK3066_PLL_RATE( 742500000, 8, 495, 2),
-	RK3066_PLL_RATE( 696000000, 1, 58, 2),
-	RK3066_PLL_RATE( 600000000, 1, 50, 2),
-	RK3066_PLL_RATE_NB(594000000, 1, 198, 8, 1),
-	RK3066_PLL_RATE( 552000000, 1, 46, 2),
-	RK3066_PLL_RATE( 504000000, 1, 84, 4),
-	RK3066_PLL_RATE( 500000000, 3, 125, 2),
-	RK3066_PLL_RATE( 456000000, 1, 76, 4),
-	RK3066_PLL_RATE( 408000000, 1, 68, 4),
-	RK3066_PLL_RATE( 400000000, 3, 100, 2),
-	RK3066_PLL_RATE( 384000000, 2, 128, 4),
-	RK3066_PLL_RATE( 360000000, 1, 60, 4),
-	RK3066_PLL_RATE( 312000000, 1, 52, 4),
-	RK3066_PLL_RATE( 300000000, 1, 50, 4),
-	RK3066_PLL_RATE( 297000000, 2, 198, 8),
-	RK3066_PLL_RATE( 252000000, 1, 84, 8),
-	RK3066_PLL_RATE( 216000000, 1, 72, 8),
-	RK3066_PLL_RATE( 148500000, 2, 99, 8),
-	RK3066_PLL_RATE( 126000000, 1, 84, 16),
-	RK3066_PLL_RATE(  48000000, 1, 64, 32),
-	{ /* sentinel */ },
-};
-
-#define RK3288_DIV_ACLK_CORE_M0_MASK	0xf
-#define RK3288_DIV_ACLK_CORE_M0_SHIFT	0
-#define RK3288_DIV_ACLK_CORE_MP_MASK	0xf
-#define RK3288_DIV_ACLK_CORE_MP_SHIFT	4
-#define RK3288_DIV_L2RAM_MASK		0x7
-#define RK3288_DIV_L2RAM_SHIFT		0
-#define RK3288_DIV_ATCLK_MASK		0x1f
-#define RK3288_DIV_ATCLK_SHIFT		4
-#define RK3288_DIV_PCLK_DBGPRE_MASK	0x1f
-#define RK3288_DIV_PCLK_DBGPRE_SHIFT	9
-
-#define RK3288_CLKSEL0(_core_m0, _core_mp)				\
-	{								\
-		.reg = RK3288_CLKSEL_CON(0),				\
-		.val = HIWORD_UPDATE(_core_m0, RK3288_DIV_ACLK_CORE_M0_MASK, \
-				RK3288_DIV_ACLK_CORE_M0_SHIFT) |	\
-		       HIWORD_UPDATE(_core_mp, RK3288_DIV_ACLK_CORE_MP_MASK, \
-				RK3288_DIV_ACLK_CORE_MP_SHIFT),		\
-	}
-#define RK3288_CLKSEL37(_l2ram, _atclk, _pclk_dbg_pre)			\
-	{								\
-		.reg = RK3288_CLKSEL_CON(37),				\
-		.val = HIWORD_UPDATE(_l2ram, RK3288_DIV_L2RAM_MASK,	\
-				RK3288_DIV_L2RAM_SHIFT) |		\
-		       HIWORD_UPDATE(_atclk, RK3288_DIV_ATCLK_MASK,	\
-				RK3288_DIV_ATCLK_SHIFT) |		\
-		       HIWORD_UPDATE(_pclk_dbg_pre,			\
-				RK3288_DIV_PCLK_DBGPRE_MASK,		\
-				RK3288_DIV_PCLK_DBGPRE_SHIFT),		\
-	}
-
-#define RK3288_CPUCLK_RATE(_prate, _core_m0, _core_mp, _l2ram, _atclk, _pdbg) \
-	{								\
-		.prate = _prate,					\
-		.divs = {						\
-			RK3288_CLKSEL0(_core_m0, _core_mp),		\
-			RK3288_CLKSEL37(_l2ram, _atclk, _pdbg),		\
-		},							\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3288_cpuclk_rates[] __initdata = {
-	RK3288_CPUCLK_RATE(1800000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE(1704000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE(1608000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE(1512000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE(1416000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE(1200000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE(1008000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 816000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 696000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 600000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 408000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 312000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 216000000, 1, 3, 1, 3, 3),
-	RK3288_CPUCLK_RATE( 126000000, 1, 3, 1, 3, 3),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3288_cpuclk_data = {
-	.core_reg = RK3288_CLKSEL_CON(0),
-	.div_core_shift = 8,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 15,
-	.mux_core_mask = 0x1,
-};
-
-PNAME(mux_pll_p)		= { "xin24m", "xin32k" };
-PNAME(mux_armclk_p)		= { "apll_core", "gpll_core" };
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr" };
-PNAME(mux_aclk_cpu_src_p)	= { "cpll_aclk_cpu", "gpll_aclk_cpu" };
-
-PNAME(mux_pll_src_cpll_gpll_p)		= { "cpll", "gpll" };
-PNAME(mux_pll_src_npll_cpll_gpll_p)	= { "npll", "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_npll_p)	= { "cpll", "gpll", "npll" };
-PNAME(mux_pll_src_cpll_gpll_usb480m_p)	= { "cpll", "gpll", "usbphy480m_src" };
-PNAME(mux_pll_src_cpll_gll_usb_npll_p)	= { "cpll", "gpll", "usbphy480m_src", "npll" };
-
-PNAME(mux_mmc_src_p)	= { "cpll", "gpll", "xin24m", "xin24m" };
-PNAME(mux_i2s_pre_p)	= { "i2s_src", "i2s_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s_clkout_p)	= { "i2s_pre", "xin12m" };
-PNAME(mux_spdif_p)	= { "spdif_pre", "spdif_frac", "xin12m" };
-PNAME(mux_spdif_8ch_p)	= { "spdif_8ch_pre", "spdif_8ch_frac", "xin12m" };
-PNAME(mux_uart0_p)	= { "uart0_src", "uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)	= { "uart1_src", "uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)	= { "uart2_src", "uart2_frac", "xin24m" };
-PNAME(mux_uart3_p)	= { "uart3_src", "uart3_frac", "xin24m" };
-PNAME(mux_uart4_p)	= { "uart4_src", "uart4_frac", "xin24m" };
-PNAME(mux_vip_out_p)	= { "vip_src", "xin24m" };
-PNAME(mux_mac_p)	= { "mac_pll_src", "ext_gmac" };
-PNAME(mux_hsadcout_p)	= { "hsadc_src", "ext_hsadc" };
-PNAME(mux_edp_24m_p)	= { "ext_edp_24m", "xin24m" };
-PNAME(mux_tspout_p)	= { "cpll", "gpll", "npll", "xin27m" };
-
-PNAME(mux_aclk_vcodec_pre_p)	= { "aclk_vdpu", "aclk_vepu" };
-PNAME(mux_usbphy480m_p)		= { "sclk_otgphy1_480m", "sclk_otgphy2_480m",
-				    "sclk_otgphy0_480m" };
-PNAME(mux_hsicphy480m_p)	= { "cpll", "gpll", "usbphy480m_src" };
-PNAME(mux_hsicphy12m_p)		= { "hsicphy12m_xin12m", "hsicphy12m_usbphy" };
-
-static struct rockchip_pll_clock rk3288_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3066, PLL_APLL, "apll", mux_pll_p, 0, RK3288_PLL_CON(0),
-		     RK3288_MODE_CON, 0, 6, 0, rk3288_pll_rates),
-	[dpll] = PLL(pll_rk3066, PLL_DPLL, "dpll", mux_pll_p, 0, RK3288_PLL_CON(4),
-		     RK3288_MODE_CON, 4, 5, 0, NULL),
-	[cpll] = PLL(pll_rk3066, PLL_CPLL, "cpll", mux_pll_p, 0, RK3288_PLL_CON(8),
-		     RK3288_MODE_CON, 8, 7, ROCKCHIP_PLL_SYNC_RATE, rk3288_pll_rates),
-	[gpll] = PLL(pll_rk3066, PLL_GPLL, "gpll", mux_pll_p, 0, RK3288_PLL_CON(12),
-		     RK3288_MODE_CON, 12, 8, ROCKCHIP_PLL_SYNC_RATE, rk3288_pll_rates),
-	[npll] = PLL(pll_rk3066, PLL_NPLL, "npll",  mux_pll_p, 0, RK3288_PLL_CON(16),
-		     RK3288_MODE_CON, 14, 9, ROCKCHIP_PLL_SYNC_RATE, rk3288_pll_rates),
-};
-
-static struct clk_div_table div_hclk_cpu_t[] = {
-	{ .val = 0, .div = 1 },
-	{ .val = 1, .div = 2 },
-	{ .val = 3, .div = 4 },
-	{ /* sentinel */},
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-#define IFLAGS ROCKCHIP_INVERTER_HIWORD_MASK
-
-static struct rockchip_clk_branch rk3288_i2s_fracmux __initdata =
-	MUX(0, "i2s_pre", mux_i2s_pre_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(4), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_spdif_fracmux __initdata =
-	MUX(0, "spdif_mux", mux_spdif_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(5), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_spdif_8ch_fracmux __initdata =
-	MUX(0, "spdif_8ch_mux", mux_spdif_8ch_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(40), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(13), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(15), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_uart3_fracmux __initdata =
-	MUX(SCLK_UART3, "sclk_uart3", mux_uart3_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(16), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_uart4_fracmux __initdata =
-	MUX(SCLK_UART4, "sclk_uart4", mux_uart4_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(3), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 1
-	 */
-
-	GATE(0, "apll_core", "apll", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "gpll_core", "gpll", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 2, GFLAGS),
-
-	COMPOSITE_NOMUX(0, "armcore0", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(36), 0, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 0, GFLAGS),
-	COMPOSITE_NOMUX(0, "armcore1", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(36), 4, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 1, GFLAGS),
-	COMPOSITE_NOMUX(0, "armcore2", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(36), 8, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 2, GFLAGS),
-	COMPOSITE_NOMUX(0, "armcore3", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(36), 12, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 3, GFLAGS),
-	COMPOSITE_NOMUX(0, "l2ram", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(37), 0, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 4, GFLAGS),
-	COMPOSITE_NOMUX(0, "aclk_core_m0", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(0), 0, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 5, GFLAGS),
-	COMPOSITE_NOMUX(0, "aclk_core_mp", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(0), 4, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 6, GFLAGS),
-	COMPOSITE_NOMUX(0, "atclk", "armclk", 0,
-			RK3288_CLKSEL_CON(37), 4, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 7, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_dbg_pre", "armclk", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(37), 9, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3288_CLKGATE_CON(12), 8, GFLAGS),
-	GATE(0, "pclk_dbg", "pclk_dbg_pre", 0,
-			RK3288_CLKGATE_CON(12), 9, GFLAGS),
-	GATE(0, "cs_dbg", "pclk_dbg_pre", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(12), 10, GFLAGS),
-	GATE(0, "pclk_core_niu", "pclk_dbg_pre", 0,
-			RK3288_CLKGATE_CON(12), 11, GFLAGS),
-
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 8, GFLAGS),
-	GATE(0, "gpll_ddr", "gpll", 0,
-			RK3288_CLKGATE_CON(0), 9, GFLAGS),
-	COMPOSITE_NOGATE(0, "ddrphy", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(26), 2, 1, MFLAGS, 0, 2,
-					DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-
-	GATE(0, "gpll_aclk_cpu", "gpll", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 10, GFLAGS),
-	GATE(0, "cpll_aclk_cpu", "cpll", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 11, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_cpu_src", mux_aclk_cpu_src_p, CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(1), 15, 1, MFLAGS, 3, 5, DFLAGS),
-	DIV(0, "aclk_cpu_pre", "aclk_cpu_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(1), 0, 3, DFLAGS),
-	GATE(ACLK_CPU, "aclk_cpu", "aclk_cpu_pre", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 3, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_CPU, "pclk_cpu", "aclk_cpu_pre", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(1), 12, 3, DFLAGS,
-			RK3288_CLKGATE_CON(0), 5, GFLAGS),
-	COMPOSITE_NOMUX_DIVTBL(HCLK_CPU, "hclk_cpu", "aclk_cpu_pre", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(1), 8, 2, DFLAGS, div_hclk_cpu_t,
-			RK3288_CLKGATE_CON(0), 4, GFLAGS),
-	GATE(0, "c2c_host", "aclk_cpu_src", 0,
-			RK3288_CLKGATE_CON(13), 8, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_CRYPTO, "crypto", "aclk_cpu_pre", 0,
-			RK3288_CLKSEL_CON(26), 6, 2, DFLAGS,
-			RK3288_CLKGATE_CON(5), 4, GFLAGS),
-	GATE(0, "aclk_bus_2pmu", "aclk_cpu_pre", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(0), 7, GFLAGS),
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	COMPOSITE(0, "i2s_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(4), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(4), 1, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s_frac", "i2s_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(8), 0,
-			RK3288_CLKGATE_CON(4), 2, GFLAGS,
-			&rk3288_i2s_fracmux),
-	COMPOSITE_NODIV(SCLK_I2S0_OUT, "i2s0_clkout", mux_i2s_clkout_p, 0,
-			RK3288_CLKSEL_CON(4), 12, 1, MFLAGS,
-			RK3288_CLKGATE_CON(4), 0, GFLAGS),
-	GATE(SCLK_I2S0, "sclk_i2s0", "i2s_pre", CLK_SET_RATE_PARENT,
-			RK3288_CLKGATE_CON(4), 3, GFLAGS),
-
-	MUX(0, "spdif_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(5), 15, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "spdif_pre", "spdif_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(5), 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(4), 4, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_frac", "spdif_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(9), 0,
-			RK3288_CLKGATE_CON(4), 5, GFLAGS,
-			&rk3288_spdif_fracmux),
-	GATE(SCLK_SPDIF, "sclk_spdif", "spdif_mux", CLK_SET_RATE_PARENT,
-			RK3288_CLKGATE_CON(4), 6, GFLAGS),
-	COMPOSITE_NOMUX(0, "spdif_8ch_pre", "spdif_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(40), 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(4), 7, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_8ch_frac", "spdif_8ch_pre", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(41), 0,
-			RK3288_CLKGATE_CON(4), 8, GFLAGS,
-			&rk3288_spdif_8ch_fracmux),
-	GATE(SCLK_SPDIF8CH, "sclk_spdif_8ch", "spdif_8ch_mux", CLK_SET_RATE_PARENT,
-			RK3288_CLKGATE_CON(4), 9, GFLAGS),
-
-	GATE(0, "sclk_acc_efuse", "xin24m", 0,
-			RK3288_CLKGATE_CON(0), 12, GFLAGS),
-
-	GATE(SCLK_TIMER0, "sclk_timer0", "xin24m", 0,
-			RK3288_CLKGATE_CON(1), 0, GFLAGS),
-	GATE(SCLK_TIMER1, "sclk_timer1", "xin24m", 0,
-			RK3288_CLKGATE_CON(1), 1, GFLAGS),
-	GATE(SCLK_TIMER2, "sclk_timer2", "xin24m", 0,
-			RK3288_CLKGATE_CON(1), 2, GFLAGS),
-	GATE(SCLK_TIMER3, "sclk_timer3", "xin24m", 0,
-			RK3288_CLKGATE_CON(1), 3, GFLAGS),
-	GATE(SCLK_TIMER4, "sclk_timer4", "xin24m", 0,
-			RK3288_CLKGATE_CON(1), 4, GFLAGS),
-	GATE(SCLK_TIMER5, "sclk_timer5", "xin24m", 0,
-			RK3288_CLKGATE_CON(1), 5, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	COMPOSITE(0, "aclk_vepu", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK3288_CLKSEL_CON(32), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(3), 9, GFLAGS),
-	COMPOSITE(0, "aclk_vdpu", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK3288_CLKSEL_CON(32), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(3), 11, GFLAGS),
-	MUXGRF(0, "aclk_vcodec_pre", mux_aclk_vcodec_pre_p, CLK_SET_RATE_PARENT,
-			RK3288_GRF_SOC_CON(0), 7, 1, MFLAGS),
-	GATE(ACLK_VCODEC, "aclk_vcodec", "aclk_vcodec_pre", 0,
-		RK3288_CLKGATE_CON(9), 0, GFLAGS),
-
-	FACTOR_GATE(0, "hclk_vcodec_pre", "aclk_vcodec_pre", 0, 1, 4,
-		RK3288_CLKGATE_CON(3), 10, GFLAGS),
-
-	GATE(HCLK_VCODEC, "hclk_vcodec", "hclk_vcodec_pre", 0,
-		RK3288_CLKGATE_CON(9), 1, GFLAGS),
-
-	COMPOSITE(0, "aclk_vio0", mux_pll_src_cpll_gpll_usb480m_p, CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(31), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(3), 0, GFLAGS),
-	DIV(0, "hclk_vio", "aclk_vio0", 0,
-			RK3288_CLKSEL_CON(28), 8, 5, DFLAGS),
-	COMPOSITE(0, "aclk_vio1", mux_pll_src_cpll_gpll_usb480m_p, CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(31), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(3), 2, GFLAGS),
-
-	COMPOSITE(0, "aclk_rga_pre", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK3288_CLKSEL_CON(30), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(3), 5, GFLAGS),
-	COMPOSITE(SCLK_RGA, "sclk_rga", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK3288_CLKSEL_CON(30), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(3), 4, GFLAGS),
-
-	COMPOSITE(DCLK_VOP0, "dclk_vop0", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(27), 0, 2, MFLAGS, 8, 8, DFLAGS,
-			RK3288_CLKGATE_CON(3), 1, GFLAGS),
-	COMPOSITE(DCLK_VOP1, "dclk_vop1", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(29), 6, 2, MFLAGS, 8, 8, DFLAGS,
-			RK3288_CLKGATE_CON(3), 3, GFLAGS),
-
-	COMPOSITE_NODIV(SCLK_EDP_24M, "sclk_edp_24m", mux_edp_24m_p, 0,
-			RK3288_CLKSEL_CON(28), 15, 1, MFLAGS,
-			RK3288_CLKGATE_CON(3), 12, GFLAGS),
-	COMPOSITE(SCLK_EDP, "sclk_edp", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(28), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3288_CLKGATE_CON(3), 13, GFLAGS),
-
-	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(6), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3288_CLKGATE_CON(3), 14, GFLAGS),
-	COMPOSITE(SCLK_ISP_JPE, "sclk_isp_jpe", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(6), 14, 2, MFLAGS, 8, 6, DFLAGS,
-			RK3288_CLKGATE_CON(3), 15, GFLAGS),
-
-	GATE(SCLK_HDMI_HDCP, "sclk_hdmi_hdcp", "xin24m", 0,
-			RK3288_CLKGATE_CON(5), 12, GFLAGS),
-	GATE(SCLK_HDMI_CEC, "sclk_hdmi_cec", "xin32k", 0,
-			RK3288_CLKGATE_CON(5), 11, GFLAGS),
-
-	COMPOSITE(ACLK_HEVC, "aclk_hevc", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(39), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(13), 13, GFLAGS),
-	DIV(HCLK_HEVC, "hclk_hevc", "aclk_hevc", 0,
-			RK3288_CLKSEL_CON(40), 12, 2, DFLAGS),
-
-	COMPOSITE(SCLK_HEVC_CABAC, "sclk_hevc_cabac", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(42), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(13), 14, GFLAGS),
-	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(42), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(13), 15, GFLAGS),
-
-	COMPOSITE_NODIV(0, "vip_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(26), 8, 1, MFLAGS,
-			RK3288_CLKGATE_CON(3), 7, GFLAGS),
-	COMPOSITE_NOGATE(SCLK_VIP_OUT, "sclk_vip_out", mux_vip_out_p, 0,
-			RK3288_CLKSEL_CON(26), 15, 1, MFLAGS, 9, 5, DFLAGS),
-
-	DIV(0, "pclk_pd_alive", "gpll", 0,
-			RK3288_CLKSEL_CON(33), 8, 5, DFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_pd_pmu", "gpll", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(33), 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(5), 8, GFLAGS),
-
-	COMPOSITE(SCLK_GPU, "sclk_gpu", mux_pll_src_cpll_gll_usb_npll_p, 0,
-			RK3288_CLKSEL_CON(34), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(5), 7, GFLAGS),
-
-	COMPOSITE(0, "aclk_peri_src", mux_pll_src_cpll_gpll_p, CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(10), 15, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_src", 0,
-			RK3288_CLKSEL_CON(10), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3288_CLKGATE_CON(2), 3, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERI, "hclk_peri", "aclk_peri_src", CLK_IGNORE_UNUSED,
-			RK3288_CLKSEL_CON(10), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3288_CLKGATE_CON(2), 2, GFLAGS),
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_src", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(2), 1, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-
-	COMPOSITE(SCLK_SPI0, "sclk_spi0", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(25), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(2), 9, GFLAGS),
-	COMPOSITE(SCLK_SPI1, "sclk_spi1", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(25), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3288_CLKGATE_CON(2), 10, GFLAGS),
-	COMPOSITE(SCLK_SPI2, "sclk_spi2", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(39), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(2), 11, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC, "sclk_sdmmc", mux_mmc_src_p, 0,
-			RK3288_CLKSEL_CON(11), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3288_CLKGATE_CON(13), 0, GFLAGS),
-	COMPOSITE(SCLK_SDIO0, "sclk_sdio0", mux_mmc_src_p, 0,
-			RK3288_CLKSEL_CON(12), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3288_CLKGATE_CON(13), 1, GFLAGS),
-	COMPOSITE(SCLK_SDIO1, "sclk_sdio1", mux_mmc_src_p, 0,
-			RK3288_CLKSEL_CON(34), 14, 2, MFLAGS, 8, 6, DFLAGS,
-			RK3288_CLKGATE_CON(13), 2, GFLAGS),
-	COMPOSITE(SCLK_EMMC, "sclk_emmc", mux_mmc_src_p, 0,
-			RK3288_CLKSEL_CON(12), 14, 2, MFLAGS, 8, 6, DFLAGS,
-			RK3288_CLKGATE_CON(13), 3, GFLAGS),
-
-	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RK3288_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3288_SDMMC_CON1, 0),
-
-	MMC(SCLK_SDIO0_DRV,    "sdio0_drv",    "sclk_sdio0", RK3288_SDIO0_CON0, 1),
-	MMC(SCLK_SDIO0_SAMPLE, "sdio0_sample", "sclk_sdio0", RK3288_SDIO0_CON1, 0),
-
-	MMC(SCLK_SDIO1_DRV,    "sdio1_drv",    "sclk_sdio1", RK3288_SDIO1_CON0, 1),
-	MMC(SCLK_SDIO1_SAMPLE, "sdio1_sample", "sclk_sdio1", RK3288_SDIO1_CON1, 0),
-
-	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RK3288_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3288_EMMC_CON1,  0),
-
-	COMPOSITE(0, "sclk_tspout", mux_tspout_p, 0,
-			RK3288_CLKSEL_CON(35), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(4), 11, GFLAGS),
-	COMPOSITE(0, "sclk_tsp", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3288_CLKSEL_CON(35), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(4), 10, GFLAGS),
-
-	GATE(SCLK_OTGPHY0, "sclk_otgphy0", "xin24m", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(13), 4, GFLAGS),
-	GATE(SCLK_OTGPHY1, "sclk_otgphy1", "xin24m", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(13), 5, GFLAGS),
-	GATE(SCLK_OTGPHY2, "sclk_otgphy2", "xin24m", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(13), 6, GFLAGS),
-	GATE(SCLK_OTG_ADP, "sclk_otg_adp", "xin32k", CLK_IGNORE_UNUSED,
-			RK3288_CLKGATE_CON(13), 7, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_TSADC, "sclk_tsadc", "xin32k", 0,
-			RK3288_CLKSEL_CON(2), 0, 6, DFLAGS,
-			RK3288_CLKGATE_CON(2), 7, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_SARADC, "sclk_saradc", "xin24m", 0,
-			RK3288_CLKSEL_CON(24), 8, 8, DFLAGS,
-			RK3288_CLKGATE_CON(2), 8, GFLAGS),
-
-	GATE(SCLK_PS2C, "sclk_ps2c", "xin24m", 0,
-			RK3288_CLKGATE_CON(5), 13, GFLAGS),
-
-	COMPOSITE(SCLK_NANDC0, "sclk_nandc0", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(38), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3288_CLKGATE_CON(5), 5, GFLAGS),
-	COMPOSITE(SCLK_NANDC1, "sclk_nandc1", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(38), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(5), 6, GFLAGS),
-
-	COMPOSITE(0, "uart0_src", mux_pll_src_cpll_gll_usb_npll_p, 0,
-			RK3288_CLKSEL_CON(13), 13, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(1), 8, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(17), 0,
-			RK3288_CLKGATE_CON(1), 9, GFLAGS,
-			&rk3288_uart0_fracmux),
-	MUX(0, "uart_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(13), 15, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "uart1_src", "uart_src", 0,
-			RK3288_CLKSEL_CON(14), 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(1), 10, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(18), 0,
-			RK3288_CLKGATE_CON(1), 11, GFLAGS,
-			&rk3288_uart1_fracmux),
-	COMPOSITE_NOMUX(0, "uart2_src", "uart_src", 0,
-			RK3288_CLKSEL_CON(15), 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(1), 12, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart2_frac", "uart2_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(19), 0,
-			RK3288_CLKGATE_CON(1), 13, GFLAGS,
-			&rk3288_uart2_fracmux),
-	COMPOSITE_NOMUX(0, "uart3_src", "uart_src", 0,
-			RK3288_CLKSEL_CON(16), 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(1), 14, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart3_frac", "uart3_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(20), 0,
-			RK3288_CLKGATE_CON(1), 15, GFLAGS,
-			&rk3288_uart3_fracmux),
-	COMPOSITE_NOMUX(0, "uart4_src", "uart_src", 0,
-			RK3288_CLKSEL_CON(3), 0, 7, DFLAGS,
-			RK3288_CLKGATE_CON(2), 12, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart4_frac", "uart4_src", CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(7), 0,
-			RK3288_CLKGATE_CON(2), 13, GFLAGS,
-			&rk3288_uart4_fracmux),
-
-	COMPOSITE(0, "mac_pll_src", mux_pll_src_npll_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(21), 0, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3288_CLKGATE_CON(2), 5, GFLAGS),
-	MUX(SCLK_MAC, "mac_clk", mux_mac_p, CLK_SET_RATE_PARENT,
-			RK3288_CLKSEL_CON(21), 4, 1, MFLAGS),
-	GATE(SCLK_MACREF_OUT, "sclk_macref_out", "mac_clk", 0,
-			RK3288_CLKGATE_CON(5), 3, GFLAGS),
-	GATE(SCLK_MACREF, "sclk_macref", "mac_clk", 0,
-			RK3288_CLKGATE_CON(5), 2, GFLAGS),
-	GATE(SCLK_MAC_RX, "sclk_mac_rx", "mac_clk", 0,
-			RK3288_CLKGATE_CON(5), 0, GFLAGS),
-	GATE(SCLK_MAC_TX, "sclk_mac_tx", "mac_clk", 0,
-			RK3288_CLKGATE_CON(5), 1, GFLAGS),
-
-	COMPOSITE(0, "hsadc_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3288_CLKSEL_CON(22), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK3288_CLKGATE_CON(2), 6, GFLAGS),
-	MUX(0, "sclk_hsadc_out", mux_hsadcout_p, 0,
-			RK3288_CLKSEL_CON(22), 4, 1, MFLAGS),
-	INVERTER(SCLK_HSADC, "sclk_hsadc", "sclk_hsadc_out",
-			RK3288_CLKSEL_CON(22), 7, IFLAGS),
-
-	GATE(0, "jtag", "ext_jtag", 0,
-			RK3288_CLKGATE_CON(4), 14, GFLAGS),
-
-	COMPOSITE_NODIV(SCLK_USBPHY480M_SRC, "usbphy480m_src", mux_usbphy480m_p, 0,
-			RK3288_CLKSEL_CON(13), 11, 2, MFLAGS,
-			RK3288_CLKGATE_CON(5), 14, GFLAGS),
-	COMPOSITE_NODIV(SCLK_HSICPHY480M, "sclk_hsicphy480m", mux_hsicphy480m_p, 0,
-			RK3288_CLKSEL_CON(29), 0, 2, MFLAGS,
-			RK3288_CLKGATE_CON(3), 6, GFLAGS),
-	GATE(0, "hsicphy12m_xin12m", "xin12m", 0,
-			RK3288_CLKGATE_CON(13), 9, GFLAGS),
-	DIV(0, "hsicphy12m_usbphy", "sclk_hsicphy480m", 0,
-			RK3288_CLKSEL_CON(11), 8, 6, DFLAGS),
-	MUX(SCLK_HSICPHY12M, "sclk_hsicphy12m", mux_hsicphy12m_p, 0,
-			RK3288_CLKSEL_CON(22), 4, 1, MFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 4
-	 */
-
-	/* aclk_cpu gates */
-	GATE(0, "sclk_intmem0", "aclk_cpu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(10), 5, GFLAGS),
-	GATE(0, "sclk_intmem1", "aclk_cpu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(10), 6, GFLAGS),
-	GATE(0, "sclk_intmem2", "aclk_cpu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(10), 7, GFLAGS),
-	GATE(ACLK_DMAC1, "aclk_dmac1", "aclk_cpu", 0, RK3288_CLKGATE_CON(10), 12, GFLAGS),
-	GATE(0, "aclk_strc_sys", "aclk_cpu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(10), 13, GFLAGS),
-	GATE(0, "aclk_intmem", "aclk_cpu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(10), 4, GFLAGS),
-	GATE(ACLK_CRYPTO, "aclk_crypto", "aclk_cpu", 0, RK3288_CLKGATE_CON(11), 6, GFLAGS),
-	GATE(0, "aclk_ccp", "aclk_cpu", 0, RK3288_CLKGATE_CON(11), 8, GFLAGS),
-
-	/* hclk_cpu gates */
-	GATE(HCLK_CRYPTO, "hclk_crypto", "hclk_cpu", 0, RK3288_CLKGATE_CON(11), 7, GFLAGS),
-	GATE(HCLK_I2S0, "hclk_i2s0", "hclk_cpu", 0, RK3288_CLKGATE_CON(10), 8, GFLAGS),
-	GATE(HCLK_ROM, "hclk_rom", "hclk_cpu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(10), 9, GFLAGS),
-	GATE(HCLK_SPDIF, "hclk_spdif", "hclk_cpu", 0, RK3288_CLKGATE_CON(10), 10, GFLAGS),
-	GATE(HCLK_SPDIF8CH, "hclk_spdif_8ch", "hclk_cpu", 0, RK3288_CLKGATE_CON(10), 11, GFLAGS),
-
-	/* pclk_cpu gates */
-	GATE(PCLK_PWM, "pclk_pwm", "pclk_cpu", 0, RK3288_CLKGATE_CON(10), 0, GFLAGS),
-	GATE(PCLK_TIMER, "pclk_timer", "pclk_cpu", 0, RK3288_CLKGATE_CON(10), 1, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_cpu", 0, RK3288_CLKGATE_CON(10), 2, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_cpu", 0, RK3288_CLKGATE_CON(10), 3, GFLAGS),
-	GATE(PCLK_DDRUPCTL0, "pclk_ddrupctl0", "pclk_cpu", 0, RK3288_CLKGATE_CON(10), 14, GFLAGS),
-	GATE(PCLK_PUBL0, "pclk_publ0", "pclk_cpu", 0, RK3288_CLKGATE_CON(10), 15, GFLAGS),
-	GATE(PCLK_DDRUPCTL1, "pclk_ddrupctl1", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 0, GFLAGS),
-	GATE(PCLK_PUBL1, "pclk_publ1", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 1, GFLAGS),
-	GATE(PCLK_EFUSE1024, "pclk_efuse_1024", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 2, GFLAGS),
-	GATE(PCLK_TZPC, "pclk_tzpc", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 3, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 9, GFLAGS),
-	GATE(PCLK_EFUSE256, "pclk_efuse_256", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 10, GFLAGS),
-	GATE(PCLK_RKPWM, "pclk_rkpwm", "pclk_cpu", 0, RK3288_CLKGATE_CON(11), 11, GFLAGS),
-
-	/* ddrctrl [DDR Controller PHY clock] gates */
-	GATE(0, "nclk_ddrupctl0", "ddrphy", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(11), 4, GFLAGS),
-	GATE(0, "nclk_ddrupctl1", "ddrphy", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(11), 5, GFLAGS),
-
-	/* ddrphy gates */
-	GATE(0, "sclk_ddrphy0", "ddrphy", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(4), 12, GFLAGS),
-	GATE(0, "sclk_ddrphy1", "ddrphy", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(4), 13, GFLAGS),
-
-	/* aclk_peri gates */
-	GATE(0, "aclk_peri_axi_matrix", "aclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(6), 2, GFLAGS),
-	GATE(ACLK_DMAC2, "aclk_dmac2", "aclk_peri", 0, RK3288_CLKGATE_CON(6), 3, GFLAGS),
-	GATE(0, "aclk_peri_niu", "aclk_peri", 0, RK3288_CLKGATE_CON(7), 11, GFLAGS),
-	GATE(ACLK_MMU, "aclk_mmu", "aclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(8), 12, GFLAGS),
-	GATE(ACLK_GMAC, "aclk_gmac", "aclk_peri", 0, RK3288_CLKGATE_CON(8), 0, GFLAGS),
-	GATE(HCLK_GPS, "hclk_gps", "aclk_peri", 0, RK3288_CLKGATE_CON(8), 2, GFLAGS),
-
-	/* hclk_peri gates */
-	GATE(0, "hclk_peri_matrix", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(6), 0, GFLAGS),
-	GATE(HCLK_OTG0, "hclk_otg0", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(7), 4, GFLAGS),
-	GATE(HCLK_USBHOST0, "hclk_host0", "hclk_peri", 0, RK3288_CLKGATE_CON(7), 6, GFLAGS),
-	GATE(HCLK_USBHOST1, "hclk_host1", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(7), 7, GFLAGS),
-	GATE(HCLK_HSIC, "hclk_hsic", "hclk_peri", 0, RK3288_CLKGATE_CON(7), 8, GFLAGS),
-	GATE(0, "hclk_usb_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(7), 9, GFLAGS),
-	GATE(0, "hclk_peri_ahb_arbi", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(7), 10, GFLAGS),
-	GATE(0, "hclk_emem", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(7), 12, GFLAGS),
-	GATE(0, "hclk_mem", "hclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(7), 13, GFLAGS),
-	GATE(HCLK_NANDC0, "hclk_nandc0", "hclk_peri", 0, RK3288_CLKGATE_CON(7), 14, GFLAGS),
-	GATE(HCLK_NANDC1, "hclk_nandc1", "hclk_peri", 0, RK3288_CLKGATE_CON(7), 15, GFLAGS),
-	GATE(HCLK_TSP, "hclk_tsp", "hclk_peri", 0, RK3288_CLKGATE_CON(8), 8, GFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK3288_CLKGATE_CON(8), 3, GFLAGS),
-	GATE(HCLK_SDIO0, "hclk_sdio0", "hclk_peri", 0, RK3288_CLKGATE_CON(8), 4, GFLAGS),
-	GATE(HCLK_SDIO1, "hclk_sdio1", "hclk_peri", 0, RK3288_CLKGATE_CON(8), 5, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK3288_CLKGATE_CON(8), 6, GFLAGS),
-	GATE(HCLK_HSADC, "hclk_hsadc", "hclk_peri", 0, RK3288_CLKGATE_CON(8), 7, GFLAGS),
-	GATE(0, "pmu_hclk_otg0", "hclk_peri", 0, RK3288_CLKGATE_CON(7), 5, GFLAGS),
-
-	/* pclk_peri gates */
-	GATE(0, "pclk_peri_matrix", "pclk_peri", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(6), 1, GFLAGS),
-	GATE(PCLK_SPI0, "pclk_spi0", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 4, GFLAGS),
-	GATE(PCLK_SPI1, "pclk_spi1", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 5, GFLAGS),
-	GATE(PCLK_SPI2, "pclk_spi2", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 6, GFLAGS),
-	GATE(PCLK_PS2C, "pclk_ps2c", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 7, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 8, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 9, GFLAGS),
-	GATE(PCLK_I2C4, "pclk_i2c4", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 15, GFLAGS),
-	GATE(PCLK_UART3, "pclk_uart3", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 11, GFLAGS),
-	GATE(PCLK_UART4, "pclk_uart4", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 12, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 13, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_peri", 0, RK3288_CLKGATE_CON(6), 14, GFLAGS),
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_peri", 0, RK3288_CLKGATE_CON(7), 1, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_peri", 0, RK3288_CLKGATE_CON(7), 2, GFLAGS),
-	GATE(PCLK_SIM, "pclk_sim", "pclk_peri", 0, RK3288_CLKGATE_CON(7), 3, GFLAGS),
-	GATE(PCLK_I2C5, "pclk_i2c5", "pclk_peri", 0, RK3288_CLKGATE_CON(7), 0, GFLAGS),
-	GATE(PCLK_GMAC, "pclk_gmac", "pclk_peri", 0, RK3288_CLKGATE_CON(8), 1, GFLAGS),
-
-	GATE(SCLK_LCDC_PWM0, "sclk_lcdc_pwm0", "xin24m", 0, RK3288_CLKGATE_CON(13), 10, GFLAGS),
-	GATE(SCLK_LCDC_PWM1, "sclk_lcdc_pwm1", "xin24m", 0, RK3288_CLKGATE_CON(13), 11, GFLAGS),
-	GATE(SCLK_PVTM_CORE, "sclk_pvtm_core", "xin24m", 0, RK3288_CLKGATE_CON(5), 9, GFLAGS),
-	GATE(SCLK_PVTM_GPU, "sclk_pvtm_gpu", "xin24m", 0, RK3288_CLKGATE_CON(5), 10, GFLAGS),
-	GATE(SCLK_MIPIDSI_24M, "sclk_mipidsi_24m", "xin24m", 0, RK3288_CLKGATE_CON(5), 15, GFLAGS),
-
-	/* sclk_gpu gates */
-	GATE(ACLK_GPU, "aclk_gpu", "sclk_gpu", 0, RK3288_CLKGATE_CON(18), 0, GFLAGS),
-
-	/* pclk_pd_alive gates */
-	GATE(PCLK_GPIO8, "pclk_gpio8", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 8, GFLAGS),
-	GATE(PCLK_GPIO7, "pclk_gpio7", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 7, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 1, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 2, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 3, GFLAGS),
-	GATE(PCLK_GPIO4, "pclk_gpio4", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 4, GFLAGS),
-	GATE(PCLK_GPIO5, "pclk_gpio5", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 5, GFLAGS),
-	GATE(PCLK_GPIO6, "pclk_gpio6", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 6, GFLAGS),
-	GATE(PCLK_GRF, "pclk_grf", "pclk_pd_alive", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(14), 11, GFLAGS),
-	GATE(0, "pclk_alive_niu", "pclk_pd_alive", 0, RK3288_CLKGATE_CON(14), 12, GFLAGS),
-
-	/* pclk_pd_pmu gates */
-	GATE(PCLK_PMU, "pclk_pmu", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(17), 0, GFLAGS),
-	GATE(0, "pclk_intmem1", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(17), 1, GFLAGS),
-	GATE(0, "pclk_pmu_niu", "pclk_pd_pmu", 0, RK3288_CLKGATE_CON(17), 2, GFLAGS),
-	GATE(PCLK_SGRF, "pclk_sgrf", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(17), 3, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_pd_pmu", 0, RK3288_CLKGATE_CON(17), 4, GFLAGS),
-
-	/* hclk_vio gates */
-	GATE(HCLK_RGA, "hclk_rga", "hclk_vio", 0, RK3288_CLKGATE_CON(15), 1, GFLAGS),
-	GATE(HCLK_VOP0, "hclk_vop0", "hclk_vio", 0, RK3288_CLKGATE_CON(15), 6, GFLAGS),
-	GATE(HCLK_VOP1, "hclk_vop1", "hclk_vio", 0, RK3288_CLKGATE_CON(15), 8, GFLAGS),
-	GATE(HCLK_VIO_AHB_ARBI, "hclk_vio_ahb_arbi", "hclk_vio", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(15), 9, GFLAGS),
-	GATE(HCLK_VIO_NIU, "hclk_vio_niu", "hclk_vio", 0, RK3288_CLKGATE_CON(15), 10, GFLAGS),
-	GATE(HCLK_VIP, "hclk_vip", "hclk_vio", 0, RK3288_CLKGATE_CON(15), 15, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_vio", 0, RK3288_CLKGATE_CON(15), 3, GFLAGS),
-	GATE(HCLK_ISP, "hclk_isp", "hclk_vio", 0, RK3288_CLKGATE_CON(16), 1, GFLAGS),
-	GATE(HCLK_VIO2_H2P, "hclk_vio2_h2p", "hclk_vio", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(16), 10, GFLAGS),
-	GATE(PCLK_MIPI_DSI0, "pclk_mipi_dsi0", "hclk_vio", 0, RK3288_CLKGATE_CON(16), 4, GFLAGS),
-	GATE(PCLK_MIPI_DSI1, "pclk_mipi_dsi1", "hclk_vio", 0, RK3288_CLKGATE_CON(16), 5, GFLAGS),
-	GATE(PCLK_MIPI_CSI, "pclk_mipi_csi", "hclk_vio", 0, RK3288_CLKGATE_CON(16), 6, GFLAGS),
-	GATE(PCLK_LVDS_PHY, "pclk_lvds_phy", "hclk_vio", 0, RK3288_CLKGATE_CON(16), 7, GFLAGS),
-	GATE(PCLK_EDP_CTRL, "pclk_edp_ctrl", "hclk_vio", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(16), 8, GFLAGS),
-	GATE(PCLK_HDMI_CTRL, "pclk_hdmi_ctrl", "hclk_vio", 0, RK3288_CLKGATE_CON(16), 9, GFLAGS),
-	GATE(PCLK_VIO2_H2P, "pclk_vio2_h2p", "hclk_vio", CLK_IGNORE_UNUSED, RK3288_CLKGATE_CON(16), 11, GFLAGS),
-
-	/* aclk_vio0 gates */
-	GATE(ACLK_VOP0, "aclk_vop0", "aclk_vio0", 0, RK3288_CLKGATE_CON(15), 5, GFLAGS),
-	GATE(ACLK_IEP, "aclk_iep", "aclk_vio0", 0, RK3288_CLKGATE_CON(15), 2, GFLAGS),
-	GATE(ACLK_VIO0_NIU, "aclk_vio0_niu", "aclk_vio0", 0, RK3288_CLKGATE_CON(15), 11, GFLAGS),
-	GATE(ACLK_VIP, "aclk_vip", "aclk_vio0", 0, RK3288_CLKGATE_CON(15), 14, GFLAGS),
-
-	/* aclk_vio1 gates */
-	GATE(ACLK_VOP1, "aclk_vop1", "aclk_vio1", 0, RK3288_CLKGATE_CON(15), 7, GFLAGS),
-	GATE(ACLK_ISP, "aclk_isp", "aclk_vio1", 0, RK3288_CLKGATE_CON(16), 2, GFLAGS),
-	GATE(ACLK_VIO1_NIU, "aclk_vio1_niu", "aclk_vio1", 0, RK3288_CLKGATE_CON(15), 12, GFLAGS),
-
-	/* aclk_rga_pre gates */
-	GATE(ACLK_RGA, "aclk_rga", "aclk_rga_pre", 0, RK3288_CLKGATE_CON(15), 0, GFLAGS),
-	GATE(ACLK_RGA_NIU, "aclk_rga_niu", "aclk_rga_pre", 0, RK3288_CLKGATE_CON(15), 13, GFLAGS),
-
-	/*
-	 * Other ungrouped clocks.
-	 */
-
-	GATE(0, "pclk_vip_in", "ext_vip", 0, RK3288_CLKGATE_CON(16), 0, GFLAGS),
-	INVERTER(0, "pclk_vip", "pclk_vip_in", RK3288_CLKSEL_CON(29), 4, IFLAGS),
-	GATE(PCLK_ISP_IN, "pclk_isp_in", "ext_isp", 0, RK3288_CLKGATE_CON(16), 3, GFLAGS),
-	INVERTER(0, "pclk_isp", "pclk_isp_in", RK3288_CLKSEL_CON(29), 3, IFLAGS),
-};
-
-static const char *const rk3288_critical_clocks[] __initconst = {
-	"aclk_cpu",
-	"aclk_peri",
-	"aclk_peri_niu",
-	"aclk_vio0_niu",
-	"aclk_vio1_niu",
-	"aclk_rga_niu",
-	"hclk_peri",
-	"hclk_vio_niu",
-	"pclk_alive_niu",
-	"pclk_pd_pmu",
-	"pclk_pmu_niu",
-	"pmu_hclk_otg0",
-	/* pwm-regulators on some boards, so handoff-critical later */
-	"pclk_rkpwm",
-};
-
-static void __iomem *rk3288_cru_base;
-
-/*
- * Some CRU registers will be reset in maskrom when the system
- * wakes up from fastboot.
- * So save them before suspend, restore them after resume.
- */
-static const int rk3288_saved_cru_reg_ids[] = {
-	RK3288_MODE_CON,
-	RK3288_CLKSEL_CON(0),
-	RK3288_CLKSEL_CON(1),
-	RK3288_CLKSEL_CON(10),
-	RK3288_CLKSEL_CON(33),
-	RK3288_CLKSEL_CON(37),
-
-	/* We turn aclk_dmac1 on for suspend; this will restore it */
-	RK3288_CLKGATE_CON(10),
-};
-
-static u32 rk3288_saved_cru_regs[ARRAY_SIZE(rk3288_saved_cru_reg_ids)];
-
-static int rk3288_clk_suspend(void)
-{
-	int i, reg_id;
-
-	for (i = 0; i < ARRAY_SIZE(rk3288_saved_cru_reg_ids); i++) {
-		reg_id = rk3288_saved_cru_reg_ids[i];
-
-		rk3288_saved_cru_regs[i] =
-				readl_relaxed(rk3288_cru_base + reg_id);
-	}
-
-	/*
-	 * Going into deep sleep (specifically setting PMU_CLR_DMA in
-	 * RK3288_PMU_PWRMODE_CON1) appears to fail unless
-	 * "aclk_dmac1" is on.
-	 */
-	writel_relaxed(1 << (12 + 16),
-		       rk3288_cru_base + RK3288_CLKGATE_CON(10));
-
-	/*
-	 * Switch PLLs other than DPLL (for SDRAM) to slow mode to
-	 * avoid crashes on resume. The Mask ROM on the system will
-	 * put APLL, CPLL, and GPLL into slow mode at resume time
-	 * anyway (which is why we restore them), but we might not
-	 * even make it to the Mask ROM if this isn't done at suspend
-	 * time.
-	 *
-	 * NOTE: only APLL truly matters here, but we'll do them all.
-	 */
-
-	writel_relaxed(0xf3030000, rk3288_cru_base + RK3288_MODE_CON);
-
-	return 0;
-}
-
-static void rk3288_clk_resume(void)
-{
-	int i, reg_id;
-
-	for (i = ARRAY_SIZE(rk3288_saved_cru_reg_ids) - 1; i >= 0; i--) {
-		reg_id = rk3288_saved_cru_reg_ids[i];
-
-		writel_relaxed(rk3288_saved_cru_regs[i] | 0xffff0000,
-			       rk3288_cru_base + reg_id);
-	}
-}
-
-static void rk3288_clk_shutdown(void)
-{
-	writel_relaxed(0xf3030000, rk3288_cru_base + RK3288_MODE_CON);
-}
-
-static struct syscore_ops rk3288_clk_syscore_ops = {
-	.suspend = rk3288_clk_suspend,
-	.resume = rk3288_clk_resume,
-};
-
-static void __init rk3288_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	struct clk *clk;
-
-	rk3288_cru_base = of_iomap(np, 0);
-	if (!rk3288_cru_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, rk3288_cru_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(rk3288_cru_base);
-		return;
-	}
-
-	/* Watchdog pclk is controlled by RK3288_SGRF_SOC_CON0[1]. */
-	clk = clk_register_fixed_factor(NULL, "pclk_wdt", "pclk_pd_alive", 0, 1, 1);
-	if (IS_ERR(clk))
-		pr_warn("%s: could not register clock pclk_wdt: %ld\n",
-			__func__, PTR_ERR(clk));
-	else
-		rockchip_clk_add_lookup(ctx, clk, PCLK_WDT);
-
-	rockchip_clk_register_plls(ctx, rk3288_pll_clks,
-				   ARRAY_SIZE(rk3288_pll_clks),
-				   RK3288_GRF_SOC_STATUS1);
-	rockchip_clk_register_branches(ctx, rk3288_clk_branches,
-				  ARRAY_SIZE(rk3288_clk_branches));
-	rockchip_clk_protect_critical(rk3288_critical_clocks,
-				      ARRAY_SIZE(rk3288_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-			mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-			&rk3288_cpuclk_data, rk3288_cpuclk_rates,
-			ARRAY_SIZE(rk3288_cpuclk_rates));
-
-	rockchip_register_softrst(np, 12,
-				  rk3288_cru_base + RK3288_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK3288_GLB_SRST_FST,
-					   rk3288_clk_shutdown);
-	register_syscore_ops(&rk3288_clk_syscore_ops);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3288_cru, "rockchip,rk3288-cru", rk3288_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
deleted file mode 100644
index f2f13b603..000000000
--- a/drivers/clk/rockchip/clk-rk3328.c
+++ /dev/null
@@ -1,923 +0,0 @@
-/*
- * Copyright (c) 2016 Rockchip Electronics Co. Ltd.
- * Author: Elaine <zhangqing@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/syscore_ops.h>
-#include <dt-bindings/clock/rk3328-cru.h>
-#include "clk.h"
-
-#define RK3328_GRF_SOC_CON4		0x410
-#define RK3328_GRF_SOC_STATUS0		0x480
-#define RK3328_GRF_MAC_CON1		0x904
-#define RK3328_GRF_MAC_CON2		0x908
-
-enum rk3328_plls {
-	apll, dpll, cpll, gpll, npll,
-};
-
-static struct rockchip_pll_rate_table rk3328_pll_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1584000000, 1, 66, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1560000000, 1, 65, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1536000000, 1, 64, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1488000000, 1, 62, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1464000000, 1, 61, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1440000000, 1, 60, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1392000000, 1, 58, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1368000000, 1, 57, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1344000000, 1, 56, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1320000000, 1, 55, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1272000000, 1, 53, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1248000000, 1, 52, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1188000000, 2, 99, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1104000000, 1, 46, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1100000000, 12, 550, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
-	RK3036_PLL_RATE(1000000000, 6, 500, 2, 1, 1, 0),
-	RK3036_PLL_RATE(984000000, 1, 82, 2, 1, 1, 0),
-	RK3036_PLL_RATE(960000000, 1, 80, 2, 1, 1, 0),
-	RK3036_PLL_RATE(936000000, 1, 78, 2, 1, 1, 0),
-	RK3036_PLL_RATE(912000000, 1, 76, 2, 1, 1, 0),
-	RK3036_PLL_RATE(900000000, 4, 300, 2, 1, 1, 0),
-	RK3036_PLL_RATE(888000000, 1, 74, 2, 1, 1, 0),
-	RK3036_PLL_RATE(864000000, 1, 72, 2, 1, 1, 0),
-	RK3036_PLL_RATE(840000000, 1, 70, 2, 1, 1, 0),
-	RK3036_PLL_RATE(816000000, 1, 68, 2, 1, 1, 0),
-	RK3036_PLL_RATE(800000000, 6, 400, 2, 1, 1, 0),
-	RK3036_PLL_RATE(700000000, 6, 350, 2, 1, 1, 0),
-	RK3036_PLL_RATE(696000000, 1, 58, 2, 1, 1, 0),
-	RK3036_PLL_RATE(600000000, 1, 75, 3, 1, 1, 0),
-	RK3036_PLL_RATE(594000000, 2, 99, 2, 1, 1, 0),
-	RK3036_PLL_RATE(504000000, 1, 63, 3, 1, 1, 0),
-	RK3036_PLL_RATE(500000000, 6, 250, 2, 1, 1, 0),
-	RK3036_PLL_RATE(408000000, 1, 68, 2, 2, 1, 0),
-	RK3036_PLL_RATE(312000000, 1, 52, 2, 2, 1, 0),
-	RK3036_PLL_RATE(216000000, 1, 72, 4, 2, 1, 0),
-	RK3036_PLL_RATE(96000000, 1, 64, 4, 4, 1, 0),
-	{ /* sentinel */ },
-};
-
-static struct rockchip_pll_rate_table rk3328_pll_frac_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(1016064000, 3, 127, 1, 1, 0, 134218),
-	/* vco = 1016064000 */
-	RK3036_PLL_RATE(983040000, 24, 983, 1, 1, 0, 671089),
-	/* vco = 983040000 */
-	RK3036_PLL_RATE(491520000, 24, 983, 2, 1, 0, 671089),
-	/* vco = 983040000 */
-	RK3036_PLL_RATE(61440000, 6, 215, 7, 2, 0, 671089),
-	/* vco = 860156000 */
-	RK3036_PLL_RATE(56448000, 12, 451, 4, 4, 0, 9797895),
-	/* vco = 903168000 */
-	RK3036_PLL_RATE(40960000, 12, 409, 4, 5, 0, 10066330),
-	/* vco = 819200000 */
-	{ /* sentinel */ },
-};
-
-#define RK3328_DIV_ACLKM_MASK		0x7
-#define RK3328_DIV_ACLKM_SHIFT		4
-#define RK3328_DIV_PCLK_DBG_MASK	0xf
-#define RK3328_DIV_PCLK_DBG_SHIFT	0
-
-#define RK3328_CLKSEL1(_aclk_core, _pclk_dbg)				\
-{									\
-	.reg = RK3328_CLKSEL_CON(1),					\
-	.val = HIWORD_UPDATE(_aclk_core, RK3328_DIV_ACLKM_MASK,		\
-			     RK3328_DIV_ACLKM_SHIFT) |			\
-	       HIWORD_UPDATE(_pclk_dbg, RK3328_DIV_PCLK_DBG_MASK,	\
-			     RK3328_DIV_PCLK_DBG_SHIFT),		\
-}
-
-#define RK3328_CPUCLK_RATE(_prate, _aclk_core, _pclk_dbg)		\
-{									\
-	.prate = _prate,						\
-	.divs = {							\
-		RK3328_CLKSEL1(_aclk_core, _pclk_dbg),			\
-	},								\
-}
-
-static struct rockchip_cpuclk_rate_table rk3328_cpuclk_rates[] __initdata = {
-	RK3328_CPUCLK_RATE(1800000000, 1, 7),
-	RK3328_CPUCLK_RATE(1704000000, 1, 7),
-	RK3328_CPUCLK_RATE(1608000000, 1, 7),
-	RK3328_CPUCLK_RATE(1512000000, 1, 7),
-	RK3328_CPUCLK_RATE(1488000000, 1, 5),
-	RK3328_CPUCLK_RATE(1416000000, 1, 5),
-	RK3328_CPUCLK_RATE(1392000000, 1, 5),
-	RK3328_CPUCLK_RATE(1296000000, 1, 5),
-	RK3328_CPUCLK_RATE(1200000000, 1, 5),
-	RK3328_CPUCLK_RATE(1104000000, 1, 5),
-	RK3328_CPUCLK_RATE(1008000000, 1, 5),
-	RK3328_CPUCLK_RATE(912000000, 1, 5),
-	RK3328_CPUCLK_RATE(816000000, 1, 3),
-	RK3328_CPUCLK_RATE(696000000, 1, 3),
-	RK3328_CPUCLK_RATE(600000000, 1, 3),
-	RK3328_CPUCLK_RATE(408000000, 1, 1),
-	RK3328_CPUCLK_RATE(312000000, 1, 1),
-	RK3328_CPUCLK_RATE(216000000,  1, 1),
-	RK3328_CPUCLK_RATE(96000000, 1, 1),
-};
-
-static const struct rockchip_cpuclk_reg_data rk3328_cpuclk_data = {
-	.core_reg = RK3328_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 3,
-	.mux_core_shift = 6,
-	.mux_core_mask = 0x3,
-};
-
-PNAME(mux_pll_p)		= { "xin24m" };
-
-PNAME(mux_2plls_p)		= { "cpll", "gpll" };
-PNAME(mux_gpll_cpll_p)		= { "gpll", "cpll" };
-PNAME(mux_cpll_gpll_apll_p)	= { "cpll", "gpll", "apll" };
-PNAME(mux_2plls_xin24m_p)	= { "cpll", "gpll", "xin24m" };
-PNAME(mux_2plls_hdmiphy_p)	= { "cpll", "gpll",
-				    "dummy_hdmiphy" };
-PNAME(mux_4plls_p)		= { "cpll", "gpll",
-				    "dummy_hdmiphy",
-				    "usb480m" };
-PNAME(mux_2plls_u480m_p)	= { "cpll", "gpll",
-				    "usb480m" };
-PNAME(mux_2plls_24m_u480m_p)	= { "cpll", "gpll",
-				     "xin24m", "usb480m" };
-
-PNAME(mux_ddrphy_p)		= { "dpll", "apll", "cpll" };
-PNAME(mux_armclk_p)		= { "apll_core",
-				    "gpll_core",
-				    "dpll_core",
-				    "npll_core"};
-PNAME(mux_hdmiphy_p)		= { "hdmi_phy", "xin24m" };
-PNAME(mux_usb480m_p)		= { "usb480m_phy",
-				    "xin24m" };
-
-PNAME(mux_i2s0_p)		= { "clk_i2s0_div",
-				    "clk_i2s0_frac",
-				    "xin12m",
-				    "xin12m" };
-PNAME(mux_i2s1_p)		= { "clk_i2s1_div",
-				    "clk_i2s1_frac",
-				    "clkin_i2s1",
-				    "xin12m" };
-PNAME(mux_i2s2_p)		= { "clk_i2s2_div",
-				    "clk_i2s2_frac",
-				    "clkin_i2s2",
-				    "xin12m" };
-PNAME(mux_i2s1out_p)		= { "clk_i2s1", "xin12m"};
-PNAME(mux_i2s2out_p)		= { "clk_i2s2", "xin12m" };
-PNAME(mux_spdif_p)		= { "clk_spdif_div",
-				    "clk_spdif_frac",
-				    "xin12m",
-				    "xin12m" };
-PNAME(mux_uart0_p)		= { "clk_uart0_div",
-				    "clk_uart0_frac",
-				    "xin24m" };
-PNAME(mux_uart1_p)		= { "clk_uart1_div",
-				    "clk_uart1_frac",
-				    "xin24m" };
-PNAME(mux_uart2_p)		= { "clk_uart2_div",
-				    "clk_uart2_frac",
-				    "xin24m" };
-
-PNAME(mux_sclk_cif_p)		= { "clk_cif_src",
-				    "xin24m" };
-PNAME(mux_dclk_lcdc_p)		= { "hdmiphy",
-				    "dclk_lcdc_src" };
-PNAME(mux_aclk_peri_pre_p)	= { "cpll_peri",
-				    "gpll_peri",
-				    "hdmiphy_peri" };
-PNAME(mux_ref_usb3otg_src_p)	= { "xin24m",
-				    "clk_usb3otg_ref" };
-PNAME(mux_xin24m_32k_p)		= { "xin24m",
-				    "clk_rtc32k" };
-PNAME(mux_mac2io_src_p)		= { "clk_mac2io_src",
-				    "gmac_clkin" };
-PNAME(mux_mac2phy_src_p)	= { "clk_mac2phy_src",
-				    "phy_50m_out" };
-PNAME(mux_mac2io_ext_p)		= { "clk_mac2io",
-				    "gmac_clkin" };
-
-static struct rockchip_pll_clock rk3328_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3328, PLL_APLL, "apll", mux_pll_p,
-		     0, RK3328_PLL_CON(0),
-		     RK3328_MODE_CON, 0, 4, 0, rk3328_pll_frac_rates),
-	[dpll] = PLL(pll_rk3328, PLL_DPLL, "dpll", mux_pll_p,
-		     0, RK3328_PLL_CON(8),
-		     RK3328_MODE_CON, 4, 3, 0, NULL),
-	[cpll] = PLL(pll_rk3328, PLL_CPLL, "cpll", mux_pll_p,
-		     0, RK3328_PLL_CON(16),
-		     RK3328_MODE_CON, 8, 2, 0, rk3328_pll_rates),
-	[gpll] = PLL(pll_rk3328, PLL_GPLL, "gpll", mux_pll_p,
-		     0, RK3328_PLL_CON(24),
-		     RK3328_MODE_CON, 12, 1, 0, rk3328_pll_frac_rates),
-	[npll] = PLL(pll_rk3328, PLL_NPLL, "npll", mux_pll_p,
-		     0, RK3328_PLL_CON(40),
-		     RK3328_MODE_CON, 1, 0, 0, rk3328_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-
-static struct rockchip_clk_branch rk3328_i2s0_fracmux __initdata =
-	MUX(0, "i2s0_pre", mux_i2s0_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(6), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_i2s1_fracmux __initdata =
-	MUX(0, "i2s1_pre", mux_i2s1_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(8), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_i2s2_fracmux __initdata =
-	MUX(0, "i2s2_pre", mux_i2s2_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(10), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_spdif_fracmux __initdata =
-	MUX(SCLK_SPDIF, "sclk_spdif", mux_spdif_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(12), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(16), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(18), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 1
-	 */
-
-	DIV(0, "clk_24m", "xin24m", CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(2), 8, 5, DFLAGS),
-	COMPOSITE(SCLK_RTC32K, "clk_rtc32k", mux_2plls_xin24m_p, 0,
-			RK3328_CLKSEL_CON(38), 14, 2, MFLAGS, 0, 14, DFLAGS,
-			RK3328_CLKGATE_CON(0), 11, GFLAGS),
-
-	/* PD_MISC */
-	MUX(HDMIPHY, "hdmiphy", mux_hdmiphy_p, CLK_SET_RATE_PARENT,
-			RK3328_MISC_CON, 13, 1, MFLAGS),
-	MUX(USB480M, "usb480m", mux_usb480m_p, CLK_SET_RATE_PARENT,
-			RK3328_MISC_CON, 15, 1, MFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	/* PD_CORE */
-	GATE(0, "apll_core", "apll", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(0), 0, GFLAGS),
-	GATE(0, "gpll_core", "gpll", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "dpll_core", "dpll", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "npll_core", "npll", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(0), 12, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_dbg", "armclk", CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(1), 0, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3328_CLKGATE_CON(7), 0, GFLAGS),
-	COMPOSITE_NOMUX(0, "aclk_core", "armclk", CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(1), 4, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3328_CLKGATE_CON(7), 1, GFLAGS),
-	GATE(0, "aclk_core_niu", "aclk_core", 0,
-			RK3328_CLKGATE_CON(13), 0, GFLAGS),
-	GATE(0, "aclk_gic400", "aclk_core", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(13), 1, GFLAGS),
-
-	GATE(0, "clk_jtag", "jtag_clkin", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(7), 2, GFLAGS),
-
-	/* PD_GPU */
-	COMPOSITE(0, "aclk_gpu_pre", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(44), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 6, GFLAGS),
-	GATE(ACLK_GPU, "aclk_gpu", "aclk_gpu_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(14), 0, GFLAGS),
-	GATE(0, "aclk_gpu_niu", "aclk_gpu_pre", 0,
-			RK3328_CLKGATE_CON(14), 1, GFLAGS),
-
-	/* PD_DDR */
-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
-	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 6, GFLAGS),
-	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 5, GFLAGS),
-	GATE(0, "aclk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 4, GFLAGS),
-	GATE(0, "clk_ddrmon", "xin24m", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(0), 6, GFLAGS),
-
-	COMPOSITE(PCLK_DDR, "pclk_ddr", mux_2plls_hdmiphy_p, 0,
-			RK3328_CLKSEL_CON(4), 13, 2, MFLAGS, 8, 3, DFLAGS,
-			RK3328_CLKGATE_CON(7), 4, GFLAGS),
-	GATE(0, "pclk_ddrupctl", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 1, GFLAGS),
-	GATE(0, "pclk_ddr_msch", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 2, GFLAGS),
-	GATE(0, "pclk_ddr_mon", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 3, GFLAGS),
-	GATE(0, "pclk_ddrstdby", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 7, GFLAGS),
-	GATE(0, "pclk_ddr_grf", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(18), 9, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-
-	/* PD_BUS */
-	COMPOSITE(ACLK_BUS_PRE, "aclk_bus_pre", mux_2plls_hdmiphy_p, 0,
-			RK3328_CLKSEL_CON(0), 13, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(8), 0, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_BUS_PRE, "hclk_bus_pre", "aclk_bus_pre", 0,
-			RK3328_CLKSEL_CON(1), 8, 2, DFLAGS,
-			RK3328_CLKGATE_CON(8), 1, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_BUS_PRE, "pclk_bus_pre", "aclk_bus_pre", 0,
-			RK3328_CLKSEL_CON(1), 12, 3, DFLAGS,
-			RK3328_CLKGATE_CON(8), 2, GFLAGS),
-	GATE(0, "pclk_bus", "pclk_bus_pre", 0,
-			RK3328_CLKGATE_CON(8), 3, GFLAGS),
-	GATE(0, "pclk_phy_pre", "pclk_bus_pre", 0,
-			RK3328_CLKGATE_CON(8), 4, GFLAGS),
-
-	COMPOSITE(SCLK_TSP, "clk_tsp", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(21), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(2), 5, GFLAGS),
-	GATE(0, "clk_hsadc_tsp", "ext_gpio3a2", 0,
-			RK3328_CLKGATE_CON(17), 13, GFLAGS),
-
-	/* PD_I2S */
-	COMPOSITE(0, "clk_i2s0_div", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(6), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(1), 1, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_i2s0_frac", "clk_i2s0_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(7), 0,
-			RK3328_CLKGATE_CON(1), 2, GFLAGS,
-			&rk3328_i2s0_fracmux),
-	GATE(SCLK_I2S0, "clk_i2s0", "i2s0_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(1), 3, GFLAGS),
-
-	COMPOSITE(0, "clk_i2s1_div", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(8), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(1), 4, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_i2s1_frac", "clk_i2s1_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(9), 0,
-			RK3328_CLKGATE_CON(1), 5, GFLAGS,
-			&rk3328_i2s1_fracmux),
-	GATE(SCLK_I2S1, "clk_i2s1", "i2s1_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(1), 6, GFLAGS),
-	COMPOSITE_NODIV(SCLK_I2S1_OUT, "i2s1_out", mux_i2s1out_p, 0,
-			RK3328_CLKSEL_CON(8), 12, 1, MFLAGS,
-			RK3328_CLKGATE_CON(1), 7, GFLAGS),
-
-	COMPOSITE(0, "clk_i2s2_div", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(10), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(1), 8, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_i2s2_frac", "clk_i2s2_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(11), 0,
-			RK3328_CLKGATE_CON(1), 9, GFLAGS,
-			&rk3328_i2s2_fracmux),
-	GATE(SCLK_I2S2, "clk_i2s2", "i2s2_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(1), 10, GFLAGS),
-	COMPOSITE_NODIV(SCLK_I2S2_OUT, "i2s2_out", mux_i2s2out_p, 0,
-			RK3328_CLKSEL_CON(10), 12, 1, MFLAGS,
-			RK3328_CLKGATE_CON(1), 11, GFLAGS),
-
-	COMPOSITE(0, "clk_spdif_div", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(12), 15, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(1), 12, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_spdif_frac", "clk_spdif_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(13), 0,
-			RK3328_CLKGATE_CON(1), 13, GFLAGS,
-			&rk3328_spdif_fracmux),
-
-	/* PD_UART */
-	COMPOSITE(0, "clk_uart0_div", mux_2plls_u480m_p, 0,
-			RK3328_CLKSEL_CON(14), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(1), 14, GFLAGS),
-	COMPOSITE(0, "clk_uart1_div", mux_2plls_u480m_p, 0,
-			RK3328_CLKSEL_CON(16), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE(0, "clk_uart2_div", mux_2plls_u480m_p, 0,
-			RK3328_CLKSEL_CON(18), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 2, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_uart0_frac", "clk_uart0_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(15), 0,
-			RK3328_CLKGATE_CON(1), 15, GFLAGS,
-			&rk3328_uart0_fracmux),
-	COMPOSITE_FRACMUX(0, "clk_uart1_frac", "clk_uart1_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(17), 0,
-			RK3328_CLKGATE_CON(2), 1, GFLAGS,
-			&rk3328_uart1_fracmux),
-	COMPOSITE_FRACMUX(0, "clk_uart2_frac", "clk_uart2_div", CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(19), 0,
-			RK3328_CLKGATE_CON(2), 3, GFLAGS,
-			&rk3328_uart2_fracmux),
-
-	/*
-	 * Clock-Architecture Diagram 4
-	 */
-
-	COMPOSITE(SCLK_I2C0, "clk_i2c0", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(34), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 9, GFLAGS),
-	COMPOSITE(SCLK_I2C1, "clk_i2c1", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(34), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 10, GFLAGS),
-	COMPOSITE(SCLK_I2C2, "clk_i2c2", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(35), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 11, GFLAGS),
-	COMPOSITE(SCLK_I2C3, "clk_i2c3", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(35), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 12, GFLAGS),
-	COMPOSITE(SCLK_CRYPTO, "clk_crypto", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(20), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(2), 4, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_TSADC, "clk_tsadc", "clk_24m", 0,
-			RK3328_CLKSEL_CON(22), 0, 10, DFLAGS,
-			RK3328_CLKGATE_CON(2), 6, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_SARADC, "clk_saradc", "clk_24m", 0,
-			RK3328_CLKSEL_CON(23), 0, 10, DFLAGS,
-			RK3328_CLKGATE_CON(2), 14, GFLAGS),
-	COMPOSITE(SCLK_SPI, "clk_spi", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(24), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 7, GFLAGS),
-	COMPOSITE(SCLK_PWM, "clk_pwm", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(24), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3328_CLKGATE_CON(2), 8, GFLAGS),
-	COMPOSITE(SCLK_OTP, "clk_otp", mux_2plls_xin24m_p, 0,
-			RK3328_CLKSEL_CON(4), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3328_CLKGATE_CON(3), 8, GFLAGS),
-	COMPOSITE(SCLK_EFUSE, "clk_efuse", mux_2plls_xin24m_p, 0,
-			RK3328_CLKSEL_CON(5), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(2), 13, GFLAGS),
-	COMPOSITE(SCLK_PDM, "clk_pdm", mux_cpll_gpll_apll_p, CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(20), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(2), 15, GFLAGS),
-
-	GATE(SCLK_TIMER0, "sclk_timer0", "xin24m", 0,
-			RK3328_CLKGATE_CON(8), 5, GFLAGS),
-	GATE(SCLK_TIMER1, "sclk_timer1", "xin24m", 0,
-			RK3328_CLKGATE_CON(8), 6, GFLAGS),
-	GATE(SCLK_TIMER2, "sclk_timer2", "xin24m", 0,
-			RK3328_CLKGATE_CON(8), 7, GFLAGS),
-	GATE(SCLK_TIMER3, "sclk_timer3", "xin24m", 0,
-			RK3328_CLKGATE_CON(8), 8, GFLAGS),
-	GATE(SCLK_TIMER4, "sclk_timer4", "xin24m", 0,
-			RK3328_CLKGATE_CON(8), 9, GFLAGS),
-	GATE(SCLK_TIMER5, "sclk_timer5", "xin24m", 0,
-			RK3328_CLKGATE_CON(8), 10, GFLAGS),
-
-	COMPOSITE(SCLK_WIFI, "clk_wifi", mux_2plls_u480m_p, 0,
-			RK3328_CLKSEL_CON(52), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3328_CLKGATE_CON(0), 10, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 5
-	 */
-
-	/* PD_VIDEO */
-	COMPOSITE(ACLK_RKVDEC_PRE, "aclk_rkvdec_pre", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(48), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 0, GFLAGS),
-	FACTOR_GATE(HCLK_RKVDEC_PRE, "hclk_rkvdec_pre", "aclk_rkvdec_pre", 0, 1, 4,
-			RK3328_CLKGATE_CON(11), 0, GFLAGS),
-	GATE(ACLK_RKVDEC, "aclk_rkvdec", "aclk_rkvdec_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(24), 0, GFLAGS),
-	GATE(HCLK_RKVDEC, "hclk_rkvdec", "hclk_rkvdec_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(24), 1, GFLAGS),
-	GATE(0, "aclk_rkvdec_niu", "aclk_rkvdec_pre", 0,
-			RK3328_CLKGATE_CON(24), 2, GFLAGS),
-	GATE(0, "hclk_rkvdec_niu", "hclk_rkvdec_pre", 0,
-			RK3328_CLKGATE_CON(24), 3, GFLAGS),
-
-	COMPOSITE(SCLK_VDEC_CABAC, "sclk_vdec_cabac", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(48), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 1, GFLAGS),
-
-	COMPOSITE(SCLK_VDEC_CORE, "sclk_vdec_core", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(49), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 2, GFLAGS),
-
-	COMPOSITE(ACLK_VPU_PRE, "aclk_vpu_pre", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(50), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 5, GFLAGS),
-	FACTOR_GATE(HCLK_VPU_PRE, "hclk_vpu_pre", "aclk_vpu_pre", 0, 1, 4,
-			RK3328_CLKGATE_CON(11), 8, GFLAGS),
-	GATE(ACLK_VPU, "aclk_vpu", "aclk_vpu_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(23), 0, GFLAGS),
-	GATE(HCLK_VPU, "hclk_vpu", "hclk_vpu_pre", CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(23), 1, GFLAGS),
-	GATE(0, "aclk_vpu_niu", "aclk_vpu_pre", 0,
-			RK3328_CLKGATE_CON(23), 2, GFLAGS),
-	GATE(0, "hclk_vpu_niu", "hclk_vpu_pre", 0,
-			RK3328_CLKGATE_CON(23), 3, GFLAGS),
-
-	COMPOSITE(ACLK_RKVENC, "aclk_rkvenc", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(51), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 3, GFLAGS),
-	FACTOR_GATE(HCLK_RKVENC, "hclk_rkvenc", "aclk_rkvenc", 0, 1, 4,
-			RK3328_CLKGATE_CON(11), 4, GFLAGS),
-	GATE(0, "aclk_rkvenc_niu", "aclk_rkvenc", 0,
-			RK3328_CLKGATE_CON(25), 0, GFLAGS),
-	GATE(0, "hclk_rkvenc_niu", "hclk_rkvenc", 0,
-			RK3328_CLKGATE_CON(25), 1, GFLAGS),
-	GATE(ACLK_H265, "aclk_h265", "aclk_rkvenc", 0,
-			RK3328_CLKGATE_CON(25), 2, GFLAGS),
-	GATE(PCLK_H265, "pclk_h265", "hclk_rkvenc", 0,
-			RK3328_CLKGATE_CON(25), 3, GFLAGS),
-	GATE(ACLK_H264, "aclk_h264", "aclk_rkvenc", 0,
-			RK3328_CLKGATE_CON(25), 4, GFLAGS),
-	GATE(HCLK_H264, "hclk_h264", "hclk_rkvenc", 0,
-			RK3328_CLKGATE_CON(25), 5, GFLAGS),
-	GATE(ACLK_AXISRAM, "aclk_axisram", "aclk_rkvenc", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(25), 6, GFLAGS),
-
-	COMPOSITE(SCLK_VENC_CORE, "sclk_venc_core", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(51), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 4, GFLAGS),
-
-	COMPOSITE(SCLK_VENC_DSP, "sclk_venc_dsp", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(52), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(6), 7, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 6
-	 */
-
-	/* PD_VIO */
-	COMPOSITE(ACLK_VIO_PRE, "aclk_vio_pre", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(37), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(5), 2, GFLAGS),
-	DIV(HCLK_VIO_PRE, "hclk_vio_pre", "aclk_vio_pre", 0,
-			RK3328_CLKSEL_CON(37), 8, 5, DFLAGS),
-
-	COMPOSITE(ACLK_RGA_PRE, "aclk_rga_pre", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(36), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(5), 0, GFLAGS),
-	COMPOSITE(SCLK_RGA, "clk_rga", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(36), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(5), 1, GFLAGS),
-	COMPOSITE(ACLK_VOP_PRE, "aclk_vop_pre", mux_4plls_p, 0,
-			RK3328_CLKSEL_CON(39), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(5), 5, GFLAGS),
-	GATE(SCLK_HDMI_SFC, "sclk_hdmi_sfc", "xin24m", 0,
-			RK3328_CLKGATE_CON(5), 4, GFLAGS),
-
-	COMPOSITE_NODIV(0, "clk_cif_src", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(42), 7, 1, MFLAGS,
-			RK3328_CLKGATE_CON(5), 3, GFLAGS),
-	COMPOSITE_NOGATE(SCLK_CIF_OUT, "clk_cif_out", mux_sclk_cif_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(42), 5, 1, MFLAGS, 0, 5, DFLAGS),
-
-	COMPOSITE(DCLK_LCDC_SRC, "dclk_lcdc_src", mux_gpll_cpll_p, 0,
-			RK3328_CLKSEL_CON(40), 0, 1, MFLAGS, 8, 8, DFLAGS,
-			RK3328_CLKGATE_CON(5), 6, GFLAGS),
-	DIV(DCLK_HDMIPHY, "dclk_hdmiphy", "dclk_lcdc_src", 0,
-			RK3328_CLKSEL_CON(40), 3, 3, DFLAGS),
-	MUX(DCLK_LCDC, "dclk_lcdc", mux_dclk_lcdc_p,  CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
-			RK3328_CLKSEL_CON(40), 1, 1, MFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 7
-	 */
-
-	/* PD_PERI */
-	GATE(0, "gpll_peri", "gpll", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(4), 0, GFLAGS),
-	GATE(0, "cpll_peri", "cpll", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(4), 1, GFLAGS),
-	GATE(0, "hdmiphy_peri", "hdmiphy", CLK_IGNORE_UNUSED,
-			RK3328_CLKGATE_CON(4), 2, GFLAGS),
-	COMPOSITE_NOGATE(ACLK_PERI_PRE, "aclk_peri_pre", mux_aclk_peri_pre_p, 0,
-			RK3328_CLKSEL_CON(28), 6, 2, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_pre", CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(29), 0, 2, DFLAGS,
-			RK3328_CLKGATE_CON(10), 2, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERI, "hclk_peri", "aclk_peri_pre", CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(29), 4, 3, DFLAGS,
-			RK3328_CLKGATE_CON(10), 1, GFLAGS),
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_pre", CLK_IGNORE_UNUSED | CLK_SET_RATE_PARENT,
-			RK3328_CLKGATE_CON(10), 0, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC, "clk_sdmmc", mux_2plls_24m_u480m_p, 0,
-			RK3328_CLKSEL_CON(30), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3328_CLKGATE_CON(4), 3, GFLAGS),
-
-	COMPOSITE(SCLK_SDIO, "clk_sdio", mux_2plls_24m_u480m_p, 0,
-			RK3328_CLKSEL_CON(31), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3328_CLKGATE_CON(4), 4, GFLAGS),
-
-	COMPOSITE(SCLK_EMMC, "clk_emmc", mux_2plls_24m_u480m_p, 0,
-			RK3328_CLKSEL_CON(32), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3328_CLKGATE_CON(4), 5, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC_EXT, "clk_sdmmc_ext", mux_2plls_24m_u480m_p, 0,
-			RK3328_CLKSEL_CON(43), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3328_CLKGATE_CON(4), 10, GFLAGS),
-
-	COMPOSITE(SCLK_REF_USB3OTG_SRC, "clk_ref_usb3otg_src", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(45), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3328_CLKGATE_CON(4), 9, GFLAGS),
-
-	MUX(SCLK_REF_USB3OTG, "clk_ref_usb3otg", mux_ref_usb3otg_src_p, CLK_SET_RATE_PARENT,
-			RK3328_CLKSEL_CON(45), 8, 1, MFLAGS),
-
-	GATE(SCLK_USB3OTG_REF, "clk_usb3otg_ref", "xin24m", 0,
-			RK3328_CLKGATE_CON(4), 7, GFLAGS),
-
-	COMPOSITE(SCLK_USB3OTG_SUSPEND, "clk_usb3otg_suspend", mux_xin24m_32k_p, 0,
-			RK3328_CLKSEL_CON(33), 15, 1, MFLAGS, 0, 10, DFLAGS,
-			RK3328_CLKGATE_CON(4), 8, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 8
-	 */
-
-	/* PD_GMAC */
-	COMPOSITE(ACLK_GMAC, "aclk_gmac", mux_2plls_hdmiphy_p, 0,
-			RK3328_CLKSEL_CON(25), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(3), 2, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_GMAC, "pclk_gmac", "aclk_gmac", 0,
-			RK3328_CLKSEL_CON(25), 8, 3, DFLAGS,
-			RK3328_CLKGATE_CON(9), 0, GFLAGS),
-
-	COMPOSITE(SCLK_MAC2IO_SRC, "clk_mac2io_src", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(27), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(3), 1, GFLAGS),
-	GATE(SCLK_MAC2IO_REF, "clk_mac2io_ref", "clk_mac2io", 0,
-			RK3328_CLKGATE_CON(9), 7, GFLAGS),
-	GATE(SCLK_MAC2IO_RX, "clk_mac2io_rx", "clk_mac2io", 0,
-			RK3328_CLKGATE_CON(9), 4, GFLAGS),
-	GATE(SCLK_MAC2IO_TX, "clk_mac2io_tx", "clk_mac2io", 0,
-			RK3328_CLKGATE_CON(9), 5, GFLAGS),
-	GATE(SCLK_MAC2IO_REFOUT, "clk_mac2io_refout", "clk_mac2io", 0,
-			RK3328_CLKGATE_CON(9), 6, GFLAGS),
-	COMPOSITE(SCLK_MAC2IO_OUT, "clk_mac2io_out", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(27), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3328_CLKGATE_CON(3), 5, GFLAGS),
-	MUXGRF(SCLK_MAC2IO, "clk_mac2io", mux_mac2io_src_p, CLK_SET_RATE_NO_REPARENT,
-			RK3328_GRF_MAC_CON1, 10, 1, MFLAGS),
-	MUXGRF(SCLK_MAC2IO_EXT, "clk_mac2io_ext", mux_mac2io_ext_p, CLK_SET_RATE_NO_REPARENT,
-			RK3328_GRF_SOC_CON4, 14, 1, MFLAGS),
-
-	COMPOSITE(SCLK_MAC2PHY_SRC, "clk_mac2phy_src", mux_2plls_p, 0,
-			RK3328_CLKSEL_CON(26), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3328_CLKGATE_CON(3), 0, GFLAGS),
-	GATE(SCLK_MAC2PHY_REF, "clk_mac2phy_ref", "clk_mac2phy", 0,
-			RK3328_CLKGATE_CON(9), 3, GFLAGS),
-	GATE(SCLK_MAC2PHY_RXTX, "clk_mac2phy_rxtx", "clk_mac2phy", 0,
-			RK3328_CLKGATE_CON(9), 1, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_MAC2PHY_OUT, "clk_mac2phy_out", "clk_mac2phy", 0,
-			RK3328_CLKSEL_CON(26), 8, 2, DFLAGS,
-			RK3328_CLKGATE_CON(9), 2, GFLAGS),
-	MUXGRF(SCLK_MAC2PHY, "clk_mac2phy", mux_mac2phy_src_p, CLK_SET_RATE_NO_REPARENT,
-			RK3328_GRF_MAC_CON2, 10, 1, MFLAGS),
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	/*
-	 * Clock-Architecture Diagram 9
-	 */
-
-	/* PD_VOP */
-	GATE(ACLK_RGA, "aclk_rga", "aclk_rga_pre", 0, RK3328_CLKGATE_CON(21), 10, GFLAGS),
-	GATE(0, "aclk_rga_niu", "aclk_rga_pre", 0, RK3328_CLKGATE_CON(22), 3, GFLAGS),
-	GATE(ACLK_VOP, "aclk_vop", "aclk_vop_pre", 0, RK3328_CLKGATE_CON(21), 2, GFLAGS),
-	GATE(0, "aclk_vop_niu", "aclk_vop_pre", 0, RK3328_CLKGATE_CON(21), 4, GFLAGS),
-
-	GATE(ACLK_IEP, "aclk_iep", "aclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 6, GFLAGS),
-	GATE(ACLK_CIF, "aclk_cif", "aclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 8, GFLAGS),
-	GATE(ACLK_HDCP, "aclk_hdcp", "aclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 15, GFLAGS),
-	GATE(0, "aclk_vio_niu", "aclk_vio_pre", 0, RK3328_CLKGATE_CON(22), 2, GFLAGS),
-
-	GATE(HCLK_VOP, "hclk_vop", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 3, GFLAGS),
-	GATE(0, "hclk_vop_niu", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 5, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 7, GFLAGS),
-	GATE(HCLK_CIF, "hclk_cif", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 9, GFLAGS),
-	GATE(HCLK_RGA, "hclk_rga", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 11, GFLAGS),
-	GATE(0, "hclk_ahb1tom", "hclk_vio_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(21), 12, GFLAGS),
-	GATE(0, "pclk_vio_h2p", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 13, GFLAGS),
-	GATE(0, "hclk_vio_h2p", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(21), 14, GFLAGS),
-	GATE(HCLK_HDCP, "hclk_hdcp", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(22), 0, GFLAGS),
-	GATE(0, "hclk_vio_niu", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(22), 1, GFLAGS),
-	GATE(PCLK_HDMI, "pclk_hdmi", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(22), 4, GFLAGS),
-	GATE(PCLK_HDCP, "pclk_hdcp", "hclk_vio_pre", 0, RK3328_CLKGATE_CON(22), 5, GFLAGS),
-
-	/* PD_PERI */
-	GATE(0, "aclk_peri_noc", "aclk_peri", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(19), 11, GFLAGS),
-	GATE(ACLK_USB3OTG, "aclk_usb3otg", "aclk_peri", 0, RK3328_CLKGATE_CON(19), 14, GFLAGS),
-
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 0, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 1, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 2, GFLAGS),
-	GATE(HCLK_SDMMC_EXT, "hclk_sdmmc_ext", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 15, GFLAGS),
-	GATE(HCLK_HOST0, "hclk_host0", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 6, GFLAGS),
-	GATE(HCLK_HOST0_ARB, "hclk_host0_arb", "hclk_peri", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(19), 7, GFLAGS),
-	GATE(HCLK_OTG, "hclk_otg", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 8, GFLAGS),
-	GATE(HCLK_OTG_PMU, "hclk_otg_pmu", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 9, GFLAGS),
-	GATE(0, "hclk_peri_niu", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 12, GFLAGS),
-	GATE(0, "pclk_peri_niu", "hclk_peri", 0, RK3328_CLKGATE_CON(19), 13, GFLAGS),
-
-	/* PD_GMAC */
-	GATE(ACLK_MAC2PHY, "aclk_mac2phy", "aclk_gmac", 0, RK3328_CLKGATE_CON(26), 0, GFLAGS),
-	GATE(ACLK_MAC2IO, "aclk_mac2io", "aclk_gmac", 0, RK3328_CLKGATE_CON(26), 2, GFLAGS),
-	GATE(0, "aclk_gmac_niu", "aclk_gmac", 0, RK3328_CLKGATE_CON(26), 4, GFLAGS),
-	GATE(PCLK_MAC2PHY, "pclk_mac2phy", "pclk_gmac", 0, RK3328_CLKGATE_CON(26), 1, GFLAGS),
-	GATE(PCLK_MAC2IO, "pclk_mac2io", "pclk_gmac", 0, RK3328_CLKGATE_CON(26), 3, GFLAGS),
-	GATE(0, "pclk_gmac_niu", "pclk_gmac", 0, RK3328_CLKGATE_CON(26), 5, GFLAGS),
-
-	/* PD_BUS */
-	GATE(0, "aclk_bus_niu", "aclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 12, GFLAGS),
-	GATE(ACLK_DCF, "aclk_dcf", "aclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 11, GFLAGS),
-	GATE(ACLK_TSP, "aclk_tsp", "aclk_bus_pre", 0, RK3328_CLKGATE_CON(17), 12, GFLAGS),
-	GATE(0, "aclk_intmem", "aclk_bus_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(15), 0, GFLAGS),
-	GATE(ACLK_DMAC, "aclk_dmac_bus", "aclk_bus_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(15), 1, GFLAGS),
-
-	GATE(0, "hclk_rom", "hclk_bus_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(15), 2, GFLAGS),
-	GATE(HCLK_I2S0_8CH, "hclk_i2s0_8ch", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 3, GFLAGS),
-	GATE(HCLK_I2S1_8CH, "hclk_i2s1_8ch", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 4, GFLAGS),
-	GATE(HCLK_I2S2_2CH, "hclk_i2s2_2ch", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 5, GFLAGS),
-	GATE(HCLK_SPDIF_8CH, "hclk_spdif_8ch", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 6, GFLAGS),
-	GATE(HCLK_TSP, "hclk_tsp", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(17), 11, GFLAGS),
-	GATE(HCLK_CRYPTO_MST, "hclk_crypto_mst", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 7, GFLAGS),
-	GATE(HCLK_CRYPTO_SLV, "hclk_crypto_slv", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 8, GFLAGS),
-	GATE(0, "hclk_bus_niu", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(15), 13, GFLAGS),
-	GATE(HCLK_PDM, "hclk_pdm", "hclk_bus_pre", 0, RK3328_CLKGATE_CON(28), 0, GFLAGS),
-
-	GATE(0, "pclk_bus_niu", "pclk_bus", 0, RK3328_CLKGATE_CON(15), 14, GFLAGS),
-	GATE(0, "pclk_efuse", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(15), 9, GFLAGS),
-	GATE(0, "pclk_otp", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(28), 4, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_bus", 0, RK3328_CLKGATE_CON(15), 10, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 0, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 1, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 2, GFLAGS),
-	GATE(PCLK_TIMER, "pclk_timer0", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 3, GFLAGS),
-	GATE(0, "pclk_stimer", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 4, GFLAGS),
-	GATE(PCLK_SPI, "pclk_spi", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 5, GFLAGS),
-	GATE(PCLK_PWM, "pclk_rk_pwm", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 6, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 7, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 8, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 9, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 10, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 11, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 12, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 13, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 14, GFLAGS),
-	GATE(PCLK_DCF, "pclk_dcf", "pclk_bus", 0, RK3328_CLKGATE_CON(16), 15, GFLAGS),
-	GATE(PCLK_GRF, "pclk_grf", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 0, GFLAGS),
-	GATE(0, "pclk_cru", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 4, GFLAGS),
-	GATE(0, "pclk_sgrf", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 6, GFLAGS),
-	GATE(0, "pclk_sim", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 10, GFLAGS),
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_bus", 0, RK3328_CLKGATE_CON(17), 15, GFLAGS),
-	GATE(0, "pclk_pmu", "pclk_bus", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(28), 3, GFLAGS),
-
-	GATE(PCLK_USB3PHY_OTG, "pclk_usb3phy_otg", "pclk_phy_pre", 0, RK3328_CLKGATE_CON(28), 1, GFLAGS),
-	GATE(PCLK_USB3PHY_PIPE, "pclk_usb3phy_pipe", "pclk_phy_pre", 0, RK3328_CLKGATE_CON(28), 2, GFLAGS),
-	GATE(PCLK_USB3_GRF, "pclk_usb3_grf", "pclk_phy_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 2, GFLAGS),
-	GATE(PCLK_USB2_GRF, "pclk_usb2_grf", "pclk_phy_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 14, GFLAGS),
-	GATE(0, "pclk_ddrphy", "pclk_phy_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 13, GFLAGS),
-	GATE(0, "pclk_acodecphy", "pclk_phy_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 5, GFLAGS),
-	GATE(PCLK_HDMIPHY, "pclk_hdmiphy", "pclk_phy_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 7, GFLAGS),
-	GATE(0, "pclk_vdacphy", "pclk_phy_pre", CLK_IGNORE_UNUSED, RK3328_CLKGATE_CON(17), 8, GFLAGS),
-	GATE(0, "pclk_phy_niu", "pclk_phy_pre", 0, RK3328_CLKGATE_CON(15), 15, GFLAGS),
-
-	/* PD_MMC */
-	MMC(SCLK_SDMMC_DRV, "sdmmc_drv", "clk_sdmmc",
-	    RK3328_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "clk_sdmmc",
-	    RK3328_SDMMC_CON1, 0),
-
-	MMC(SCLK_SDIO_DRV, "sdio_drv", "clk_sdio",
-	    RK3328_SDIO_CON0, 1),
-	MMC(SCLK_SDIO_SAMPLE, "sdio_sample", "clk_sdio",
-	    RK3328_SDIO_CON1, 0),
-
-	MMC(SCLK_EMMC_DRV, "emmc_drv", "clk_emmc",
-	    RK3328_EMMC_CON0, 1),
-	MMC(SCLK_EMMC_SAMPLE, "emmc_sample", "clk_emmc",
-	    RK3328_EMMC_CON1, 0),
-
-	MMC(SCLK_SDMMC_EXT_DRV, "sdmmc_ext_drv", "clk_sdmmc_ext",
-	    RK3328_SDMMC_EXT_CON0, 1),
-	MMC(SCLK_SDMMC_EXT_SAMPLE, "sdmmc_ext_sample", "clk_sdmmc_ext",
-	    RK3328_SDMMC_EXT_CON1, 0),
-};
-
-static const char *const rk3328_critical_clocks[] __initconst = {
-	"aclk_bus",
-	"aclk_bus_niu",
-	"pclk_bus",
-	"pclk_bus_niu",
-	"hclk_bus",
-	"hclk_bus_niu",
-	"aclk_peri",
-	"hclk_peri",
-	"hclk_peri_niu",
-	"pclk_peri",
-	"pclk_peri_niu",
-	"pclk_dbg",
-	"aclk_core_niu",
-	"aclk_gic400",
-	"aclk_intmem",
-	"hclk_rom",
-	"pclk_grf",
-	"pclk_cru",
-	"pclk_sgrf",
-	"pclk_timer0",
-	"clk_timer0",
-	"pclk_ddr_msch",
-	"pclk_ddr_mon",
-	"pclk_ddr_grf",
-	"clk_ddrupctl",
-	"clk_ddrmsch",
-	"hclk_ahb1tom",
-	"clk_jtag",
-	"pclk_ddrphy",
-	"pclk_pmu",
-	"hclk_otg_pmu",
-	"aclk_rga_niu",
-	"pclk_vio_h2p",
-	"hclk_vio_h2p",
-	"aclk_vio_niu",
-	"hclk_vio_niu",
-	"aclk_vop_niu",
-	"hclk_vop_niu",
-	"aclk_gpu_niu",
-	"aclk_rkvdec_niu",
-	"hclk_rkvdec_niu",
-	"aclk_vpu_niu",
-	"hclk_vpu_niu",
-	"aclk_rkvenc_niu",
-	"hclk_rkvenc_niu",
-	"aclk_gmac_niu",
-	"pclk_gmac_niu",
-	"pclk_phy_niu",
-};
-
-static void __init rk3328_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	rockchip_clk_register_plls(ctx, rk3328_pll_clks,
-				   ARRAY_SIZE(rk3328_pll_clks),
-				   RK3328_GRF_SOC_STATUS0);
-	rockchip_clk_register_branches(ctx, rk3328_clk_branches,
-				       ARRAY_SIZE(rk3328_clk_branches));
-	rockchip_clk_protect_critical(rk3328_critical_clocks,
-				      ARRAY_SIZE(rk3328_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-				     mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-				     &rk3328_cpuclk_data, rk3328_cpuclk_rates,
-				     ARRAY_SIZE(rk3328_cpuclk_rates));
-
-	rockchip_register_softrst(np, 12, reg_base + RK3328_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK3328_GLB_SRST_FST, NULL);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3328_cru, "rockchip,rk3328-cru", rk3328_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3368.c b/drivers/clk/rockchip/clk-rk3368.c
deleted file mode 100644
index 7c4d242f1..000000000
--- a/drivers/clk/rockchip/clk-rk3368.c
+++ /dev/null
@@ -1,921 +0,0 @@
-/*
- * Copyright (c) 2015 Heiko Stuebner <heiko@sntech.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <dt-bindings/clock/rk3368-cru.h>
-#include "clk.h"
-
-#define RK3368_GRF_SOC_STATUS0	0x480
-
-enum rk3368_plls {
-	apllb, aplll, dpll, cpll, gpll, npll,
-};
-
-static struct rockchip_pll_rate_table rk3368_pll_rates[] = {
-	RK3066_PLL_RATE(2208000000, 1, 92, 1),
-	RK3066_PLL_RATE(2184000000, 1, 91, 1),
-	RK3066_PLL_RATE(2160000000, 1, 90, 1),
-	RK3066_PLL_RATE(2136000000, 1, 89, 1),
-	RK3066_PLL_RATE(2112000000, 1, 88, 1),
-	RK3066_PLL_RATE(2088000000, 1, 87, 1),
-	RK3066_PLL_RATE(2064000000, 1, 86, 1),
-	RK3066_PLL_RATE(2040000000, 1, 85, 1),
-	RK3066_PLL_RATE(2016000000, 1, 84, 1),
-	RK3066_PLL_RATE(1992000000, 1, 83, 1),
-	RK3066_PLL_RATE(1968000000, 1, 82, 1),
-	RK3066_PLL_RATE(1944000000, 1, 81, 1),
-	RK3066_PLL_RATE(1920000000, 1, 80, 1),
-	RK3066_PLL_RATE(1896000000, 1, 79, 1),
-	RK3066_PLL_RATE(1872000000, 1, 78, 1),
-	RK3066_PLL_RATE(1848000000, 1, 77, 1),
-	RK3066_PLL_RATE(1824000000, 1, 76, 1),
-	RK3066_PLL_RATE(1800000000, 1, 75, 1),
-	RK3066_PLL_RATE(1776000000, 1, 74, 1),
-	RK3066_PLL_RATE(1752000000, 1, 73, 1),
-	RK3066_PLL_RATE(1728000000, 1, 72, 1),
-	RK3066_PLL_RATE(1704000000, 1, 71, 1),
-	RK3066_PLL_RATE(1680000000, 1, 70, 1),
-	RK3066_PLL_RATE(1656000000, 1, 69, 1),
-	RK3066_PLL_RATE(1632000000, 1, 68, 1),
-	RK3066_PLL_RATE(1608000000, 1, 67, 1),
-	RK3066_PLL_RATE(1560000000, 1, 65, 1),
-	RK3066_PLL_RATE(1512000000, 1, 63, 1),
-	RK3066_PLL_RATE(1488000000, 1, 62, 1),
-	RK3066_PLL_RATE(1464000000, 1, 61, 1),
-	RK3066_PLL_RATE(1440000000, 1, 60, 1),
-	RK3066_PLL_RATE(1416000000, 1, 59, 1),
-	RK3066_PLL_RATE(1392000000, 1, 58, 1),
-	RK3066_PLL_RATE(1368000000, 1, 57, 1),
-	RK3066_PLL_RATE(1344000000, 1, 56, 1),
-	RK3066_PLL_RATE(1320000000, 1, 55, 1),
-	RK3066_PLL_RATE(1296000000, 1, 54, 1),
-	RK3066_PLL_RATE(1272000000, 1, 53, 1),
-	RK3066_PLL_RATE(1248000000, 1, 52, 1),
-	RK3066_PLL_RATE(1224000000, 1, 51, 1),
-	RK3066_PLL_RATE(1200000000, 1, 50, 1),
-	RK3066_PLL_RATE(1176000000, 1, 49, 1),
-	RK3066_PLL_RATE(1128000000, 1, 47, 1),
-	RK3066_PLL_RATE(1104000000, 1, 46, 1),
-	RK3066_PLL_RATE(1008000000, 1, 84, 2),
-	RK3066_PLL_RATE( 912000000, 1, 76, 2),
-	RK3066_PLL_RATE( 888000000, 1, 74, 2),
-	RK3066_PLL_RATE( 816000000, 1, 68, 2),
-	RK3066_PLL_RATE( 792000000, 1, 66, 2),
-	RK3066_PLL_RATE( 696000000, 1, 58, 2),
-	RK3066_PLL_RATE( 672000000, 1, 56, 2),
-	RK3066_PLL_RATE( 648000000, 1, 54, 2),
-	RK3066_PLL_RATE( 624000000, 1, 52, 2),
-	RK3066_PLL_RATE( 600000000, 1, 50, 2),
-	RK3066_PLL_RATE( 576000000, 1, 48, 2),
-	RK3066_PLL_RATE( 552000000, 1, 46, 2),
-	RK3066_PLL_RATE( 528000000, 1, 88, 4),
-	RK3066_PLL_RATE( 504000000, 1, 84, 4),
-	RK3066_PLL_RATE( 480000000, 1, 80, 4),
-	RK3066_PLL_RATE( 456000000, 1, 76, 4),
-	RK3066_PLL_RATE( 408000000, 1, 68, 4),
-	RK3066_PLL_RATE( 312000000, 1, 52, 4),
-	RK3066_PLL_RATE( 252000000, 1, 84, 8),
-	RK3066_PLL_RATE( 216000000, 1, 72, 8),
-	RK3066_PLL_RATE( 126000000, 2, 84, 8),
-	RK3066_PLL_RATE(  48000000, 2, 32, 8),
-	{ /* sentinel */ },
-};
-
-PNAME(mux_pll_p)		= { "xin24m", "xin32k" };
-PNAME(mux_armclkb_p)		= { "apllb_core", "gpllb_core" };
-PNAME(mux_armclkl_p)		= { "aplll_core", "gplll_core" };
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr" };
-PNAME(mux_cs_src_p)		= { "apllb_cs", "aplll_cs", "gpll_cs"};
-PNAME(mux_aclk_bus_src_p)	= { "cpll_aclk_bus", "gpll_aclk_bus" };
-
-PNAME(mux_pll_src_cpll_gpll_p)		= { "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_npll_p)	= { "cpll", "gpll", "npll" };
-PNAME(mux_pll_src_npll_cpll_gpll_p)	= { "npll", "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_usb_p)	= { "cpll", "gpll", "usbphy_480m" };
-PNAME(mux_pll_src_cpll_gpll_usb_usb_p)	= { "cpll", "gpll", "usbphy_480m",
-					    "usbphy_480m" };
-PNAME(mux_pll_src_cpll_gpll_usb_npll_p)	= { "cpll", "gpll", "usbphy_480m",
-					    "npll" };
-PNAME(mux_pll_src_cpll_gpll_npll_npll_p) = { "cpll", "gpll", "npll", "npll" };
-PNAME(mux_pll_src_cpll_gpll_npll_usb_p) = { "cpll", "gpll", "npll",
-					    "usbphy_480m" };
-
-PNAME(mux_i2s_8ch_pre_p)	= { "i2s_8ch_src", "i2s_8ch_frac",
-				    "ext_i2s", "xin12m" };
-PNAME(mux_i2s_8ch_clkout_p)	= { "i2s_8ch_pre", "xin12m" };
-PNAME(mux_i2s_2ch_p)		= { "i2s_2ch_src", "i2s_2ch_frac",
-				    "dummy", "xin12m" };
-PNAME(mux_spdif_8ch_p)		= { "spdif_8ch_pre", "spdif_8ch_frac",
-				    "ext_i2s", "xin12m" };
-PNAME(mux_edp_24m_p)		= { "xin24m", "dummy" };
-PNAME(mux_vip_out_p)		= { "vip_src", "xin24m" };
-PNAME(mux_usbphy480m_p)		= { "usbotg_out", "xin24m" };
-PNAME(mux_hsic_usbphy480m_p)	= { "usbotg_out", "dummy" };
-PNAME(mux_hsicphy480m_p)	= { "cpll", "gpll", "usbphy_480m" };
-PNAME(mux_uart0_p)		= { "uart0_src", "uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)		= { "uart1_src", "uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)		= { "uart2_src", "xin24m" };
-PNAME(mux_uart3_p)		= { "uart3_src", "uart3_frac", "xin24m" };
-PNAME(mux_uart4_p)		= { "uart4_src", "uart4_frac", "xin24m" };
-PNAME(mux_mac_p)		= { "mac_pll_src", "ext_gmac" };
-PNAME(mux_mmc_src_p)		= { "cpll", "gpll", "usbphy_480m", "xin24m" };
-
-static struct rockchip_pll_clock rk3368_pll_clks[] __initdata = {
-	[apllb] = PLL(pll_rk3066, PLL_APLLB, "apllb", mux_pll_p, 0, RK3368_PLL_CON(0),
-		     RK3368_PLL_CON(3), 8, 1, 0, rk3368_pll_rates),
-	[aplll] = PLL(pll_rk3066, PLL_APLLL, "aplll", mux_pll_p, 0, RK3368_PLL_CON(4),
-		     RK3368_PLL_CON(7), 8, 0, 0, rk3368_pll_rates),
-	[dpll] = PLL(pll_rk3066, PLL_DPLL, "dpll", mux_pll_p, 0, RK3368_PLL_CON(8),
-		     RK3368_PLL_CON(11), 8, 2, 0, NULL),
-	[cpll] = PLL(pll_rk3066, PLL_CPLL, "cpll", mux_pll_p, 0, RK3368_PLL_CON(12),
-		     RK3368_PLL_CON(15), 8, 3, ROCKCHIP_PLL_SYNC_RATE, rk3368_pll_rates),
-	[gpll] = PLL(pll_rk3066, PLL_GPLL, "gpll", mux_pll_p, 0, RK3368_PLL_CON(16),
-		     RK3368_PLL_CON(19), 8, 4, ROCKCHIP_PLL_SYNC_RATE, rk3368_pll_rates),
-	[npll] = PLL(pll_rk3066, PLL_NPLL, "npll",  mux_pll_p, 0, RK3368_PLL_CON(20),
-		     RK3368_PLL_CON(23), 8, 5, ROCKCHIP_PLL_SYNC_RATE, rk3368_pll_rates),
-};
-
-static struct clk_div_table div_ddrphy_t[] = {
-	{ .val = 0, .div = 1 },
-	{ .val = 1, .div = 2 },
-	{ .val = 3, .div = 4 },
-	{ /* sentinel */ },
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-#define IFLAGS ROCKCHIP_INVERTER_HIWORD_MASK
-
-static const struct rockchip_cpuclk_reg_data rk3368_cpuclkb_data = {
-	.core_reg = RK3368_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 7,
-	.mux_core_mask = 0x1,
-};
-
-static const struct rockchip_cpuclk_reg_data rk3368_cpuclkl_data = {
-	.core_reg = RK3368_CLKSEL_CON(2),
-	.div_core_shift = 0,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_shift = 7,
-	.mux_core_mask = 0x1,
-};
-
-#define RK3368_DIV_ACLKM_MASK		0x1f
-#define RK3368_DIV_ACLKM_SHIFT		8
-#define RK3368_DIV_ATCLK_MASK		0x1f
-#define RK3368_DIV_ATCLK_SHIFT		0
-#define RK3368_DIV_PCLK_DBG_MASK	0x1f
-#define RK3368_DIV_PCLK_DBG_SHIFT	8
-
-#define RK3368_CLKSEL0(_offs, _aclkm)					\
-	{								\
-		.reg = RK3368_CLKSEL_CON(0 + _offs),			\
-		.val = HIWORD_UPDATE(_aclkm, RK3368_DIV_ACLKM_MASK,	\
-				RK3368_DIV_ACLKM_SHIFT),		\
-	}
-#define RK3368_CLKSEL1(_offs, _atclk, _pdbg)				\
-	{								\
-		.reg = RK3368_CLKSEL_CON(1 + _offs),			\
-		.val = HIWORD_UPDATE(_atclk, RK3368_DIV_ATCLK_MASK,	\
-				RK3368_DIV_ATCLK_SHIFT) |		\
-		       HIWORD_UPDATE(_pdbg, RK3368_DIV_PCLK_DBG_MASK,	\
-				RK3368_DIV_PCLK_DBG_SHIFT),		\
-	}
-
-/* cluster_b: aclkm in clksel0, rest in clksel1 */
-#define RK3368_CPUCLKB_RATE(_prate, _aclkm, _atclk, _pdbg)		\
-	{								\
-		.prate = _prate,					\
-		.divs = {						\
-			RK3368_CLKSEL0(0, _aclkm),			\
-			RK3368_CLKSEL1(0, _atclk, _pdbg),		\
-		},							\
-	}
-
-/* cluster_l: aclkm in clksel2, rest in clksel3 */
-#define RK3368_CPUCLKL_RATE(_prate, _aclkm, _atclk, _pdbg)		\
-	{								\
-		.prate = _prate,					\
-		.divs = {						\
-			RK3368_CLKSEL0(2, _aclkm),			\
-			RK3368_CLKSEL1(2, _atclk, _pdbg),		\
-		},							\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3368_cpuclkb_rates[] __initdata = {
-	RK3368_CPUCLKB_RATE(1512000000, 1, 5, 5),
-	RK3368_CPUCLKB_RATE(1488000000, 1, 4, 4),
-	RK3368_CPUCLKB_RATE(1416000000, 1, 4, 4),
-	RK3368_CPUCLKB_RATE(1200000000, 1, 3, 3),
-	RK3368_CPUCLKB_RATE(1008000000, 1, 3, 3),
-	RK3368_CPUCLKB_RATE( 816000000, 1, 2, 2),
-	RK3368_CPUCLKB_RATE( 696000000, 1, 2, 2),
-	RK3368_CPUCLKB_RATE( 600000000, 1, 1, 1),
-	RK3368_CPUCLKB_RATE( 408000000, 1, 1, 1),
-	RK3368_CPUCLKB_RATE( 312000000, 1, 1, 1),
-};
-
-static struct rockchip_cpuclk_rate_table rk3368_cpuclkl_rates[] __initdata = {
-	RK3368_CPUCLKL_RATE(1512000000, 1, 6, 6),
-	RK3368_CPUCLKL_RATE(1488000000, 1, 5, 5),
-	RK3368_CPUCLKL_RATE(1416000000, 1, 5, 5),
-	RK3368_CPUCLKL_RATE(1200000000, 1, 4, 4),
-	RK3368_CPUCLKL_RATE(1008000000, 1, 4, 4),
-	RK3368_CPUCLKL_RATE( 816000000, 1, 3, 3),
-	RK3368_CPUCLKL_RATE( 696000000, 1, 2, 2),
-	RK3368_CPUCLKL_RATE( 600000000, 1, 2, 2),
-	RK3368_CPUCLKL_RATE( 408000000, 1, 1, 1),
-	RK3368_CPUCLKL_RATE( 312000000, 1, 1, 1),
-};
-
-static struct rockchip_clk_branch rk3368_i2s_8ch_fracmux __initdata =
-	MUX(0, "i2s_8ch_pre", mux_i2s_8ch_pre_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(27), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_spdif_8ch_fracmux __initdata =
-	MUX(0, "spdif_8ch_pre", mux_spdif_8ch_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(31), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_i2s_2ch_fracmux __initdata =
-	MUX(0, "i2s_2ch_pre", mux_i2s_2ch_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(53), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(33), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(35), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_uart3_fracmux __initdata =
-	MUX(SCLK_UART3, "sclk_uart3", mux_uart3_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(39), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_uart4_fracmux __initdata =
-	MUX(SCLK_UART4, "sclk_uart4", mux_uart4_p, CLK_SET_RATE_PARENT,
-	    RK3368_CLKSEL_CON(41), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3368_clk_branches[] __initdata = {
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-	MUX(SCLK_USBPHY480M, "usbphy_480m", mux_usbphy480m_p, CLK_SET_RATE_PARENT,
-			RK3368_CLKSEL_CON(13), 8, 1, MFLAGS),
-
-	GATE(0, "apllb_core", "apllb", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 0, GFLAGS),
-	GATE(0, "gpllb_core", "gpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 1, GFLAGS),
-
-	GATE(0, "aplll_core", "aplll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 4, GFLAGS),
-	GATE(0, "gplll_core", "gpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 5, GFLAGS),
-
-	DIV(0, "aclkm_core_b", "armclkb", 0,
-			RK3368_CLKSEL_CON(0), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY),
-	DIV(0, "atclk_core_b", "armclkb", 0,
-			RK3368_CLKSEL_CON(1), 0, 5, DFLAGS | CLK_DIVIDER_READ_ONLY),
-	DIV(0, "pclk_dbg_b", "armclkb", 0,
-			RK3368_CLKSEL_CON(1), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY),
-
-	DIV(0, "aclkm_core_l", "armclkl", 0,
-			RK3368_CLKSEL_CON(2), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY),
-	DIV(0, "atclk_core_l", "armclkl", 0,
-			RK3368_CLKSEL_CON(3), 0, 5, DFLAGS | CLK_DIVIDER_READ_ONLY),
-	DIV(0, "pclk_dbg_l", "armclkl", 0,
-			RK3368_CLKSEL_CON(3), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY),
-
-	GATE(0, "apllb_cs", "apllb", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 9, GFLAGS),
-	GATE(0, "aplll_cs", "aplll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 10, GFLAGS),
-	GATE(0, "gpll_cs", "gpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(0), 8, GFLAGS),
-	COMPOSITE_NOGATE(0, "sclk_cs_pre", mux_cs_src_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(4), 6, 2, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(0, "clkin_trace", "sclk_cs_pre", CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(4), 8, 5, DFLAGS,
-			RK3368_CLKGATE_CON(0), 13, GFLAGS),
-
-	COMPOSITE(0, "aclk_cci_pre", mux_pll_src_cpll_gpll_usb_npll_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(5), 6, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(0), 12, GFLAGS),
-	GATE(SCLK_PVTM_CORE, "sclk_pvtm_core", "xin24m", 0, RK3368_CLKGATE_CON(7), 10, GFLAGS),
-
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(1), 8, GFLAGS),
-	GATE(0, "gpll_ddr", "gpll", 0,
-			RK3368_CLKGATE_CON(1), 9, GFLAGS),
-	COMPOSITE_NOGATE_DIVTBL(0, "ddrphy_src", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(13), 4, 1, MFLAGS, 0, 2, DFLAGS, div_ddrphy_t),
-
-	FACTOR_GATE(0, "sclk_ddr", "ddrphy_src", CLK_IGNORE_UNUSED, 1, 4,
-			RK3368_CLKGATE_CON(6), 14, GFLAGS),
-	GATE(0, "sclk_ddr4x", "ddrphy_src", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(6), 15, GFLAGS),
-
-	GATE(0, "gpll_aclk_bus", "gpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(1), 10, GFLAGS),
-	GATE(0, "cpll_aclk_bus", "cpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(1), 11, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_bus_src", mux_aclk_bus_src_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(8), 7, 1, MFLAGS, 0, 5, DFLAGS),
-
-	GATE(ACLK_BUS, "aclk_bus", "aclk_bus_src", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(1), 0, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_BUS, "pclk_bus", "aclk_bus_src", CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(8), 12, 3, DFLAGS,
-			RK3368_CLKGATE_CON(1), 2, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_BUS, "hclk_bus", "aclk_bus_src", CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(8), 8, 2, DFLAGS,
-			RK3368_CLKGATE_CON(1), 1, GFLAGS),
-	COMPOSITE_NOMUX(0, "sclk_crypto", "aclk_bus_src", 0,
-			RK3368_CLKSEL_CON(10), 14, 2, DFLAGS,
-			RK3368_CLKGATE_CON(7), 2, GFLAGS),
-
-	COMPOSITE(0, "fclk_mcu_src", mux_pll_src_cpll_gpll_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(12), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(1), 3, GFLAGS),
-	/*
-	 * stclk_mcu is listed as child of fclk_mcu_src in diagram 5,
-	 * but stclk_mcu has an additional own divider in diagram 2
-	 */
-	COMPOSITE_NOMUX(0, "stclk_mcu", "fclk_mcu_src", 0,
-			RK3368_CLKSEL_CON(12), 8, 3, DFLAGS,
-			RK3368_CLKGATE_CON(13), 13, GFLAGS),
-
-	COMPOSITE(0, "i2s_8ch_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(27), 12, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(6), 1, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s_8ch_frac", "i2s_8ch_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(28), 0,
-			  RK3368_CLKGATE_CON(6), 2, GFLAGS,
-			  &rk3368_i2s_8ch_fracmux),
-	COMPOSITE_NODIV(SCLK_I2S_8CH_OUT, "i2s_8ch_clkout", mux_i2s_8ch_clkout_p, 0,
-			RK3368_CLKSEL_CON(27), 15, 1, MFLAGS,
-			RK3368_CLKGATE_CON(6), 0, GFLAGS),
-	GATE(SCLK_I2S_8CH, "sclk_i2s_8ch", "i2s_8ch_pre", CLK_SET_RATE_PARENT,
-			RK3368_CLKGATE_CON(6), 3, GFLAGS),
-	COMPOSITE(0, "spdif_8ch_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(31), 12, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(6), 4, GFLAGS),
-	COMPOSITE_FRACMUX(0, "spdif_8ch_frac", "spdif_8ch_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(32), 0,
-			  RK3368_CLKGATE_CON(6), 5, GFLAGS,
-			  &rk3368_spdif_8ch_fracmux),
-	GATE(SCLK_SPDIF_8CH, "sclk_spdif_8ch", "spdif_8ch_pre", CLK_SET_RATE_PARENT,
-	     RK3368_CLKGATE_CON(6), 6, GFLAGS),
-	COMPOSITE(0, "i2s_2ch_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(53), 12, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(5), 13, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s_2ch_frac", "i2s_2ch_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(54), 0,
-			  RK3368_CLKGATE_CON(5), 14, GFLAGS,
-			  &rk3368_i2s_2ch_fracmux),
-	GATE(SCLK_I2S_2CH, "sclk_i2s_2ch", "i2s_2ch_pre", CLK_SET_RATE_PARENT,
-	     RK3368_CLKGATE_CON(5), 15, GFLAGS),
-
-	COMPOSITE(0, "sclk_tsp", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3368_CLKSEL_CON(46), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(6), 12, GFLAGS),
-	GATE(0, "sclk_hsadc_tsp", "ext_hsadc_tsp", 0,
-			RK3368_CLKGATE_CON(13), 7, GFLAGS),
-
-	MUX(0, "uart_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(35), 12, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "uart2_src", "uart_src", 0,
-			RK3368_CLKSEL_CON(37), 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(2), 4, GFLAGS),
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK3368_CLKSEL_CON(37), 8, 1, MFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-
-	COMPOSITE(0, "aclk_vepu", mux_pll_src_cpll_gpll_npll_usb_p, 0,
-			RK3368_CLKSEL_CON(15), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(4), 6, GFLAGS),
-	COMPOSITE(0, "aclk_vdpu", mux_pll_src_cpll_gpll_npll_usb_p, 0,
-			RK3368_CLKSEL_CON(15), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3368_CLKGATE_CON(4), 7, GFLAGS),
-
-	/*
-	 * We use aclk_vdpu by default ---GRF_SOC_CON0[7] setting in system,
-	 * so we ignore the mux and make clocks nodes as following,
-	 */
-	FACTOR_GATE(0, "hclk_video_pre", "aclk_vdpu", 0, 1, 4,
-		RK3368_CLKGATE_CON(4), 8, GFLAGS),
-
-	COMPOSITE(0, "sclk_hevc_cabac_src", mux_pll_src_cpll_gpll_npll_usb_p, 0,
-			RK3368_CLKSEL_CON(17), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(5), 1, GFLAGS),
-	COMPOSITE(0, "sclk_hevc_core_src", mux_pll_src_cpll_gpll_npll_usb_p, 0,
-			RK3368_CLKSEL_CON(17), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3368_CLKGATE_CON(5), 2, GFLAGS),
-
-	COMPOSITE(0, "aclk_vio0", mux_pll_src_cpll_gpll_usb_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(19), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(4), 0, GFLAGS),
-	DIV(0, "hclk_vio", "aclk_vio0", 0,
-			RK3368_CLKSEL_CON(21), 0, 5, DFLAGS),
-
-	COMPOSITE(0, "aclk_rga_pre", mux_pll_src_cpll_gpll_usb_p, 0,
-			RK3368_CLKSEL_CON(18), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3368_CLKGATE_CON(4), 3, GFLAGS),
-	COMPOSITE(SCLK_RGA, "sclk_rga", mux_pll_src_cpll_gpll_usb_p, 0,
-			RK3368_CLKSEL_CON(18), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(4), 4, GFLAGS),
-
-	COMPOSITE(DCLK_VOP, "dclk_vop", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3368_CLKSEL_CON(20), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3368_CLKGATE_CON(4), 1, GFLAGS),
-
-	GATE(SCLK_VOP0_PWM, "sclk_vop0_pwm", "xin24m", 0,
-			RK3368_CLKGATE_CON(4), 2, GFLAGS),
-
-	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_cpll_gpll_npll_npll_p, 0,
-			RK3368_CLKSEL_CON(22), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3368_CLKGATE_CON(4), 9, GFLAGS),
-
-	GATE(0, "pclk_isp_in", "ext_isp", 0,
-			RK3368_CLKGATE_CON(17), 2, GFLAGS),
-	INVERTER(PCLK_ISP, "pclk_isp", "pclk_isp_in",
-			RK3368_CLKSEL_CON(21), 6, IFLAGS),
-
-	GATE(0, "pclk_vip_in", "ext_vip", 0,
-			RK3368_CLKGATE_CON(16), 13, GFLAGS),
-	INVERTER(PCLK_VIP, "pclk_vip", "pclk_vip_in",
-			RK3368_CLKSEL_CON(21), 13, IFLAGS),
-
-	GATE(SCLK_HDMI_HDCP, "sclk_hdmi_hdcp", "xin24m", 0,
-			RK3368_CLKGATE_CON(4), 13, GFLAGS),
-	GATE(SCLK_HDMI_CEC, "sclk_hdmi_cec", "xin32k", 0,
-			RK3368_CLKGATE_CON(4), 12, GFLAGS),
-
-	COMPOSITE_NODIV(0, "vip_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(21), 15, 1, MFLAGS,
-			RK3368_CLKGATE_CON(4), 5, GFLAGS),
-	COMPOSITE_NOGATE(0, "sclk_vip_out", mux_vip_out_p, 0,
-			RK3368_CLKSEL_CON(21), 14, 1, MFLAGS, 8, 5, DFLAGS),
-
-	COMPOSITE_NODIV(SCLK_EDP_24M, "sclk_edp_24m", mux_edp_24m_p, 0,
-			RK3368_CLKSEL_CON(23), 8, 1, MFLAGS,
-			RK3368_CLKGATE_CON(5), 4, GFLAGS),
-	COMPOSITE(SCLK_EDP, "sclk_edp", mux_pll_src_cpll_gpll_npll_npll_p, 0,
-			RK3368_CLKSEL_CON(23), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3368_CLKGATE_CON(5), 3, GFLAGS),
-
-	COMPOSITE(SCLK_HDCP, "sclk_hdcp", mux_pll_src_cpll_gpll_npll_npll_p, 0,
-			RK3368_CLKSEL_CON(55), 6, 2, MFLAGS, 0, 6, DFLAGS,
-			RK3368_CLKGATE_CON(5), 5, GFLAGS),
-
-	DIV(0, "pclk_pd_alive", "gpll", 0,
-			RK3368_CLKSEL_CON(10), 8, 5, DFLAGS),
-
-	/* sclk_timer has a gate in the sgrf */
-
-	COMPOSITE_NOMUX(0, "pclk_pd_pmu", "gpll", CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(10), 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(7), 9, GFLAGS),
-	GATE(SCLK_PVTM_PMU, "sclk_pvtm_pmu", "xin24m", 0,
-			RK3368_CLKGATE_CON(7), 3, GFLAGS),
-	COMPOSITE(0, "sclk_gpu_core_src", mux_pll_src_cpll_gpll_usb_npll_p, 0,
-			RK3368_CLKSEL_CON(14), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(4), 11, GFLAGS),
-	MUX(0, "aclk_gpu_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(14), 14, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "aclk_gpu_mem_pre", "aclk_gpu_src", 0,
-			RK3368_CLKSEL_CON(14), 8, 5, DFLAGS,
-			RK3368_CLKGATE_CON(5), 8, GFLAGS),
-	COMPOSITE_NOMUX(0, "aclk_gpu_cfg_pre", "aclk_gpu_src", 0,
-			RK3368_CLKSEL_CON(16), 8, 5, DFLAGS,
-			RK3368_CLKGATE_CON(5), 9, GFLAGS),
-	GATE(SCLK_PVTM_GPU, "sclk_pvtm_gpu", "xin24m", 0,
-			RK3368_CLKGATE_CON(7), 11, GFLAGS),
-
-	COMPOSITE(0, "aclk_peri_src", mux_pll_src_cpll_gpll_p, CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(9), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(3), 0, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_src", 0,
-			RK3368_CLKSEL_CON(9), 12, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3368_CLKGATE_CON(3), 3, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERI, "hclk_peri", "aclk_peri_src", CLK_IGNORE_UNUSED,
-			RK3368_CLKSEL_CON(9), 8, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3368_CLKGATE_CON(3), 2, GFLAGS),
-	GATE(ACLK_PERI, "aclk_peri", "aclk_peri_src", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(3), 1, GFLAGS),
-
-	GATE(0, "sclk_mipidsi_24m", "xin24m", 0, RK3368_CLKGATE_CON(4), 14, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 4
-	 */
-
-	COMPOSITE(SCLK_SPI0, "sclk_spi0", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(45), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(3), 7, GFLAGS),
-	COMPOSITE(SCLK_SPI1, "sclk_spi1", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(45), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3368_CLKGATE_CON(3), 8, GFLAGS),
-	COMPOSITE(SCLK_SPI2, "sclk_spi2", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(46), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3368_CLKGATE_CON(3), 9, GFLAGS),
-
-
-	COMPOSITE(SCLK_SDMMC, "sclk_sdmmc", mux_mmc_src_p, 0,
-			RK3368_CLKSEL_CON(50), 8, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(7), 12, GFLAGS),
-	COMPOSITE(SCLK_SDIO0, "sclk_sdio0", mux_mmc_src_p, 0,
-			RK3368_CLKSEL_CON(48), 8, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(7), 13, GFLAGS),
-	COMPOSITE(SCLK_EMMC, "sclk_emmc", mux_mmc_src_p, 0,
-			RK3368_CLKSEL_CON(51), 8, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(7), 15, GFLAGS),
-
-	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RK3368_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3368_SDMMC_CON1, 0),
-
-	MMC(SCLK_SDIO0_DRV,    "sdio0_drv",    "sclk_sdio0", RK3368_SDIO0_CON0, 1),
-	MMC(SCLK_SDIO0_SAMPLE, "sdio0_sample", "sclk_sdio0", RK3368_SDIO0_CON1, 0),
-
-	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RK3368_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3368_EMMC_CON1,  0),
-
-	GATE(SCLK_OTGPHY0, "sclk_otgphy0", "xin24m", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(8), 1, GFLAGS),
-
-	/* pmu_grf_soc_con0[6] allows to select between xin32k and pvtm_pmu */
-	GATE(SCLK_OTG_ADP, "sclk_otg_adp", "xin32k", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(8), 4, GFLAGS),
-
-	/* pmu_grf_soc_con0[6] allows to select between xin32k and pvtm_pmu */
-	COMPOSITE_NOMUX(SCLK_TSADC, "sclk_tsadc", "xin32k", 0,
-			RK3368_CLKSEL_CON(25), 0, 6, DFLAGS,
-			RK3368_CLKGATE_CON(3), 5, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_SARADC, "sclk_saradc", "xin24m", 0,
-			RK3368_CLKSEL_CON(25), 8, 8, DFLAGS,
-			RK3368_CLKGATE_CON(3), 6, GFLAGS),
-
-	COMPOSITE(SCLK_NANDC0, "sclk_nandc0", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(47), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(7), 8, GFLAGS),
-
-	COMPOSITE(SCLK_SFC, "sclk_sfc", mux_pll_src_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(52), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(6), 7, GFLAGS),
-
-	COMPOSITE(0, "uart0_src", mux_pll_src_cpll_gpll_usb_usb_p, 0,
-			RK3368_CLKSEL_CON(33), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(34), 0,
-			  RK3368_CLKGATE_CON(2), 1, GFLAGS,
-			  &rk3368_uart0_fracmux),
-
-	COMPOSITE_NOMUX(0, "uart1_src", "uart_src", 0,
-			RK3368_CLKSEL_CON(35), 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(2), 2, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(36), 0,
-			  RK3368_CLKGATE_CON(2), 3, GFLAGS,
-			  &rk3368_uart1_fracmux),
-
-	COMPOSITE_NOMUX(0, "uart3_src", "uart_src", 0,
-			RK3368_CLKSEL_CON(39), 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(2), 6, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart3_frac", "uart3_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(40), 0,
-			  RK3368_CLKGATE_CON(2), 7, GFLAGS,
-			  &rk3368_uart3_fracmux),
-
-	COMPOSITE_NOMUX(0, "uart4_src", "uart_src", 0,
-			RK3368_CLKSEL_CON(41), 0, 7, DFLAGS,
-			RK3368_CLKGATE_CON(2), 8, GFLAGS),
-	COMPOSITE_FRACMUX(0, "uart4_frac", "uart4_src", CLK_SET_RATE_PARENT,
-			  RK3368_CLKSEL_CON(42), 0,
-			  RK3368_CLKGATE_CON(2), 9, GFLAGS,
-			  &rk3368_uart4_fracmux),
-
-	COMPOSITE(0, "mac_pll_src", mux_pll_src_npll_cpll_gpll_p, 0,
-			RK3368_CLKSEL_CON(43), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3368_CLKGATE_CON(3), 4, GFLAGS),
-	MUX(SCLK_MAC, "mac_clk", mux_mac_p, CLK_SET_RATE_PARENT,
-			RK3368_CLKSEL_CON(43), 8, 1, MFLAGS),
-	GATE(SCLK_MACREF_OUT, "sclk_macref_out", "mac_clk", 0,
-			RK3368_CLKGATE_CON(7), 7, GFLAGS),
-	GATE(SCLK_MACREF, "sclk_macref", "mac_clk", 0,
-			RK3368_CLKGATE_CON(7), 6, GFLAGS),
-	GATE(SCLK_MAC_RX, "sclk_mac_rx", "mac_clk", 0,
-			RK3368_CLKGATE_CON(7), 4, GFLAGS),
-	GATE(SCLK_MAC_TX, "sclk_mac_tx", "mac_clk", 0,
-			RK3368_CLKGATE_CON(7), 5, GFLAGS),
-
-	GATE(0, "jtag", "ext_jtag", CLK_IGNORE_UNUSED,
-			RK3368_CLKGATE_CON(7), 0, GFLAGS),
-
-	COMPOSITE_NODIV(0, "hsic_usbphy_480m", mux_hsic_usbphy480m_p, 0,
-			RK3368_CLKSEL_CON(26), 8, 2, MFLAGS,
-			RK3368_CLKGATE_CON(8), 0, GFLAGS),
-	COMPOSITE_NODIV(SCLK_HSICPHY480M, "sclk_hsicphy480m", mux_hsicphy480m_p, 0,
-			RK3368_CLKSEL_CON(26), 12, 2, MFLAGS,
-			RK3368_CLKGATE_CON(8), 7, GFLAGS),
-	GATE(SCLK_HSICPHY12M, "sclk_hsicphy12m", "xin12m", 0,
-			RK3368_CLKGATE_CON(8), 6, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 5
-	 */
-
-	/* aclk_cci_pre gates */
-	GATE(0, "aclk_core_niu_cpup", "aclk_cci_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 4, GFLAGS),
-	GATE(0, "aclk_core_niu_cci", "aclk_cci_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 3, GFLAGS),
-	GATE(0, "aclk_cci400", "aclk_cci_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 2, GFLAGS),
-	GATE(0, "aclk_adb400m_pd_core_b", "aclk_cci_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 1, GFLAGS),
-	GATE(0, "aclk_adb400m_pd_core_l", "aclk_cci_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 0, GFLAGS),
-
-	/* aclkm_core_* gates */
-	GATE(0, "aclk_adb400s_pd_core_b", "aclkm_core_b", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(10), 0, GFLAGS),
-	GATE(0, "aclk_adb400s_pd_core_l", "aclkm_core_l", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(9), 0, GFLAGS),
-
-	/* armclk* gates */
-	GATE(0, "sclk_dbg_pd_core_b", "armclkb", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(10), 1, GFLAGS),
-	GATE(0, "sclk_dbg_pd_core_l", "armclkl", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(9), 1, GFLAGS),
-
-	/* sclk_cs_pre gates */
-	GATE(0, "sclk_dbg", "sclk_cs_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 7, GFLAGS),
-	GATE(0, "pclk_core_niu_sdbg", "sclk_cs_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 6, GFLAGS),
-	GATE(0, "hclk_core_niu_dbg", "sclk_cs_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(11), 5, GFLAGS),
-
-	/* aclk_bus gates */
-	GATE(0, "aclk_strc_sys", "aclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(12), 12, GFLAGS),
-	GATE(ACLK_DMAC_BUS, "aclk_dmac_bus", "aclk_bus", 0, RK3368_CLKGATE_CON(12), 11, GFLAGS),
-	GATE(0, "sclk_intmem1", "aclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(12), 6, GFLAGS),
-	GATE(0, "sclk_intmem0", "aclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(12), 5, GFLAGS),
-	GATE(0, "aclk_intmem", "aclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(12), 4, GFLAGS),
-	GATE(0, "aclk_gic400", "aclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(13), 9, GFLAGS),
-
-	/* sclk_ddr gates */
-	GATE(0, "nclk_ddrupctl", "sclk_ddr", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(13), 2, GFLAGS),
-
-	/* clk_hsadc_tsp is part of diagram2 */
-
-	/* fclk_mcu_src gates */
-	GATE(0, "hclk_noc_mcu", "fclk_mcu_src", 0, RK3368_CLKGATE_CON(13), 14, GFLAGS),
-	GATE(0, "fclk_mcu", "fclk_mcu_src", 0, RK3368_CLKGATE_CON(13), 12, GFLAGS),
-	GATE(0, "hclk_mcu", "fclk_mcu_src", 0, RK3368_CLKGATE_CON(13), 11, GFLAGS),
-
-	/* hclk_cpu gates */
-	GATE(HCLK_SPDIF, "hclk_spdif", "hclk_bus", 0, RK3368_CLKGATE_CON(12), 10, GFLAGS),
-	GATE(HCLK_ROM, "hclk_rom", "hclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(12), 9, GFLAGS),
-	GATE(HCLK_I2S_2CH, "hclk_i2s_2ch", "hclk_bus", 0, RK3368_CLKGATE_CON(12), 8, GFLAGS),
-	GATE(HCLK_I2S_8CH, "hclk_i2s_8ch", "hclk_bus", 0, RK3368_CLKGATE_CON(12), 7, GFLAGS),
-	GATE(HCLK_TSP, "hclk_tsp", "hclk_bus", 0, RK3368_CLKGATE_CON(13), 10, GFLAGS),
-	GATE(HCLK_CRYPTO, "hclk_crypto", "hclk_bus", 0, RK3368_CLKGATE_CON(13), 4, GFLAGS),
-	GATE(MCLK_CRYPTO, "mclk_crypto", "hclk_bus", 0, RK3368_CLKGATE_CON(13), 3, GFLAGS),
-
-	/* pclk_cpu gates */
-	GATE(PCLK_DDRPHY, "pclk_ddrphy", "pclk_bus", 0, RK3368_CLKGATE_CON(12), 14, GFLAGS),
-	GATE(PCLK_DDRUPCTL, "pclk_ddrupctl", "pclk_bus", 0, RK3368_CLKGATE_CON(12), 13, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_bus", 0, RK3368_CLKGATE_CON(12), 3, GFLAGS),
-	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_bus", 0, RK3368_CLKGATE_CON(12), 2, GFLAGS),
-	GATE(PCLK_MAILBOX, "pclk_mailbox", "pclk_bus", 0, RK3368_CLKGATE_CON(12), 1, GFLAGS),
-	GATE(PCLK_PWM0, "pclk_pwm0", "pclk_bus", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(12), 0, GFLAGS),
-	GATE(PCLK_SIM, "pclk_sim", "pclk_bus", 0, RK3368_CLKGATE_CON(13), 8, GFLAGS),
-	GATE(PCLK_PWM1, "pclk_pwm1", "pclk_bus", 0, RK3368_CLKGATE_CON(13), 6, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_bus", 0, RK3368_CLKGATE_CON(13), 5, GFLAGS),
-	GATE(PCLK_EFUSE256, "pclk_efuse_256", "pclk_bus", 0, RK3368_CLKGATE_CON(13), 1, GFLAGS),
-	GATE(0, "pclk_efuse_1024", "pclk_bus", 0, RK3368_CLKGATE_CON(13), 0, GFLAGS),
-
-	/*
-	 * video clk gates
-	 * aclk_video(_pre) can actually select between parents of aclk_vdpu
-	 * and aclk_vepu by setting bit GRF_SOC_CON0[7].
-	 */
-	GATE(ACLK_VIDEO, "aclk_video", "aclk_vdpu", 0, RK3368_CLKGATE_CON(15), 0, GFLAGS),
-	GATE(SCLK_HEVC_CABAC, "sclk_hevc_cabac", "sclk_hevc_cabac_src", 0, RK3368_CLKGATE_CON(15), 3, GFLAGS),
-	GATE(SCLK_HEVC_CORE, "sclk_hevc_core", "sclk_hevc_core_src", 0, RK3368_CLKGATE_CON(15), 2, GFLAGS),
-	GATE(HCLK_VIDEO, "hclk_video", "hclk_video_pre", 0, RK3368_CLKGATE_CON(15), 1, GFLAGS),
-
-	/* aclk_rga_pre gates */
-	GATE(ACLK_VIO1_NOC, "aclk_vio1_noc", "aclk_rga_pre", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(16), 10, GFLAGS),
-	GATE(ACLK_RGA, "aclk_rga", "aclk_rga_pre", 0, RK3368_CLKGATE_CON(16), 0, GFLAGS),
-	GATE(ACLK_HDCP, "aclk_hdcp", "aclk_rga_pre", 0, RK3368_CLKGATE_CON(17), 10, GFLAGS),
-
-	/* aclk_vio0 gates */
-	GATE(ACLK_VIP, "aclk_vip", "aclk_vio0", 0, RK3368_CLKGATE_CON(16), 11, GFLAGS),
-	GATE(ACLK_VIO0_NOC, "aclk_vio0_noc", "aclk_vio0", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(16), 9, GFLAGS),
-	GATE(ACLK_VOP, "aclk_vop", "aclk_vio0", 0, RK3368_CLKGATE_CON(16), 5, GFLAGS),
-	GATE(ACLK_VOP_IEP, "aclk_vop_iep", "aclk_vio0", 0, RK3368_CLKGATE_CON(16), 4, GFLAGS),
-	GATE(ACLK_IEP, "aclk_iep", "aclk_vio0", 0, RK3368_CLKGATE_CON(16), 2, GFLAGS),
-
-	/* sclk_isp gates */
-	GATE(HCLK_ISP, "hclk_isp", "sclk_isp", 0, RK3368_CLKGATE_CON(16), 14, GFLAGS),
-	GATE(ACLK_ISP, "aclk_isp", "sclk_isp", 0, RK3368_CLKGATE_CON(17), 0, GFLAGS),
-
-	/* hclk_vio gates */
-	GATE(HCLK_VIP, "hclk_vip", "hclk_vio", 0, RK3368_CLKGATE_CON(16), 12, GFLAGS),
-	GATE(HCLK_VIO_NOC, "hclk_vio_noc", "hclk_vio", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(16), 8, GFLAGS),
-	GATE(HCLK_VIO_AHB_ARBI, "hclk_vio_ahb_arbi", "hclk_vio", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(16), 7, GFLAGS),
-	GATE(HCLK_VOP, "hclk_vop", "hclk_vio", 0, RK3368_CLKGATE_CON(16), 6, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_vio", 0, RK3368_CLKGATE_CON(16), 3, GFLAGS),
-	GATE(HCLK_RGA, "hclk_rga", "hclk_vio", 0, RK3368_CLKGATE_CON(16), 1, GFLAGS),
-	GATE(HCLK_VIO_HDCPMMU, "hclk_hdcpmmu", "hclk_vio", 0, RK3368_CLKGATE_CON(17), 12, GFLAGS),
-	GATE(HCLK_VIO_H2P, "hclk_vio_h2p", "hclk_vio", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(17), 7, GFLAGS),
-
-	/*
-	 * pclk_vio gates
-	 * pclk_vio comes from the exactly same source as hclk_vio
-	 */
-	GATE(PCLK_HDCP, "pclk_hdcp", "hclk_vio", 0, RK3368_CLKGATE_CON(17), 11, GFLAGS),
-	GATE(PCLK_EDP_CTRL, "pclk_edp_ctrl", "hclk_vio", 0, RK3368_CLKGATE_CON(17), 9, GFLAGS),
-	GATE(PCLK_VIO_H2P, "pclk_vio_h2p", "hclk_vio", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(17), 8, GFLAGS),
-	GATE(PCLK_HDMI_CTRL, "pclk_hdmi_ctrl", "hclk_vio", 0, RK3368_CLKGATE_CON(17), 6, GFLAGS),
-	GATE(PCLK_MIPI_CSI, "pclk_mipi_csi", "hclk_vio", 0, RK3368_CLKGATE_CON(17), 4, GFLAGS),
-	GATE(PCLK_MIPI_DSI0, "pclk_mipi_dsi0", "hclk_vio", 0, RK3368_CLKGATE_CON(17), 3, GFLAGS),
-
-	/* ext_vip gates in diagram3 */
-
-	/* gpu gates */
-	GATE(SCLK_GPU_CORE, "sclk_gpu_core", "sclk_gpu_core_src", 0, RK3368_CLKGATE_CON(18), 2, GFLAGS),
-	GATE(ACLK_GPU_MEM, "aclk_gpu_mem", "aclk_gpu_mem_pre", 0, RK3368_CLKGATE_CON(18), 1, GFLAGS),
-	GATE(ACLK_GPU_CFG, "aclk_gpu_cfg", "aclk_gpu_cfg_pre", 0, RK3368_CLKGATE_CON(18), 0, GFLAGS),
-
-	/* aclk_peri gates */
-	GATE(ACLK_DMAC_PERI, "aclk_dmac_peri", "aclk_peri", 0, RK3368_CLKGATE_CON(19), 3, GFLAGS),
-	GATE(0, "aclk_peri_axi_matrix", "aclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(19), 2, GFLAGS),
-	GATE(HCLK_SFC, "hclk_sfc", "aclk_peri", 0, RK3368_CLKGATE_CON(20), 15, GFLAGS),
-	GATE(ACLK_GMAC, "aclk_gmac", "aclk_peri", 0, RK3368_CLKGATE_CON(20), 13, GFLAGS),
-	GATE(0, "aclk_peri_niu", "aclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 8, GFLAGS),
-	GATE(ACLK_PERI_MMU, "aclk_peri_mmu", "aclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(21), 4, GFLAGS),
-
-	/* hclk_peri gates */
-	GATE(0, "hclk_peri_axi_matrix", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(19), 0, GFLAGS),
-	GATE(HCLK_NANDC0, "hclk_nandc0", "hclk_peri", 0, RK3368_CLKGATE_CON(20), 11, GFLAGS),
-	GATE(0, "hclk_mmc_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 10, GFLAGS),
-	GATE(0, "hclk_emem_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 9, GFLAGS),
-	GATE(0, "hclk_peri_ahb_arbi", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 7, GFLAGS),
-	GATE(0, "hclk_usb_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 6, GFLAGS),
-	GATE(HCLK_HSIC, "hclk_hsic", "hclk_peri", 0, RK3368_CLKGATE_CON(20), 5, GFLAGS),
-	GATE(HCLK_HOST1, "hclk_host1", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 4, GFLAGS),
-	GATE(HCLK_HOST0, "hclk_host0", "hclk_peri", 0, RK3368_CLKGATE_CON(20), 3, GFLAGS),
-	GATE(0, "pmu_hclk_otg0", "hclk_peri", 0, RK3368_CLKGATE_CON(20), 2, GFLAGS),
-	GATE(HCLK_OTG0, "hclk_otg0", "hclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(20), 1, GFLAGS),
-	GATE(HCLK_HSADC, "hclk_hsadc", "hclk_peri", 0, RK3368_CLKGATE_CON(21), 3, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri", 0, RK3368_CLKGATE_CON(21), 2, GFLAGS),
-	GATE(HCLK_SDIO0, "hclk_sdio0", "hclk_peri", 0, RK3368_CLKGATE_CON(21), 1, GFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_peri", 0, RK3368_CLKGATE_CON(21), 0, GFLAGS),
-
-	/* pclk_peri gates */
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 15, GFLAGS),
-	GATE(PCLK_I2C5, "pclk_i2c5", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 14, GFLAGS),
-	GATE(PCLK_I2C4, "pclk_i2c4", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 13, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 12, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 11, GFLAGS),
-	GATE(PCLK_UART4, "pclk_uart4", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 10, GFLAGS),
-	GATE(PCLK_UART3, "pclk_uart3", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 9, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 8, GFLAGS),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 7, GFLAGS),
-	GATE(PCLK_SPI2, "pclk_spi2", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 6, GFLAGS),
-	GATE(PCLK_SPI1, "pclk_spi1", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 5, GFLAGS),
-	GATE(PCLK_SPI0, "pclk_spi0", "pclk_peri", 0, RK3368_CLKGATE_CON(19), 4, GFLAGS),
-	GATE(0, "pclk_peri_axi_matrix", "pclk_peri", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(19), 1, GFLAGS),
-	GATE(PCLK_GMAC, "pclk_gmac", "pclk_peri", 0, RK3368_CLKGATE_CON(20), 14, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_peri", 0, RK3368_CLKGATE_CON(20), 0, GFLAGS),
-
-	/* pclk_pd_alive gates */
-	GATE(PCLK_TIMER1, "pclk_timer1", "pclk_pd_alive", 0, RK3368_CLKGATE_CON(22), 13, GFLAGS),
-	GATE(PCLK_TIMER0, "pclk_timer0", "pclk_pd_alive", 0, RK3368_CLKGATE_CON(22), 12, GFLAGS),
-	GATE(0, "pclk_alive_niu", "pclk_pd_alive", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(22), 9, GFLAGS),
-	GATE(PCLK_GRF, "pclk_grf", "pclk_pd_alive", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(22), 8, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_pd_alive", 0, RK3368_CLKGATE_CON(22), 3, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_pd_alive", 0, RK3368_CLKGATE_CON(22), 2, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_pd_alive", 0, RK3368_CLKGATE_CON(22), 1, GFLAGS),
-
-	/*
-	 * pclk_vio gates
-	 * pclk_vio comes from the exactly same source as hclk_vio
-	 */
-	GATE(0, "pclk_dphyrx", "hclk_vio", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(14), 8, GFLAGS),
-	GATE(0, "pclk_dphytx", "hclk_vio", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(14), 8, GFLAGS),
-
-	/* pclk_pd_pmu gates */
-	GATE(PCLK_PMUGRF, "pclk_pmugrf", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(23), 5, GFLAGS),
-	GATE(PCLK_GPIO0, "pclk_gpio0", "pclk_pd_pmu", 0, RK3368_CLKGATE_CON(23), 4, GFLAGS),
-	GATE(PCLK_SGRF, "pclk_sgrf", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(23), 3, GFLAGS),
-	GATE(0, "pclk_pmu_noc", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(23), 2, GFLAGS),
-	GATE(0, "pclk_intmem1", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(23), 1, GFLAGS),
-	GATE(PCLK_PMU, "pclk_pmu", "pclk_pd_pmu", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(23), 0, GFLAGS),
-
-	/* timer gates */
-	GATE(SCLK_TIMER15, "sclk_timer15", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 11, GFLAGS),
-	GATE(SCLK_TIMER14, "sclk_timer14", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 10, GFLAGS),
-	GATE(SCLK_TIMER13, "sclk_timer13", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 9, GFLAGS),
-	GATE(SCLK_TIMER12, "sclk_timer12", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 8, GFLAGS),
-	GATE(SCLK_TIMER11, "sclk_timer11", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 7, GFLAGS),
-	GATE(SCLK_TIMER10, "sclk_timer10", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 6, GFLAGS),
-	GATE(SCLK_TIMER05, "sclk_timer05", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 5, GFLAGS),
-	GATE(SCLK_TIMER04, "sclk_timer04", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 4, GFLAGS),
-	GATE(SCLK_TIMER03, "sclk_timer03", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 3, GFLAGS),
-	GATE(SCLK_TIMER02, "sclk_timer02", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 2, GFLAGS),
-	GATE(SCLK_TIMER01, "sclk_timer01", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 1, GFLAGS),
-	GATE(SCLK_TIMER00, "sclk_timer00", "xin24m", CLK_IGNORE_UNUSED, RK3368_CLKGATE_CON(24), 0, GFLAGS),
-};
-
-static const char *const rk3368_critical_clocks[] __initconst = {
-	"aclk_bus",
-	"aclk_peri",
-	/*
-	 * pwm1 supplies vdd_logic on a lot of boards, is currently unhandled
-	 * but needs to stay enabled there (including its parents) at all times.
-	 */
-	"pclk_pwm1",
-	"pclk_pd_pmu",
-	"pclk_pd_alive",
-	"pclk_peri",
-	"hclk_peri",
-	"pclk_ddrphy",
-	"pclk_ddrupctl",
-	"pmu_hclk_otg0",
-};
-
-static void __init rk3368_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-	struct clk *clk;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	/* Watchdog pclk is controlled by sgrf_soc_con3[7]. */
-	clk = clk_register_fixed_factor(NULL, "pclk_wdt", "pclk_pd_alive", 0, 1, 1);
-	if (IS_ERR(clk))
-		pr_warn("%s: could not register clock pclk_wdt: %ld\n",
-			__func__, PTR_ERR(clk));
-	else
-		rockchip_clk_add_lookup(ctx, clk, PCLK_WDT);
-
-	rockchip_clk_register_plls(ctx, rk3368_pll_clks,
-				   ARRAY_SIZE(rk3368_pll_clks),
-				   RK3368_GRF_SOC_STATUS0);
-	rockchip_clk_register_branches(ctx, rk3368_clk_branches,
-				  ARRAY_SIZE(rk3368_clk_branches));
-	rockchip_clk_protect_critical(rk3368_critical_clocks,
-				      ARRAY_SIZE(rk3368_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLKB, "armclkb",
-			mux_armclkb_p, ARRAY_SIZE(mux_armclkb_p),
-			&rk3368_cpuclkb_data, rk3368_cpuclkb_rates,
-			ARRAY_SIZE(rk3368_cpuclkb_rates));
-
-	rockchip_clk_register_armclk(ctx, ARMCLKL, "armclkl",
-			mux_armclkl_p, ARRAY_SIZE(mux_armclkl_p),
-			&rk3368_cpuclkl_data, rk3368_cpuclkl_rates,
-			ARRAY_SIZE(rk3368_cpuclkl_rates));
-
-	rockchip_register_softrst(np, 15, reg_base + RK3368_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK3368_GLB_SRST_FST, NULL);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3368_cru, "rockchip,rk3368-cru", rk3368_clk_init);
diff --git a/drivers/clk/rockchip/clk-rk3399.c b/drivers/clk/rockchip/clk-rk3399.c
deleted file mode 100644
index 5a628148f..000000000
--- a/drivers/clk/rockchip/clk-rk3399.c
+++ /dev/null
@@ -1,1616 +0,0 @@
-/*
- * Copyright (c) 2016 Rockchip Electronics Co. Ltd.
- * Author: Xing Zheng <zhengxing@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/regmap.h>
-#include <dt-bindings/clock/rk3399-cru.h>
-#include "clk.h"
-
-enum rk3399_plls {
-	lpll, bpll, dpll, cpll, gpll, npll, vpll,
-};
-
-enum rk3399_pmu_plls {
-	ppll,
-};
-
-static struct rockchip_pll_rate_table rk3399_pll_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(2208000000, 1, 92, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2184000000, 1, 91, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2160000000, 1, 90, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2136000000, 1, 89, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2112000000, 1, 88, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2088000000, 1, 87, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2064000000, 1, 86, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2040000000, 1, 85, 1, 1, 1, 0),
-	RK3036_PLL_RATE(2016000000, 1, 84, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1992000000, 1, 83, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1968000000, 1, 82, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1944000000, 1, 81, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1920000000, 1, 80, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1896000000, 1, 79, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1872000000, 1, 78, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1848000000, 1, 77, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1824000000, 1, 76, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1800000000, 1, 75, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1776000000, 1, 74, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1752000000, 1, 73, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1728000000, 1, 72, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1704000000, 1, 71, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1680000000, 1, 70, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1656000000, 1, 69, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1632000000, 1, 68, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1600000000, 3, 200, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1584000000, 1, 66, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1560000000, 1, 65, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1536000000, 1, 64, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1488000000, 1, 62, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1464000000, 1, 61, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1440000000, 1, 60, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1392000000, 1, 58, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1368000000, 1, 57, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1344000000, 1, 56, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1320000000, 1, 55, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1272000000, 1, 53, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1248000000, 1, 52, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1188000000, 2, 99, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1104000000, 1, 46, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1100000000, 12, 550, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
-	RK3036_PLL_RATE(1000000000, 1, 125, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 984000000, 1, 82, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 960000000, 1, 80, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 936000000, 1, 78, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 912000000, 1, 76, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 900000000, 4, 300, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 888000000, 1, 74, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 864000000, 1, 72, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 840000000, 1, 70, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 816000000, 1, 68, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 800000000, 1, 100, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 700000000, 6, 350, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 696000000, 1, 58, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 676000000, 3, 169, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 600000000, 1, 75, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 594000000, 1, 99, 4, 1, 1, 0),
-	RK3036_PLL_RATE( 533250000, 8, 711, 4, 1, 1, 0),
-	RK3036_PLL_RATE( 504000000, 1, 63, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 500000000, 6, 250, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 408000000, 1, 68, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 312000000, 1, 52, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 297000000, 1, 99, 4, 2, 1, 0),
-	RK3036_PLL_RATE( 216000000, 1, 72, 4, 2, 1, 0),
-	RK3036_PLL_RATE( 148500000, 1, 99, 4, 4, 1, 0),
-	RK3036_PLL_RATE( 106500000, 1, 71, 4, 4, 1, 0),
-	RK3036_PLL_RATE(  96000000, 1, 64, 4, 4, 1, 0),
-	RK3036_PLL_RATE(  74250000, 2, 99, 4, 4, 1, 0),
-	RK3036_PLL_RATE(  65000000, 1, 65, 6, 4, 1, 0),
-	RK3036_PLL_RATE(  54000000, 1, 54, 6, 4, 1, 0),
-	RK3036_PLL_RATE(  27000000, 1, 27, 6, 4, 1, 0),
-	{ /* sentinel */ },
-};
-
-/* CRU parents */
-PNAME(mux_pll_p)				= { "xin24m", "xin32k" };
-
-PNAME(mux_armclkl_p)				= { "clk_core_l_lpll_src",
-						    "clk_core_l_bpll_src",
-						    "clk_core_l_dpll_src",
-						    "clk_core_l_gpll_src" };
-PNAME(mux_armclkb_p)				= { "clk_core_b_lpll_src",
-						    "clk_core_b_bpll_src",
-						    "clk_core_b_dpll_src",
-						    "clk_core_b_gpll_src" };
-PNAME(mux_ddrclk_p)				= { "clk_ddrc_lpll_src",
-						    "clk_ddrc_bpll_src",
-						    "clk_ddrc_dpll_src",
-						    "clk_ddrc_gpll_src" };
-PNAME(mux_aclk_cci_p)				= { "cpll_aclk_cci_src",
-						    "gpll_aclk_cci_src",
-						    "npll_aclk_cci_src",
-						    "vpll_aclk_cci_src" };
-PNAME(mux_cci_trace_p)				= { "cpll_cci_trace",
-						    "gpll_cci_trace" };
-PNAME(mux_cs_p)					= { "cpll_cs", "gpll_cs",
-						    "npll_cs"};
-PNAME(mux_aclk_perihp_p)			= { "cpll_aclk_perihp_src",
-						    "gpll_aclk_perihp_src" };
-
-PNAME(mux_pll_src_cpll_gpll_p)			= { "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_npll_p)		= { "cpll", "gpll", "npll" };
-PNAME(mux_pll_src_cpll_gpll_ppll_p)		= { "cpll", "gpll", "ppll" };
-PNAME(mux_pll_src_cpll_gpll_upll_p)		= { "cpll", "gpll", "upll" };
-PNAME(mux_pll_src_npll_cpll_gpll_p)		= { "npll", "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_npll_ppll_p)	= { "cpll", "gpll", "npll",
-						    "ppll" };
-PNAME(mux_pll_src_cpll_gpll_npll_24m_p)		= { "cpll", "gpll", "npll",
-						    "xin24m" };
-PNAME(mux_pll_src_cpll_gpll_npll_usbphy480m_p)	= { "cpll", "gpll", "npll",
-						    "clk_usbphy_480m" };
-PNAME(mux_pll_src_ppll_cpll_gpll_npll_p)	= { "ppll", "cpll", "gpll",
-						    "npll", "upll" };
-PNAME(mux_pll_src_cpll_gpll_npll_upll_24m_p)	= { "cpll", "gpll", "npll",
-						    "upll", "xin24m" };
-PNAME(mux_pll_src_cpll_gpll_npll_ppll_upll_24m_p) = { "cpll", "gpll", "npll",
-						    "ppll", "upll", "xin24m" };
-
-PNAME(mux_pll_src_vpll_cpll_gpll_p)		= { "vpll", "cpll", "gpll" };
-PNAME(mux_pll_src_vpll_cpll_gpll_npll_p)	= { "vpll", "cpll", "gpll",
-						    "npll" };
-PNAME(mux_pll_src_vpll_cpll_gpll_24m_p)		= { "vpll", "cpll", "gpll",
-						    "xin24m" };
-
-PNAME(mux_dclk_vop0_p)			= { "dclk_vop0_div",
-					    "dclk_vop0_frac" };
-PNAME(mux_dclk_vop1_p)			= { "dclk_vop1_div",
-					    "dclk_vop1_frac" };
-
-PNAME(mux_clk_cif_p)			= { "clk_cifout_src", "xin24m" };
-
-PNAME(mux_pll_src_24m_usbphy480m_p)	= { "xin24m", "clk_usbphy_480m" };
-PNAME(mux_pll_src_24m_pciephy_p)	= { "xin24m", "clk_pciephy_ref100m" };
-PNAME(mux_pll_src_24m_32k_cpll_gpll_p)	= { "xin24m", "xin32k",
-					    "cpll", "gpll" };
-PNAME(mux_pciecore_cru_phy_p)		= { "clk_pcie_core_cru",
-					    "clk_pcie_core_phy" };
-
-PNAME(mux_aclk_emmc_p)			= { "cpll_aclk_emmc_src",
-					    "gpll_aclk_emmc_src" };
-
-PNAME(mux_aclk_perilp0_p)		= { "cpll_aclk_perilp0_src",
-					    "gpll_aclk_perilp0_src" };
-
-PNAME(mux_fclk_cm0s_p)			= { "cpll_fclk_cm0s_src",
-					    "gpll_fclk_cm0s_src" };
-
-PNAME(mux_hclk_perilp1_p)		= { "cpll_hclk_perilp1_src",
-					    "gpll_hclk_perilp1_src" };
-
-PNAME(mux_clk_testout1_p)		= { "clk_testout1_pll_src", "xin24m" };
-PNAME(mux_clk_testout2_p)		= { "clk_testout2_pll_src", "xin24m" };
-
-PNAME(mux_usbphy_480m_p)		= { "clk_usbphy0_480m_src",
-					    "clk_usbphy1_480m_src" };
-PNAME(mux_aclk_gmac_p)			= { "cpll_aclk_gmac_src",
-					    "gpll_aclk_gmac_src" };
-PNAME(mux_rmii_p)			= { "clk_gmac", "clkin_gmac" };
-PNAME(mux_spdif_p)			= { "clk_spdif_div", "clk_spdif_frac",
-					    "clkin_i2s", "xin12m" };
-PNAME(mux_i2s0_p)			= { "clk_i2s0_div", "clk_i2s0_frac",
-					    "clkin_i2s", "xin12m" };
-PNAME(mux_i2s1_p)			= { "clk_i2s1_div", "clk_i2s1_frac",
-					    "clkin_i2s", "xin12m" };
-PNAME(mux_i2s2_p)			= { "clk_i2s2_div", "clk_i2s2_frac",
-					    "clkin_i2s", "xin12m" };
-PNAME(mux_i2sch_p)			= { "clk_i2s0", "clk_i2s1",
-					    "clk_i2s2" };
-PNAME(mux_i2sout_p)			= { "clk_i2sout_src", "xin12m" };
-
-PNAME(mux_uart0_p)	= { "clk_uart0_div", "clk_uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)	= { "clk_uart1_div", "clk_uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)	= { "clk_uart2_div", "clk_uart2_frac", "xin24m" };
-PNAME(mux_uart3_p)	= { "clk_uart3_div", "clk_uart3_frac", "xin24m" };
-
-/* PMU CRU parents */
-PNAME(mux_ppll_24m_p)		= { "ppll", "xin24m" };
-PNAME(mux_24m_ppll_p)		= { "xin24m", "ppll" };
-PNAME(mux_fclk_cm0s_pmu_ppll_p)	= { "fclk_cm0s_pmu_ppll_src", "xin24m" };
-PNAME(mux_wifi_pmu_p)		= { "clk_wifi_div", "clk_wifi_frac" };
-PNAME(mux_uart4_pmu_p)		= { "clk_uart4_div", "clk_uart4_frac",
-				    "xin24m" };
-PNAME(mux_clk_testout2_2io_p)	= { "clk_testout2", "clk_32k_suspend_pmu" };
-
-static struct rockchip_pll_clock rk3399_pll_clks[] __initdata = {
-	[lpll] = PLL(pll_rk3399, PLL_APLLL, "lpll", mux_pll_p, 0, RK3399_PLL_CON(0),
-		     RK3399_PLL_CON(3), 8, 31, 0, rk3399_pll_rates),
-	[bpll] = PLL(pll_rk3399, PLL_APLLB, "bpll", mux_pll_p, 0, RK3399_PLL_CON(8),
-		     RK3399_PLL_CON(11), 8, 31, 0, rk3399_pll_rates),
-	[dpll] = PLL(pll_rk3399, PLL_DPLL, "dpll", mux_pll_p, 0, RK3399_PLL_CON(16),
-		     RK3399_PLL_CON(19), 8, 31, 0, NULL),
-	[cpll] = PLL(pll_rk3399, PLL_CPLL, "cpll", mux_pll_p, 0, RK3399_PLL_CON(24),
-		     RK3399_PLL_CON(27), 8, 31, ROCKCHIP_PLL_SYNC_RATE, rk3399_pll_rates),
-	[gpll] = PLL(pll_rk3399, PLL_GPLL, "gpll", mux_pll_p, 0, RK3399_PLL_CON(32),
-		     RK3399_PLL_CON(35), 8, 31, ROCKCHIP_PLL_SYNC_RATE, rk3399_pll_rates),
-	[npll] = PLL(pll_rk3399, PLL_NPLL, "npll",  mux_pll_p, 0, RK3399_PLL_CON(40),
-		     RK3399_PLL_CON(43), 8, 31, ROCKCHIP_PLL_SYNC_RATE, rk3399_pll_rates),
-	[vpll] = PLL(pll_rk3399, PLL_VPLL, "vpll",  mux_pll_p, 0, RK3399_PLL_CON(48),
-		     RK3399_PLL_CON(51), 8, 31, ROCKCHIP_PLL_SYNC_RATE, rk3399_pll_rates),
-};
-
-static struct rockchip_pll_clock rk3399_pmu_pll_clks[] __initdata = {
-	[ppll] = PLL(pll_rk3399, PLL_PPLL, "ppll",  mux_pll_p, 0, RK3399_PMU_PLL_CON(0),
-		     RK3399_PMU_PLL_CON(3), 8, 31, ROCKCHIP_PLL_SYNC_RATE, rk3399_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-#define IFLAGS ROCKCHIP_INVERTER_HIWORD_MASK
-
-static struct rockchip_clk_branch rk3399_spdif_fracmux __initdata =
-	MUX(0, "clk_spdif_mux", mux_spdif_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(32), 13, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_i2s0_fracmux __initdata =
-	MUX(0, "clk_i2s0_mux", mux_i2s0_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(28), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_i2s1_fracmux __initdata =
-	MUX(0, "clk_i2s1_mux", mux_i2s1_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(29), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_i2s2_fracmux __initdata =
-	MUX(0, "clk_i2s2_mux", mux_i2s2_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(30), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "clk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(33), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "clk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(34), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "clk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(35), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_uart3_fracmux __initdata =
-	MUX(SCLK_UART3, "clk_uart3", mux_uart3_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(36), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_uart4_pmu_fracmux __initdata =
-	MUX(SCLK_UART4_PMU, "clk_uart4_pmu", mux_uart4_pmu_p, CLK_SET_RATE_PARENT,
-			RK3399_PMU_CLKSEL_CON(5), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_dclk_vop0_fracmux __initdata =
-	MUX(DCLK_VOP0, "dclk_vop0", mux_dclk_vop0_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(49), 11, 1, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_dclk_vop1_fracmux __initdata =
-	MUX(DCLK_VOP1, "dclk_vop1", mux_dclk_vop1_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(50), 11, 1, MFLAGS);
-
-static struct rockchip_clk_branch rk3399_pmuclk_wifi_fracmux __initdata =
-	MUX(SCLK_WIFI_PMU, "clk_wifi_pmu", mux_wifi_pmu_p, CLK_SET_RATE_PARENT,
-			RK3399_PMU_CLKSEL_CON(1), 14, 1, MFLAGS);
-
-static const struct rockchip_cpuclk_reg_data rk3399_cpuclkl_data = {
-	.core_reg = RK3399_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 3,
-	.mux_core_main = 0,
-	.mux_core_shift = 6,
-	.mux_core_mask = 0x3,
-};
-
-static const struct rockchip_cpuclk_reg_data rk3399_cpuclkb_data = {
-	.core_reg = RK3399_CLKSEL_CON(2),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 3,
-	.mux_core_main = 1,
-	.mux_core_shift = 6,
-	.mux_core_mask = 0x3,
-};
-
-#define RK3399_DIV_ACLKM_MASK		0x1f
-#define RK3399_DIV_ACLKM_SHIFT		8
-#define RK3399_DIV_ATCLK_MASK		0x1f
-#define RK3399_DIV_ATCLK_SHIFT		0
-#define RK3399_DIV_PCLK_DBG_MASK	0x1f
-#define RK3399_DIV_PCLK_DBG_SHIFT	8
-
-#define RK3399_CLKSEL0(_offs, _aclkm)					\
-	{								\
-		.reg = RK3399_CLKSEL_CON(0 + _offs),			\
-		.val = HIWORD_UPDATE(_aclkm, RK3399_DIV_ACLKM_MASK,	\
-				RK3399_DIV_ACLKM_SHIFT),		\
-	}
-#define RK3399_CLKSEL1(_offs, _atclk, _pdbg)				\
-	{								\
-		.reg = RK3399_CLKSEL_CON(1 + _offs),			\
-		.val = HIWORD_UPDATE(_atclk, RK3399_DIV_ATCLK_MASK,	\
-				RK3399_DIV_ATCLK_SHIFT) |		\
-		       HIWORD_UPDATE(_pdbg, RK3399_DIV_PCLK_DBG_MASK,	\
-				RK3399_DIV_PCLK_DBG_SHIFT),		\
-	}
-
-/* cluster_l: aclkm in clksel0, rest in clksel1 */
-#define RK3399_CPUCLKL_RATE(_prate, _aclkm, _atclk, _pdbg)		\
-	{								\
-		.prate = _prate##U,					\
-		.divs = {						\
-			RK3399_CLKSEL0(0, _aclkm),			\
-			RK3399_CLKSEL1(0, _atclk, _pdbg),		\
-		},							\
-	}
-
-/* cluster_b: aclkm in clksel2, rest in clksel3 */
-#define RK3399_CPUCLKB_RATE(_prate, _aclkm, _atclk, _pdbg)		\
-	{								\
-		.prate = _prate##U,					\
-		.divs = {						\
-			RK3399_CLKSEL0(2, _aclkm),			\
-			RK3399_CLKSEL1(2, _atclk, _pdbg),		\
-		},							\
-	}
-
-static struct rockchip_cpuclk_rate_table rk3399_cpuclkl_rates[] __initdata = {
-	RK3399_CPUCLKL_RATE(1800000000, 1, 8, 8),
-	RK3399_CPUCLKL_RATE(1704000000, 1, 8, 8),
-	RK3399_CPUCLKL_RATE(1608000000, 1, 7, 7),
-	RK3399_CPUCLKL_RATE(1512000000, 1, 7, 7),
-	RK3399_CPUCLKL_RATE(1488000000, 1, 6, 6),
-	RK3399_CPUCLKL_RATE(1416000000, 1, 6, 6),
-	RK3399_CPUCLKL_RATE(1200000000, 1, 5, 5),
-	RK3399_CPUCLKL_RATE(1008000000, 1, 5, 5),
-	RK3399_CPUCLKL_RATE( 816000000, 1, 4, 4),
-	RK3399_CPUCLKL_RATE( 696000000, 1, 3, 3),
-	RK3399_CPUCLKL_RATE( 600000000, 1, 3, 3),
-	RK3399_CPUCLKL_RATE( 408000000, 1, 2, 2),
-	RK3399_CPUCLKL_RATE( 312000000, 1, 1, 1),
-	RK3399_CPUCLKL_RATE( 216000000, 1, 1, 1),
-	RK3399_CPUCLKL_RATE(  96000000, 1, 1, 1),
-};
-
-static struct rockchip_cpuclk_rate_table rk3399_cpuclkb_rates[] __initdata = {
-	RK3399_CPUCLKB_RATE(2208000000, 1, 11, 11),
-	RK3399_CPUCLKB_RATE(2184000000, 1, 11, 11),
-	RK3399_CPUCLKB_RATE(2088000000, 1, 10, 10),
-	RK3399_CPUCLKB_RATE(2040000000, 1, 10, 10),
-	RK3399_CPUCLKB_RATE(2016000000, 1, 9, 9),
-	RK3399_CPUCLKB_RATE(1992000000, 1, 9, 9),
-	RK3399_CPUCLKB_RATE(1896000000, 1, 9, 9),
-	RK3399_CPUCLKB_RATE(1800000000, 1, 8, 8),
-	RK3399_CPUCLKB_RATE(1704000000, 1, 8, 8),
-	RK3399_CPUCLKB_RATE(1608000000, 1, 7, 7),
-	RK3399_CPUCLKB_RATE(1512000000, 1, 7, 7),
-	RK3399_CPUCLKB_RATE(1488000000, 1, 6, 6),
-	RK3399_CPUCLKB_RATE(1416000000, 1, 6, 6),
-	RK3399_CPUCLKB_RATE(1200000000, 1, 5, 5),
-	RK3399_CPUCLKB_RATE(1008000000, 1, 5, 5),
-	RK3399_CPUCLKB_RATE( 816000000, 1, 4, 4),
-	RK3399_CPUCLKB_RATE( 696000000, 1, 3, 3),
-	RK3399_CPUCLKB_RATE( 600000000, 1, 3, 3),
-	RK3399_CPUCLKB_RATE( 408000000, 1, 2, 2),
-	RK3399_CPUCLKB_RATE( 312000000, 1, 1, 1),
-	RK3399_CPUCLKB_RATE( 216000000, 1, 1, 1),
-	RK3399_CPUCLKB_RATE(  96000000, 1, 1, 1),
-};
-
-static struct rockchip_clk_branch rk3399_clk_branches[] __initdata = {
-	/*
-	 * CRU Clock-Architecture
-	 */
-
-	/* usbphy */
-	GATE(SCLK_USB2PHY0_REF, "clk_usb2phy0_ref", "xin24m", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(6), 5, GFLAGS),
-	GATE(SCLK_USB2PHY1_REF, "clk_usb2phy1_ref", "xin24m", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(6), 6, GFLAGS),
-
-	GATE(0, "clk_usbphy0_480m_src", "clk_usbphy0_480m", 0,
-			RK3399_CLKGATE_CON(13), 12, GFLAGS),
-	GATE(0, "clk_usbphy1_480m_src", "clk_usbphy1_480m", 0,
-			RK3399_CLKGATE_CON(13), 12, GFLAGS),
-	MUX(0, "clk_usbphy_480m", mux_usbphy_480m_p, 0,
-			RK3399_CLKSEL_CON(14), 6, 1, MFLAGS),
-
-	MUX(0, "upll", mux_pll_src_24m_usbphy480m_p, 0,
-			RK3399_CLKSEL_CON(14), 15, 1, MFLAGS),
-
-	COMPOSITE_NODIV(SCLK_HSICPHY, "clk_hsicphy", mux_pll_src_cpll_gpll_npll_usbphy480m_p, 0,
-			RK3399_CLKSEL_CON(19), 0, 2, MFLAGS,
-			RK3399_CLKGATE_CON(6), 4, GFLAGS),
-
-	COMPOSITE(ACLK_USB3, "aclk_usb3", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(39), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 0, GFLAGS),
-	GATE(ACLK_USB3_NOC, "aclk_usb3_noc", "aclk_usb3", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(30), 0, GFLAGS),
-	GATE(ACLK_USB3OTG0, "aclk_usb3otg0", "aclk_usb3", 0,
-			RK3399_CLKGATE_CON(30), 1, GFLAGS),
-	GATE(ACLK_USB3OTG1, "aclk_usb3otg1", "aclk_usb3", 0,
-			RK3399_CLKGATE_CON(30), 2, GFLAGS),
-	GATE(ACLK_USB3_RKSOC_AXI_PERF, "aclk_usb3_rksoc_axi_perf", "aclk_usb3", 0,
-			RK3399_CLKGATE_CON(30), 3, GFLAGS),
-	GATE(ACLK_USB3_GRF, "aclk_usb3_grf", "aclk_usb3", 0,
-			RK3399_CLKGATE_CON(30), 4, GFLAGS),
-
-	GATE(SCLK_USB3OTG0_REF, "clk_usb3otg0_ref", "xin24m", 0,
-			RK3399_CLKGATE_CON(12), 1, GFLAGS),
-	GATE(SCLK_USB3OTG1_REF, "clk_usb3otg1_ref", "xin24m", 0,
-			RK3399_CLKGATE_CON(12), 2, GFLAGS),
-
-	COMPOSITE(SCLK_USB3OTG0_SUSPEND, "clk_usb3otg0_suspend", mux_pll_p, 0,
-			RK3399_CLKSEL_CON(40), 15, 1, MFLAGS, 0, 10, DFLAGS,
-			RK3399_CLKGATE_CON(12), 3, GFLAGS),
-
-	COMPOSITE(SCLK_USB3OTG1_SUSPEND, "clk_usb3otg1_suspend", mux_pll_p, 0,
-			RK3399_CLKSEL_CON(41), 15, 1, MFLAGS, 0, 10, DFLAGS,
-			RK3399_CLKGATE_CON(12), 4, GFLAGS),
-
-	COMPOSITE(SCLK_UPHY0_TCPDPHY_REF, "clk_uphy0_tcpdphy_ref", mux_pll_p, 0,
-			RK3399_CLKSEL_CON(64), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 4, GFLAGS),
-
-	COMPOSITE(SCLK_UPHY0_TCPDCORE, "clk_uphy0_tcpdcore", mux_pll_src_24m_32k_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(64), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 5, GFLAGS),
-
-	COMPOSITE(SCLK_UPHY1_TCPDPHY_REF, "clk_uphy1_tcpdphy_ref", mux_pll_p, 0,
-			RK3399_CLKSEL_CON(65), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 6, GFLAGS),
-
-	COMPOSITE(SCLK_UPHY1_TCPDCORE, "clk_uphy1_tcpdcore", mux_pll_src_24m_32k_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(65), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 7, GFLAGS),
-
-	/* little core */
-	GATE(0, "clk_core_l_lpll_src", "lpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(0), 0, GFLAGS),
-	GATE(0, "clk_core_l_bpll_src", "bpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "clk_core_l_dpll_src", "dpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "clk_core_l_gpll_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(0), 3, GFLAGS),
-
-	COMPOSITE_NOMUX(0, "aclkm_core_l", "armclkl", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(0), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3399_CLKGATE_CON(0), 4, GFLAGS),
-	COMPOSITE_NOMUX(0, "atclk_core_l", "armclkl", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(1), 0, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3399_CLKGATE_CON(0), 5, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_dbg_core_l", "armclkl", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(1), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3399_CLKGATE_CON(0), 6, GFLAGS),
-
-	GATE(ACLK_CORE_ADB400_CORE_L_2_CCI500, "aclk_core_adb400_core_l_2_cci500", "aclkm_core_l", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 12, GFLAGS),
-	GATE(ACLK_PERF_CORE_L, "aclk_perf_core_l", "aclkm_core_l", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 13, GFLAGS),
-
-	GATE(0, "clk_dbg_pd_core_l", "armclkl", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 9, GFLAGS),
-	GATE(ACLK_GIC_ADB400_GIC_2_CORE_L, "aclk_core_adb400_gic_2_core_l", "armclkl", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 10, GFLAGS),
-	GATE(ACLK_GIC_ADB400_CORE_L_2_GIC, "aclk_core_adb400_core_l_2_gic", "armclkl", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 11, GFLAGS),
-	GATE(SCLK_PVTM_CORE_L, "clk_pvtm_core_l", "xin24m", 0,
-			RK3399_CLKGATE_CON(0), 7, GFLAGS),
-
-	/* big core */
-	GATE(0, "clk_core_b_lpll_src", "lpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(1), 0, GFLAGS),
-	GATE(0, "clk_core_b_bpll_src", "bpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(1), 1, GFLAGS),
-	GATE(0, "clk_core_b_dpll_src", "dpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(1), 2, GFLAGS),
-	GATE(0, "clk_core_b_gpll_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(1), 3, GFLAGS),
-
-	COMPOSITE_NOMUX(0, "aclkm_core_b", "armclkb", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(2), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3399_CLKGATE_CON(1), 4, GFLAGS),
-	COMPOSITE_NOMUX(0, "atclk_core_b", "armclkb", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(3), 0, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3399_CLKGATE_CON(1), 5, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_dbg_core_b", "armclkb", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(3), 8, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RK3399_CLKGATE_CON(1), 6, GFLAGS),
-
-	GATE(ACLK_CORE_ADB400_CORE_B_2_CCI500, "aclk_core_adb400_core_b_2_cci500", "aclkm_core_b", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 5, GFLAGS),
-	GATE(ACLK_PERF_CORE_B, "aclk_perf_core_b", "aclkm_core_b", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 6, GFLAGS),
-
-	GATE(0, "clk_dbg_pd_core_b", "armclkb", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 1, GFLAGS),
-	GATE(ACLK_GIC_ADB400_GIC_2_CORE_B, "aclk_core_adb400_gic_2_core_b", "armclkb", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 3, GFLAGS),
-	GATE(ACLK_GIC_ADB400_CORE_B_2_GIC, "aclk_core_adb400_core_b_2_gic", "armclkb", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 4, GFLAGS),
-
-	DIV(0, "pclken_dbg_core_b", "pclk_dbg_core_b", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(3), 13, 2, DFLAGS | CLK_DIVIDER_READ_ONLY),
-
-	GATE(0, "pclk_dbg_cxcs_pd_core_b", "pclk_dbg_core_b", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(14), 2, GFLAGS),
-
-	GATE(SCLK_PVTM_CORE_B, "clk_pvtm_core_b", "xin24m", 0,
-			RK3399_CLKGATE_CON(1), 7, GFLAGS),
-
-	/* gmac */
-	GATE(0, "cpll_aclk_gmac_src", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(6), 9, GFLAGS),
-	GATE(0, "gpll_aclk_gmac_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(6), 8, GFLAGS),
-	COMPOSITE(0, "aclk_gmac_pre", mux_aclk_gmac_p, 0,
-			RK3399_CLKSEL_CON(20), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(6), 10, GFLAGS),
-
-	GATE(ACLK_GMAC, "aclk_gmac", "aclk_gmac_pre", 0,
-			RK3399_CLKGATE_CON(32), 0, GFLAGS),
-	GATE(ACLK_GMAC_NOC, "aclk_gmac_noc", "aclk_gmac_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(32), 1, GFLAGS),
-	GATE(ACLK_PERF_GMAC, "aclk_perf_gmac", "aclk_gmac_pre", 0,
-			RK3399_CLKGATE_CON(32), 4, GFLAGS),
-
-	COMPOSITE_NOMUX(0, "pclk_gmac_pre", "aclk_gmac_pre", 0,
-			RK3399_CLKSEL_CON(19), 8, 3, DFLAGS,
-			RK3399_CLKGATE_CON(6), 11, GFLAGS),
-	GATE(PCLK_GMAC, "pclk_gmac", "pclk_gmac_pre", 0,
-			RK3399_CLKGATE_CON(32), 2, GFLAGS),
-	GATE(PCLK_GMAC_NOC, "pclk_gmac_noc", "pclk_gmac_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(32), 3, GFLAGS),
-
-	COMPOSITE(SCLK_MAC, "clk_gmac", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(20), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(5), 5, GFLAGS),
-
-	MUX(SCLK_RMII_SRC, "clk_rmii_src", mux_rmii_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(19), 4, 1, MFLAGS),
-	GATE(SCLK_MACREF_OUT, "clk_mac_refout", "clk_rmii_src", 0,
-			RK3399_CLKGATE_CON(5), 6, GFLAGS),
-	GATE(SCLK_MACREF, "clk_mac_ref", "clk_rmii_src", 0,
-			RK3399_CLKGATE_CON(5), 7, GFLAGS),
-	GATE(SCLK_MAC_RX, "clk_rmii_rx", "clk_rmii_src", 0,
-			RK3399_CLKGATE_CON(5), 8, GFLAGS),
-	GATE(SCLK_MAC_TX, "clk_rmii_tx", "clk_rmii_src", 0,
-			RK3399_CLKGATE_CON(5), 9, GFLAGS),
-
-	/* spdif */
-	COMPOSITE(0, "clk_spdif_div", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(32), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(8), 13, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_spdif_frac", "clk_spdif_div", 0,
-			RK3399_CLKSEL_CON(99), 0,
-			RK3399_CLKGATE_CON(8), 14, GFLAGS,
-			&rk3399_spdif_fracmux),
-	GATE(SCLK_SPDIF_8CH, "clk_spdif", "clk_spdif_mux", CLK_SET_RATE_PARENT,
-			RK3399_CLKGATE_CON(8), 15, GFLAGS),
-
-	COMPOSITE(SCLK_SPDIF_REC_DPTX, "clk_spdif_rec_dptx", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(32), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 6, GFLAGS),
-	/* i2s */
-	COMPOSITE(0, "clk_i2s0_div", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(28), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(8), 3, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_i2s0_frac", "clk_i2s0_div", 0,
-			RK3399_CLKSEL_CON(96), 0,
-			RK3399_CLKGATE_CON(8), 4, GFLAGS,
-			&rk3399_i2s0_fracmux),
-	GATE(SCLK_I2S0_8CH, "clk_i2s0", "clk_i2s0_mux", CLK_SET_RATE_PARENT,
-			RK3399_CLKGATE_CON(8), 5, GFLAGS),
-
-	COMPOSITE(0, "clk_i2s1_div", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(29), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(8), 6, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_i2s1_frac", "clk_i2s1_div", 0,
-			RK3399_CLKSEL_CON(97), 0,
-			RK3399_CLKGATE_CON(8), 7, GFLAGS,
-			&rk3399_i2s1_fracmux),
-	GATE(SCLK_I2S1_8CH, "clk_i2s1", "clk_i2s1_mux", CLK_SET_RATE_PARENT,
-			RK3399_CLKGATE_CON(8), 8, GFLAGS),
-
-	COMPOSITE(0, "clk_i2s2_div", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(30), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(8), 9, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_i2s2_frac", "clk_i2s2_div", 0,
-			RK3399_CLKSEL_CON(98), 0,
-			RK3399_CLKGATE_CON(8), 10, GFLAGS,
-			&rk3399_i2s2_fracmux),
-	GATE(SCLK_I2S2_8CH, "clk_i2s2", "clk_i2s2_mux", CLK_SET_RATE_PARENT,
-			RK3399_CLKGATE_CON(8), 11, GFLAGS),
-
-	MUX(0, "clk_i2sout_src", mux_i2sch_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(31), 0, 2, MFLAGS),
-	COMPOSITE_NODIV(SCLK_I2S_8CH_OUT, "clk_i2sout", mux_i2sout_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(31), 2, 1, MFLAGS,
-			RK3399_CLKGATE_CON(8), 12, GFLAGS),
-
-	/* uart */
-	MUX(0, "clk_uart0_src", mux_pll_src_cpll_gpll_upll_p, 0,
-			RK3399_CLKSEL_CON(33), 12, 2, MFLAGS),
-	COMPOSITE_NOMUX(0, "clk_uart0_div", "clk_uart0_src", 0,
-			RK3399_CLKSEL_CON(33), 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 0, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_uart0_frac", "clk_uart0_div", 0,
-			RK3399_CLKSEL_CON(100), 0,
-			RK3399_CLKGATE_CON(9), 1, GFLAGS,
-			&rk3399_uart0_fracmux),
-
-	MUX(0, "clk_uart_src", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(33), 15, 1, MFLAGS),
-	COMPOSITE_NOMUX(0, "clk_uart1_div", "clk_uart_src", 0,
-			RK3399_CLKSEL_CON(34), 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 2, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_uart1_frac", "clk_uart1_div", 0,
-			RK3399_CLKSEL_CON(101), 0,
-			RK3399_CLKGATE_CON(9), 3, GFLAGS,
-			&rk3399_uart1_fracmux),
-
-	COMPOSITE_NOMUX(0, "clk_uart2_div", "clk_uart_src", 0,
-			RK3399_CLKSEL_CON(35), 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 4, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_uart2_frac", "clk_uart2_div", 0,
-			RK3399_CLKSEL_CON(102), 0,
-			RK3399_CLKGATE_CON(9), 5, GFLAGS,
-			&rk3399_uart2_fracmux),
-
-	COMPOSITE_NOMUX(0, "clk_uart3_div", "clk_uart_src", 0,
-			RK3399_CLKSEL_CON(36), 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 6, GFLAGS),
-	COMPOSITE_FRACMUX(0, "clk_uart3_frac", "clk_uart3_div", 0,
-			RK3399_CLKSEL_CON(103), 0,
-			RK3399_CLKGATE_CON(9), 7, GFLAGS,
-			&rk3399_uart3_fracmux),
-
-	COMPOSITE(PCLK_DDR, "pclk_ddr", mux_pll_src_cpll_gpll_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(6), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(3), 4, GFLAGS),
-
-	GATE(PCLK_CENTER_MAIN_NOC, "pclk_center_main_noc", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(18), 10, GFLAGS),
-	GATE(PCLK_DDR_MON, "pclk_ddr_mon", "pclk_ddr", 0,
-			RK3399_CLKGATE_CON(18), 12, GFLAGS),
-	GATE(PCLK_CIC, "pclk_cic", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(18), 15, GFLAGS),
-	GATE(PCLK_DDR_SGRF, "pclk_ddr_sgrf", "pclk_ddr", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(19), 2, GFLAGS),
-
-	GATE(SCLK_PVTM_DDR, "clk_pvtm_ddr", "xin24m", 0,
-			RK3399_CLKGATE_CON(4), 11, GFLAGS),
-	GATE(SCLK_DFIMON0_TIMER, "clk_dfimon0_timer", "xin24m", 0,
-			RK3399_CLKGATE_CON(3), 5, GFLAGS),
-	GATE(SCLK_DFIMON1_TIMER, "clk_dfimon1_timer", "xin24m", 0,
-			RK3399_CLKGATE_CON(3), 6, GFLAGS),
-
-	/* cci */
-	GATE(0, "cpll_aclk_cci_src", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "gpll_aclk_cci_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 1, GFLAGS),
-	GATE(0, "npll_aclk_cci_src", "npll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 2, GFLAGS),
-	GATE(0, "vpll_aclk_cci_src", "vpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 3, GFLAGS),
-
-	COMPOSITE(0, "aclk_cci_pre", mux_aclk_cci_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(5), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(2), 4, GFLAGS),
-
-	GATE(ACLK_ADB400M_PD_CORE_L, "aclk_adb400m_pd_core_l", "aclk_cci_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 0, GFLAGS),
-	GATE(ACLK_ADB400M_PD_CORE_B, "aclk_adb400m_pd_core_b", "aclk_cci_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 1, GFLAGS),
-	GATE(ACLK_CCI, "aclk_cci", "aclk_cci_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 2, GFLAGS),
-	GATE(ACLK_CCI_NOC0, "aclk_cci_noc0", "aclk_cci_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 3, GFLAGS),
-	GATE(ACLK_CCI_NOC1, "aclk_cci_noc1", "aclk_cci_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 4, GFLAGS),
-	GATE(ACLK_CCI_GRF, "aclk_cci_grf", "aclk_cci_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 7, GFLAGS),
-
-	GATE(0, "cpll_cci_trace", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 5, GFLAGS),
-	GATE(0, "gpll_cci_trace", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 6, GFLAGS),
-	COMPOSITE(SCLK_CCI_TRACE, "clk_cci_trace", mux_cci_trace_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(5), 15, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(2), 7, GFLAGS),
-
-	GATE(0, "cpll_cs", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 8, GFLAGS),
-	GATE(0, "gpll_cs", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 9, GFLAGS),
-	GATE(0, "npll_cs", "npll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(2), 10, GFLAGS),
-	COMPOSITE_NOGATE(0, "clk_cs", mux_cs_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(4), 6, 2, MFLAGS, 0, 5, DFLAGS),
-	GATE(0, "clk_dbg_cxcs", "clk_cs", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 5, GFLAGS),
-	GATE(0, "clk_dbg_noc", "clk_cs", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(15), 6, GFLAGS),
-
-	/* vcodec */
-	COMPOSITE(0, "aclk_vcodec_pre", mux_pll_src_cpll_gpll_npll_ppll_p, 0,
-			RK3399_CLKSEL_CON(7), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 0, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_vcodec_pre", "aclk_vcodec_pre", 0,
-			RK3399_CLKSEL_CON(7), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 1, GFLAGS),
-	GATE(HCLK_VCODEC, "hclk_vcodec", "hclk_vcodec_pre", 0,
-			RK3399_CLKGATE_CON(17), 2, GFLAGS),
-	GATE(0, "hclk_vcodec_noc", "hclk_vcodec_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(17), 3, GFLAGS),
-
-	GATE(ACLK_VCODEC, "aclk_vcodec", "aclk_vcodec_pre", 0,
-			RK3399_CLKGATE_CON(17), 0, GFLAGS),
-	GATE(0, "aclk_vcodec_noc", "aclk_vcodec_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(17), 1, GFLAGS),
-
-	/* vdu */
-	COMPOSITE(SCLK_VDU_CORE, "clk_vdu_core", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(9), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 4, GFLAGS),
-	COMPOSITE(SCLK_VDU_CA, "clk_vdu_ca", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(9), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 5, GFLAGS),
-
-	COMPOSITE(0, "aclk_vdu_pre", mux_pll_src_cpll_gpll_npll_ppll_p, 0,
-			RK3399_CLKSEL_CON(8), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 2, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_vdu_pre", "aclk_vdu_pre", 0,
-			RK3399_CLKSEL_CON(8), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 3, GFLAGS),
-	GATE(HCLK_VDU, "hclk_vdu", "hclk_vdu_pre", 0,
-			RK3399_CLKGATE_CON(17), 10, GFLAGS),
-	GATE(HCLK_VDU_NOC, "hclk_vdu_noc", "hclk_vdu_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(17), 11, GFLAGS),
-
-	GATE(ACLK_VDU, "aclk_vdu", "aclk_vdu_pre", 0,
-			RK3399_CLKGATE_CON(17), 8, GFLAGS),
-	GATE(ACLK_VDU_NOC, "aclk_vdu_noc", "aclk_vdu_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(17), 9, GFLAGS),
-
-	/* iep */
-	COMPOSITE(0, "aclk_iep_pre", mux_pll_src_cpll_gpll_npll_ppll_p, 0,
-			RK3399_CLKSEL_CON(10), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 6, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_iep_pre", "aclk_iep_pre", 0,
-			RK3399_CLKSEL_CON(10), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 7, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_iep_pre", 0,
-			RK3399_CLKGATE_CON(16), 2, GFLAGS),
-	GATE(HCLK_IEP_NOC, "hclk_iep_noc", "hclk_iep_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(16), 3, GFLAGS),
-
-	GATE(ACLK_IEP, "aclk_iep", "aclk_iep_pre", 0,
-			RK3399_CLKGATE_CON(16), 0, GFLAGS),
-	GATE(ACLK_IEP_NOC, "aclk_iep_noc", "aclk_iep_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(16), 1, GFLAGS),
-
-	/* rga */
-	COMPOSITE(SCLK_RGA_CORE, "clk_rga_core", mux_pll_src_cpll_gpll_npll_ppll_p, 0,
-			RK3399_CLKSEL_CON(12), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 10, GFLAGS),
-
-	COMPOSITE(0, "aclk_rga_pre", mux_pll_src_cpll_gpll_npll_ppll_p, 0,
-			RK3399_CLKSEL_CON(11), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 8, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_rga_pre", "aclk_rga_pre", 0,
-			RK3399_CLKSEL_CON(11), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(4), 9, GFLAGS),
-	GATE(HCLK_RGA, "hclk_rga", "hclk_rga_pre", 0,
-			RK3399_CLKGATE_CON(16), 10, GFLAGS),
-	GATE(HCLK_RGA_NOC, "hclk_rga_noc", "hclk_rga_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(16), 11, GFLAGS),
-
-	GATE(ACLK_RGA, "aclk_rga", "aclk_rga_pre", 0,
-			RK3399_CLKGATE_CON(16), 8, GFLAGS),
-	GATE(ACLK_RGA_NOC, "aclk_rga_noc", "aclk_rga_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(16), 9, GFLAGS),
-
-	/* center */
-	COMPOSITE(0, "aclk_center", mux_pll_src_cpll_gpll_npll_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(12), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(3), 7, GFLAGS),
-	GATE(ACLK_CENTER_MAIN_NOC, "aclk_center_main_noc", "aclk_center", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(19), 0, GFLAGS),
-	GATE(ACLK_CENTER_PERI_NOC, "aclk_center_peri_noc", "aclk_center", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(19), 1, GFLAGS),
-
-	/* gpu */
-	COMPOSITE(0, "aclk_gpu_pre", mux_pll_src_ppll_cpll_gpll_npll_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(13), 5, 3, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 0, GFLAGS),
-	GATE(ACLK_GPU, "aclk_gpu", "aclk_gpu_pre", 0,
-			RK3399_CLKGATE_CON(30), 8, GFLAGS),
-	GATE(ACLK_PERF_GPU, "aclk_perf_gpu", "aclk_gpu_pre", 0,
-			RK3399_CLKGATE_CON(30), 10, GFLAGS),
-	GATE(ACLK_GPU_GRF, "aclk_gpu_grf", "aclk_gpu_pre", 0,
-			RK3399_CLKGATE_CON(30), 11, GFLAGS),
-	GATE(SCLK_PVTM_GPU, "aclk_pvtm_gpu", "xin24m", 0,
-			RK3399_CLKGATE_CON(13), 1, GFLAGS),
-
-	/* perihp */
-	GATE(0, "cpll_aclk_perihp_src", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(5), 1, GFLAGS),
-	GATE(0, "gpll_aclk_perihp_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(5), 0, GFLAGS),
-	COMPOSITE(ACLK_PERIHP, "aclk_perihp", mux_aclk_perihp_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(14), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(5), 2, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERIHP, "hclk_perihp", "aclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(14), 8, 2, DFLAGS,
-			RK3399_CLKGATE_CON(5), 3, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERIHP, "pclk_perihp", "aclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(14), 12, 2, DFLAGS,
-			RK3399_CLKGATE_CON(5), 4, GFLAGS),
-
-	GATE(ACLK_PERF_PCIE, "aclk_perf_pcie", "aclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 2, GFLAGS),
-	GATE(ACLK_PCIE, "aclk_pcie", "aclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 10, GFLAGS),
-	GATE(0, "aclk_perihp_noc", "aclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(20), 12, GFLAGS),
-
-	GATE(HCLK_HOST0, "hclk_host0", "hclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 5, GFLAGS),
-	GATE(HCLK_HOST0_ARB, "hclk_host0_arb", "hclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 6, GFLAGS),
-	GATE(HCLK_HOST1, "hclk_host1", "hclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 7, GFLAGS),
-	GATE(HCLK_HOST1_ARB, "hclk_host1_arb", "hclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 8, GFLAGS),
-	GATE(HCLK_HSIC, "hclk_hsic", "hclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 9, GFLAGS),
-	GATE(0, "hclk_perihp_noc", "hclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(20), 13, GFLAGS),
-	GATE(0, "hclk_ahb1tom", "hclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(20), 15, GFLAGS),
-
-	GATE(PCLK_PERIHP_GRF, "pclk_perihp_grf", "pclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(20), 4, GFLAGS),
-	GATE(PCLK_PCIE, "pclk_pcie", "pclk_perihp", 0,
-			RK3399_CLKGATE_CON(20), 11, GFLAGS),
-	GATE(0, "pclk_perihp_noc", "pclk_perihp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(20), 14, GFLAGS),
-	GATE(PCLK_HSICPHY, "pclk_hsicphy", "pclk_perihp", 0,
-			RK3399_CLKGATE_CON(31), 8, GFLAGS),
-
-	/* sdio & sdmmc */
-	COMPOSITE(HCLK_SD, "hclk_sd", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(13), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 13, GFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_sd", 0,
-			RK3399_CLKGATE_CON(33), 8, GFLAGS),
-	GATE(0, "hclk_sdmmc_noc", "hclk_sd", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(33), 9, GFLAGS),
-
-	COMPOSITE(SCLK_SDIO, "clk_sdio", mux_pll_src_cpll_gpll_npll_ppll_upll_24m_p, 0,
-			RK3399_CLKSEL_CON(15), 8, 3, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(6), 0, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC, "clk_sdmmc", mux_pll_src_cpll_gpll_npll_ppll_upll_24m_p, 0,
-			RK3399_CLKSEL_CON(16), 8, 3, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(6), 1, GFLAGS),
-
-	MMC(SCLK_SDMMC_DRV,     "sdmmc_drv",    "clk_sdmmc", RK3399_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE,  "sdmmc_sample", "clk_sdmmc", RK3399_SDMMC_CON1, 1),
-
-	MMC(SCLK_SDIO_DRV,      "sdio_drv",    "clk_sdio",  RK3399_SDIO_CON0,  1),
-	MMC(SCLK_SDIO_SAMPLE,   "sdio_sample", "clk_sdio",  RK3399_SDIO_CON1,  1),
-
-	/* pcie */
-	COMPOSITE(SCLK_PCIE_PM, "clk_pcie_pm", mux_pll_src_cpll_gpll_npll_24m_p, 0,
-			RK3399_CLKSEL_CON(17), 8, 3, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(6), 2, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_PCIEPHY_REF100M, "clk_pciephy_ref100m", "npll", 0,
-			RK3399_CLKSEL_CON(18), 11, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 6, GFLAGS),
-	MUX(SCLK_PCIEPHY_REF, "clk_pciephy_ref", mux_pll_src_24m_pciephy_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(18), 10, 1, MFLAGS),
-
-	COMPOSITE(0, "clk_pcie_core_cru", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(18), 8, 2, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(6), 3, GFLAGS),
-	MUX(SCLK_PCIE_CORE, "clk_pcie_core", mux_pciecore_cru_phy_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(18), 7, 1, MFLAGS),
-
-	/* emmc */
-	COMPOSITE(SCLK_EMMC, "clk_emmc", mux_pll_src_cpll_gpll_npll_upll_24m_p, 0,
-			RK3399_CLKSEL_CON(22), 8, 3, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(6), 14, GFLAGS),
-
-	GATE(0, "cpll_aclk_emmc_src", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(6), 13, GFLAGS),
-	GATE(0, "gpll_aclk_emmc_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(6), 12, GFLAGS),
-	COMPOSITE_NOGATE(ACLK_EMMC, "aclk_emmc", mux_aclk_emmc_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(21), 7, 1, MFLAGS, 0, 5, DFLAGS),
-	GATE(ACLK_EMMC_CORE, "aclk_emmccore", "aclk_emmc", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(32), 8, GFLAGS),
-	GATE(ACLK_EMMC_NOC, "aclk_emmc_noc", "aclk_emmc", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(32), 9, GFLAGS),
-	GATE(ACLK_EMMC_GRF, "aclk_emmcgrf", "aclk_emmc", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(32), 10, GFLAGS),
-
-	/* perilp0 */
-	GATE(0, "cpll_aclk_perilp0_src", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(7), 1, GFLAGS),
-	GATE(0, "gpll_aclk_perilp0_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(7), 0, GFLAGS),
-	COMPOSITE(ACLK_PERILP0, "aclk_perilp0", mux_aclk_perilp0_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(23), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(7), 2, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_PERILP0, "hclk_perilp0", "aclk_perilp0", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(23), 8, 2, DFLAGS,
-			RK3399_CLKGATE_CON(7), 3, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERILP0, "pclk_perilp0", "aclk_perilp0", 0,
-			RK3399_CLKSEL_CON(23), 12, 3, DFLAGS,
-			RK3399_CLKGATE_CON(7), 4, GFLAGS),
-
-	/* aclk_perilp0 gates */
-	GATE(ACLK_INTMEM, "aclk_intmem", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 0, GFLAGS),
-	GATE(ACLK_TZMA, "aclk_tzma", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 1, GFLAGS),
-	GATE(SCLK_INTMEM0, "clk_intmem0", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 2, GFLAGS),
-	GATE(SCLK_INTMEM1, "clk_intmem1", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 3, GFLAGS),
-	GATE(SCLK_INTMEM2, "clk_intmem2", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 4, GFLAGS),
-	GATE(SCLK_INTMEM3, "clk_intmem3", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 5, GFLAGS),
-	GATE(SCLK_INTMEM4, "clk_intmem4", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 6, GFLAGS),
-	GATE(SCLK_INTMEM5, "clk_intmem5", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(23), 7, GFLAGS),
-	GATE(ACLK_DCF, "aclk_dcf", "aclk_perilp0", 0, RK3399_CLKGATE_CON(23), 8, GFLAGS),
-	GATE(ACLK_DMAC0_PERILP, "aclk_dmac0_perilp", "aclk_perilp0", 0, RK3399_CLKGATE_CON(25), 5, GFLAGS),
-	GATE(ACLK_DMAC1_PERILP, "aclk_dmac1_perilp", "aclk_perilp0", 0, RK3399_CLKGATE_CON(25), 6, GFLAGS),
-	GATE(ACLK_PERILP0_NOC, "aclk_perilp0_noc", "aclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(25), 7, GFLAGS),
-
-	/* hclk_perilp0 gates */
-	GATE(HCLK_ROM, "hclk_rom", "hclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(24), 4, GFLAGS),
-	GATE(HCLK_M_CRYPTO0, "hclk_m_crypto0", "hclk_perilp0", 0, RK3399_CLKGATE_CON(24), 5, GFLAGS),
-	GATE(HCLK_S_CRYPTO0, "hclk_s_crypto0", "hclk_perilp0", 0, RK3399_CLKGATE_CON(24), 6, GFLAGS),
-	GATE(HCLK_M_CRYPTO1, "hclk_m_crypto1", "hclk_perilp0", 0, RK3399_CLKGATE_CON(24), 14, GFLAGS),
-	GATE(HCLK_S_CRYPTO1, "hclk_s_crypto1", "hclk_perilp0", 0, RK3399_CLKGATE_CON(24), 15, GFLAGS),
-	GATE(HCLK_PERILP0_NOC, "hclk_perilp0_noc", "hclk_perilp0", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(25), 8, GFLAGS),
-
-	/* pclk_perilp0 gates */
-	GATE(PCLK_DCF, "pclk_dcf", "pclk_perilp0", 0, RK3399_CLKGATE_CON(23), 9, GFLAGS),
-
-	/* crypto */
-	COMPOSITE(SCLK_CRYPTO0, "clk_crypto0", mux_pll_src_cpll_gpll_ppll_p, 0,
-			RK3399_CLKSEL_CON(24), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(7), 7, GFLAGS),
-
-	COMPOSITE(SCLK_CRYPTO1, "clk_crypto1", mux_pll_src_cpll_gpll_ppll_p, 0,
-			RK3399_CLKSEL_CON(26), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(7), 8, GFLAGS),
-
-	/* cm0s_perilp */
-	GATE(0, "cpll_fclk_cm0s_src", "cpll", 0,
-			RK3399_CLKGATE_CON(7), 6, GFLAGS),
-	GATE(0, "gpll_fclk_cm0s_src", "gpll", 0,
-			RK3399_CLKGATE_CON(7), 5, GFLAGS),
-	COMPOSITE(FCLK_CM0S, "fclk_cm0s", mux_fclk_cm0s_p, 0,
-			RK3399_CLKSEL_CON(24), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(7), 9, GFLAGS),
-
-	/* fclk_cm0s gates */
-	GATE(SCLK_M0_PERILP, "sclk_m0_perilp", "fclk_cm0s", 0, RK3399_CLKGATE_CON(24), 8, GFLAGS),
-	GATE(HCLK_M0_PERILP, "hclk_m0_perilp", "fclk_cm0s", 0, RK3399_CLKGATE_CON(24), 9, GFLAGS),
-	GATE(DCLK_M0_PERILP, "dclk_m0_perilp", "fclk_cm0s", 0, RK3399_CLKGATE_CON(24), 10, GFLAGS),
-	GATE(SCLK_M0_PERILP_DEC, "clk_m0_perilp_dec", "fclk_cm0s", 0, RK3399_CLKGATE_CON(24), 11, GFLAGS),
-	GATE(HCLK_M0_PERILP_NOC, "hclk_m0_perilp_noc", "fclk_cm0s", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(25), 11, GFLAGS),
-
-	/* perilp1 */
-	GATE(0, "cpll_hclk_perilp1_src", "cpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(8), 1, GFLAGS),
-	GATE(0, "gpll_hclk_perilp1_src", "gpll", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(8), 0, GFLAGS),
-	COMPOSITE_NOGATE(HCLK_PERILP1, "hclk_perilp1", mux_hclk_perilp1_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(25), 7, 1, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(PCLK_PERILP1, "pclk_perilp1", "hclk_perilp1", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(25), 8, 3, DFLAGS,
-			RK3399_CLKGATE_CON(8), 2, GFLAGS),
-
-	/* hclk_perilp1 gates */
-	GATE(0, "hclk_perilp1_noc", "hclk_perilp1", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(25), 9, GFLAGS),
-	GATE(0, "hclk_sdio_noc", "hclk_perilp1", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(25), 12, GFLAGS),
-	GATE(HCLK_I2S0_8CH, "hclk_i2s0", "hclk_perilp1", 0, RK3399_CLKGATE_CON(34), 0, GFLAGS),
-	GATE(HCLK_I2S1_8CH, "hclk_i2s1", "hclk_perilp1", 0, RK3399_CLKGATE_CON(34), 1, GFLAGS),
-	GATE(HCLK_I2S2_8CH, "hclk_i2s2", "hclk_perilp1", 0, RK3399_CLKGATE_CON(34), 2, GFLAGS),
-	GATE(HCLK_SPDIF, "hclk_spdif", "hclk_perilp1", 0, RK3399_CLKGATE_CON(34), 3, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_perilp1", 0, RK3399_CLKGATE_CON(34), 4, GFLAGS),
-	GATE(PCLK_SPI5, "pclk_spi5", "hclk_perilp1", 0, RK3399_CLKGATE_CON(34), 5, GFLAGS),
-	GATE(0, "hclk_sdioaudio_noc", "hclk_perilp1", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(34), 6, GFLAGS),
-
-	/* pclk_perilp1 gates */
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 0, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 1, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 2, GFLAGS),
-	GATE(PCLK_UART3, "pclk_uart3", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 3, GFLAGS),
-	GATE(PCLK_I2C7, "pclk_rki2c7", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 5, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_rki2c1", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 6, GFLAGS),
-	GATE(PCLK_I2C5, "pclk_rki2c5", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 7, GFLAGS),
-	GATE(PCLK_I2C6, "pclk_rki2c6", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 8, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_rki2c2", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 9, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_rki2c3", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 10, GFLAGS),
-	GATE(PCLK_MAILBOX0, "pclk_mailbox0", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 11, GFLAGS),
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 12, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 13, GFLAGS),
-	GATE(PCLK_EFUSE1024NS, "pclk_efuse1024ns", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 14, GFLAGS),
-	GATE(PCLK_EFUSE1024S, "pclk_efuse1024s", "pclk_perilp1", 0, RK3399_CLKGATE_CON(22), 15, GFLAGS),
-	GATE(PCLK_SPI0, "pclk_spi0", "pclk_perilp1", 0, RK3399_CLKGATE_CON(23), 10, GFLAGS),
-	GATE(PCLK_SPI1, "pclk_spi1", "pclk_perilp1", 0, RK3399_CLKGATE_CON(23), 11, GFLAGS),
-	GATE(PCLK_SPI2, "pclk_spi2", "pclk_perilp1", 0, RK3399_CLKGATE_CON(23), 12, GFLAGS),
-	GATE(PCLK_SPI4, "pclk_spi4", "pclk_perilp1", 0, RK3399_CLKGATE_CON(23), 13, GFLAGS),
-	GATE(PCLK_PERIHP_GRF, "pclk_perilp_sgrf", "pclk_perilp1", 0, RK3399_CLKGATE_CON(24), 13, GFLAGS),
-	GATE(0, "pclk_perilp1_noc", "pclk_perilp1", 0, RK3399_CLKGATE_CON(25), 10, GFLAGS),
-
-	/* saradc */
-	COMPOSITE_NOMUX(SCLK_SARADC, "clk_saradc", "xin24m", 0,
-			RK3399_CLKSEL_CON(26), 8, 8, DFLAGS,
-			RK3399_CLKGATE_CON(9), 11, GFLAGS),
-
-	/* tsadc */
-	COMPOSITE(SCLK_TSADC, "clk_tsadc", mux_pll_p, 0,
-			RK3399_CLKSEL_CON(27), 15, 1, MFLAGS, 0, 10, DFLAGS,
-			RK3399_CLKGATE_CON(9), 10, GFLAGS),
-
-	/* cif_testout */
-	MUX(0, "clk_testout1_pll_src", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(38), 6, 2, MFLAGS),
-	COMPOSITE(SCLK_TESTCLKOUT1, "clk_testout1", mux_clk_testout1_p, 0,
-			RK3399_CLKSEL_CON(38), 5, 1, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 14, GFLAGS),
-
-	MUX(0, "clk_testout2_pll_src", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(38), 14, 2, MFLAGS),
-	COMPOSITE(SCLK_TESTCLKOUT2, "clk_testout2", mux_clk_testout2_p, 0,
-			RK3399_CLKSEL_CON(38), 13, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 15, GFLAGS),
-
-	/* vio */
-	COMPOSITE(ACLK_VIO, "aclk_vio", mux_pll_src_cpll_gpll_ppll_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(42), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 0, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_VIO, "pclk_vio", "aclk_vio", 0,
-			RK3399_CLKSEL_CON(43), 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 1, GFLAGS),
-
-	GATE(ACLK_VIO_NOC, "aclk_vio_noc", "aclk_vio", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(29), 0, GFLAGS),
-
-	GATE(PCLK_MIPI_DSI0, "pclk_mipi_dsi0", "pclk_vio", 0,
-			RK3399_CLKGATE_CON(29), 1, GFLAGS),
-	GATE(PCLK_MIPI_DSI1, "pclk_mipi_dsi1", "pclk_vio", 0,
-			RK3399_CLKGATE_CON(29), 2, GFLAGS),
-	GATE(PCLK_VIO_GRF, "pclk_vio_grf", "pclk_vio", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(29), 12, GFLAGS),
-
-	/* hdcp */
-	COMPOSITE(ACLK_HDCP, "aclk_hdcp", mux_pll_src_cpll_gpll_ppll_p, 0,
-			RK3399_CLKSEL_CON(42), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 12, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_HDCP, "hclk_hdcp", "aclk_hdcp", 0,
-			RK3399_CLKSEL_CON(43), 5, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 3, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_HDCP, "pclk_hdcp", "aclk_hdcp", 0,
-			RK3399_CLKSEL_CON(43), 10, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 10, GFLAGS),
-
-	GATE(ACLK_HDCP_NOC, "aclk_hdcp_noc", "aclk_hdcp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(29), 4, GFLAGS),
-	GATE(ACLK_HDCP22, "aclk_hdcp22", "aclk_hdcp", 0,
-			RK3399_CLKGATE_CON(29), 10, GFLAGS),
-
-	GATE(HCLK_HDCP_NOC, "hclk_hdcp_noc", "hclk_hdcp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(29), 5, GFLAGS),
-	GATE(HCLK_HDCP22, "hclk_hdcp22", "hclk_hdcp", 0,
-			RK3399_CLKGATE_CON(29), 9, GFLAGS),
-
-	GATE(PCLK_HDCP_NOC, "pclk_hdcp_noc", "pclk_hdcp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(29), 3, GFLAGS),
-	GATE(PCLK_HDMI_CTRL, "pclk_hdmi_ctrl", "pclk_hdcp", 0,
-			RK3399_CLKGATE_CON(29), 6, GFLAGS),
-	GATE(PCLK_DP_CTRL, "pclk_dp_ctrl", "pclk_hdcp", 0,
-			RK3399_CLKGATE_CON(29), 7, GFLAGS),
-	GATE(PCLK_HDCP22, "pclk_hdcp22", "pclk_hdcp", 0,
-			RK3399_CLKGATE_CON(29), 8, GFLAGS),
-	GATE(PCLK_GASKET, "pclk_gasket", "pclk_hdcp", 0,
-			RK3399_CLKGATE_CON(29), 11, GFLAGS),
-
-	/* edp */
-	COMPOSITE(SCLK_DP_CORE, "clk_dp_core", mux_pll_src_npll_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(46), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 8, GFLAGS),
-
-	COMPOSITE(PCLK_EDP, "pclk_edp", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(44), 15, 1, MFLAGS, 8, 6, DFLAGS,
-			RK3399_CLKGATE_CON(11), 11, GFLAGS),
-	GATE(PCLK_EDP_NOC, "pclk_edp_noc", "pclk_edp", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(32), 12, GFLAGS),
-	GATE(PCLK_EDP_CTRL, "pclk_edp_ctrl", "pclk_edp", 0,
-			RK3399_CLKGATE_CON(32), 13, GFLAGS),
-
-	/* hdmi */
-	GATE(SCLK_HDMI_SFR, "clk_hdmi_sfr", "xin24m", 0,
-			RK3399_CLKGATE_CON(11), 6, GFLAGS),
-
-	COMPOSITE(SCLK_HDMI_CEC, "clk_hdmi_cec", mux_pll_p, 0,
-			RK3399_CLKSEL_CON(45), 15, 1, MFLAGS, 0, 10, DFLAGS,
-			RK3399_CLKGATE_CON(11), 7, GFLAGS),
-
-	/* vop0 */
-	COMPOSITE(ACLK_VOP0_PRE, "aclk_vop0_pre", mux_pll_src_vpll_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(47), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 8, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_vop0_pre", "aclk_vop0_pre", 0,
-			RK3399_CLKSEL_CON(47), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 9, GFLAGS),
-
-	GATE(ACLK_VOP0, "aclk_vop0", "aclk_vop0_pre", 0,
-			RK3399_CLKGATE_CON(28), 3, GFLAGS),
-	GATE(ACLK_VOP0_NOC, "aclk_vop0_noc", "aclk_vop0_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(28), 1, GFLAGS),
-
-	GATE(HCLK_VOP0, "hclk_vop0", "hclk_vop0_pre", 0,
-			RK3399_CLKGATE_CON(28), 2, GFLAGS),
-	GATE(HCLK_VOP0_NOC, "hclk_vop0_noc", "hclk_vop0_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(28), 0, GFLAGS),
-
-	COMPOSITE(DCLK_VOP0_DIV, "dclk_vop0_div", mux_pll_src_vpll_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(49), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3399_CLKGATE_CON(10), 12, GFLAGS),
-
-	COMPOSITE_FRACMUX_NOGATE(DCLK_VOP0_FRAC, "dclk_vop0_frac", "dclk_vop0_div", 0,
-			RK3399_CLKSEL_CON(106), 0,
-			&rk3399_dclk_vop0_fracmux),
-
-	COMPOSITE(SCLK_VOP0_PWM, "clk_vop0_pwm", mux_pll_src_vpll_cpll_gpll_24m_p, 0,
-			RK3399_CLKSEL_CON(51), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 14, GFLAGS),
-
-	/* vop1 */
-	COMPOSITE(ACLK_VOP1_PRE, "aclk_vop1_pre", mux_pll_src_vpll_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(48), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 10, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_vop1_pre", "aclk_vop1_pre", 0,
-			RK3399_CLKSEL_CON(48), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 11, GFLAGS),
-
-	GATE(ACLK_VOP1, "aclk_vop1", "aclk_vop1_pre", 0,
-			RK3399_CLKGATE_CON(28), 7, GFLAGS),
-	GATE(ACLK_VOP1_NOC, "aclk_vop1_noc", "aclk_vop1_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(28), 5, GFLAGS),
-
-	GATE(HCLK_VOP1, "hclk_vop1", "hclk_vop1_pre", 0,
-			RK3399_CLKGATE_CON(28), 6, GFLAGS),
-	GATE(HCLK_VOP1_NOC, "hclk_vop1_noc", "hclk_vop1_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(28), 4, GFLAGS),
-
-	COMPOSITE(DCLK_VOP1_DIV, "dclk_vop1_div", mux_pll_src_vpll_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(50), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RK3399_CLKGATE_CON(10), 13, GFLAGS),
-
-	COMPOSITE_FRACMUX_NOGATE(DCLK_VOP1_FRAC, "dclk_vop1_frac", "dclk_vop1_div", 0,
-			RK3399_CLKSEL_CON(107), 0,
-			&rk3399_dclk_vop1_fracmux),
-
-	COMPOSITE(SCLK_VOP1_PWM, "clk_vop1_pwm", mux_pll_src_vpll_cpll_gpll_24m_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(52), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(10), 15, GFLAGS),
-
-	/* isp */
-	COMPOSITE(ACLK_ISP0, "aclk_isp0", mux_pll_src_cpll_gpll_ppll_p, 0,
-			RK3399_CLKSEL_CON(53), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 8, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_ISP0, "hclk_isp0", "aclk_isp0", 0,
-			RK3399_CLKSEL_CON(53), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 9, GFLAGS),
-
-	GATE(ACLK_ISP0_NOC, "aclk_isp0_noc", "aclk_isp0", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(27), 1, GFLAGS),
-	GATE(ACLK_ISP0_WRAPPER, "aclk_isp0_wrapper", "aclk_isp0", 0,
-			RK3399_CLKGATE_CON(27), 5, GFLAGS),
-	GATE(HCLK_ISP1_WRAPPER, "hclk_isp1_wrapper", "aclk_isp0", 0,
-			RK3399_CLKGATE_CON(27), 7, GFLAGS),
-
-	GATE(HCLK_ISP0_NOC, "hclk_isp0_noc", "hclk_isp0", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(27), 0, GFLAGS),
-	GATE(HCLK_ISP0_WRAPPER, "hclk_isp0_wrapper", "hclk_isp0", 0,
-			RK3399_CLKGATE_CON(27), 4, GFLAGS),
-
-	COMPOSITE(SCLK_ISP0, "clk_isp0", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(55), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 4, GFLAGS),
-
-	COMPOSITE(ACLK_ISP1, "aclk_isp1", mux_pll_src_cpll_gpll_ppll_p, 0,
-			RK3399_CLKSEL_CON(54), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 10, GFLAGS),
-	COMPOSITE_NOMUX(HCLK_ISP1, "hclk_isp1", "aclk_isp1", 0,
-			RK3399_CLKSEL_CON(54), 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 11, GFLAGS),
-
-	GATE(ACLK_ISP1_NOC, "aclk_isp1_noc", "aclk_isp1", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(27), 3, GFLAGS),
-
-	GATE(HCLK_ISP1_NOC, "hclk_isp1_noc", "hclk_isp1", CLK_IGNORE_UNUSED,
-			RK3399_CLKGATE_CON(27), 2, GFLAGS),
-	GATE(ACLK_ISP1_WRAPPER, "aclk_isp1_wrapper", "hclk_isp1", 0,
-			RK3399_CLKGATE_CON(27), 8, GFLAGS),
-
-	COMPOSITE(SCLK_ISP1, "clk_isp1", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(55), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(11), 5, GFLAGS),
-
-	/*
-	 * We use pclkin_cifinv by default GRF_SOC_CON20[9] (GSC20_9) setting in system,
-	 * so we ignore the mux and make clocks nodes as following,
-	 *
-	 * pclkin_cifinv --|-------\
-	 *                 |GSC20_9|-- pclkin_cifmux -- |G27_6| -- pclkin_isp1_wrapper
-	 * pclkin_cif    --|-------/
-	 */
-	GATE(PCLK_ISP1_WRAPPER, "pclkin_isp1_wrapper", "pclkin_cif", 0,
-			RK3399_CLKGATE_CON(27), 6, GFLAGS),
-
-	/* cif */
-	COMPOSITE_NODIV(0, "clk_cifout_src", mux_pll_src_cpll_gpll_npll_p, 0,
-			RK3399_CLKSEL_CON(56), 6, 2, MFLAGS,
-			RK3399_CLKGATE_CON(10), 7, GFLAGS),
-
-	COMPOSITE_NOGATE(SCLK_CIF_OUT, "clk_cifout", mux_clk_cif_p, 0,
-			 RK3399_CLKSEL_CON(56), 5, 1, MFLAGS, 0, 5, DFLAGS),
-
-	/* gic */
-	COMPOSITE(ACLK_GIC_PRE, "aclk_gic_pre", mux_pll_src_cpll_gpll_p, CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(56), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_CLKGATE_CON(12), 12, GFLAGS),
-
-	GATE(ACLK_GIC, "aclk_gic", "aclk_gic_pre", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(33), 0, GFLAGS),
-	GATE(ACLK_GIC_NOC, "aclk_gic_noc", "aclk_gic_pre", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(33), 1, GFLAGS),
-	GATE(ACLK_GIC_ADB400_CORE_L_2_GIC, "aclk_gic_adb400_core_l_2_gic", "aclk_gic_pre", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(33), 2, GFLAGS),
-	GATE(ACLK_GIC_ADB400_CORE_B_2_GIC, "aclk_gic_adb400_core_b_2_gic", "aclk_gic_pre", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(33), 3, GFLAGS),
-	GATE(ACLK_GIC_ADB400_GIC_2_CORE_L, "aclk_gic_adb400_gic_2_core_l", "aclk_gic_pre", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(33), 4, GFLAGS),
-	GATE(ACLK_GIC_ADB400_GIC_2_CORE_B, "aclk_gic_adb400_gic_2_core_b", "aclk_gic_pre", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(33), 5, GFLAGS),
-
-	/* alive */
-	/* pclk_alive_gpll_src is controlled by PMUGRF_SOC_CON0[6] */
-	DIV(PCLK_ALIVE, "pclk_alive", "gpll", 0,
-			RK3399_CLKSEL_CON(57), 0, 5, DFLAGS),
-
-	GATE(PCLK_USBPHY_MUX_G, "pclk_usbphy_mux_g", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 4, GFLAGS),
-	GATE(PCLK_UPHY0_TCPHY_G, "pclk_uphy0_tcphy_g", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 5, GFLAGS),
-	GATE(PCLK_UPHY0_TCPD_G, "pclk_uphy0_tcpd_g", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 6, GFLAGS),
-	GATE(PCLK_UPHY1_TCPHY_G, "pclk_uphy1_tcphy_g", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 8, GFLAGS),
-	GATE(PCLK_UPHY1_TCPD_G, "pclk_uphy1_tcpd_g", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 9, GFLAGS),
-
-	GATE(PCLK_GRF, "pclk_grf", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(31), 1, GFLAGS),
-	GATE(PCLK_INTR_ARB, "pclk_intr_arb", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(31), 2, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_alive", 0, RK3399_CLKGATE_CON(31), 3, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_alive", 0, RK3399_CLKGATE_CON(31), 4, GFLAGS),
-	GATE(PCLK_GPIO4, "pclk_gpio4", "pclk_alive", 0, RK3399_CLKGATE_CON(31), 5, GFLAGS),
-	GATE(PCLK_TIMER0, "pclk_timer0", "pclk_alive", 0, RK3399_CLKGATE_CON(31), 6, GFLAGS),
-	GATE(PCLK_TIMER1, "pclk_timer1", "pclk_alive", 0, RK3399_CLKGATE_CON(31), 7, GFLAGS),
-	GATE(PCLK_PMU_INTR_ARB, "pclk_pmu_intr_arb", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(31), 9, GFLAGS),
-	GATE(PCLK_SGRF, "pclk_sgrf", "pclk_alive", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(31), 10, GFLAGS),
-
-	GATE(SCLK_MIPIDPHY_REF, "clk_mipidphy_ref", "xin24m", 0, RK3399_CLKGATE_CON(11), 14, GFLAGS),
-	GATE(SCLK_DPHY_PLL, "clk_dphy_pll", "clk_mipidphy_ref", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 0, GFLAGS),
-
-	GATE(SCLK_MIPIDPHY_CFG, "clk_mipidphy_cfg", "xin24m", 0, RK3399_CLKGATE_CON(11), 15, GFLAGS),
-	GATE(SCLK_DPHY_TX0_CFG, "clk_dphy_tx0_cfg", "clk_mipidphy_cfg", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 1, GFLAGS),
-	GATE(SCLK_DPHY_TX1RX1_CFG, "clk_dphy_tx1rx1_cfg", "clk_mipidphy_cfg", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 2, GFLAGS),
-	GATE(SCLK_DPHY_RX0_CFG, "clk_dphy_rx0_cfg", "clk_mipidphy_cfg", CLK_IGNORE_UNUSED, RK3399_CLKGATE_CON(21), 3, GFLAGS),
-
-	/* testout */
-	MUX(0, "clk_test_pre", mux_pll_src_cpll_gpll_p, CLK_SET_RATE_PARENT,
-			RK3399_CLKSEL_CON(58), 7, 1, MFLAGS),
-	COMPOSITE_FRAC(0, "clk_test_frac", "clk_test_pre", 0,
-			RK3399_CLKSEL_CON(105), 0,
-			RK3399_CLKGATE_CON(13), 9, GFLAGS),
-
-	DIV(0, "clk_test_24m", "xin24m", 0,
-			RK3399_CLKSEL_CON(57), 6, 10, DFLAGS),
-
-	/* spi */
-	COMPOSITE(SCLK_SPI0, "clk_spi0", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(59), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 12, GFLAGS),
-
-	COMPOSITE(SCLK_SPI1, "clk_spi1", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(59), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 13, GFLAGS),
-
-	COMPOSITE(SCLK_SPI2, "clk_spi2", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(60), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 14, GFLAGS),
-
-	COMPOSITE(SCLK_SPI4, "clk_spi4", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(60), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3399_CLKGATE_CON(9), 15, GFLAGS),
-
-	COMPOSITE(SCLK_SPI5, "clk_spi5", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(58), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3399_CLKGATE_CON(13), 13, GFLAGS),
-
-	/* i2c */
-	COMPOSITE(SCLK_I2C1, "clk_i2c1", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(61), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(10), 0, GFLAGS),
-
-	COMPOSITE(SCLK_I2C2, "clk_i2c2", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(62), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(10), 2, GFLAGS),
-
-	COMPOSITE(SCLK_I2C3, "clk_i2c3", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(63), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_CLKGATE_CON(10), 4, GFLAGS),
-
-	COMPOSITE(SCLK_I2C5, "clk_i2c5", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(61), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3399_CLKGATE_CON(10), 1, GFLAGS),
-
-	COMPOSITE(SCLK_I2C6, "clk_i2c6", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(62), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3399_CLKGATE_CON(10), 3, GFLAGS),
-
-	COMPOSITE(SCLK_I2C7, "clk_i2c7", mux_pll_src_cpll_gpll_p, 0,
-			RK3399_CLKSEL_CON(63), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RK3399_CLKGATE_CON(10), 5, GFLAGS),
-
-	/* timer */
-	GATE(SCLK_TIMER00, "clk_timer00", "xin24m", 0, RK3399_CLKGATE_CON(26), 0, GFLAGS),
-	GATE(SCLK_TIMER01, "clk_timer01", "xin24m", 0, RK3399_CLKGATE_CON(26), 1, GFLAGS),
-	GATE(SCLK_TIMER02, "clk_timer02", "xin24m", 0, RK3399_CLKGATE_CON(26), 2, GFLAGS),
-	GATE(SCLK_TIMER03, "clk_timer03", "xin24m", 0, RK3399_CLKGATE_CON(26), 3, GFLAGS),
-	GATE(SCLK_TIMER04, "clk_timer04", "xin24m", 0, RK3399_CLKGATE_CON(26), 4, GFLAGS),
-	GATE(SCLK_TIMER05, "clk_timer05", "xin24m", 0, RK3399_CLKGATE_CON(26), 5, GFLAGS),
-	GATE(SCLK_TIMER06, "clk_timer06", "xin24m", 0, RK3399_CLKGATE_CON(26), 6, GFLAGS),
-	GATE(SCLK_TIMER07, "clk_timer07", "xin24m", 0, RK3399_CLKGATE_CON(26), 7, GFLAGS),
-	GATE(SCLK_TIMER08, "clk_timer08", "xin24m", 0, RK3399_CLKGATE_CON(26), 8, GFLAGS),
-	GATE(SCLK_TIMER09, "clk_timer09", "xin24m", 0, RK3399_CLKGATE_CON(26), 9, GFLAGS),
-	GATE(SCLK_TIMER10, "clk_timer10", "xin24m", 0, RK3399_CLKGATE_CON(26), 10, GFLAGS),
-	GATE(SCLK_TIMER11, "clk_timer11", "xin24m", 0, RK3399_CLKGATE_CON(26), 11, GFLAGS),
-
-	/* clk_test */
-	/* clk_test_pre is controlled by CRU_MISC_CON[3] */
-	COMPOSITE_NOMUX(0, "clk_test", "clk_test_pre", CLK_IGNORE_UNUSED,
-			RK3399_CLKSEL_CON(58), 0, 5, DFLAGS,
-			RK3399_CLKGATE_CON(13), 11, GFLAGS),
-
-	/* ddrc */
-	GATE(0, "clk_ddrc_lpll_src", "lpll", 0, RK3399_CLKGATE_CON(3),
-	     0, GFLAGS),
-	GATE(0, "clk_ddrc_bpll_src", "bpll", 0, RK3399_CLKGATE_CON(3),
-	     1, GFLAGS),
-	GATE(0, "clk_ddrc_dpll_src", "dpll", 0, RK3399_CLKGATE_CON(3),
-	     2, GFLAGS),
-	GATE(0, "clk_ddrc_gpll_src", "gpll", 0, RK3399_CLKGATE_CON(3),
-	     3, GFLAGS),
-	COMPOSITE_DDRCLK(SCLK_DDRC, "sclk_ddrc", mux_ddrclk_p, 0,
-		       RK3399_CLKSEL_CON(6), 4, 2, 0, 0, ROCKCHIP_DDRCLK_SIP),
-};
-
-static struct rockchip_clk_branch rk3399_clk_pmu_branches[] __initdata = {
-	/*
-	 * PMU CRU Clock-Architecture
-	 */
-
-	GATE(0, "fclk_cm0s_pmu_ppll_src", "ppll", 0,
-			RK3399_PMU_CLKGATE_CON(0), 1, GFLAGS),
-
-	COMPOSITE_NOGATE(FCLK_CM0S_SRC_PMU, "fclk_cm0s_src_pmu", mux_fclk_cm0s_pmu_ppll_p, 0,
-			RK3399_PMU_CLKSEL_CON(0), 15, 1, MFLAGS, 8, 5, DFLAGS),
-
-	COMPOSITE(SCLK_SPI3_PMU, "clk_spi3_pmu", mux_24m_ppll_p, 0,
-			RK3399_PMU_CLKSEL_CON(1), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_PMU_CLKGATE_CON(0), 2, GFLAGS),
-
-	COMPOSITE(0, "clk_wifi_div", mux_ppll_24m_p, CLK_IGNORE_UNUSED,
-			RK3399_PMU_CLKSEL_CON(1), 13, 1, MFLAGS, 8, 5, DFLAGS,
-			RK3399_PMU_CLKGATE_CON(0), 8, GFLAGS),
-
-	COMPOSITE_FRACMUX_NOGATE(0, "clk_wifi_frac", "clk_wifi_div", 0,
-			RK3399_PMU_CLKSEL_CON(7), 0,
-			&rk3399_pmuclk_wifi_fracmux),
-
-	MUX(0, "clk_timer_src_pmu", mux_pll_p, CLK_IGNORE_UNUSED,
-			RK3399_PMU_CLKSEL_CON(1), 15, 1, MFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_I2C0_PMU, "clk_i2c0_pmu", "ppll", 0,
-			RK3399_PMU_CLKSEL_CON(2), 0, 7, DFLAGS,
-			RK3399_PMU_CLKGATE_CON(0), 9, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_I2C4_PMU, "clk_i2c4_pmu", "ppll", 0,
-			RK3399_PMU_CLKSEL_CON(3), 0, 7, DFLAGS,
-			RK3399_PMU_CLKGATE_CON(0), 10, GFLAGS),
-
-	COMPOSITE_NOMUX(SCLK_I2C8_PMU, "clk_i2c8_pmu", "ppll", 0,
-			RK3399_PMU_CLKSEL_CON(2), 8, 7, DFLAGS,
-			RK3399_PMU_CLKGATE_CON(0), 11, GFLAGS),
-
-	DIV(0, "clk_32k_suspend_pmu", "xin24m", CLK_IGNORE_UNUSED,
-			RK3399_PMU_CLKSEL_CON(4), 0, 10, DFLAGS),
-	MUX(0, "clk_testout_2io", mux_clk_testout2_2io_p, CLK_IGNORE_UNUSED,
-			RK3399_PMU_CLKSEL_CON(4), 15, 1, MFLAGS),
-
-	COMPOSITE(0, "clk_uart4_div", mux_24m_ppll_p, 0,
-			RK3399_PMU_CLKSEL_CON(5), 10, 1, MFLAGS, 0, 7, DFLAGS,
-			RK3399_PMU_CLKGATE_CON(0), 5, GFLAGS),
-
-	COMPOSITE_FRACMUX(0, "clk_uart4_frac", "clk_uart4_div", 0,
-			RK3399_PMU_CLKSEL_CON(6), 0,
-			RK3399_PMU_CLKGATE_CON(0), 6, GFLAGS,
-			&rk3399_uart4_pmu_fracmux),
-
-	DIV(PCLK_SRC_PMU, "pclk_pmu_src", "ppll", CLK_IGNORE_UNUSED,
-			RK3399_PMU_CLKSEL_CON(0), 0, 5, DFLAGS),
-
-	/* pmu clock gates */
-	GATE(SCLK_TIMER12_PMU, "clk_timer0_pmu", "clk_timer_src_pmu", 0, RK3399_PMU_CLKGATE_CON(0), 3, GFLAGS),
-	GATE(SCLK_TIMER13_PMU, "clk_timer1_pmu", "clk_timer_src_pmu", 0, RK3399_PMU_CLKGATE_CON(0), 4, GFLAGS),
-
-	GATE(SCLK_PVTM_PMU, "clk_pvtm_pmu", "xin24m", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(0), 7, GFLAGS),
-
-	GATE(PCLK_PMU, "pclk_pmu", "pclk_pmu_src", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(1), 0, GFLAGS),
-	GATE(PCLK_PMUGRF_PMU, "pclk_pmugrf_pmu", "pclk_pmu_src", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(1), 1, GFLAGS),
-	GATE(PCLK_INTMEM1_PMU, "pclk_intmem1_pmu", "pclk_pmu_src", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(1), 2, GFLAGS),
-	GATE(PCLK_GPIO0_PMU, "pclk_gpio0_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 3, GFLAGS),
-	GATE(PCLK_GPIO1_PMU, "pclk_gpio1_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 4, GFLAGS),
-	GATE(PCLK_SGRF_PMU, "pclk_sgrf_pmu", "pclk_pmu_src", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(1), 5, GFLAGS),
-	GATE(PCLK_NOC_PMU, "pclk_noc_pmu", "pclk_pmu_src", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(1), 6, GFLAGS),
-	GATE(PCLK_I2C0_PMU, "pclk_i2c0_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 7, GFLAGS),
-	GATE(PCLK_I2C4_PMU, "pclk_i2c4_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 8, GFLAGS),
-	GATE(PCLK_I2C8_PMU, "pclk_i2c8_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 9, GFLAGS),
-	GATE(PCLK_RKPWM_PMU, "pclk_rkpwm_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 10, GFLAGS),
-	GATE(PCLK_SPI3_PMU, "pclk_spi3_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 11, GFLAGS),
-	GATE(PCLK_TIMER_PMU, "pclk_timer_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 12, GFLAGS),
-	GATE(PCLK_MAILBOX_PMU, "pclk_mailbox_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 13, GFLAGS),
-	GATE(PCLK_UART4_PMU, "pclk_uart4_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 14, GFLAGS),
-	GATE(PCLK_WDT_M0_PMU, "pclk_wdt_m0_pmu", "pclk_pmu_src", 0, RK3399_PMU_CLKGATE_CON(1), 15, GFLAGS),
-
-	GATE(FCLK_CM0S_PMU, "fclk_cm0s_pmu", "fclk_cm0s_src_pmu", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(SCLK_CM0S_PMU, "sclk_cm0s_pmu", "fclk_cm0s_src_pmu", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(2), 1, GFLAGS),
-	GATE(HCLK_CM0S_PMU, "hclk_cm0s_pmu", "fclk_cm0s_src_pmu", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(2), 2, GFLAGS),
-	GATE(DCLK_CM0S_PMU, "dclk_cm0s_pmu", "fclk_cm0s_src_pmu", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(2), 3, GFLAGS),
-	GATE(HCLK_NOC_PMU, "hclk_noc_pmu", "fclk_cm0s_src_pmu", CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(2), 5, GFLAGS),
-};
-
-static const char *const rk3399_cru_critical_clocks[] __initconst = {
-	"aclk_cci_pre",
-	"aclk_gic",
-	"aclk_gic_noc",
-	"aclk_hdcp_noc",
-	"hclk_hdcp_noc",
-	"pclk_hdcp_noc",
-	"pclk_perilp0",
-	"pclk_perilp0",
-	"hclk_perilp0",
-	"hclk_perilp0_noc",
-	"pclk_perilp1",
-	"pclk_perilp1_noc",
-	"pclk_perihp",
-	"pclk_perihp_noc",
-	"hclk_perihp",
-	"aclk_perihp",
-	"aclk_perihp_noc",
-	"aclk_perilp0",
-	"aclk_perilp0_noc",
-	"hclk_perilp1",
-	"hclk_perilp1_noc",
-	"aclk_dmac0_perilp",
-	"aclk_emmc_noc",
-	"gpll_hclk_perilp1_src",
-	"gpll_aclk_perilp0_src",
-	"gpll_aclk_perihp_src",
-	"aclk_vio_noc",
-
-	/* ddrc */
-	"sclk_ddrc"
-};
-
-static const char *const rk3399_pmucru_critical_clocks[] __initconst = {
-	"ppll",
-	"pclk_pmu_src",
-	"fclk_cm0s_src_pmu",
-	"clk_timer_src_pmu",
-	"pclk_rkpwm_pmu",
-};
-
-static void __init rk3399_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-	struct clk *clk;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	/* Watchdog pclk is controlled by RK3399 SECURE_GRF_SOC_CON3[8]. */
-	clk = clk_register_fixed_factor(NULL, "pclk_wdt", "pclk_alive", 0, 1, 1);
-	if (IS_ERR(clk))
-		pr_warn("%s: could not register clock pclk_wdt: %ld\n",
-			__func__, PTR_ERR(clk));
-	else
-		rockchip_clk_add_lookup(ctx, clk, PCLK_WDT);
-
-	rockchip_clk_register_plls(ctx, rk3399_pll_clks,
-				   ARRAY_SIZE(rk3399_pll_clks), -1);
-
-	rockchip_clk_register_branches(ctx, rk3399_clk_branches,
-				  ARRAY_SIZE(rk3399_clk_branches));
-
-	rockchip_clk_protect_critical(rk3399_cru_critical_clocks,
-				      ARRAY_SIZE(rk3399_cru_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLKL, "armclkl",
-			mux_armclkl_p, ARRAY_SIZE(mux_armclkl_p),
-			&rk3399_cpuclkl_data, rk3399_cpuclkl_rates,
-			ARRAY_SIZE(rk3399_cpuclkl_rates));
-
-	rockchip_clk_register_armclk(ctx, ARMCLKB, "armclkb",
-			mux_armclkb_p, ARRAY_SIZE(mux_armclkb_p),
-			&rk3399_cpuclkb_data, rk3399_cpuclkb_rates,
-			ARRAY_SIZE(rk3399_cpuclkb_rates));
-
-	rockchip_register_softrst(np, 21, reg_base + RK3399_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RK3399_GLB_SRST_FST, NULL);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3399_cru, "rockchip,rk3399-cru", rk3399_clk_init);
-
-static void __init rk3399_pmu_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru pmu region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLKPMU_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip pmu clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	rockchip_clk_register_plls(ctx, rk3399_pmu_pll_clks,
-				   ARRAY_SIZE(rk3399_pmu_pll_clks), -1);
-
-	rockchip_clk_register_branches(ctx, rk3399_clk_pmu_branches,
-				  ARRAY_SIZE(rk3399_clk_pmu_branches));
-
-	rockchip_clk_protect_critical(rk3399_pmucru_critical_clocks,
-				  ARRAY_SIZE(rk3399_pmucru_critical_clocks));
-
-	rockchip_register_softrst(np, 2, reg_base + RK3399_PMU_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rk3399_cru_pmu, "rockchip,rk3399-pmucru", rk3399_pmu_clk_init);
diff --git a/drivers/clk/rockchip/clk-rv1108.c b/drivers/clk/rockchip/clk-rv1108.c
deleted file mode 100644
index 089cb1792..000000000
--- a/drivers/clk/rockchip/clk-rv1108.c
+++ /dev/null
@@ -1,831 +0,0 @@
-/*
- * Copyright (c) 2016 Rockchip Electronics Co. Ltd.
- * Author: Shawn Lin <shawn.lin@rock-chips.com>
- *         Andy Yan <andy.yan@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/syscore_ops.h>
-#include <dt-bindings/clock/rv1108-cru.h>
-#include "clk.h"
-
-#define RV1108_GRF_SOC_STATUS0	0x480
-
-enum rv1108_plls {
-	apll, dpll, gpll,
-};
-
-static struct rockchip_pll_rate_table rv1108_pll_rates[] = {
-	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
-	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1584000000, 1, 66, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1560000000, 1, 65, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1536000000, 1, 64, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1488000000, 1, 62, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1464000000, 1, 61, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1440000000, 1, 60, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1392000000, 1, 58, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1368000000, 1, 57, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1344000000, 1, 56, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1320000000, 1, 55, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1272000000, 1, 53, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1248000000, 1, 52, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1188000000, 2, 99, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1104000000, 1, 46, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1100000000, 12, 550, 1, 1, 1, 0),
-	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
-	RK3036_PLL_RATE(1000000000, 6, 500, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 984000000, 1, 82, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 960000000, 1, 80, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 936000000, 1, 78, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 912000000, 1, 76, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 900000000, 4, 300, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 888000000, 1, 74, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 864000000, 1, 72, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 840000000, 1, 70, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 816000000, 1, 68, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 800000000, 6, 400, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 700000000, 6, 350, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 696000000, 1, 58, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 600000000, 1, 75, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 594000000, 2, 99, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 504000000, 1, 63, 3, 1, 1, 0),
-	RK3036_PLL_RATE( 500000000, 6, 250, 2, 1, 1, 0),
-	RK3036_PLL_RATE( 408000000, 1, 68, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 312000000, 1, 52, 2, 2, 1, 0),
-	RK3036_PLL_RATE( 216000000, 1, 72, 4, 2, 1, 0),
-	RK3036_PLL_RATE(  96000000, 1, 64, 4, 4, 1, 0),
-	{ /* sentinel */ },
-};
-
-#define RV1108_DIV_CORE_MASK		0xf
-#define RV1108_DIV_CORE_SHIFT		4
-
-#define RV1108_CLKSEL0(_core_peri_div)	\
-	{				\
-		.reg = RV1108_CLKSEL_CON(1),	\
-		.val = HIWORD_UPDATE(_core_peri_div, RV1108_DIV_CORE_MASK,\
-				RV1108_DIV_CORE_SHIFT)	\
-	}
-
-#define RV1108_CPUCLK_RATE(_prate, _core_peri_div)			\
-	{								\
-		.prate = _prate,					\
-		.divs = {						\
-			RV1108_CLKSEL0(_core_peri_div),		\
-		},							\
-	}
-
-static struct rockchip_cpuclk_rate_table rv1108_cpuclk_rates[] __initdata = {
-	RV1108_CPUCLK_RATE(1608000000, 7),
-	RV1108_CPUCLK_RATE(1512000000, 7),
-	RV1108_CPUCLK_RATE(1488000000, 5),
-	RV1108_CPUCLK_RATE(1416000000, 5),
-	RV1108_CPUCLK_RATE(1392000000, 5),
-	RV1108_CPUCLK_RATE(1296000000, 5),
-	RV1108_CPUCLK_RATE(1200000000, 5),
-	RV1108_CPUCLK_RATE(1104000000, 5),
-	RV1108_CPUCLK_RATE(1008000000, 5),
-	RV1108_CPUCLK_RATE(912000000, 5),
-	RV1108_CPUCLK_RATE(816000000, 3),
-	RV1108_CPUCLK_RATE(696000000, 3),
-	RV1108_CPUCLK_RATE(600000000, 3),
-	RV1108_CPUCLK_RATE(500000000, 3),
-	RV1108_CPUCLK_RATE(408000000, 1),
-	RV1108_CPUCLK_RATE(312000000, 1),
-	RV1108_CPUCLK_RATE(216000000, 1),
-	RV1108_CPUCLK_RATE(96000000, 1),
-};
-
-static const struct rockchip_cpuclk_reg_data rv1108_cpuclk_data = {
-	.core_reg = RV1108_CLKSEL_CON(0),
-	.div_core_shift = 0,
-	.div_core_mask = 0x1f,
-	.mux_core_alt = 1,
-	.mux_core_main = 0,
-	.mux_core_shift = 8,
-	.mux_core_mask = 0x3,
-};
-
-PNAME(mux_pll_p)		= { "xin24m", "xin24m"};
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr", "apll_ddr" };
-PNAME(mux_armclk_p)		= { "apll_core", "gpll_core", "dpll_core" };
-PNAME(mux_usb480m_pre_p)	= { "usbphy", "xin24m" };
-PNAME(mux_hdmiphy_phy_p)	= { "hdmiphy", "xin24m" };
-PNAME(mux_dclk_hdmiphy_pre_p)	= { "dclk_hdmiphy_src_gpll", "dclk_hdmiphy_src_dpll" };
-PNAME(mux_pll_src_4plls_p)	= { "dpll", "gpll", "hdmiphy", "usb480m" };
-PNAME(mux_pll_src_3plls_p)	= { "apll", "gpll", "dpll" };
-PNAME(mux_pll_src_2plls_p)	= { "dpll", "gpll" };
-PNAME(mux_pll_src_apll_gpll_p)	= { "apll", "gpll" };
-PNAME(mux_aclk_peri_src_p)	= { "aclk_peri_src_gpll", "aclk_peri_src_dpll" };
-PNAME(mux_aclk_bus_src_p)	= { "aclk_bus_src_gpll", "aclk_bus_src_apll", "aclk_bus_src_dpll" };
-PNAME(mux_mmc_src_p)		= { "dpll", "gpll", "xin24m", "usb480m" };
-PNAME(mux_pll_src_dpll_gpll_usb480m_p)	= { "dpll", "gpll", "usb480m" };
-PNAME(mux_uart0_p)		= { "uart0_src", "uart0_frac", "xin24m" };
-PNAME(mux_uart1_p)		= { "uart1_src", "uart1_frac", "xin24m" };
-PNAME(mux_uart2_p)		= { "uart2_src", "uart2_frac", "xin24m" };
-PNAME(mux_sclk_mac_p)		= { "sclk_mac_pre", "ext_gmac" };
-PNAME(mux_i2s0_pre_p)		= { "i2s0_src", "i2s0_frac", "ext_i2s", "xin12m" };
-PNAME(mux_i2s_out_p)		= { "i2s0_pre", "xin12m" };
-PNAME(mux_i2s1_p)		= { "i2s1_src", "i2s1_frac", "dummy", "xin12m" };
-PNAME(mux_i2s2_p)		= { "i2s2_src", "i2s2_frac", "dummy", "xin12m" };
-PNAME(mux_wifi_src_p)		= { "gpll", "xin24m" };
-PNAME(mux_cifout_src_p)	= { "hdmiphy", "gpll" };
-PNAME(mux_cifout_p)		= { "sclk_cifout_src", "xin24m" };
-PNAME(mux_sclk_cif0_src_p)	= { "pclk_vip", "clk_cif0_chn_out", "pclkin_cvbs2cif" };
-PNAME(mux_sclk_cif1_src_p)	= { "pclk_vip", "clk_cif1_chn_out", "pclkin_cvbs2cif" };
-PNAME(mux_sclk_cif2_src_p)	= { "pclk_vip", "clk_cif2_chn_out", "pclkin_cvbs2cif" };
-PNAME(mux_sclk_cif3_src_p)	= { "pclk_vip", "clk_cif3_chn_out", "pclkin_cvbs2cif" };
-PNAME(mux_dsp_src_p)		= { "dpll", "gpll", "apll", "usb480m" };
-PNAME(mux_dclk_hdmiphy_p)	= { "hdmiphy", "xin24m" };
-PNAME(mux_dclk_vop_p)		= { "dclk_hdmiphy", "dclk_vop_src" };
-PNAME(mux_hdmi_cec_src_p)		= { "dpll", "gpll", "xin24m" };
-PNAME(mux_cvbs_src_p)		= { "apll", "io_cvbs_clkin", "hdmiphy", "gpll" };
-
-static struct rockchip_pll_clock rv1108_pll_clks[] __initdata = {
-	[apll] = PLL(pll_rk3399, PLL_APLL, "apll", mux_pll_p, 0, RV1108_PLL_CON(0),
-		     RV1108_PLL_CON(3), 8, 0, 0, rv1108_pll_rates),
-	[dpll] = PLL(pll_rk3399, PLL_DPLL, "dpll", mux_pll_p, 0, RV1108_PLL_CON(8),
-		     RV1108_PLL_CON(11), 8, 1, 0, NULL),
-	[gpll] = PLL(pll_rk3399, PLL_GPLL, "gpll", mux_pll_p, 0, RV1108_PLL_CON(16),
-		     RV1108_PLL_CON(19), 8, 2, 0, rv1108_pll_rates),
-};
-
-#define MFLAGS CLK_MUX_HIWORD_MASK
-#define DFLAGS CLK_DIVIDER_HIWORD_MASK
-#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
-#define IFLAGS ROCKCHIP_INVERTER_HIWORD_MASK
-
-static struct rockchip_clk_branch rv1108_uart0_fracmux __initdata =
-	MUX(SCLK_UART0, "sclk_uart0", mux_uart0_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(13), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rv1108_uart1_fracmux __initdata =
-	MUX(SCLK_UART1, "sclk_uart1", mux_uart1_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(14), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rv1108_uart2_fracmux __initdata =
-	MUX(SCLK_UART2, "sclk_uart2", mux_uart2_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(15), 8, 2, MFLAGS);
-
-static struct rockchip_clk_branch rv1108_i2s0_fracmux __initdata =
-	MUX(0, "i2s0_pre", mux_i2s0_pre_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(5), 12, 2, MFLAGS);
-
-static struct rockchip_clk_branch rv1108_i2s1_fracmux __initdata =
-	MUX(0, "i2s1_pre", mux_i2s1_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(6), 12, 2, MFLAGS);
-
-static struct rockchip_clk_branch rv1108_i2s2_fracmux __initdata =
-	MUX(0, "i2s2_pre", mux_i2s2_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(7), 12, 2, MFLAGS);
-
-static struct rockchip_clk_branch rv1108_clk_branches[] __initdata = {
-	MUX(0, "hdmiphy", mux_hdmiphy_phy_p, CLK_SET_RATE_PARENT,
-			RV1108_MISC_CON, 13, 1, MFLAGS),
-	MUX(0, "usb480m", mux_usb480m_pre_p, CLK_SET_RATE_PARENT,
-			RV1108_MISC_CON, 15, 1, MFLAGS),
-	/*
-	 * Clock-Architecture Diagram 2
-	 */
-
-	/* PD_CORE */
-	GATE(0, "dpll_core", "dpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "apll_core", "apll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 0, GFLAGS),
-	GATE(0, "gpll_core", "gpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 2, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclken_dbg", "armclk", CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(1), 4, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RV1108_CLKGATE_CON(0), 5, GFLAGS),
-	COMPOSITE_NOMUX(ACLK_ENMCORE, "aclkenm_core", "armclk", CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(1), 0, 3, DFLAGS | CLK_DIVIDER_READ_ONLY,
-			RV1108_CLKGATE_CON(0), 4, GFLAGS),
-	GATE(ACLK_CORE, "aclk_core", "aclkenm_core", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(11), 0, GFLAGS),
-	GATE(0, "pclk_dbg", "pclken_dbg", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(11), 1, GFLAGS),
-
-	/* PD_RKVENC */
-	COMPOSITE(0, "aclk_rkvenc_pre", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(37), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 8, GFLAGS),
-	FACTOR_GATE(0, "hclk_rkvenc_pre", "aclk_rkvenc_pre", 0, 1, 4,
-			RV1108_CLKGATE_CON(8), 10, GFLAGS),
-	COMPOSITE(SCLK_VENC_CORE, "clk_venc_core", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(37), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 9, GFLAGS),
-	GATE(ACLK_RKVENC, "aclk_rkvenc", "aclk_rkvenc_pre", 0,
-			RV1108_CLKGATE_CON(19), 8, GFLAGS),
-	GATE(HCLK_RKVENC, "hclk_rkvenc", "hclk_rkvenc_pre", 0,
-			RV1108_CLKGATE_CON(19), 9, GFLAGS),
-	GATE(0, "aclk_rkvenc_niu", "aclk_rkvenc_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(19), 11, GFLAGS),
-	GATE(0, "hclk_rkvenc_niu", "hclk_rkvenc_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(19), 10, GFLAGS),
-
-	/* PD_RKVDEC */
-	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(36), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 2, GFLAGS),
-	FACTOR_GATE(0, "hclk_rkvdec_pre", "sclk_hevc_core", 0, 1, 4,
-			RV1108_CLKGATE_CON(8), 10, GFLAGS),
-	COMPOSITE(SCLK_HEVC_CABAC, "clk_hevc_cabac", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(35), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 1, GFLAGS),
-
-	COMPOSITE(0, "aclk_rkvdec_pre", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(35), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 0, GFLAGS),
-	COMPOSITE(0, "aclk_vpu_pre", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(36), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 3, GFLAGS),
-	GATE(ACLK_RKVDEC, "aclk_rkvdec", "aclk_rkvdec_pre", 0,
-			RV1108_CLKGATE_CON(19), 0, GFLAGS),
-	GATE(ACLK_VPU, "aclk_vpu", "aclk_vpu_pre", 0,
-			RV1108_CLKGATE_CON(19), 1, GFLAGS),
-	GATE(HCLK_RKVDEC, "hclk_rkvdec", "hclk_rkvdec_pre", 0,
-			RV1108_CLKGATE_CON(19), 2, GFLAGS),
-	GATE(HCLK_VPU, "hclk_vpu", "hclk_rkvdec_pre", 0,
-			RV1108_CLKGATE_CON(19), 3, GFLAGS),
-	GATE(0, "aclk_rkvdec_niu", "aclk_rkvdec_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(19), 4, GFLAGS),
-	GATE(0, "hclk_rkvdec_niu", "hclk_rkvdec_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(19), 5, GFLAGS),
-	GATE(0, "aclk_vpu_niu", "aclk_vpu_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(19), 6, GFLAGS),
-
-	/* PD_PMU_wrapper */
-	COMPOSITE_NOMUX(0, "pmu_24m_ena", "gpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(38), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(8), 12, GFLAGS),
-	GATE(0, "pclk_pmu", "pmu_24m_ena", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(10), 0, GFLAGS),
-	GATE(0, "pclk_intmem1", "pmu_24m_ena", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(10), 1, GFLAGS),
-	GATE(PCLK_GPIO0_PMU, "pclk_gpio0_pmu", "pmu_24m_ena", 0,
-			RV1108_CLKGATE_CON(10), 2, GFLAGS),
-	GATE(0, "pclk_pmugrf", "pmu_24m_ena", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(10), 3, GFLAGS),
-	GATE(0, "pclk_pmu_niu", "pmu_24m_ena", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(10), 4, GFLAGS),
-	GATE(PCLK_I2C0_PMU, "pclk_i2c0_pmu", "pmu_24m_ena", 0,
-			RV1108_CLKGATE_CON(10), 5, GFLAGS),
-	GATE(PCLK_PWM0_PMU, "pclk_pwm0_pmu", "pmu_24m_ena", 0,
-			RV1108_CLKGATE_CON(10), 6, GFLAGS),
-	COMPOSITE(SCLK_PWM0_PMU, "sclk_pwm0_pmu", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(12), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(8), 15, GFLAGS),
-	COMPOSITE(SCLK_I2C0_PMU, "sclk_i2c0_pmu", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(19), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(8), 14, GFLAGS),
-	GATE(0, "pvtm_pmu", "xin24m", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(8), 13, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 3
-	 */
-	COMPOSITE(SCLK_WIFI, "sclk_wifi", mux_wifi_src_p, 0,
-			RV1108_CLKSEL_CON(28), 15, 1, MFLAGS, 8, 6, DFLAGS,
-			RV1108_CLKGATE_CON(9), 8, GFLAGS),
-	COMPOSITE_NODIV(0, "sclk_cifout_src", mux_cifout_src_p, 0,
-			RV1108_CLKSEL_CON(40), 8, 1, MFLAGS,
-			RV1108_CLKGATE_CON(9), 11, GFLAGS),
-	COMPOSITE_NOGATE(SCLK_CIFOUT, "sclk_cifout", mux_cifout_p, 0,
-			RV1108_CLKSEL_CON(40), 12, 1, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(SCLK_MIPI_CSI_OUT, "sclk_mipi_csi_out", "xin24m", 0,
-			RV1108_CLKSEL_CON(41), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 12, GFLAGS),
-
-	GATE(0, "pclk_acodecphy", "pclk_top_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 6, GFLAGS),
-	GATE(0, "pclk_usbgrf", "pclk_top_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 14, GFLAGS),
-
-	GATE(ACLK_CIF0, "aclk_cif0", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(18), 10, GFLAGS),
-	GATE(HCLK_CIF0, "hclk_cif0", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 10, GFLAGS),
-	COMPOSITE_NODIV(SCLK_CIF0, "sclk_cif0", mux_sclk_cif0_src_p, 0,
-			RV1108_CLKSEL_CON(31), 0, 2, MFLAGS,
-			RV1108_CLKGATE_CON(7), 9, GFLAGS),
-	GATE(ACLK_CIF1, "aclk_cif1", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(17), 6, GFLAGS),
-	GATE(HCLK_CIF1, "hclk_cif1", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(17), 7, GFLAGS),
-	COMPOSITE_NODIV(SCLK_CIF1, "sclk_cif1", mux_sclk_cif1_src_p, 0,
-			RV1108_CLKSEL_CON(31), 2, 2, MFLAGS,
-			RV1108_CLKGATE_CON(7), 10, GFLAGS),
-	GATE(ACLK_CIF2, "aclk_cif2", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(17), 8, GFLAGS),
-	GATE(HCLK_CIF2, "hclk_cif2", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(17), 9, GFLAGS),
-	COMPOSITE_NODIV(SCLK_CIF2, "sclk_cif2", mux_sclk_cif2_src_p, 0,
-			RV1108_CLKSEL_CON(31), 4, 2, MFLAGS,
-			RV1108_CLKGATE_CON(7), 11, GFLAGS),
-	GATE(ACLK_CIF3, "aclk_cif3", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(17), 10, GFLAGS),
-	GATE(HCLK_CIF3, "hclk_cif3", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(17), 11, GFLAGS),
-	COMPOSITE_NODIV(SCLK_CIF3, "sclk_cif3", mux_sclk_cif3_src_p, 0,
-			RV1108_CLKSEL_CON(31), 6, 2, MFLAGS,
-			RV1108_CLKGATE_CON(7), 12, GFLAGS),
-	GATE(0, "pclk_cif1to4", "pclk_vip", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(7), 8, GFLAGS),
-
-	/* PD_DSP_wrapper */
-	COMPOSITE(SCLK_DSP, "sclk_dsp", mux_dsp_src_p, 0,
-			RV1108_CLKSEL_CON(42), 8, 2, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 0, GFLAGS),
-	GATE(0, "clk_dsp_sys_wd", "sclk_dsp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 0, GFLAGS),
-	GATE(0, "clk_dsp_epp_wd", "sclk_dsp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 1, GFLAGS),
-	GATE(0, "clk_dsp_edp_wd", "sclk_dsp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 2, GFLAGS),
-	GATE(0, "clk_dsp_iop_wd", "sclk_dsp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 3, GFLAGS),
-	GATE(0, "clk_dsp_free", "sclk_dsp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 13, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_DSP_IOP, "sclk_dsp_iop", "sclk_dsp", 0,
-			RV1108_CLKSEL_CON(44), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 1, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_DSP_EPP, "sclk_dsp_epp", "sclk_dsp", 0,
-			RV1108_CLKSEL_CON(44), 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 2, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_DSP_EDP, "sclk_dsp_edp", "sclk_dsp", 0,
-			RV1108_CLKSEL_CON(45), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 3, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_DSP_EDAP, "sclk_dsp_edap", "sclk_dsp", 0,
-			RV1108_CLKSEL_CON(45), 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 4, GFLAGS),
-	GATE(0, "pclk_dsp_iop_niu", "sclk_dsp_iop", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 4, GFLAGS),
-	GATE(0, "aclk_dsp_epp_niu", "sclk_dsp_epp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 5, GFLAGS),
-	GATE(0, "aclk_dsp_edp_niu", "sclk_dsp_edp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 6, GFLAGS),
-	GATE(0, "pclk_dsp_dbg_niu", "sclk_dsp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 7, GFLAGS),
-	GATE(0, "aclk_dsp_edap_niu", "sclk_dsp_edap", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 14, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_DSP_PFM, "sclk_dsp_pfm", "sclk_dsp", 0,
-			RV1108_CLKSEL_CON(43), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 5, GFLAGS),
-	COMPOSITE_NOMUX(PCLK_DSP_CFG, "pclk_dsp_cfg", "sclk_dsp", 0,
-			RV1108_CLKSEL_CON(43), 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(9), 6, GFLAGS),
-	GATE(0, "pclk_dsp_cfg_niu", "pclk_dsp_cfg", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 8, GFLAGS),
-	GATE(0, "pclk_dsp_pfm_mon", "pclk_dsp_cfg", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 9, GFLAGS),
-	GATE(0, "pclk_intc", "pclk_dsp_cfg", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 10, GFLAGS),
-	GATE(0, "pclk_dsp_grf", "pclk_dsp_cfg", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 11, GFLAGS),
-	GATE(0, "pclk_mailbox", "pclk_dsp_cfg", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 12, GFLAGS),
-	GATE(0, "aclk_dsp_epp_perf", "sclk_dsp_epp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(16), 15, GFLAGS),
-	GATE(0, "aclk_dsp_edp_perf", "sclk_dsp_edp", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(11), 8, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 4
-	 */
-	COMPOSITE(0, "aclk_vio0_pre", mux_pll_src_4plls_p, CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(28), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(6), 0, GFLAGS),
-	GATE(ACLK_VIO0, "aclk_vio0", "aclk_vio0_pre", 0,
-			RV1108_CLKGATE_CON(17), 0, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_vio_pre", "aclk_vio0_pre", 0,
-			RV1108_CLKSEL_CON(29), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(7), 2, GFLAGS),
-	GATE(HCLK_VIO, "hclk_vio", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(17), 2, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_vio_pre", "aclk_vio0_pre", 0,
-			RV1108_CLKSEL_CON(29), 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(7), 3, GFLAGS),
-	GATE(PCLK_VIO, "pclk_vio", "pclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(17), 3, GFLAGS),
-	COMPOSITE(0, "aclk_vio1_pre", mux_pll_src_4plls_p, CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(28), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(6), 1, GFLAGS),
-	GATE(ACLK_VIO1, "aclk_vio1", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(17), 1, GFLAGS),
-
-	INVERTER(0, "pclk_vip", "ext_vip",
-			RV1108_CLKSEL_CON(31), 8, IFLAGS),
-	GATE(0, "pclk_isp_pre", "pclk_vip", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(7), 6, GFLAGS),
-	GATE(0, "pclk_isp", "pclk_isp_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(18), 10, GFLAGS),
-	GATE(0, "dclk_hdmiphy_src_gpll", "gpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(6), 5, GFLAGS),
-	GATE(0, "dclk_hdmiphy_src_dpll", "dpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(6), 4, GFLAGS),
-	COMPOSITE_NOGATE(0, "dclk_hdmiphy_pre", mux_dclk_hdmiphy_pre_p, 0,
-			RV1108_CLKSEL_CON(32), 6, 1, MFLAGS, 8, 6, DFLAGS),
-	COMPOSITE_NOGATE(DCLK_VOP_SRC, "dclk_vop_src", mux_dclk_hdmiphy_pre_p, 0,
-			RV1108_CLKSEL_CON(32), 6, 1, MFLAGS, 0, 6, DFLAGS),
-	MUX(DCLK_HDMIPHY, "dclk_hdmiphy", mux_dclk_hdmiphy_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(32), 15, 1, MFLAGS),
-	MUX(DCLK_VOP, "dclk_vop", mux_dclk_vop_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(32), 7, 1, MFLAGS),
-	GATE(ACLK_VOP, "aclk_vop", "aclk_vio0_pre", 0,
-			RV1108_CLKGATE_CON(18), 0, GFLAGS),
-	GATE(HCLK_VOP, "hclk_vop", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 1, GFLAGS),
-	GATE(ACLK_IEP, "aclk_iep", "aclk_vio0_pre", 0,
-			RV1108_CLKGATE_CON(18), 2, GFLAGS),
-	GATE(HCLK_IEP, "hclk_iep", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 3, GFLAGS),
-
-	GATE(ACLK_RGA, "aclk_rga", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(18), 4, GFLAGS),
-	GATE(HCLK_RGA, "hclk_rga", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 5, GFLAGS),
-	COMPOSITE(SCLK_RGA, "sclk_rga", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(33), 6, 2, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(6), 6, GFLAGS),
-
-	COMPOSITE(SCLK_CVBS_HOST, "sclk_cvbs_host", mux_cvbs_src_p, 0,
-			RV1108_CLKSEL_CON(33), 13, 2, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(6), 7, GFLAGS),
-	FACTOR(0, "sclk_cvbs_27m", "sclk_cvbs_host", 0, 1, 2),
-
-	GATE(SCLK_HDMI_SFR, "sclk_hdmi_sfr", "xin24m", 0,
-			RV1108_CLKGATE_CON(6), 8, GFLAGS),
-
-	COMPOSITE(SCLK_HDMI_CEC, "sclk_hdmi_cec", mux_hdmi_cec_src_p, 0,
-			RV1108_CLKSEL_CON(34), 14, 2, MFLAGS, 0, 14, DFLAGS,
-			RV1108_CLKGATE_CON(6), 9, GFLAGS),
-	GATE(PCLK_MIPI_DSI, "pclk_mipi_dsi", "pclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 8, GFLAGS),
-	GATE(PCLK_HDMI_CTRL, "pclk_hdmi_ctrl", "pclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 9, GFLAGS),
-
-	GATE(ACLK_ISP, "aclk_isp", "aclk_vio1_pre", 0,
-			RV1108_CLKGATE_CON(18), 12, GFLAGS),
-	GATE(HCLK_ISP, "hclk_isp", "hclk_vio_pre", 0,
-			RV1108_CLKGATE_CON(18), 11, GFLAGS),
-	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_4plls_p, 0,
-			RV1108_CLKSEL_CON(30), 14, 2, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(6), 3, GFLAGS),
-
-	GATE(0, "clk_dsiphy24m", "xin24m", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(9), 10, GFLAGS),
-	GATE(0, "pclk_vdacphy", "pclk_top_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 9, GFLAGS),
-	GATE(0, "pclk_mipi_dsiphy", "pclk_top_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 11, GFLAGS),
-	GATE(0, "pclk_mipi_csiphy", "pclk_top_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 12, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 5
-	 */
-
-	FACTOR(0, "xin12m", "xin24m", 0, 1, 2),
-
-
-	COMPOSITE(SCLK_I2S0_SRC, "i2s0_src", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(5), 8, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s0_frac", "i2s0_src", CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(8), 0,
-			RV1108_CLKGATE_CON(2), 1, GFLAGS,
-			&rv1108_i2s0_fracmux),
-	GATE(SCLK_I2S0, "sclk_i2s0", "i2s0_pre", CLK_SET_RATE_PARENT,
-			RV1108_CLKGATE_CON(2), 2, GFLAGS),
-	COMPOSITE_NODIV(0, "i2s_out", mux_i2s_out_p, 0,
-			RV1108_CLKSEL_CON(5), 15, 1, MFLAGS,
-			RV1108_CLKGATE_CON(2), 3, GFLAGS),
-
-	COMPOSITE(SCLK_I2S1_SRC, "i2s1_src", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(6), 8, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(2), 4, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s1_frac", "i2s1_src", CLK_SET_RATE_PARENT,
-			RK2928_CLKSEL_CON(9), 0,
-			RK2928_CLKGATE_CON(2), 5, GFLAGS,
-			&rv1108_i2s1_fracmux),
-	GATE(SCLK_I2S1, "sclk_i2s1", "i2s1_pre", CLK_SET_RATE_PARENT,
-			RV1108_CLKGATE_CON(2), 6, GFLAGS),
-
-	COMPOSITE(SCLK_I2S2_SRC, "i2s2_src", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(7), 8, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 8, GFLAGS),
-	COMPOSITE_FRACMUX(0, "i2s2_frac", "i2s2_src", CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(10), 0,
-			RV1108_CLKGATE_CON(2), 9, GFLAGS,
-			&rv1108_i2s2_fracmux),
-	GATE(SCLK_I2S2, "sclk_i2s2", "i2s2_pre", CLK_SET_RATE_PARENT,
-			RV1108_CLKGATE_CON(2), 10, GFLAGS),
-
-	/* PD_BUS */
-	GATE(0, "aclk_bus_src_gpll", "gpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(1), 0, GFLAGS),
-	GATE(0, "aclk_bus_src_apll", "apll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(1), 1, GFLAGS),
-	GATE(0, "aclk_bus_src_dpll", "dpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(1), 2, GFLAGS),
-	COMPOSITE_NOGATE(ACLK_PRE, "aclk_bus_pre", mux_aclk_bus_src_p, 0,
-			RV1108_CLKSEL_CON(2), 8, 2, MFLAGS, 0, 5, DFLAGS),
-	COMPOSITE_NOMUX(HCLK_BUS, "hclk_bus_pre", "aclk_bus_pre", 0,
-			RV1108_CLKSEL_CON(3), 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(1), 4, GFLAGS),
-	COMPOSITE_NOMUX(0, "pclk_bus_pre", "aclk_bus_pre", 0,
-			RV1108_CLKSEL_CON(3), 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(1), 5, GFLAGS),
-	GATE(PCLK_BUS, "pclk_bus", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(1), 6, GFLAGS),
-	GATE(0, "pclk_top_pre", "pclk_bus_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(1), 7, GFLAGS),
-	GATE(0, "pclk_ddr_pre", "pclk_bus_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(1), 8, GFLAGS),
-	GATE(SCLK_TIMER0, "clk_timer0", "xin24m", 0,
-			RV1108_CLKGATE_CON(1), 9, GFLAGS),
-	GATE(SCLK_TIMER1, "clk_timer1", "xin24m", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(1), 10, GFLAGS),
-	GATE(PCLK_TIMER, "pclk_timer", "pclk_bus_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(13), 4, GFLAGS),
-
-	GATE(HCLK_I2S0_8CH, "hclk_i2s0_8ch", "hclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 7, GFLAGS),
-	GATE(HCLK_I2S1_2CH, "hclk_i2s1_2ch", "hclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 8, GFLAGS),
-	GATE(HCLK_I2S2_2CH, "hclk_i2s2_2ch", "hclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 9, GFLAGS),
-
-	GATE(HCLK_CRYPTO_MST, "hclk_crypto_mst", "hclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 10, GFLAGS),
-	GATE(HCLK_CRYPTO_SLV, "hclk_crypto_slv", "hclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 11, GFLAGS),
-	COMPOSITE(SCLK_CRYPTO, "sclk_crypto", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(11), 7, 1, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(2), 12, GFLAGS),
-
-	COMPOSITE(SCLK_SPI, "sclk_spi", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(11), 15, 1, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(3), 0, GFLAGS),
-	GATE(PCLK_SPI, "pclk_spi", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 5, GFLAGS),
-
-	COMPOSITE(SCLK_UART0_SRC, "uart0_src", mux_pll_src_dpll_gpll_usb480m_p, CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(13), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 1, GFLAGS),
-	COMPOSITE(SCLK_UART1_SRC, "uart1_src", mux_pll_src_dpll_gpll_usb480m_p, CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(14), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 3, GFLAGS),
-	COMPOSITE(SCLK_UART2_SRC, "uart2_src", mux_pll_src_dpll_gpll_usb480m_p, CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(15), 12, 2, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 5, GFLAGS),
-
-	COMPOSITE_FRACMUX(0, "uart0_frac", "uart0_src", CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(16), 0,
-			RV1108_CLKGATE_CON(3), 2, GFLAGS,
-			&rv1108_uart0_fracmux),
-	COMPOSITE_FRACMUX(0, "uart1_frac", "uart1_src", CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(17), 0,
-			RV1108_CLKGATE_CON(3), 4, GFLAGS,
-			&rv1108_uart1_fracmux),
-	COMPOSITE_FRACMUX(0, "uart2_frac", "uart2_src", CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(18), 0,
-			RV1108_CLKGATE_CON(3), 6, GFLAGS,
-			&rv1108_uart2_fracmux),
-	GATE(PCLK_UART0, "pclk_uart0", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 10, GFLAGS),
-	GATE(PCLK_UART1, "pclk_uart1", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 11, GFLAGS),
-	GATE(PCLK_UART2, "pclk_uart2", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 12, GFLAGS),
-
-	COMPOSITE(SCLK_I2C1, "clk_i2c1", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(19), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 7, GFLAGS),
-	COMPOSITE(SCLK_I2C2, "clk_i2c2", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(20), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 8, GFLAGS),
-	COMPOSITE(SCLK_I2C3, "clk_i2c3", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(20), 15, 1, MFLAGS, 8, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 9, GFLAGS),
-	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 0, GFLAGS),
-	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 1, GFLAGS),
-	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 2, GFLAGS),
-	COMPOSITE(SCLK_PWM, "clk_pwm", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(12), 15, 2, MFLAGS, 8, 7, DFLAGS,
-			RV1108_CLKGATE_CON(3), 10, GFLAGS),
-	GATE(PCLK_PWM, "pclk_pwm", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 6, GFLAGS),
-	GATE(PCLK_WDT, "pclk_wdt", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 3, GFLAGS),
-	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 7, GFLAGS),
-	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 8, GFLAGS),
-	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 9, GFLAGS),
-
-	GATE(0, "pclk_grf", "pclk_bus_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 0, GFLAGS),
-	GATE(PCLK_EFUSE0, "pclk_efuse0", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 12, GFLAGS),
-	GATE(PCLK_EFUSE1, "pclk_efuse1", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(12), 13, GFLAGS),
-	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 13, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_TSADC, "sclk_tsadc", "xin24m", 0,
-			RV1108_CLKSEL_CON(21), 0, 10, DFLAGS,
-			RV1108_CLKGATE_CON(3), 11, GFLAGS),
-	GATE(PCLK_SARADC, "pclk_saradc", "pclk_bus_pre", 0,
-			RV1108_CLKGATE_CON(13), 14, GFLAGS),
-	COMPOSITE_NOMUX(SCLK_SARADC, "sclk_saradc", "xin24m", 0,
-			RV1108_CLKSEL_CON(22), 0, 10, DFLAGS,
-			RV1108_CLKGATE_CON(3), 12, GFLAGS),
-
-	GATE(ACLK_DMAC, "aclk_dmac", "aclk_bus_pre", 0,
-	     RV1108_CLKGATE_CON(12), 2, GFLAGS),
-	GATE(0, "hclk_rom", "hclk_bus_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(12), 3, GFLAGS),
-	GATE(0, "aclk_intmem", "aclk_bus_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(12), 1, GFLAGS),
-
-	/* PD_DDR */
-	GATE(0, "apll_ddr", "apll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 8, GFLAGS),
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 9, GFLAGS),
-	GATE(0, "gpll_ddr", "gpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 10, GFLAGS),
-	COMPOSITE_NOGATE(0, "clk_ddrphy_src", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RV1108_CLKSEL_CON(4), 8, 2, MFLAGS, 0, 3,
-			DFLAGS | CLK_DIVIDER_POWER_OF_TWO),
-	FACTOR(0, "clk_ddr", "clk_ddrphy_src", 0, 1, 2),
-	GATE(0, "clk_ddrphy4x", "clk_ddr", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(10), 9, GFLAGS),
-	GATE(0, "pclk_ddrupctl", "pclk_ddr_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(12), 4, GFLAGS),
-	GATE(0, "nclk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(12), 5, GFLAGS),
-	GATE(0, "pclk_ddrmon", "pclk_ddr_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(12), 6, GFLAGS),
-	GATE(0, "timer_clk", "xin24m", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(0), 11, GFLAGS),
-	GATE(0, "pclk_mschniu", "pclk_ddr_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 2, GFLAGS),
-	GATE(0, "pclk_ddrphy", "pclk_ddr_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(14), 4, GFLAGS),
-
-	/*
-	 * Clock-Architecture Diagram 6
-	 */
-
-	/* PD_PERI */
-	COMPOSITE_NOMUX(0, "pclk_periph_pre", "gpll", 0,
-			RV1108_CLKSEL_CON(23), 10, 5, DFLAGS,
-			RV1108_CLKGATE_CON(4), 5, GFLAGS),
-	GATE(PCLK_PERI, "pclk_periph", "pclk_periph_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(15), 13, GFLAGS),
-	COMPOSITE_NOMUX(0, "hclk_periph_pre", "gpll", 0,
-			RV1108_CLKSEL_CON(23), 5, 5, DFLAGS,
-			RV1108_CLKGATE_CON(4), 4, GFLAGS),
-	GATE(HCLK_PERI, "hclk_periph", "hclk_periph_pre", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(15), 12, GFLAGS),
-
-	GATE(0, "aclk_peri_src_dpll", "dpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(4), 1, GFLAGS),
-	GATE(0, "aclk_peri_src_gpll", "gpll", CLK_IGNORE_UNUSED,
-			RV1108_CLKGATE_CON(4), 2, GFLAGS),
-	COMPOSITE(ACLK_PERI, "aclk_periph", mux_aclk_peri_src_p, 0,
-			RV1108_CLKSEL_CON(23), 15, 1, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(15), 11, GFLAGS),
-
-	COMPOSITE(SCLK_SDMMC, "sclk_sdmmc", mux_mmc_src_p, 0,
-			RV1108_CLKSEL_CON(25), 8, 2, MFLAGS, 0, 8, DFLAGS,
-			RV1108_CLKGATE_CON(5), 0, GFLAGS),
-
-	COMPOSITE_NODIV(0, "sclk_sdio_src", mux_mmc_src_p, 0,
-			RV1108_CLKSEL_CON(25), 10, 2, MFLAGS,
-			RV1108_CLKGATE_CON(5), 2, GFLAGS),
-	DIV(SCLK_SDIO, "sclk_sdio", "sclk_sdio_src", 0,
-			RV1108_CLKSEL_CON(26), 0, 8, DFLAGS),
-
-	COMPOSITE_NODIV(0, "sclk_emmc_src", mux_mmc_src_p, 0,
-			RV1108_CLKSEL_CON(25), 12, 2, MFLAGS,
-			RV1108_CLKGATE_CON(5), 1, GFLAGS),
-	DIV(SCLK_EMMC, "sclk_emmc", "sclk_emmc_src", 0,
-			RK2928_CLKSEL_CON(26), 8, 8, DFLAGS),
-	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 0, GFLAGS),
-	GATE(HCLK_SDIO, "hclk_sdio", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 1, GFLAGS),
-	GATE(HCLK_EMMC, "hclk_emmc", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 2, GFLAGS),
-
-	COMPOSITE(SCLK_NANDC, "sclk_nandc", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(27), 14, 1, MFLAGS, 8, 5, DFLAGS,
-			RV1108_CLKGATE_CON(5), 3, GFLAGS),
-	GATE(HCLK_NANDC, "hclk_nandc", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 3, GFLAGS),
-
-	GATE(HCLK_HOST0, "hclk_host0", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 6, GFLAGS),
-	GATE(0, "hclk_host0_arb", "hclk_periph", CLK_IGNORE_UNUSED, RV1108_CLKGATE_CON(15), 7, GFLAGS),
-	GATE(HCLK_OTG, "hclk_otg", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 8, GFLAGS),
-	GATE(0, "hclk_otg_pmu", "hclk_periph", CLK_IGNORE_UNUSED, RV1108_CLKGATE_CON(15), 9, GFLAGS),
-	GATE(SCLK_USBPHY, "clk_usbphy", "xin24m", CLK_IGNORE_UNUSED, RV1108_CLKGATE_CON(5), 5, GFLAGS),
-
-	COMPOSITE(SCLK_SFC, "sclk_sfc", mux_pll_src_2plls_p, 0,
-			RV1108_CLKSEL_CON(27), 7, 1, MFLAGS, 0, 7, DFLAGS,
-			RV1108_CLKGATE_CON(5), 4, GFLAGS),
-	GATE(HCLK_SFC, "hclk_sfc", "hclk_periph", 0, RV1108_CLKGATE_CON(15), 10, GFLAGS),
-
-	COMPOSITE(SCLK_MAC_PRE, "sclk_mac_pre", mux_pll_src_apll_gpll_p, 0,
-			RV1108_CLKSEL_CON(24), 12, 1, MFLAGS, 0, 5, DFLAGS,
-			RV1108_CLKGATE_CON(4), 10, GFLAGS),
-	MUX(SCLK_MAC, "sclk_mac", mux_sclk_mac_p, CLK_SET_RATE_PARENT,
-			RV1108_CLKSEL_CON(24), 8, 1, MFLAGS),
-	GATE(SCLK_MAC_RX, "sclk_mac_rx", "sclk_mac", 0, RV1108_CLKGATE_CON(4), 8, GFLAGS),
-	GATE(SCLK_MAC_REF, "sclk_mac_ref", "sclk_mac", 0, RV1108_CLKGATE_CON(4), 6, GFLAGS),
-	GATE(SCLK_MAC_REFOUT, "sclk_mac_refout", "sclk_mac", 0, RV1108_CLKGATE_CON(4), 7, GFLAGS),
-	GATE(ACLK_GMAC, "aclk_gmac", "aclk_periph", 0, RV1108_CLKGATE_CON(15), 4, GFLAGS),
-	GATE(PCLK_GMAC, "pclk_gmac", "pclk_periph", 0, RV1108_CLKGATE_CON(15), 5, GFLAGS),
-
-	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RV1108_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RV1108_SDMMC_CON1, 1),
-
-	MMC(SCLK_SDIO_DRV,     "sdio_drv",     "sclk_sdio",  RV1108_SDIO_CON0,  1),
-	MMC(SCLK_SDIO_SAMPLE,  "sdio_sample",  "sclk_sdio",  RV1108_SDIO_CON1,  1),
-
-	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RV1108_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RV1108_EMMC_CON1,  1),
-};
-
-static const char *const rv1108_critical_clocks[] __initconst = {
-	"aclk_core",
-	"aclk_bus",
-	"hclk_bus",
-	"pclk_bus",
-	"aclk_periph",
-	"hclk_periph",
-	"pclk_periph",
-	"nclk_ddrupctl",
-	"pclk_ddrmon",
-	"pclk_acodecphy",
-	"pclk_pmu",
-};
-
-static void __init rv1108_clk_init(struct device_node *np)
-{
-	struct rockchip_clk_provider *ctx;
-	void __iomem *reg_base;
-
-	reg_base = of_iomap(np, 0);
-	if (!reg_base) {
-		pr_err("%s: could not map cru region\n", __func__);
-		return;
-	}
-
-	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
-	if (IS_ERR(ctx)) {
-		pr_err("%s: rockchip clk init failed\n", __func__);
-		iounmap(reg_base);
-		return;
-	}
-
-	rockchip_clk_register_plls(ctx, rv1108_pll_clks,
-				   ARRAY_SIZE(rv1108_pll_clks),
-				   RV1108_GRF_SOC_STATUS0);
-	rockchip_clk_register_branches(ctx, rv1108_clk_branches,
-				  ARRAY_SIZE(rv1108_clk_branches));
-	rockchip_clk_protect_critical(rv1108_critical_clocks,
-				      ARRAY_SIZE(rv1108_critical_clocks));
-
-	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
-			mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
-			&rv1108_cpuclk_data, rv1108_cpuclk_rates,
-			ARRAY_SIZE(rv1108_cpuclk_rates));
-
-	rockchip_register_softrst(np, 13, reg_base + RV1108_SOFTRST_CON(0),
-				  ROCKCHIP_SOFTRST_HIWORD_MASK);
-
-	rockchip_register_restart_notifier(ctx, RV1108_GLB_SRST_FST, NULL);
-
-	rockchip_clk_of_add_provider(np, ctx);
-}
-CLK_OF_DECLARE(rv1108_cru, "rockchip,rv1108-cru", rv1108_clk_init);
diff --git a/drivers/clk/rockchip/clk.c b/drivers/clk/rockchip/clk.c
index c3ad92965..06769a020 100644
--- a/drivers/clk/rockchip/clk.c
+++ b/drivers/clk/rockchip/clk.c
@@ -46,7 +46,8 @@ static struct clk *rockchip_clk_register_branch(const char *name,
 		const char *const *parent_names, u8 num_parents,
 		void __iomem *base,
 		int muxdiv_offset, u8 mux_shift, u8 mux_width, u8 mux_flags,
-		u8 div_shift, u8 div_width, u8 div_flags,
+		u32 *mux_table,
+		int div_offset, u8 div_shift, u8 div_width, u8 div_flags,
 		struct clk_div_table *div_table, int gate_offset,
 		u8 gate_shift, u8 gate_flags, unsigned long flags,
 		spinlock_t *lock)
@@ -68,6 +69,7 @@ static struct clk *rockchip_clk_register_branch(const char *name,
 		mux->shift = mux_shift;
 		mux->mask = BIT(mux_width) - 1;
 		mux->flags = mux_flags;
+		mux->table = mux_table;
 		mux->lock = lock;
 		mux_ops = (mux_flags & CLK_MUX_READ_ONLY) ? &clk_mux_ro_ops
 							: &clk_mux_ops;
@@ -95,7 +97,10 @@ static struct clk *rockchip_clk_register_branch(const char *name,
 		}
 
 		div->flags = div_flags;
-		div->reg = base + muxdiv_offset;
+		if (div_offset)
+			div->reg = base + div_offset;
+		else
+			div->reg = base + muxdiv_offset;
 		div->shift = div_shift;
 		div->width = div_width;
 		div->lock = lock;
@@ -189,12 +194,43 @@ static void rockchip_fractional_approximation(struct clk_hw *hw,
 	unsigned long p_rate, p_parent_rate;
 	struct clk_hw *p_parent;
 	unsigned long scale;
+	u32 div;
 
 	p_rate = clk_hw_get_rate(clk_hw_get_parent(hw));
-	if ((rate * 20 > p_rate) && (p_rate % rate != 0)) {
+	if (((rate * 20 > p_rate) && (p_rate % rate != 0)) ||
+	    (fd->max_prate && fd->max_prate < p_rate)) {
 		p_parent = clk_hw_get_parent(clk_hw_get_parent(hw));
-		p_parent_rate = clk_hw_get_rate(p_parent);
-		*parent_rate = p_parent_rate;
+		if (!p_parent) {
+			*parent_rate = p_rate;
+		} else {
+			p_parent_rate = clk_hw_get_rate(p_parent);
+			*parent_rate = p_parent_rate;
+			if (fd->max_prate && p_parent_rate > fd->max_prate) {
+				div = DIV_ROUND_UP(p_parent_rate,
+						   fd->max_prate);
+				*parent_rate = p_parent_rate / div;
+			}
+		}
+
+		if (*parent_rate < rate * 20) {
+			/*
+			 * Fractional frequency divider to do
+			 * integer frequency divider does not
+			 * need 20 times the limit.
+			 */
+			if (!(*parent_rate % rate)) {
+				*m = 1;
+				*n = *parent_rate / rate;
+				return;
+			} else if (!(fd->flags & CLK_FRAC_DIVIDER_NO_LIMIT)) {
+				pr_warn("%s p_rate(%ld) is low than rate(%ld)*20, use integer or half-div\n",
+					clk_hw_get_name(hw),
+					*parent_rate, rate);
+				*m = 0;
+				*n = 1;
+				return;
+			}
+		}
 	}
 
 	/*
@@ -217,7 +253,7 @@ static struct clk *rockchip_clk_register_frac_branch(
 		void __iomem *base, int muxdiv_offset, u8 div_flags,
 		int gate_offset, u8 gate_shift, u8 gate_flags,
 		unsigned long flags, struct rockchip_clk_branch *child,
-		spinlock_t *lock)
+		unsigned long max_prate, spinlock_t *lock)
 {
 	struct rockchip_clk_frac *frac;
 	struct clk *clk;
@@ -258,6 +294,7 @@ static struct clk *rockchip_clk_register_frac_branch(
 	div->nmask = GENMASK(div->nwidth - 1, 0) << div->nshift;
 	div->lock = lock;
 	div->approximation = rockchip_fractional_approximation;
+	div->max_prate = max_prate;
 	div_ops = &clk_fractional_divider_ops;
 
 	clk = clk_register_composite(NULL, name, parent_names, num_parents,
@@ -272,7 +309,7 @@ static struct clk *rockchip_clk_register_frac_branch(
 
 	if (child) {
 		struct clk_mux *frac_mux = &frac->mux;
-		struct clk_init_data init;
+		struct clk_init_data init = {};
 		struct clk *mux_clk;
 		int ret;
 
@@ -285,6 +322,8 @@ static struct clk *rockchip_clk_register_frac_branch(
 		frac_mux->shift = child->mux_shift;
 		frac_mux->mask = BIT(child->mux_width) - 1;
 		frac_mux->flags = child->mux_flags;
+		if (child->mux_table)
+			frac_mux->table = child->mux_table;
 		frac_mux->lock = lock;
 		frac_mux->hw.init = &init;
 
@@ -366,6 +405,61 @@ static struct clk *rockchip_clk_register_factor_branch(const char *name,
 	return clk;
 }
 
+static struct clk *rockchip_clk_register_composite_brother_branch(
+		struct rockchip_clk_provider *ctx, const char *name,
+		const char *const *parent_names, u8 num_parents,
+		void __iomem *base, int muxdiv_offset, u8 mux_shift,
+		u8 mux_width, u8 mux_flags, u32 *mux_table,
+		int div_offset, u8 div_shift, u8 div_width, u8 div_flags,
+		struct clk_div_table *div_table, int gate_offset,
+		u8 gate_shift, u8 gate_flags, unsigned long flags,
+		struct rockchip_clk_branch *brother, spinlock_t *lock)
+{
+	struct clk *clk, *brother_clk;
+	struct clk_composite *composite, *brother_composite;
+	struct clk_hw *hw, *brother_hw;
+
+	if (brother && brother->branch_type != branch_half_divider) {
+		pr_err("%s: composite brother for %s can only be a halfdiv\n",
+		       __func__, name);
+		return ERR_PTR(-EINVAL);
+	}
+
+	clk = rockchip_clk_register_branch(name, parent_names, num_parents,
+					   base, muxdiv_offset, mux_shift,
+					   mux_width, mux_flags, mux_table,
+					   div_offset, div_shift, div_width,
+					   div_flags, div_table,
+					   gate_offset, gate_shift, gate_flags,
+					   flags, lock);
+	if (IS_ERR(clk))
+		return clk;
+
+	brother_clk = rockchip_clk_register_halfdiv(brother->name,
+				brother->parent_names, brother->num_parents,
+				base, brother->muxdiv_offset,
+				brother->mux_shift, brother->mux_width,
+				brother->mux_flags, brother->div_offset,
+				brother->div_shift, brother->div_width,
+				brother->div_flags, brother->gate_offset,
+				brother->gate_shift, brother->gate_flags,
+				flags, lock);
+	if (IS_ERR(brother_clk))
+		return brother_clk;
+	rockchip_clk_add_lookup(ctx, brother_clk, brother->id);
+
+	hw = __clk_get_hw(clk);
+	brother_hw = __clk_get_hw(brother_clk);
+	if (hw && brother_hw) {
+		composite = to_clk_composite(hw);
+		brother_composite = to_clk_composite(brother_hw);
+		composite->brother_hw = brother_hw;
+		brother_composite->brother_hw = hw;
+	}
+
+	return clk;
+}
+
 struct rockchip_clk_provider * __init rockchip_clk_init(struct device_node *np,
 			void __iomem *base, unsigned long nr_clks)
 {
@@ -392,6 +486,8 @@ struct rockchip_clk_provider * __init rockchip_clk_init(struct device_node *np,
 
 	ctx->grf = syscon_regmap_lookup_by_phandle(ctx->cru_node,
 						   "rockchip,grf");
+	ctx->pmugrf = syscon_regmap_lookup_by_phandle(ctx->cru_node,
+						   "rockchip,pmugrf");
 
 	return ctx;
 
@@ -454,11 +550,22 @@ void __init rockchip_clk_register_branches(
 		/* catch simple muxes */
 		switch (list->branch_type) {
 		case branch_mux:
-			clk = clk_register_mux(NULL, list->name,
-				list->parent_names, list->num_parents,
-				flags, ctx->reg_base + list->muxdiv_offset,
-				list->mux_shift, list->mux_width,
-				list->mux_flags, &ctx->lock);
+			if (list->mux_table)
+				clk = clk_register_mux_table(NULL, list->name,
+					list->parent_names, list->num_parents,
+					flags,
+					ctx->reg_base + list->muxdiv_offset,
+					list->mux_shift,
+					BIT(list->mux_width) - 1,
+					list->mux_flags, list->mux_table,
+					&ctx->lock);
+			else
+				clk = clk_register_mux(NULL, list->name,
+					list->parent_names, list->num_parents,
+					flags,
+					ctx->reg_base + list->muxdiv_offset,
+					list->mux_shift, list->mux_width,
+					list->mux_flags, &ctx->lock);
 			break;
 		case branch_muxgrf:
 			clk = rockchip_clk_register_muxgrf(list->name,
@@ -467,6 +574,13 @@ void __init rockchip_clk_register_branches(
 				list->mux_shift, list->mux_width,
 				list->mux_flags);
 			break;
+		case branch_muxpmugrf:
+			clk = rockchip_clk_register_muxgrf(list->name,
+				list->parent_names, list->num_parents,
+				flags, ctx->pmugrf, list->muxdiv_offset,
+				list->mux_shift, list->mux_width,
+				list->mux_flags);
+			break;
 		case branch_divider:
 			if (list->div_table)
 				clk = clk_register_divider_table(NULL,
@@ -490,20 +604,22 @@ void __init rockchip_clk_register_branches(
 				list->div_flags,
 				list->gate_offset, list->gate_shift,
 				list->gate_flags, flags, list->child,
-				&ctx->lock);
+				list->max_prate, &ctx->lock);
 			break;
 		case branch_half_divider:
 			clk = rockchip_clk_register_halfdiv(list->name,
 				list->parent_names, list->num_parents,
 				ctx->reg_base, list->muxdiv_offset,
 				list->mux_shift, list->mux_width,
-				list->mux_flags, list->div_shift,
-				list->div_width, list->div_flags,
-				list->gate_offset, list->gate_shift,
-				list->gate_flags, flags, &ctx->lock);
+				list->mux_flags, list->div_offset,
+				list->div_shift, list->div_width,
+				list->div_flags, list->gate_offset,
+				list->gate_shift, list->gate_flags,
+				flags, &ctx->lock);
 			break;
 		case branch_gate:
-			flags |= CLK_SET_RATE_PARENT;
+			if (!(list->gate_flags & CLK_GATE_NO_SET_RATE))
+				flags |= CLK_SET_RATE_PARENT;
 
 			clk = clk_register_gate(NULL, list->name,
 				list->parent_names[0], flags,
@@ -516,11 +632,25 @@ void __init rockchip_clk_register_branches(
 				ctx->reg_base, list->muxdiv_offset,
 				list->mux_shift,
 				list->mux_width, list->mux_flags,
+				list->mux_table, list->div_offset,
 				list->div_shift, list->div_width,
 				list->div_flags, list->div_table,
 				list->gate_offset, list->gate_shift,
 				list->gate_flags, flags, &ctx->lock);
 			break;
+		case branch_composite_brother:
+			clk = rockchip_clk_register_composite_brother_branch(
+				ctx, list->name, list->parent_names,
+				list->num_parents, ctx->reg_base,
+				list->muxdiv_offset, list->mux_shift,
+				list->mux_width, list->mux_flags,
+				list->mux_table, list->div_offset,
+				list->div_shift, list->div_width,
+				list->div_flags, list->div_table,
+				list->gate_offset, list->gate_shift,
+				list->gate_flags, flags, list->child,
+				&ctx->lock);
+			break;
 		case branch_mmc:
 			clk = rockchip_clk_register_mmc(
 				list->name,
@@ -530,11 +660,13 @@ void __init rockchip_clk_register_branches(
 			);
 			break;
 		case branch_inverter:
+#ifdef CONFIG_ROCKCHIP_CLK_INV
 			clk = rockchip_clk_register_inverter(
 				list->name, list->parent_names,
 				list->num_parents,
 				ctx->reg_base + list->muxdiv_offset,
 				list->div_shift, list->div_flags, &ctx->lock);
+#endif
 			break;
 		case branch_factor:
 			clk = rockchip_clk_register_factor_branch(
@@ -551,7 +683,19 @@ void __init rockchip_clk_register_branches(
 				list->muxdiv_offset, list->mux_shift,
 				list->mux_width, list->div_shift,
 				list->div_width, list->div_flags,
-				ctx->reg_base, &ctx->lock);
+				ctx->reg_base);
+			break;
+		case branch_dclk_divider:
+#ifdef CONFIG_ROCKCHIP_DCLK_DIV
+			clk = rockchip_clk_register_dclk_branch(list->name,
+				list->parent_names, list->num_parents,
+				ctx->reg_base, list->muxdiv_offset, list->mux_shift,
+				list->mux_width, list->mux_flags,
+				list->div_offset, list->div_shift, list->div_width,
+				list->div_flags, list->div_table,
+				list->gate_offset, list->gate_shift,
+				list->gate_flags, flags, list->max_prate, &ctx->lock);
+#endif
 			break;
 		}
 
@@ -608,6 +752,21 @@ void __init rockchip_clk_protect_critical(const char *const clocks[],
 	}
 }
 
+void (*rk_dump_cru)(void);
+EXPORT_SYMBOL(rk_dump_cru);
+
+static int rk_clk_panic(struct notifier_block *this,
+			unsigned long ev, void *ptr)
+{
+	if (rk_dump_cru)
+		rk_dump_cru();
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block rk_clk_panic_block = {
+	.notifier_call = rk_clk_panic,
+};
+
 static void __iomem *rst_base;
 static unsigned int reg_restart;
 static void (*cb_restart)(void);
@@ -640,4 +799,6 @@ rockchip_register_restart_notifier(struct rockchip_clk_provider *ctx,
 	if (ret)
 		pr_err("%s: cannot register restart handler, %d\n",
 		       __func__, ret);
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &rk_clk_panic_block);
 }
diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
index 6b53fff4c..45630b5b8 100644
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -46,12 +46,25 @@ struct clk;
 #define BOOST_SWITCH_THRESHOLD		0x0024
 #define BOOST_FSM_STATUS		0x0028
 #define BOOST_PLL_L_CON(x)		((x) * 0x4 + 0x2c)
+#define BOOST_PLL_CON_MASK		0xffff
+#define BOOST_CORE_DIV_MASK		0x1f
+#define BOOST_CORE_DIV_SHIFT		0
+#define BOOST_BACKUP_PLL_MASK		0x3
+#define BOOST_BACKUP_PLL_SHIFT		8
+#define BOOST_BACKUP_PLL_USAGE_MASK	0x1
+#define BOOST_BACKUP_PLL_USAGE_SHIFT	12
+#define BOOST_BACKUP_PLL_USAGE_BORROW	0
+#define BOOST_BACKUP_PLL_USAGE_TARGET	1
+#define BOOST_ENABLE_MASK		0x1
+#define BOOST_ENABLE_SHIFT		0
 #define BOOST_RECOVERY_MASK		0x1
 #define BOOST_RECOVERY_SHIFT		1
 #define BOOST_SW_CTRL_MASK		0x1
 #define BOOST_SW_CTRL_SHIFT		2
 #define BOOST_LOW_FREQ_EN_MASK		0x1
 #define BOOST_LOW_FREQ_EN_SHIFT		3
+#define BOOST_STATIS_ENABLE_MASK	0x1
+#define BOOST_STATIS_ENABLE_SHIFT	4
 #define BOOST_BUSY_STATE		BIT(8)
 
 #define PX30_PLL_CON(x)			((x) * 0x4)
@@ -88,6 +101,51 @@ struct clk;
 #define RV1108_EMMC_CON0		0x1e8
 #define RV1108_EMMC_CON1		0x1ec
 
+#define RV1126_PMU_MODE			0x0
+#define RV1126_PMU_PLL_CON(x)		((x) * 0x4 + 0x10)
+#define RV1126_PMU_CLKSEL_CON(x)	((x) * 0x4 + 0x100)
+#define RV1126_PMU_CLKGATE_CON(x)	((x) * 0x4 + 0x180)
+#define RV1126_PMU_SOFTRST_CON(x)	((x) * 0x4 + 0x200)
+#define RV1126_PLL_CON(x)		((x) * 0x4)
+#define RV1126_MODE_CON			0x90
+#define RV1126_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
+#define RV1126_CLKGATE_CON(x)		((x) * 0x4 + 0x280)
+#define RV1126_SOFTRST_CON(x)		((x) * 0x4 + 0x300)
+#define RV1126_GLB_SRST_FST		0x408
+#define RV1126_GLB_SRST_SND		0x40c
+#define RV1126_SDMMC_CON0		0x440
+#define RV1126_SDMMC_CON1		0x444
+#define RV1126_SDIO_CON0		0x448
+#define RV1126_SDIO_CON1		0x44c
+#define RV1126_EMMC_CON0		0x450
+#define RV1126_EMMC_CON1		0x454
+
+/*
+ * register positions shared by RK1808 RK2928, RK3036,
+ * RK3066, RK3188 and RK3228
+ */
+
+#define RK1808_PLL_CON(x)		((x) * 0x4)
+#define RK1808_MODE_CON			0xa0
+#define RK1808_MISC_CON			0xa4
+#define RK1808_MISC1_CON		0xa8
+#define RK1808_GLB_SRST_FST		0xb8
+#define RK1808_GLB_SRST_SND		0xbc
+#define RK1808_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
+#define RK1808_CLKGATE_CON(x)		((x) * 0x4 + 0x230)
+#define RK1808_SOFTRST_CON(x)		((x) * 0x4 + 0x300)
+#define RK1808_SDMMC_CON0		0x380
+#define RK1808_SDMMC_CON1		0x384
+#define RK1808_SDIO_CON0		0x388
+#define RK1808_SDIO_CON1		0x38c
+#define RK1808_EMMC_CON0		0x390
+#define RK1808_EMMC_CON1		0x394
+
+#define RK1808_PMU_PLL_CON(x)		((x) * 0x4 + 0x4000)
+#define RK1808_PMU_MODE_CON		0x4020
+#define RK1808_PMU_CLKSEL_CON(x)	((x) * 0x4 + 0x4040)
+#define RK1808_PMU_CLKGATE_CON(x)	((x) * 0x4 + 0x4080)
+
 #define RK2928_PLL_CON(x)		((x) * 0x4)
 #define RK2928_MODE_CON		0x40
 #define RK2928_CLKSEL_CON(x)	((x) * 0x4 + 0x44)
@@ -130,6 +188,19 @@ struct clk;
 #define RK3288_EMMC_CON0		0x218
 #define RK3288_EMMC_CON1		0x21c
 
+#define RK3308_PLL_CON(x)		RK2928_PLL_CON(x)
+#define RK3308_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
+#define RK3308_CLKGATE_CON(x)		((x) * 0x4 + 0x300)
+#define RK3308_GLB_SRST_FST		0xb8
+#define RK3308_SOFTRST_CON(x)		((x) * 0x4 + 0x400)
+#define RK3308_MODE_CON			0xa0
+#define RK3308_SDMMC_CON0		0x480
+#define RK3308_SDMMC_CON1		0x484
+#define RK3308_SDIO_CON0		0x488
+#define RK3308_SDIO_CON1		0x48c
+#define RK3308_EMMC_CON0		0x490
+#define RK3308_EMMC_CON1		0x494
+
 #define RK3328_PLL_CON(x)		RK2928_PLL_CON(x)
 #define RK3328_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
 #define RK3328_CLKGATE_CON(x)		((x) * 0x4 + 0x200)
@@ -184,6 +255,34 @@ struct clk;
 #define RK3399_PMU_CLKGATE_CON(x)	((x) * 0x4 + 0x100)
 #define RK3399_PMU_SOFTRST_CON(x)	((x) * 0x4 + 0x110)
 
+#define RK3568_PLL_CON(x)		RK2928_PLL_CON(x)
+#define RK3568_MODE_CON0		0xc0
+#define RK3568_MISC_CON0		0xc4
+#define RK3568_MISC_CON1		0xc8
+#define RK3568_MISC_CON2		0xcc
+#define RK3568_GLB_CNT_TH		0xd0
+#define RK3568_GLB_SRST_FST		0xd4
+#define RK3568_GLB_SRST_SND		0xd8
+#define RK3568_GLB_RST_CON		0xdc
+#define RK3568_GLB_RST_ST		0xe0
+#define RK3568_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
+#define RK3568_CLKGATE_CON(x)		((x) * 0x4 + 0x300)
+#define RK3568_SOFTRST_CON(x)		((x) * 0x4 + 0x400)
+#define RK3568_SDMMC0_CON0		0x580
+#define RK3568_SDMMC0_CON1		0x584
+#define RK3568_SDMMC1_CON0		0x588
+#define RK3568_SDMMC1_CON1		0x58c
+#define RK3568_SDMMC2_CON0		0x590
+#define RK3568_SDMMC2_CON1		0x594
+#define RK3568_EMMC_CON0		0x598
+#define RK3568_EMMC_CON1		0x59c
+
+#define RK3568_PMU_PLL_CON(x)		RK2928_PLL_CON(x)
+#define RK3568_PMU_MODE_CON0		0x80
+#define RK3568_PMU_CLKSEL_CON(x)	((x) * 0x4 + 0x100)
+#define RK3568_PMU_CLKGATE_CON(x)	((x) * 0x4 + 0x180)
+#define RK3568_PMU_SOFTRST_CON(x)	((x) * 0x4 + 0x200)
+
 enum rockchip_pll_type {
 	pll_rk3036,
 	pll_rk3066,
@@ -234,22 +333,30 @@ struct rockchip_clk_provider {
 	struct clk_onecell_data clk_data;
 	struct device_node *cru_node;
 	struct regmap *grf;
+	struct regmap *pmugrf;
 	spinlock_t lock;
 };
 
 struct rockchip_pll_rate_table {
 	unsigned long rate;
-	unsigned int nr;
-	unsigned int nf;
-	unsigned int no;
-	unsigned int nb;
-	/* for RK3036/RK3399 */
-	unsigned int fbdiv;
-	unsigned int postdiv1;
-	unsigned int refdiv;
-	unsigned int postdiv2;
-	unsigned int dsmpd;
-	unsigned int frac;
+	union {
+		struct {
+			/* for RK3066 */
+			unsigned int nr;
+			unsigned int nf;
+			unsigned int no;
+			unsigned int nb;
+		};
+		struct {
+			/* for RK3036/RK3399 */
+			unsigned int fbdiv;
+			unsigned int postdiv1;
+			unsigned int refdiv;
+			unsigned int postdiv2;
+			unsigned int dsmpd;
+			unsigned int frac;
+		};
+	};
 };
 
 /**
@@ -313,35 +420,49 @@ struct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,
 		struct rockchip_pll_rate_table *rate_table,
 		unsigned long flags, u8 clk_pll_flags);
 
+void rockchip_boost_init(struct clk_hw *hw);
+
+void rockchip_boost_enable_recovery_sw_low(struct clk_hw *hw);
+
+void rockchip_boost_disable_recovery_sw(struct clk_hw *hw);
+
+void rockchip_boost_add_core_div(struct clk_hw *hw, unsigned long prate);
+
 struct rockchip_cpuclk_clksel {
 	int reg;
 	u32 val;
 };
 
-#define ROCKCHIP_CPUCLK_NUM_DIVIDERS	2
+#define ROCKCHIP_CPUCLK_NUM_DIVIDERS	5
+#define ROCKCHIP_CPUCLK_MAX_CORES	4
 struct rockchip_cpuclk_rate_table {
 	unsigned long prate;
 	struct rockchip_cpuclk_clksel divs[ROCKCHIP_CPUCLK_NUM_DIVIDERS];
+	struct rockchip_cpuclk_clksel pre_muxs[ROCKCHIP_CPUCLK_NUM_DIVIDERS];
+	struct rockchip_cpuclk_clksel post_muxs[ROCKCHIP_CPUCLK_NUM_DIVIDERS];
 };
 
 /**
  * struct rockchip_cpuclk_reg_data - register offsets and masks of the cpuclock
- * @core_reg:		register offset of the core settings register
- * @div_core_shift:	core divider offset used to divide the pll value
- * @div_core_mask:	core divider mask
- * @mux_core_alt:	mux value to select alternate parent
+ * @core_reg[]:	register offset of the cores setting register
+ * @div_core_shift[]:	cores divider offset used to divide the pll value
+ * @div_core_mask[]:	cores divider mask
+ * @num_cores:	number of cpu cores
+ * @mux_core_alt:       mux value to select alternate parent
  * @mux_core_main:	mux value to select main parent of core
  * @mux_core_shift:	offset of the core multiplexer
  * @mux_core_mask:	core multiplexer mask
  */
 struct rockchip_cpuclk_reg_data {
-	int		core_reg;
-	u8		div_core_shift;
-	u32		div_core_mask;
-	u8		mux_core_alt;
-	u8		mux_core_main;
-	u8		mux_core_shift;
-	u32		mux_core_mask;
+	int	core_reg[ROCKCHIP_CPUCLK_MAX_CORES];
+	u8	div_core_shift[ROCKCHIP_CPUCLK_MAX_CORES];
+	u32	div_core_mask[ROCKCHIP_CPUCLK_MAX_CORES];
+	int	num_cores;
+	u8	mux_core_alt;
+	u8	mux_core_main;
+	u8	mux_core_shift;
+	u32	mux_core_mask;
+	const char	*pll_name;
 };
 
 struct clk *rockchip_clk_register_cpuclk(const char *name,
@@ -357,16 +478,18 @@ struct clk *rockchip_clk_register_mmc(const char *name,
 /*
  * DDRCLK flags, including method of setting the rate
  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
+ * ROCKCHIP_DDRCLK_SCPI: use SCPI APIs to let mcu change ddrclk rate.
  */
 #define ROCKCHIP_DDRCLK_SIP		BIT(0)
+#define ROCKCHIP_DDRCLK_SCPI		0x02
+#define ROCKCHIP_DDRCLK_SIP_V2		0x03
 
 struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 					 const char *const *parent_names,
 					 u8 num_parents, int mux_offset,
 					 int mux_shift, int mux_width,
 					 int div_shift, int div_width,
-					 int ddr_flags, void __iomem *reg_base,
-					 spinlock_t *lock);
+					 int ddr_flags, void __iomem *reg_base);
 
 #define ROCKCHIP_INVERTER_HIWORD_MASK	BIT(0)
 
@@ -384,8 +507,10 @@ struct clk *rockchip_clk_register_muxgrf(const char *name,
 
 enum rockchip_clk_branch_type {
 	branch_composite,
+	branch_composite_brother,
 	branch_mux,
 	branch_muxgrf,
+	branch_muxpmugrf,
 	branch_divider,
 	branch_fraction_divider,
 	branch_gate,
@@ -394,6 +519,7 @@ enum rockchip_clk_branch_type {
 	branch_factor,
 	branch_ddrclk,
 	branch_half_divider,
+	branch_dclk_divider,
 };
 
 struct rockchip_clk_branch {
@@ -407,6 +533,8 @@ struct rockchip_clk_branch {
 	u8				mux_shift;
 	u8				mux_width;
 	u8				mux_flags;
+	u32				*mux_table;
+	int				div_offset;
 	u8				div_shift;
 	u8				div_width;
 	u8				div_flags;
@@ -415,6 +543,7 @@ struct rockchip_clk_branch {
 	u8				gate_shift;
 	u8				gate_flags;
 	struct rockchip_clk_branch	*child;
+	unsigned long			max_prate;
 };
 
 #define COMPOSITE(_id, cname, pnames, f, mo, ms, mw, mf, ds, dw,\
@@ -438,6 +567,72 @@ struct rockchip_clk_branch {
 		.gate_flags	= gf,				\
 	}
 
+#define COMPOSITE_BROTHER(_id, cname, pnames, f, mo, ms, mw, mf,\
+			  ds, dw, df, go, gs, gf, bro)		\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_composite_brother,	\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= mo,				\
+		.mux_shift	= ms,				\
+		.mux_width	= mw,				\
+		.mux_flags	= mf,				\
+		.div_shift	= ds,				\
+		.div_width	= dw,				\
+		.div_flags	= df,				\
+		.gate_offset	= go,				\
+		.gate_shift	= gs,				\
+		.gate_flags	= gf,				\
+		.child		= bro,				\
+	}
+
+#define COMPOSITE_MUXTBL(_id, cname, pnames, f, mo, ms, mw, mf,	\
+		 mt, ds, dw, df, go, gs, gf)			\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_composite,		\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= mo,				\
+		.mux_shift	= ms,				\
+		.mux_width	= mw,				\
+		.mux_flags	= mf,				\
+		.mux_table	= mt,				\
+		.div_shift	= ds,				\
+		.div_width	= dw,				\
+		.div_flags	= df,				\
+		.gate_offset	= go,				\
+		.gate_shift	= gs,				\
+		.gate_flags	= gf,				\
+	}
+
+#define COMPOSITE_DIV_OFFSET(_id, cname, pnames, f, mo, ms, mw,	\
+			     mf, do, ds, dw, df, go, gs, gf)	\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_composite,		\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= mo,				\
+		.mux_shift	= ms,				\
+		.mux_width	= mw,				\
+		.mux_flags	= mf,				\
+		.div_offset	= do,				\
+		.div_shift	= ds,				\
+		.div_width	= dw,				\
+		.div_flags	= df,				\
+		.gate_offset	= go,				\
+		.gate_shift	= gs,				\
+		.gate_flags	= gf,				\
+	}
+
 #define COMPOSITE_NOMUX(_id, cname, pname, f, mo, ds, dw, df,	\
 			go, gs, gf)				\
 	{							\
@@ -512,6 +707,26 @@ struct rockchip_clk_branch {
 		.gate_offset	= -1,				\
 	}
 
+#define COMPOSITE_BROTHER_NOGATE(_id, cname, pnames, f, mo, ms, \
+				 mw, mf, ds, dw, df, bro)	\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_composite_brother,	\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= mo,				\
+		.mux_shift	= ms,				\
+		.mux_width	= mw,				\
+		.mux_flags	= mf,				\
+		.div_shift	= ds,				\
+		.div_width	= dw,				\
+		.div_flags	= df,				\
+		.gate_offset	= -1,				\
+		.child		= bro,				\
+	}
+
 #define COMPOSITE_NOGATE_DIVTBL(_id, cname, pnames, f, mo, ms,	\
 				mw, mf, ds, dw, df, dt)		\
 	{							\
@@ -532,7 +747,7 @@ struct rockchip_clk_branch {
 		.gate_offset	= -1,				\
 	}
 
-#define COMPOSITE_FRAC(_id, cname, pname, f, mo, df, go, gs, gf)\
+#define COMPOSITE_FRAC(_id, cname, pname, f, mo, df, go, gs, gf, prate)\
 	{							\
 		.id		= _id,				\
 		.branch_type	= branch_fraction_divider,	\
@@ -547,9 +762,10 @@ struct rockchip_clk_branch {
 		.gate_offset	= go,				\
 		.gate_shift	= gs,				\
 		.gate_flags	= gf,				\
+		.max_prate	= prate,			\
 	}
 
-#define COMPOSITE_FRACMUX(_id, cname, pname, f, mo, df, go, gs, gf, ch) \
+#define COMPOSITE_FRACMUX(_id, cname, pname, f, mo, df, go, gs, gf, ch, prate) \
 	{							\
 		.id		= _id,				\
 		.branch_type	= branch_fraction_divider,	\
@@ -565,9 +781,10 @@ struct rockchip_clk_branch {
 		.gate_shift	= gs,				\
 		.gate_flags	= gf,				\
 		.child		= ch,				\
+		.max_prate	= prate,			\
 	}
 
-#define COMPOSITE_FRACMUX_NOGATE(_id, cname, pname, f, mo, df, ch) \
+#define COMPOSITE_FRACMUX_NOGATE(_id, cname, pname, f, mo, df, ch, prate) \
 	{							\
 		.id		= _id,				\
 		.branch_type	= branch_fraction_divider,	\
@@ -581,6 +798,7 @@ struct rockchip_clk_branch {
 		.div_flags	= df,				\
 		.gate_offset	= -1,				\
 		.child		= ch,				\
+		.max_prate	= prate,			\
 	}
 
 #define COMPOSITE_DDRCLK(_id, cname, pnames, f, mo, ms, mw,	\
@@ -616,6 +834,22 @@ struct rockchip_clk_branch {
 		.gate_offset	= -1,				\
 	}
 
+#define MUXTBL(_id, cname, pnames, f, o, s, w, mf, mt)		\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_mux,			\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= o,				\
+		.mux_shift	= s,				\
+		.mux_width	= w,				\
+		.mux_flags	= mf,				\
+		.gate_offset	= -1,				\
+		.mux_table	= mt,				\
+	}
+
 #define MUXGRF(_id, cname, pnames, f, o, s, w, mf)		\
 	{							\
 		.id		= _id,				\
@@ -631,6 +865,21 @@ struct rockchip_clk_branch {
 		.gate_offset	= -1,				\
 	}
 
+#define MUXPMUGRF(_id, cname, pnames, f, o, s, w, mf)		\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_muxpmugrf,		\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= o,				\
+		.mux_shift	= s,				\
+		.mux_width	= w,				\
+		.mux_flags	= mf,				\
+		.gate_offset	= -1,				\
+	}
+
 #define DIV(_id, cname, pname, f, o, s, w, df)			\
 	{							\
 		.id		= _id,				\
@@ -745,6 +994,28 @@ struct rockchip_clk_branch {
 		.gate_flags	= gf,				\
 	}
 
+#define COMPOSITE_HALFDIV_OFFSET(_id, cname, pnames, f, mo, ms, mw, mf, do,\
+				 ds, dw, df, go, gs, gf)		   \
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_half_divider,		\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= mo,				\
+		.mux_shift	= ms,				\
+		.mux_width	= mw,				\
+		.mux_flags	= mf,				\
+		.div_offset	= do,				\
+		.div_shift	= ds,				\
+		.div_width	= dw,				\
+		.div_flags	= df,				\
+		.gate_offset	= go,				\
+		.gate_shift	= gs,				\
+		.gate_flags	= gf,				\
+	}
+
 #define COMPOSITE_NOGATE_HALFDIV(_id, cname, pnames, f, mo, ms, mw, mf,	\
 				 ds, dw, df)				\
 	{							\
@@ -797,6 +1068,32 @@ struct rockchip_clk_branch {
 		.gate_offset	= -1,				\
 	}
 
+#define COMPOSITE_DCLK(_id, cname, pnames, f, mo, ms, mw, mf, ds, dw,\
+		  df, go, gs, gf, prate)				\
+	{							\
+		.id		= _id,				\
+		.branch_type	= branch_dclk_divider,		\
+		.name		= cname,			\
+		.parent_names	= pnames,			\
+		.num_parents	= ARRAY_SIZE(pnames),		\
+		.flags		= f,				\
+		.muxdiv_offset	= mo,				\
+		.mux_shift	= ms,				\
+		.mux_width	= mw,				\
+		.mux_flags	= mf,				\
+		.div_shift	= ds,				\
+		.div_width	= dw,				\
+		.div_flags	= df,				\
+		.gate_offset	= go,				\
+		.gate_shift	= gs,				\
+		.gate_flags	= gf,				\
+		.max_prate	= prate,				\
+	}
+
+/* SGRF clocks are only accessible from secure mode, so not controllable */
+#define SGRF_GATE(_id, cname, pname)				\
+		FACTOR(_id, cname, pname, 0, 1, 1)
+
 struct rockchip_clk_provider *rockchip_clk_init(struct device_node *np,
 			void __iomem *base, unsigned long nr_clks);
 void rockchip_clk_of_add_provider(struct device_node *np,
@@ -816,6 +1113,9 @@ void rockchip_clk_register_armclk(struct rockchip_clk_provider *ctx,
 			const struct rockchip_cpuclk_rate_table *rates,
 			int nrates);
 void rockchip_clk_protect_critical(const char *const clocks[], int nclocks);
+int rockchip_pll_clk_rate_to_scale(struct clk *clk, unsigned long rate);
+int rockchip_pll_clk_scale_to_rate(struct clk *clk, unsigned int scale);
+int rockchip_pll_clk_adaptive_scaling(struct clk *clk, int sel);
 void rockchip_register_restart_notifier(struct rockchip_clk_provider *ctx,
 					unsigned int reg, void (*cb)(void));
 
@@ -826,12 +1126,27 @@ struct clk *rockchip_clk_register_halfdiv(const char *name,
 					  u8 num_parents, void __iomem *base,
 					  int muxdiv_offset, u8 mux_shift,
 					  u8 mux_width, u8 mux_flags,
-					  u8 div_shift, u8 div_width,
-					  u8 div_flags, int gate_offset,
-					  u8 gate_shift, u8 gate_flags,
-					  unsigned long flags,
+					  int div_offset, u8 div_shift,
+					  u8 div_width, u8 div_flags,
+					  int gate_offset, u8 gate_shift,
+					  u8 gate_flags, unsigned long flags,
 					  spinlock_t *lock);
 
+struct clk *rockchip_clk_register_dclk_branch(const char *name,
+					      const char *const *parent_names,
+					      u8 num_parents,
+					      void __iomem *base,
+					      int muxdiv_offset, u8 mux_shift,
+					      u8 mux_width, u8 mux_flags,
+					      int div_offset, u8 div_shift,
+					      u8 div_width, u8 div_flags,
+					      struct clk_div_table *div_table,
+					      int gate_offset,
+					      u8 gate_shift, u8 gate_flags,
+					      unsigned long flags,
+					      unsigned long max_prate,
+					      spinlock_t *lock);
+
 #ifdef CONFIG_RESET_CONTROLLER
 void rockchip_register_softrst(struct device_node *np,
 			       unsigned int num_regs,
@@ -843,5 +1158,6 @@ static inline void rockchip_register_softrst(struct device_node *np,
 {
 }
 #endif
+extern void (*rk_dump_cru)(void);
 
 #endif
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 8642504b7..7d845458b 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -52,6 +52,8 @@
 #define CNTFRQ		0x10
 #define CNTP_TVAL	0x28
 #define CNTP_CTL	0x2c
+#define CNTCVAL_LO	0x30
+#define CNTCVAL_HI	0x34
 #define CNTV_TVAL	0x38
 #define CNTV_CTL	0x3c
 
@@ -955,6 +957,7 @@ u32 arch_timer_get_rate(void)
 {
 	return arch_timer_rate;
 }
+EXPORT_SYMBOL_GPL(arch_timer_get_rate);
 
 bool arch_timer_evtstrm_available(void)
 {
@@ -966,6 +969,24 @@ bool arch_timer_evtstrm_available(void)
 	return cpumask_test_cpu(raw_smp_processor_id(), &evtstrm_available);
 }
 
+void arch_timer_mem_get_cval(u32 *lo, u32 *hi)
+{
+	u32 ctrl;
+
+	*lo = *hi = ~0U;
+
+	if (!arch_counter_base)
+		return;
+
+	ctrl = readl_relaxed(arch_counter_base + CNTV_CTL);
+
+	if (ctrl & ARCH_TIMER_CTRL_ENABLE) {
+		*lo = readl_relaxed(arch_counter_base + CNTCVAL_LO);
+		*hi = readl_relaxed(arch_counter_base + CNTCVAL_HI);
+	}
+}
+EXPORT_SYMBOL_GPL(arch_timer_mem_get_cval);
+
 static u64 arch_counter_get_cntvct_mem(void)
 {
 	u32 vct_lo, vct_hi, tmp_hi;
diff --git a/drivers/clocksource/arm_global_timer.c b/drivers/clocksource/arm_global_timer.c
index 095bb965f..f60e77216 100644
--- a/drivers/clocksource/arm_global_timer.c
+++ b/drivers/clocksource/arm_global_timer.c
@@ -49,6 +49,7 @@
  * the units for all operations.
  */
 static void __iomem *gt_base;
+static struct clk *gt_clk;
 static unsigned long gt_clk_rate;
 static int gt_ppi;
 static struct clock_event_device __percpu *gt_evt;
@@ -137,6 +138,97 @@ static int gt_clockevent_set_next_event(unsigned long evt,
 	return 0;
 }
 
+#ifdef CONFIG_COMMON_CLK
+
+/*
+ * Updates clockevent frequency when the cpu frequency changes.
+ * Called on the cpu that is changing frequency with interrupts disabled.
+ */
+static void gt_update_frequency(void *new_rate)
+{
+	gt_clk_rate = *((unsigned long *) new_rate);
+
+	clockevents_update_freq(raw_cpu_ptr(gt_evt), gt_clk_rate);
+}
+
+static int gt_rate_change(struct notifier_block *nb,
+	unsigned long flags, void *data)
+{
+	struct clk_notifier_data *cnd = data;
+
+	/*
+	 * The gt clock events must be reprogrammed to account for the new
+	 * frequency.  The timer is local to a cpu, so cross-call to the
+	 * changing cpu.
+	 */
+	if (flags == POST_RATE_CHANGE)
+		on_each_cpu(gt_update_frequency,
+				  (void *)&cnd->new_rate, 1);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block gt_clk_nb = {
+	.notifier_call = gt_rate_change,
+};
+
+static int gt_clk_init(void)
+{
+	if (gt_evt && raw_cpu_ptr(gt_evt) && !IS_ERR(gt_clk))
+		return clk_notifier_register(gt_clk, &gt_clk_nb);
+
+	return 0;
+}
+core_initcall(gt_clk_init);
+
+#elif defined (CONFIG_CPU_FREQ)
+
+#include <linux/cpufreq.h>
+
+/*
+ * Updates clockevent frequency when the cpu frequency changes.
+ * Called on the cpu that is changing frequency with interrupts disabled.
+ */
+static void gt_update_frequency(void *data)
+{
+	gt_clk_rate = clk_get_rate(gt_clk);
+
+	clockevents_update_freq(raw_cpu_ptr(gt_evt), gt_clk_rate);
+}
+
+static int gt_cpufreq_transition(struct notifier_block *nb,
+	unsigned long state, void *data)
+{
+	struct cpufreq_freqs *freqs = data;
+
+	/*
+	 * The gt clock events must be reprogrammed to account for the new
+	 * frequency.  The timer is local to a cpu, so cross-call to the
+	 * changing cpu.
+	 */
+	if (state == CPUFREQ_POSTCHANGE)
+		smp_call_function_single(freqs->cpu, gt_update_frequency,
+			NULL, 1);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block gt_cpufreq_nb = {
+	.notifier_call = gt_cpufreq_transition,
+};
+
+static int gt_cpufreq_init(void)
+{
+	if (gt_evt && raw_cpu_ptr(gt_evt) && !IS_ERR(gt_clk))
+		return cpufreq_register_notifier(&gt_cpufreq_nb,
+			CPUFREQ_TRANSITION_NOTIFIER);
+
+	return 0;
+}
+core_initcall(gt_cpufreq_init);
+
+#endif
+
 static irqreturn_t gt_clockevent_interrupt(int irq, void *dev_id)
 {
 	struct clock_event_device *evt = dev_id;
@@ -257,7 +349,6 @@ static int __init gt_clocksource_init(void)
 
 static int __init global_timer_of_register(struct device_node *np)
 {
-	struct clk *gt_clk;
 	int err = 0;
 
 	/*
diff --git a/include/clocksource/arm_arch_timer.h b/include/clocksource/arm_arch_timer.h
index 349e5957c..99ccc84f4 100644
--- a/include/clocksource/arm_arch_timer.h
+++ b/include/clocksource/arm_arch_timer.h
@@ -96,6 +96,7 @@ extern u32 arch_timer_get_rate(void);
 extern u64 (*arch_timer_read_counter)(void);
 extern struct arch_timer_kvm_info *arch_timer_get_kvm_info(void);
 extern bool arch_timer_evtstrm_available(void);
+extern void arch_timer_mem_get_cval(u32 *lo, u32 *hi);
 
 #else
 
@@ -114,6 +115,10 @@ static inline bool arch_timer_evtstrm_available(void)
 	return false;
 }
 
+static void arch_timer_mem_get_cval(u32 *lo, u32 *hi)
+{
+	*lo = *hi = ~0U;
+}
 #endif
 
 #endif
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index d1b6d2c3a..402e3639a 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -14,6 +14,7 @@
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_clk.h>
+#include <linux/mutex.h>
 
 #ifdef CONFIG_COMMON_CLK
 
@@ -40,6 +41,14 @@
 #define CLK_OPS_PARENT_ENABLE	BIT(12)
 /* duty cycle call may be forwarded to the parent clock */
 #define CLK_DUTY_CYCLE_PARENT	BIT(13)
+#define CLK_DONT_HOLD_STATE	BIT(14) /* Don't hold state */
+#define CLK_ENABLE_HAND_OFF	BIT(15) /* enable clock when registered. */
+					/*
+					 * hand-off enable_count & prepare_count
+					 * to first consumer that enables clk
+					 */
+#define CLK_IS_MEASURE          BIT(16) /* measure clock */
+#define CLK_KEEP_REQ_RATE	BIT(17) /* keep reqrate on parent rate change */
 
 struct clk;
 struct clk_hw;
@@ -202,6 +211,18 @@ struct clk_duty {
  *		directory is provided as an argument.  Called with
  *		prepare_lock held.  Returns 0 on success, -EERROR otherwise.
  *
+ * @set_flags: Set custom flags which deal with hardware specifics. Returns 0
+ *	       on success, -EERROR otherwise.
+ *
+ * @list_registers: Queries the hardware to get the current register contents.
+ *		    This callback is optional.
+ *
+ * @list_rate:  On success, return the nth supported frequency for a given
+ *		clock that is below rate_max. Return -ENXIO in case there is
+ *		no frequency table.
+ *
+ * @bus_vote:	Votes for bandwidth on certain config slaves to connect
+ *		ports in order to gain access to clock controllers.
  *
  * The clk_enable/clk_disable and clk_prepare/clk_unprepare pairs allow
  * implementations to split any work between atomic (enable) and sleepable
@@ -246,6 +267,12 @@ struct clk_ops {
 					  struct clk_duty *duty);
 	void		(*init)(struct clk_hw *hw);
 	void		(*debug_init)(struct clk_hw *hw, struct dentry *dentry);
+	int		(*set_flags)(struct clk_hw *hw, unsigned int flags);
+	void		(*list_registers)(struct seq_file *f,
+							struct clk_hw *hw);
+	long		(*list_rate)(struct clk_hw *hw, unsigned int n,
+							unsigned long rate_max);
+	void		(*bus_vote)(struct clk_hw *hw, bool enable);
 };
 
 /**
@@ -257,15 +284,86 @@ struct clk_ops {
  * @parent_names: array of string names for all possible parents
  * @num_parents: number of possible parents
  * @flags: framework-level hints and quirks
+ * @vdd_class: voltage scaling requirement class
+ * @rate_max: maximum clock rate in Hz supported at each voltage level
+ * @num_rate_max: number of maximum voltage level supported
+ * @bus_cl_id: client id registered with the bus driver used for bw votes
  */
 struct clk_init_data {
 	const char		*name;
 	const struct clk_ops	*ops;
 	const char		* const *parent_names;
-	u8			num_parents;
+	unsigned int		num_parents;
 	unsigned long		flags;
+	struct clk_vdd_class	*vdd_class;
+	unsigned long		*rate_max;
+	int			num_rate_max;
+	unsigned int		bus_cl_id;
+};
+
+struct regulator;
+
+/**
+ * struct clk_vdd_class - Voltage scaling class
+ * @class_name: name of the class
+ * @regulator: array of regulators
+ * @num_regulators: size of regulator array. Standard regulator APIs will be
+			used if this field > 0
+ * @set_vdd: function to call when applying a new voltage setting
+ * @vdd_uv: sorted 2D array of legal voltage settings. Indexed by level, then
+		regulator
+ * @level_votes: array of votes for each level
+ * @num_levels: specifies the size of level_votes array
+ * @skip_handoff: do not vote for the max possible voltage during init
+ * @cur_level: the currently set voltage level
+ * @lock: lock to protect this struct
+ */
+struct clk_vdd_class {
+	const char *class_name;
+	struct regulator **regulator;
+	int num_regulators;
+	int (*set_vdd)(struct clk_vdd_class *v_class, int level);
+	int *vdd_uv;
+	int *level_votes;
+	int num_levels;
+	bool skip_handoff;
+	unsigned long cur_level;
+	struct mutex lock;
 };
 
+#define DEFINE_VDD_CLASS(_name, _set_vdd, _num_levels) \
+	struct clk_vdd_class _name = { \
+		.class_name = #_name, \
+		.set_vdd = _set_vdd, \
+		.level_votes = (int [_num_levels]) {}, \
+		.num_levels = _num_levels, \
+		.cur_level = _num_levels, \
+		.lock = __MUTEX_INITIALIZER(_name.lock) \
+	}
+
+#define DEFINE_VDD_REGULATORS(_name, _num_levels, _num_regulators, _vdd_uv) \
+	struct clk_vdd_class _name = { \
+		.class_name = #_name, \
+		.vdd_uv = _vdd_uv, \
+		.regulator = (struct regulator * [_num_regulators]) {}, \
+		.num_regulators = _num_regulators, \
+		.level_votes = (int [_num_levels]) {}, \
+		.num_levels = _num_levels, \
+		.cur_level = _num_levels, \
+		.lock = __MUTEX_INITIALIZER(_name.lock) \
+	}
+
+#define DEFINE_VDD_REGS_INIT(_name, _num_regulators) \
+	struct clk_vdd_class _name = { \
+		.class_name = #_name, \
+		.regulator = (struct regulator * [_num_regulators]) {}, \
+		.num_regulators = _num_regulators, \
+		.lock = __MUTEX_INITIALIZER(_name.lock) \
+	}
+
+int clk_vote_vdd_level(struct clk_vdd_class *vdd_class, int level);
+int clk_unvote_vdd_level(struct clk_vdd_class *vdd_class, int level);
+
 /**
  * struct clk_hw - handle for traversing from a struct clk to its corresponding
  * hardware-specific structure.  struct clk_hw should be declared within struct
@@ -347,6 +445,8 @@ void of_fixed_clk_setup(struct device_node *np);
  *	of this register, and mask of gate bits are in higher 16-bit of this
  *	register.  While setting the gate bits, higher 16-bit should also be
  *	updated to indicate changing gate bits.
+ * CLK_GATE_NO_SET_RATE - The Gate not allowed to set rate.
+ *	And not allowed to set parent rate.
  */
 struct clk_gate {
 	struct clk_hw hw;
@@ -360,6 +460,7 @@ struct clk_gate {
 
 #define CLK_GATE_SET_TO_DISABLE		BIT(0)
 #define CLK_GATE_HIWORD_MASK		BIT(1)
+#define CLK_GATE_NO_SET_RATE		BIT(3)
 
 extern const struct clk_ops clk_gate_ops;
 struct clk *clk_register_gate(struct device *dev, const char *name,
@@ -386,6 +487,7 @@ struct clk_div_table {
  * @reg:	register containing the divider
  * @shift:	shift to the divider bit field
  * @width:	width of the divider bit field
+ * @max_prate:	the maximum frequency of the parent clock
  * @table:	array of value/divider pairs, last entry should have div = 0
  * @lock:	register lock
  *
@@ -422,6 +524,7 @@ struct clk_divider {
 	u8		shift;
 	u8		width;
 	u8		flags;
+	unsigned long	max_prate;
 	const struct clk_div_table	*table;
 	spinlock_t	*lock;
 };
@@ -591,9 +694,14 @@ void clk_hw_unregister_fixed_factor(struct clk_hw *hw);
  * @mwidth:	width of the numerator bit field
  * @nshift:	shift to the denominator bit field
  * @nwidth:	width of the denominator bit field
+ * @max_parent:	the maximum frequency of fractional divider parent clock
  * @lock:	register lock
  *
  * Clock with adjustable fractional divider affecting its output frequency.
+ *
+ * Flags:
+ * CLK_FRAC_DIVIDER_NO_LIMIT - not need to follow the 20 times limit on
+ *	fractional divider
  */
 struct clk_fractional_divider {
 	struct clk_hw	hw;
@@ -605,6 +713,7 @@ struct clk_fractional_divider {
 	u8		nwidth;
 	u32		nmask;
 	u8		flags;
+	unsigned long	max_prate;
 	void		(*approximation)(struct clk_hw *hw,
 				unsigned long rate, unsigned long *parent_rate,
 				unsigned long *m, unsigned long *n);
@@ -613,6 +722,8 @@ struct clk_fractional_divider {
 
 #define to_clk_fd(_hw) container_of(_hw, struct clk_fractional_divider, hw)
 
+#define CLK_FRAC_DIVIDER_NO_LIMIT		BIT(2)
+
 extern const struct clk_ops clk_fractional_divider_ops;
 struct clk *clk_register_fractional_divider(struct device *dev,
 		const char *name, const char *parent_name, unsigned long flags,
@@ -668,6 +779,9 @@ extern const struct clk_ops clk_multiplier_ops;
  * @mux_hw:	handle between composite and hardware-specific mux clock
  * @rate_hw:	handle between composite and hardware-specific rate clock
  * @gate_hw:	handle between composite and hardware-specific gate clock
+ * @brother_hw: a member of clk_composite who has the common parent clocks
+ *              with another clk_composite, and it's also a handle between
+ *              common and hardware-specific interfaces
  * @mux_ops:	clock ops for mux
  * @rate_ops:	clock ops for rate
  * @gate_ops:	clock ops for gate
@@ -679,6 +793,7 @@ struct clk_composite {
 	struct clk_hw	*mux_hw;
 	struct clk_hw	*rate_hw;
 	struct clk_hw	*gate_hw;
+	struct clk_hw	*brother_hw;
 
 	const struct clk_ops	*mux_ops;
 	const struct clk_ops	*rate_ops;
@@ -769,6 +884,7 @@ void devm_clk_unregister(struct device *dev, struct clk *clk);
 
 void clk_hw_unregister(struct clk_hw *hw);
 void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw);
+void clk_sync_state(struct device *dev);
 
 /* helper functions */
 const char *__clk_get_name(const struct clk *clk);
@@ -782,9 +898,6 @@ unsigned int __clk_get_enable_count(struct clk *clk);
 unsigned long clk_hw_get_rate(const struct clk_hw *hw);
 unsigned long __clk_get_flags(struct clk *clk);
 unsigned long clk_hw_get_flags(const struct clk_hw *hw);
-#define clk_hw_can_set_rate_parent(hw) \
-	(clk_hw_get_flags((hw)) & CLK_SET_RATE_PARENT)
-
 bool clk_hw_is_prepared(const struct clk_hw *hw);
 bool clk_hw_rate_is_protected(const struct clk_hw *hw);
 bool clk_hw_is_enabled(const struct clk_hw *hw);
@@ -802,6 +915,11 @@ void clk_hw_reparent(struct clk_hw *hw, struct clk_hw *new_parent);
 void clk_hw_set_rate_range(struct clk_hw *hw, unsigned long min_rate,
 			   unsigned long max_rate);
 
+unsigned long clk_aggregate_rate(struct clk_hw *hw,
+					const struct clk_core *parent);
+int clk_vote_rate_vdd(struct clk_core *core, unsigned long rate);
+void clk_unvote_rate_vdd(struct clk_core *core, unsigned long rate);
+
 static inline void __clk_hw_set_clk(struct clk_hw *dst, struct clk_hw *src)
 {
 	dst->clk = src->clk;
diff --git a/include/linux/clk.h b/include/linux/clk.h
index 4f750c481..9c0d0ff2a 100644
--- a/include/linux/clk.h
+++ b/include/linux/clk.h
@@ -312,7 +312,39 @@ struct clk *clk_get(struct device *dev, const char *id);
  */
 int __must_check clk_bulk_get(struct device *dev, int num_clks,
 			      struct clk_bulk_data *clks);
+/**
+ * clk_bulk_get_all - lookup and obtain all available references to clock
+ *		      producer.
+ * @dev: device for clock "consumer"
+ * @clks: pointer to the clk_bulk_data table of consumer
+ *
+ * This helper function allows drivers to get all clk consumers in one
+ * operation. If any of the clk cannot be acquired then any clks
+ * that were obtained will be freed before returning to the caller.
+ *
+ * Returns a positive value for the number of clocks obtained while the
+ * clock references are stored in the clk_bulk_data table in @clks field.
+ * Returns 0 if there're none and a negative value if something failed.
+ *
+ * Drivers must assume that the clock source is not enabled.
+ *
+ * clk_bulk_get should not be called from within interrupt context.
+ */
+int __must_check clk_bulk_get_all(struct device *dev,
+				  struct clk_bulk_data **clks);
 
+/**
+ * clk_bulk_get_optional - lookup and obtain a number of references to clock producer
+ * @dev: device for clock "consumer"
+ * @num_clks: the number of clk_bulk_data
+ * @clks: the clk_bulk_data table of consumer
+ *
+ * Behaves the same as clk_bulk_get() except where there is no clock producer.
+ * In this case, instead of returning -ENOENT, the function returns 0 and
+ * NULL for a clk for which a clock producer could not be determined.
+ */
+int __must_check clk_bulk_get_optional(struct device *dev, int num_clks,
+				       struct clk_bulk_data *clks);
 /**
  * devm_clk_bulk_get - managed get multiple clk consumers
  * @dev: device for clock "consumer"
@@ -327,6 +359,44 @@ int __must_check clk_bulk_get(struct device *dev, int num_clks,
  */
 int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
 				   struct clk_bulk_data *clks);
+/**
+ * devm_clk_bulk_get_optional - managed get multiple optional consumer clocks
+ * @dev: device for clock "consumer"
+ * @clks: pointer to the clk_bulk_data table of consumer
+ *
+ * Behaves the same as devm_clk_bulk_get() except where there is no clock
+ * producer.  In this case, instead of returning -ENOENT, the function returns
+ * NULL for given clk. It is assumed all clocks in clk_bulk_data are optional.
+ *
+ * Returns 0 if all clocks specified in clk_bulk_data table are obtained
+ * successfully or for any clk there was no clk provider available, otherwise
+ * returns valid IS_ERR() condition containing errno.
+ * The implementation uses @dev and @clk_bulk_data.id to determine the
+ * clock consumer, and thereby the clock producer.
+ * The clock returned is stored in each @clk_bulk_data.clk field.
+ *
+ * Drivers must assume that the clock source is not enabled.
+ *
+ * clk_bulk_get should not be called from within interrupt context.
+ */
+int __must_check devm_clk_bulk_get_optional(struct device *dev, int num_clks,
+					    struct clk_bulk_data *clks);
+/**
+ * devm_clk_bulk_get_all - managed get multiple clk consumers
+ * @dev: device for clock "consumer"
+ * @clks: pointer to the clk_bulk_data table of consumer
+ *
+ * Returns a positive value for the number of clocks obtained while the
+ * clock references are stored in the clk_bulk_data table in @clks field.
+ * Returns 0 if there're none and a negative value if something failed.
+ *
+ * This helper function allows drivers to get several clk
+ * consumers in one operation with management, the clks will
+ * automatically be freed when the device is unbound.
+ */
+
+int __must_check devm_clk_bulk_get_all(struct device *dev,
+				       struct clk_bulk_data **clks);
 
 /**
  * devm_clk_get - lookup and obtain a managed reference to a clock producer.
@@ -348,6 +418,17 @@ int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
  */
 struct clk *devm_clk_get(struct device *dev, const char *id);
 
+/**
+ * devm_clk_get_optional - lookup and obtain a managed reference to an optional
+ *			   clock producer.
+ * @dev: device for clock "consumer"
+ * @id: clock consumer ID
+ *
+ * Behaves the same as devm_clk_get() except where there is no clock producer.
+ * In this case, instead of returning -ENOENT, the function returns NULL.
+ */
+struct clk *devm_clk_get_optional(struct device *dev, const char *id);
+
 /**
  * devm_get_clk_from_child - lookup and obtain a managed reference to a
  *			     clock producer from child node.
@@ -487,6 +568,19 @@ void clk_put(struct clk *clk);
  */
 void clk_bulk_put(int num_clks, struct clk_bulk_data *clks);
 
+/**
+ * clk_bulk_put_all - "free" all the clock source
+ * @num_clks: the number of clk_bulk_data
+ * @clks: the clk_bulk_data table of consumer
+ *
+ * Note: drivers must ensure that all clk_bulk_enable calls made on this
+ * clock source are balanced by clk_bulk_disable calls prior to calling
+ * this function.
+ *
+ * clk_bulk_put_all should not be called from within interrupt context.
+ */
+void clk_bulk_put_all(int num_clks, struct clk_bulk_data *clks);
+
 /**
  * devm_clk_put	- "free" a managed clock source
  * @dev: device used to acquire the clock
@@ -642,17 +736,48 @@ static inline int __must_check clk_bulk_get(struct device *dev, int num_clks,
 	return 0;
 }
 
+static inline int __must_check clk_bulk_get_optional(struct device *dev,
+				int num_clks, struct clk_bulk_data *clks)
+{
+	return 0;
+}
+
+static inline int __must_check clk_bulk_get_all(struct device *dev,
+					 struct clk_bulk_data **clks)
+{
+	return 0;
+}
+
 static inline struct clk *devm_clk_get(struct device *dev, const char *id)
 {
 	return NULL;
 }
 
+static inline struct clk *devm_clk_get_optional(struct device *dev,
+						const char *id)
+{
+	return NULL;
+}
+
 static inline int __must_check devm_clk_bulk_get(struct device *dev, int num_clks,
 						 struct clk_bulk_data *clks)
 {
 	return 0;
 }
 
+static inline int __must_check devm_clk_bulk_get_optional(struct device *dev,
+				int num_clks, struct clk_bulk_data *clks)
+{
+	return 0;
+}
+
+static inline int __must_check devm_clk_bulk_get_all(struct device *dev,
+						     struct clk_bulk_data **clks)
+{
+
+	return 0;
+}
+
 static inline struct clk *devm_get_clk_from_child(struct device *dev,
 				struct device_node *np, const char *con_id)
 {
@@ -663,6 +788,8 @@ static inline void clk_put(struct clk *clk) {}
 
 static inline void clk_bulk_put(int num_clks, struct clk_bulk_data *clks) {}
 
+static inline void clk_bulk_put_all(int num_clks, struct clk_bulk_data *clks) {}
+
 static inline void devm_clk_put(struct device *dev, struct clk *clk) {}
 
 
@@ -774,6 +901,25 @@ static inline void clk_bulk_disable_unprepare(int num_clks,
 	clk_bulk_unprepare(num_clks, clks);
 }
 
+/**
+ * clk_get_optional - lookup and obtain a reference to an optional clock
+ *		      producer.
+ * @dev: device for clock "consumer"
+ * @id: clock consumer ID
+ *
+ * Behaves the same as clk_get() except where there is no clock producer. In
+ * this case, instead of returning -ENOENT, the function returns NULL.
+ */
+static inline struct clk *clk_get_optional(struct device *dev, const char *id)
+{
+	struct clk *clk = clk_get(dev, id);
+
+	if (clk == ERR_PTR(-ENOENT))
+		return NULL;
+
+	return clk;
+}
+
 #if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
 struct clk *of_clk_get(struct device_node *np, int index);
 struct clk *of_clk_get_by_name(struct device_node *np, const char *name);
-- 
2.37.0 (Apple Git-136)

