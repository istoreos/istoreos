From 9147448c10f5e5a647b8bdc66fc31b22d1524a32 Mon Sep 17 00:00:00 2001
From: Liangbin Lian <jjm2473@gmail.com>
Date: Fri, 4 Nov 2022 19:55:48 +0800
Subject: [PATCH] patches

---
 .gitignore                                    |    2 +
 Kconfig                                       |   95 +-
 Makefile                                      |  126 +-
 api/api_platform-powerpc.c                    |    2 +-
 arch/arm/Kconfig                              |   83 +-
 arch/arm/Makefile                             |    2 +-
 arch/arm/config.mk                            |    9 +-
 arch/arm/cpu/armv7/Makefile                   |    4 +
 arch/arm/cpu/armv7/arch_timer.c               |   22 +-
 arch/arm/cpu/armv7/cache_v7.c                 |   24 +-
 arch/arm/cpu/armv7/config.mk                  |    4 +
 arch/arm/cpu/armv7/cpu.c                      |    1 +
 arch/arm/cpu/armv7/start.S                    |   46 +
 arch/arm/cpu/armv7/virt-dt.c                  |    2 +-
 arch/arm/cpu/armv8/Makefile                   |    5 +
 arch/arm/cpu/armv8/cache.S                    |    2 +
 arch/arm/cpu/armv8/cache_v8.c                 |   44 +-
 arch/arm/cpu/armv8/cpu.c                      |    2 +
 arch/arm/cpu/armv8/exceptions.S               |  158 +-
 arch/arm/cpu/armv8/generic_timer.c            |    7 +
 arch/arm/cpu/armv8/spin_table.c               |    2 +-
 arch/arm/cpu/armv8/start.S                    |   34 +-
 arch/arm/cpu/armv8/u-boot-spl.lds             |   17 +
 arch/arm/cpu/u-boot.lds                       |   22 +-
 arch/arm/dts/Makefile                         |   37 +-
 arch/arm/include/asm/arch-rockchip/boot0.h    |   68 +-
 .../arm/include/asm/arch-rockchip/boot_mode.h |   20 +
 arch/arm/include/asm/arch-rockchip/bootrom.h  |   50 +-
 arch/arm/include/asm/arch-rockchip/clock.h    |  135 +
 .../include/asm/arch-rockchip/cru_rk3036.h    |   49 +
 .../include/asm/arch-rockchip/cru_rk3188.h    |   18 +
 .../include/asm/arch-rockchip/cru_rk322x.h    |  132 +-
 .../include/asm/arch-rockchip/cru_rk3288.h    |   56 +
 .../include/asm/arch-rockchip/cru_rk3328.h    |  216 +-
 .../include/asm/arch-rockchip/cru_rk3368.h    |   86 +
 .../include/asm/arch-rockchip/cru_rk3399.h    |   59 +-
 .../include/asm/arch-rockchip/cru_rv1108.h    |  249 +-
 arch/arm/include/asm/arch-rockchip/gpio.h     |   36 +
 .../include/asm/arch-rockchip/grf_rk3036.h    |    4 +-
 .../include/asm/arch-rockchip/grf_rk322x.h    |  481 +-
 .../include/asm/arch-rockchip/grf_rk3328.h    |  113 -
 .../include/asm/arch-rockchip/grf_rk3399.h    |    9 +-
 .../include/asm/arch-rockchip/grf_rv1108.h    |  451 +-
 arch/arm/include/asm/arch-rockchip/i2c.h      |    7 +
 arch/arm/include/asm/arch-rockchip/periph.h   |    4 +
 arch/arm/include/asm/arch-rockchip/pwm.h      |   17 +-
 arch/arm/include/asm/arch-rockchip/sdram.h    |  178 +-
 .../include/asm/arch-rockchip/sdram_common.h  |  455 +-
 .../include/asm/arch-rockchip/sdram_rk3036.h  |    2 +-
 .../include/asm/arch-rockchip/sdram_rk3399.h  |   95 +-
 .../arm/include/asm/arch-rockchip/sys_proto.h |    4 +
 arch/arm/include/asm/armv7.h                  |   21 +
 arch/arm/include/asm/armv8/mmu.h              |   12 +-
 arch/arm/include/asm/config.h                 |    4 -
 arch/arm/include/asm/dma-mapping.h            |    8 +-
 arch/arm/include/asm/global_data.h            |    3 +-
 arch/arm/include/asm/io.h                     |   30 +-
 arch/arm/include/asm/macro.h                  |   12 +
 arch/arm/include/asm/proc-armv/ptrace.h       |   14 +
 arch/arm/include/asm/setjmp.h                 |   94 +-
 arch/arm/include/asm/setup.h                  |    2 +-
 arch/arm/include/asm/spl.h                    |    4 +
 arch/arm/include/asm/system.h                 |  102 +-
 arch/arm/include/asm/u-boot-arm.h             |    2 +-
 arch/arm/lib/Makefile                         |   10 +-
 arch/arm/lib/bootm-fdt.c                      |   32 +
 arch/arm/lib/bootm.c                          |   90 +-
 arch/arm/lib/cache-cp15.c                     |   22 +-
 arch/arm/lib/crt0.S                           |   23 +-
 arch/arm/lib/crt0_64.S                        |   58 +-
 arch/arm/lib/gic_64.S                         |   46 +
 arch/arm/lib/interrupts.c                     |   34 +-
 arch/arm/lib/interrupts_64.c                  |  100 +-
 arch/arm/lib/psci-dt.c                        |    2 +-
 arch/arm/lib/relocate_64.S                    |   32 +-
 arch/arm/lib/stack.c                          |    8 +
 arch/arm/lib/vectors.S                        |   79 +-
 arch/arm/mach-rockchip/Kconfig                |  844 ++-
 arch/arm/mach-rockchip/Makefile               |   66 +-
 arch/arm/mach-rockchip/bootrom.c              |  102 +-
 arch/arm/mach-rockchip/rk_timer.c             |    2 +-
 arch/arm/mach-rockchip/sdram_common.c         |    2 +-
 arch/arm/mach-rockchip/spl-boot-order.c       |   88 +-
 cmd/Kconfig                                   |  225 +-
 cmd/Makefile                                  |   35 +-
 cmd/bdinfo.c                                  |   17 +-
 cmd/blk_common.c                              |   25 +-
 cmd/boot.c                                    |   29 +-
 cmd/bootefi.c                                 |  211 +-
 cmd/bootm.c                                   |    3 +
 cmd/eeprom.c                                  |    4 +-
 cmd/ext4.c                                    |   28 +
 cmd/fastboot.c                                |   53 +-
 cmd/fastboot/Kconfig                          |   54 +-
 cmd/fdt.c                                     |   19 +-
 cmd/flash.c                                   |   33 +-
 cmd/fs.c                                      |    2 +
 cmd/gpt.c                                     |   92 +-
 cmd/i2c.c                                     |   14 +-
 cmd/jffs2.c                                   |    2 +-
 cmd/load.c                                    |  118 +
 cmd/log.c                                     |  326 +-
 cmd/mdio.c                                    |    5 +
 cmd/mem.c                                     |  106 +-
 cmd/mmc.c                                     |  172 +-
 cmd/mtdparts.c                                |   23 +-
 cmd/mvebu/bubt.c                              |    2 +-
 cmd/net.c                                     |  117 +-
 cmd/nvedit.c                                  |  431 +-
 cmd/part.c                                    |    2 +-
 cmd/pxe.c                                     |   25 +-
 cmd/regulator.c                               |    2 +-
 cmd/sf.c                                      |   22 +-
 cmd/source.c                                  |   25 +-
 cmd/spl.c                                     |   12 +-
 cmd/thordown.c                                |   10 +-
 cmd/time.c                                    |    2 +-
 cmd/tpm_test.c                                |    6 +-
 cmd/usb.c                                     |   22 +-
 cmd/usb_gadget_sdp.c                          |    8 +-
 cmd/usb_mass_storage.c                        |   10 +-
 common/Kconfig                                |  231 +-
 common/Makefile                               |   54 +-
 common/autoboot.c                             |   19 +-
 common/board_f.c                              |  125 +-
 common/board_info.c                           |    7 +-
 common/board_r.c                              |  255 +-
 common/boot_fit.c                             |   10 +-
 common/bootm.c                                |  185 +-
 common/bootm_os.c                             |    6 +-
 common/bootstage.c                            |    2 +-
 common/cli.c                                  |   11 +-
 common/command.c                              |    2 -
 common/common_fit.c                           |   22 +-
 common/console.c                              |  137 +-
 common/dfu.c                                  |   28 +-
 common/dlmalloc.c                             |   14 +-
 common/edid.c                                 | 6300 ++++++++++++++++-
 common/fb_mmc.c                               |  191 +-
 common/fb_nand.c                              |   43 +-
 common/fdt_support.c                          |  242 +-
 common/flash.c                                |    4 +-
 common/image-android.c                        | 1101 ++-
 common/image-fdt.c                            |  151 +-
 common/image-fit.c                            |  717 +-
 common/image-sig.c                            |  144 +-
 common/image-sparse.c                         |   26 +-
 common/image.c                                |  130 +-
 common/init/board_init.c                      |   13 +
 common/iotrace.c                              |    4 +
 common/lcd_simplefb.c                         |    2 +-
 common/malloc_simple.c                        |    2 +-
 common/spl/Kconfig                            |  292 +-
 common/spl/Makefile                           |   30 +-
 common/spl/spl.c                              |  256 +-
 common/spl/spl_atf.c                          |  141 +-
 common/spl/spl_dfu.c                          |    4 +-
 common/spl/spl_fat.c                          |    8 +-
 common/spl/spl_fit.c                          |  672 +-
 common/spl/spl_mmc.c                          |   65 +-
 common/spl/spl_nand.c                         |   37 +-
 common/spl/spl_net.c                          |    8 +-
 common/spl/spl_ram.c                          |   12 +-
 common/spl/spl_sdp.c                          |   14 +-
 common/spl/spl_spi.c                          |   12 +-
 common/spl/spl_ymodem.c                       |    2 +-
 common/splash_source.c                        |    2 +-
 common/stdio.c                                |   18 +-
 common/update.c                               |    2 +-
 common/usb.c                                  |   82 +-
 common/usb_hub.c                              |   40 +-
 common/usb_kbd.c                              |  138 +-
 common/usb_storage.c                          |   73 +-
 common/xyzModem.c                             |    7 +-
 disk/Kconfig                                  |   49 +
 disk/Makefile                                 |    5 +
 disk/part.c                                   |  188 +-
 disk/part_dos.c                               |   12 +-
 disk/part_efi.c                               |  274 +-
 disk/part_iso.c                               |    4 +-
 drivers/Kconfig                               |   10 +
 drivers/Makefile                              |   36 +-
 drivers/adc/Kconfig                           |   25 +
 drivers/adc/Makefile                          |    2 +
 drivers/adc/adc-uclass.c                      |   18 +-
 drivers/adc/exynos-adc.c                      |    6 +-
 drivers/adc/sandbox.c                         |    6 +-
 drivers/ata/Kconfig                           |   11 +
 drivers/ata/ahci.c                            |   64 +-
 drivers/ata/dwc_ahci.c                        |   46 +-
 drivers/ata/sata_dwc.c                        |    1 +
 drivers/ata/sata_dwc.h                        |    7 -
 .../bios_emulator/include/x86emu/x86emui.h    |    3 -
 drivers/block/Kconfig                         |    9 +
 drivers/block/blk-uclass.c                    |   66 +-
 drivers/block/blk_legacy.c                    |    3 -
 drivers/bootcount/Makefile                    |    1 +
 drivers/clk/Kconfig                           |   19 +-
 drivers/clk/Makefile                          |    3 +
 drivers/clk/clk-uclass.c                      |  265 +-
 drivers/clk/clk_boston.c                      |    4 +-
 drivers/clk/clk_fixed_rate.c                  |    2 -
 drivers/clk/clk_pic32.c                       |   12 +-
 drivers/clk/clk_sandbox_test.c                |   42 +
 drivers/clk/clk_stm32f7.c                     |    2 +-
 drivers/clk/renesas/clk-rcar-gen3.c           |    4 +-
 drivers/clk/rockchip/Makefile                 |   12 +-
 drivers/clk/rockchip/clk_rk3036.c             |  279 +-
 drivers/clk/rockchip/clk_rk3188.c             |  174 +-
 drivers/clk/rockchip/clk_rk322x.c             | 1198 +++-
 drivers/clk/rockchip/clk_rk3288.c             | 1042 ++-
 drivers/clk/rockchip/clk_rk3328.c             | 1510 +++-
 drivers/clk/rockchip/clk_rk3368.c             | 1047 ++-
 drivers/clk/rockchip/clk_rk3399.c             | 1045 ++-
 drivers/clk/rockchip/clk_rv1108.c             |  574 +-
 drivers/core/Kconfig                          |    6 +
 drivers/core/Makefile                         |    2 +
 drivers/core/device.c                         |  124 +-
 drivers/core/dump.c                           |   29 +-
 drivers/core/lists.c                          |   15 +-
 drivers/core/of_access.c                      |  112 +-
 drivers/core/of_addr.c                        |    2 +-
 drivers/core/of_extra.c                       |    2 +-
 drivers/core/ofnode.c                         |   85 +-
 drivers/core/read.c                           |   50 +
 drivers/core/regmap.c                         |   22 +-
 drivers/core/root.c                           |   59 +-
 drivers/core/simple-bus.c                     |    2 -
 drivers/core/syscon-uclass.c                  |   19 +
 drivers/core/uclass.c                         |   71 +-
 drivers/core/util.c                           |   13 +-
 drivers/cpu/Kconfig                           |   12 +
 drivers/cpu/Makefile                          |    1 +
 drivers/crypto/Kconfig                        |   13 +
 drivers/crypto/Makefile                       |    4 +-
 drivers/crypto/fsl/sec.c                      |    2 +-
 drivers/ddr/microchip/ddr2.c                  |    8 +-
 drivers/dfu/Kconfig                           |    6 +
 drivers/dfu/Makefile                          |    1 +
 drivers/dfu/dfu.c                             |   17 +-
 drivers/dfu/dfu_mmc.c                         |   18 +-
 drivers/dfu/dfu_nand.c                        |    5 +-
 drivers/dfu/dfu_ram.c                         |    8 +-
 drivers/dfu/dfu_tftp.c                        |    4 +-
 drivers/dma/Kconfig                           |   15 +
 drivers/dma/dma-uclass.c                      |    2 +-
 drivers/dma/lpc32xx_dma.c                     |    8 +-
 drivers/dma/ti-edma3.c                        |    2 +-
 drivers/firmware/Kconfig                      |    2 +
 drivers/firmware/Makefile                     |    1 +
 drivers/firmware/firmware-uclass.c            |    8 +
 drivers/firmware/psci.c                       |    6 +-
 drivers/fpga/Kconfig                          |   15 +
 drivers/fpga/socfpga_arria10.c                |   17 +-
 drivers/gpio/Kconfig                          |   13 +
 drivers/gpio/adi_gpio2.c                      |    2 +-
 drivers/gpio/atmel_pio4.c                     |   12 +-
 drivers/gpio/imx_rgpio2p.c                    |    2 +-
 drivers/gpio/kw_gpio.c                        |    2 +-
 drivers/gpio/mxc_gpio.c                       |    2 +-
 drivers/gpio/omap_gpio.c                      |    2 +-
 drivers/gpio/pca953x_gpio.c                   |    3 +-
 drivers/gpio/rk_gpio.c                        |   98 +-
 drivers/gpio/tegra186_gpio.c                  |    2 +-
 drivers/i2c/i2c-gpio.c                        |    2 +-
 drivers/i2c/i2c-uclass.c                      |    6 +
 drivers/i2c/imx_lpi2c.c                       |    2 +-
 drivers/i2c/mxc_i2c.c                         |   12 +-
 drivers/i2c/omap24xx_i2c.c                    |    2 +-
 drivers/i2c/rk_i2c.c                          |  266 +-
 drivers/i2c/stm32f7_i2c.c                     |   16 +-
 drivers/i2c/tegra186_bpmp_i2c.c               |    2 +-
 drivers/i2c/tegra_i2c.c                       |    4 +-
 drivers/input/Kconfig                         |  106 +
 drivers/input/Makefile                        |   22 +-
 drivers/input/input.c                         |    5 +-
 drivers/led/led_gpio.c                        |   20 +-
 drivers/misc/Kconfig                          |   57 +
 drivers/misc/Makefile                         |   36 +-
 drivers/misc/cros_ec.c                        |    3 +-
 drivers/misc/misc-uclass.c                    |   27 +
 drivers/misc/rockchip-efuse.c                 |  417 +-
 drivers/misc/tegra186_bpmp.c                  |   28 +-
 drivers/mmc/Kconfig                           |   42 +
 drivers/mmc/Makefile                          |    5 +-
 drivers/mmc/bcm2835_sdhci.c                   |    8 +-
 drivers/mmc/dw_mmc.c                          |  404 +-
 drivers/mmc/exynos_dw_mmc.c                   |    4 +-
 drivers/mmc/fsl_esdhc.c                       |    4 +-
 drivers/mmc/hi6220_dw_mmc.c                   |    2 +-
 drivers/mmc/mmc-uclass.c                      |   70 +-
 drivers/mmc/mmc.c                             |  811 ++-
 drivers/mmc/mmc_private.h                     |   16 +-
 drivers/mmc/mmc_write.c                       |  108 +-
 drivers/mmc/msm_sdhci.c                       |    8 +-
 drivers/mmc/rockchip_dw_mmc.c                 |  108 +-
 drivers/mmc/rockchip_sdhci.c                  |  487 +-
 drivers/mmc/rpmb.c                            |  223 +-
 drivers/mmc/s5p_sdhci.c                       |    6 +-
 drivers/mmc/sdhci-cadence.c                   |    2 +-
 drivers/mmc/sdhci.c                           |  203 +-
 drivers/mmc/socfpga_dw_mmc.c                  |    2 +-
 drivers/mmc/uniphier-sd.c                     |    6 +-
 drivers/mmc/xenon_sdhci.c                     |   26 +-
 drivers/mmc/zynq_sdhci.c                      |    2 +-
 drivers/mtd/Kconfig                           |   41 +-
 drivers/mtd/Makefile                          |    9 +-
 drivers/mtd/cfi_flash.c                       | 1006 +--
 drivers/mtd/mtd-uclass.c                      |   16 +
 drivers/mtd/mtd_uboot.c                       |  353 +-
 drivers/mtd/mtdcore.c                         |  491 +-
 drivers/mtd/mtdcore.h                         |    6 -
 drivers/mtd/mtdpart.c                         |  639 +-
 drivers/mtd/nand/Kconfig                      |  190 +-
 drivers/mtd/nand/Makefile                     |   81 +-
 drivers/mtd/onenand/onenand_base.c            |   40 +-
 drivers/mtd/onenand/onenand_bbt.c             |    5 +-
 drivers/mtd/pic32_flash.c                     |   10 +-
 drivers/mtd/spi/Kconfig                       |  106 +-
 drivers/mtd/spi/Makefile                      |   11 +-
 drivers/mtd/spi/sandbox.c                     |  252 +-
 drivers/mtd/spi/sf-uclass.c                   |   15 +-
 drivers/mtd/spi/sf_dataflash.c                |   33 +-
 drivers/mtd/spi/sf_internal.h                 |  234 +-
 drivers/mtd/spi/sf_mtd.c                      |   48 +-
 drivers/mtd/spi/sf_probe.c                    |  104 +-
 drivers/mtd/spi/spi_flash.c                   |  256 +-
 drivers/mtd/spi/spi_flash_ids.c               |   40 +-
 drivers/mtd/stm32_flash.c                     |    2 +-
 drivers/mtd/ubi/Kconfig                       |    8 +-
 drivers/mtd/ubi/attach.c                      |    5 +-
 drivers/mtd/ubi/build.c                       |   22 +-
 drivers/mtd/ubi/debug.c                       |    7 +-
 drivers/mtd/ubi/debug.h                       |   16 +-
 drivers/mtd/ubi/fastmap-wl.c                  |   34 +-
 drivers/mtd/ubi/io.c                          |    7 +-
 drivers/mtd/ubi/ubi.h                         |    2 +-
 drivers/mtd/ubi/wl.c                          |   53 +-
 drivers/net/Kconfig                           |   32 +-
 drivers/net/Makefile                          |    1 +
 drivers/net/ag7xxx.c                          |   16 +-
 drivers/net/bcm-sf2-eth-gmac.c                |   14 +-
 drivers/net/bcm-sf2-eth.c                     |   18 +-
 drivers/net/cpsw-common.c                     |    8 +-
 drivers/net/cpsw.c                            |    8 +-
 drivers/net/designware.c                      |   11 +-
 drivers/net/dwc_eth_qos.c                     | 1040 ++-
 drivers/net/e1000_spi.c                       |    2 -
 drivers/net/ep93xx_eth.c                      |   16 +-
 drivers/net/ethoc.c                           |    8 +-
 drivers/net/fec_mxc.c                         |   23 +-
 drivers/net/fm/fm.c                           |    2 -
 drivers/net/fsl-mc/dpio/qbman_private.h       |    4 +-
 drivers/net/fsl-mc/mc.c                       |    2 +-
 drivers/net/gmac_rockchip.c                   | 1666 ++++-
 drivers/net/keystone_net.c                    |   14 +-
 drivers/net/mpc8xx_fec.c                      |    2 +-
 drivers/net/phy/Kconfig                       |    3 +
 drivers/net/phy/Makefile                      |    1 +
 drivers/net/phy/cortina.c                     |    2 -
 drivers/net/phy/micrel_ksz90x1.c              |    5 +-
 drivers/net/phy/phy.c                         |   29 +-
 drivers/net/pic32_eth.c                       |   12 +-
 drivers/net/pic32_mdio.c                      |   28 +-
 drivers/net/ravb.c                            |    4 +-
 drivers/net/xilinx_axi_emac.c                 |   20 +-
 drivers/net/zynq_gem.c                        |   12 +-
 drivers/nvme/nvme-uclass.c                    |   29 -
 drivers/nvme/nvme.c                           |  186 +-
 drivers/nvme/nvme.h                           |    3 +-
 drivers/nvme/nvme_show.c                      |    4 +-
 drivers/pci/Kconfig                           |    8 +
 drivers/pci/Makefile                          |    1 +
 drivers/pci/fsl_pci_init.c                    |    2 +-
 drivers/pci/pci-emul-uclass.c                 |    2 +-
 drivers/pci/pci_tegra.c                       |   50 +-
 drivers/pci/pcie_layerscape_fixup.c           |    2 +-
 drivers/pci/pcie_xilinx.c                     |    2 +-
 drivers/phy/Kconfig                           |   64 +
 drivers/phy/Makefile                          |    9 +
 drivers/phy/marvell/comphy_cp110.c            |   40 +-
 drivers/phy/phy-uclass.c                      |   72 +-
 drivers/phy/ti-pipe3-phy.c                    |   12 +-
 drivers/pinctrl/Kconfig                       |   83 +-
 drivers/pinctrl/Makefile                      |    3 +-
 drivers/pinctrl/mvebu/pinctrl-armada-37xx.c   |    2 +-
 drivers/pinctrl/pinctrl-single.c              |    2 +-
 drivers/pinctrl/pinctrl-sti.c                 |   14 +-
 drivers/pinctrl/pinctrl-uclass.c              |   31 +-
 drivers/pinctrl/pinctrl_stm32.c               |    2 +-
 drivers/pinctrl/rockchip/Makefile             |   30 +-
 drivers/pinctrl/rockchip/pinctrl_rk3036.c     |    8 +-
 drivers/pinctrl/rockchip/pinctrl_rk3188.c     |   10 +-
 drivers/pinctrl/rockchip/pinctrl_rk322x.c     |    8 +-
 drivers/pinctrl/rockchip/pinctrl_rk3288.c     |   10 +-
 drivers/pinctrl/rockchip/pinctrl_rk3328.c     |    8 +-
 drivers/pinctrl/rockchip/pinctrl_rk3368.c     |    8 +-
 drivers/pinctrl/rockchip/pinctrl_rk3399.c     |    8 +-
 drivers/pinctrl/rockchip/pinctrl_rv1108.c     |    8 +-
 drivers/power/Kconfig                         |   31 +
 drivers/power/Makefile                        |    4 +
 drivers/power/fuel_gauge/Makefile             |   11 +
 drivers/power/pmic/Kconfig                    |   20 +
 drivers/power/pmic/Makefile                   |    1 +
 drivers/power/pmic/act8846.c                  |    2 +-
 drivers/power/pmic/as3722.c                   |   12 +-
 drivers/power/pmic/as3722_gpio.c              |   10 +-
 drivers/power/pmic/i2c_pmic_emul.c            |    6 +-
 drivers/power/pmic/lp873x.c                   |    4 +-
 drivers/power/pmic/lp87565.c                  |    4 +-
 drivers/power/pmic/max77686.c                 |    4 +-
 drivers/power/pmic/max8997.c                  |    4 +-
 drivers/power/pmic/max8998.c                  |    4 +-
 drivers/power/pmic/palmas.c                   |    4 +-
 drivers/power/pmic/pfuze100.c                 |    4 +-
 drivers/power/pmic/pmic-uclass.c              |   70 +-
 drivers/power/pmic/rk8xx.c                    |  558 +-
 drivers/power/pmic/rn5t567.c                  |    2 +-
 drivers/power/pmic/s2mps11.c                  |    4 +-
 drivers/power/pmic/s5m8767.c                  |    4 +-
 drivers/power/pmic/sandbox.c                  |    6 +-
 drivers/power/pmic/tps65090.c                 |    4 +-
 drivers/power/regulator/Kconfig               |   32 +
 drivers/power/regulator/Makefile              |    3 +
 drivers/power/regulator/fixed.c               |    7 +-
 drivers/power/regulator/gpio-regulator.c      |   18 +-
 drivers/power/regulator/max77686.c            |   20 +-
 drivers/power/regulator/pwm_regulator.c       |   29 +-
 drivers/power/regulator/regulator-uclass.c    |  273 +-
 drivers/power/regulator/rk8xx.c               | 1070 ++-
 drivers/power/regulator/sandbox.c             |   18 +-
 drivers/pwm/rk_pwm.c                          |  181 +-
 drivers/qe/fdt.c                              |    2 +-
 drivers/qe/qe.c                               |    2 -
 drivers/ram/Kconfig                           |   24 +-
 drivers/ram/Makefile                          |    8 +-
 drivers/ram/rockchip/Makefile                 |   25 +-
 drivers/ram/rockchip/dmc-rk3368.c             |   41 +-
 drivers/ram/stm32_sdram.c                     |    8 +-
 drivers/reset/Kconfig                         |   34 +
 drivers/reset/Makefile                        |    4 +-
 drivers/reset/reset-uclass.c                  |   60 +
 drivers/reset/sandbox-reset-test.c            |   29 +
 drivers/reset/sandbox-reset.c                 |    2 +-
 drivers/reset/sti-reset.c                     |   14 +-
 drivers/rtc/Kconfig                           |    6 +
 drivers/rtc/Makefile                          |    1 +
 drivers/rtc/rtc-uclass.c                      |   10 +
 drivers/serial/Kconfig                        |   16 +-
 drivers/serial/ns16550.c                      |  140 +-
 drivers/serial/serial-uclass.c                |   97 +-
 drivers/serial/serial_mpc8xx.c                |    2 +-
 drivers/serial/serial_pic32.c                 |    4 +-
 drivers/serial/serial_rockchip.c              |    2 +-
 drivers/serial/usbtty.c                       |    2 +-
 drivers/spi/Kconfig                           |  116 +-
 drivers/spi/Makefile                          |    9 +-
 drivers/spi/atmel_spi.c                       |   20 +-
 drivers/spi/cadence_qspi.c                    |   20 +-
 drivers/spi/cadence_qspi.h                    |    6 +-
 drivers/spi/cadence_qspi_apb.c                |   83 +-
 drivers/spi/cf_spi.c                          |    8 -
 drivers/spi/davinci_spi.c                     |    1 +
 drivers/spi/designware_spi.c                  |  175 +-
 drivers/spi/fsl_dspi.c                        |   10 -
 drivers/spi/fsl_qspi.c                        |   64 +-
 drivers/spi/fsl_qspi.h                        |    4 +
 drivers/spi/ich.c                             |   22 +
 drivers/spi/ich.h                             |    1 +
 drivers/spi/kirkwood_spi.c                    |   69 +-
 drivers/spi/lpc32xx_ssp.c                     |    6 +-
 drivers/spi/mpc8xx_spi.c                      |    2 +-
 drivers/spi/mvebu_a3700_spi.c                 |   20 +-
 drivers/spi/mxc_spi.c                         |  181 +-
 drivers/spi/omap3_spi.c                       |   34 +-
 drivers/spi/rk_spi.c                          |   58 +-
 drivers/spi/sandbox_spi.c                     |   49 +-
 drivers/spi/sh_qspi.c                         |  119 +-
 drivers/spi/spi-uclass.c                      |  208 +-
 drivers/spi/spi.c                             |   27 +-
 drivers/spi/stm32_qspi.c                      |    6 +-
 drivers/sysreset/Kconfig                      |   35 +
 drivers/sysreset/Makefile                     |   22 +-
 drivers/sysreset/sysreset-uclass.c            |   30 +-
 drivers/sysreset/sysreset_psci.c              |    3 +-
 drivers/sysreset/sysreset_sti.c               |    6 +-
 drivers/sysreset/sysreset_syscon.c            |    4 +-
 drivers/sysreset/sysreset_watchdog.c          |    2 +-
 drivers/thermal/Kconfig                       |    6 +
 drivers/thermal/Makefile                      |    1 +
 drivers/timer/rockchip_timer.c                |   80 +-
 drivers/timer/timer-uclass.c                  |   52 +-
 drivers/tpm/tpm_tis_infineon.c                |    2 +-
 drivers/usb/Kconfig                           |   31 +-
 drivers/usb/common/Makefile                   |    2 +-
 drivers/usb/common/common.c                   |   62 +-
 drivers/usb/common/fsl-errata.c               |    7 +-
 drivers/usb/dwc3/Kconfig                      |   22 +
 drivers/usb/dwc3/Makefile                     |    3 +
 drivers/usb/dwc3/core.c                       |  309 +-
 drivers/usb/dwc3/core.h                       |   38 +-
 drivers/usb/dwc3/dwc3-omap.c                  |    3 +-
 drivers/usb/dwc3/ep0.c                        |   15 +-
 drivers/usb/dwc3/gadget.c                     |   73 +-
 drivers/usb/dwc3/linux-compat.h               |    8 -
 drivers/usb/dwc3/ti_usb_phy.c                 |    2 +-
 drivers/usb/emul/sandbox_flash.c              |    3 +-
 drivers/usb/emul/sandbox_hub.c                |   38 +-
 drivers/usb/emul/sandbox_keyb.c               |    6 +-
 drivers/usb/emul/usb-emul-uclass.c            |   65 +-
 drivers/usb/eth/lan78xx.c                     |    2 +-
 drivers/usb/eth/mcs7830.c                     |   12 +-
 drivers/usb/eth/r8152.c                       |    1 -
 drivers/usb/eth/usb_ether.c                   |    2 +-
 drivers/usb/gadget/Kconfig                    |   82 +-
 drivers/usb/gadget/Makefile                   |    4 +-
 drivers/usb/gadget/at91_udc.c                 |    5 +-
 drivers/usb/gadget/atmel_usba_udc.c           |    7 +-
 drivers/usb/gadget/ci_udc.c                   |    2 +-
 drivers/usb/gadget/composite.c                |  221 +-
 drivers/usb/gadget/dwc2_udc_otg.c             |  404 +-
 drivers/usb/gadget/dwc2_udc_otg_phy.c         |    1 -
 drivers/usb/gadget/dwc2_udc_otg_priv.h        |    3 +-
 drivers/usb/gadget/dwc2_udc_otg_regs.h        |   40 +-
 drivers/usb/gadget/dwc2_udc_otg_xfer_dma.c    |   40 +-
 drivers/usb/gadget/epautoconf.c               |    3 +
 drivers/usb/gadget/ether.c                    |   97 +-
 drivers/usb/gadget/f_dfu.c                    |    1 +
 drivers/usb/gadget/f_fastboot.c               | 2039 +++++-
 drivers/usb/gadget/f_mass_storage.c           |   85 +-
 drivers/usb/gadget/f_sdp.c                    |   91 +-
 drivers/usb/gadget/f_thor.c                   |  115 +-
 drivers/usb/gadget/f_thor.h                   |    2 +-
 drivers/usb/gadget/g_dnl.c                    |   15 +-
 drivers/usb/gadget/gadget_chips.h             |   16 +-
 drivers/usb/gadget/pxa25x_udc.c               |    1 -
 drivers/usb/gadget/storage_common.c           |   76 +-
 drivers/usb/gadget/udc/Makefile               |    5 +
 drivers/usb/gadget/udc/udc-core.c             |   26 +-
 drivers/usb/host/Kconfig                      |   79 +-
 drivers/usb/host/Makefile                     |   15 +-
 drivers/usb/host/dwc2.c                       |  155 +-
 drivers/usb/host/dwc2.h                       |    2 +
 drivers/usb/host/ehci-atmel.c                 |    4 +-
 drivers/usb/host/ehci-exynos.c                |    2 +-
 drivers/usb/host/ehci-fsl.c                   |   30 +-
 drivers/usb/host/ehci-generic.c               |  110 +-
 drivers/usb/host/ehci-hcd.c                   |  175 +-
 drivers/usb/host/ehci-marvell.c               |    4 +-
 drivers/usb/host/ehci-msm.c                   |    8 +-
 drivers/usb/host/ehci-mx5.c                   |  103 +
 drivers/usb/host/ehci-mx6.c                   |  134 +-
 drivers/usb/host/ehci-mxs.c                   |    2 +-
 drivers/usb/host/ehci-pci.c                   |   39 +-
 drivers/usb/host/ehci-rcar_gen3.c             |    2 +-
 drivers/usb/host/ehci-sunxi.c                 |   15 +-
 drivers/usb/host/ehci-tegra.c                 |    2 +-
 drivers/usb/host/ehci-vf.c                    |    4 +-
 drivers/usb/host/ehci.h                       |   14 +-
 drivers/usb/host/ohci-da8xx.c                 |  139 +-
 drivers/usb/host/ohci-generic.c               |  101 +-
 drivers/usb/host/ohci-hcd.c                   |   28 +-
 drivers/usb/host/ohci-lpc32xx.c               |   12 +-
 drivers/usb/host/ohci-sunxi.c                 |   19 +-
 drivers/usb/host/ohci.h                       |    8 +-
 drivers/usb/host/r8a66597-hcd.c               |  337 +-
 drivers/usb/host/r8a66597.h                   |  524 +-
 drivers/usb/host/sl811-hcd.c                  |    2 +-
 drivers/usb/host/usb-sandbox.c                |   35 +-
 drivers/usb/host/usb-uclass.c                 |   71 +-
 drivers/usb/host/xhci-dwc3.c                  |   61 +-
 drivers/usb/host/xhci-exynos5.c               |    4 +-
 drivers/usb/host/xhci-fsl.c                   |    9 +-
 drivers/usb/host/xhci-mem.c                   |   35 +-
 drivers/usb/host/xhci-mvebu.c                 |    7 +-
 drivers/usb/host/xhci-omap.c                  |   24 +-
 drivers/usb/host/xhci-pci.c                   |    7 +-
 drivers/usb/host/xhci-ring.c                  |    6 +-
 drivers/usb/host/xhci-zynqmp.c                |   87 +-
 drivers/usb/host/xhci.c                       |  309 +-
 drivers/usb/musb-new/Kconfig                  |   12 +
 drivers/usb/musb-new/Makefile                 |    1 +
 drivers/usb/musb-new/linux-compat.h           |    8 -
 drivers/usb/musb-new/musb_uboot.c             |   24 +-
 drivers/usb/musb-new/omap2430.c               |  596 +-
 drivers/usb/musb-new/sunxi.c                  |   91 +-
 drivers/usb/musb-new/ti-musb.c                |   31 +-
 drivers/usb/musb-new/usb-compat.h             |    2 +-
 drivers/usb/musb/musb_hcd.c                   |    4 +-
 drivers/usb/phy/omap_usb_phy.c                |    2 +-
 drivers/usb/phy/rockchip_usb2_phy.c           |  109 +-
 drivers/usb/ulpi/Kconfig                      |    1 -
 drivers/watchdog/Kconfig                      |    6 +
 drivers/watchdog/Makefile                     |    3 +
 dts/Kconfig                                   |  157 +-
 dts/Makefile                                  |   77 +-
 env/Kconfig                                   |  126 +-
 env/Makefile                                  |    9 +-
 env/common.c                                  |   28 +-
 env/env.c                                     |    6 +-
 env/mmc.c                                     |   62 +-
 env/sf.c                                      |    2 +-
 examples/Makefile                             |    4 +
 examples/api/Makefile                         |    3 +
 examples/api/glue.c                           |   12 +
 fs/Makefile                                   |    1 +
 fs/ext4/Makefile                              |    1 +
 fs/ext4/dev.c                                 |   84 +-
 fs/ext4/ext4_common.c                         |  112 +-
 fs/ext4/ext4_common.h                         |    2 +-
 fs/ext4/ext4_journal.c                        |   28 +-
 fs/ext4/ext4_journal.h                        |    4 +-
 fs/ext4/ext4_write.c                          |   78 +-
 fs/ext4/ext4fs.c                              |  236 +-
 fs/fat/Makefile                               |    4 -
 fs/fat/fat.c                                  | 1091 ++-
 fs/fat/fat_write.c                            |   12 +-
 fs/fs.c                                       |  156 +-
 fs/jffs2/jffs2_nand_1pass.c                   |    2 +-
 fs/reiserfs/dev.c                             |   78 +-
 fs/ubifs/debug.c                              |    6 +-
 fs/ubifs/debug.h                              |    4 +-
 fs/ubifs/scan.c                               |    3 +-
 fs/ubifs/ubifs.c                              |    4 +
 fs/yaffs2/yaffs_mtdif.c                       |    2 +-
 fs/yaffs2/yaffs_uboot_glue.c                  |    2 +-
 fs/zfs/dev.c                                  |   86 +-
 include/android_image.h                       |  384 +-
 include/asm-generic/global_data.h             |   45 +-
 include/asm-generic/sections.h                |    4 +
 include/asm-generic/u-boot.h                  |    9 +-
 include/backlight.h                           |   16 +
 include/blk.h                                 |   52 +-
 include/boot_fit.h                            |    9 +-
 include/bootm.h                               |    6 +-
 include/clk-uclass.h                          |   25 +
 include/clk.h                                 |  134 +-
 include/command.h                             |   10 +
 include/common.h                              |  199 +-
 include/config_fallbacks.h                    |    5 +-
 include/configs/rockchip-common.h             |  184 +-
 include/console.h                             |    5 +
 include/debug_uart.h                          |   43 +
 include/dfu.h                                 |   24 +
 include/dm/device.h                           |   75 +
 include/dm/of_access.h                        |   48 +
 include/dm/ofnode.h                           |   78 +-
 include/dm/pinctrl.h                          |   54 +-
 include/dm/platdata.h                         |    1 -
 include/dm/read.h                             |  101 +
 include/dm/root.h                             |   14 +
 include/dm/uclass-id.h                        |   23 +
 include/dm/uclass-internal.h                  |    2 +-
 include/dm/uclass.h                           |   27 +
 include/dm/util.h                             |    8 -
 include/dt-bindings/clock/rk3036-cru.h        |    1 +
 include/dt-bindings/clock/rk3228-cru.h        |   51 +
 include/dt-bindings/clock/rk3288-cru.h        |   26 +-
 include/dt-bindings/clock/rk3328-cru.h        |  213 +-
 include/dt-bindings/clock/rk3368-cru.h        |   32 +-
 include/dt-bindings/clock/rk3399-cru.h        |    2 +
 include/dt-bindings/clock/rv1108-cru.h        |  105 +-
 include/dt-bindings/phy/phy.h                 |    5 +
 include/dt-bindings/pinctrl/rockchip.h        |   10 +
 include/dt-structs.h                          |   16 +-
 include/dwc3-uboot.h                          |   23 +
 include/dwmmc.h                               |   20 +
 include/edid.h                                |  686 +-
 include/efi.h                                 |    4 +
 include/efi_api.h                             |   64 +
 include/efi_loader.h                          |   31 +-
 include/elf.h                                 |    5 +
 include/env_default.h                         |    3 +
 include/environment.h                         |   21 +-
 include/exports.h                             |    3 +-
 include/ext4fs.h                              |   23 +-
 include/fastboot.h                            |   55 +-
 include/fat.h                                 |   49 +-
 include/fb_mmc.h                              |   10 +-
 include/fb_nand.h                             |    4 +-
 include/fdt.h                                 |    2 +-
 include/fdt_support.h                         |   67 +-
 include/fdtdec.h                              |    9 +-
 include/flash.h                               |    7 +-
 include/fs.h                                  |   76 +
 include/fsl_ifc.h                             |    4 +-
 include/generic-phy.h                         |  118 +-
 include/image-sparse.h                        |    2 +-
 include/image.h                               |  185 +-
 include/jffs2/load_kernel.h                   |    7 +-
 include/keyboard.h                            |   11 +
 include/linux/bitops.h                        |    7 +
 include/linux/bug.h                           |   95 +-
 include/linux/compat.h                        |   46 +-
 include/linux/compiler-gcc.h                  |    1 +
 include/linux/compiler.h                      |    6 +-
 include/linux/input.h                         |    1 +
 include/linux/io.h                            |   44 +
 include/linux/kernel.h                        |    5 +
 include/linux/log2.h                          |   64 +-
 include/linux/lzo.h                           |    3 +
 include/linux/mii.h                           |  126 +-
 include/linux/mtd/fsl_upm.h                   |    2 +-
 include/linux/mtd/fsmc_nand.h                 |    2 +-
 include/linux/mtd/mtd.h                       |  168 +-
 include/linux/mtd/nand.h                      | 1610 ++---
 include/linux/mtd/partitions.h                |   22 +-
 include/linux/sizes.h                         |    3 +
 include/linux/time.h                          |    5 -
 include/linux/types.h                         |    5 +
 include/linux/usb/ch9.h                       |   20 +
 include/linux/usb/composite.h                 |    7 +-
 include/linux/usb/gadget.h                    |   54 +
 include/linux/usb/otg.h                       |   15 +-
 include/lmb.h                                 |    2 +-
 include/miiphy.h                              |   49 +
 include/mipi_display.h                        |    8 +
 include/misc.h                                |   54 +
 include/mmc.h                                 |  188 +-
 include/mpc8xx.h                              |    4 +-
 include/mtd.h                                 |   12 +-
 include/mtd/cfi_flash.h                       |    1 +
 include/nand.h                                |    5 +-
 include/net.h                                 |    6 +-
 include/netdev.h                              |    3 +
 include/nvme.h                                |   12 +
 include/part.h                                |   59 +-
 include/part_efi.h                            |    6 +-
 include/phy.h                                 |  224 +-
 include/post.h                                |    4 +-
 include/power/pmic.h                          |   29 +
 include/power/regulator.h                     |   70 +-
 include/power/rk8xx_pmic.h                    |  101 +
 include/power/sandbox_pmic.h                  |    5 +-
 include/ppc_asm.tmpl                          |    6 +-
 include/regmap.h                              |   50 +-
 include/reset.h                               |  100 +
 include/rtc.h                                 |   14 +
 include/sdhci.h                               |   23 +-
 include/sdp.h                                 |    9 +-
 include/serial.h                              |    8 +
 include/sound.h                               |   10 +
 include/spi.h                                 |  129 +-
 include/spi_flash.h                           |  146 +-
 include/spl.h                                 |   74 +-
 include/stdio_dev.h                           |    3 +
 include/stdlib.h                              |    2 +
 include/syscon.h                              |   19 +-
 include/sysreset.h                            |   35 +
 include/u-boot/crc.h                          |    4 +
 include/u-boot/rsa-mod-exp.h                  |    8 +
 include/u-boot/rsa.h                          |   36 +-
 include/u-boot/sha256.h                       |    2 +
 include/usb.h                                 |   79 +-
 include/usb/dwc2_udc.h                        |    7 +
 include/usb/lin_gadget_compat.h               |    4 +-
 include/usb_mass_storage.h                    |    3 +
 include/video_bridge.h                        |   35 +
 include/vsprintf.h                            |    1 +
 include/wait_bit.h                            |   85 +-
 include/watchdog.h                            |    2 +-
 lib/Kconfig                                   |  111 +-
 lib/Makefile                                  |   32 +-
 lib/asm-offsets.c                             |    5 +
 lib/efi_loader/Makefile                       |    2 +-
 lib/efi_loader/efi_boottime.c                 |   53 +-
 lib/efi_loader/efi_console.c                  |   17 +-
 lib/efi_loader/efi_disk.c                     |   54 +-
 lib/efi_loader/efi_memory.c                   |    2 +-
 lib/efi_loader/efi_net.c                      |    5 +-
 lib/fdtdec.c                                  |  149 +-
 lib/fdtdec_common.c                           |    2 +-
 lib/fdtdec_test.c                             |    2 +-
 lib/gunzip.c                                  |   28 +-
 lib/hang.c                                    |    6 +
 lib/hashtable.c                               |   10 +-
 lib/initcall.c                                |   22 +
 lib/libfdt/Makefile                           |   18 +-
 lib/libfdt/fdt.c                              |  212 +-
 lib/libfdt/fdt_addresses.c                    |   57 +-
 lib/libfdt/fdt_empty_tree.c                   |   39 +-
 lib/libfdt/fdt_overlay.c                      |  679 +-
 lib/libfdt/fdt_region.c                       |  133 +-
 lib/libfdt/fdt_ro.c                           |   27 +-
 lib/libfdt/fdt_rw.c                           |  484 +-
 lib/libfdt/fdt_strerror.c                     |   63 +-
 lib/libfdt/fdt_sw.c                           |  256 +-
 lib/libfdt/fdt_wip.c                          |  229 +-
 lib/libfdt/libfdt.h                           |   31 +
 lib/libfdt/libfdt_internal.h                  |   51 +-
 lib/lz4_wrapper.c                             |   80 +-
 lib/lzma/LzmaTools.c                          |   12 +-
 lib/lzma/LzmaTools.h                          |    1 +
 lib/lzo/lzo1x_decompress.c                    |   21 +-
 lib/of_live.c                                 |    2 +-
 lib/rsa/Kconfig                               |   18 +
 lib/rsa/rsa-checksum.c                        |   54 +-
 lib/rsa/rsa-mod-exp.c                         |   21 +-
 lib/rsa/rsa-sign.c                            |  218 +-
 lib/rsa/rsa-verify.c                          |  557 +-
 lib/sha256.c                                  |   13 +
 lib/strto.c                                   |   45 +-
 lib/tpm.c                                     |   12 +-
 lib/uuid.c                                    |   14 +-
 lib/vsprintf.c                                |   94 +-
 net/Kconfig                                   |    2 +-
 net/Makefile                                  |   10 +-
 net/eth-uclass.c                              |    9 +-
 net/net.c                                     |    9 +
 net/tftp.c                                    |    2 +
 post/post.c                                   |    9 -
 post/tests.c                                  |    4 -
 scripts/Kbuild.include                        |   10 +-
 scripts/Makefile                              |    1 +
 scripts/Makefile.extrawarn                    |   16 +-
 scripts/Makefile.lib                          |   27 +-
 scripts/Makefile.spl                          |   92 +-
 scripts/Makefile.uncmd_spl                    |    2 +-
 scripts/basic/fixdep.c                        |   11 +-
 scripts/checkpatch.pl                         | 2644 +++++--
 scripts/config_whitelist.txt                  |   60 +-
 scripts/dtc-version.sh                        |    7 +-
 scripts/get_maintainer.pl                     |  202 +-
 scripts/mailmapper                            |    2 +-
 scripts/setlocalversion                       |   13 +-
 test/Kconfig                                  |   12 +
 test/Makefile                                 |    2 +
 test/dm/Makefile                              |    2 +
 test/dm/clk.c                                 |   38 +
 test/dm/cmd_dm.c                              |   14 +-
 test/dm/core.c                                |    9 +
 test/dm/regulator.c                           |    2 +
 test/dm/reset.c                               |   33 +
 test/dm/sf.c                                  |   58 +
 test/dm/spi.c                                 |    8 +-
 test/dm/syscon.c                              |   29 +
 test/dm/test-main.c                           |    2 +-
 test/overlay/Makefile                         |    1 +
 test/overlay/cmd_ut_overlay.c                 |   50 +-
 test/py/multiplexed_log.css                   |    4 +
 test/py/multiplexed_log.py                    |   37 +
 test/py/test.py                               |    2 +-
 test/py/tests/test_env.py                     |   11 +-
 test/py/u_boot_console_base.py                |    5 +-
 tools/.gitignore                              |   10 +-
 tools/Makefile                                |   71 +-
 tools/binman/binman.py                        |    2 +-
 tools/buildman/buildman.py                    |    2 +-
 tools/buildman/kconfiglib.py                  |   22 +-
 tools/dtoc/dtb_platdata.py                    |  206 +-
 tools/dtoc/dtoc.py                            |    2 +-
 tools/dtoc/dtoc_test_phandle.dts              |   16 +-
 tools/dtoc/dtoc_test_simple.dts               |   14 +
 tools/dtoc/fdt.py                             |   19 +-
 tools/dtoc/fdt_util.py                        |   16 +
 tools/dtoc/test_dtoc.py                       |  304 +-
 tools/env/.gitignore                          |    1 +
 tools/env/Makefile                            |    2 +
 tools/env/fw_env_main.c                       |   14 +-
 tools/fdt_host.h                              |   21 +-
 tools/fdtgrep.c                               |    7 +-
 tools/fit_check_sign.c                        |    8 +-
 tools/fit_image.c                             |  115 +-
 tools/fit_info.c                              |    1 +
 tools/gen_ethaddr_crc.c                       |    1 +
 tools/genboardscfg.py                         |    7 +-
 tools/ifdtool.c                               |    3 +-
 tools/image-host.c                            |   99 +-
 tools/imagetool.h                             |    3 +
 tools/microcode-tool.py                       |    2 +-
 tools/mips-relocs.c                           |    1 +
 tools/mkimage.c                               |   35 +-
 tools/moveconfig.py                           |    6 +-
 tools/patman/README                           |   12 +
 tools/patman/patman.py                        |    2 +-
 tools/patman/series.py                        |    5 +
 tools/patman/settings.py                      |   44 +-
 tools/patman/test.py                          |   41 +-
 tools/rkcommon.c                              |  466 +-
 tools/rkcommon.h                              |   18 +-
 tools/rkmux.py                                |    2 +-
 tools/rksd.c                                  |   35 +-
 tools/rkspi.c                                 |   42 +-
 tools/zynqmpimage.c                           |   99 +-
 884 files changed, 55753 insertions(+), 16227 deletions(-)
 mode change 100644 => 100755 common/fb_mmc.c
 mode change 100644 => 100755 common/usb.c
 mode change 100644 => 100755 lib/libfdt/fdt_ro.c

diff --git a/.gitignore b/.gitignore
index 29757aa51e..4ab7be6ec9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -85,3 +85,5 @@ GTAGS
 *.orig
 *~
 \#*#
+
+idbloader.img
diff --git a/Kconfig b/Kconfig
index 238fa3e1ed..b92331e8e0 100644
--- a/Kconfig
+++ b/Kconfig
@@ -14,6 +14,12 @@ source "arch/Kconfig"
 
 menu "General setup"
 
+config BROKEN
+	bool
+	help
+	  This option cannot be enabled. It is used as dependency
+	  for broken and incomplete features.
+
 config LOCALVERSION
 	string "Local version - append to U-Boot release"
 	help
@@ -63,12 +69,12 @@ config DISTRO_DEFAULTS
 	select CMD_BOOTZ if ARM && !ARM64
 	select CMD_BOOTI if ARM64
 	select CMD_DHCP
-	select CMD_PXE
+	imply CMD_PXE
 	select CMD_EXT2
 	select CMD_EXT4
 	select CMD_FAT
 	select CMD_FS_GENERIC
-	select CMD_MII
+	imply CMD_MII
 	select CMD_PING
 	select CMD_PART
 	select HUSH_PARSER
@@ -127,7 +133,7 @@ menuconfig EXPERT
 if EXPERT
 	config SYS_MALLOC_CLEAR_ON_INIT
 	bool "Init with zeros the memory reserved for malloc (slow)"
-	default y
+	default y if !ARCH_ROCKCHIP
 	help
 	  This setting is enabled by default. The reserved malloc
 	  memory is initialized with zeros, so first malloc calls
@@ -171,8 +177,6 @@ config ANDROID_BOOT_IMAGE
 
 config FIT
 	bool "Support Flattened Image Tree"
-	select MD5
-	select SHA1
 	help
 	  This option allows you to boot the new uImage structure,
 	  Flattened Image Tree.  FIT is formally a FDT, which can include
@@ -187,7 +191,7 @@ if FIT
 
 config FIT_ENABLE_SHA256_SUPPORT
 	bool "Support SHA256 checksum of FIT image contents"
-	select SHA256
+	select SHA256 if !DM_CRYPTO
 	default y
 	help
 	  Enable this to support SHA256 checksum of FIT image contents. A
@@ -203,6 +207,7 @@ config FIT_SIGNATURE
 	bool "Enable signature verification of FIT uImages"
 	depends on DM
 	select RSA
+	select CONSOLE_DISABLE_CLI
 	help
 	  This option enables signature verification of FIT uImages,
 	  using a hash signed and verified using RSA. If
@@ -216,6 +221,20 @@ config FIT_SIGNATURE
 	  format support in this case, enable it using
 	  CONFIG_IMAGE_FORMAT_LEGACY.
 
+config FIT_ROLLBACK_PROTECT
+	bool "Enable rollback-index protection for FIT image"
+	depends on FIT_SIGNATURE
+	help
+	  Enable rollback-index protection for FIT image
+
+config FIT_ENABLE_RSASSA_PSS_SUPPORT
+	bool "Support rsassa-pss signature scheme of FIT image contents"
+	depends on FIT_SIGNATURE
+	default y
+	help
+	  Enable this to support the pss padding algorithm as described
+	  in the rfc8017 (https://tools.ietf.org/html/rfc8017).
+
 config FIT_VERBOSE
 	bool "Show verbose messages when FIT images fail"
 	help
@@ -235,7 +254,6 @@ config FIT_BEST_MATCH
 
 config FIT_IMAGE_POST_PROCESS
 	bool "Enable post-processing of FIT artifacts after loading by U-Boot"
-	depends on TI_SECURE_DEVICE
 	help
 	  Allows doing any sort of manipulation to blobs after they got extracted
 	  from FIT images like stripping off headers or modifying the size of the
@@ -247,6 +265,19 @@ config FIT_IMAGE_POST_PROCESS
 	  injected into the FIT creation (i.e. the blobs would have been pre-
 	  processed before being added to the FIT image).
 
+config FIT_HW_CRYPTO
+	bool "Enable hardware crypto for FIT image checksum and rsa verify"
+	depends on DM_CRYPTO
+	help
+	  Enable hardware crypto for FIT image checksum and rsa verify.
+
+config FIT_PRINT
+	bool "Enable fit image structure and data print"
+	default y
+	help
+	  Say y here if you want to enable fit image structure and data
+	  print.
+
 if SPL
 
 config SPL_FIT
@@ -260,6 +291,12 @@ config SPL_FIT_SIGNATURE
 	select SPL_FIT
 	select SPL_RSA
 
+config SPL_FIT_ROLLBACK_PROTECT
+	bool "Enable SPL rollback-index protection for FIT image"
+	depends on SPL_FIT_SIGNATURE
+	help
+	  Enable SPL rollback-index protection for FIT image
+
 config SPL_LOAD_FIT
 	bool "Enable SPL loading U-Boot as a FIT"
 	select SPL_FIT
@@ -273,7 +310,7 @@ config SPL_LOAD_FIT
 
 config SPL_FIT_IMAGE_POST_PROCESS
 	bool "Enable post-processing of FIT artifacts after loading by the SPL"
-	depends on SPL_LOAD_FIT && TI_SECURE_DEVICE
+	depends on SPL_LOAD_FIT
 	help
 	  Allows doing any sort of manipulation to blobs after they got extracted
 	  from the U-Boot FIT image like stripping off headers or modifying the
@@ -285,9 +322,31 @@ config SPL_FIT_IMAGE_POST_PROCESS
 	  injected into the FIT creation (i.e. the blobs would have been pre-
 	  processed before being added to the FIT image).
 
+config SPL_FIT_HW_CRYPTO
+	bool "Enable SPL hardware crypto for FIT image checksum and rsa verify"
+	depends on SPL_DM_CRYPTO
+	help
+	  Enable SPL hardware crypto for FIT image checksum and rsa verify.
+
+config SPL_SYS_DCACHE_OFF
+	bool "Disable SPL dcache"
+	default y
+	help
+	  Disable SPL dcache. Please make sure CONFIG_SPL_SYS_MALLOC_F_LEN
+	  is large enough to malloc TLB and bd_t buffer while enabling dcache.
+
+config SPL_FIT_PRINT
+	bool "Enable fit image structure and data print in SPL"
+	default n
+	help
+	  Say y here if you want to enable fit image structure and data
+	  print in SPL.
+
+endif # SPL
+
 config SPL_FIT_SOURCE
 	string ".its source file for U-Boot FIT image"
-	depends on SPL_FIT
+	depends on SPL_FIT || FIT
 	help
 	  Specifies a (platform specific) FIT source file to generate the
 	  U-Boot FIT image. This could specify further image to load and/or
@@ -295,7 +354,7 @@ config SPL_FIT_SOURCE
 
 config SPL_FIT_GENERATOR
 	string ".its file generator script for U-Boot FIT image"
-	depends on SPL_FIT
+	depends on SPL_FIT || FIT
 	default "board/sunxi/mksunxi_fit_atf.sh" if SPL_LOAD_FIT && ARCH_SUNXI
 	help
 	  Specifies a (platform specific) script file to generate the FIT
@@ -303,7 +362,19 @@ config SPL_FIT_GENERATOR
 	  passed a list of supported device tree file stub names to
 	  include in the generated image.
 
-endif # SPL
+config SPL_FIT_IMAGE_KB
+	int "SPL FIT image size in KiB"
+	depends on SPL_FIT || FIT
+	default 2048
+	help
+	  SPL FIT image size in KiB, default 2048KB = 1024KB(u-boot) + 1024KB(tee/atf + others).
+
+config SPL_FIT_IMAGE_MULTIPLE
+	int "SPL FIT image multiple number"
+	depends on SPL_FIT || FIT
+	default 2
+	help
+	  SPL FIT image multiple number.
 
 endif # FIT
 
@@ -398,5 +469,3 @@ source "fs/Kconfig"
 source "lib/Kconfig"
 
 source "test/Kconfig"
-
-source "scripts/Kconfig"
diff --git a/Makefile b/Makefile
index 8086f3c93e..b70a9d499d 100644
--- a/Makefile
+++ b/Makefile
@@ -349,7 +349,7 @@ OBJDUMP		= $(CROSS_COMPILE)objdump
 AWK		= awk
 PERL		= perl
 PYTHON		?= python
-DTC		?= dtc
+DTC		?= $(objtree)/scripts/dtc/dtc
 CHECK		= sparse
 
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
@@ -360,6 +360,7 @@ KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__
 KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
 		   -Wno-format-security \
 		   -fno-builtin -ffreestanding
+KBUILD_CFLAGS	+= -fshort-wchar -Werror
 KBUILD_AFLAGS   := -D__ASSEMBLY__
 
 # Read UBOOTRELEASE from include/config/uboot.release (if it exists)
@@ -604,6 +605,7 @@ ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-stack-usage.sh $(CC)),y)
 endif
 
 KBUILD_CFLAGS += $(call cc-option,-Wno-format-nonliteral)
+KBUILD_CFLAGS += $(call cc-disable-warning, address-of-packed-member)
 
 # turn jbsr into jsr for m68k
 ifeq ($(ARCH),m68k)
@@ -649,15 +651,17 @@ HAVE_VENDOR_COMMON_LIB = $(if $(wildcard $(srctree)/board/$(VENDOR)/common/Makef
 libs-y += lib/
 libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
 libs-$(CONFIG_OF_EMBED) += dts/
+ifneq ($(CONFIG_SPL_BUILD)$(CONFIG_SPL_DECOMP_HEADER),yy)
 libs-y += fs/
 libs-y += net/
 libs-y += disk/
 libs-y += drivers/
+libs-y += drivers/cpu/
 libs-y += drivers/dma/
 libs-y += drivers/gpio/
 libs-y += drivers/i2c/
 libs-y += drivers/mtd/
-libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/
+libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/raw/
 libs-y += drivers/mtd/onenand/
 libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/
 libs-y += drivers/mtd/spi/
@@ -670,13 +674,17 @@ libs-y += drivers/power/ \
 	drivers/power/mfd/ \
 	drivers/power/pmic/ \
 	drivers/power/battery/ \
-	drivers/power/regulator/
+	drivers/power/regulator/ \
+	drivers/power/dvfs/ \
+	drivers/power/io-domain/ \
+	drivers/power/charge/
 libs-y += drivers/spi/
 libs-$(CONFIG_FMAN_ENET) += drivers/net/fm/
 libs-$(CONFIG_SYS_FSL_DDR) += drivers/ddr/fsl/
 libs-$(CONFIG_SYS_FSL_MMDC) += drivers/ddr/fsl/
 libs-$(CONFIG_ALTERA_SDRAM) += drivers/ddr/altera/
 libs-y += drivers/serial/
+libs-y += drivers/usb/cdns3/
 libs-y += drivers/usb/dwc3/
 libs-y += drivers/usb/common/
 libs-y += drivers/usb/emul/
@@ -693,6 +701,7 @@ libs-y += common/
 libs-y += env/
 libs-$(CONFIG_API) += api/
 libs-$(CONFIG_HAS_POST) += post/
+endif
 libs-y += test/
 libs-y += test/dm/
 libs-$(CONFIG_UT_ENV) += test/env/
@@ -765,6 +774,7 @@ endif
 
 # Always append ALL so that arch config.mk's can add custom ones
 ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check
+ALL-$(CONFIG_SUPPORT_USBPLUG) += usbplug.bin
 
 ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin
 ifeq ($(CONFIG_SPL_FSL_PBL),y)
@@ -799,6 +809,21 @@ ifneq ($(BUILD_ROM),)
 ALL-$(CONFIG_X86_RESET_VECTOR) += u-boot.rom
 endif
 
+ifeq ($(CONFIG_ARCH_ROCKCHIP),y)
+# On ARM64 this target is produced by binman so we don't need this dep
+ifeq ($(CONFIG_ARM64),y)
+ifeq ($(CONFIG_SPL),y)
+# TODO: Get binman to generate this too
+ALL-y += u-boot-rockchip.bin
+endif
+else # CONFIG_ARM64
+ifeq ($(CONFIG_SPL),y)
+# Generate these inputs for binman which will create the output files
+ALL-y += idbloader.img u-boot.img
+endif
+endif # CONFIG_ARM64
+endif # CONFIG_ARCH_ROCKCHIP
+
 # enable combined SPL/u-boot/dtb rules for tegra
 ifeq ($(CONFIG_TEGRA)$(CONFIG_SPL),yy)
 ALL-y += u-boot-tegra.bin u-boot-nodtb-tegra.bin
@@ -837,6 +862,9 @@ quiet_cmd_mkimage = MKIMAGE $@
 cmd_mkimage = $(objtree)/tools/mkimage $(MKIMAGEFLAGS_$(@F)) -d $< $@ \
 	$(if $(KBUILD_VERBOSE:1=), >$(MKIMAGEOUTPUT))
 
+cmd_mkimage_combined = $(objtree)/tools/mkimage $(MKIMAGEFLAGS_$(@F)) -d $(COMBINED_FILE):$< $@ \
+	$(if $(KBUILD_VERBOSE:1=), >$(MKIMAGEOUTPUT))
+
 quiet_cmd_mkfitimage = MKIMAGE $@
 cmd_mkfitimage = $(objtree)/tools/mkimage $(MKIMAGEFLAGS_$(@F)) -f $(U_BOOT_ITS) -E $@ \
 	$(if $(KBUILD_VERBOSE:1=), >$(MKIMAGEOUTPUT))
@@ -871,13 +899,16 @@ endif
 PHONY += dtbs
 dtbs: dts/dt.dtb
 	@:
-dts/dt.dtb: checkdtc u-boot
+dts/dt.dtb: u-boot
 	$(Q)$(MAKE) $(build)=dts dtbs
 
 quiet_cmd_copy = COPY    $@
       cmd_copy = cp $< $@
 
-ifeq ($(CONFIG_FIT_EMBED),y)
+quiet_cmd_truncate = ALIGN   $@
+      cmd_truncate = truncate -s "%8" $@
+
+ifeq ($(CONFIG_MULTI_DTB_FIT),y)
 
 fit-dtb.blob: dts/dt.dtb FORCE
 	$(call if_changed,mkimage)
@@ -892,16 +923,33 @@ u-boot-fit-dtb.bin: u-boot-nodtb.bin fit-dtb.blob
 u-boot.bin: u-boot-fit-dtb.bin FORCE
 	$(call if_changed,copy)
 else ifeq ($(CONFIG_OF_SEPARATE),y)
+
 u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE
 	$(call if_changed,cat)
 
+EMBED_KERN_DTB := $(CONFIG_EMBED_KERNEL_DTB_PATH:"%"=%)
+ifneq ($(wildcard $(EMBED_KERN_DTB)),)
+u-boot-dtb-kern.bin: u-boot-dtb.bin FORCE
+	$(call if_changed,copy)
+	$(call if_changed,truncate)
+u-boot.bin: u-boot-dtb-kern.bin $(EMBED_KERN_DTB) FORCE
+	$(call if_changed,cat)
+else
 u-boot.bin: u-boot-dtb.bin FORCE
 	$(call if_changed,copy)
+	$(call if_changed,truncate)
+endif
+
 else
 u-boot.bin: u-boot-nodtb.bin FORCE
 	$(call if_changed,copy)
 endif
 
+ifeq ($(CONFIG_SUPPORT_USBPLUG),y)
+usbplug.bin: u-boot.bin
+	$(call if_changed,copy)
+endif
+
 %.imx: %.bin
 	$(Q)$(MAKE) $(build)=arch/arm/mach-imx $@
 
@@ -911,7 +959,7 @@ endif
 quiet_cmd_copy = COPY    $@
       cmd_copy = cp $< $@
 
-u-boot.dtb: dts/dt.dtb
+u-boot.dtb: dts/dt.dtb FORCE
 	$(call cmd,copy)
 
 OBJCOPYFLAGS_u-boot.hex := -O ihex
@@ -981,7 +1029,7 @@ U_BOOT_ITS = $(subst ",,$(CONFIG_SPL_FIT_SOURCE))
 else
 ifneq ($(CONFIG_SPL_FIT_GENERATOR),"")
 U_BOOT_ITS := u-boot.its
-$(U_BOOT_ITS): FORCE
+$(U_BOOT_ITS): dtbs FORCE
 	$(srctree)/$(CONFIG_SPL_FIT_GENERATOR) \
 	$(patsubst %,arch/$(ARCH)/dts/%.dtb,$(subst ",,$(CONFIG_OF_LIST))) > $@
 endif
@@ -1042,6 +1090,21 @@ OBJCOPYFLAGS_u-boot-with-spl.bin = -I binary -O binary \
 u-boot-with-spl.bin: spl/u-boot-spl.bin $(SPL_PAYLOAD) FORCE
 	$(call if_changed,pad_cat)
 
+ifeq ($(CONFIG_ARCH_ROCKCHIP),y)
+MKIMAGEFLAGS_idbloader.img = -n $(CONFIG_SYS_SOC) -T rksd
+COMBINED_FILE = ram_init.bin
+idbloader.img: spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage_combined)
+
+ifeq ($(CONFIG_ARM64),y)
+OBJCOPYFLAGS_u-boot-rockchip.bin = -I binary -O binary \
+	--pad-to=$(CONFIG_SPL_PAD_TO) --gap-fill=0xff
+u-boot-rockchip.bin: idbloader.img u-boot.itb FORCE
+	$(call if_changed,pad_cat)
+endif # CONFIG_ARM64
+
+endif #CONFIG_ARCH_ROCKCHIP
+
 MKIMAGEFLAGS_lpc32xx-spl.img = -T lpc32xximage -a $(CONFIG_SPL_TEXT_BASE)
 
 lpc32xx-spl.img: spl/u-boot-spl.bin FORCE
@@ -1134,7 +1197,7 @@ cmd_ldr = $(LD) $(LDFLAGS_$(@F)) \
 
 u-boot.rom: u-boot-x86-16bit.bin u-boot.bin \
 		$(if $(CONFIG_SPL_X86_16BIT_INIT),spl/u-boot-spl.bin) \
-		$(if $(CONFIG_HAVE_REFCODE),refcode.bin) checkbinman FORCE
+		$(if $(CONFIG_HAVE_REFCODE),refcode.bin) FORCE
 	$(call if_changed,binman)
 
 OBJCOPYFLAGS_u-boot-x86-16bit.bin := -O binary -j .start16 -j .resetvec
@@ -1143,8 +1206,7 @@ u-boot-x86-16bit.bin: u-boot FORCE
 endif
 
 ifneq ($(CONFIG_ARCH_SUNXI),)
-u-boot-sunxi-with-spl.bin: spl/sunxi-spl.bin u-boot.img u-boot.dtb \
-		checkbinman FORCE
+u-boot-sunxi-with-spl.bin: spl/sunxi-spl.bin u-boot.img u-boot.dtb FORCE
 	$(call if_changed,binman)
 endif
 
@@ -1336,12 +1398,21 @@ prepare: prepare0
 # Generate some files
 # ---------------------------------------------------------------------------
 
+ifeq ($(CONFIG_SUPPORT_USBPLUG),)
 define filechk_version.h
 	(echo \#define PLAIN_VERSION \"$(UBOOTRELEASE)\"; \
 	echo \#define U_BOOT_VERSION \"U-Boot \" PLAIN_VERSION; \
 	echo \#define CC_VERSION_STRING \"$$(LC_ALL=C $(CC) --version | head -n 1)\"; \
 	echo \#define LD_VERSION_STRING \"$$(LC_ALL=C $(LD) --version | head -n 1)\"; )
 endef
+else
+define filechk_version.h
+        (echo \#define PLAIN_VERSION \"$(UBOOTRELEASE)\"; \
+        echo \#define U_BOOT_VERSION \"USB-PLUG \" PLAIN_VERSION; \
+        echo \#define CC_VERSION_STRING \"$$(LC_ALL=C $(CC) --version | head -n 1)\"; \
+        echo \#define LD_VERSION_STRING \"$$(LC_ALL=C $(LD) --version | head -n 1)\"; )
+endef
+endif
 
 # The SOURCE_DATE_EPOCH mechanism requires a date that behaves like GNU date.
 # The BSD date on the other hand behaves different and would produce errors
@@ -1378,18 +1449,6 @@ $(version_h): include/config/uboot.release FORCE
 $(timestamp_h): $(srctree)/Makefile FORCE
 	$(call filechk,timestamp.h)
 
-checkbinman: tools
-	@if ! ( echo 'import libfdt' | ( PYTHONPATH=tools $(PYTHON) )); then \
-		echo >&2; \
-		echo >&2 '*** binman needs the Python libfdt library.'; \
-		echo >&2 '*** Either install it on your system, or try:'; \
-		echo >&2 '***'; \
-		echo >&2 '*** sudo apt-get install swig libpython-dev'; \
-		echo >&2 '***'; \
-		echo >&2 '*** to have U-Boot build its own version.'; \
-		false; \
-	fi
-
 # ---------------------------------------------------------------------------
 quiet_cmd_cpp_lds = LDS     $@
 cmd_cpp_lds = $(CPP) -Wp,-MD,$(depfile) $(cpp_flags) $(LDPPFLAGS) \
@@ -1401,8 +1460,8 @@ u-boot.lds: $(LDSCRIPT) prepare FORCE
 spl/u-boot-spl.bin: spl/u-boot-spl
 	@:
 spl/u-boot-spl: tools prepare \
-		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_SPL_OF_PLATDATA),dts/dt.dtb) \
-		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_TPL_OF_PLATDATA),dts/dt.dtb)
+		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_OF_EMBED)$(CONFIG_SPL_OF_PLATDATA),dts/dt.dtb) \
+		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_OF_EMBED)$(CONFIG_TPL_OF_PLATDATA),dts/dt.dtb)
 	$(Q)$(MAKE) obj=spl -f $(srctree)/scripts/Makefile.spl all
 
 spl/sunxi-spl.bin: spl/u-boot-spl
@@ -1418,7 +1477,7 @@ spl/boot.bin: spl/u-boot-spl
 	@:
 
 tpl/u-boot-tpl.bin: tools prepare \
-		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_SPL_OF_PLATDATA),dts/dt.dtb)
+		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_OF_EMBED)$(CONFIG_SPL_OF_PLATDATA),dts/dt.dtb)
 	$(Q)$(MAKE) obj=tpl -f $(srctree)/scripts/Makefile.spl all
 
 TAG_SUBDIRS := $(patsubst %,$(srctree)/%,$(u-boot-dirs) include)
@@ -1446,12 +1505,6 @@ SYSTEM_MAP = \
 System.map:	u-boot
 		@$(call SYSTEM_MAP,$<) > $@
 
-checkdtc:
-	@if test $(call dtc-version) -lt 0104; then \
-		echo '*** Your dtc is too old, please upgrade to dtc 1.4 or newer'; \
-		false; \
-	fi
-
 #########################################################################
 
 # ARM relocations should all be R_ARM_RELATIVE (32-bit) or
@@ -1465,7 +1518,7 @@ checkarmreloc: u-boot
 		false; \
 	fi
 
-envtools: scripts_basic
+envtools: scripts_basic $(version_h) $(timestamp_h)
 	$(Q)$(MAKE) $(build)=tools/env
 
 tools-only: scripts_basic $(version_h) $(timestamp_h)
@@ -1497,7 +1550,7 @@ CLEAN_DIRS  += $(MODVERDIR) \
 			$(filter-out include, $(shell ls -1 $d 2>/dev/null))))
 
 CLEAN_FILES += include/bmp_logo.h include/bmp_logo_data.h \
-	       boot* u-boot* MLO* SPL System.map fit-dtb.blob
+	       boot* u-boot* MLO* SPL System.map fit-dtb.blob *.bin *.img *.gz .cc
 
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config include/generated spl tpl \
@@ -1682,6 +1735,13 @@ endif
 	$(build)=$(build-dir) $(@:.ko=.o)
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
 
+quiet_cmd_genenv = GENENV $@
+cmd_genenv = $(OBJCOPY) --dump-section .rodata.default_environment=$@ env/common.o; \
+	sed --in-place -e 's/\x00/\x0A/g' $@
+
+u-boot-initial-env: u-boot.bin
+	$(call if_changed,genenv)
+
 # FIXME Should go into a make.lib or something
 # ===========================================================================
 
diff --git a/api/api_platform-powerpc.c b/api/api_platform-powerpc.c
index 9e9bc63b2f..aae7ddee95 100644
--- a/api/api_platform-powerpc.c
+++ b/api/api_platform-powerpc.c
@@ -30,7 +30,7 @@ int platform_sys_info(struct sys_info *si)
 	si->clk_bus = gd->bus_clk;
 	si->clk_cpu = gd->cpu_clk;
 
-#if defined(CONFIG_8xx) || defined(CONFIG_E500) || defined(CONFIG_MPC86xx)
+#if defined(CONFIG_MPC8xx) || defined(CONFIG_E500) || defined(CONFIG_MPC86xx)
 #define bi_bar	bi_immr_base
 #elif defined(CONFIG_MPC83xx)
 #define bi_bar	bi_immrbar
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 53eae8953e..1ab2880e09 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -9,6 +9,22 @@ config ARM64
 	select PHYS_64BIT
 	select SYS_CACHE_SHIFT_6
 
+if ARM64
+config POSITION_INDEPENDENT
+	bool "Generate position-independent pre-relocation code"
+	help
+	  U-Boot expects to be linked to a specific hard-coded address, and to
+	  be loaded to and run from that address. This option lifts that
+	  restriction, thus allowing the code to be loaded to and executed
+	  from almost any address. This logic relies on the relocation
+	  information that is embedded into the binary to support U-Boot
+	  relocating itself to the top-of-RAM later during execution.
+endif
+
+config STATIC_RELA
+	bool
+	default y if ARM64 && !POSITION_INDEPENDENT
+
 config DMA_ADDR_T_64BIT
 	bool
 	default y if ARM64
@@ -106,6 +122,9 @@ config ARM_ERRATA_852421
 config ARM_ERRATA_852423
 	bool
 
+config ARM_ZERO_CNTVOFF
+	bool
+
 config CPU_ARM720T
 	bool
 	select SYS_CACHE_SHIFT_5
@@ -202,6 +221,13 @@ config ARM_SMCCC
 	  This should be enabled if U-Boot needs to communicate with system
 	  firmware (for example, PSCI) according to SMCCC.
 
+config ARM_CPU_SUSPEND
+	bool "Support for ARM cpu suspend and resume"
+	depends on CPU_V7 || ARM64
+	help
+	  Say Y here if you want to enable ARM cpu suspend/resume which allows
+	  to poweroff cpu power supply.
+
 config SEMIHOSTING
 	bool "support boot from semihosting"
 	help
@@ -228,6 +254,17 @@ config SPL_SYS_THUMB_BUILD
 	   density. For ARM architectures that support Thumb2 this flag will
 	   result in Thumb2 code generated by GCC.
 
+config TPL_SYS_THUMB_BUILD
+	bool "Build TPL using the Thumb instruction set"
+	default y if SYS_THUMB_BUILD
+	depends on TPL && !ARM64
+	help
+	   Use this flag to build SPL using the Thumb instruction set for
+	   ARM architectures. Thumb instruction set provides better code
+	   density. For ARM architectures that support Thumb2 this flag will
+	   result in Thumb2 code generated by GCC.
+
+
 config SYS_L2CACHE_OFF
 	bool "L2cache off"
 	help
@@ -264,6 +301,15 @@ config SPL_USE_ARCH_MEMCPY
 	  Such implementation may be faster under some conditions
 	  but may increase the binary size.
 
+config TPL_USE_ARCH_MEMCPY
+	bool "Use an assembly optimized implementation of memcpy for TPL"
+	default y if USE_ARCH_MEMCPY
+	depends on !ARM64
+	help
+	  Enable the generation of an optimized version of memcpy.
+	  Such implementation may be faster under some conditions
+	  but may increase the binary size.
+
 config USE_ARCH_MEMSET
 	bool "Use an assembly optimized implementation of memset"
 	default y
@@ -282,6 +328,15 @@ config SPL_USE_ARCH_MEMSET
 	  Such implementation may be faster under some conditions
 	  but may increase the binary size.
 
+config TPL_USE_ARCH_MEMSET
+	bool "Use an assembly optimized implementation of memset for TPL"
+	default y if USE_ARCH_MEMSET
+	depends on !ARM64
+	help
+	  Enable the generation of an optimized version of memset.
+	  Such implementation may be faster under some conditions
+	  but may increase the binary size.
+
 config ARM64_SUPPORT_AARCH32
 	bool "ARM64 system support AArch32 execution state"
 	default y if ARM64 && !TARGET_THUNDERX_88XX
@@ -330,6 +385,7 @@ config ARCH_MVEBU
 	select DM_SERIAL
 	select DM_SPI
 	select DM_SPI_FLASH
+	select SPI
 
 config TARGET_DEVKIT3250
 	bool "Support devkit3250"
@@ -440,6 +496,7 @@ config TARGET_STV0991
 	select DM_SERIAL
 	select DM_SPI
 	select DM_SPI_FLASH
+	select SPI
 	select SPI_FLASH
 
 config TARGET_X600
@@ -555,6 +612,7 @@ config ARCH_EXYNOS
 	select DM_SPI
 	select DM_GPIO
 	select DM_KEYBOARD
+	select SPI
 	imply FAT_WRITE
 
 config ARCH_S5PC1XX
@@ -673,6 +731,7 @@ config ARCH_SOCFPGA
 
 config ARCH_SUNXI
 	bool "Support sunxi (Allwinner) SoCs"
+	select BINMAN
 	select CMD_GPIO
 	select CMD_MMC if MMC
 	select CMD_USB if DISTRO_DEFAULTS
@@ -740,6 +799,7 @@ config ARCH_ZYNQ
 	select CLK
 	select SPL_CLK
 	select CLK_ZYNQ
+	select SPI
 	imply CMD_CLK
 	imply FAT_WRITE
 	imply CMD_SPL
@@ -757,6 +817,7 @@ config ARCH_ZYNQMP
 	select SPL_CLK
 	select DM_USB if USB
 	imply FAT_WRITE
+	imply DM_USB_GADGET
 
 config TEGRA
 	bool "NVIDIA Tegra"
@@ -1074,20 +1135,28 @@ config ARCH_ROCKCHIP
 	select SYS_MALLOC_F
 	select SYS_THUMB_BUILD if !ARM64
 	select SPL_SYS_MALLOC_SIMPLE if SPL
-	select DM_GPIO
-	select DM_I2C
-	select DM_MMC
+	imply DM_GPIO
 	select DM_SERIAL
-	select DM_SPI
-	select DM_SPI_FLASH
 	select DM_USB if USB
-	select DM_PWM
-	select DM_REGULATOR
+	select CMD_ROCKUSB if USB_GADGET_DOWNLOAD
+	select ENABLE_ARM_SOC_BOOT0_HOOK
+	select SYS_NS16550
+	select SPI
+	select DEBUG_UART_BOARD_INIT
+	select PANIC_HANG
+	imply DM_MMC
+	imply DM_I2C
+	imply DM_PWM
+	imply DM_REGULATOR
 	imply CMD_FASTBOOT
 	imply FASTBOOT
 	imply FAT_WRITE
 	imply USB_FUNCTION_FASTBOOT
+	imply USB_FUNCTION_ROCKUSB
 	imply SPL_SYSRESET
+	imply TPL_SYSRESET
+	imply ADC
+	imply SARADC_ROCKCHIP
 
 config TARGET_THUNDERX_88XX
 	bool "Support ThunderX 88xx"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 0e0ae77822..65a493d580 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -18,7 +18,7 @@ arch-$(CONFIG_CPU_ARM1136)	=-march=armv5
 arch-$(CONFIG_CPU_ARM1176)	=-march=armv5t
 arch-$(CONFIG_CPU_V7)		=$(call cc-option, -march=armv7-a, \
 				 $(call cc-option, -march=armv7, -march=armv5))
-arch-$(CONFIG_ARM64)		=-march=armv8-a
+arch-$(CONFIG_ARM64)		=-march=armv8-a+nosimd
 
 # On Tegra systems we must build SPL for the armv4 core on the device
 # but otherwise we can use the value in CONFIG_SYS_ARM_ARCH
diff --git a/arch/arm/config.mk b/arch/arm/config.mk
index 1a77779db4..bd83fcab71 100644
--- a/arch/arm/config.mk
+++ b/arch/arm/config.mk
@@ -105,6 +105,12 @@ endif
 # needed for relocation
 LDFLAGS_u-boot += -pie
 
+ifndef CONFIG_SPL_SKIP_RELOCATE
+LDFLAGS_u-boot-spl = -pie
+else
+SPL_LDFLAGS_u-boot-spl =
+endif
+
 #
 # FIXME: binutils versions < 2.22 have a bug in the assembler where
 # branches to weak symbols can be incorrectly optimized in thumb mode
@@ -139,7 +145,8 @@ OBJCOPYFLAGS += -j .text -j .secure_text -j .secure_data -j .rodata -j .data \
 		-j .u_boot_list -j .rela.dyn -j .got -j .got.plt
 else
 OBJCOPYFLAGS += -j .text -j .secure_text -j .secure_data -j .rodata -j .hash \
-		-j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn
+		-j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn \
+		-j .ARM.exidx -j .ARM.extab
 endif
 
 # if a dtb section exists we always have to include it
diff --git a/arch/arm/cpu/armv7/Makefile b/arch/arm/cpu/armv7/Makefile
index b14ee54519..48cbfbf8c0 100644
--- a/arch/arm/cpu/armv7/Makefile
+++ b/arch/arm/cpu/armv7/Makefile
@@ -20,6 +20,10 @@ obj-$(CONFIG_ARM_SMCCC)		+= smccc-call.o
 obj-$(CONFIG_ARMV7_NONSEC)	+= nonsec_virt.o virt-v7.o virt-dt.o
 obj-$(CONFIG_ARMV7_PSCI)	+= psci.o psci-common.o
 
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
+obj-$(CONFIG_ARM_CPU_SUSPEND)	+= suspend.o sleep.o
+endif
+
 obj-$(CONFIG_IPROC) += iproc-common/
 obj-$(CONFIG_KONA) += kona-common/
 obj-$(CONFIG_SYS_ARCH_TIMER) += arch_timer.o
diff --git a/arch/arm/cpu/armv7/arch_timer.c b/arch/arm/cpu/armv7/arch_timer.c
index 30915d28aa..545c518506 100644
--- a/arch/arm/cpu/armv7/arch_timer.c
+++ b/arch/arm/cpu/armv7/arch_timer.c
@@ -17,7 +17,7 @@ int timer_init(void)
 	gd->arch.tbl = 0;
 	gd->arch.tbu = 0;
 
-	gd->arch.timer_rate_hz = CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ;
+	gd->arch.timer_rate_hz = CONFIG_SYS_HZ_CLOCK;
 	return 0;
 }
 
@@ -34,27 +34,9 @@ unsigned long long get_ticks(void)
 }
 
 
-ulong get_timer(ulong base)
-{
-	return lldiv(get_ticks(), gd->arch.timer_rate_hz) - base;
-}
-
 ulong timer_get_boot_us(void)
 {
-	return lldiv(get_ticks(), CONFIG_SYS_HZ_CLOCK / (CONFIG_SYS_HZ * 1000));
-}
-
-void __udelay(unsigned long usec)
-{
-	unsigned long long endtime;
-
-	endtime = lldiv((unsigned long long)usec * gd->arch.timer_rate_hz,
-			1000UL);
-
-	endtime += get_ticks();
-
-	while (get_ticks() < endtime)
-		;
+	return lldiv(get_ticks(), CONFIG_SYS_HZ_CLOCK / 1000000);
 }
 
 ulong get_tbclk(void)
diff --git a/arch/arm/cpu/armv7/cache_v7.c b/arch/arm/cpu/armv7/cache_v7.c
index c4bbcc3cc3..e1c783e80b 100644
--- a/arch/arm/cpu/armv7/cache_v7.c
+++ b/arch/arm/cpu/armv7/cache_v7.c
@@ -44,8 +44,22 @@ static void v7_dcache_inval_range(u32 start, u32 stop, u32 line_len)
 {
 	u32 mva;
 
-	if (!check_cache_range(start, stop))
-		return;
+#ifdef DEBUG
+	check_cache_range(start, stop);
+#endif
+	/* aligned ? backward and flush a line_len */
+	if (start & (line_len - 1)) {
+		mva = start & ~(line_len - 1);
+		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
+		start = mva + line_len;
+	}
+
+	/* aligned ? forward and flush a line_len */
+	if (stop & (line_len - 1)) {
+		mva = stop & ~(line_len - 1);
+		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
+		stop = mva;
+	}
 
 	for (mva = start; mva < stop; mva = mva + line_len) {
 		/* DCIMVAC - Invalidate data cache by MVA to PoC */
@@ -117,8 +131,9 @@ void flush_dcache_all(void)
  */
 void invalidate_dcache_range(unsigned long start, unsigned long stop)
 {
+#ifdef DEBUG
 	check_cache_range(start, stop);
-
+#endif
 	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
 
 	v7_outer_cache_inval_range(start, stop);
@@ -131,8 +146,9 @@ void invalidate_dcache_range(unsigned long start, unsigned long stop)
  */
 void flush_dcache_range(unsigned long start, unsigned long stop)
 {
+#ifdef DEBUG
 	check_cache_range(start, stop);
-
+#endif
 	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
 
 	v7_outer_cache_flush_range(start, stop);
diff --git a/arch/arm/cpu/armv7/config.mk b/arch/arm/cpu/armv7/config.mk
index 63591d4a29..63ae71cd4c 100644
--- a/arch/arm/cpu/armv7/config.mk
+++ b/arch/arm/cpu/armv7/config.mk
@@ -11,3 +11,7 @@
 # of our decision.
 PF_NO_UNALIGNED := $(call cc-option, -mno-unaligned-access,)
 PLATFORM_CPPFLAGS += $(PF_NO_UNALIGNED)
+
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
+PLATFORM_CPPFLAGS += -mabi=aapcs-linux -funwind-tables
+endif
diff --git a/arch/arm/cpu/armv7/cpu.c b/arch/arm/cpu/armv7/cpu.c
index 6eac5ef3fe..0cd75c6846 100644
--- a/arch/arm/cpu/armv7/cpu.c
+++ b/arch/arm/cpu/armv7/cpu.c
@@ -35,6 +35,7 @@ int cleanup_before_linux_select(int flags)
 #ifndef CONFIG_SPL_BUILD
 	disable_interrupts();
 #endif
+	disable_async_abort();
 
 	if (flags & CBL_DISABLE_CACHES) {
 		/*
diff --git a/arch/arm/cpu/armv7/start.S b/arch/arm/cpu/armv7/start.S
index 7b84a7a0f1..ed631e961b 100644
--- a/arch/arm/cpu/armv7/start.S
+++ b/arch/arm/cpu/armv7/start.S
@@ -31,10 +31,13 @@
 
 	.globl	reset
 	.globl	save_boot_params_ret
+	.type   save_boot_params_ret,%function
 #ifdef CONFIG_ARMV7_LPAE
 	.global	switch_to_hypervisor_ret
 #endif
 
+#if !CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+
 reset:
 	/* Allow the board to save important registers */
 	b	save_boot_params
@@ -61,6 +64,11 @@ switch_to_hypervisor_ret:
 	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
 	msr	cpsr,r0
 
+	/* Enable ACTLR.SMP bit */
+	mrc	p15, 0, r0, c1, c0, 1
+	orr	r0, r0, #(1 << 6)	@ Enable ACTLR.SMP bit
+	mcr	p15, 0, r0, c1, c0, 1
+
 /*
  * Setup vector:
  * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
@@ -77,6 +85,11 @@ switch_to_hypervisor_ret:
 	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
 #endif
 
+	/* Enable Asynchronous external abort after vectors setup */
+	mrs	r0, cpsr
+	bic	r0, r0, #0x100		@ CPSR.A bit
+	msr	cpsr_x,r0
+
 	/* the mask ROM code should have PLL and others stable */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 	bl	cpu_init_cp15
@@ -103,6 +116,8 @@ ENTRY(c_runtime_cpu_setup)
 
 ENDPROC(c_runtime_cpu_setup)
 
+#endif/* !CONFIG_IS_ENABLED(TINY_FRAMEWORK) */
+
 /*************************************************************************
  *
  * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
@@ -301,6 +316,37 @@ skip_errata_725233:
 	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
 #endif
 
+#if defined(CONFIG_ARM_ZERO_CNTVOFF) && defined(CONFIG_SPL_BUILD)
+	/*
+	 * CNTVOFF usage constraints:
+	 * Only accessible from Hyp mode, or from Monitor mode when SCR.NS is
+	 * set to 1.
+	 */
+	/* switch to MON */
+	cps #22
+	isb
+
+	/* Update SCR.NS to non Secure mode */
+	mrc	p15, 0, r0, c1, c1, 0
+	orr r0, r0, #(1 << 0)
+	mcr	p15, 0, r0, c1, c1, 0
+	isb
+
+	/* set vtimer virtual offset 0 */
+	mov	r0, #0
+	mcrr	p15, 4, r0, r0, c14	@ CNTVOFF
+
+	/* Update SCR.NS to Secure mode */
+	mrc	p15, 0, r0, c1, c1, 0
+	bic r0, r0, #(1 << 0)
+	mcr	p15, 0, r0, c1, c1, 0
+	isb
+
+	/* switch back to SVC */
+	cps #19
+	isb
+#endif
+
 	mov	pc, r5			@ back to my caller
 ENDPROC(cpu_init_cp15)
 
diff --git a/arch/arm/cpu/armv7/virt-dt.c b/arch/arm/cpu/armv7/virt-dt.c
index 707dad4829..204187c1b4 100644
--- a/arch/arm/cpu/armv7/virt-dt.c
+++ b/arch/arm/cpu/armv7/virt-dt.c
@@ -21,7 +21,7 @@
 #include <linux/ctype.h>
 #include <linux/types.h>
 #include <asm/global_data.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #include <asm/armv7.h>
 #include <asm/psci.h>
diff --git a/arch/arm/cpu/armv8/Makefile b/arch/arm/cpu/armv8/Makefile
index 1249547436..c200dc28b8 100644
--- a/arch/arm/cpu/armv8/Makefile
+++ b/arch/arm/cpu/armv8/Makefile
@@ -18,8 +18,13 @@ obj-y	+= tlb.o
 obj-y	+= transition.o
 obj-y	+= fwcall.o
 obj-y	+= cpu-dt.o
+
 obj-$(CONFIG_ARM_SMCCC)		+= smccc-call.o
 
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
+obj-$(CONFIG_ARM_CPU_SUSPEND)	+= ../armv7/suspend.o sleep.o
+endif
+
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_ARMV8_SPIN_TABLE) += spin_table.o spin_table_v8.o
 endif
diff --git a/arch/arm/cpu/armv8/cache.S b/arch/arm/cpu/armv8/cache.S
index ea845d1809..b3ffa49e42 100644
--- a/arch/arm/cpu/armv8/cache.S
+++ b/arch/arm/cpu/armv8/cache.S
@@ -131,6 +131,7 @@ ENDPROC(__asm_invalidate_dcache_all)
  */
 .pushsection .text.__asm_flush_dcache_range, "ax"
 ENTRY(__asm_flush_dcache_range)
+	isb
 	mrs	x3, ctr_el0
 	lsr	x3, x3, #16
 	and	x3, x3, #0xf
@@ -171,6 +172,7 @@ ENTRY(__asm_invalidate_dcache_range)
 	cmp	x0, x1
 	b.lo	1b
 	dsb	sy
+	isb
 	ret
 ENDPROC(__asm_invalidate_dcache_range)
 .popsection
diff --git a/arch/arm/cpu/armv8/cache_v8.c b/arch/arm/cpu/armv8/cache_v8.c
index adc7e1746f..e9f5244216 100644
--- a/arch/arm/cpu/armv8/cache_v8.c
+++ b/arch/arm/cpu/armv8/cache_v8.c
@@ -109,7 +109,7 @@ static u64 *find_pte(u64 addr, int level)
 	u64 va_bits;
 	int i;
 
-	debug("addr=%llx level=%d\n", addr, level);
+	pr_debug("addr=%llx level=%d\n", addr, level);
 
 	get_tcr(0, NULL, &va_bits);
 	if (va_bits < 39)
@@ -123,7 +123,7 @@ static u64 *find_pte(u64 addr, int level)
 	for (i = start_level; i < 4; i++) {
 		idx = (addr >> level2shift(i)) & 0x1FF;
 		pte += idx;
-		debug("idx=%llx PTE %p at level %d: %llx\n", idx, pte, i, *pte);
+		pr_debug("idx=%llx PTE %p at level %d: %llx\n", idx, pte, i, *pte);
 
 		/* Found it */
 		if (i == level)
@@ -163,7 +163,7 @@ static u64 *create_table(void)
 static void set_pte_table(u64 *pte, u64 *table)
 {
 	/* Point *pte to the new table */
-	debug("Setting %p to addr=%p\n", pte, table);
+	pr_debug("Setting %p to addr=%p\n", pte, table);
 	*pte = PTE_TYPE_TABLE | (ulong)table;
 }
 
@@ -182,7 +182,7 @@ static void split_block(u64 *pte, int level)
 		      "mem_map.", pte, old_pte);
 
 	new_table = create_table();
-	debug("Splitting pte %p (%llx) into %p\n", pte, old_pte, new_table);
+	pr_debug("Splitting pte %p (%llx) into %p\n", pte, old_pte, new_table);
 
 	for (i = 0; i < MAX_PTE_ENTRIES; i++) {
 		new_table[i] = old_pte | (i << levelshift);
@@ -191,7 +191,7 @@ static void split_block(u64 *pte, int level)
 		if ((level + 1) == 3)
 			new_table[i] |= PTE_TYPE_TABLE;
 
-		debug("Setting new_table[%lld] = %llx\n", i, new_table[i]);
+		pr_debug("Setting new_table[%lld] = %llx\n", i, new_table[i]);
 	}
 
 	/* Set the new table into effect */
@@ -213,7 +213,7 @@ static void add_map(struct mm_region *map)
 	while (size) {
 		pte = find_pte(virt, 0);
 		if (pte && (pte_type(pte) == PTE_TYPE_FAULT)) {
-			debug("Creating table for virt 0x%llx\n", virt);
+			pr_debug("Creating table for virt 0x%llx\n", virt);
 			new_table = create_table();
 			set_pte_table(pte, new_table);
 		}
@@ -224,25 +224,28 @@ static void add_map(struct mm_region *map)
 				panic("pte not found\n");
 
 			blocksize = 1ULL << level2shift(level);
-			debug("Checking if pte fits for virt=%llx size=%llx blocksize=%llx\n",
+			pr_debug("Checking if pte fits for virt=%llx size=%llx blocksize=%llx\n",
 			      virt, size, blocksize);
 			if (size >= blocksize && !(virt & (blocksize - 1))) {
 				/* Page fits, create block PTE */
-				debug("Setting PTE %p to block virt=%llx\n",
+				pr_debug("Setting PTE %p to block virt=%llx\n",
 				      pte, virt);
-				*pte = phys | attrs;
+				if (level == 3)
+					*pte = phys | attrs | PTE_TYPE_PAGE;
+				else
+					*pte = phys | attrs;
 				virt += blocksize;
 				phys += blocksize;
 				size -= blocksize;
 				break;
 			} else if (pte_type(pte) == PTE_TYPE_FAULT) {
 				/* Page doesn't fit, create subpages */
-				debug("Creating subtable for virt 0x%llx blksize=%llx\n",
+				pr_debug("Creating subtable for virt 0x%llx blksize=%llx\n",
 				      virt, blocksize);
 				new_table = create_table();
 				set_pte_table(pte, new_table);
 			} else if (pte_type(pte) == PTE_TYPE_BLOCK) {
-				debug("Split block into subtable for virt 0x%llx blksize=0x%llx\n",
+				pr_debug("Split block into subtable for virt 0x%llx blksize=0x%llx\n",
 				      virt, blocksize);
 				split_block(pte, level);
 			}
@@ -436,9 +439,9 @@ inline void flush_dcache_all(void)
 	__asm_flush_dcache_all();
 	ret = __asm_flush_l3_dcache();
 	if (ret)
-		debug("flushing dcache returns 0x%x\n", ret);
+		pr_debug("flushing dcache returns 0x%x\n", ret);
 	else
-		debug("flushing dcache successfully.\n");
+		pr_debug("flushing dcache successfully.\n");
 }
 
 /*
@@ -517,13 +520,13 @@ static u64 set_one_region(u64 start, u64 size, u64 attrs, bool flag, int level)
 			*pte &= ~PMD_ATTRINDX_MASK;
 			*pte |= attrs & PMD_ATTRINDX_MASK;
 		}
-		debug("Set attrs=%llx pte=%p level=%d\n", attrs, pte, level);
+		pr_debug("Set attrs=%llx pte=%p level=%d\n", attrs, pte, level);
 
 		return levelsize;
 	}
 
 	/* Unaligned or doesn't fit, maybe split block into table */
-	debug("addr=%llx level=%d pte=%p (%llx)\n", start, level, pte, *pte);
+	pr_debug("addr=%llx level=%d pte=%p (%llx)\n", start, level, pte, *pte);
 
 	/* Maybe we need to split the block into a table */
 	if (pte_type(pte) == PTE_TYPE_BLOCK)
@@ -545,7 +548,7 @@ void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
 	u64 real_start = start;
 	u64 real_size = size;
 
-	debug("start=%lx size=%lx\n", (ulong)start, (ulong)size);
+	pr_debug("start=%lx size=%lx\n", (ulong)start, (ulong)size);
 
 	if (!gd->arch.tlb_emerg)
 		panic("Emergency page table not setup.");
@@ -646,16 +649,15 @@ void mmu_change_region_attr(phys_addr_t addr, size_t siz, u64 attrs)
 }
 
 #else	/* CONFIG_SYS_DCACHE_OFF */
-
+u64 get_page_table_size(void)
+{
+	return SZ_64K;
+}
 /*
  * For SPL builds, we may want to not have dcache enabled. Any real U-Boot
  * running however really wants to have dcache and the MMU active. Check that
  * everything is sane and give the developer a hint if it isn't.
  */
-#ifndef CONFIG_SPL_BUILD
-#error Please describe your MMU layout in CONFIG_SYS_MEM_MAP and enable dcache.
-#endif
-
 void invalidate_dcache_all(void)
 {
 }
diff --git a/arch/arm/cpu/armv8/cpu.c b/arch/arm/cpu/armv8/cpu.c
index 28a27f724e..20979e8de5 100644
--- a/arch/arm/cpu/armv8/cpu.c
+++ b/arch/arm/cpu/armv8/cpu.c
@@ -41,6 +41,8 @@ int cleanup_before_linux(void)
 	 */
 	disable_interrupts();
 
+	disable_serror();
+
 	/*
 	 * Turn off I-cache and invalidate it
 	 */
diff --git a/arch/arm/cpu/armv8/exceptions.S b/arch/arm/cpu/armv8/exceptions.S
index 4f4f526f93..cf3997793d 100644
--- a/arch/arm/cpu/armv8/exceptions.S
+++ b/arch/arm/cpu/armv8/exceptions.S
@@ -11,13 +11,66 @@
 #include <asm/macro.h>
 #include <linux/linkage.h>
 
+/*
+ * Exception vectors.
+ */
+	.align	11
+	.globl	vectors
+vectors:
+	.align	7		/* Current EL Synchronous Thread */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_bad_sync
+	b	exception_exit
+
+	.align	7		/* Current EL IRQ Thread */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_bad_irq
+	b	exception_exit
+
+	.align	7		/* Current EL FIQ Thread */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_bad_fiq
+	b	exception_exit
+
+	.align	7		/* Current EL Error Thread */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_bad_error
+	b	exception_exit
+
+	.align	7		 /* Current EL Synchronous Handler */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_sync
+	b	exception_exit
+
+	.align	7		 /* Current EL IRQ Handler */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_irq
+	b	exception_exit
+
+	.align	7		 /* Current EL FIQ Handler */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_fiq
+	b	exception_exit
+
+	.align	7		 /* Current EL Error Handler */
+	stp	x29, x30, [sp, #-16]!
+	bl	_exception_entry
+	bl	do_error
+	b	exception_exit
+
 /*
  * Enter Exception.
  * This will save the processor state that is ELR/X0~X30
  * to the stack frame.
  */
-.macro	exception_entry
-	stp	x29, x30, [sp, #-16]!
+_exception_entry:
 	stp	x27, x28, [sp, #-16]!
 	stp	x25, x26, [sp, #-16]!
 	stp	x23, x24, [sp, #-16]!
@@ -37,89 +90,46 @@
 	switch_el x11, 3f, 2f, 1f
 3:	mrs	x1, esr_el3
 	mrs	x2, elr_el3
+	mrs	x3, daif
+	mrs	x4, vbar_el3
+	mrs	x5, spsr_el3
+	sub	x6, sp, #(8*30)
+	mrs	x7, sctlr_el3
+	mrs	x8, scr_el3
+	mrs	x9, ttbr0_el3
 	b	0f
 2:	mrs	x1, esr_el2
 	mrs	x2, elr_el2
+	mrs	x3, daif
+	mrs	x4, vbar_el2
+	mrs	x5, spsr_el2
+	sub	x6, sp, #(8*30)
+	mrs	x7, sctlr_el2
+	mrs	x8, hcr_el2
+	mrs	x9, ttbr0_el2
 	b	0f
+
 1:	mrs	x1, esr_el1
 	mrs	x2, elr_el1
+	mrs	x3, daif
+	mrs	x4, vbar_el1
+	mrs	x5, spsr_el1
+	sub	x6, sp, #(8*30)
+	mrs	x7, sctlr_el1
+	mov	x8, #0	/* Not used, EL1 don't have register, like 'scr_el1' */
+	mrs	x9, ttbr0_el1
 0:
-	stp	x2, x0, [sp, #-16]!
+	stp     x2, x0, [sp, #-16]!
+	stp	x3, x1, [sp, #-16]!
+	stp	x5, x4, [sp, #-16]!
+	stp	x7, x6, [sp, #-16]!
+	stp	x9, x8, [sp, #-16]!
 	mov	x0, sp
-.endm
-
-/*
- * Exception vectors.
- */
-	.align	11
-	.globl	vectors
-vectors:
-	.align	7
-	b	_do_bad_sync	/* Current EL Synchronous Thread */
-
-	.align	7
-	b	_do_bad_irq	/* Current EL IRQ Thread */
-
-	.align	7
-	b	_do_bad_fiq	/* Current EL FIQ Thread */
+	ret
 
-	.align	7
-	b	_do_bad_error	/* Current EL Error Thread */
-
-	.align	7
-	b	_do_sync	/* Current EL Synchronous Handler */
-
-	.align	7
-	b	_do_irq		/* Current EL IRQ Handler */
-
-	.align	7
-	b	_do_fiq		/* Current EL FIQ Handler */
-
-	.align	7
-	b	_do_error	/* Current EL Error Handler */
-
-
-_do_bad_sync:
-	exception_entry
-	bl	do_bad_sync
-	b	exception_exit
-
-_do_bad_irq:
-	exception_entry
-	bl	do_bad_irq
-	b	exception_exit
-
-_do_bad_fiq:
-	exception_entry
-	bl	do_bad_fiq
-	b	exception_exit
-
-_do_bad_error:
-	exception_entry
-	bl	do_bad_error
-	b	exception_exit
-
-_do_sync:
-	exception_entry
-	bl	do_sync
-	b	exception_exit
-
-_do_irq:
-	exception_entry
-	bl	do_irq
-	b	exception_exit
-
-_do_fiq:
-	exception_entry
-	bl	do_fiq
-	b	exception_exit
-
-_do_error:
-	exception_entry
-	bl	do_error
-	b	exception_exit
 
 exception_exit:
+	add	sp, sp, #(8*8)/* see: sys registers size of struct pt_regs */
 	ldp	x2, x0, [sp],#16
 	switch_el x11, 3f, 2f, 1f
 3:	msr	elr_el3, x2
diff --git a/arch/arm/cpu/armv8/generic_timer.c b/arch/arm/cpu/armv8/generic_timer.c
index a2dda333fe..8b13dd95ca 100644
--- a/arch/arm/cpu/armv8/generic_timer.c
+++ b/arch/arm/cpu/armv8/generic_timer.c
@@ -62,3 +62,10 @@ unsigned long usec2ticks(unsigned long usec)
 
 	return ticks;
 }
+
+ulong timer_get_boot_us(void)
+{
+	ulong count = timer_read_counter();
+
+	return count/24;
+}
diff --git a/arch/arm/cpu/armv8/spin_table.c b/arch/arm/cpu/armv8/spin_table.c
index ec1c9b8ddb..195901a7a7 100644
--- a/arch/arm/cpu/armv8/spin_table.c
+++ b/arch/arm/cpu/armv8/spin_table.c
@@ -6,7 +6,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <asm/spin_table.h>
 
 int spin_table_update_dt(void *fdt)
diff --git a/arch/arm/cpu/armv8/start.S b/arch/arm/cpu/armv8/start.S
index 5c500be51d..8447fc69d1 100644
--- a/arch/arm/cpu/armv8/start.S
+++ b/arch/arm/cpu/armv8/start.S
@@ -30,11 +30,16 @@ _start:
 	b	reset
 #endif
 
+#if !CONFIG_IS_ENABLED(TINY_FRAMEWORK)
 	.align 3
 
 .globl	_TEXT_BASE
 _TEXT_BASE:
+#if defined(CONFIG_SPL_BUILD)
+	.quad   CONFIG_SPL_TEXT_BASE
+#else
 	.quad	CONFIG_SYS_TEXT_BASE
+#endif
 
 /*
  * These are defined in the linker script.
@@ -57,6 +62,32 @@ reset:
 .globl	save_boot_params_ret
 save_boot_params_ret:
 
+#if CONFIG_POSITION_INDEPENDENT
+	/*
+	 * Fix .rela.dyn relocations. This allows U-Boot to be loaded to and
+	 * executed at a different address than it was linked at.
+	 */
+pie_fixup:
+	adr	x0, _start		/* x0 <- Runtime value of _start */
+	ldr	x1, _TEXT_BASE		/* x1 <- Linked value of _start */
+	sub	x9, x0, x1		/* x9 <- Run-vs-link offset */
+	adr	x2, __rel_dyn_start	/* x2 <- Runtime &__rel_dyn_start */
+	adr	x3, __rel_dyn_end	/* x3 <- Runtime &__rel_dyn_end */
+pie_fix_loop:
+	ldp	x0, x1, [x2], #16	/* (x0, x1) <- (Link location, fixup) */
+	ldr	x4, [x2], #8		/* x4 <- addend */
+	cmp	w1, #1027		/* relative fixup? */
+	bne	pie_skip_reloc
+	/* relative fix: store addend plus offset at dest location */
+	add	x0, x0, x9
+	add	x4, x4, x9
+	str	x4, [x0]
+pie_skip_reloc:
+	cmp	x2, x3
+	b.lo	pie_fix_loop
+pie_fixup_done:
+#endif
+
 #ifdef CONFIG_SYS_RESET_SCTRL
 	bl reset_sctrl
 #endif
@@ -231,7 +262,7 @@ ENDPROC(apply_core_errata)
 WEAK(lowlevel_init)
 	mov	x29, lr			/* Save LR */
 
-#if defined(CONFIG_GICV2) || defined(CONFIG_GICV3)
+#if CONFIG_IS_ENABLED(IRQ)
 	branch_if_slave x0, 1f
 	ldr	x0, =GICD_BASE
 	bl	gic_init_secure
@@ -312,3 +343,4 @@ ENDPROC(c_runtime_cpu_setup)
 WEAK(save_boot_params)
 	b	save_boot_params_ret	/* back to my caller */
 ENDPROC(save_boot_params)
+#endif
diff --git a/arch/arm/cpu/armv8/u-boot-spl.lds b/arch/arm/cpu/armv8/u-boot-spl.lds
index 0d1b0c4993..c6579b50be 100644
--- a/arch/arm/cpu/armv8/u-boot-spl.lds
+++ b/arch/arm/cpu/armv8/u-boot-spl.lds
@@ -54,6 +54,23 @@ SECTIONS
 		*(.__end)
 	} >.sram
 
+#ifndef CONFIG_SPL_SKIP_RELOCATE
+	. = ALIGN(8);
+
+	.rel_dyn_start :
+	{
+		*(.__rel_dyn_start)
+	} >.sram
+
+	.rela.dyn : {
+		*(.rela*)
+	} >.sram
+
+	.rel_dyn_end :
+	{
+		*(.__rel_dyn_end)
+	} >.sram
+#endif
 	_image_binary_end = .;
 
 	.bss_start (NOLOAD) : {
diff --git a/arch/arm/cpu/u-boot.lds b/arch/arm/cpu/u-boot.lds
index 37d4c605ac..87b57bc18d 100644
--- a/arch/arm/cpu/u-boot.lds
+++ b/arch/arm/cpu/u-boot.lds
@@ -15,7 +15,7 @@ OUTPUT_ARCH(arm)
 ENTRY(_start)
 SECTIONS
 {
-#ifndef CONFIG_CMDLINE
+#if !defined(CONFIG_CMDLINE) && !defined(CONFIG_U_BOOT_CMD_ALWAYS)
 	/DISCARD/ : { *(.u_boot_list_2_cmd_*) }
 #endif
 #if defined(CONFIG_ARMV7_SECURE_BASE) && defined(CONFIG_ARMV7_NONSEC)
@@ -135,6 +135,23 @@ SECTIONS
 		KEEP(*(SORT(.u_boot_list*)));
 	}
 
+	/*
+	 * Stack unwinding tables
+	 */
+	. = ALIGN(8);
+	/* .ARM.exidx is sorted, so has to go in its own output section. */
+	.ARM.exidx : {
+		__exidx_start = .;
+		*(.ARM.exidx*)
+		__exidx_end = .;
+	}
+
+	.ARM.extab : {
+		__extab_start = .;
+		*(.ARM.extab*)
+		__extab_end = .;
+	}
+
 	. = ALIGN(4);
 
 	.__efi_runtime_start : {
@@ -165,7 +182,7 @@ SECTIONS
 		*(.__efi_runtime_rel_stop)
 	}
 
-	. = ALIGN(4);
+	. = ALIGN(8);
 
 	.image_copy_end :
 	{
@@ -188,6 +205,7 @@ SECTIONS
 
 	.end :
 	{
+		. = ALIGN(8);
 		*(.__end)
 	}
 
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 762429c463..79739bf581 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -27,31 +27,10 @@ dtb-$(CONFIG_EXYNOS5) += exynos5250-arndale.dtb \
 	exynos5800-peach-pi.dtb \
 	exynos5422-odroidxu3.dtb
 dtb-$(CONFIG_EXYNOS7420) += exynos7420-espresso7420.dtb
-dtb-$(CONFIG_ARCH_ROCKCHIP) += \
-	rk3036-sdk.dtb \
-	rk3188-radxarock.dtb \
-	rk3288-evb.dtb \
-	rk3288-fennec.dtb \
-	rk3288-firefly.dtb \
-	rk3288-miqi.dtb \
-	rk3288-phycore-rdk.dtb \
-	rk3288-popmetal.dtb \
-	rk3288-rock2-square.dtb \
-	rk3288-tinker.dtb \
-	rk3288-veyron-jerry.dtb \
-	rk3288-veyron-mickey.dtb \
-	rk3288-veyron-minnie.dtb \
-	rk3328-evb.dtb \
-	rk3368-lion.dtb \
-	rk3368-sheep.dtb \
-	rk3368-geekbox.dtb \
-	rk3368-px5-evb.dtb \
-	rk3399-evb.dtb \
-	rk3399-firefly.dtb \
-	rk3399-puma-ddr1333.dtb \
-	rk3399-puma-ddr1600.dtb \
-	rk3399-puma-ddr1866.dtb \
-	rv1108-evb.dtb
+dtb-$(CONFIG_ROCKCHIP_RK3568) += \
+	rk3568-easepi.dtb \
+	rk3568-firefly.dtb \
+	rk3568-evb.dtb
 dtb-$(CONFIG_ARCH_MESON) += \
 	meson-gxbb-odroidc2.dtb
 dtb-$(CONFIG_TEGRA) += tegra20-harmony.dtb \
@@ -447,6 +426,14 @@ dtb-$(CONFIG_ARCH_ASPEED) += ast2500-evb.dtb
 
 dtb-$(CONFIG_ARCH_STI) += stih410-b2260.dtb
 
+# Compile embeded kernel dts to dtb, and put it behind of u-boot.dtb
+EMBED_KERN_DTB_PATH := $(CONFIG_EMBED_KERNEL_DTB_PATH:"%"=%)
+EMBED_KERN_DTS_PATH := $(subst dtb,dts, $(EMBED_KERN_DTB_PATH))
+ifneq ($(wildcard $(EMBED_KERN_DTS_PATH)),)
+EMBED_KERN_DTB=$(shell echo $(EMBED_KERN_DTB_PATH) | awk -F '/' '{ print $$NF }')
+dtb-y += $(EMBED_KERN_DTB)
+endif
+
 targets += $(dtb-y)
 
 # Add any required device tree compiler flags here
diff --git a/arch/arm/include/asm/arch-rockchip/boot0.h b/arch/arm/include/asm/arch-rockchip/boot0.h
index 72d264bcbe..f25c29468f 100644
--- a/arch/arm/include/asm/arch-rockchip/boot0.h
+++ b/arch/arm/include/asm/arch-rockchip/boot0.h
@@ -1,4 +1,3 @@
-
 /*
  * Copyright 2017 Theobroma Systems Design und Consulting GmbH
  *
@@ -7,27 +6,78 @@
 
 /*
  * Execution starts on the instruction following this 4-byte header
- * (containing the magic 'RK33').
+ * (containing the magic 'RK30', 'RK31', 'RK32' or 'RK33').  This
+ * magic constant will be written into the final image by the rkimage
+ * tool, but we need to reserve space for it here.
  *
  * To make life easier for everyone, we build the SPL binary with
  * space for this 4-byte header already included in the binary.
  */
-
 #ifdef CONFIG_SPL_BUILD
 	/*
 	 * We need to add 4 bytes of space for the 'RK33' at the
 	 * beginning of the executable.	 However, as we want to keep
 	 * this generic and make it applicable to builds that are like
 	 * the RK3368 (TPL needs this, SPL doesn't) or the RK3399 (no
-	 * TPL, but extra space needed in the SPL), we simply repeat
-	 * the 'b reset' with the expectation that the first one will
-	 * be overwritten, if this is the first stage contained in the
-	 * final image created with mkimage)...
+	 * TPL, but extra space needed in the SPL), we simply insert
+	 * a branch-to-next-instruction-word with the expectation that
+	 * the first one may be overwritten, if this is the first stage
+	 * contained in the final image created with mkimage)...
+	 */
+	b 1f	 /* if overwritten, entry-address is at the next word */
+1:
+#endif
+#if CONFIG_IS_ENABLED(ROCKCHIP_EARLYRETURN_TO_BROM)
+	adr     r3, entry_counter
+	ldr	r0, [r3]
+	cmp	r0, #1           /* check if entry_counter == 1 */
+	beq	reset            /* regular bootup */
+	add     r0, #1
+	str	r0, [r3]         /* increment the entry_counter in memory */
+	mov     r0, #0           /* return 0 to the BROM to signal 'OK' */
+	bx	lr               /* return control to the BROM */
+entry_counter:
+	.word   0
+#endif
+
+#if (defined(CONFIG_SPL_BUILD) || defined(CONFIG_ARM64))
+	/* U-Boot proper of armv7 do not need this */
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+#if !defined(CONFIG_ARM64)
+	/*
+	 * For armv7, the addr '_start' will check by u-boot-tpl.lds file.
 	 */
-	b reset	 /* may be overwritten --- should be 'nop' or a 'b reset' */
+_start:
+#endif
+	/* Allow the board to save important registers */
+	b save_boot_params
+
+.type   save_boot_params_ret, % function
+.globl	save_boot_params_ret
+save_boot_params_ret:
+	/* Init gd as null */
+#ifdef CONFIG_ARM64
+	mov	x18, #0
+#else
+	mov	r9, #0
 #endif
+	b board_init_f
+#else
 	b reset
+#endif
+
+#endif
+
+#if !defined(CONFIG_ARM64) && !CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+	/*
+	 * For armv7, the addr '_start' will used as vector start address
+	 * and write to VBAR register, which needs to aligned to 0x20.
+	 */
+	.align(5), 0x0
+_start:
+	ARM_VECTORS
+#endif
 
-#if defined(CONFIG_ROCKCHIP_RK3399) && defined(CONFIG_SPL_BUILD)
+#if !defined(CONFIG_TPL_BUILD) && defined(CONFIG_SPL_BUILD) && (CONFIG_ROCKCHIP_SPL_RESERVE_IRAM > 0)
 	.space CONFIG_ROCKCHIP_SPL_RESERVE_IRAM	/* space for the ATF data */
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/boot_mode.h b/arch/arm/include/asm/arch-rockchip/boot_mode.h
index bd65f60bf2..bc1395ee2c 100644
--- a/arch/arm/include/asm/arch-rockchip/boot_mode.h
+++ b/arch/arm/include/asm/arch-rockchip/boot_mode.h
@@ -3,17 +3,37 @@
 
 /* high 24 bits is tag, low 8 bits is type */
 #define REBOOT_FLAG		0x5242C300
+/* cold boot */
+#define BOOT_COLD		0
 /* normal boot */
 #define BOOT_NORMAL		(REBOOT_FLAG + 0)
 /* enter loader rockusb mode */
 #define BOOT_LOADER		(REBOOT_FLAG + 1)
 /* enter recovery */
 #define BOOT_RECOVERY		(REBOOT_FLAG + 3)
+/* reboot by panic */
+#define BOOT_PANIC		(REBOOT_FLAG + 7)
+/* reboot by watchdog */
+#define BOOT_WATCHDOG		(REBOOT_FLAG + 8)
 /* enter fastboot mode */
 #define BOOT_FASTBOOT		(REBOOT_FLAG + 9)
 /* enter charging mode */
 #define BOOT_CHARGING		(REBOOT_FLAG + 11)
 /* enter usb mass storage mode */
 #define BOOT_UMS		(REBOOT_FLAG + 12)
+/* enter dfu download mode */
+#define BOOT_DFU                (REBOOT_FLAG + 13)
+/* enter bootrom download mode */
+#define BOOT_BROM_DOWNLOAD	0xEF08A53C
+
+#ifndef __ASSEMBLY__
+int setup_boot_mode(void);
+#endif
+
+enum {
+	BCB_MSG_RECOVERY_NONE,
+	BCB_MSG_RECOVERY_RK_FWUPDATE,
+	BCB_MSG_RECOVERY_PCBA,
+};
 
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/bootrom.h b/arch/arm/include/asm/arch-rockchip/bootrom.h
index 92eb8783a3..0aa58493d0 100644
--- a/arch/arm/include/asm/arch-rockchip/bootrom.h
+++ b/arch/arm/include/asm/arch-rockchip/bootrom.h
@@ -1,5 +1,6 @@
 /*
  * (C) Copyright 2017 Heiko Stuebner <heiko@sntech.de>
+ * (C) Copyright 2017 Theobroma Systems Design und Consulting GmbH
  *
  * SPDX-License-Identifier:	GPL-2.0
  */
@@ -14,14 +15,53 @@
 extern u32 SAVE_SP_ADDR;
 
 /**
- * Hand control back to the bootrom to load another
- * boot stage.
+ * back_to_bootrom() - return to bootrom (for TPL/SPL), passing a
+ *                     result code
+ *
+ * Transfer control back to the Rockchip BROM, restoring necessary
+ * register context and passing a command/result code to the BROM
+ * to instruct its next actions (e.g. continue boot sequence, enter
+ * download mode, ...).
+ *
+ * This function does not return.
+ *
+ * @brom_cmd: indicates how the bootrom should continue the boot
+ *            sequence (e.g. load the next stage)
+ */
+enum rockchip_bootrom_cmd {
+	/*
+	* These can not start at 0, as 0 has a special meaning
+	* for setjmp().
+	*/
+
+	BROM_BOOT_NEXTSTAGE = 1,  /* continue boot-sequence */
+	BROM_BOOT_ENTER_DNL,      /* have BROM enter download-mode */
+};
+
+void back_to_bootrom(enum rockchip_bootrom_cmd brom_cmd);
+
+/**
+ * Boot-device identifiers as used by the BROM
  */
-void back_to_bootrom(void);
+enum {
+	BROM_BOOTSOURCE_UNKNOWN = 0,
+	BROM_BOOTSOURCE_NAND = 1,
+	BROM_BOOTSOURCE_EMMC = 2,
+	BROM_BOOTSOURCE_SPINOR = 3,
+	BROM_BOOTSOURCE_SPINAND = 4,
+	BROM_BOOTSOURCE_SD = 5,
+	BROM_BOOTSOURCE_I2C = 8,
+	BROM_BOOTSOURCE_SPI = 9,
+	BROM_BOOTSOURCE_USB = 10,
+	BROM_LAST_BOOTSOURCE = BROM_BOOTSOURCE_USB
+};
+
+extern const char * const boot_devices[BROM_LAST_BOOTSOURCE + 1];
 
 /**
- * Assembler component for the above (do not call this directly)
+ * Locations of the boot-device identifier in SRAM
  */
-void _back_to_bootrom_s(void);
+#define BROM_BOOTSOURCE_ID_ADDR (CONFIG_ROCKCHIP_IRAM_START_ADDR + 0x10)
+
 
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/clock.h b/arch/arm/include/asm/arch-rockchip/clock.h
index 641df58ac2..cabe1d5c0e 100644
--- a/arch/arm/include/asm/arch-rockchip/clock.h
+++ b/arch/arm/include/asm/arch-rockchip/clock.h
@@ -10,6 +10,7 @@
 /* define pll mode */
 #define RKCLK_PLL_MODE_SLOW		0
 #define RKCLK_PLL_MODE_NORMAL		1
+#define RKCLK_PLL_MODE_DEEP		2
 
 enum {
 	ROCKCHIP_SYSCON_NOC,
@@ -20,6 +21,14 @@ enum {
 	ROCKCHIP_SYSCON_PMUSGRF,
 	ROCKCHIP_SYSCON_CIC,
 	ROCKCHIP_SYSCON_MSCH,
+	ROCKCHIP_SYSCON_USBGRF,
+	ROCKCHIP_SYSCON_PCIE30_PHY_GRF,
+	ROCKCHIP_SYSCON_PHP_GRF,
+	ROCKCHIP_SYSCON_PIPE_PHY0_GRF,
+	ROCKCHIP_SYSCON_PIPE_PHY1_GRF,
+	ROCKCHIP_SYSCON_PIPE_PHY2_GRF,
+	ROCKCHIP_SYSCON_VOP_GRF,
+	ROCKCHIP_SYSCON_VO_GRF,
 };
 
 /* Standard Rockchip clock numbers */
@@ -34,11 +43,135 @@ enum rk_clk_id {
 	CLK_COUNT,
 };
 
+#define PLL(_type, _id, _con, _mode, _mshift,			\
+		 _lshift, _pflags, _rtable)			\
+	{							\
+		.id		= _id,				\
+		.type		= _type,			\
+		.con_offset	= _con,				\
+		.mode_offset	= _mode,			\
+		.mode_shift	= _mshift,			\
+		.lock_shift	= _lshift,			\
+		.pll_flags	= _pflags,			\
+		.rate_table	= _rtable,			\
+	}
+
+#define RK3036_PLL_RATE(_rate, _refdiv, _fbdiv, _postdiv1,	\
+			_postdiv2, _dsmpd, _frac)		\
+{								\
+	.rate	= _rate##U,					\
+	.fbdiv = _fbdiv,					\
+	.postdiv1 = _postdiv1,					\
+	.refdiv = _refdiv,					\
+	.postdiv2 = _postdiv2,					\
+	.dsmpd = _dsmpd,					\
+	.frac = _frac,						\
+}
+
+#define RK3588_PLL_RATE(_rate, _p, _m, _s, _k)			\
+{								\
+	.rate	= _rate##U,					\
+	.p = _p,						\
+	.m = _m,						\
+	.s = _s,						\
+	.k = _k,						\
+}
+
+struct rockchip_pll_rate_table {
+	unsigned long rate;
+	unsigned int nr;
+	unsigned int nf;
+	unsigned int no;
+	unsigned int nb;
+	/* for RK3036/RK3399 */
+	unsigned int fbdiv;
+	unsigned int postdiv1;
+	unsigned int refdiv;
+	unsigned int postdiv2;
+	unsigned int dsmpd;
+	unsigned int frac;
+	/* for RK3588 */
+	unsigned int m;
+	unsigned int p;
+	unsigned int s;
+	unsigned int k;
+};
+
+enum rockchip_pll_type {
+	pll_rk3036,
+	pll_rk3066,
+	pll_rk3328,
+	pll_rk3366,
+	pll_rk3399,
+	pll_rk3588,
+};
+
+struct rockchip_pll_clock {
+	unsigned int			id;
+	unsigned int			con_offset;
+	unsigned int			mode_offset;
+	unsigned int			mode_shift;
+	unsigned int			lock_shift;
+	enum rockchip_pll_type		type;
+	unsigned int			pll_flags;
+	struct rockchip_pll_rate_table *rate_table;
+	unsigned int			mode_mask;
+};
+
+struct rockchip_cpu_rate_table {
+	unsigned long rate;
+	unsigned int aclk_div;
+	unsigned int pclk_div;
+};
+
+#ifdef CONFIG_ROCKCHIP_IMAGE_TINY
+static inline ulong rockchip_pll_get_rate(struct rockchip_pll_clock *pll,
+					  void __iomem *base,
+					  ulong pll_id)
+{
+	return 0;
+}
+
+static inline int rockchip_pll_set_rate(struct rockchip_pll_clock *pll,
+					void __iomem *base, ulong pll_id,
+					ulong drate)
+{
+	return 0;
+}
+
+static inline const struct rockchip_cpu_rate_table *
+rockchip_get_cpu_settings(struct rockchip_cpu_rate_table *cpu_table,
+			  ulong rate)
+{
+	return NULL;
+}
+#else
+int rockchip_pll_set_rate(struct rockchip_pll_clock *pll,
+			  void __iomem *base, ulong clk_id,
+			  ulong drate);
+ulong rockchip_pll_get_rate(struct rockchip_pll_clock *pll,
+			    void __iomem *base, ulong clk_id);
+const struct rockchip_cpu_rate_table *
+rockchip_get_cpu_settings(struct rockchip_cpu_rate_table *cpu_table,
+			  ulong rate);
+#endif
+
 static inline int rk_pll_id(enum rk_clk_id clk_id)
 {
 	return clk_id - 1;
 }
 
+struct sysreset_reg {
+	unsigned int glb_srst_fst_value;
+	unsigned int glb_srst_snd_value;
+};
+
+struct softreset_reg {
+	void __iomem *base;
+	unsigned int sf_reset_offset;
+	unsigned int sf_reset_num;
+};
+
 /**
  * clk_get_divisor() - Calculate the required clock divisior
  *
@@ -80,4 +213,6 @@ void rk3288_clk_configure_cpu(struct rk3288_cru *cru, struct rk3288_grf *grf);
 
 int rockchip_get_clk(struct udevice **devp);
 
+int rockchip_get_scmi_clk(struct udevice **devp);
+
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk3036.h b/arch/arm/include/asm/arch-rockchip/cru_rk3036.h
index 22278e11ac..aa1a70a912 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk3036.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3036.h
@@ -28,6 +28,11 @@
 struct rk3036_clk_priv {
 	struct rk3036_cru *cru;
 	ulong rate;
+	ulong armclk_hz;
+	ulong armclk_enter_hz;
+	ulong armclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 struct rk3036_cru {
@@ -66,6 +71,12 @@ struct pll_div {
 	u32 frac;
 };
 
+struct rk3036_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
+};
+
 enum {
 	/* PLLCON0*/
 	PLL_POSTDIV1_SHIFT	= 12,
@@ -75,6 +86,8 @@ enum {
 
 	/* PLLCON1 */
 	PLL_RST_SHIFT		= 14,
+	PLL_PD_SHIFT		= 13,
+	PLL_PD_MASK		= 1 << PLL_PD_SHIFT,
 	PLL_DSMPD_SHIFT		= 12,
 	PLL_DSMPD_MASK		= 1 << PLL_DSMPD_SHIFT,
 	PLL_LOCK_STATUS_SHIFT	= 10,
@@ -165,6 +178,42 @@ enum {
 	EMMC_DIV_SHIFT		= 0,
 	EMMC_DIV_MASK		= 0x7f << EMMC_DIV_SHIFT,
 
+	/* CRU_CLKSEL16_CON */
+	NANDC_DIV_SHIFT		= 10,
+	NANDC_DIV_MASK		= 0x1f << NANDC_DIV_SHIFT,
+	NANDC_PLL_SHIFT		= 8,
+	NANDC_PLL_MASK		= 3 << NANDC_PLL_SHIFT,
+	NANDC_SEL_APLL		= 0,
+	NANDC_SEL_DPLL,
+	NANDC_SEL_GPLL,
+
+	/* CLKSEL_CON25 */
+	SPI_PLL_SEL_SHIFT	= 8,
+	SPI_PLL_SEL_MASK	= 0x3 << SPI_PLL_SEL_SHIFT,
+	SPI_PLL_SEL_APLL	= 0,
+	SPI_PLL_SEL_DPLL,
+	SPI_PLL_SEL_GPLL,
+	SPI_DIV_SHIFT		= 0,
+	SPI_DIV_MASK		= 0x7f << SPI_DIV_SHIFT,
+
+	/* CRU_CLKSEL28_CON */
+	LCDC_DCLK_DIV_SHIFT	= 8,
+	LCDC_DCLK_DIV_MASK	= 0xff << LCDC_DCLK_DIV_SHIFT,
+	LCDC_DCLK_SEL_SHIFT	= 0,
+	LCDC_DCLK_SEL_MASK	= 0x3 << LCDC_DCLK_SEL_SHIFT,
+	LCDC_DCLK_SEL_APLL	= 0,
+	LCDC_DCLK_SEL_DPLL,
+	LCDC_DCLK_SEL_GPLL,
+
+	/* CRU_CLKSEL31_CON */
+	LCDC_ACLK_SEL_SHIFT	= 14,
+	LCDC_ACLK_SEL_MASK	= 0x3 << LCDC_ACLK_SEL_SHIFT,
+	LCDC_ACLK_SEL_APLL	= 0,
+	LCDC_ACLK_SEL_DPLL,
+	LCDC_ACLK_SEL_GPLL,
+	LCDC_ACLK_DIV_SHIFT	= 8,
+	LCDC_ACLK_DIV_MASK	= 0x1f << LCDC_ACLK_DIV_SHIFT,
+
 	/* CRU_SOFTRST5_CON */
 	DDRCTRL_PSRST_SHIFT	= 11,
 	DDRCTRL_SRST_SHIFT	= 10,
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk3188.h b/arch/arm/include/asm/arch-rockchip/cru_rk3188.h
index f5d6420d04..09a650e689 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk3188.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3188.h
@@ -29,6 +29,11 @@ struct rk3188_clk_priv {
 	struct rk3188_cru *cru;
 	ulong rate;
 	bool has_bwadj;
+	ulong armclk_hz;
+	ulong armclk_enter_hz;
+	ulong armclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 struct rk3188_cru {
@@ -52,6 +57,12 @@ struct rk3188_cru {
 };
 check_member(rk3188_cru, cru_glb_cnt_th, 0x0140);
 
+struct rk3188_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
+};
+
 /* CRU_CLKSEL0_CON */
 enum {
 	/* a9_core_div: core = core_src / (a9_core_div + 1) */
@@ -138,6 +149,13 @@ enum {
 	SDIO_DIV_MASK		= 0x3f,
 };
 
+/* CRU_CLKSEL24_CON */
+enum {
+	SARADC_DIV_SHIFT	= 8,
+	SARADC_DIV_MASK		=GENMASK(15, 8),
+	SARADC_DIV_WIDTH	= 8,
+};
+
 /* CRU_CLKSEL25_CON */
 enum {
 	SPI1_DIV_SHIFT		= 8,
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk322x.h b/arch/arm/include/asm/arch-rockchip/cru_rk322x.h
index a7999ca5af..fc07143219 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk322x.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk322x.h
@@ -8,27 +8,24 @@
 
 #include <common.h>
 
-#define MHz		1000000
-#define OSC_HZ		(24 * MHz)
-
-#define APLL_HZ		(600 * MHz)
-#define GPLL_HZ		(594 * MHz)
-
-#define CORE_PERI_HZ	150000000
-#define CORE_ACLK_HZ	300000000
-
-#define BUS_ACLK_HZ	148500000
-#define BUS_HCLK_HZ	148500000
-#define BUS_PCLK_HZ	74250000
-
-#define PERI_ACLK_HZ	148500000
-#define PERI_HCLK_HZ	148500000
-#define PERI_PCLK_HZ	74250000
+#define MHz				1000 * 1000
+#define OSC_HZ				(24 * MHz)
+#define APLL_HZ				(600 * MHz)
+#define GPLL_HZ				(1200 * MHz)
+#define CPLL_HZ				(500 * MHz)
+#define ACLK_BUS_HZ			(150 * MHz)
+#define ACLK_PERI_HZ			(150 * MHz)
 
 /* Private data for the clock driver - used by rockchip_get_cru() */
 struct rk322x_clk_priv {
 	struct rk322x_cru *cru;
-	ulong rate;
+	ulong gpll_hz;
+	ulong cpll_hz;
+	ulong armclk_hz;
+	ulong armclk_enter_hz;
+	ulong armclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 struct rk322x_cru {
@@ -59,57 +56,29 @@ struct rk322x_cru {
 };
 check_member(rk322x_cru, cru_pll_mask_con, 0x01f8);
 
-struct pll_div {
-	u32 refdiv;
-	u32 fbdiv;
-	u32 postdiv1;
-	u32 postdiv2;
-	u32 frac;
+enum rk322x_pll_id {
+	APLL,
+	DPLL,
+	CPLL,
+	GPLL,
+	NPLL,
+	PLL_COUNT,
 };
 
-enum {
-	/* PLLCON0*/
-	PLL_BP_SHIFT		= 15,
-	PLL_POSTDIV1_SHIFT	= 12,
-	PLL_POSTDIV1_MASK	= 7 << PLL_POSTDIV1_SHIFT,
-	PLL_FBDIV_SHIFT		= 0,
-	PLL_FBDIV_MASK		= 0xfff,
-
-	/* PLLCON1 */
-	PLL_RST_SHIFT		= 14,
-	PLL_PD_SHIFT		= 13,
-	PLL_PD_MASK		= 1 << PLL_PD_SHIFT,
-	PLL_DSMPD_SHIFT		= 12,
-	PLL_DSMPD_MASK		= 1 << PLL_DSMPD_SHIFT,
-	PLL_LOCK_STATUS_SHIFT	= 10,
-	PLL_LOCK_STATUS_MASK	= 1 << PLL_LOCK_STATUS_SHIFT,
-	PLL_POSTDIV2_SHIFT	= 6,
-	PLL_POSTDIV2_MASK	= 7 << PLL_POSTDIV2_SHIFT,
-	PLL_REFDIV_SHIFT	= 0,
-	PLL_REFDIV_MASK		= 0x3f,
-
-	/* CRU_MODE */
-	GPLL_MODE_SHIFT		= 12,
-	GPLL_MODE_MASK		= 1 << GPLL_MODE_SHIFT,
-	GPLL_MODE_SLOW		= 0,
-	GPLL_MODE_NORM,
-	CPLL_MODE_SHIFT		= 8,
-	CPLL_MODE_MASK		= 1 << CPLL_MODE_SHIFT,
-	CPLL_MODE_SLOW		= 0,
-	CPLL_MODE_NORM,
-	DPLL_MODE_SHIFT		= 4,
-	DPLL_MODE_MASK		= 1 << DPLL_MODE_SHIFT,
-	DPLL_MODE_SLOW		= 0,
-	DPLL_MODE_NORM,
-	APLL_MODE_SHIFT		= 0,
-	APLL_MODE_MASK		= 1 << APLL_MODE_SHIFT,
-	APLL_MODE_SLOW		= 0,
-	APLL_MODE_NORM,
+struct rk322x_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
+};
+
+#define RK2928_PLL_CON(x)		((x) * 0x4)
+#define RK2928_MODE_CON		0x40
 
+enum {
 	/* CRU_CLK_SEL0_CON */
 	BUS_ACLK_PLL_SEL_SHIFT	= 13,
 	BUS_ACLK_PLL_SEL_MASK	= 3 << BUS_ACLK_PLL_SEL_SHIFT,
-	BUS_ACLK_PLL_SEL_APLL	= 0,
+	BUS_ACLK_PLL_SEL_CPLL	= 0,
 	BUS_ACLK_PLL_SEL_GPLL,
 	BUS_ACLK_PLL_SEL_HDMIPLL,
 	BUS_ACLK_DIV_SHIFT	= 8,
@@ -184,6 +153,22 @@ enum {
 	SDIO_DIV_SHIFT		= 0,
 	SDIO_DIV_MASK		= 0xff << SDIO_DIV_SHIFT,
 
+	/* CLKSEL_CON24 */
+	CRYPTO_PLL_SEL_SHIFT	= 5,
+	CRYPTO_PLL_SEL_MASK	= 0x1 << CRYPTO_PLL_SEL_SHIFT,
+	CRYPTO_PLL_SEL_CPLL	= 0,
+	CRYPTO_PLL_SEL_GPLL,
+	CRYPTO_DIV_SHIFT	= 0,
+	CRYPTO_DIV_MASK		= 0x1f << CRYPTO_DIV_SHIFT,
+
+	/* CLKSEL_CON25 */
+	SPI_PLL_SEL_SHIFT	= 8,
+	SPI_PLL_SEL_MASK	= 0x1 << SPI_PLL_SEL_SHIFT,
+	SPI_PLL_SEL_CPLL	= 0,
+	SPI_PLL_SEL_GPLL,
+	SPI_DIV_SHIFT		= 0,
+	SPI_DIV_MASK		= 0x7f << SPI_DIV_SHIFT,
+
 	/* CRU_CLKSEL26_CON */
 	DDR_CLK_PLL_SEL_SHIFT	= 8,
 	DDR_CLK_PLL_SEL_MASK	= 3 << DDR_CLK_PLL_SEL_SHIFT,
@@ -194,15 +179,30 @@ enum {
 	DDR_DIV_SEL_MASK	= 3 << DDR_DIV_SEL_SHIFT,
 
 	/* CRU_CLKSEL27_CON */
-	VOP_DCLK_DIV_SHIFT	= 8,
-	VOP_DCLK_DIV_MASK	= 0xff << VOP_DCLK_DIV_SHIFT,
-	VOP_PLL_SEL_SHIFT	= 1,
-	VOP_PLL_SEL_MASK	= 1 << VOP_PLL_SEL_SHIFT,
+	DCLK_LCDC_PLL_SEL_GPLL		= 0,
+	DCLK_LCDC_PLL_SEL_CPLL		= 1,
+	DCLK_LCDC_PLL_SEL_SHIFT		= 0,
+	DCLK_LCDC_PLL_SEL_MASK		= 1 << DCLK_LCDC_PLL_SEL_SHIFT,
+	DCLK_LCDC_SEL_HDMIPHY		= 0,
+	DCLK_LCDC_SEL_PLL		= 1,
+	DCLK_LCDC_SEL_SHIFT		= 1,
+	DCLK_LCDC_SEL_MASK		= 1 << DCLK_LCDC_SEL_SHIFT,
+	DCLK_LCDC_DIV_CON_SHIFT		= 8,
+	DCLK_LCDC_DIV_CON_MASK		= 0xFf << DCLK_LCDC_DIV_CON_SHIFT,
 
 	/* CRU_CLKSEL29_CON */
 	GMAC_CLK_SRC_SHIFT	= 12,
 	GMAC_CLK_SRC_MASK	= 1 << GMAC_CLK_SRC_SHIFT,
 
+	/* CRU_CLKSEL33_CON */
+	ACLK_VOP_PLL_SEL_SHIFT		= 5,
+	ACLK_VOP_PLL_SEL_MASK		= 0x3 << ACLK_VOP_PLL_SEL_SHIFT,
+	ACLK_VOP_PLL_SEL_CPLL		= 0,
+	ACLK_VOP_PLL_SEL_GPLL		= 1,
+	ACLK_VOP_PLL_SEL_HDMIPHY		= 2,
+	ACLK_VOP_DIV_CON_SHIFT		= 0,
+	ACLK_VOP_DIV_CON_MASK		= 0x1f << ACLK_VOP_DIV_CON_SHIFT,
+
 	/* CRU_SOFTRST5_CON */
 	DDRCTRL_PSRST_SHIFT	= 11,
 	DDRCTRL_SRST_SHIFT	= 10,
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk3288.h b/arch/arm/include/asm/arch-rockchip/cru_rk3288.h
index 79a6d6db80..4ebf05d082 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk3288.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3288.h
@@ -25,11 +25,18 @@
 #define PERI_HCLK_HZ	148500000
 #define PERI_PCLK_HZ	74250000
 
+#define HCLK_VIO_HZ	100000000
+
 /* Private data for the clock driver - used by rockchip_get_cru() */
 struct rk3288_clk_priv {
 	struct rk3288_grf *grf;
 	struct rk3288_cru *cru;
 	ulong rate;
+	ulong armclk_hz;
+	ulong armclk_enter_hz;
+	ulong armclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 struct rk3288_cru {
@@ -61,6 +68,12 @@ struct rk3288_cru {
 };
 check_member(rk3288_cru, cru_emmc_con[1], 0x021c);
 
+struct rk3288_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
+};
+
 /* CRU_CLKSEL11_CON */
 enum {
 	HSICPHY_DIV_SHIFT	= 8,
@@ -133,6 +146,49 @@ enum {
 	SPI0_DIV_MASK		= 0x7f << SPI0_DIV_SHIFT,
 };
 
+/* CRU_CLKSEL27_CON */
+enum {
+	DCLK_VOP0_DIV_SHIFT	= 8,
+	DCLK_VOP0_DIV_MASK	= 0xff << DCLK_VOP0_DIV_SHIFT,
+	DCLK_VOP0_PLL_SHIFT	= 0,
+	DCLK_VOP0_PLL_MASK	= 3 << DCLK_VOP0_PLL_SHIFT,
+	DCLK_VOP0_SELECT_CPLL	= 0,
+	DCLK_VOP0_SELECT_GPLL	= 1,
+	DCLK_VOP0_SELECT_NPLL	= 2,
+};
+
+/* CRU_CLKSEL28_CON */
+enum {
+	HCLK_VIO_DIV_SHIFT	= 8,
+	HCLK_VIO_DIV_MASK	= 0x1f << HCLK_VIO_DIV_SHIFT,
+};
+
+/* CRU_CLKSEL29_CON */
+enum {
+	DCLK_VOP1_DIV_SHIFT	= 8,
+	DCLK_VOP1_DIV_MASK	= 0xff << DCLK_VOP1_DIV_SHIFT,
+	DCLK_VOP1_PLL_SHIFT	= 6,
+	DCLK_VOP1_PLL_MASK	= 3 << DCLK_VOP1_PLL_SHIFT,
+	DCLK_VOP1_SELECT_CPLL	= 0,
+	DCLK_VOP1_SELECT_GPLL	= 1,
+	DCLK_VOP1_SELECT_NPLL	= 2,
+};
+
+/* CRU_CLKSEL31_CON */
+enum {
+	ACLK_VIO_SELECT_CPLL	= 0,
+	ACLK_VIO_SELECT_GPLL	= 1,
+	ACLK_VIO_SELECT_USB480	= 2,
+	ACLK_VIO1_PLL_SHIFT	= 14,
+	ACLK_VIO1_PLL_MASK	= 3 << ACLK_VIO1_PLL_SHIFT,
+	ACLK_VIO1_DIV_SHIFT	= 8,
+	ACLK_VIO1_DIV_MASK	= 0x1f << ACLK_VIO1_DIV_SHIFT,
+	ACLK_VIO0_PLL_SHIFT	= 6,
+	ACLK_VIO0_PLL_MASK	= 3 << ACLK_VIO0_PLL_SHIFT,
+	ACLK_VIO0_DIV_SHIFT	= 0,
+	ACLK_VIO0_DIV_MASK	= 0x1f << ACLK_VIO0_DIV_SHIFT,
+};
+
 /* CRU_CLKSEL37_CON */
 enum {
 	PCLK_CORE_DBG_DIV_SHIFT	= 9,
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk3328.h b/arch/arm/include/asm/arch-rockchip/cru_rk3328.h
index 948706e9a3..a412c72a87 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk3328.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3328.h
@@ -12,6 +12,13 @@
 struct rk3328_clk_priv {
 	struct rk3328_cru *cru;
 	ulong rate;
+	ulong cpll_hz;
+	ulong gpll_hz;
+	ulong armclk_hz;
+	ulong armclk_enter_hz;
+	ulong armclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 struct rk3328_cru {
@@ -45,26 +52,195 @@ struct rk3328_cru {
 	u32 sdmmc_ext_con[2];
 };
 check_member(rk3328_cru, sdmmc_ext_con[1], 0x39c);
-#define MHz		1000000
-#define KHz		1000
-#define OSC_HZ		(24 * MHz)
-#define APLL_HZ		(600 * MHz)
-#define GPLL_HZ		(576 * MHz)
-#define CPLL_HZ		(594 * MHz)
-
-#define CLK_CORE_HZ	(600 * MHz)
-#define ACLKM_CORE_HZ	(300 * MHz)
-#define PCLK_DBG_HZ	(300 * MHz)
-
-#define PERIHP_ACLK_HZ	(144000 * KHz)
-#define PERIHP_HCLK_HZ	(72000 * KHz)
-#define PERIHP_PCLK_HZ	(72000 * KHz)
-
-#define PWM_CLOCK_HZ    (74 * MHz)
-
-enum apll_frequencies {
-	APLL_816_MHZ,
-	APLL_600_MHZ,
+
+/* PX30 pll id */
+enum rk3328_pll_id {
+	APLL,
+	DPLL,
+	CPLL,
+	GPLL,
+	NPLL,
+	PLL_COUNT,
+};
+
+struct rk3328_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
+};
+
+#define MHz				1000 * 1000
+#define OSC_HZ				(24 * MHz)
+#define APLL_HZ				(600 * MHz)
+#define GPLL_HZ				491520000
+#define CPLL_HZ				(1200 * MHz)
+#define ACLK_BUS_HZ			(150 * MHz)
+#define ACLK_PERI_HZ			(150 * MHz)
+#define PWM_CLOCK_HZ			(74 * MHz)
+
+#define RK3328_PLL_CON(x)		((x) * 0x4)
+#define RK3328_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
+#define RK3328_CLKGATE_CON(x)		((x) * 0x4 + 0x200)
+#define RK3328_MODE_CON			0x80
+
+enum {
+	/* CLKSEL_CON0 */
+	CLK_BUS_PLL_SEL_CPLL		= 0,
+	CLK_BUS_PLL_SEL_GPLL		= 1,
+	CLK_BUS_PLL_SEL_SHIFT		= 13,
+	CLK_BUS_PLL_SEL_MASK		= 3 << CLK_BUS_PLL_SEL_SHIFT,
+	ACLK_BUS_DIV_CON_SHIFT		= 8,
+	ACLK_BUS_DIV_CON_MASK		= 0x1f << ACLK_BUS_DIV_CON_SHIFT,
+	CORE_CLK_PLL_SEL_SHIFT		= 6,
+	CORE_CLK_PLL_SEL_MASK		= 3 << CORE_CLK_PLL_SEL_SHIFT,
+	CORE_CLK_PLL_SEL_APLL		= 0,
+	CORE_CLK_PLL_SEL_GPLL,
+	CORE_CLK_PLL_SEL_NPLL		= 3,
+	CORE_DIV_CON_SHIFT		= 0,
+	CORE_DIV_CON_MASK		= 0x1f << CORE_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON1 */
+	PCLK_BUS_DIV_CON_SHIFT		= 12,
+	PCLK_BUS_DIV_CON_MASK		= 0x7 << PCLK_BUS_DIV_CON_SHIFT,
+	HCLK_BUS_DIV_CON_SHIFT		= 8,
+	HCLK_BUS_DIV_CON_MASK		= 0x3 << HCLK_BUS_DIV_CON_SHIFT,
+	CORE_ACLK_DIV_SHIFT		= 4,
+	CORE_ACLK_DIV_MASK		= 0x07 << CORE_ACLK_DIV_SHIFT,
+	CORE_DBG_DIV_SHIFT		= 0,
+	CORE_DBG_DIV_MASK		= 0x0f << CORE_DBG_DIV_SHIFT,
+
+	/* CLKSEL_CON26 */
+	GMAC2PHY_PLL_SEL_SHIFT          = 7,
+	GMAC2PHY_PLL_SEL_MASK           = 1 << GMAC2PHY_PLL_SEL_SHIFT,
+	GMAC2PHY_PLL_SEL_CPLL           = 0,
+	GMAC2PHY_PLL_SEL_GPLL           = 1,
+	GMAC2PHY_CLK_DIV_MASK           = 0x1f,
+	GMAC2PHY_CLK_DIV_SHIFT          = 0,
+
+	/* CLKSEL_CON27 */
+	GMAC2IO_PLL_SEL_SHIFT		= 7,
+	GMAC2IO_PLL_SEL_MASK		= 1 << GMAC2IO_PLL_SEL_SHIFT,
+	GMAC2IO_PLL_SEL_CPLL		= 0,
+	GMAC2IO_PLL_SEL_GPLL		= 1,
+	GMAC2IO_CLK_DIV_MASK		= 0x1f,
+	GMAC2IO_CLK_DIV_SHIFT		= 0,
+
+	/* CLKSEL_CON28 */
+	CLK_PERI_PLL_SEL_CPLL		= 0,
+	CLK_PERI_PLL_SEL_GPLL,
+	CLK_PERI_PLL_SEL_HDMIPHY,
+	CLK_PERI_PLL_SEL_SHIFT		= 6,
+	CLK_PERI_PLL_SEL_MASK		= 3 << CLK_PERI_PLL_SEL_SHIFT,
+	ACLK_PERI_DIV_CON_SHIFT		= 0,
+	ACLK_PERI_DIV_CON_MASK		= 0x1f,
+
+	/* CLKSEL_CON29 */
+	PCLK_PERI_DIV_CON_SHIFT		= 4,
+	PCLK_PERI_DIV_CON_MASK		= 0x7 << PCLK_PERI_DIV_CON_SHIFT,
+	HCLK_PERI_DIV_CON_SHIFT		= 0,
+	HCLK_PERI_DIV_CON_MASK		= 3 << HCLK_PERI_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON20 */
+	CRYPTO_PLL_SEL_SHIFT		= 7,
+	CRYPTO_PLL_SEL_MASK		= 0x1 << CRYPTO_PLL_SEL_SHIFT,
+	CRYPTO_PLL_SEL_CPLL		= 0,
+	CRYPTO_PLL_SEL_GPLL,
+	CRYPTO_DIV_SHIFT		= 0,
+	CRYPTO_DIV_MASK			= 0x7f << CRYPTO_DIV_SHIFT,
+
+	/* CLKSEL_CON22 */
+	CLK_TSADC_DIV_CON_SHIFT		= 0,
+	CLK_TSADC_DIV_CON_MASK		= 0x3ff,
+
+	/* CLKSEL_CON23 */
+	CLK_SARADC_DIV_CON_SHIFT	= 0,
+	CLK_SARADC_DIV_CON_MASK		= GENMASK(9, 0),
+	CLK_SARADC_DIV_CON_WIDTH	= 10,
+
+	/* CLKSEL_CON24 */
+	CLK_PWM_PLL_SEL_CPLL		= 0,
+	CLK_PWM_PLL_SEL_GPLL,
+	CLK_PWM_PLL_SEL_SHIFT		= 15,
+	CLK_PWM_PLL_SEL_MASK		= 1 << CLK_PWM_PLL_SEL_SHIFT,
+	CLK_PWM_DIV_CON_SHIFT		= 8,
+	CLK_PWM_DIV_CON_MASK		= 0x7f << CLK_PWM_DIV_CON_SHIFT,
+
+	CLK_SPI_PLL_SEL_CPLL		= 0,
+	CLK_SPI_PLL_SEL_GPLL,
+	CLK_SPI_PLL_SEL_SHIFT		= 7,
+	CLK_SPI_PLL_SEL_MASK		= 1 << CLK_SPI_PLL_SEL_SHIFT,
+	CLK_SPI_DIV_CON_SHIFT		= 0,
+	CLK_SPI_DIV_CON_MASK		= 0x7f << CLK_SPI_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON30 */
+	CLK_SDMMC_PLL_SEL_CPLL		= 0,
+	CLK_SDMMC_PLL_SEL_GPLL,
+	CLK_SDMMC_PLL_SEL_24M,
+	CLK_SDMMC_PLL_SEL_USBPHY,
+	CLK_SDMMC_PLL_SHIFT		= 8,
+	CLK_SDMMC_PLL_MASK		= 0x3 << CLK_SDMMC_PLL_SHIFT,
+	CLK_SDMMC_DIV_CON_SHIFT          = 0,
+	CLK_SDMMC_DIV_CON_MASK           = 0xff << CLK_SDMMC_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON32 */
+	CLK_EMMC_PLL_SEL_CPLL		= 0,
+	CLK_EMMC_PLL_SEL_GPLL,
+	CLK_EMMC_PLL_SEL_24M,
+	CLK_EMMC_PLL_SEL_USBPHY,
+	CLK_EMMC_PLL_SHIFT		= 8,
+	CLK_EMMC_PLL_MASK		= 0x3 << CLK_EMMC_PLL_SHIFT,
+	CLK_EMMC_DIV_CON_SHIFT          = 0,
+	CLK_EMMC_DIV_CON_MASK           = 0xff << CLK_EMMC_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON34 */
+	CLK_I2C_PLL_SEL_CPLL		= 0,
+	CLK_I2C_PLL_SEL_GPLL,
+	CLK_I2C_DIV_CON_MASK		= 0x7f,
+	CLK_I2C_PLL_SEL_MASK		= 1,
+	CLK_I2C1_PLL_SEL_SHIFT		= 15,
+	CLK_I2C1_DIV_CON_SHIFT		= 8,
+	CLK_I2C0_PLL_SEL_SHIFT		= 7,
+	CLK_I2C0_DIV_CON_SHIFT		= 0,
+
+	/* CLKSEL_CON35 */
+	CLK_I2C3_PLL_SEL_SHIFT		= 15,
+	CLK_I2C3_DIV_CON_SHIFT		= 8,
+	CLK_I2C2_PLL_SEL_SHIFT		= 7,
+	CLK_I2C2_DIV_CON_SHIFT		= 0,
+
+	/* CRU_CLK_SEL37_CON */
+	ACLK_VIO_PLL_SEL_CPLL		= 0,
+	ACLK_VIO_PLL_SEL_GPLL		= 1,
+	ACLK_VIO_PLL_SEL_HDMIPHY	= 2,
+	ACLK_VIO_PLL_SEL_USB480M	= 3,
+	ACLK_VIO_PLL_SEL_SHIFT		= 6,
+	ACLK_VIO_PLL_SEL_MASK		= 3 << ACLK_VIO_PLL_SEL_SHIFT,
+	ACLK_VIO_DIV_CON_SHIFT		= 0,
+	ACLK_VIO_DIV_CON_MASK		= 0x1f << ACLK_VIO_DIV_CON_SHIFT,
+	HCLK_VIO_DIV_CON_SHIFT		= 8,
+	HCLK_VIO_DIV_CON_MASK		= 0x1f << HCLK_VIO_DIV_CON_SHIFT,
+
+	/* CRU_CLK_SEL39_CON */
+	ACLK_VOP_PLL_SEL_CPLL		= 0,
+	ACLK_VOP_PLL_SEL_GPLL		= 1,
+	ACLK_VOP_PLL_SEL_HDMIPHY	= 2,
+	ACLK_VOP_PLL_SEL_USB480M	= 3,
+	ACLK_VOP_PLL_SEL_SHIFT		= 6,
+	ACLK_VOP_PLL_SEL_MASK		= 3 << ACLK_VOP_PLL_SEL_SHIFT,
+	ACLK_VOP_DIV_CON_SHIFT		= 0,
+	ACLK_VOP_DIV_CON_MASK		= 0x1f << ACLK_VOP_DIV_CON_SHIFT,
+
+	/* CRU_CLK_SEL40_CON */
+	DCLK_LCDC_PLL_SEL_GPLL		= 0,
+	DCLK_LCDC_PLL_SEL_CPLL		= 1,
+	DCLK_LCDC_PLL_SEL_SHIFT		= 0,
+	DCLK_LCDC_PLL_SEL_MASK		= 1 << DCLK_LCDC_PLL_SEL_SHIFT,
+	DCLK_LCDC_SEL_HDMIPHY		= 0,
+	DCLK_LCDC_SEL_PLL		= 1,
+	DCLK_LCDC_SEL_SHIFT		= 1,
+	DCLK_LCDC_SEL_MASK		= 1 << DCLK_LCDC_SEL_SHIFT,
+	DCLK_LCDC_DIV_CON_SHIFT		= 8,
+	DCLK_LCDC_DIV_CON_MASK		= 0xFf << DCLK_LCDC_DIV_CON_SHIFT,
 };
 
 #endif	/* __ASM_ARCH_CRU_RK3328_H_ */
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk3368.h b/arch/arm/include/asm/arch-rockchip/cru_rk3368.h
index 2b1197fd46..dcb7d6eafd 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk3368.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3368.h
@@ -20,6 +20,12 @@ enum rk3368_pll_id {
 	PLL_COUNT,
 };
 
+struct rk3368_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
+};
+
 struct rk3368_cru {
 	struct rk3368_pll {
 		unsigned int con0;
@@ -51,6 +57,14 @@ check_member(rk3368_cru, emmc_con[1], 0x41c);
 
 struct rk3368_clk_priv {
 	struct rk3368_cru *cru;
+	ulong armlclk_hz;
+	ulong armlclk_enter_hz;
+	ulong armlclk_init_hz;
+	ulong armbclk_hz;
+	ulong armbclk_enter_hz;
+	ulong armbclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 enum {
@@ -79,6 +93,49 @@ enum {
 	PLL_RESET			= 1,
 	PLL_RESET_MASK			= GENMASK(5, 5),
 
+	/* CLKSEL1CON */
+	CORE_ACLK_DIV_SHIFT		= 0,
+	CORE_ACLK_DIV_MASK		= 0x1f << CORE_ACLK_DIV_SHIFT,
+	CORE_DBG_DIV_SHIFT		= 8,
+	CORE_DBG_DIV_MASK		= 0x1f << CORE_DBG_DIV_SHIFT,
+
+	CORE_CLK_PLL_SEL_SHIFT		= 7,
+	CORE_CLK_PLL_SEL_MASK		= 1 << CORE_CLK_PLL_SEL_SHIFT,
+	CORE_CLK_PLL_SEL_APLL		= 0,
+	CORE_CLK_PLL_SEL_GPLL,
+	CORE_DIV_CON_SHIFT		= 0,
+	CORE_DIV_CON_MASK		= 0x1f << CORE_DIV_CON_SHIFT,
+
+	/* CLKSEL8CON */
+	PCLK_BUS_DIV_CON_SHIFT		= 12,
+	PCLK_BUS_DIV_CON_MASK		= 0x7 << PCLK_BUS_DIV_CON_SHIFT,
+	HCLK_BUS_DIV_CON_SHIFT		= 8,
+	HCLK_BUS_DIV_CON_MASK		= 0x3 << HCLK_BUS_DIV_CON_SHIFT,
+	CLK_BUS_PLL_SEL_CPLL		= 0,
+	CLK_BUS_PLL_SEL_GPLL		= 1,
+	CLK_BUS_PLL_SEL_SHIFT		= 7,
+	CLK_BUS_PLL_SEL_MASK		= 1 << CLK_BUS_PLL_SEL_SHIFT,
+	ACLK_BUS_DIV_CON_SHIFT		= 0,
+	ACLK_BUS_DIV_CON_MASK		= 0x1f << ACLK_BUS_DIV_CON_SHIFT,
+
+	/* CLKSEL9CON */
+	PCLK_PERI_DIV_CON_SHIFT		= 12,
+	PCLK_PERI_DIV_CON_MASK		= 0x3 << PCLK_PERI_DIV_CON_SHIFT,
+	HCLK_PERI_DIV_CON_SHIFT		= 8,
+	HCLK_PERI_DIV_CON_MASK		= 3 << HCLK_PERI_DIV_CON_SHIFT,
+	CLK_PERI_PLL_SEL_CPLL		= 0,
+	CLK_PERI_PLL_SEL_GPLL,
+	CLK_PERI_PLL_SEL_SHIFT		= 7,
+	CLK_PERI_PLL_SEL_MASK		= 1 << CLK_PERI_PLL_SEL_SHIFT,
+	ACLK_PERI_DIV_CON_SHIFT		= 0,
+	ACLK_PERI_DIV_CON_MASK		= 0x1f,
+
+	/* CLKSEL10CON */
+	CLK_CRYPTO_DIV_CON_SHIFT	= 14,
+	CLK_CRYPTO_DIV_CON_MASK		= 0x3 << CLK_CRYPTO_DIV_CON_SHIFT,
+	PCLK_ALIVE_DIV_CON_SHIFT	= 8,
+	PCLK_ALIVE_DIV_CON_MASK		= 0x1f << PCLK_ALIVE_DIV_CON_SHIFT,
+
 	/* CLKSEL12_CON */
 	MCU_STCLK_DIV_SHIFT		= 8,
 	MCU_STCLK_DIV_MASK		= GENMASK(10, 8),
@@ -89,7 +146,36 @@ enum {
 	MCU_CLK_DIV_SHIFT		= 0,
 	MCU_CLK_DIV_MASK		= GENMASK(4, 0),
 
+	/* CLKSEL19_CON */
+	ACLK_VOP_PLL_SEL_SHIFT		= 6,
+	ACLK_VOP_PLL_SEL_MASK		= GENMASK(7, 6),
+	ACLK_VOP_PLL_SEL_CPLL		= 0,
+	ACLK_VOP_PLL_SEL_GPLL		= 1,
+	ACLK_VOP_DIV_SHIFT		= 0,
+	ACLK_VOP_DIV_MASK		= GENMASK(4, 0),
+
+	/* CLKSEL20_CON */
+	DCLK_VOP_PLL_SEL_SHIFT		= 8,
+	DCLK_VOP_PLL_SEL_MASK		= GENMASK(9, 8),
+	DCLK_VOP_PLL_SEL_CPLL		= 0,
+	DCLK_VOP_PLL_SEL_GPLL		= 1,
+	DCLK_VOP_PLL_SEL_NPLL		= 2,
+	DCLK_VOP_DIV_SHIFT		= 0,
+	DCLK_VOP_DIV_MASK		= GENMASK(7, 0),
+
+	/* CLKSEL_CON25 */
+	CLK_SARADC_DIV_CON_SHIFT	= 8,
+	CLK_SARADC_DIV_CON_MASK		= GENMASK(15, 8),
+	CLK_SARADC_DIV_CON_WIDTH	= 8,
+
 	/* CLKSEL43_CON */
+	GMAC_DIV_CON_SHIFT		= 0x0,
+	GMAC_DIV_CON_MASK		= GENMASK(4, 0),
+	GMAC_PLL_SHIFT			= 6,
+	GMAC_PLL_MASK			= GENMASK(7, 6),
+	GMAC_PLL_SELECT_NEW		= (0x0 << GMAC_PLL_SHIFT),
+	GMAC_PLL_SELECT_CODEC		= (0x1 << GMAC_PLL_SHIFT),
+	GMAC_PLL_SELECT_GENERAL		= (0x2 << GMAC_PLL_SHIFT),
 	GMAC_MUX_SEL_EXTCLK             = BIT(8),
 
 	/* CLKSEL51_CON */
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rk3399.h b/arch/arm/include/asm/arch-rockchip/cru_rk3399.h
index 033f067122..55d09af7ea 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rk3399.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3399.h
@@ -12,6 +12,14 @@
 /* Private data for the clock driver - used by rockchip_get_cru() */
 struct rk3399_clk_priv {
 	struct rk3399_cru *cru;
+	ulong armlclk_hz;
+	ulong armlclk_enter_hz;
+	ulong armlclk_init_hz;
+	ulong armbclk_hz;
+	ulong armbclk_enter_hz;
+	ulong armbclk_init_hz;
+	bool sync_kernel;
+	bool set_armclk_rate;
 };
 
 struct rk3399_pmuclk_priv {
@@ -71,8 +79,9 @@ check_member(rk3399_cru, sdio1_con[1], 0x594);
 #define KHz		1000
 #define OSC_HZ		(24*MHz)
 #define APLL_HZ		(600*MHz)
-#define GPLL_HZ		(594*MHz)
+#define GPLL_HZ		(800 * MHz)
 #define CPLL_HZ		(384*MHz)
+#define NPLL_HZ		(600 * MHz)
 #define PPLL_HZ		(676*MHz)
 
 #define PMU_PCLK_HZ	(48*MHz)
@@ -81,22 +90,48 @@ check_member(rk3399_cru, sdio1_con[1], 0x594);
 #define ATCLK_CORE_HZ	(300*MHz)
 #define PCLK_DBG_HZ	(100*MHz)
 
-#define PERIHP_ACLK_HZ	(148500*KHz)
-#define PERIHP_HCLK_HZ	(148500*KHz)
-#define PERIHP_PCLK_HZ	(37125*KHz)
+#define PERIHP_ACLK_HZ	(150 * MHz)
+#define PERIHP_HCLK_HZ	(75 * MHz)
+#define PERIHP_PCLK_HZ	(37500 * KHz)
 
-#define PERILP0_ACLK_HZ	(99000*KHz)
-#define PERILP0_HCLK_HZ	(99000*KHz)
-#define PERILP0_PCLK_HZ	(49500*KHz)
+#define PERILP0_ACLK_HZ	(300 * MHz)
+#define PERILP0_HCLK_HZ	(100 * MHz)
+#define PERILP0_PCLK_HZ	(50 * MHz)
 
-#define PERILP1_HCLK_HZ	(99000*KHz)
-#define PERILP1_PCLK_HZ	(49500*KHz)
+#define PERILP1_HCLK_HZ	(100 * MHz)
+#define PERILP1_PCLK_HZ	(50 * MHz)
 
 #define PWM_CLOCK_HZ    PMU_PCLK_HZ
 
-enum apll_l_frequencies {
-	APLL_L_1600_MHZ,
-	APLL_L_600_MHZ,
+enum apll_frequencies {
+	APLL_1600_MHZ,
+	APLL_816_MHZ,
+	APLL_600_MHZ,
+};
+
+enum cpu_cluster {
+	CPU_CLUSTER_LITTLE,
+	CPU_CLUSTER_BIG,
+};
+
+enum rk3399_pll_id {
+	APLLL_ID = 0,
+	APLLB_ID,
+	DPLL_ID,
+	CPLL_ID,
+	GPLL_ID,
+	NPLL_ID,
+	VPLL_ID,
+
+	PPLL_ID,
+
+	END_PLL_ID
+};
+
+struct rk3399_clk_info {
+	unsigned long id;
+	char *name;
+	bool is_cru;
 };
 
 #endif	/* __ASM_ARCH_CRU_RK3399_H_ */
diff --git a/arch/arm/include/asm/arch-rockchip/cru_rv1108.h b/arch/arm/include/asm/arch-rockchip/cru_rv1108.h
index 2a1ae692be..a29b9f8be2 100644
--- a/arch/arm/include/asm/arch-rockchip/cru_rv1108.h
+++ b/arch/arm/include/asm/arch-rockchip/cru_rv1108.h
@@ -1,8 +1,9 @@
 /*
- * (C) Copyright 2016 Rockchip Electronics Co., Ltd
- * Author: Andy Yan <andy.yan@rock-chips.com>
- * SPDX-License-Identifier:     GPL-2.0+
+ * Copyright (C) 2018 Rockchip Electronics Co., Ltd
+ * Author: Zhihuan He <huan.he@rock-chips.com>
+ * SPDX-License-Identifier:	GPL-2.0
  */
+
 #ifndef _ASM_ARCH_CRU_RV1108_H
 #define _ASM_ARCH_CRU_RV1108_H
 
@@ -11,7 +12,11 @@
 #define OSC_HZ		(24 * 1000 * 1000)
 
 #define APLL_HZ		(600 * 1000000)
-#define GPLL_HZ		(594 * 1000000)
+#define GPLL_HZ		(1188 * 1000000)
+#define ACLK_PERI_HZ	(148500000)
+#define HCLK_PERI_HZ	(148500000)
+#define PCLK_PERI_HZ	(74250000)
+#define ACLK_BUS_HZ	(148500000)
 
 struct rv1108_clk_priv {
 	struct rv1108_cru *cru;
@@ -56,56 +61,214 @@ struct pll_div {
 
 enum {
 	/* PLL CON0 */
-	FBDIV_MASK		= 0xfff,
-	FBDIV_SHIFT		= 0,
+	FBDIV_MASK			= 0xfff,
+	FBDIV_SHIFT			= 0,
 
 	/* PLL CON1 */
-	POSTDIV2_SHIFT          = 12,
-	POSTDIV2_MASK		= 7 << POSTDIV2_SHIFT,
-	POSTDIV1_SHIFT          = 8,
-	POSTDIV1_MASK		= 7 << POSTDIV1_SHIFT,
-	REFDIV_MASK		= 0x3f,
-	REFDIV_SHIFT		= 0,
+	POSTDIV2_SHIFT			= 12,
+	POSTDIV2_MASK			= 7 << POSTDIV2_SHIFT,
+	POSTDIV1_SHIFT			= 8,
+	POSTDIV1_MASK			= 7 << POSTDIV1_SHIFT,
+	REFDIV_MASK			= 0x3f,
+	REFDIV_SHIFT			= 0,
 
 	/* PLL CON2 */
-	LOCK_STA_SHIFT          = 31,
-	LOCK_STA_MASK		= 1 << LOCK_STA_SHIFT,
-	FRACDIV_MASK		= 0xffffff,
-	FRACDIV_SHIFT		= 0,
+	LOCK_STA_SHIFT			= 31,
+	LOCK_STA_MASK			= 1 << LOCK_STA_SHIFT,
+	FRACDIV_MASK			= 0xffffff,
+	FRACDIV_SHIFT			= 0,
 
 	/* PLL CON3 */
-	WORK_MODE_SHIFT         = 8,
-	WORK_MODE_MASK		= 1 << WORK_MODE_SHIFT,
-	WORK_MODE_SLOW		= 0,
-	WORK_MODE_NORMAL	= 1,
-	DSMPD_SHIFT             = 3,
-	DSMPD_MASK		= 1 << DSMPD_SHIFT,
+	WORK_MODE_SHIFT			= 8,
+	WORK_MODE_MASK			= 1 << WORK_MODE_SHIFT,
+	WORK_MODE_SLOW			= 0,
+	WORK_MODE_NORMAL		= 1,
+	DSMPD_SHIFT			= 3,
+	DSMPD_MASK			= 1 << DSMPD_SHIFT,
+	INTEGER_MODE			= 1,
+	GLOBAL_POWER_DOWN_SHIFT		= 0,
+	GLOBAL_POWER_DOWN_MASK		= 1 << GLOBAL_POWER_DOWN_SHIFT,
+	GLOBAL_POWER_DOWN		= 1,
+	GLOBAL_POWER_UP			= 0,
 
 	/* CLKSEL0_CON */
-	CORE_PLL_SEL_SHIFT	= 8,
-	CORE_PLL_SEL_MASK	= 3 << CORE_PLL_SEL_SHIFT,
-	CORE_PLL_SEL_APLL	= 0,
-	CORE_PLL_SEL_GPLL	= 1,
-	CORE_PLL_SEL_DPLL	= 2,
-	CORE_CLK_DIV_SHIFT	= 0,
-	CORE_CLK_DIV_MASK	= 0x1f << CORE_CLK_DIV_SHIFT,
+	CORE_PLL_SEL_SHIFT		= 8,
+	CORE_PLL_SEL_MASK		= 3 << CORE_PLL_SEL_SHIFT,
+	CORE_PLL_SEL_APLL		= 0,
+	CORE_PLL_SEL_GPLL		= 1,
+	CORE_PLL_SEL_DPLL		= 2,
+	CORE_CLK_DIV_SHIFT		= 0,
+	CORE_CLK_DIV_MASK		= 0x1f << CORE_CLK_DIV_SHIFT,
+
+	/* CLKSEL_CON1 */
+	PCLK_DBG_DIV_CON_SHIFT		= 4,
+	PCLK_DBG_DIV_CON_MASK		= 0xf << PCLK_DBG_DIV_CON_SHIFT,
+	ACLK_CORE_DIV_CON_SHIFT		= 0,
+	ACLK_CORE_DIV_CON_MASK		= 7 << ACLK_CORE_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON2 */
+	ACLK_BUS_PLL_SEL_SHIFT		= 8,
+	ACLK_BUS_PLL_SEL_MASK		= 3 << ACLK_BUS_PLL_SEL_SHIFT,
+	ACLK_BUS_PLL_SEL_GPLL		= 0,
+	ACLK_BUS_PLL_SEL_APLL		= 1,
+	ACLK_BUS_PLL_SEL_DPLL		= 2,
+	ACLK_BUS_DIV_CON_SHIFT		= 0,
+	ACLK_BUS_DIV_CON_MASK		= 0x1f << ACLK_BUS_DIV_CON_SHIFT,
+	ACLK_BUS_DIV_CON_WIDTH		= 5,
+
+	/* CLKSEL_CON3 */
+	PCLK_BUS_DIV_CON_SHIFT		= 8,
+	PCLK_BUS_DIV_CON_MASK		= 0x1f << PCLK_BUS_DIV_CON_SHIFT,
+	HCLK_BUS_DIV_CON_SHIFT		= 0,
+	HCLK_BUS_DIV_CON_MASK		= 0x1f,
+
+	/* CLKSEL_CON4 */
+	CLK_DDR_PLL_SEL_SHIFT		= 8,
+	CLK_DDR_PLL_SEL_MASK		= 0x3 << CLK_DDR_PLL_SEL_SHIFT,
+	CLK_DDR_DIV_CON_SHIFT		= 0,
+	CLK_DDR_DIV_CON_MASK		= 0x3 << CLK_DDR_DIV_CON_SHIFT,
+
+	/* CLKSEL_CON11 */
+	SPI_PLL_SEL_SHIFT		= 15,
+	SPI_PLL_SEL_MASK		= 0x1 << SPI_PLL_SEL_SHIFT,
+	SPI_PLL_SEL_DPLL		= 0,
+	SPI_PLL_SEL_GPLL,
+	SPI_DIV_SHIFT			= 8,
+	SPI_DIV_MASK			= 0x7f << SPI_DIV_SHIFT,
+
+	/* CLKSEL_CON19 */
+	CLK_I2C1_PLL_SEL_SHIFT		= 15,
+	CLK_I2C1_PLL_SEL_MASK		= 1 << CLK_I2C1_PLL_SEL_SHIFT,
+	CLK_I2C1_PLL_SEL_DPLL		= 0,
+	CLK_I2C1_PLL_SEL_GPLL		= 1,
+	CLK_I2C1_DIV_CON_SHIFT		= 8,
+	CLK_I2C1_DIV_CON_MASK		= 0x7f << CLK_I2C1_DIV_CON_SHIFT,
+	CLK_I2C0_PLL_SEL_SHIFT		= 7,
+	CLK_I2C0_PLL_SEL_MASK		= 1 << CLK_I2C0_PLL_SEL_SHIFT,
+	CLK_I2C0_DIV_CON_SHIFT		= 0,
+	CLK_I2C0_DIV_CON_MASK		= 0x7f,
+	I2C_DIV_CON_WIDTH		= 7,
+
+	/* CLKSEL_CON20 */
+	CLK_I2C3_PLL_SEL_SHIFT		= 15,
+	CLK_I2C3_PLL_SEL_MASK		= 1 << CLK_I2C3_PLL_SEL_SHIFT,
+	CLK_I2C3_PLL_SEL_DPLL		= 0,
+	CLK_I2C3_PLL_SEL_GPLL		= 1,
+	CLK_I2C3_DIV_CON_SHIFT		= 8,
+	CLK_I2C3_DIV_CON_MASK		= 0x7f << CLK_I2C3_DIV_CON_SHIFT,
+	CLK_I2C2_PLL_SEL_SHIFT		= 7,
+	CLK_I2C2_PLL_SEL_MASK		= 1 << CLK_I2C2_PLL_SEL_SHIFT,
+	CLK_I2C2_DIV_CON_SHIFT		= 0,
+	CLK_I2C2_DIV_CON_MASK		= 0x7f,
+
+	/* CLKSEL_CON22 */
+	CLK_SARADC_DIV_CON_SHIFT	= 0,
+	CLK_SARADC_DIV_CON_MASK		= GENMASK(9, 0),
+	CLK_SARADC_DIV_CON_WIDTH	= 10,
+
+	/* CLKSEL_CON23 */
+	ACLK_PERI_PLL_SEL_SHIFT		= 15,
+	ACLK_PERI_PLL_SEL_MASK		= 1 << ACLK_PERI_PLL_SEL_SHIFT,
+	ACLK_PERI_PLL_SEL_GPLL		= 0,
+	ACLK_PERI_PLL_SEL_DPLL		= 1,
+	PCLK_PERI_DIV_CON_SHIFT		= 10,
+	PCLK_PERI_DIV_CON_MASK		= 0x1f << PCLK_PERI_DIV_CON_SHIFT,
+	HCLK_PERI_DIV_CON_SHIFT		= 5,
+	HCLK_PERI_DIV_CON_MASK		= 0x1f << HCLK_PERI_DIV_CON_SHIFT,
+	ACLK_PERI_DIV_CON_SHIFT		= 0,
+	ACLK_PERI_DIV_CON_MASK		= 0x1f,
+	PERI_DIV_CON_WIDTH		= 5,
 
 	/* CLKSEL24_CON */
-	MAC_PLL_SEL_SHIFT	= 12,
-	MAC_PLL_SEL_MASK	= 1 << MAC_PLL_SEL_SHIFT,
-	MAC_PLL_SEL_APLL	= 0,
-	MAC_PLL_SEL_GPLL	= 1,
-	RMII_EXTCLK_SEL_SHIFT   = 8,
-	RMII_EXTCLK_SEL_MASK	= 1 << RMII_EXTCLK_SEL_SHIFT,
-	MAC_CLK_DIV_MASK	= 0x1f,
-	MAC_CLK_DIV_SHIFT	= 0,
+	MAC_PLL_SEL_SHIFT		= 12,
+	MAC_PLL_SEL_MASK		= 1 << MAC_PLL_SEL_SHIFT,
+	MAC_PLL_SEL_APLL		= 0,
+	MAC_PLL_SEL_GPLL		= 1,
+	RMII_EXTCLK_SEL_SHIFT		= 8,
+	RMII_EXTCLK_SEL_MASK		= 1 << RMII_EXTCLK_SEL_SHIFT,
+	MAC_CLK_DIV_MASK		= 0x1f,
+	MAC_CLK_DIV_SHIFT		= 0,
+
+	/* CLKSEL25_CON */
+	EMMC_PLL_SEL_SHIFT	= 12,
+	EMMC_PLL_SEL_MASK	= 3 << EMMC_PLL_SEL_SHIFT,
+	EMMC_PLL_SEL_DPLL	= 0,
+	EMMC_PLL_SEL_GPLL,
+	EMMC_PLL_SEL_OSC,
+
+	/* CLKSEL26_CON */
+	EMMC_CLK_DIV_SHIFT	= 8,
+	EMMC_CLK_DIV_MASK	= 0xff << EMMC_CLK_DIV_SHIFT,
 
 	/* CLKSEL27_CON */
-	SFC_PLL_SEL_SHIFT	= 7,
-	SFC_PLL_SEL_MASK	= 1 << SFC_PLL_SEL_SHIFT,
-	SFC_PLL_SEL_DPLL	= 0,
-	SFC_PLL_SEL_GPLL	= 1,
-	SFC_CLK_DIV_SHIFT	= 0,
-	SFC_CLK_DIV_MASK	= 0x3f << SFC_CLK_DIV_SHIFT,
+	NANDC_PLL_SEL_SHIFT     = 14,
+	NANDC_PLL_SEL_MASK      = 3 << NANDC_PLL_SEL_SHIFT,
+	NANDC_PLL_SEL_CPLL      = 0,
+	NANDC_PLL_SEL_GPLL,
+	NANDC_CLK_DIV_SHIFT     = 8,
+	NANDC_CLK_DIV_MASK      = 0x1f << NANDC_CLK_DIV_SHIFT,
+
+	SFC_PLL_SEL_SHIFT		= 7,
+	SFC_PLL_SEL_MASK		= 1 << SFC_PLL_SEL_SHIFT,
+	SFC_PLL_SEL_DPLL		= 0,
+	SFC_PLL_SEL_GPLL		= 1,
+	SFC_CLK_DIV_SHIFT		= 0,
+	SFC_CLK_DIV_MASK		= 0x3f << SFC_CLK_DIV_SHIFT,
+
+	/* CLKSEL28_CON */
+	ACLK_VIO1_PLL_SEL_SHIFT		= 14,
+	ACLK_VIO1_PLL_SEL_MASK		= 3 << ACLK_VIO1_PLL_SEL_SHIFT,
+	VIO_PLL_SEL_DPLL		= 0,
+	VIO_PLL_SEL_GPLL		= 1,
+	ACLK_VIO1_CLK_DIV_SHIFT		= 8,
+	ACLK_VIO1_CLK_DIV_MASK		= 0x1f << ACLK_VIO1_CLK_DIV_SHIFT,
+	CLK_VIO_DIV_CON_WIDTH		= 5,
+	ACLK_VIO0_PLL_SEL_SHIFT		= 6,
+	ACLK_VIO0_PLL_SEL_MASK		= 3 << ACLK_VIO0_PLL_SEL_SHIFT,
+	ACLK_VIO0_CLK_DIV_SHIFT		= 0,
+	ACLK_VIO0_CLK_DIV_MASK		= 0x1f << ACLK_VIO0_CLK_DIV_SHIFT,
+
+	/* CLKSEL29_CON */
+	PCLK_VIO_CLK_DIV_SHIFT		= 8,
+	PCLK_VIO_CLK_DIV_MASK		= 0x1f << PCLK_VIO_CLK_DIV_SHIFT,
+	HCLK_VIO_CLK_DIV_SHIFT		= 0,
+	HCLK_VIO_CLK_DIV_MASK		= 0x1f << HCLK_VIO_CLK_DIV_SHIFT,
+
+	/* CLKSEL32_CON */
+	DCLK_VOP_SEL_SHIFT		= 7,
+	DCLK_VOP_SEL_MASK		= 1 << DCLK_VOP_SEL_SHIFT,
+	DCLK_VOP_SEL_HDMI		= 0,
+	DCLK_VOP_SEL_PLL		= 1,
+	DCLK_VOP_PLL_SEL_SHIFT		= 6,
+	DCLK_VOP_PLL_SEL_MASK		= 1 << DCLK_VOP_PLL_SEL_SHIFT,
+	DCLK_VOP_PLL_SEL_GPLL		= 0,
+	DCLK_VOP_PLL_SEL_DPLL		= 1,
+	DCLK_VOP_CLK_DIV_SHIFT		= 0,
+	DCLK_VOP_CLK_DIV_MASK		= 0x3f << DCLK_VOP_CLK_DIV_SHIFT,
+	DCLK_VOP_DIV_CON_WIDTH		= 6,
+
+	/* SOFTRST1_CON*/
+	DDRPHY_SRSTN_CLKDIV_REQ_SHIFT	= 0,
+	DDRPHY_SRSTN_CLKDIV_REQ		= 1,
+	DDRPHY_SRSTN_CLKDIV_DIS		= 0,
+	DDRPHY_SRSTN_CLKDIV_REQ_MASK	= 1 << DDRPHY_SRSTN_CLKDIV_REQ_SHIFT,
+	DDRPHY_SRSTN_REQ_SHIFT		= 1,
+	DDRPHY_SRSTN_REQ		= 1,
+	DDRPHY_SRSTN_DIS		= 0,
+	DDRPHY_SRSTN_REQ_MASK		= 1 << DDRPHY_SRSTN_REQ_SHIFT,
+	DDRPHY_PSRSTN_REQ_SHIFT		= 2,
+	DDRPHY_PSRSTN_REQ		= 1,
+	DDRPHY_PSRSTN_DIS		= 0,
+	DDRPHY_PSRSTN_REQ_MASK		= 1 << DDRPHY_PSRSTN_REQ_SHIFT,
+
+	/* SOFTRST2_CON*/
+	DDRUPCTL_PSRSTN_REQ_SHIFT	= 0,
+	DDRUPCTL_PSRSTN_REQ		= 1,
+	DDRUPCTL_PSRSTN_DIS		= 0,
+	DDRUPCTL_PSRSTN_REQ_MASK	= 1 << DDRUPCTL_PSRSTN_REQ_SHIFT,
+	DDRUPCTL_NSRSTN_REQ_SHIFT	= 1,
+	DDRUPCTL_NSRSTN_REQ		= 1,
+	DDRUPCTL_NSRSTN_DIS		= 0,
+	DDRUPCTL_NSRSTN_REQ_MASK	= 1 << DDRUPCTL_NSRSTN_REQ_SHIFT,
 };
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/gpio.h b/arch/arm/include/asm/arch-rockchip/gpio.h
index e39218d0a9..84b11b7dd5 100644
--- a/arch/arm/include/asm/arch-rockchip/gpio.h
+++ b/arch/arm/include/asm/arch-rockchip/gpio.h
@@ -7,6 +7,7 @@
 #ifndef _ASM_ARCH_GPIO_H
 #define _ASM_ARCH_GPIO_H
 
+#ifndef CONFIG_ROCKCHIP_GPIO_V2
 struct rockchip_gpio_regs {
 	u32 swport_dr;
 	u32 swport_ddr;
@@ -24,5 +25,40 @@ struct rockchip_gpio_regs {
 	u32 ls_sync;
 };
 check_member(rockchip_gpio_regs, ls_sync, 0x60);
+#else
+struct rockchip_gpio_regs {
+	u32 swport_dr_l;                        /* ADDRESS OFFSET: 0x0000 */
+	u32 swport_dr_h;                        /* ADDRESS OFFSET: 0x0004 */
+	u32 swport_ddr_l;                       /* ADDRESS OFFSET: 0x0008 */
+	u32 swport_ddr_h;                       /* ADDRESS OFFSET: 0x000c */
+	u32 int_en_l;                           /* ADDRESS OFFSET: 0x0010 */
+	u32 int_en_h;                           /* ADDRESS OFFSET: 0x0014 */
+	u32 int_mask_l;                         /* ADDRESS OFFSET: 0x0018 */
+	u32 int_mask_h;                         /* ADDRESS OFFSET: 0x001c */
+	u32 int_type_l;                         /* ADDRESS OFFSET: 0x0020 */
+	u32 int_type_h;                         /* ADDRESS OFFSET: 0x0024 */
+	u32 int_polarity_l;                     /* ADDRESS OFFSET: 0x0028 */
+	u32 int_polarity_h;                     /* ADDRESS OFFSET: 0x002c */
+	u32 int_bothedge_l;                     /* ADDRESS OFFSET: 0x0030 */
+	u32 int_bothedge_h;                     /* ADDRESS OFFSET: 0x0034 */
+	u32 debounce_l;                         /* ADDRESS OFFSET: 0x0038 */
+	u32 debounce_h;                         /* ADDRESS OFFSET: 0x003c */
+	u32 dbclk_div_en_l;                     /* ADDRESS OFFSET: 0x0040 */
+	u32 dbclk_div_en_h;                     /* ADDRESS OFFSET: 0x0044 */
+	u32 dbclk_div_con;                      /* ADDRESS OFFSET: 0x0048 */
+	u32 reserved004c;                       /* ADDRESS OFFSET: 0x004c */
+	u32 int_status;                         /* ADDRESS OFFSET: 0x0050 */
+	u32 reserved0054;                       /* ADDRESS OFFSET: 0x0054 */
+	u32 int_rawstatus;                      /* ADDRESS OFFSET: 0x0058 */
+	u32 reserved005c;                       /* ADDRESS OFFSET: 0x005c */
+	u32 port_eoi_l;                         /* ADDRESS OFFSET: 0x0060 */
+	u32 port_eoi_h;                         /* ADDRESS OFFSET: 0x0064 */
+	u32 reserved0068[2];                    /* ADDRESS OFFSET: 0x0068 */
+	u32 ext_port;                           /* ADDRESS OFFSET: 0x0070 */
+	u32 reserved0074;                       /* ADDRESS OFFSET: 0x0074 */
+	u32 ver_id;                             /* ADDRESS OFFSET: 0x0078 */
+};
+check_member(rockchip_gpio_regs, ver_id, 0x0078);
+#endif
 
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/grf_rk3036.h b/arch/arm/include/asm/arch-rockchip/grf_rk3036.h
index 7625f249bd..d995b7db14 100644
--- a/arch/arm/include/asm/arch-rockchip/grf_rk3036.h
+++ b/arch/arm/include/asm/arch-rockchip/grf_rk3036.h
@@ -209,10 +209,10 @@ enum {
 	GPIO1A3_I2S_LRCKTX,
 
 	GPIO1A2_SHIFT		= 4,
-	GPIO1A2_MASK		= 6 << GPIO1A2_SHIFT,
+	GPIO1A2_MASK		= 3 << GPIO1A2_SHIFT,
 	GPIO1A2_GPIO		= 0,
 	GPIO1A2_I2S_LRCKRX,
-	GPIO1A2_I2S_PWM1_0,
+	GPIO1A2_PWM1_0,
 
 	GPIO1A1_SHIFT		= 2,
 	GPIO1A1_MASK		= 1 << GPIO1A1_SHIFT,
diff --git a/arch/arm/include/asm/arch-rockchip/grf_rk322x.h b/arch/arm/include/asm/arch-rockchip/grf_rk322x.h
index 26071c8ec8..52e5a0a0d5 100644
--- a/arch/arm/include/asm/arch-rockchip/grf_rk322x.h
+++ b/arch/arm/include/asm/arch-rockchip/grf_rk322x.h
@@ -54,6 +54,32 @@ struct rk322x_grf {
 	unsigned int os_reg[8];
 	unsigned int reserved9[(0x604 - 0x5e4) / 4 - 1];
 	unsigned int ddrc_stat;
+	unsigned int reserved10[(0x680 - 0x604) / 4 - 1];
+	unsigned int sig_detect_con[2];
+	unsigned int reserved11[(0x690 - 0x684) / 4 - 1];
+	unsigned int sig_detect_status[2];
+	unsigned int reserved12[(0x6a0 - 0x694) / 4 - 1];
+	unsigned int sig_detect_clr[2];
+	unsigned int reserved13[(0x6b0 - 0x6a4) / 4 - 1];
+	unsigned int emmc_det;
+	unsigned int reserved14[(0x700 - 0x6b0) / 4 - 1];
+	unsigned int host0_con[3];
+	unsigned int reserved15;
+	unsigned int host1_con[3];
+	unsigned int reserved16;
+	unsigned int host2_con[3];
+	unsigned int reserved17[(0x760 - 0x728) / 4 - 1];
+	unsigned int usbphy0_con[27];
+	unsigned int reserved18[(0x800 - 0x7c8) / 4 - 1];
+	unsigned int usbphy1_con[27];
+	unsigned int reserved19[(0x880 - 0x868) / 4 - 1];
+	unsigned int otg_con0;
+	unsigned int uoc_status0;
+	unsigned int reserved20[(0x900 - 0x884) / 4 - 1];
+	unsigned int mac_con[2];
+	unsigned int reserved21[(0xb00 - 0x904) / 4 - 1];
+	unsigned int macphy_con[4];
+	unsigned int macphy_status;
 };
 check_member(rk322x_grf, ddrc_stat, 0x604);
 
@@ -62,458 +88,9 @@ struct rk322x_sgrf {
 	unsigned int busdmac_con[4];
 };
 
-/* GRF_GPIO0A_IOMUX */
+/* GRF_MACPHY_CON0 */
 enum {
-	GPIO0A7_SHIFT		= 14,
-	GPIO0A7_MASK		= 3 << GPIO0A7_SHIFT,
-	GPIO0A7_GPIO		= 0,
-	GPIO0A7_I2C3_SDA,
-	GPIO0A7_HDMI_DDCSDA,
-
-	GPIO0A6_SHIFT		= 12,
-	GPIO0A6_MASK		= 3 << GPIO0A6_SHIFT,
-	GPIO0A6_GPIO		= 0,
-	GPIO0A6_I2C3_SCL,
-	GPIO0A6_HDMI_DDCSCL,
-
-	GPIO0A3_SHIFT		= 6,
-	GPIO0A3_MASK		= 3 << GPIO0A3_SHIFT,
-	GPIO0A3_GPIO		= 0,
-	GPIO0A3_I2C1_SDA,
-	GPIO0A3_SDIO_CMD,
-
-	GPIO0A2_SHIFT		= 4,
-	GPIO0A2_MASK		= 3 << GPIO0A2_SHIFT,
-	GPIO0A2_GPIO		= 0,
-	GPIO0A2_I2C1_SCL,
-
-	GPIO0A1_SHIFT		= 2,
-	GPIO0A1_MASK		= 3 << GPIO0A1_SHIFT,
-	GPIO0A1_GPIO		= 0,
-	GPIO0A1_I2C0_SDA,
-
-	GPIO0A0_SHIFT		= 0,
-	GPIO0A0_MASK		= 3 << GPIO0A0_SHIFT,
-	GPIO0A0_GPIO		= 0,
-	GPIO0A0_I2C0_SCL,
-};
-
-/* GRF_GPIO0B_IOMUX */
-enum {
-	GPIO0B7_SHIFT		= 14,
-	GPIO0B7_MASK		= 3 << GPIO0B7_SHIFT,
-	GPIO0B7_GPIO		= 0,
-	GPIO0B7_HDMI_HDP,
-
-	GPIO0B6_SHIFT		= 12,
-	GPIO0B6_MASK		= 3 << GPIO0B6_SHIFT,
-	GPIO0B6_GPIO		= 0,
-	GPIO0B6_I2S_SDI,
-	GPIO0B6_SPI_CSN0,
-
-	GPIO0B5_SHIFT		= 10,
-	GPIO0B5_MASK		= 3 << GPIO0B5_SHIFT,
-	GPIO0B5_GPIO		= 0,
-	GPIO0B5_I2S_SDO,
-	GPIO0B5_SPI_RXD,
-
-	GPIO0B3_SHIFT		= 6,
-	GPIO0B3_MASK		= 3 << GPIO0B3_SHIFT,
-	GPIO0B3_GPIO		= 0,
-	GPIO0B3_I2S1_LRCKRX,
-	GPIO0B3_SPI_TXD,
-
-	GPIO0B1_SHIFT		= 2,
-	GPIO0B1_MASK		= 3 << GPIO0B1_SHIFT,
-	GPIO0B1_GPIO		= 0,
-	GPIO0B1_I2S_SCLK,
-	GPIO0B1_SPI_CLK,
-
-	GPIO0B0_SHIFT		= 0,
-	GPIO0B0_MASK		= 3,
-	GPIO0B0_GPIO		= 0,
-	GPIO0B0_I2S_MCLK,
-};
-
-/* GRF_GPIO0C_IOMUX */
-enum {
-	GPIO0C4_SHIFT		= 8,
-	GPIO0C4_MASK		= 3 << GPIO0C4_SHIFT,
-	GPIO0C4_GPIO		= 0,
-	GPIO0C4_HDMI_CECSDA,
-
-	GPIO0C1_SHIFT		= 2,
-	GPIO0C1_MASK		= 3 << GPIO0C1_SHIFT,
-	GPIO0C1_GPIO		= 0,
-	GPIO0C1_UART0_RSTN,
-	GPIO0C1_CLK_OUT1,
-};
-
-/* GRF_GPIO0D_IOMUX */
-enum {
-	GPIO0D6_SHIFT		= 12,
-	GPIO0D6_MASK		= 3 << GPIO0D6_SHIFT,
-	GPIO0D6_GPIO		= 0,
-	GPIO0D6_SDIO_PWREN,
-	GPIO0D6_PWM11,
-
-
-	GPIO0D4_SHIFT		= 8,
-	GPIO0D4_MASK		= 3 << GPIO0D4_SHIFT,
-	GPIO0D4_GPIO		= 0,
-	GPIO0D4_PWM2,
-
-	GPIO0D3_SHIFT		= 6,
-	GPIO0D3_MASK		= 3 << GPIO0D3_SHIFT,
-	GPIO0D3_GPIO		= 0,
-	GPIO0D3_PWM1,
-
-	GPIO0D2_SHIFT		= 4,
-	GPIO0D2_MASK		= 3 << GPIO0D2_SHIFT,
-	GPIO0D2_GPIO		= 0,
-	GPIO0D2_PWM0,
-};
-
-/* GRF_GPIO1A_IOMUX */
-enum {
-	GPIO1A7_SHIFT		= 14,
-	GPIO1A7_MASK		= 1,
-	GPIO1A7_GPIO		= 0,
-	GPIO1A7_SDMMC_WRPRT,
-};
-
-/* GRF_GPIO1B_IOMUX */
-enum {
-	GPIO1B7_SHIFT		= 14,
-	GPIO1B7_MASK		= 3 << GPIO1B7_SHIFT,
-	GPIO1B7_GPIO		= 0,
-	GPIO1B7_SDMMC_CMD,
-
-	GPIO1B6_SHIFT		= 12,
-	GPIO1B6_MASK		= 3 << GPIO1B6_SHIFT,
-	GPIO1B6_GPIO		= 0,
-	GPIO1B6_SDMMC_PWREN,
-
-	GPIO1B4_SHIFT		= 8,
-	GPIO1B4_MASK		= 3 << GPIO1B4_SHIFT,
-	GPIO1B4_GPIO		= 0,
-	GPIO1B4_SPI_CSN1,
-	GPIO1B4_PWM12,
-
-	GPIO1B3_SHIFT		= 6,
-	GPIO1B3_MASK		= 3 << GPIO1B3_SHIFT,
-	GPIO1B3_GPIO		= 0,
-	GPIO1B3_UART1_RSTN,
-	GPIO1B3_PWM13,
-
-	GPIO1B2_SHIFT		= 4,
-	GPIO1B2_MASK		= 3 << GPIO1B2_SHIFT,
-	GPIO1B2_GPIO		= 0,
-	GPIO1B2_UART1_SIN,
-	GPIO1B2_UART21_SIN,
-
-	GPIO1B1_SHIFT		= 2,
-	GPIO1B1_MASK		= 3 << GPIO1B1_SHIFT,
-	GPIO1B1_GPIO		= 0,
-	GPIO1B1_UART1_SOUT,
-	GPIO1B1_UART21_SOUT,
-};
-
-/* GRF_GPIO1C_IOMUX */
-enum {
-	GPIO1C7_SHIFT		= 14,
-	GPIO1C7_MASK		= 3 << GPIO1C7_SHIFT,
-	GPIO1C7_GPIO		= 0,
-	GPIO1C7_NAND_CS3,
-	GPIO1C7_EMMC_RSTNOUT,
-
-	GPIO1C6_SHIFT		= 12,
-	GPIO1C6_MASK		= 3 << GPIO1C6_SHIFT,
-	GPIO1C6_GPIO		= 0,
-	GPIO1C6_NAND_CS2,
-	GPIO1C6_EMMC_CMD,
-
-
-	GPIO1C5_SHIFT		= 10,
-	GPIO1C5_MASK		= 3 << GPIO1C5_SHIFT,
-	GPIO1C5_GPIO		= 0,
-	GPIO1C5_SDMMC_D3,
-	GPIO1C5_JTAG_TMS,
-
-	GPIO1C4_SHIFT		= 8,
-	GPIO1C4_MASK		= 3 << GPIO1C4_SHIFT,
-	GPIO1C4_GPIO		= 0,
-	GPIO1C4_SDMMC_D2,
-	GPIO1C4_JTAG_TCK,
-
-	GPIO1C3_SHIFT		= 6,
-	GPIO1C3_MASK		= 3 << GPIO1C3_SHIFT,
-	GPIO1C3_GPIO		= 0,
-	GPIO1C3_SDMMC_D1,
-	GPIO1C3_UART2_SIN,
-
-	GPIO1C2_SHIFT		= 4,
-	GPIO1C2_MASK		= 3 << GPIO1C2_SHIFT ,
-	GPIO1C2_GPIO		= 0,
-	GPIO1C2_SDMMC_D0,
-	GPIO1C2_UART2_SOUT,
-
-	GPIO1C1_SHIFT		= 2,
-	GPIO1C1_MASK		= 3 << GPIO1C1_SHIFT,
-	GPIO1C1_GPIO		= 0,
-	GPIO1C1_SDMMC_DETN,
-
-	GPIO1C0_SHIFT		= 0,
-	GPIO1C0_MASK		= 3 << GPIO1C0_SHIFT,
-	GPIO1C0_GPIO		= 0,
-	GPIO1C0_SDMMC_CLKOUT,
-};
-
-/* GRF_GPIO1D_IOMUX */
-enum {
-	GPIO1D7_SHIFT		= 14,
-	GPIO1D7_MASK		= 3 << GPIO1D7_SHIFT,
-	GPIO1D7_GPIO		= 0,
-	GPIO1D7_NAND_D7,
-	GPIO1D7_EMMC_D7,
-
-	GPIO1D6_SHIFT		= 12,
-	GPIO1D6_MASK		= 3 << GPIO1D6_SHIFT,
-	GPIO1D6_GPIO		= 0,
-	GPIO1D6_NAND_D6,
-	GPIO1D6_EMMC_D6,
-
-	GPIO1D5_SHIFT		= 10,
-	GPIO1D5_MASK		= 3 << GPIO1D5_SHIFT,
-	GPIO1D5_GPIO		= 0,
-	GPIO1D5_NAND_D5,
-	GPIO1D5_EMMC_D5,
-
-	GPIO1D4_SHIFT		= 8,
-	GPIO1D4_MASK		= 3 << GPIO1D4_SHIFT,
-	GPIO1D4_GPIO		= 0,
-	GPIO1D4_NAND_D4,
-	GPIO1D4_EMMC_D4,
-
-	GPIO1D3_SHIFT		= 6,
-	GPIO1D3_MASK		= 3 << GPIO1D3_SHIFT,
-	GPIO1D3_GPIO		= 0,
-	GPIO1D3_NAND_D3,
-	GPIO1D3_EMMC_D3,
-
-	GPIO1D2_SHIFT		= 4,
-	GPIO1D2_MASK		= 3 << GPIO1D2_SHIFT,
-	GPIO1D2_GPIO		= 0,
-	GPIO1D2_NAND_D2,
-	GPIO1D2_EMMC_D2,
-
-	GPIO1D1_SHIFT		= 2,
-	GPIO1D1_MASK		= 3 << GPIO1D1_SHIFT,
-	GPIO1D1_GPIO		= 0,
-	GPIO1D1_NAND_D1,
-	GPIO1D1_EMMC_D1,
-
-	GPIO1D0_SHIFT		= 0,
-	GPIO1D0_MASK		= 3 << GPIO1D0_SHIFT,
-	GPIO1D0_GPIO		= 0,
-	GPIO1D0_NAND_D0,
-	GPIO1D0_EMMC_D0,
-};
-
-/* GRF_GPIO2A_IOMUX */
-enum {
-	GPIO2A7_SHIFT		= 14,
-	GPIO2A7_MASK		= 3 << GPIO2A7_SHIFT,
-	GPIO2A7_GPIO		= 0,
-	GPIO2A7_NAND_DQS,
-	GPIO2A7_EMMC_CLKOUT,
-
-	GPIO2A5_SHIFT		= 10,
-	GPIO2A5_MASK		= 3 << GPIO2A5_SHIFT,
-	GPIO2A5_GPIO		= 0,
-	GPIO2A5_NAND_WP,
-	GPIO2A5_EMMC_PWREN,
-
-	GPIO2A4_SHIFT		= 8,
-	GPIO2A4_MASK		= 3 << GPIO2A4_SHIFT,
-	GPIO2A4_GPIO		= 0,
-	GPIO2A4_NAND_RDY,
-	GPIO2A4_EMMC_CMD,
-
-	GPIO2A3_SHIFT		= 6,
-	GPIO2A3_MASK		= 3 << GPIO2A3_SHIFT,
-	GPIO2A3_GPIO		= 0,
-	GPIO2A3_NAND_RDN,
-	GPIO2A4_SPI1_CSN1,
-
-	GPIO2A2_SHIFT		= 4,
-	GPIO2A2_MASK		= 3 << GPIO2A2_SHIFT,
-	GPIO2A2_GPIO		= 0,
-	GPIO2A2_NAND_WRN,
-	GPIO2A4_SPI1_CSN0,
-
-	GPIO2A1_SHIFT		= 2,
-	GPIO2A1_MASK		= 3 << GPIO2A1_SHIFT,
-	GPIO2A1_GPIO		= 0,
-	GPIO2A1_NAND_CLE,
-	GPIO2A1_SPI1_TXD,
-
-	GPIO2A0_SHIFT		= 0,
-	GPIO2A0_MASK		= 3 << GPIO2A0_SHIFT,
-	GPIO2A0_GPIO		= 0,
-	GPIO2A0_NAND_ALE,
-	GPIO2A0_SPI1_RXD,
-};
-
-/* GRF_GPIO2B_IOMUX */
-enum {
-	GPIO2B7_SHIFT		= 14,
-	GPIO2B7_MASK		= 3 << GPIO2B7_SHIFT,
-	GPIO2B7_GPIO		= 0,
-	GPIO2B7_GMAC_RXER,
-
-	GPIO2B6_SHIFT		= 12,
-	GPIO2B6_MASK		= 3 << GPIO2B6_SHIFT,
-	GPIO2B6_GPIO		= 0,
-	GPIO2B6_GMAC_CLK,
-	GPIO2B6_MAC_LINK,
-
-	GPIO2B5_SHIFT		= 10,
-	GPIO2B5_MASK		= 3 << GPIO2B5_SHIFT,
-	GPIO2B5_GPIO		= 0,
-	GPIO2B5_GMAC_TXEN,
-
-	GPIO2B4_SHIFT		= 8,
-	GPIO2B4_MASK		= 3 << GPIO2B4_SHIFT,
-	GPIO2B4_GPIO		= 0,
-	GPIO2B4_GMAC_MDIO,
-
-	GPIO2B3_SHIFT		= 6,
-	GPIO2B3_MASK		= 3 << GPIO2B3_SHIFT,
-	GPIO2B3_GPIO		= 0,
-	GPIO2B3_GMAC_RXCLK,
-
-	GPIO2B2_SHIFT		= 4,
-	GPIO2B2_MASK		= 3 << GPIO2B2_SHIFT,
-	GPIO2B2_GPIO		= 0,
-	GPIO2B2_GMAC_CRS,
-
-	GPIO2B1_SHIFT		= 2,
-	GPIO2B1_MASK		= 3 << GPIO2B1_SHIFT,
-	GPIO2B1_GPIO		= 0,
-	GPIO2B1_GMAC_TXCLK,
-
-
-	GPIO2B0_SHIFT		= 0,
-	GPIO2B0_MASK		= 3 << GPIO2B0_SHIFT,
-	GPIO2B0_GPIO		= 0,
-	GPIO2B0_GMAC_RXDV,
-	GPIO2B0_MAC_SPEED_IOUT,
-};
-
-/* GRF_GPIO2C_IOMUX */
-enum {
-	GPIO2C7_SHIFT		= 14,
-	GPIO2C7_MASK		= 3 << GPIO2C7_SHIFT,
-	GPIO2C7_GPIO		= 0,
-	GPIO2C7_GMAC_TXD3,
-
-	GPIO2C6_SHIFT		= 12,
-	GPIO2C6_MASK		= 3 << GPIO2C6_SHIFT,
-	GPIO2C6_GPIO		= 0,
-	GPIO2C6_GMAC_TXD2,
-
-	GPIO2C5_SHIFT		= 10,
-	GPIO2C5_MASK		= 3 << GPIO2C5_SHIFT,
-	GPIO2C5_GPIO		= 0,
-	GPIO2C5_I2C2_SCL,
-	GPIO2C5_GMAC_RXD2,
-
-	GPIO2C4_SHIFT		= 8,
-	GPIO2C4_MASK		= 3 << GPIO2C4_SHIFT,
-	GPIO2C4_GPIO		= 0,
-	GPIO2C4_I2C2_SDA,
-	GPIO2C4_GMAC_RXD3,
-
-	GPIO2C3_SHIFT		= 6,
-	GPIO2C3_MASK		= 3 << GPIO2C3_SHIFT,
-	GPIO2C3_GPIO		= 0,
-	GPIO2C3_GMAC_TXD0,
-
-	GPIO2C2_SHIFT		= 4,
-	GPIO2C2_MASK		= 3 << GPIO2C2_SHIFT,
-	GPIO2C2_GPIO		= 0,
-	GPIO2C2_GMAC_TXD1,
-
-	GPIO2C1_SHIFT		= 2,
-	GPIO2C1_MASK		= 3 << GPIO2C1_SHIFT,
-	GPIO2C1_GPIO		= 0,
-	GPIO2C1_GMAC_RXD0,
-
-	GPIO2C0_SHIFT		= 0,
-	GPIO2C0_MASK		= 3 << GPIO2C0_SHIFT,
-	GPIO2C0_GPIO		= 0,
-	GPIO2C0_GMAC_RXD1,
-};
-
-/* GRF_GPIO2D_IOMUX */
-enum {
-	GPIO2D1_SHIFT		= 2,
-	GPIO2D1_MASK		= 3 << GPIO2D1_SHIFT,
-	GPIO2D1_GPIO		= 0,
-	GPIO2D1_GMAC_MDC,
-
-	GPIO2D0_SHIFT		= 0,
-	GPIO2D0_MASK		= 3,
-	GPIO2D0_GPIO		= 0,
-	GPIO2D0_GMAC_COL,
-};
-
-/* GRF_GPIO3C_IOMUX */
-enum {
-	GPIO3C6_SHIFT		= 12,
-	GPIO3C6_MASK		= 3 << GPIO3C6_SHIFT,
-	GPIO3C6_GPIO		= 0,
-	GPIO3C6_DRV_VBUS1,
-
-	GPIO3C5_SHIFT		= 10,
-	GPIO3C5_MASK		= 3 << GPIO3C5_SHIFT,
-	GPIO3C5_GPIO		= 0,
-	GPIO3C5_PWM10,
-
-	GPIO3C1_SHIFT		= 2,
-	GPIO3C1_MASK		= 3 << GPIO3C1_SHIFT,
-	GPIO3C1_GPIO		= 0,
-	GPIO3C1_DRV_VBUS,
-};
-
-/* GRF_GPIO3D_IOMUX */
-enum {
-	GPIO3D2_SHIFT	= 4,
-	GPIO3D2_MASK	= 3 << GPIO3D2_SHIFT,
-	GPIO3D2_GPIO	= 0,
-	GPIO3D2_PWM3,
-};
-
-/* GRF_CON_IOMUX */
-enum {
-	CON_IOMUX_GMAC_SHIFT		= 15,
-	CON_IOMUX_GMAC_MASK	= 1 << CON_IOMUX_GMAC_SHIFT,
-	CON_IOMUX_UART1SEL_SHIFT	= 11,
-	CON_IOMUX_UART1SEL_MASK	= 1 << CON_IOMUX_UART1SEL_SHIFT,
-	CON_IOMUX_UART2SEL_SHIFT	= 8,
-	CON_IOMUX_UART2SEL_MASK	= 1 << CON_IOMUX_UART2SEL_SHIFT,
-	CON_IOMUX_UART2SEL_2	= 0,
-	CON_IOMUX_UART2SEL_21,
-	CON_IOMUX_EMMCSEL_SHIFT	= 7,
-	CON_IOMUX_EMMCSEL_MASK	= 1 << CON_IOMUX_EMMCSEL_SHIFT,
-	CON_IOMUX_PWM3SEL_SHIFT	= 3,
-	CON_IOMUX_PWM3SEL_MASK	= 1 << CON_IOMUX_PWM3SEL_SHIFT,
-	CON_IOMUX_PWM2SEL_SHIFT	= 2,
-	CON_IOMUX_PWM2SEL_MASK	= 1 << CON_IOMUX_PWM2SEL_SHIFT,
-	CON_IOMUX_PWM1SEL_SHIFT	= 1,
-	CON_IOMUX_PWM1SEL_MASK	= 1 << CON_IOMUX_PWM1SEL_SHIFT,
-	CON_IOMUX_PWM0SEL_SHIFT	= 0,
-	CON_IOMUX_PWM0SEL_MASK	= 1 << CON_IOMUX_PWM0SEL_SHIFT,
+	MACPHY_CFG_ENABLE_SHIFT = 0,
+	MACPHY_CFG_ENABLE_MASK  = 1 << MACPHY_CFG_ENABLE_SHIFT,
 };
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/grf_rk3328.h b/arch/arm/include/asm/arch-rockchip/grf_rk3328.h
index f0a0781d8d..0c37f2ad18 100644
--- a/arch/arm/include/asm/arch-rockchip/grf_rk3328.h
+++ b/arch/arm/include/asm/arch-rockchip/grf_rk3328.h
@@ -131,118 +131,5 @@ struct rk3328_sgrf_regs {
 };
 check_member(rk3328_sgrf_regs, hdcp_key_access_mask, 0x2a0);
 
-enum {
-	/* GPIO0A_IOMUX */
-	GPIO0A5_SEL_SHIFT	= 10,
-	GPIO0A5_SEL_MASK	= 3 << GPIO0A5_SEL_SHIFT,
-	GPIO0A5_I2C3_SCL	= 2,
-
-	GPIO0A6_SEL_SHIFT	= 12,
-	GPIO0A6_SEL_MASK	= 3 << GPIO0A6_SEL_SHIFT,
-	GPIO0A6_I2C3_SDA	= 2,
-
-	GPIO0A7_SEL_SHIFT	= 14,
-	GPIO0A7_SEL_MASK	= 3 << GPIO0A7_SEL_SHIFT,
-	GPIO0A7_EMMC_DATA0	= 2,
-
-	/* GPIO0D_IOMUX*/
-	GPIO0D6_SEL_SHIFT	= 12,
-	GPIO0D6_SEL_MASK	= 3 << GPIO0D6_SEL_SHIFT,
-	GPIO0D6_GPIO		= 0,
-	GPIO0D6_SDMMC0_PWRENM1	= 3,
-
-	/* GPIO1A_IOMUX */
-	GPIO1A0_SEL_SHIFT	= 0,
-	GPIO1A0_SEL_MASK	= 0x3fff << GPIO1A0_SEL_SHIFT,
-	GPIO1A0_CARD_DATA_CLK_CMD_DETN	= 0x1555,
-
-	/* GPIO2A_IOMUX */
-	GPIO2A0_SEL_SHIFT	= 0,
-	GPIO2A0_SEL_MASK	= 3 << GPIO2A0_SEL_SHIFT,
-	GPIO2A0_UART2_TX_M1	= 1,
-
-	GPIO2A1_SEL_SHIFT	= 2,
-	GPIO2A1_SEL_MASK	= 3 << GPIO2A1_SEL_SHIFT,
-	GPIO2A1_UART2_RX_M1	= 1,
-
-	GPIO2A2_SEL_SHIFT	= 4,
-	GPIO2A2_SEL_MASK	= 3 << GPIO2A2_SEL_SHIFT,
-	GPIO2A2_PWM_IR		= 1,
-
-	GPIO2A4_SEL_SHIFT	= 8,
-	GPIO2A4_SEL_MASK	= 3 << GPIO2A4_SEL_SHIFT,
-	GPIO2A4_PWM_0		= 1,
-	GPIO2A4_I2C1_SDA,
-
-	GPIO2A5_SEL_SHIFT	= 10,
-	GPIO2A5_SEL_MASK	= 3 << GPIO2A5_SEL_SHIFT,
-	GPIO2A5_PWM_1		= 1,
-	GPIO2A5_I2C1_SCL,
-
-	GPIO2A6_SEL_SHIFT	= 12,
-	GPIO2A6_SEL_MASK	= 3 << GPIO2A6_SEL_SHIFT,
-	GPIO2A6_PWM_2		= 1,
-
-	GPIO2A7_SEL_SHIFT	= 14,
-	GPIO2A7_SEL_MASK	= 3 << GPIO2A7_SEL_SHIFT,
-	GPIO2A7_GPIO		= 0,
-	GPIO2A7_SDMMC0_PWRENM0,
-
-	/* GPIO2BL_IOMUX */
-	GPIO2BL0_SEL_SHIFT	= 0,
-	GPIO2BL0_SEL_MASK	= 0x3f << GPIO2BL0_SEL_SHIFT,
-	GPIO2BL0_SPI_CLK_TX_RX_M0	= 0x15,
-
-	GPIO2BL3_SEL_SHIFT	= 6,
-	GPIO2BL3_SEL_MASK	= 3 << GPIO2BL3_SEL_SHIFT,
-	GPIO2BL3_SPI_CSN0_M0	= 1,
-
-	GPIO2BL4_SEL_SHIFT	= 8,
-	GPIO2BL4_SEL_MASK	= 3 << GPIO2BL4_SEL_SHIFT,
-	GPIO2BL4_SPI_CSN1_M0	= 1,
-
-	GPIO2BL5_SEL_SHIFT	= 10,
-	GPIO2BL5_SEL_MASK	= 3 << GPIO2BL5_SEL_SHIFT,
-	GPIO2BL5_I2C2_SDA	= 1,
-
-	GPIO2BL6_SEL_SHIFT	= 12,
-	GPIO2BL6_SEL_MASK	= 3 << GPIO2BL6_SEL_SHIFT,
-	GPIO2BL6_I2C2_SCL	= 1,
-
-	/* GPIO2D_IOMUX */
-	GPIO2D0_SEL_SHIFT	= 0,
-	GPIO2D0_SEL_MASK	= 3 << GPIO2D0_SEL_SHIFT,
-	GPIO2D0_I2C0_SCL	= 1,
-
-	GPIO2D1_SEL_SHIFT	= 2,
-	GPIO2D1_SEL_MASK	= 3 << GPIO2D1_SEL_SHIFT,
-	GPIO2D1_I2C0_SDA	= 1,
-
-	GPIO2D4_SEL_SHIFT	= 8,
-	GPIO2D4_SEL_MASK	= 0xff << GPIO2D4_SEL_SHIFT,
-	GPIO2D4_EMMC_DATA1234	= 0xaa,
-
-	/* GPIO3C_IOMUX */
-	GPIO3C0_SEL_SHIFT	= 0,
-	GPIO3C0_SEL_MASK	= 0x3fff << GPIO3C0_SEL_SHIFT,
-	GPIO3C0_EMMC_DATA567_PWR_CLK_RSTN_CMD	= 0x2aaa,
-
-	/* COM_IOMUX */
-	IOMUX_SEL_UART2_SHIFT	= 0,
-	IOMUX_SEL_UART2_MASK	= 3 << IOMUX_SEL_UART2_SHIFT,
-	IOMUX_SEL_UART2_M0	= 0,
-	IOMUX_SEL_UART2_M1,
-
-	IOMUX_SEL_SPI_SHIFT	= 4,
-	IOMUX_SEL_SPI_MASK	= 3 << IOMUX_SEL_SPI_SHIFT,
-	IOMUX_SEL_SPI_M0	= 0,
-	IOMUX_SEL_SPI_M1,
-	IOMUX_SEL_SPI_M2,
-
-	IOMUX_SEL_SDMMC_SHIFT	= 7,
-	IOMUX_SEL_SDMMC_MASK	= 1 << IOMUX_SEL_SDMMC_SHIFT,
-	IOMUX_SEL_SDMMC_M0	= 0,
-	IOMUX_SEL_SDMMC_M1,
-};
 
 #endif	/* __SOC_ROCKCHIP_RK3328_GRF_H__ */
diff --git a/arch/arm/include/asm/arch-rockchip/grf_rk3399.h b/arch/arm/include/asm/arch-rockchip/grf_rk3399.h
index 8d21eb7bee..c29e2379d9 100644
--- a/arch/arm/include/asm/arch-rockchip/grf_rk3399.h
+++ b/arch/arm/include/asm/arch-rockchip/grf_rk3399.h
@@ -527,6 +527,8 @@ enum {
 	/* GRF_SOC_CON7 */
 	GRF_UART_DBG_SEL_SHIFT  = 10,
 	GRF_UART_DBG_SEL_MASK   = 3 << GRF_UART_DBG_SEL_SHIFT,
+	GRF_UART_DBG_SEL_A	= 0,
+	GRF_UART_DBG_SEL_B	= 1,
 	GRF_UART_DBG_SEL_C      = 2,
 
 	/* GRF_SOC_CON20 */
@@ -589,7 +591,12 @@ enum {
 	PMUGRF_GPIO1C3_SEL_SHIFT        = 6,
 	PMUGRF_GPIO1C3_SEL_MASK = 3 << PMUGRF_GPIO1C3_SEL_SHIFT,
 	PMUGRF_PWM_2            = 1,
-
+	PMUGRF_GPIO1C4_SEL_SHIFT = 8,
+	PMUGRF_GPIO1C4_SEL_MASK = 3 << PMUGRF_GPIO1C4_SEL_SHIFT,
+	PMUGRF_I2C8PMU_SDA = 1,
+	PMUGRF_GPIO1C5_SEL_SHIFT = 10,
+	PMUGRF_GPIO1C5_SEL_MASK = 3 << PMUGRF_GPIO1C5_SEL_SHIFT,
+	PMUGRF_I2C8PMU_SCL = 1,
 };
 
 /* GRF_SOC_CON5 */
diff --git a/arch/arm/include/asm/arch-rockchip/grf_rv1108.h b/arch/arm/include/asm/arch-rockchip/grf_rv1108.h
index c816a5bf8f..999d679ced 100644
--- a/arch/arm/include/asm/arch-rockchip/grf_rv1108.h
+++ b/arch/arm/include/asm/arch-rockchip/grf_rv1108.h
@@ -1,8 +1,9 @@
 /*
- * (C) Copyright 2016 Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:     GPL-2.0+
+ * Copyright (C) 2018 Rockchip Electronics Co., Ltd
+ * Author: Zhihuan He <huan.he@rock-chips.com>
+ * SPDX-License-Identifier:	GPL-2.0+
  */
+
 #ifndef _ASM_ARCH_GRF_RV1108_H
 #define _ASM_ARCH_GRF_RV1108_H
 
@@ -100,410 +101,68 @@ struct rv1108_grf {
 	u32 reserved14[2];
 	u32 dma_con0;
 	u32 dma_con1;
-	u32 reserved15[539];
+	u32 reserved15[59];
 	u32 uoc_status;
+	u32 reserved16[2];
 	u32 host_status;
+	u32 reserved17[59];
 	u32 gmac_con0;
+	u32 reserved18[191];
 	u32 chip_id;
 };
-check_member(rv1108_grf, chip_id, 0xf90);
-
-/* GRF_GPIO1B_IOMUX */
-enum {
-	GPIO1B7_SHIFT		= 14,
-	GPIO1B7_MASK		= 3 << GPIO1B7_SHIFT,
-	GPIO1B7_GPIO		= 0,
-	GPIO1B7_LCDC_D12,
-	GPIO1B7_I2S_SDIO2_M0,
-	GPIO1B7_GMAC_RXDV,
-
-	GPIO1B6_SHIFT		= 12,
-	GPIO1B6_MASK		= 3 << GPIO1B6_SHIFT,
-	GPIO1B6_GPIO		= 0,
-	GPIO1B6_LCDC_D13,
-	GPIO1B6_I2S_LRCLKTX_M0,
-	GPIO1B6_GMAC_RXD1,
-
-	GPIO1B5_SHIFT		= 10,
-	GPIO1B5_MASK		= 3 << GPIO1B5_SHIFT,
-	GPIO1B5_GPIO		= 0,
-	GPIO1B5_LCDC_D14,
-	GPIO1B5_I2S_SDIO1_M0,
-	GPIO1B5_GMAC_RXD0,
 
-	GPIO1B4_SHIFT		= 8,
-	GPIO1B4_MASK		= 3 << GPIO1B4_SHIFT,
-	GPIO1B4_GPIO		= 0,
-	GPIO1B4_LCDC_D15,
-	GPIO1B4_I2S_MCLK_M0,
-	GPIO1B4_GMAC_TXEN,
-
-	GPIO1B3_SHIFT		= 6,
-	GPIO1B3_MASK		= 3 << GPIO1B3_SHIFT,
-	GPIO1B3_GPIO		= 0,
-	GPIO1B3_LCDC_D16,
-	GPIO1B3_I2S_SCLK_M0,
-	GPIO1B3_GMAC_TXD1,
-
-	GPIO1B2_SHIFT		= 4,
-	GPIO1B2_MASK		= 3 << GPIO1B2_SHIFT,
-	GPIO1B2_GPIO		= 0,
-	GPIO1B2_LCDC_D17,
-	GPIO1B2_I2S_SDIO_M0,
-	GPIO1B2_GMAC_TXD0,
-
-	GPIO1B1_SHIFT		= 2,
-	GPIO1B1_MASK		= 3 << GPIO1B1_SHIFT,
-	GPIO1B1_GPIO		= 0,
-	GPIO1B1_LCDC_D9,
-	GPIO1B1_PWM7,
-
-	GPIO1B0_SHIFT		= 0,
-	GPIO1B0_MASK		= 3,
-	GPIO1B0_GPIO		= 0,
-	GPIO1B0_LCDC_D8,
-	GPIO1B0_PWM6,
+check_member(rv1108_grf, chip_id, 0x0c00);
+
+struct rv1108_pmu_grf {
+	u32 gpioa_iomux;
+	u32 gpiob_iomux;
+	u32 gpioc_iomux;
+	u32 reserved1;
+	u32 gpioa_p;
+	u32 gpiob_p;
+	u32 gpioc_p;
+	u32 reserved2;
+	u32 gpioa_e;
+	u32 gpiob_e;
+	u32 gpioc_e;
+	u32 reserved3;
+	u32 gpioa_smt;
+	u32 gpiob_smt;
+	u32 gpioc_smt;
+	u32 reserved4;
+	u32 gpio0a_sr;
+	u32 gpio0b_sr;
+	u32 gpio0c_sr;
+	u32 reserved5[(0x100-0x4c)/4];
+	u32 soc_con[4];
+	u32 reserved6[(0x180-0x110)/4];
+	u32 dll_con[2];
+	u32 reserved7[2];
+	u32 dll_status[2];
+	u32 reserved8[(0x200-0x198)/4];
+	u32 os_reg[4];
+	u32 reserved9[(0x300-0x210)/4];
+	u32 fast_boot_addr;
+	u32 reserved10[(0x380-0x304)/4];
+	u32 a7_jtag_mask;
+	u32 reserved11[(0x388-0x384)/4];
+	u32 ceva_jtag_mask;
 };
+check_member(rv1108_pmu_grf, ceva_jtag_mask, 0x388);
 
-/* GRF_GPIO1C_IOMUX */
 enum {
-	GPIO1C7_SHIFT		= 14,
-	GPIO1C7_MASK		= 3 << GPIO1C7_SHIFT,
-	GPIO1C7_GPIO		= 0,
-	GPIO1C7_CIF_D5,
-	GPIO1C7_I2S_SDIO2_M1,
-
-	GPIO1C6_SHIFT		= 12,
-	GPIO1C6_MASK		= 3 << GPIO1C6_SHIFT,
-	GPIO1C6_GPIO		= 0,
-	GPIO1C6_CIF_D4,
-	GPIO1C6_I2S_LRCLKTX_M1,
-
-	GPIO1C5_SHIFT		= 10,
-	GPIO1C5_MASK		= 3 << GPIO1C5_SHIFT,
-	GPIO1C5_GPIO		= 0,
-	GPIO1C5_LCDC_CLK,
-	GPIO1C5_GMAC_CLK,
-
-	GPIO1C4_SHIFT		= 8,
-	GPIO1C4_MASK		= 3 << GPIO1C4_SHIFT,
-	GPIO1C4_GPIO		= 0,
-	GPIO1C4_LCDC_HSYNC,
-	GPIO1C4_GMAC_MDC,
-
-	GPIO1C3_SHIFT		= 6,
-	GPIO1C3_MASK		= 3 << GPIO1C3_SHIFT,
-	GPIO1C3_GPIO		= 0,
-	GPIO1C3_LCDC_VSYNC,
-	GPIO1C3_GMAC_MDIO,
-
-	GPIO1C2_SHIFT		= 4,
-	GPIO1C2_MASK		= 3 << GPIO1C2_SHIFT,
-	GPIO1C2_GPIO		= 0,
-	GPIO1C2_LCDC_EN,
-	GPIO1C2_I2S_SDIO3_M0,
-	GPIO1C2_GMAC_RXER,
-
-	GPIO1C1_SHIFT		= 2,
-	GPIO1C1_MASK		= 3 << GPIO1C1_SHIFT,
-	GPIO1C1_GPIO		= 0,
-	GPIO1C1_LCDC_D10,
-	GPIO1C1_I2S_SDI_M0,
-	GPIO1C1_PWM4,
-
-	GPIO1C0_SHIFT           = 0,
-	GPIO1C0_MASK		= 3,
-	GPIO1C0_GPIO		= 0,
-	GPIO1C0_LCDC_D11,
-	GPIO1C0_I2S_LRCLKRX_M0,
+	/* GRF_SOC_CON0 */
+	MSCH_MAINDDR3_SHIFT		= 4,
+	MSCH_MAINDDR3			= 1 << MSCH_MAINDDR3_SHIFT,
+	MSCH_MAINPARTIALPOP_SHIFT	= 5,
+	MSCH_MAINPARTIALPOP		= 1 << MSCH_MAINPARTIALPOP_SHIFT,
+	MSCH_MAINPARTIALPOP_MASK	= 1 << MSCH_MAINPARTIALPOP_SHIFT,
 };
 
-/* GRF_GPIO1D_OIMUX */
 enum {
-	GPIO1D7_SHIFT		= 14,
-	GPIO1D7_MASK		= 3 << GPIO1D7_SHIFT,
-	GPIO1D7_GPIO		= 0,
-	GPIO1D7_HDMI_CEC,
-	GPIO1D7_DSP_RTCK,
-
-	GPIO1D6_SHIFT		= 12,
-	GPIO1D6_MASK		= 1 << GPIO1D6_SHIFT,
-	GPIO1D6_GPIO		= 0,
-	GPIO1D6_HDMI_HPD_M0,
-
-	GPIO1D5_SHIFT		= 10,
-	GPIO1D5_MASK		= 3 << GPIO1D5_SHIFT,
-	GPIO1D5_GPIO		= 0,
-	GPIO1D5_UART2_RTSN,
-	GPIO1D5_HDMI_SDA_M0,
-
-	GPIO1D4_SHIFT		= 8,
-	GPIO1D4_MASK		= 3 << GPIO1D4_SHIFT,
-	GPIO1D4_GPIO		= 0,
-	GPIO1D4_UART2_CTSN,
-	GPIO1D4_HDMI_SCL_M0,
-
-	GPIO1D3_SHIFT		= 6,
-	GPIO1D3_MASK		= 3 << GPIO1D3_SHIFT,
-	GPIO1D3_GPIO		= 0,
-	GPIO1D3_UART0_SOUT,
-	GPIO1D3_SPI_TXD_M0,
-
-	GPIO1D2_SHIFT		= 4,
-	GPIO1D2_MASK		= 3 << GPIO1D2_SHIFT,
-	GPIO1D2_GPIO		= 0,
-	GPIO1D2_UART0_SIN,
-	GPIO1D2_SPI_RXD_M0,
-	GPIO1D2_DSP_TDI,
-
-	GPIO1D1_SHIFT		= 2,
-	GPIO1D1_MASK		= 3 << GPIO1D1_SHIFT,
-	GPIO1D1_GPIO		= 0,
-	GPIO1D1_UART0_RTSN,
-	GPIO1D1_SPI_CSN0_M0,
-	GPIO1D1_DSP_TMS,
-
-	GPIO1D0_SHIFT		= 0,
-	GPIO1D0_MASK		= 3,
-	GPIO1D0_GPIO		= 0,
-	GPIO1D0_UART0_CTSN,
-	GPIO1D0_SPI_CLK_M0,
-	GPIO1D0_DSP_TCK,
-};
-
-/* GRF_GPIO2A_IOMUX */
-enum {
-	GPIO2A7_SHIFT		= 14,
-	GPIO2A7_MASK		= 3 << GPIO2A7_SHIFT,
-	GPIO2A7_GPIO		= 0,
-	GPIO2A7_FLASH_D7,
-	GPIO2A7_EMMC_D7,
-
-	GPIO2A6_SHIFT		= 12,
-	GPIO2A6_MASK		= 3 << GPIO2A6_SHIFT,
-	GPIO2A6_GPIO		= 0,
-	GPIO2A6_FLASH_D6,
-	GPIO2A6_EMMC_D6,
-
-	GPIO2A5_SHIFT           = 10,
-	GPIO2A5_MASK            = 3 << GPIO2A5_SHIFT,
-	GPIO2A5_GPIO            = 0,
-	GPIO2A5_FLASH_D5,
-	GPIO2A5_EMMC_D5,
-
-	GPIO2A4_SHIFT           = 8,
-	GPIO2A4_MASK            = 3 << GPIO2A4_SHIFT,
-	GPIO2A4_GPIO            = 0,
-	GPIO2A4_FLASH_D4,
-	GPIO2A4_EMMC_D4,
-
-	GPIO2A3_SHIFT           = 6,
-	GPIO2A3_MASK            = 3 << GPIO2A3_SHIFT,
-	GPIO2A3_GPIO            = 0,
-	GPIO2A3_FLASH_D3,
-	GPIO2A3_EMMC_D3,
-	GPIO2A3_SFC_HOLD_IO3,
-
-	GPIO2A2_SHIFT           = 4,
-	GPIO2A2_MASK            = 3 << GPIO2A2_SHIFT,
-	GPIO2A2_GPIO            = 0,
-	GPIO2A2_FLASH_D2,
-	GPIO2A2_EMMC_D2,
-	GPIO2A2_SFC_WP_IO2,
-
-	GPIO2A1_SHIFT           = 2,
-	GPIO2A1_MASK            = 3 << GPIO2A1_SHIFT,
-	GPIO2A1_GPIO            = 0,
-	GPIO2A1_FLASH_D1,
-	GPIO2A1_EMMC_D1,
-	GPIO2A1_SFC_SO_IO1,
-
-	GPIO2A0_SHIFT           = 0,
-	GPIO2A0_MASK            = 3 << GPIO2A0_SHIFT,
-	GPIO2A0_GPIO            = 0,
-	GPIO2A0_FLASH_D0,
-	GPIO2A0_EMMC_D0,
-	GPIO2A0_SFC_SI_IO0,
-};
-
-/* GRF_GPIO2D_IOMUX */
-enum {
-	GPIO2B7_SHIFT		= 14,
-	GPIO2B7_MASK		= 3 << GPIO2B7_SHIFT,
-	GPIO2B7_GPIO		= 0,
-	GPIO2B7_FLASH_CS1,
-	GPIO2B7_SFC_CLK,
-
-	GPIO2B6_SHIFT           = 12,
-	GPIO2B6_MASK            = 1 << GPIO2B6_SHIFT,
-	GPIO2B6_GPIO            = 0,
-	GPIO2B6_EMMC_CLKO,
-
-	GPIO2B5_SHIFT           = 10,
-	GPIO2B5_MASK            = 1 << GPIO2B5_SHIFT,
-	GPIO2B5_GPIO            = 0,
-	GPIO2B5_FLASH_CS0,
-
-	GPIO2B4_SHIFT           = 8,
-	GPIO2B4_MASK            = 3 << GPIO2B4_SHIFT,
-	GPIO2B4_GPIO            = 0,
-	GPIO2B4_FLASH_RDY,
-	GPIO2B4_EMMC_CMD,
-	GPIO2B4_SFC_CSN0,
-
-	GPIO2B3_SHIFT           = 6,
-	GPIO2B3_MASK            = 1 << GPIO2B3_SHIFT,
-	GPIO2B3_GPIO            = 0,
-	GPIO2B3_FLASH_RDN,
-
-	GPIO2B2_SHIFT           = 4,
-	GPIO2B2_MASK            = 1 << GPIO2B2_SHIFT,
-	GPIO2B2_GPIO            = 0,
-	GPIO2B2_FLASH_WRN,
-
-	GPIO2B1_SHIFT           = 2,
-	GPIO2B1_MASK            = 1 << GPIO2B1_SHIFT,
-	GPIO2B1_GPIO            = 0,
-	GPIO2B1_FLASH_CLE,
-
-	GPIO2B0_SHIFT           = 0,
-	GPIO2B0_MASK            = 1 << GPIO2B0_SHIFT,
-	GPIO2B0_GPIO            = 0,
-	GPIO2B0_FLASH_ALE,
-};
-
-/* GRF_GPIO2D_IOMUX */
-enum {
-	GPIO2D7_SHIFT		= 14,
-	GPIO2D7_MASK		= 1 << GPIO2D7_SHIFT,
-	GPIO2D7_GPIO		= 0,
-	GPIO2D7_SDIO_D0,
-
-	GPIO2D6_SHIFT		= 12,
-	GPIO2D6_MASK		= 1 << GPIO2D6_SHIFT,
-	GPIO2D6_GPIO		= 0,
-	GPIO2D6_SDIO_CMD,
-
-	GPIO2D5_SHIFT		= 10,
-	GPIO2D5_MASK		= 1 << GPIO2D5_SHIFT,
-	GPIO2D5_GPIO		= 0,
-	GPIO2D5_SDIO_CLKO,
-
-	GPIO2D4_SHIFT		= 8,
-	GPIO2D4_MASK		= 1 << GPIO2D4_SHIFT,
-	GPIO2D4_GPIO		= 0,
-	GPIO2D4_I2C1_SCL,
-
-	GPIO2D3_SHIFT		= 6,
-	GPIO2D3_MASK		= 1 << GPIO2D3_SHIFT,
-	GPIO2D3_GPIO		= 0,
-	GPIO2D3_I2C1_SDA,
-
-	GPIO2D2_SHIFT		= 4,
-	GPIO2D2_MASK		= 3 << GPIO2D2_SHIFT,
-	GPIO2D2_GPIO		= 0,
-	GPIO2D2_UART2_SOUT_M0,
-	GPIO2D2_JTAG_TCK,
-
-	GPIO2D1_SHIFT		= 2,
-	GPIO2D1_MASK		= 3 << GPIO2D1_SHIFT,
-	GPIO2D1_GPIO		= 0,
-	GPIO2D1_UART2_SIN_M0,
-	GPIO2D1_JTAG_TMS,
-	GPIO2D1_DSP_TMS,
-
-	GPIO2D0_SHIFT		= 0,
-	GPIO2D0_MASK		= 3,
-	GPIO2D0_GPIO		= 0,
-	GPIO2D0_UART0_CTSN,
-	GPIO2D0_SPI_CLK_M0,
-	GPIO2D0_DSP_TCK,
-};
-
-/* GRF_GPIO3A_IOMUX */
-enum {
-	GPIO3A7_SHIFT		= 14,
-	GPIO3A7_MASK		= 1 << GPIO3A7_SHIFT,
-	GPIO3A7_GPIO		= 0,
-
-	GPIO3A6_SHIFT		= 12,
-	GPIO3A6_MASK		= 1 << GPIO3A6_SHIFT,
-	GPIO3A6_GPIO		= 0,
-	GPIO3A6_UART1_SOUT,
-
-	GPIO3A5_SHIFT		= 10,
-	GPIO3A5_MASK		= 1 << GPIO3A5_SHIFT,
-	GPIO3A5_GPIO		= 0,
-	GPIO3A5_UART1_SIN,
-
-	GPIO3A4_SHIFT		= 8,
-	GPIO3A4_MASK		= 1 << GPIO3A4_SHIFT,
-	GPIO3A4_GPIO		= 0,
-	GPIO3A4_UART1_CTSN,
-
-	GPIO3A3_SHIFT		= 6,
-	GPIO3A3_MASK		= 1 << GPIO3A3_SHIFT,
-	GPIO3A3_GPIO		= 0,
-	GPIO3A3_UART1_RTSN,
-
-	GPIO3A2_SHIFT		= 4,
-	GPIO3A2_MASK		= 1 << GPIO3A2_SHIFT,
-	GPIO3A2_GPIO		= 0,
-	GPIO3A2_SDIO_D3,
-
-	GPIO3A1_SHIFT		= 2,
-	GPIO3A1_MASK		= 1 << GPIO3A1_SHIFT,
-	GPIO3A1_GPIO		= 0,
-	GPIO3A1_SDIO_D2,
-
-	GPIO3A0_SHIFT		= 0,
-	GPIO3A0_MASK		= 1,
-	GPIO3A0_GPIO		= 0,
-	GPIO3A0_SDIO_D1,
-};
-
-/* GRF_GPIO3C_IOMUX */
-enum {
-	GPIO3C7_SHIFT		= 14,
-	GPIO3C7_MASK		= 1 << GPIO3C7_SHIFT,
-	GPIO3C7_GPIO		= 0,
-	GPIO3C7_CIF_CLKI,
-
-	GPIO3C6_SHIFT		= 12,
-	GPIO3C6_MASK		= 1 << GPIO3C6_SHIFT,
-	GPIO3C6_GPIO		= 0,
-	GPIO3C6_CIF_VSYNC,
-
-	GPIO3C5_SHIFT		= 10,
-	GPIO3C5_MASK		= 1 << GPIO3C5_SHIFT,
-	GPIO3C5_GPIO		= 0,
-	GPIO3C5_SDMMC_CMD,
-
-	GPIO3C4_SHIFT		= 8,
-	GPIO3C4_MASK		= 1 << GPIO3C4_SHIFT,
-	GPIO3C4_GPIO		= 0,
-	GPIO3C4_SDMMC_CLKO,
-
-	GPIO3C3_SHIFT		= 6,
-	GPIO3C3_MASK		= 3 << GPIO3C3_SHIFT,
-	GPIO3C3_GPIO		= 0,
-	GPIO3C3_SDMMC_D0,
-	GPIO3C3_UART2_SOUT_M1,
-
-	GPIO3C2_SHIFT		= 4,
-	GPIO3C2_MASK		= 3 << GPIO3C2_SHIFT,
-	GPIO3C2_GPIO		= 0,
-	GPIO3C2_SDMMC_D1,
-	GPIO3C2_UART2_SIN_M1,
-
-	GPIOC1_SHIFT		= 2,
-	GPIOC1_MASK		= 1 << GPIOC1_SHIFT,
-	GPIOC1_GPIO		= 0,
-	GPIOC1_SDMMC_D2,
-
-	GPIOC0_SHIFT		= 0,
-	GPIOC0_MASK		= 1,
-	GPIO3C0_GPIO		= 0,
-	GPIO3C0_SDMMC_D3,
+	/* PMU_GRF_SOC_CON0 */
+	DDRPHY_BUFFEREN_CORE_SHIFT	= 2,
+	DDRPHY_BUFFEREN_CORE_MASK	= 1 << DDRPHY_BUFFEREN_CORE_SHIFT,
+	DDRPHY_BUFFEREN_CORE_EN		= 1 << DDRPHY_BUFFEREN_CORE_SHIFT,
 };
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/i2c.h b/arch/arm/include/asm/arch-rockchip/i2c.h
index d81f8fffce..b52c6f77da 100644
--- a/arch/arm/include/asm/arch-rockchip/i2c.h
+++ b/arch/arm/include/asm/arch-rockchip/i2c.h
@@ -37,8 +37,15 @@ struct i2c_regs {
 #define I2C_CON_STOP		(1 << 4)
 #define I2C_CON_LASTACK		(1 << 5)
 #define I2C_CON_ACTACK		(1 << 6)
+#define I2C_CON_TUNING_MASK	(0xff << 8)
+#define I2C_CON_SDA_CFG(cfg)	((cfg) << 8)
+#define I2C_CON_STA_CFG(cfg)	((cfg) << 12)
+#define I2C_CON_STO_CFG(cfg)	((cfg) << 14)
+#define I2C_CON_VERSION		GENMASK_ULL(24, 16)
+#define I2C_CON_VERSION_SHIFT	16
 
 /* Clock dividor register */
+#define I2C_CLK_DIV_HIGH_SHIFT	16
 #define I2C_CLKDIV_VAL(divl, divh) \
 	(((divl) & 0xffff) | (((divh) << 16) & 0xffff0000))
 
diff --git a/arch/arm/include/asm/arch-rockchip/periph.h b/arch/arm/include/asm/arch-rockchip/periph.h
index 9f4bc2e107..b968ecf2b5 100644
--- a/arch/arm/include/asm/arch-rockchip/periph.h
+++ b/arch/arm/include/asm/arch-rockchip/periph.h
@@ -24,6 +24,9 @@ enum periph_id {
 	PERIPH_ID_I2C3,
 	PERIPH_ID_I2C4,
 	PERIPH_ID_I2C5,
+	PERIPH_ID_I2C6,
+	PERIPH_ID_I2C7,
+	PERIPH_ID_I2C8,
 	PERIPH_ID_SPI0,
 	PERIPH_ID_SPI1,
 	PERIPH_ID_SPI2,
@@ -43,6 +46,7 @@ enum periph_id {
 	PERIPH_ID_HDMI,
 	PERIPH_ID_GMAC,
 	PERIPH_ID_SFC,
+	PERIPH_ID_NAND,
 
 	PERIPH_ID_COUNT,
 
diff --git a/arch/arm/include/asm/arch-rockchip/pwm.h b/arch/arm/include/asm/arch-rockchip/pwm.h
index b1d8047691..3b6eb353e5 100644
--- a/arch/arm/include/asm/arch-rockchip/pwm.h
+++ b/arch/arm/include/asm/arch-rockchip/pwm.h
@@ -8,13 +8,15 @@
 #ifndef _ASM_ARCH_PWM_H
 #define _ASM_ARCH_PWM_H
 
-struct rk3288_pwm {
-	u32 cnt;
-	u32 period_hpr;
-	u32 duty_lpr;
-	u32 ctrl;
+struct rockchip_pwm_regs {
+	unsigned long duty;
+	unsigned long period;
+	unsigned long cntr;
+	unsigned long ctrl;
 };
-check_member(rk3288_pwm, ctrl, 0xc);
+
+#define PWM_CTRL_TIMER_EN		(1 << 0)
+#define PWM_CTRL_OUTPUT_EN		(1 << 3)
 
 #define RK_PWM_DISABLE                  (0 << 0)
 #define RK_PWM_ENABLE                   (1 << 0)
@@ -34,6 +36,9 @@ check_member(rk3288_pwm, ctrl, 0xc);
 #define PWM_OUTPUT_LEFT                 (0 << 5)
 #define PWM_OUTPUT_CENTER               (1 << 5)
 
+#define PWM_LOCK			(1 << 6)
+#define PWM_UNLOCK			(0 << 6)
+
 #define PWM_LP_ENABLE                   (1 << 8)
 #define PWM_LP_DISABLE                  (0 << 8)
 
diff --git a/arch/arm/include/asm/arch-rockchip/sdram.h b/arch/arm/include/asm/arch-rockchip/sdram.h
index d7d67baa68..e44455dacd 100644
--- a/arch/arm/include/asm/arch-rockchip/sdram.h
+++ b/arch/arm/include/asm/arch-rockchip/sdram.h
@@ -1,109 +1,101 @@
 /*
- * Copyright (c) 2015 Google, Inc
+ * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
  *
- * Copyright 2014 Rockchip Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0
+ * SPDX-License-Identifier:     GPL-2.0+
  */
 
-#ifndef _ASM_ARCH_RK3288_SDRAM_H__
-#define _ASM_ARCH_RK3288_SDRAM_H__
+#ifndef _ASM_ARCH_SDRAM_H
+#define _ASM_ARCH_SDRAM_H
 
 enum {
+	DDR4 = 0,
+	DDR2 = 2,
 	DDR3 = 3,
+	LPDDR2 = 5,
 	LPDDR3 = 6,
-	UNUSED = 0xFF,
+	LPDDR4 = 7,
+	LPDDR4X = 8,
+	LPDDR5 = 9,
+	DDR5 = 10,
+	UNUSED = 0xFF
 };
 
-struct rk3288_sdram_channel {
-	/*
-	 * bit width in address, eg:
-	 * 8 banks using 3 bit to address,
-	 * 2 cs using 1 bit to address.
-	 */
-	u8 rank;
-	u8 col;
-	u8 bk;
-	u8 bw;
-	u8 dbw;
-	u8 row_3_4;
-	u8 cs0_row;
-	u8 cs1_row;
-#if CONFIG_IS_ENABLED(OF_PLATDATA)
-	/*
-	 * For of-platdata, which would otherwise convert this into two
-	 * byte-swapped integers. With a size of 9 bytes, this struct will
-	 * appear in of-platdata as a byte array.
-	 *
-	 * If OF_PLATDATA enabled, need to add a dummy byte in dts.(i.e 0xff)
-	 */
-	u8 dummy;
-#endif
+struct ddr_param {
+	u32 count;
+	u32 reserved;
+	u64 para[8];
 };
 
-struct rk3288_sdram_pctl_timing {
-	u32 togcnt1u;
-	u32 tinit;
-	u32 trsth;
-	u32 togcnt100n;
-	u32 trefi;
-	u32 tmrd;
-	u32 trfc;
-	u32 trp;
-	u32 trtw;
-	u32 tal;
-	u32 tcl;
-	u32 tcwl;
-	u32 tras;
-	u32 trc;
-	u32 trcd;
-	u32 trrd;
-	u32 trtp;
-	u32 twr;
-	u32 twtr;
-	u32 texsr;
-	u32 txp;
-	u32 txpdll;
-	u32 tzqcs;
-	u32 tzqcsi;
-	u32 tdqs;
-	u32 tcksre;
-	u32 tcksrx;
-	u32 tcke;
-	u32 tmod;
-	u32 trstl;
-	u32 tzqcl;
-	u32 tmrr;
-	u32 tckesr;
-	u32 tdpd;
-};
-check_member(rk3288_sdram_pctl_timing, tdpd, 0x144 - 0xc0);
+/*
+ * sys_reg bitfield struct
+ * [31]		row_3_4_ch1
+ * [30]		row_3_4_ch0
+ * [29:28]	chinfo
+ * [27]		rank_ch1
+ * [26:25]	col_ch1
+ * [24]		bk_ch1
+ * [23:22]	low bits of cs0_row_ch1
+ * [21:20]	low bits of cs1_row_ch1
+ * [19:18]	bw_ch1
+ * [17:16]	dbw_ch1;
+ * [15:13]	ddrtype
+ * [12]		channelnum
+ * [11]		rank_ch0
+ * [10:9]	col_ch0,
+ * [8]		bk_ch0
+ * [7:6]	low bits of cs0_row_ch0
+ * [5:4]	low bits of cs1_row_ch0
+ * [3:2]	bw_ch0
+ * [1:0]	dbw_ch0
+ *
+ * sys_reg1 bitfield struct
+ * [7]		high bit of cs0_row_ch1
+ * [6]		high bit of cs1_row_ch1
+ * [5]		high bit of cs0_row_ch0
+ * [4]		high bit of cs1_row_ch0
+ * [3:2]	cs1_col_ch1
+ * [1:0]	cs1_col_ch0
+*/
+#define SYS_REG_DDRTYPE_SHIFT		13
+#define SYS_REG_DDRTYPE_MASK		7
+#define SYS_REG_NUM_CH_SHIFT		12
+#define SYS_REG_NUM_CH_MASK		1
+#define SYS_REG_ROW_3_4_SHIFT(ch)	(30 + (ch))
+#define SYS_REG_ROW_3_4_MASK		1
+#define SYS_REG_CHINFO_SHIFT(ch)	(28 + (ch))
+#define SYS_REG_RANK_SHIFT(ch)		(11 + (ch) * 16)
+#define SYS_REG_RANK_MASK		1
+#define SYS_REG_COL_SHIFT(ch)		(9 + (ch) * 16)
+#define SYS_REG_COL_MASK		3
+#define SYS_REG_BK_SHIFT(ch)		(8 + (ch) * 16)
+#define SYS_REG_BK_MASK			1
+#define SYS_REG_CS0_ROW_SHIFT(ch)	(6 + (ch) * 16)
+#define SYS_REG_CS0_ROW_MASK		3
+#define SYS_REG_CS1_ROW_SHIFT(ch)	(4 + (ch) * 16)
+#define SYS_REG_CS1_ROW_MASK		3
+#define SYS_REG_BW_SHIFT(ch)		(2 + (ch) * 16)
+#define SYS_REG_BW_MASK			3
+#define SYS_REG_DBW_SHIFT(ch)		((ch) * 16)
+#define SYS_REG_DBW_MASK		3
 
-struct rk3288_sdram_phy_timing {
-	u32 dtpr0;
-	u32 dtpr1;
-	u32 dtpr2;
-	u32 mr[4];
-};
+#define SYS_REG1_VERSION_SHIFT			28
+#define SYS_REG1_VERSION_MASK			0xf
+#define SYS_REG1_EXTEND_CS0_ROW_SHIFT(ch)	(5 + (ch) * 2)
+#define SYS_REG1_EXTEND_CS0_ROW_MASK		1
+#define SYS_REG1_EXTEND_CS1_ROW_SHIFT(ch)	(4 + (ch) * 2)
+#define SYS_REG1_EXTEND_CS1_ROW_MASK		1
+#define SYS_REG1_CS1_COL_SHIFT(ch)		(0 + (ch) * 2)
+#define SYS_REG1_CS1_COL_MASK			3
 
-struct rk3288_base_params {
-	u32 noc_timing;
-	u32 noc_activate;
-	u32 ddrconfig;
-	u32 ddr_freq;
-	u32 dramtype;
-	/*
-	 * DDR Stride is address mapping for DRAM space
-	 * Stride	Ch 0 range	Ch1 range	Total
-	 * 0x00		0-256MB		256MB-512MB	512MB
-	 * 0x05		0-1GB		0-1GB		1GB
-	 * 0x09		0-2GB		0-2GB		2GB
-	 * 0x0d		0-4GB		0-4GB		4GB
-	 * 0x17		N/A		0-4GB		4GB
-	 * 0x1a		0-4GB		4GB-8GB		8GB
-	 */
-	u32 stride;
-	u32 odt;
-};
+/* Get sdram size decode from reg */
+size_t rockchip_sdram_size(phys_addr_t reg);
+unsigned int get_page_size(void);
+unsigned int get_ddr_bw(void);
+
+/* Called by U-Boot board_init_r for Rockchip SoCs */
+int dram_init(void);
+
+/* Write ddr param to a known place for trustos */
+int rockchip_setup_ddr_param(struct ddr_param *info);
 
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/sdram_common.h b/arch/arm/include/asm/arch-rockchip/sdram_common.h
index fec85865ff..628fd6c6e1 100644
--- a/arch/arm/include/asm/arch-rockchip/sdram_common.h
+++ b/arch/arm/include/asm/arch-rockchip/sdram_common.h
@@ -1,11 +1,294 @@
+/* SPDX-License-Identifier:     GPL-2.0+ */
 /*
- * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
- *
- * SPDX-License-Identifier:     GPL-2.0+
+ * Copyright (C) 2018 Rockchip Electronics Co., Ltd
  */
 
-#ifndef _ASM_ARCH_SDRAM_COMMON_H
-#define _ASM_ARCH_SDRAM_COMMON_H
+#ifndef _ASM_ARCH_SDRAM_SHARE_H
+#define _ASM_ARCH_SDRAM_SHARE_H
+
+#ifndef MHZ
+#define MHZ		(1000 * 1000)
+#endif
+
+#define PATTERN		(0x5aa5f00f)
+
+#define MIN(a, b)	(((a) > (b)) ? (b) : (a))
+#define MAX(a, b)	(((a) > (b)) ? (a) : (b))
+
+/* get head info for initial */
+#define DDR_FREQ_F0_SHIFT		(0)
+#define DDR_FREQ_F1_SHIFT		(12)
+#define DDR_FREQ_F2_SHIFT		(0)
+#define DDR_FREQ_F3_SHIFT		(12)
+#define DDR_FREQ_F4_SHIFT		(0)
+#define DDR_FREQ_F5_SHIFT		(12)
+#define DDR_FREQ_MASK			(0xfff)
+
+#define UART_INFO_ID_SHIFT		(28)
+#define UART_INFO_IOMUX_SHIFT		(24)
+#define UART_INFO_BAUD_SHIFT		(0)
+#define UART_INFO_ID(n)			(((n) >> 28) & 0xf)
+#define UART_INFO_IOMUX(n)		(((n) >> 24) & 0xf)
+#define UART_INFO_BAUD(n)		((n) & 0xffffff)
+
+/* g_ch_info[15:0]: g_stdby_idle */
+#define STANDBY_IDLE(n)			((n) & 0xffff)
+
+#define SR_INFO(n)			(((n) >> 16) & 0xffff)
+#define PD_INFO(n)			((n) & 0xffff)
+
+#define FIRST_SCAN_CH(n)		(((n) >> 28) & 0xf)
+#define CHANNEL_MASK(n)			(((n) >> 24) & 0xf)
+#define STRIDE_TYPE(n)			(((n) >> 16) & 0xff)
+
+#define DDR_2T_INFO(n)			((n) & 1)
+#define PLL_SSMOD_SPREAD(n)		(((n) >> 1) & 0xff)
+#define PLL_SSMOD_DIV(n)		(((n) >> 9) & 0xff)
+#define PLL_SSMOD_DOWNSPREAD(n)		(((n) >> 17) & 0x3)
+
+/* sdram_head_info_v2 define */
+/* for *_drv_odten and *_drv_odtoff */
+#define PHY_DQ_DRV_SHIFT		0
+#define PHY_CA_DRV_SHIFT		8
+#define PHY_CLK_DRV_SHIFT		16
+#define DRAM_DQ_DRV_SHIFT		24
+#define DRV_INFO_PHY_DQ_DRV(n)		((n) & 0xff)
+#define DRV_INFO_PHY_CA_DRV(n)		(((n) >> PHY_CA_DRV_SHIFT) & 0xff)
+#define DRV_INFO_PHY_CLK_DRV(n)		(((n) >> PHY_CLK_DRV_SHIFT) & 0xff)
+#define DRV_INFO_DRAM_DQ_DRV(n)		(((n) >> DRAM_DQ_DRV_SHIFT) & 0xff)
+
+/* for *_odt_info */
+#define DRAM_ODT_SHIFT			0
+#define PHY_ODT_SHIFT			8
+#define PHY_ODT_PUUP_EN_SHIFT		18
+#define PHY_ODT_PUDN_EN_SHIFT		19
+#define ODT_INFO_DRAM_ODT(n)		(((n) >> DRAM_ODT_SHIFT) & 0xff)
+#define ODT_INFO_PHY_ODT(n)		(((n) >> PHY_ODT_SHIFT) & 0x3ff)
+#define ODT_INFO_PULLUP_EN(n)		(((n) >> PHY_ODT_PUUP_EN_SHIFT) & 1)
+#define ODT_INFO_PULLDOWN_EN(n)		(((n) >> PHY_ODT_PUDN_EN_SHIFT) & 1)
+
+/* for *odt_en_freq; */
+#define DRAM_ODT_EN_FREQ_SHIFT		0
+#define PHY_ODT_EN_FREQ_SHIFT		12
+#define DRAMODT_EN_FREQ(n)		(((n) >> DRAM_ODT_EN_FREQ_SHIFT) & \
+					 0xfff)
+#define PHYODT_EN_FREQ(n)		(((n) >> PHY_ODT_EN_FREQ_SHIFT) & 0xfff)
+
+#define PHY_DQ_SR_SHIFT			0
+#define PHY_CA_SR_SHIFT			8
+#define PHY_CLK_SR_SHIFT		16
+#define DQ_SR_INFO(n)			(((n) >> PHY_DQ_SR_SHIFT) & 0xff)
+#define CA_SR_INFO(n)			(((n) >> PHY_CA_SR_SHIFT) & 0xff)
+#define CLK_SR_INFO(n)			(((n) >> PHY_CLK_SR_SHIFT) & 0xff)
+
+/* LP4 */
+#define LP4_CA_ODT_SHIFT			(18)
+#define LP4_DRV_PU_CAL_ODTEN_SHIFT		(26)
+#define LP4_DRV_PU_CAL_ODTOFF_SHIFT		(27)
+#define PHY_LP4_DRV_PULLDOWN_EN_ODTEN_SHIFT	(28)
+#define PHY_LP4_DRV_PULLDOWN_EN_ODTOFF_SHIFT	(29)
+#define ODT_INFO_LP4_CA_ODT(n)			(((n) >> LP4_CA_ODT_SHIFT) & \
+						 0xff)
+#define LP4_DRV_PU_CAL_ODTEN(n)		\
+	(((n) >> LP4_DRV_PU_CAL_ODTEN_SHIFT) & 1)
+#define LP4_DRV_PU_CAL_ODTOFF(n)	\
+	(((n) >> LP4_DRV_PU_CAL_ODTOFF_SHIFT) & 1)
+#define PHY_LP4_DRV_PULLDOWN_EN_ODTEN(n)	\
+	(((n) >> PHY_LP4_DRV_PULLDOWN_EN_ODTEN_SHIFT) & 1)
+#define PHY_LP4_DRV_PULLDOWN_EN_ODTOFF(n)	\
+	(((n) >> PHY_LP4_DRV_PULLDOWN_EN_ODTOFF_SHIFT) & 1)
+
+#define PHY_LP4_CS_DRV_ODTEN_SHIFT	(0)
+#define PHY_LP4_CS_DRV_ODTOFF_SHIFT	(8)
+#define LP4_ODTE_CK_SHIFT		(16)
+#define LP4_ODTE_CS_EN_SHIFT		(17)
+#define LP4_ODTD_CA_EN_SHIFT		(18)
+#define PHY_LP4_CS_DRV_ODTEN(n)		\
+	(((n) >> PHY_LP4_CS_DRV_ODTEN_SHIFT) & 0xff)
+#define PHY_LP4_CS_DRV_ODTOFF(n)	\
+	(((n) >> PHY_LP4_CS_DRV_ODTOFF_SHIFT) & 0xff)
+#define LP4_ODTE_CK_EN(n)		(((n) >> LP4_ODTE_CK_SHIFT) & 1)
+#define LP4_ODTE_CS_EN(n)		(((n) >> LP4_ODTE_CS_EN_SHIFT) & 1)
+#define LP4_ODTD_CA_EN(n)		(((n) >> LP4_ODTD_CA_EN_SHIFT) & 1)
+
+#define PHY_LP4_DQ_VREF_SHIFT		(0)
+#define LP4_DQ_VREF_SHIFT		(10)
+#define LP4_CA_VREF_SHIFT		(20)
+
+#define PHY_LP4_DQ_VREF(n)		\
+	(((n) >> PHY_LP4_DQ_VREF_SHIFT) & 0x3ff)
+#define LP4_DQ_VREF(n)			(((n) >> LP4_DQ_VREF_SHIFT) & 0x3ff)
+#define LP4_CA_VREF(n)			(((n) >> LP4_CA_VREF_SHIFT) & 0x3ff)
+
+#define LP4_DQ_ODT_EN_FREQ_SHIFT	(0)
+#define PHY_LP4_ODT_EN_FREQ_SHIFT	(12)
+#define LP4_CA_ODT_EN_FREQ_SHIFT	(0)
+#define PHY_LP4_ODT_EN_FREQ(n)		\
+	(((n) >> PHY_LP4_ODT_EN_FREQ_SHIFT) & 0xfff)
+#define LP4_DQ_ODT_EN_FREQ(n)		\
+	(((n) >> LP4_DQ_ODT_EN_FREQ_SHIFT) & 0xfff)
+#define LP4_CA_ODT_EN_FREQ(n)		\
+	(((n) >> LP4_CA_ODT_EN_FREQ_SHIFT) & 0xfff)
+
+struct sdram_head_info_v0 {
+	u32 start_tag;
+	u32 version_info;
+	u32 gcpu_gen_freq;
+	u32 g_d2_lp2_freq;
+	u32 g_d3_lp3_freq;
+	u32 g_d4_lp4_freq;
+	u32 g_uart_info;
+	u32 g_sr_pd_idle;
+	u32 g_ch_info;
+	u32 g_2t_info;
+	u32 reserved11;
+	u32 reserved12;
+	u32 reserved13;
+};
+
+struct index_info {
+	u8 offset;
+	u8 size;
+};
+
+struct sdram_head_info_index_v2 {
+	u32 start_tag;
+	u32 version_info;
+	struct index_info cpu_gen_index;
+	struct index_info global_index;
+
+	struct index_info ddr2_index;
+	struct index_info ddr3_index;
+
+	struct index_info ddr4_index;
+	struct index_info ddr5_index;
+
+	struct index_info lp2_index;
+	struct index_info lp3_index;
+
+	struct index_info lp4_index;
+	struct index_info lp5_index;
+
+	struct index_info skew_index;
+	struct index_info dq_map_index;
+
+	struct index_info lp4x_index;
+	struct index_info reserved;
+};
+
+struct global_info {
+	u32 uart_info;
+	u32 sr_pd_info;
+	u32 ch_info;
+	u32 info_2t;
+	u32 reserved[4];
+};
+
+struct ddr2_3_4_lp2_3_info {
+	u32 ddr_freq0_1;
+	u32 ddr_freq2_3;
+	u32 ddr_freq4_5;
+	u32 drv_when_odten;
+	u32 drv_when_odtoff;
+	u32 odt_info;
+	u32 odten_freq;
+	u32 sr_when_odten;
+	u32 sr_when_odtoff;
+};
+
+struct lp4_info {
+	u32 ddr_freq0_1;
+	u32 ddr_freq2_3;
+	u32 ddr_freq4_5;
+	u32 drv_when_odten;
+	u32 drv_when_odtoff;
+	u32 odt_info;
+	u32 dq_odten_freq;
+	u32 sr_when_odten;
+	u32 sr_when_odtoff;
+	u32 ca_odten_freq;
+	u32 cs_drv_ca_odt_info;
+	u32 vref_when_odten;
+	u32 vref_when_odtoff;
+};
+
+struct dq_map_info {
+	u32 byte_map[2];
+	u32 lp3_dq0_7_map;
+	u32 lp2_dq0_7_map;
+	u32 ddr4_dq_map[4];
+};
+
+struct sdram_cap_info {
+	unsigned int rank;
+	unsigned int col;
+	/* 3:8bank, 2:4bank */
+	unsigned int bk;
+	/* channel buswidth, 2:32bit, 1:16bit, 0:8bit */
+	unsigned int bw;
+	/* die buswidth, 2:32bit, 1:16bit, 0:8bit */
+	unsigned int dbw;
+	unsigned int row_3_4;
+	unsigned int cs0_row;
+	unsigned int cs1_row;
+	unsigned int cs2_row;
+	unsigned int cs3_row;
+	unsigned int cs0_high16bit_row;
+	unsigned int cs1_high16bit_row;
+	unsigned int cs2_high16bit_row;
+	unsigned int cs3_high16bit_row;
+	unsigned int ddrconfig;
+};
+
+struct sdram_base_params {
+	unsigned int ddr_freq;
+	unsigned int dramtype;
+	unsigned int num_channels;
+	unsigned int stride;
+	unsigned int odt;
+};
+
+/* store result of read and write training, for ddr_dq_eye tool in u-boot */
+#define DDR_DQ_EYE_FLAG	0xdddeefa0
+
+#define FSP_NUM		4
+#define CS_NUM		4
+#define BYTE_NUM	5
+
+struct dqs_rw_trn_result {
+	u16 dq_deskew[8];
+	u16 dqs_deskew;
+	u16 dq_min[8];
+	u16 dq_max[8];
+};
+
+struct cs_rw_trn_result {
+	struct dqs_rw_trn_result dqs[BYTE_NUM];
+};
+
+struct fsp_rw_trn_result {
+	u16 min_val;
+	struct cs_rw_trn_result cs[CS_NUM];
+};
+
+struct rw_trn_result {
+	u32 flag;
+	u8 cs_num;
+	u8 byte_en;
+	u16 fsp_mhz[FSP_NUM];
+	struct fsp_rw_trn_result rd_fsp[FSP_NUM];
+	struct fsp_rw_trn_result wr_fsp[FSP_NUM];
+};
+
+/* for modify tRFC and related timing */
+#define DIE_CAP_512MBIT	64
+#define DIE_CAP_1GBIT	128
+#define DIE_CAP_2GBIT	256
+#define DIE_CAP_4GBIT	512
+#define DIE_CAP_8GBIT	1024
+#define DIE_CAP_16GBIT	2048
+#define DIE_CAP_32GBIT	4096
+
 /*
  * sys_reg bitfield struct
  * [31]		row_3_4_ch1
@@ -27,32 +310,138 @@
  * [5:4]	cs1_row_ch0
  * [3:2]	bw_ch0
  * [1:0]	dbw_ch0
-*/
-#define SYS_REG_DDRTYPE_SHIFT		13
-#define SYS_REG_DDRTYPE_MASK		7
-#define SYS_REG_NUM_CH_SHIFT		12
-#define SYS_REG_NUM_CH_MASK		1
-#define SYS_REG_ROW_3_4_SHIFT(ch)	(30 + (ch))
-#define SYS_REG_ROW_3_4_MASK		1
-#define SYS_REG_CHINFO_SHIFT(ch)	(28 + (ch))
-#define SYS_REG_RANK_SHIFT(ch)		(11 + (ch) * 16)
-#define SYS_REG_RANK_MASK		1
-#define SYS_REG_COL_SHIFT(ch)		(9 + (ch) * 16)
-#define SYS_REG_COL_MASK		3
-#define SYS_REG_BK_SHIFT(ch)		(8 + (ch) * 16)
-#define SYS_REG_BK_MASK			1
-#define SYS_REG_CS0_ROW_SHIFT(ch)	(6 + (ch) * 16)
-#define SYS_REG_CS0_ROW_MASK		3
-#define SYS_REG_CS1_ROW_SHIFT(ch)	(4 + (ch) * 16)
-#define SYS_REG_CS1_ROW_MASK		3
-#define SYS_REG_BW_SHIFT(ch)		(2 + (ch) * 16)
-#define SYS_REG_BW_MASK			3
-#define SYS_REG_DBW_SHIFT(ch)		((ch) * 16)
-#define SYS_REG_DBW_MASK		3
-
-/* Get sdram size decode from reg */
-size_t rockchip_sdram_size(phys_addr_t reg);
-
-/* Called by U-Boot board_init_r for Rockchip SoCs */
-int dram_init(void);
+ */
+
+#define DDR_SYS_REG_VERSION		(0x2)
+#define SYS_REG_ENC_ROW_3_4(n, ch)	((n) << (30 + (ch)))
+#define SYS_REG_DEC_ROW_3_4(n, ch)	(((n) >> (30 + (ch))) & 0x1)
+#define SYS_REG_ENC_CHINFO(ch)		(1 << (28 + (ch)))
+#define SYS_REG_DEC_CHINFO(n, ch)	(((n) >> (28 + (ch))) & 0x1)
+#define SYS_REG_ENC_DDRTYPE(n)		((n) << 13)
+#define SYS_REG_DEC_DDRTYPE(n)		(((n) >> 13) & 0x7)
+#define SYS_REG_ENC_NUM_CH(n)		(((n) - 1) << 12)
+#define SYS_REG_DEC_NUM_CH(n)		(1 + (((n) >> 12) & 0x1))
+#define SYS_REG_ENC_RANK(n, ch)		(((n) - 1) << (11 + ((ch) * 16)))
+#define SYS_REG_DEC_RANK(n, ch)		(1 + (((n) >> (11 + 16 * (ch))) & 0x1))
+#define SYS_REG_ENC_COL(n, ch)		(((n) - 9) << (9 + ((ch) * 16)))
+#define SYS_REG_DEC_COL(n, ch)		(9 + (((n) >> (9 + 16 * (ch))) & 0x3))
+#define SYS_REG_ENC_BK(n, ch)		(((n) == 3 ? 0 : 1) << \
+						(8 + ((ch) * 16)))
+#define SYS_REG_DEC_BK(n, ch)		(3 - (((n) >> (8 + 16 * (ch))) & 0x1))
+#define SYS_REG_ENC_BW(n, ch)		((2 >> (n)) << (2 + ((ch) * 16)))
+#define SYS_REG_DEC_BW(n, ch)		(2 >> (((n) >> (2 + 16 * (ch))) & 0x3))
+#define SYS_REG_ENC_DBW(n, ch)		((2 >> (n)) << (0 + ((ch) * 16)))
+#define SYS_REG_DEC_DBW(n, ch)		(2 >> (((n) >> (0 + 16 * (ch))) & 0x3))
+/* sys reg 3 */
+#define SYS_REG_ENC_VERSION(n)		((n) << 28)
+#define SYS_REG_DEC_VERSION(n)		(((n) >> 28) & 0xf)
+#define SYS_REG_ENC_CS0_ROW(n, os_reg2, os_reg3, ch) do { \
+			(os_reg2) &= (~(0x3 << (6 + 16 * (ch)))); \
+			(os_reg3) &= (~(0x1 << (5 + 2 * (ch)))); \
+			(os_reg2) |= (((n) - 13) & 0x3) << (6 + 16 * (ch)); \
+			(os_reg3) |= ((((n) - 13) & 0x4) >> 2) << \
+				     (5 + 2 * (ch)); \
+		} while (0)
+
+#define SYS_REG_DEC_CS0_ROW(os_reg2, os_reg3, ch)	\
+		((((((os_reg2) >> (6 + 16 * (ch)) & 0x3) | \
+		 ((((os_reg3) >> (5 + 2 * (ch))) & 0x1) << 2)) + 1) & 0x7) + 12)
+
+#define SYS_REG_ENC_CS1_ROW(n, os_reg2, os_reg3, ch) do { \
+			(os_reg2) &= (~(0x3 << (4 + 16 * (ch)))); \
+			(os_reg3) &= (~(0x1 << (4 + 2 * (ch)))); \
+			(os_reg2) |= (((n) - 13) & 0x3) << (4 + 16 * (ch)); \
+			(os_reg3) |= ((((n) - 13) & 0x4) >> 2) << \
+				     (4 + 2 * (ch)); \
+		} while (0)
+
+#define SYS_REG_DEC_CS1_ROW(os_reg2, os_reg3, ch) \
+		((((((os_reg2) >> (4 + 16 * (ch)) & 0x3) | \
+		 ((((os_reg3) >> (4 + 2 * (ch))) & 0x1) << 2)) + 1) & 0x7) + 12)
+
+#define SYS_REG_ENC_CS1_COL(n, ch)	(((n) - 9) << (0 + 2 * (ch)))
+#define SYS_REG_DEC_CS1_COL(n, ch)	(9 + (((n) >> (0 + 2 * (ch))) & 0x3))
+
+/* DDR SYS REG Version 3 */
+#define DDR_SYS_REG_VERSION_3		(0x3)
+#define SYS_REG_ENC_ROW_3_4_V3(row3_4, ch)	SYS_REG_ENC_ROW_3_4(row3_4, ch)
+#define SYS_REG_DEC_ROW_3_4_V3(reg2, ch)	SYS_REG_DEC_ROW_3_4(reg2, ch)
+#define SYS_REG_ENC_CHINFO_V3(ch)	SYS_REG_ENC_CHINFO(ch)
+#define SYS_REG_DEC_CHINFO_V3(reg2, ch)	SYS_REG_DEC_CHINFO(reg2, ch)
+#define SYS_REG_ENC_DDRTYPE_V3(n, reg2, reg3)	do { \
+		(reg2) &= (~(0x7 << 13)); \
+		(reg3) &= (~(0x3 << 12)); \
+		(reg2) |= (((n) & 0x7) << 13); \
+		(reg3) |= (((n) >> 3) & 0x3) << 12; \
+	} while (0)
+#define SYS_REG_DEC_DDRTYPE_V3(reg2, reg3) \
+	((((reg2) >> 13) & 0x7) | \
+	 ((((reg3) >> 12) & 0x3) << 3))
+
+#define SYS_REG_ENC_NUM_CH_V3(n)		SYS_REG_ENC_NUM_CH(n)
+#define SYS_REG_DEC_NUM_CH_V3(reg2)		SYS_REG_DEC_NUM_CH(reg2)
+#define SYS_REG_ENC_CH1_3_RANK(cs)		SYS_REG_ENC_RANK(cs, 1)
+#define SYS_REG_DEC_CH1_3_RANK(reg2)		SYS_REG_DEC_RANK(reg2, 1)
+#define SYS_REG_ENC_CH0_2_RANK_V3(n, reg2, reg3)	do { \
+		(reg2) &= (~(1 << 11)); \
+		(reg3) &= (~(1 << 14)); \
+		(reg2) |= (((n) == 2) ? 1 : 0) << 11; \
+		(reg3) |= (((n) == 4) ? 1 : 0) << 14; \
+	} while (0)
+#define SYS_REG_DEC_CH0_2_RANK_V3(reg2, reg3) \
+		(1 << ((((reg2) >> 11) & 1) | ((((reg3) >> 14) & 1) << 1)))
+#define SYS_REG_ENC_COL_V3(col, ch)		SYS_REG_ENC_COL(col, ch)
+#define SYS_REG_DEC_COL_V3(reg2, ch)		SYS_REG_DEC_COL(reg2, ch)
+#define SYS_REG_ENC_BK_V3(bk, ch)		SYS_REG_ENC_BK(bk, ch)
+#define SYS_REG_DEC_BK_V3(reg2, ch)		SYS_REG_DEC_BK(reg2, ch)
+#define SYS_REG_ENC_BW_V3(bw, ch)		SYS_REG_ENC_BW(bw, ch)
+#define SYS_REG_DEC_BW_V3(reg2, ch)		SYS_REG_DEC_BW(reg2, ch)
+#define SYS_REG_ENC_DBW_V3(dbw, ch)		SYS_REG_ENC_DBW(dbw, ch)
+#define SYS_REG_DEC_DBW_V3(reg2, ch)		SYS_REG_DEC_DBW(reg2, ch)
+#define SYS_REG_ENC_VERSION_V3(n)		SYS_REG_ENC_VERSION(n)
+#define SYS_REG_DEC_VERSION_V3(reg3)		SYS_REG_DEC_VERSION(reg3)
+#define SYS_REG_ENC_CS0_ROW_V3(row, reg2, reg3, ch) \
+		SYS_REG_ENC_CS0_ROW(row, reg2, reg3, ch)
+#define SYS_REG_DEC_CS0_ROW_V3(reg2, reg3, ch) \
+		SYS_REG_DEC_CS0_ROW(reg2, reg3, ch)
+#define SYS_REG_ENC_CS1_ROW_V3(row, reg2, reg3, ch) \
+		SYS_REG_ENC_CS1_ROW(row, reg2, reg3, ch)
+#define SYS_REG_DEC_CS1_ROW_V3(reg2, reg3, ch) \
+		SYS_REG_DEC_CS1_ROW(reg2, reg3, ch)
+#define SYS_REG_ENC_CS2_DELTA_ROW_V3(row_del)	((row_del) << 15)
+#define SYS_REG_DEC_CS2_DELTA_ROW_V3(reg3)	(((reg3) >> 15) & 1)
+#define SYS_REG_ENC_CS3_DELTA_ROW_V3(row_del)	((row_del) << 16)
+#define SYS_REG_DEC_CS3_DELTA_ROW_V3(reg3)	(((reg3) >> 16) & 1)
+
+#define SYS_REG_ENC_CS1_COL_V3(col, ch)		SYS_REG_ENC_CS1_COL(col, ch)
+#define SYS_REG_DEC_CS1_COL_V3(reg3, ch)	SYS_REG_DEC_CS1_COL(reg3, ch)
+
+void sdram_org_config(struct sdram_cap_info *cap_info,
+		      struct sdram_base_params *base,
+		      u32 *p_os_reg2, u32 *p_os_reg3, u32 channel);
+void sdram_org_config_v3(struct sdram_cap_info *cap_info,
+			 struct sdram_base_params *base,
+			 u32 *p_os_reg2, u32 *p_os_reg3, u32 channel);
+int sdram_detect_bw(struct sdram_cap_info *cap_info);
+int sdram_detect_cs(struct sdram_cap_info *cap_info);
+int sdram_detect_col(struct sdram_cap_info *cap_info,
+		     u32 coltmp);
+int sdram_detect_bank(struct sdram_cap_info *cap_info,
+		      u32 coltmp, u32 bktmp);
+int sdram_detect_bg(struct sdram_cap_info *cap_info,
+		    u32 coltmp);
+int sdram_detect_dbw(struct sdram_cap_info *cap_info, u32 dram_type);
+int sdram_detect_row(struct sdram_cap_info *cap_info,
+		     u32 coltmp, u32 bktmp, u32 rowtmp);
+int sdram_detect_row_3_4(struct sdram_cap_info *cap_info,
+			 u32 coltmp, u32 bktmp);
+int sdram_detect_high_row(struct sdram_cap_info *cap_info, u32 dramtype);
+int sdram_detect_cs1_row(struct sdram_cap_info *cap_info, u32 dram_type);
+
+void sdram_print_dram_type(unsigned char dramtype);
+void sdram_print_ddr_info(struct sdram_cap_info *cap_info,
+			  struct sdram_base_params *base, u32 split);
+u64 sdram_get_cs_cap(struct sdram_cap_info *cap_info, u32 cs, u32 dram_type);
+void sdram_copy_to_reg(u32 *dest, const u32 *src, u32 n);
+
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/sdram_rk3036.h b/arch/arm/include/asm/arch-rockchip/sdram_rk3036.h
index 4ce2ba5e6e..686e778f98 100644
--- a/arch/arm/include/asm/arch-rockchip/sdram_rk3036.h
+++ b/arch/arm/include/asm/arch-rockchip/sdram_rk3036.h
@@ -331,7 +331,7 @@ struct rk3036_ddr_config {
 };
 
 /* rk3036 sdram initial */
-void sdram_init(void);
+int sdram_init(void);
 
 /* get ddr die config, implement in specific board */
 void get_ddr_config(struct rk3036_ddr_config *config);
diff --git a/arch/arm/include/asm/arch-rockchip/sdram_rk3399.h b/arch/arm/include/asm/arch-rockchip/sdram_rk3399.h
index 22a6ca9ae1..333b094157 100644
--- a/arch/arm/include/asm/arch-rockchip/sdram_rk3399.h
+++ b/arch/arm/include/asm/arch-rockchip/sdram_rk3399.h
@@ -6,14 +6,8 @@
 
 #ifndef _ASM_ARCH_SDRAM_RK3399_H
 #define _ASM_ARCH_SDRAM_RK3399_H
-
-enum {
-	DDR3 = 0x3,
-	LPDDR2 = 0x5,
-	LPDDR3 = 0x6,
-	LPDDR4 = 0x7,
-	UNUSED = 0xFF
-};
+#include <asm/arch/sdram_common.h>
+#include <asm/arch/sdram_msch.h>
 
 struct rk3399_ddr_pctl_regs {
 	u32 denali_ctl[332];
@@ -27,30 +21,6 @@ struct rk3399_ddr_pi_regs {
 	u32 denali_pi[200];
 };
 
-struct rk3399_msch_regs {
-	u32 coreid;
-	u32 revisionid;
-	u32 ddrconf;
-	u32 ddrsize;
-	u32 ddrtiminga0;
-	u32 ddrtimingb0;
-	u32 ddrtimingc0;
-	u32 devtodev0;
-	u32 reserved0[(0x110 - 0x20) / 4];
-	u32 ddrmode;
-	u32 reserved1[(0x1000 - 0x114) / 4];
-	u32 agingx0;
-};
-
-struct rk3399_msch_timings {
-	u32 ddrtiminga0;
-	u32 ddrtimingb0;
-	u32 ddrtimingc0;
-	u32 devtodev0;
-	u32 ddrmode;
-	u32 agingx0;
-};
-
 struct rk3399_ddr_cic_regs {
 	u32 cic_ctrl0;
 	u32 cic_ctrl1;
@@ -72,38 +42,38 @@ struct rk3399_ddr_cic_regs {
 /* DENALI_CTL_274 */
 #define MEM_RST_VALID	1
 
-struct rk3399_sdram_channel {
-	unsigned int rank;
-	/* dram column number, 0 means this channel is invalid */
-	unsigned int col;
-	/* dram bank number, 3:8bank, 2:4bank */
-	unsigned int bk;
-	/* channel buswidth, 2:32bit, 1:16bit, 0:8bit */
-	unsigned int bw;
-	/* die buswidth, 2:32bit, 1:16bit, 0:8bit */
-	unsigned int dbw;
-	/*
-	 * row_3_4 = 1: 6Gb or 12Gb die
-	 * row_3_4 = 0: normal die, power of 2
-	 */
-	unsigned int row_3_4;
-	unsigned int cs0_row;
-	unsigned int cs1_row;
-	unsigned int ddrconfig;
-	struct rk3399_msch_timings noc_timings;
+struct msch_regs {
+	u32 coreid;
+	u32 revisionid;
+	u32 ddrconf;
+	u32 ddrsize;
+	union noc_ddrtiminga0 ddrtiminga0;
+	union noc_ddrtimingb0 ddrtimingb0;
+	union noc_ddrtimingc0 ddrtimingc0;
+	union noc_devtodev0 devtodev0;
+	u32 reserved0[(0x110 - 0x20) / 4];
+	union noc_ddrmode ddrmode;
+	u32 reserved1[(0x1000 - 0x114) / 4];
+	u32 agingx0;
 };
 
-struct rk3399_base_params {
-	unsigned int ddr_freq;
-	unsigned int dramtype;
-	unsigned int num_channels;
-	unsigned int stride;
-	unsigned int odt;
+struct sdram_msch_timings {
+	union noc_ddrtiminga0 ddrtiminga0;
+	union noc_ddrtimingb0 ddrtimingb0;
+	union noc_ddrtimingc0 ddrtimingc0;
+	union noc_devtodev0 devtodev0;
+	union noc_ddrmode ddrmode;
+	u32 agingx0;
+};
+
+struct rk3399_sdram_channel {
+	struct sdram_cap_info cap_info;
+	struct sdram_msch_timings noc_timings;
 };
 
 struct rk3399_sdram_params {
 	struct rk3399_sdram_channel ch[2];
-	struct rk3399_base_params base;
+	struct sdram_base_params base;
 	struct rk3399_ddr_pctl_regs pctl_regs;
 	struct rk3399_ddr_pi_regs pi_regs;
 	struct rk3399_ddr_publ_regs phy_regs;
@@ -116,4 +86,13 @@ struct rk3399_sdram_params {
 #define PI_WDQ_LEVELING		(1 << 4)
 #define PI_FULL_TRAINING	0xff
 
+enum {
+	STRIDE_128B = 0,
+	STRIDE_256B = 1,
+	STRIDE_512B = 2,
+	STRIDE_4KB = 3,
+	UN_STRIDE = 4,
+	PART_STRIDE = 5
+};
+
 #endif
diff --git a/arch/arm/include/asm/arch-rockchip/sys_proto.h b/arch/arm/include/asm/arch-rockchip/sys_proto.h
index 35423e1ba0..536ed98b31 100644
--- a/arch/arm/include/asm/arch-rockchip/sys_proto.h
+++ b/arch/arm/include/asm/arch-rockchip/sys_proto.h
@@ -7,4 +7,8 @@
 #ifndef _ASM_ARCH_SYS_PROTO_H
 #define _ASM_ARCH_SYS_PROTO_H
 
+#if !defined(CONFIG_SPL_FRAMEWORK) || CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+int sdram_init(void);
+#endif
+
 #endif /* _ASM_ARCH_SYS_PROTO_H */
diff --git a/arch/arm/include/asm/armv7.h b/arch/arm/include/asm/armv7.h
index a20702e612..efc515eb33 100644
--- a/arch/arm/include/asm/armv7.h
+++ b/arch/arm/include/asm/armv7.h
@@ -61,6 +61,27 @@
 #include <asm/io.h>
 #include <asm/barriers.h>
 
+/* read L2 control register (L2CTLR) */
+static inline uint32_t read_l2ctlr(void)
+{
+	uint32_t val = 0;
+
+	asm volatile ("mrc p15, 1, %0, c9, c0, 2" : "=r" (val));
+
+	return val;
+}
+
+/* write L2 control register (L2CTLR) */
+static inline void write_l2ctlr(uint32_t val)
+{
+	/*
+	 * Note: L2CTLR can only be written when the L2 memory system
+	 * is idle, ie before the MMU is enabled.
+	 */
+	asm volatile("mcr p15, 1, %0, c9, c0, 2" : : "r" (val) : "memory");
+	isb();
+}
+
 /*
  * Workaround for ARM errata # 798870
  * Set L2ACTLR[7] to reissue any memory transaction in the L2 that has been
diff --git a/arch/arm/include/asm/armv8/mmu.h b/arch/arm/include/asm/armv8/mmu.h
index a34990368e..765914c7e2 100644
--- a/arch/arm/include/asm/armv8/mmu.h
+++ b/arch/arm/include/asm/armv8/mmu.h
@@ -8,15 +8,6 @@
 #ifndef _ASM_ARMV8_MMU_H_
 #define _ASM_ARMV8_MMU_H_
 
-/***************************************************************/
-/*
- * The following definitions are related each other, shoud be
- * calculated specifically.
- */
-
-#define VA_BITS			CONFIG_SYS_VA_BITS
-#define PTE_BLOCK_BITS		CONFIG_SYS_PTL2_BITS
-
 /*
  * block/section address mask and size definitions.
  */
@@ -25,7 +16,7 @@
 #undef  PAGE_SIZE
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(1 << PAGE_SHIFT)
-#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define PAGE_MASK		(~(PAGE_SIZE - 1))
 
 /***************************************************************/
 
@@ -52,6 +43,7 @@
 #define PTE_TYPE_MASK		(3 << 0)
 #define PTE_TYPE_FAULT		(0 << 0)
 #define PTE_TYPE_TABLE		(3 << 0)
+#define PTE_TYPE_PAGE		(3 << 0)
 #define PTE_TYPE_BLOCK		(1 << 0)
 #define PTE_TYPE_VALID		(1 << 0)
 
diff --git a/arch/arm/include/asm/config.h b/arch/arm/include/asm/config.h
index 5674d37c04..9f17829381 100644
--- a/arch/arm/include/asm/config.h
+++ b/arch/arm/include/asm/config.h
@@ -10,10 +10,6 @@
 #define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
-#ifdef CONFIG_ARM64
-#define CONFIG_STATIC_RELA
-#endif
-
 #if defined(CONFIG_ARCH_LS1021A) || \
 	defined(CONFIG_CPU_PXA27X) || \
 	defined(CONFIG_CPU_MONAHANS) || \
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index a5821f54e5..287466800e 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -8,13 +8,9 @@
 #ifndef __ASM_ARM_DMA_MAPPING_H
 #define __ASM_ARM_DMA_MAPPING_H
 
-#define	dma_mapping_error(x, y)	0
+#include <linux/dma-direction.h>
 
-enum dma_data_direction {
-	DMA_BIDIRECTIONAL	= 0,
-	DMA_TO_DEVICE		= 1,
-	DMA_FROM_DEVICE		= 2,
-};
+#define	dma_mapping_error(x, y)	0
 
 static inline void *dma_alloc_coherent(size_t len, unsigned long *handle)
 {
diff --git a/arch/arm/include/asm/global_data.h b/arch/arm/include/asm/global_data.h
index 3cc0e5fa34..6cd3a6b275 100644
--- a/arch/arm/include/asm/global_data.h
+++ b/arch/arm/include/asm/global_data.h
@@ -36,7 +36,8 @@ struct arch_global_data {
 	unsigned int tbl;
 	unsigned long lastinc;
 	unsigned long long timer_reset_value;
-#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF) && \
+      defined(CONFIG_SPL_SYS_DCACHE_OFF))
 	unsigned long tlb_addr;
 	unsigned long tlb_size;
 #if defined(CONFIG_ARM64)
diff --git a/arch/arm/include/asm/io.h b/arch/arm/include/asm/io.h
index 5834f5b3dc..5df74728de 100644
--- a/arch/arm/include/asm/io.h
+++ b/arch/arm/include/asm/io.h
@@ -34,35 +34,6 @@ static inline void sync(void)
 {
 }
 
-/*
- * Given a physical address and a length, return a virtual address
- * that can be used to access the memory range with the caching
- * properties specified by "flags".
- */
-#define MAP_NOCACHE	(0)
-#define MAP_WRCOMBINE	(0)
-#define MAP_WRBACK	(0)
-#define MAP_WRTHROUGH	(0)
-
-static inline void *
-map_physmem(phys_addr_t paddr, unsigned long len, unsigned long flags)
-{
-	return (void *)((unsigned long)paddr);
-}
-
-/*
- * Take down a mapping set up by map_physmem().
- */
-static inline void unmap_physmem(void *vaddr, unsigned long flags)
-{
-
-}
-
-static inline phys_addr_t virt_to_phys(void * vaddr)
-{
-	return (phys_addr_t)((unsigned long)vaddr);
-}
-
 /*
  * Generic virtual read/write.  Note that we don't support half-word
  * read/writes.  We define __arch_*[bl] here, and leave __arch_*w
@@ -426,6 +397,7 @@ out:
 #endif	/* __mem_isa */
 #endif	/* __KERNEL__ */
 
+#include <asm-generic/io.h>
 #include <iotrace.h>
 
 #endif	/* __ASM_ARM_IO_H */
diff --git a/arch/arm/include/asm/macro.h b/arch/arm/include/asm/macro.h
index e1916f7705..61e90284ab 100644
--- a/arch/arm/include/asm/macro.h
+++ b/arch/arm/include/asm/macro.h
@@ -78,6 +78,17 @@ lr	.req	x30
 	b.eq	\el1_label
 .endm
 
+/*
+ * Branch if current processor is a Cortex-A35 core.
+ */
+.macro	branch_if_a35_core, xreg, a35_label
+	mrs	\xreg, midr_el1
+	lsr	\xreg, \xreg, #4
+	and	\xreg, \xreg, #0x00000FFF
+	cmp	\xreg, #0xD04		/* Cortex-A35 MPCore processor. */
+	b.eq	\a35_label
+.endm
+
 /*
  * Branch if current processor is a Cortex-A57 core.
  */
@@ -131,6 +142,7 @@ lr	.req	x30
 	/* NOTE: MPIDR handling will be erroneous on multi-cluster machines */
 	mrs	\xreg1, mpidr_el1
 	lsr	\xreg2, \xreg1, #32
+	lsl	\xreg2, \xreg2, #32
 	lsl	\xreg1, \xreg1, #40
 	lsr	\xreg1, \xreg1, #40
 	orr	\xreg1, \xreg1, \xreg2
diff --git a/arch/arm/include/asm/proc-armv/ptrace.h b/arch/arm/include/asm/proc-armv/ptrace.h
index 71df5a9e25..6137047504 100644
--- a/arch/arm/include/asm/proc-armv/ptrace.h
+++ b/arch/arm/include/asm/proc-armv/ptrace.h
@@ -21,6 +21,20 @@
  * on the stack during an exception.
  */
 struct pt_regs {
+	/*
+	 * system register
+	 *
+	 * Note: never change order! see "_exception_entry" and "exception_exit"
+	 */
+	unsigned long ttbr0;
+	unsigned long hcr;	/* hcr_el2/scr_el3 */
+	unsigned long sctlr;
+	unsigned long sp;
+	unsigned long spsr;
+	unsigned long vbar;
+	unsigned long daif;
+	unsigned long esr;
+
 	unsigned long elr;
 	unsigned long regs[31];
 };
diff --git a/arch/arm/include/asm/setjmp.h b/arch/arm/include/asm/setjmp.h
index c3399a7e15..517beebdea 100644
--- a/arch/arm/include/asm/setjmp.h
+++ b/arch/arm/include/asm/setjmp.h
@@ -1,6 +1,6 @@
 /*
- * (C) Copyright 2016
- * Alexander Graf <agraf@suse.de>
+ * (C) Copyright 2017 Theobroma Systems Design und Consulting GmbH
+ * (C) Copyright 2016 Alexander Graf <agraf@suse.de>
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -8,89 +8,21 @@
 #ifndef _SETJMP_H_
 #define _SETJMP_H_	1
 
+/*
+ * This really should be opaque, but the EFI implementation wrongly
+ * assumes that a 'struct jmp_buf_data' is defined.
+ */
 struct jmp_buf_data {
-	ulong target;
-	ulong regs[5];
-	int ret;
-};
-
-typedef struct jmp_buf_data jmp_buf[1];
-
-static inline int setjmp(jmp_buf jmp)
-{
-	jmp->ret = 0;
-
-#ifdef CONFIG_ARM64
-	asm volatile(
-		"adr x1, jmp_target\n"
-		"str x1, %0\n"
-		"stp x26, x27, %1\n"
-		"stp x28, x29, %2\n"
-		"mov x1, sp\n"
-		"str x1, %3\n"
-		"jmp_target: "
-		: "=m" (jmp->target), "=m" (jmp->regs[0]),
-		  "=m" (jmp->regs[2]), "=m" (jmp->regs[4])
-		:
-		: "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
-		  "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
-		  "x16", "x17", "x18", "x19", "x20", "x21", "x22",
-		  "x23", "x24", "x25", /* x26, x27, x28, x29, sp */
-		  "x30", "cc", "memory");
-#else
-	asm volatile(
-#if CONFIG_IS_ENABLED(SYS_THUMB_BUILD)
-		".align 2\n"
-		"adr r0, jmp_target\n"
-		"add r0, r0, $1\n"
+#if defined(__aarch64__)
+	u64  regs[13];
 #else
-		"adr r0, jmp_target\n"
-#endif
-		"mov r1, %0\n"
-		"mov r2, sp\n"
-		"stm r1!, {r0, r2, r4, r5, r6, r7}\n"
-		".align 2\n"
-		"jmp_target: \n"
-		:
-		: "l" (&jmp->target)
-		: "r0", "r1", "r2", "r3", /* "r4", "r5", "r6", "r7", */
-		  "r8", "r9", "r10", "r11", /* sp, */ "ip", "lr",
-		  "cc", "memory");
-#endif
-
-	return jmp->ret;
-}
-
-static inline __noreturn void longjmp(jmp_buf jmp, int ret)
-{
-	jmp->ret = ret;
-
-#ifdef CONFIG_ARM64
-	asm volatile(
-		"ldr x0, %0\n"
-		"ldr x1, %3\n"
-		"mov sp, x1\n"
-		"ldp x26, x27, %1\n"
-		"ldp x28, x25, %2\n"
-		"mov x29, x25\n"
-		"br x0\n"
-		:
-		: "m" (jmp->target), "m" (jmp->regs[0]), "m" (jmp->regs[2]),
-		  "m" (jmp->regs[4])
-		: "x0", "x1", "x25", "x26", "x27", "x28");
-#else
-	asm volatile(
-		"mov r1, %0\n"
-		"ldm r1!, {r0, r2, r4, r5, r6, r7}\n"
-		"mov sp, r2\n"
-		"bx r0\n"
-		:
-		: "l" (&jmp->target)
-		: "r1");
+	u32  regs[10];  /* r4-r9, sl, fp, sp, lr */
 #endif
+};
 
-	while (1) { }
-}
+typedef struct jmp_buf_data jmp_buf[1];
 
+int setjmp(jmp_buf jmp);
+void longjmp(jmp_buf jmp, int ret);
 
 #endif /* _SETJMP_H_ */
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index 3a4e902af1..97e38b43b0 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -30,7 +30,7 @@
  *  - this structure is relatively short-lived - only
  *    guaranteed to contain useful data in setup_arch()
  */
-#define COMMAND_LINE_SIZE 1024
+#define COMMAND_LINE_SIZE 2048
 
 /* This is the old deprecated way to pass parameters to the kernel */
 struct param_struct {
diff --git a/arch/arm/include/asm/spl.h b/arch/arm/include/asm/spl.h
index df45511699..45ed028e13 100644
--- a/arch/arm/include/asm/spl.h
+++ b/arch/arm/include/asm/spl.h
@@ -31,6 +31,10 @@ enum {
 	BOOT_DEVICE_DFU,
 	BOOT_DEVICE_XIP,
 	BOOT_DEVICE_BOOTROM,
+	BOOT_DEVICE_MTD_BLK_NAND,
+	BOOT_DEVICE_MTD_BLK_SPI_NAND,
+	BOOT_DEVICE_MTD_BLK_SPI_NOR,
+	BOOT_DEVICE_RKNAND,
 	BOOT_DEVICE_NONE
 };
 #endif
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index 79bd19af7d..795d82d6fe 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -78,6 +78,10 @@
 #define HCR_EL2_RW_AARCH64	(1 << 31) /* EL1 is AArch64                   */
 #define HCR_EL2_RW_AARCH32	(0 << 31) /* Lower levels are AArch32         */
 #define HCR_EL2_HCD_DIS		(1 << 29) /* Hypervisor Call disabled         */
+#define HCR_EL2_TGE		(1 << 27) /* Trap General Exceptions          */
+#define HCR_EL2_AMO		(1 << 5)  /* Asynchronous External Abort and SError Interrupt routing */
+#define HCR_EL2_IMO		(1 << 4)  /* Physical IRQ Routing */
+#define HCR_EL2_FMO		(1 << 3)  /* Physical FIQ Routing */
 
 /*
  * CPACR_EL1 bits definitions
@@ -175,6 +179,20 @@ static inline unsigned long read_mpidr(void)
 	return val;
 }
 
+static inline unsigned long get_daif(void)
+{
+	unsigned long daif;
+
+	asm volatile("mrs %0, daif" : "=r" (daif));
+
+	return daif;
+}
+
+static inline void disable_serror(void)
+{
+	asm volatile("msr daifset, #0x04");
+}
+
 #define BSP_COREID	0
 
 void __asm_flush_dcache_all(void);
@@ -332,37 +350,6 @@ void psci_arch_init(void);
 
 #ifndef __ASSEMBLY__
 
-/**
- * save_boot_params() - Save boot parameters before starting reset sequence
- *
- * If you provide this function it will be called immediately U-Boot starts,
- * both for SPL and U-Boot proper.
- *
- * All registers are unchanged from U-Boot entry. No registers need be
- * preserved.
- *
- * This is not a normal C function. There is no stack. Return by branching to
- * save_boot_params_ret.
- *
- * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3);
- */
-
-/**
- * save_boot_params_ret() - Return from save_boot_params()
- *
- * If you provide save_boot_params(), then you should jump back to this
- * function when done. Try to preserve all registers.
- *
- * If your implementation of save_boot_params() is in C then it is acceptable
- * to simply call save_boot_params_ret() at the end of your function. Since
- * there is no link register set up, you cannot just exit the function. U-Boot
- * will return to the (initialised) value of lr, and likely crash/hang.
- *
- * If your implementation of save_boot_params() is in assembler then you
- * should use 'b' or 'bx' to return to save_boot_params_ret.
- */
-void save_boot_params_ret(void);
-
 #ifdef CONFIG_ARMV7_LPAE
 void switch_to_hypervisor_ret(void);
 #endif
@@ -383,6 +370,20 @@ static inline unsigned long get_cpsr(void)
 	return cpsr;
 }
 
+static inline void set_cpsr(unsigned long cpsr)
+{
+	asm volatile("msr cpsr_fsxc, %[cpsr]" : : [cpsr] "r" (cpsr));
+}
+
+static inline void disable_async_abort(void)
+{
+	unsigned long cpsr;
+
+	cpsr = get_cpsr();
+	cpsr &= ~(1 << 8);
+	set_cpsr(cpsr);
+}
+
 static inline int is_hyp(void)
 {
 #ifdef CONFIG_ARMV7_LPAE
@@ -436,6 +437,14 @@ static inline void set_dacr(unsigned int val)
 	isb();
 }
 
+static inline unsigned int read_mpidr(void)
+{
+	unsigned int mpidr;
+
+	asm volatile ("mrc p15, 0, %[mpidr], c0, c0, 5" : [mpidr] "=r" (mpidr));
+	return mpidr;
+}
+
 #ifdef CONFIG_ARMV7_LPAE
 /* Long-Descriptor Translation Table Level 1/2 Bits */
 #define TTB_SECT_XN_MASK	(1ULL << 54)
@@ -555,6 +564,37 @@ void mmu_page_table_flush(unsigned long start, unsigned long stop);
 #endif /* CONFIG_ARM64 */
 
 #ifndef __ASSEMBLY__
+/**
+ * save_boot_params() - Save boot parameters before starting reset sequence
+ *
+ * If you provide this function it will be called immediately U-Boot starts,
+ * both for SPL and U-Boot proper.
+ *
+ * All registers are unchanged from U-Boot entry. No registers need be
+ * preserved.
+ *
+ * This is not a normal C function. There is no stack. Return by branching to
+ * save_boot_params_ret.
+ *
+ * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3);
+ */
+
+/**
+ * save_boot_params_ret() - Return from save_boot_params()
+ *
+ * If you provide save_boot_params(), then you should jump back to this
+ * function when done. Try to preserve all registers.
+ *
+ * If your implementation of save_boot_params() is in C then it is acceptable
+ * to simply call save_boot_params_ret() at the end of your function. Since
+ * there is no link register set up, you cannot just exit the function. U-Boot
+ * will return to the (initialised) value of lr, and likely crash/hang.
+ *
+ * If your implementation of save_boot_params() is in assembler then you
+ * should use 'b' or 'bx' to return to save_boot_params_ret.
+ */
+void save_boot_params_ret(void);
+
 /**
  * Change the cache settings for a region.
  *
diff --git a/arch/arm/include/asm/u-boot-arm.h b/arch/arm/include/asm/u-boot-arm.h
index ef4fca68ee..724b55025d 100644
--- a/arch/arm/include/asm/u-boot-arm.h
+++ b/arch/arm/include/asm/u-boot-arm.h
@@ -38,7 +38,7 @@ int	arch_early_init_r(void);
 
 /* board/.../... */
 int	board_init(void);
-void	board_quiesce_devices(void);
+void	board_quiesce_devices(void *images);
 
 /* cpu/.../interrupt.c */
 int	arch_interrupt_init	(void);
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 6e1c436933..1cba844c5f 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -17,7 +17,13 @@ else
 obj-y	+= vectors.o crt0.o
 endif
 
-ifndef CONFIG_SPL_BUILD
+ifdef CONFIG_ARM64
+obj-y   += setjmp_aarch64.o
+else
+obj-y   += setjmp.o
+endif
+
+ifndef CONFIG_TPL_BUILD
 ifdef CONFIG_ARM64
 obj-y	+= relocate_64.o
 else
@@ -49,8 +55,10 @@ ifneq ($(CONFIG_GICV2)$(CONFIG_GICV3),)
 obj-y	+= gic_64.o
 endif
 obj-y	+= interrupts_64.o
+obj-y	+= stacktrace_64.o
 else
 obj-y	+= interrupts.o
+obj-y	+= stacktrace.o
 endif
 ifndef CONFIG_SYSRESET
 obj-y	+= reset.o
diff --git a/arch/arm/lib/bootm-fdt.c b/arch/arm/lib/bootm-fdt.c
index eaa817b9ac..af4797445f 100644
--- a/arch/arm/lib/bootm-fdt.c
+++ b/arch/arm/lib/bootm-fdt.c
@@ -22,21 +22,48 @@
 #endif
 #include <asm/psci.h>
 #include <asm/spin_table.h>
+#include <bidram.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_FMAN_ENET
+__weak int fdt_update_ethernet_dt(void *blob)
+{
+	return 0;
+}
+#endif
+
+__weak int board_fdt_fixup(void *blob)
+{
+	return 0;
+}
+
 int arch_fixup_fdt(void *blob)
 {
 	int ret = 0;
+
+	ret = board_fdt_fixup(blob);
+	if (ret)
+		return ret;
+
 #if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_OF_LIBFDT)
 	bd_t *bd = gd->bd;
 	int bank;
 	u64 start[CONFIG_NR_DRAM_BANKS];
 	u64 size[CONFIG_NR_DRAM_BANKS];
 
+#ifdef CONFIG_BIDRAM
+	bidram_fixup();
+#endif
 	for (bank = 0; bank < CONFIG_NR_DRAM_BANKS; bank++) {
 		start[bank] = bd->bi_dram[bank].start;
 		size[bank] = bd->bi_dram[bank].size;
+		if (size[bank] == 0)
+			continue;
+#ifdef CONFIG_ARCH_FIXUP_FDT_MEMORY
+		printf("Adding bank: 0x%08llx - 0x%08llx (size: 0x%08llx)\n",
+		       start[bank], start[bank] + size[bank], size[bank]);
+#endif
 #ifdef CONFIG_ARMV7_NONSEC
 		ret = armv7_apply_memory_carveout(&start[bank], &size[bank]);
 		if (ret)
@@ -64,5 +91,10 @@ int arch_fixup_fdt(void *blob)
 #endif
 #endif
 
+#ifdef CONFIG_FMAN_ENET
+	ret = fdt_update_ethernet_dt(blob);
+	if (ret)
+		return ret;
+#endif
 	return 0;
 }
diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
index 5c62d9c144..2da3ce3a32 100644
--- a/arch/arm/lib/bootm.c
+++ b/arch/arm/lib/bootm.c
@@ -14,12 +14,13 @@
 
 #include <common.h>
 #include <command.h>
+#include <amp.h>
 #include <dm.h>
 #include <dm/root.h>
 #include <image.h>
 #include <u-boot/zlib.h>
 #include <asm/byteorder.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <mapmem.h>
 #include <fdt_support.h>
 #include <asm/bootm.h>
@@ -32,6 +33,7 @@
 #include <asm/armv7.h>
 #endif
 #include <asm/setup.h>
+#include <asm/arch-rockchip/rockchip_smccc.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -64,10 +66,10 @@ void arch_lmb_reserve(struct lmb *lmb)
 	/* adjust sp by 4K to be safe */
 	sp -= 4096;
 	lmb_reserve(lmb, sp,
-		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
+		    gd->ram_top - sp);
 }
 
-__weak void board_quiesce_devices(void)
+__weak void board_quiesce_devices(void *images)
 {
 }
 
@@ -76,10 +78,10 @@ __weak void board_quiesce_devices(void)
  *
  * @fake: non-zero to do everything except actually boot
  */
-static void announce_and_cleanup(int fake)
+static void announce_and_cleanup(bootm_headers_t *images, int fake)
 {
-	printf("\nStarting kernel ...%s\n\n", fake ?
-		"(fake run for tracing)" : "");
+	ulong us;
+
 	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_HANDOFF, "start_kernel");
 #ifdef CONFIG_BOOTSTAGE_FDT
 	bootstage_fdt_add_report();
@@ -92,7 +94,10 @@ static void announce_and_cleanup(int fake)
 	udc_disconnect();
 #endif
 
-	board_quiesce_devices();
+	board_quiesce_devices(images);
+
+	/* Flush all console data */
+	flushc();
 
 	/*
 	 * Call remove function of all devices with a removal flag set.
@@ -102,6 +107,12 @@ static void announce_and_cleanup(int fake)
 	dm_remove_devices_flags(DM_REMOVE_ACTIVE_ALL);
 
 	cleanup_before_linux();
+
+	us = (get_ticks() - gd->sys_start_tick) / (COUNTER_FREQUENCY / 1000000);
+	printf("Total: %ld.%ld ms\n", us / 1000, us % 1000);
+
+	printf("\nStarting kernel ...%s\n\n", fake ?
+		"(fake run for tracing)" : "");
 }
 
 static void setup_start_tag (bd_t *bd)
@@ -308,6 +319,57 @@ static void switch_to_el1(void)
 #endif
 #endif
 
+#ifdef CONFIG_ARM64_SWITCH_TO_AARCH32
+static int arm64_switch_aarch32(bootm_headers_t *images)
+{
+	void *fdt = images->ft_addr;
+	ulong mpidr;
+	int ret, es_flag;
+	int nodeoff, tmp;
+	int num = -1;
+
+	/* arm aarch32 SVC */
+	images->os.arch = IH_ARCH_ARM;
+	es_flag = PE_STATE(0, 0, 0, 0);
+
+	nodeoff = fdt_path_offset(fdt, "/cpus");
+	if (nodeoff < 0) {
+		printf("couldn't find /cpus\n");
+		return nodeoff;
+	}
+
+	/* config all nonboot cpu state */
+	for (tmp = fdt_first_subnode(fdt, nodeoff);
+	     tmp >= 0;
+	     tmp = fdt_next_subnode(fdt, tmp)) {
+		const struct fdt_property *prop;
+		int len;
+
+		prop = fdt_get_property(fdt, tmp, "device_type", &len);
+		if (!prop)
+			continue;
+		if (len < 4)
+			continue;
+		if (strcmp(prop->data, "cpu"))
+			continue;
+		/* skip boot(first) cpu */
+		num++;
+		if (num == 0)
+			continue;
+
+		mpidr = (ulong)fdtdec_get_addr_size_auto_parent(fdt,
+					nodeoff, tmp, "reg", 0, NULL, false);
+		ret = sip_smc_amp_cfg(AMP_PE_STATE, mpidr, es_flag, 0);
+		if (ret) {
+			printf("CPU@%lx init AArch32 failed: %d\n", mpidr, ret);
+			continue;
+		}
+	}
+
+	return es_flag;
+}
+#endif
+
 /* Subcommand: GO */
 static void boot_jump_linux(bootm_headers_t *images, int flag)
 {
@@ -315,7 +377,13 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 	void (*kernel_entry)(void *fdt_addr, void *res0, void *res1,
 			void *res2);
 	int fake = (flag & BOOTM_STATE_OS_FAKE_GO);
+	int es_flag = 0;
 
+#if defined(CONFIG_AMP)
+	es_flag = arm64_switch_amp_pe(images);
+#elif defined(CONFIG_ARM64_SWITCH_TO_AARCH32)
+	es_flag = arm64_switch_aarch32(images);
+#endif
 	kernel_entry = (void (*)(void *fdt_addr, void *res0, void *res1,
 				void *res2))images->ep;
 
@@ -323,7 +391,7 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 		(ulong) kernel_entry);
 	bootstage_mark(BOOTSTAGE_ID_RUN_OS);
 
-	announce_and_cleanup(fake);
+	announce_and_cleanup(images, fake);
 
 	if (!fake) {
 #ifdef CONFIG_ARMV8_PSCI
@@ -340,11 +408,11 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 		if ((IH_ARCH_DEFAULT == IH_ARCH_ARM64) &&
 		    (images->os.arch == IH_ARCH_ARM))
 			armv8_switch_to_el2(0, (u64)gd->bd->bi_arch_number,
-					    (u64)images->ft_addr, 0,
+					    (u64)images->ft_addr, es_flag,
 					    (u64)images->ep,
 					    ES_TO_AARCH32);
 		else
-			armv8_switch_to_el2((u64)images->ft_addr, 0, 0, 0,
+			armv8_switch_to_el2((u64)images->ft_addr, 0, 0, es_flag,
 					    images->ep,
 					    ES_TO_AARCH64);
 #endif
@@ -373,7 +441,7 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 	debug("## Transferring control to Linux (at address %08lx)" \
 		"...\n", (ulong) kernel_entry);
 	bootstage_mark(BOOTSTAGE_ID_RUN_OS);
-	announce_and_cleanup(fake);
+	announce_and_cleanup(images, fake);
 
 	if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len)
 		r2 = (unsigned long)images->ft_addr;
diff --git a/arch/arm/lib/cache-cp15.c b/arch/arm/lib/cache-cp15.c
index f0c1b03728..cd962effdd 100644
--- a/arch/arm/lib/cache-cp15.c
+++ b/arch/arm/lib/cache-cp15.c
@@ -107,12 +107,30 @@ __weak void dram_bank_mmu_setup(int bank)
 /* to activate the MMU we need to set up virtual memory: use 1M areas */
 static inline void mmu_setup(void)
 {
-	int i;
+	int i, end;
 	u32 reg;
 
+#ifndef CONFIG_SPL_BUILD
+	/* bootrom and ddr didn't initial dcache,
+	 * skip this to save boot time.
+	 */
 	arm_init_before_mmu();
+#endif
+
+	/*
+	 * SPL thunder-boot:
+	 * only map periph device region to save boot time.
+	 */
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_KERNEL_BOOT) && \
+    defined(CONFIG_PERIPH_DEVICE_START_ADDR)
+	i = CONFIG_PERIPH_DEVICE_START_ADDR >> MMU_SECTION_SHIFT;
+	end = CONFIG_PERIPH_DEVICE_END_ADDR >> MMU_SECTION_SHIFT;
+#else
+	i = 0;
+	end = (4096ULL * 1024 * 1024) >> MMU_SECTION_SHIFT;
+#endif
 	/* Set up an identity-mapping for all 4GB, rw for everyone */
-	for (i = 0; i < ((4096ULL * 1024 * 1024) >> MMU_SECTION_SHIFT); i++)
+	for (; i < end; i++)
 		set_section_dcache(i, DCACHE_OFF);
 
 	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
diff --git a/arch/arm/lib/crt0.S b/arch/arm/lib/crt0.S
index fa81317717..4e34d28218 100644
--- a/arch/arm/lib/crt0.S
+++ b/arch/arm/lib/crt0.S
@@ -70,7 +70,9 @@ ENTRY(_main)
  * Set up initial C runtime environment and call board_init_f(0).
  */
 
-#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
+#if defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_NEEDS_SEPARATE_STACK)
+	ldr	r0, =(CONFIG_TPL_STACK)
+#elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
 	ldr	r0, =(CONFIG_SPL_STACK)
 #else
 	ldr	r0, =(CONFIG_SYS_INIT_SP_ADDR)
@@ -82,8 +84,8 @@ ENTRY(_main)
 	/* set up gd here, outside any C code */
 	mov	r9, r0
 	bl	board_init_f_init_reserve
+	bl	board_init_f_boot_flags
 
-	mov	r0, #0
 	bl	board_init_f
 
 #if ! defined(CONFIG_SPL_BUILD)
@@ -100,6 +102,7 @@ ENTRY(_main)
 	ldr	r9, [r9, #GD_BD]		/* r9 = gd->bd */
 	sub	r9, r9, #GD_SIZE		/* new GD is below bd */
 
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
 	adr	lr, here
 	ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd->reloc_off */
 	add	lr, lr, r0
@@ -108,18 +111,30 @@ ENTRY(_main)
 #endif
 	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
 	b	relocate_code
+#endif
 here:
+
 /*
- * now relocate vectors
+ * The "relocate_vectors" is in section: .text.relocate_vectors, if we don't
+ * compile "bl	relocate_vectors", there seems something wrong about sections
+ * layout(U-Boot code section is quite large, I don't find root cause now),
+ * so let's just skip it.
  */
+#ifdef CONFIG_SKIP_RELOCATE_UBOOT
+	b	c_runtime
+#endif
 
+/*
+ * now relocate vectors
+ */
 	bl	relocate_vectors
 
+c_runtime:
 /* Set up final (full) environment */
 
 	bl	c_runtime_cpu_setup	/* we still call old routine here */
 #endif
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)
+#if !defined(CONFIG_SPL_BUILD) || (defined(CONFIG_SPL_FRAMEWORK) && !defined(CONFIG_TPL_BUILD))
 # ifdef CONFIG_SPL_BUILD
 	/* Use a DRAM stack for the rest of SPL, if requested */
 	bl	spl_relocate_stack_gd
diff --git a/arch/arm/lib/crt0_64.S b/arch/arm/lib/crt0_64.S
index 62fad452b2..27e22f9d0a 100644
--- a/arch/arm/lib/crt0_64.S
+++ b/arch/arm/lib/crt0_64.S
@@ -13,6 +13,7 @@
 #include <config.h>
 #include <asm-offsets.h>
 #include <asm/macro.h>
+#include <asm/system.h>
 #include <linux/linkage.h>
 
 /*
@@ -65,6 +66,42 @@
  */
 
 ENTRY(_main)
+	/*
+	 * Enable instruction cache (if required), stack pointer,
+	 * data access alignment checks and SError.
+	 */
+#ifdef CONFIG_SPL_BUILD
+	mov x1, #CR_I
+#else
+	mov x1, #0
+#endif
+	switch_el x2, 3f, 2f, 1f
+3:	mrs	x0, sctlr_el3
+	orr	x0, x0, x1
+	msr	sctlr_el3, x0
+#ifndef CONFIG_SUPPORT_USBPLUG
+	msr	daifclr, #4			/* Enable SError. SCR_EL3.EA=1 was already set in start.S */
+#endif
+	b	0f
+2:	mrs	x0, sctlr_el2
+	orr	x0, x0, x1
+	msr	sctlr_el2, x0
+
+	mrs	x0, hcr_el2
+	orr	x0, x0, #HCR_EL2_TGE
+	orr	x0, x0, #HCR_EL2_AMO
+#if CONFIG_IS_ENABLED(IRQ)
+	orr	x0, x0, #HCR_EL2_IMO
+#endif
+	msr	hcr_el2, x0
+	msr	daifclr, #4
+	b	0f
+1:	mrs	x0, sctlr_el1
+	orr	x0, x0, x1
+	msr	sctlr_el1, x0
+	msr	daifclr, #4
+0:
+	isb
 
 /*
  * Set up initial C runtime environment and call board_init_f(0).
@@ -83,11 +120,12 @@ ENTRY(_main)
 	/* set up gd here, outside any C code */
 	mov	x18, x0
 	bl	board_init_f_init_reserve
+	bl	board_init_f_boot_flags
 
-	mov	x0, #0
 	bl	board_init_f
 
-#if !defined(CONFIG_SPL_BUILD)
+#if (defined(CONFIG_SPL_BUILD) && !defined(CONFIG_TPL_BUILD) && !defined(CONFIG_SPL_SKIP_RELOCATE)) || \
+	!defined(CONFIG_SPL_BUILD)
 /*
  * Set up intermediate environment (new sp and gd) and call
  * relocate_code(addr_moni). Trick here is that we'll return
@@ -95,14 +133,23 @@ ENTRY(_main)
  */
 	ldr	x0, [x18, #GD_START_ADDR_SP]	/* x0 <- gd->start_addr_sp */
 	bic	sp, x0, #0xf	/* 16-byte alignment for ABI compliance */
-	ldr	x18, [x18, #GD_BD]		/* x18 <- gd->bd */
-	sub	x18, x18, #GD_SIZE		/* new GD is below bd */
+	ldr	x18, [x18, #GD_NEW_GD]		/* x18 <- gd->new_gd */
 
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
 	adr	lr, relocation_return
+#if CONFIG_POSITION_INDEPENDENT
+	/* Add in link-vs-runtime offset */
+	adr	x0, _start		/* x0 <- Runtime value of _start */
+	ldr	x9, _TEXT_BASE		/* x9 <- Linked value of _start */
+	sub	x9, x9, x0		/* x9 <- Run-vs-link offset */
+	add	lr, lr, x9
+#endif
+	/* Add in link-vs-relocation offset */
 	ldr	x9, [x18, #GD_RELOC_OFF]	/* x9 <- gd->reloc_off */
 	add	lr, lr, x9	/* new return address after relocation */
 	ldr	x0, [x18, #GD_RELOCADDR]	/* x0 <- gd->relocaddr */
 	b	relocate_code
+#endif
 
 relocation_return:
 
@@ -113,6 +160,9 @@ relocation_return:
 #endif /* !CONFIG_SPL_BUILD */
 #if defined(CONFIG_SPL_BUILD)
 	bl	spl_relocate_stack_gd           /* may return NULL */
+	/* set up gd here, outside any C code, if new stack is returned */
+	cmp	x0, #0
+	csel	x18, x0, x18, ne
 	/*
 	 * Perform 'sp = (x0 != NULL) ? x0 : sp' while working
 	 * around the constraint that conditional moves can not
diff --git a/arch/arm/lib/gic_64.S b/arch/arm/lib/gic_64.S
index 62d0022408..0f0bc88c32 100644
--- a/arch/arm/lib/gic_64.S
+++ b/arch/arm/lib/gic_64.S
@@ -108,6 +108,50 @@ ENTRY(gic_init_secure_percpu)
 	mov	w11, #0x1		/* Enable SGI 0 */
 	str	w11, [x10, GICR_ISENABLERn]
 
+#if CONFIG_IS_ENABLED(IRQ)
+	/* Rockchip: check elx */
+	switch_el x0, el3_sre, el2_sre, el1_sre
+
+	/* Initialize Cpu Interface */
+el3_sre:
+	mrs	x10, ICC_SRE_EL3
+	orr	x10, x10, #0xf		/* SRE & Disable IRQ/FIQ Bypass & */
+					/* Allow EL2 access to ICC_SRE_EL2 */
+	msr	ICC_SRE_EL3, x10
+	isb
+
+el2_sre:
+	mrs	x10, ICC_SRE_EL2
+	orr	x10, x10, #0xf		/* SRE & Disable IRQ/FIQ Bypass & */
+					/* Allow EL1 access to ICC_SRE_EL1 */
+	msr	ICC_SRE_EL2, x10
+	isb
+
+el1_sre:
+	mrs	x0, CurrentEL		/* check currentEL */
+	cmp	x0, 0xC
+	b.ne	el1_ctlr		/* currentEL != EL3 */
+
+el3_ctlr:
+	mov	x10, #0x3		/* EnableGrp1NS | EnableGrp1S */
+	msr	ICC_IGRPEN1_EL3, x10
+	isb
+
+	msr	ICC_CTLR_EL3, xzr
+	isb
+
+el1_ctlr:
+	mov	x10, #0x3		/* EnableGrp1NS | EnableGrp1S */
+	msr	ICC_IGRPEN1_EL1, x10
+	isb
+
+	msr	ICC_CTLR_EL1, xzr	/* NonSecure ICC_CTLR_EL1 */
+	isb
+
+	mov	x10, #0xf0		/* Non-Secure access to ICC_PMR_EL1 */
+	msr	ICC_PMR_EL1, x10
+	isb
+#else
 	/* Initialize Cpu Interface */
 	mrs	x10, ICC_SRE_EL3
 	orr	x10, x10, #0xf		/* SRE & Disable IRQ/FIQ Bypass & */
@@ -134,6 +178,8 @@ ENTRY(gic_init_secure_percpu)
 	mov	x10, #0x1 << 7		/* Non-Secure access to ICC_PMR_EL1 */
 	msr	ICC_PMR_EL1, x10
 	isb
+#endif
+
 #elif defined(CONFIG_GICV2)
 	/*
 	 * Initialize SGIs and PPIs
diff --git a/arch/arm/lib/interrupts.c b/arch/arm/lib/interrupts.c
index 80869adb61..738b1fcefd 100644
--- a/arch/arm/lib/interrupts.c
+++ b/arch/arm/lib/interrupts.c
@@ -23,9 +23,12 @@
 #include <asm/proc-armv/ptrace.h>
 #include <asm/u-boot-arm.h>
 #include <efi_loader.h>
+#include <iomem.h>
+#include <stacktrace.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#if !CONFIG_IS_ENABLED(IRQ)
 int interrupt_init (void)
 {
 	/*
@@ -44,6 +47,7 @@ int disable_interrupts (void)
 {
 	return 0;
 }
+#endif
 
 void bad_mode (void)
 {
@@ -53,6 +57,7 @@ void bad_mode (void)
 
 void show_regs (struct pt_regs *regs)
 {
+	ulong pc, lr;
 	unsigned long __maybe_unused flags;
 	const char __maybe_unused *processor_modes[] = {
 	"USER_26",	"FIQ_26",	"IRQ_26",	"SVC_26",
@@ -67,15 +72,17 @@ void show_regs (struct pt_regs *regs)
 
 	flags = condition_codes (regs);
 
-	printf("pc : [<%08lx>]	   lr : [<%08lx>]\n",
-	       instruction_pointer(regs), regs->ARM_lr);
 	if (gd->flags & GD_FLG_RELOC) {
-		printf("reloc pc : [<%08lx>]	   lr : [<%08lx>]\n",
-		       instruction_pointer(regs) - gd->reloc_off,
-		       regs->ARM_lr - gd->reloc_off);
+		pc = instruction_pointer(regs) - gd->reloc_off;
+		lr = regs->ARM_lr - gd->reloc_off;
+	} else {
+		pc = instruction_pointer(regs);
+		lr = regs->ARM_lr;
 	}
-	printf("sp : %08lx  ip : %08lx	 fp : %08lx\n",
-	       regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+
+	printf ("pc : %08lx  lr : %08lx\n", pc, lr);
+	printf ("sp : %08lx  ip : %08lx	 fp : %08lx\n",
+	        regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
 	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
 		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
 	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
@@ -86,11 +93,20 @@ void show_regs (struct pt_regs *regs)
 		flags & CC_N_BIT ? 'N' : 'n',
 		flags & CC_Z_BIT ? 'Z' : 'z',
 		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
-	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
+	printf ("  IRQs %s  FIQs %s  Mode %s%s\n\n",
 		interrupts_enabled (regs) ? "on" : "off",
 		fast_interrupts_enabled (regs) ? "on" : "off",
 		processor_modes[processor_mode (regs)],
 		thumb_mode (regs) ? " (T)" : "");
+
+#ifdef CONFIG_ROCKCHIP_CRASH_DUMP
+	iomem_show_by_compatible("-cru", 0, 0x400);
+	iomem_show_by_compatible("-pmucru", 0, 0x400);
+	iomem_show_by_compatible("-grf", 0, 0x400);
+	iomem_show_by_compatible("-pmugrf", 0, 0x400);
+#endif
+
+	dump_core_stack(regs);
 }
 
 /* fixup PC to point to the instruction leading to the exception */
@@ -154,6 +170,7 @@ void do_fiq (struct pt_regs *pt_regs)
 	bad_mode ();
 }
 
+#if !CONFIG_IS_ENABLED(IRQ)
 void do_irq (struct pt_regs *pt_regs)
 {
 	efi_restore_gd();
@@ -162,3 +179,4 @@ void do_irq (struct pt_regs *pt_regs)
 	show_regs (pt_regs);
 	bad_mode ();
 }
+#endif
diff --git a/arch/arm/lib/interrupts_64.c b/arch/arm/lib/interrupts_64.c
index 7c9cfce69f..17271d061f 100644
--- a/arch/arm/lib/interrupts_64.c
+++ b/arch/arm/lib/interrupts_64.c
@@ -8,8 +8,12 @@
 #include <common.h>
 #include <linux/compiler.h>
 #include <efi_loader.h>
+#include <iomem.h>
+#include <stacktrace.h>
 
+DECLARE_GLOBAL_DATA_PTR;
 
+#if !CONFIG_IS_ENABLED(IRQ)
 int interrupt_init(void)
 {
 	return 0;
@@ -24,18 +28,108 @@ int disable_interrupts(void)
 {
 	return 0;
 }
+#endif
 
+#define REG_BITS(val, shift, mask)	(((val) >> (shift)) & (mask))
+
+#ifndef CONFIG_SPL_BUILD
 void show_regs(struct pt_regs *regs)
 {
+	int el = current_el();
 	int i;
 
-	printf("ELR:     %lx\n", regs->elr);
-	printf("LR:      %lx\n", regs->regs[30]);
+	const char *esr_bits_ec[] = {
+		[0]  = "an unknown reason",
+		[1]  = "a WFI or WFE instruction",
+		[3]  = "an MCR or MRC access",
+		[4]  = "an MCRR or MRRC access",
+		[5]  = "an MCR or MRC access",
+		[6]  = "an LDC or STC access to CP14",
+		[7]  = "an access to an Advanced SIMD or floating-point register, resulting from CPACR_EL1.FPEN or CPTR_ELx.TFP",
+		[8]  = "an MCR or MRC access",
+		[12] = "an MCRR or MRRC access",
+		[14] = "an Illegal execution state, or a PC or SP alignment fault",
+		[10] = "HVC or SVC instruction execution",
+		[18] = "HVC or SVC instruction execution",
+		[19] = "SMC instruction execution in AArch32 state",
+		[21] = "HVC or SVC instruction execution",
+		[22] = "HVC or SVC instruction execution",
+		[23] = "SMC instruction execution in AArch64 state",
+		[24] = "MSR, MRS, or System instruction execution in AArch64 state",
+		[31] = "IMPLEMENTATION DEFINED exception to EL3",
+		[32] = "an Instruction abort",
+		[33] = "an Instruction abort",
+		[34] = "an Illegal execution state, or a PC or SP alignment fault",
+		[36] = "a Data abort, from lower exception level",
+		[37] = "a Data abort, from current exception level",
+		[38] = "an Illegal execution state, or a PC or SP alignment fault",
+		[40] = "a trapped Floating-point exception",
+		[44] = "a trapped Floating-point exception",
+		[47] = "SError interrupt",
+		[48] = "a Breakpoint or Vector Catch debug event",
+		[49] = "a Breakpoint or Vector Catch debug event",
+		[50] = "a Software Step debug event",
+		[51] = "a Software Step debug event",
+		[52] = "a Watchpoint debug event",
+		[53] = "a Watchpoint debug event",
+		[56] = "execution of a Software Breakpoint instructio",
+	};
+
+	printf("\n");
+
+	/* PC/LR/SP ... */
+	printf("* Reason:        Exception from %s\n", esr_bits_ec[REG_BITS(regs->esr, 26, 0x3f)]);
+	if (gd->flags & GD_FLG_RELOC) {
+		printf("* PC         =   %016lx\n", regs->elr - gd->reloc_off);
+		printf("* LR         =   %016lx\n", regs->regs[30] - gd->reloc_off);
+	} else {
+		printf("* ELR(PC)    =   %016lx\n", regs->elr);
+		printf("* LR         =   %016lx\n", regs->regs[30]);
+	}
+	printf("* SP         =   %016lx\n", regs->sp);
+	printf("* ESR_EL%d    =   %016lx\n", el, regs->esr);
+	printf("* Reloc Off  =   %016lx\n\n", gd->reloc_off);
+
+	/* CPU */
 	for (i = 0; i < 29; i += 2)
 		printf("x%-2d: %016lx x%-2d: %016lx\n",
 		       i, regs->regs[i], i+1, regs->regs[i+1]);
 	printf("\n");
+
+	/* SoC */
+#ifdef CONFIG_ROCKCHIP_CRASH_DUMP
+	iomem_show_by_compatible("-cru", 0, 0x400);
+	iomem_show_by_compatible("-pmucru", 0, 0x400);
+	iomem_show_by_compatible("-grf", 0, 0x400);
+	iomem_show_by_compatible("-pmugrf", 0, 0x400);
+#endif
+	/* Call trace */
+	dump_core_stack(regs);
+}
+
+#else
+void show_regs(struct pt_regs *regs)
+{
+	int i;
+
+	if (gd->flags & GD_FLG_RELOC) {
+		printf("ELR:     %lx\n", regs->elr - gd->reloc_off);
+		printf("LR:      %lx\n", regs->regs[30] - gd->reloc_off);
+	} else {
+		printf("ELR:     %lx\n", regs->elr);
+		printf("LR:      %lx\n", regs->regs[30]);
+	}
+
+	printf("ESR:     %lx (ec=%ld)\n", regs->esr, REG_BITS(regs->esr, 26, 0x3f));
+
+	for (i = 0; i < 29; i += 2)
+		printf("x%-2d: %016lx x%-2d: %016lx\n",
+		       i, regs->regs[i], i+1, regs->regs[i+1]);
+	printf("\n");
+
+	dump_core_stack(regs);
 }
+#endif
 
 /*
  * do_bad_sync handles the impossible case in the Synchronous Abort vector.
@@ -92,6 +186,7 @@ void do_sync(struct pt_regs *pt_regs, unsigned int esr)
 	panic("Resetting CPU ...\n");
 }
 
+#if !CONFIG_IS_ENABLED(IRQ)
 /*
  * do_irq handles the Irq exception.
  */
@@ -102,6 +197,7 @@ void do_irq(struct pt_regs *pt_regs, unsigned int esr)
 	show_regs(pt_regs);
 	panic("Resetting CPU ...\n");
 }
+#endif
 
 /*
  * do_fiq handles the Fiq exception.
diff --git a/arch/arm/lib/psci-dt.c b/arch/arm/lib/psci-dt.c
index 05e0ad6e70..5502ea23c9 100644
--- a/arch/arm/lib/psci-dt.c
+++ b/arch/arm/lib/psci-dt.c
@@ -5,7 +5,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #include <linux/sizes.h>
 #include <linux/kernel.h>
diff --git a/arch/arm/lib/relocate_64.S b/arch/arm/lib/relocate_64.S
index c760053706..4c5da45599 100644
--- a/arch/arm/lib/relocate_64.S
+++ b/arch/arm/lib/relocate_64.S
@@ -27,11 +27,27 @@ ENTRY(relocate_code)
 	/*
 	 * Copy u-boot from flash to RAM
 	 */
-	ldr	x1, =__image_copy_start	/* x1 <- SRC &__image_copy_start */
-	subs	x9, x0, x1		/* x9 <- relocation offset */
-	b.eq	relocate_done		/* skip relocation */
-	ldr	x2, =__image_copy_end	/* x2 <- SRC &__image_copy_end */
+	adrp	x1, __image_copy_start		/* x1 <- address bits [31:12] */
+	add	x1, x1, :lo12:__image_copy_start/* x1 <- address bits [11:00] */
+	subs	x9, x0, x1			/* x9 <- Run to copy offset */
+	b.eq	relocate_done			/* skip relocation */
+	/*
+	 * Don't ldr x1, __image_copy_start here, since if the code is already
+	 * running at an address other than it was linked to, that instruction
+	 * will load the relocated value of __image_copy_start. To
+	 * correctly apply relocations, we need to know the linked value.
+	 *
+	 * Linked &__image_copy_start, which we know was at
+	 * CONFIG_SYS_TEXT_BASE, which is stored in _TEXT_BASE, as a non-
+	 * relocated value, since it isn't a symbol reference.
+	 */
+	ldr	x1, _TEXT_BASE		/* x1 <- Linked &__image_copy_start */
+	subs	x9, x0, x1		/* x9 <- Link to copy offset */
 
+	adrp	x1, __image_copy_start		/* x1 <- address bits [31:12] */
+	add	x1, x1, :lo12:__image_copy_start/* x1 <- address bits [11:00] */
+	adrp	x2, __image_copy_end		/* x2 <- address bits [31:12] */
+	add	x2, x2, :lo12:__image_copy_end	/* x2 <- address bits [11:00] */
 copy_loop:
 	ldp	x10, x11, [x1], #16	/* copy from source address [x1] */
 	stp	x10, x11, [x0], #16	/* copy to   target address [x0] */
@@ -42,8 +58,10 @@ copy_loop:
 	/*
 	 * Fix .rela.dyn relocations
 	 */
-	ldr	x2, =__rel_dyn_start	/* x2 <- SRC &__rel_dyn_start */
-	ldr	x3, =__rel_dyn_end	/* x3 <- SRC &__rel_dyn_end */
+	adrp	x2, __rel_dyn_start		/* x2 <- address bits [31:12] */
+	add	x2, x2, :lo12:__rel_dyn_start	/* x2 <- address bits [11:00] */
+	adrp	x3, __rel_dyn_end		/* x3 <- address bits [31:12] */
+	add	x3, x3, :lo12:__rel_dyn_end	/* x3 <- address bits [11:00] */
 fixloop:
 	ldp	x0, x1, [x2], #16	/* (x0,x1) <- (SRC location, fixup) */
 	ldr	x4, [x2], #8		/* x4 <- addend */
@@ -73,6 +91,6 @@ relocate_done:
 	isb	sy
 4:	ldp	x0, x1, [sp, #16]
 	bl	__asm_flush_dcache_range
-5:	ldp	x29, x30, [sp],#16
+5:	ldp	x29, x30, [sp],#32
 	ret
 ENDPROC(relocate_code)
diff --git a/arch/arm/lib/stack.c b/arch/arm/lib/stack.c
index 737622d26f..8aa49d7615 100644
--- a/arch/arm/lib/stack.c
+++ b/arch/arm/lib/stack.c
@@ -25,8 +25,16 @@ int arch_reserve_stacks(void)
 	gd->irq_sp = gd->start_addr_sp;
 
 # if !defined(CONFIG_ARM64)
+#if CONFIG_IS_ENABLED(IRQ)
+#ifndef CONFIG_IRQ_STACK_SIZE
+#define CONFIG_IRQ_STACK_SIZE	8192
+#endif
+	gd->start_addr_sp -= CONFIG_IRQ_STACK_SIZE;
+
+#else
 	/* leave 3 words for abort-stack, plus 1 for alignment */
 	gd->start_addr_sp -= 16;
+#endif
 # endif
 #endif
 
diff --git a/arch/arm/lib/vectors.S b/arch/arm/lib/vectors.S
index 101909103e..409be1002f 100644
--- a/arch/arm/lib/vectors.S
+++ b/arch/arm/lib/vectors.S
@@ -15,6 +15,22 @@
 
 #include <config.h>
 
+/*
+ * A macro to allow insertion of an ARM exception vector either
+ * for the non-boot0 case or by a boot0-header.
+ */
+        .macro ARM_VECTORS
+	b	reset
+	ldr	pc, _undefined_instruction
+	ldr	pc, _software_interrupt
+	ldr	pc, _prefetch_abort
+	ldr	pc, _data_abort
+	ldr	pc, _not_used
+	ldr	pc, _irq
+	ldr	pc, _fiq
+	.endm
+
+
 /*
  *************************************************************************
  *
@@ -35,6 +51,23 @@
 
 	.section ".vectors", "ax"
 
+#if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)
+/*
+ * Various SoCs need something special and SoC-specific up front in
+ * order to boot, allow them to set that in their boot0.h file and then
+ * use it here.
+ *
+ * To allow a boot0 hook to insert a 'special' sequence after the vector
+ * table (e.g. for the socfpga), the presence of a boot0 hook supresses
+ * the below vector table and assumes that the vector table is filled in
+ * by the boot0 hook.  The requirements for a boot0 hook thus are:
+ *   (1) defines '_start:' as appropriate
+ *   (2) inserts the vector table using ARM_VECTORS as appropriate
+ */
+#include <asm/arch/boot0.h>
+
+#else
+
 /*
  *************************************************************************
  *
@@ -46,28 +79,11 @@
  */
 
 _start:
-
 #ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
 	.word	CONFIG_SYS_DV_NOR_BOOT_CFG
 #endif
-
-	b	reset
-	ldr	pc, _undefined_instruction
-	ldr	pc, _software_interrupt
-	ldr	pc, _prefetch_abort
-	ldr	pc, _data_abort
-	ldr	pc, _not_used
-	ldr	pc, _irq
-	ldr	pc, _fiq
-
-#ifdef CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK
-/*
- * Various SoCs need something special and SoC-specific up front in
- * order to boot, allow them to set that in their boot0.h file and then
- * use it here.
- */
-#include <asm/arch/boot0.h>
-#endif
+	ARM_VECTORS
+#endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */
 
 /*
  *************************************************************************
@@ -131,6 +147,13 @@ IRQ_STACK_START_IN:
 	.word	0x0badc0de
 #endif
 
+#if CONFIG_IS_ENABLED(IRQ)
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+#endif
+
 @
 @ IRQ stack frame.
 @
@@ -156,6 +179,7 @@ IRQ_STACK_START_IN:
 #define S_R1		4
 #define S_R0		0
 
+#define MODE_IRQ 0x12
 #define MODE_SVC 0x13
 #define I_BIT	 0x80
 
@@ -183,7 +207,15 @@ IRQ_STACK_START_IN:
 	stmia	sp, {r0 - r12}			@ Calling r0-r12
 	@ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
 	add	r8, sp, #S_PC
-	stmdb	r8, {sp, lr}^		@ Calling SP, LR
+
+	cps	#MODE_SVC	@ SVC-Mode
+	isb
+	mov	r1, sp		@ svc_sp
+	mov	r2, lr		@ svc_lr
+	cps	#MODE_IRQ	@ IRQ-Mode
+	isb
+
+	stmdb	r8, {r1, r2}^		@ Calling svc_sp, svc_lr
 	str	lr, [r8, #0]		@ Save calling PC
 	mrs	r6, spsr
 	str	r6, [r8, #4]		@ Save CPSR
@@ -257,9 +289,16 @@ not_used:
 
 	.align	5
 irq:
+#if CONFIG_IS_ENABLED(IRQ)
+	get_irq_stack
+	irq_save_user_regs
+	bl	do_irq
+	irq_restore_user_regs
+#else
 	get_bad_stack
 	bad_save_user_regs
 	bl	do_irq
+#endif
 
 	.align	5
 fiq:
diff --git a/arch/arm/mach-rockchip/Kconfig b/arch/arm/mach-rockchip/Kconfig
index d9b25d5de4..72f3d15eb0 100644
--- a/arch/arm/mach-rockchip/Kconfig
+++ b/arch/arm/mach-rockchip/Kconfig
@@ -1,24 +1,117 @@
 if ARCH_ROCKCHIP
 
+config ROCKCHIP_PX30
+	bool "Support Rockchip PX30"
+	select ARM64 if !ARM64_BOOT_AARCH32
+	select GICV2
+	select ARM_SMCCC
+	select SUPPORT_SPL
+	select SUPPORT_TPL
+	select SPL if !ARM64_BOOT_AARCH32
+	select TPL if !ARM64_BOOT_AARCH32
+	select TPL_TINY_FRAMEWORK if TPL
+
+	imply SPL_SEPARATE_BSS
+	imply SPL_SERIAL_SUPPORT
+	imply TPL_SERIAL_SUPPORT
+	help
+	  The Rockchip PX30 is a ARM-based SoC with a quad-core Cortex-A35
+	  including NEON and GPU, Mali-400 graphics, several DDR3 options
+	  and video codec support. Peripherals include Gigabit Ethernet,
+	  USB2 host and OTG, SDIO, I2S, UART, SPI, I2C and PWMs.
+
+if ROCKCHIP_PX30
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl-v8.lds"
+
+config TPL_TEXT_BASE
+	default 0xff0e1000
+
+config TPL_MAX_SIZE
+	default 10240
+
+config ROCKCHIP_RK3326
+	bool "Support Rockchip RK3326 "
+	help
+	  RK3326 can use most code from PX30, but at some situations we have
+	  to distinguish between RK3326 and PX30, so this macro gives help.
+	  It is usually selected in rk3326 board defconfig.
+endif
+
 config ROCKCHIP_RK3036
 	bool "Support Rockchip RK3036"
 	select CPU_V7
 	select SUPPORT_SPL
+	select SUPPORT_TPL
 	select SPL
+	select TPL
+	select BOARD_LATE_INIT
+	select ROCKCHIP_BROM_HELPER
+	select TPL_NEEDS_SEPARATE_TEXT_BASE if TPL
+	select TPL_NEEDS_SEPARATE_STACK if TPL
+	select ARM_SMCCC
 	help
 	  The Rockchip RK3036 is a ARM-based SoC with a dual-core Cortex-A7
 	  including NEON and GPU, Mali-400 graphics, several DDR3 options
 	  and video codec support. Peripherals include Gigabit Ethernet,
 	  USB2 host and OTG, SDIO, I2S, UART, SPI, I2C and PWMs.
 
+config ROCKCHIP_RK3128
+	bool "Support Rockchip RK3128"
+	select CPU_V7
+	select GICV2
+	select ARM_SMCCC
+	help
+	  The Rockchip RK3128 is a ARM-based SoC with a quad-core Cortex-A7
+	  including NEON and GPU, Mali-400 graphics, several DDR3 options
+	  and video codec support. Peripherals include Gigabit Ethernet,
+	  USB2 host and OTG, SDIO, I2S, UART, SPI, I2C and PWMs.
+
+if ROCKCHIP_RK3128
+
+config ROCKCHIP_RK3126
+	bool "Support Rockchip RK3126 "
+	help
+	  RK3126 can use most code from RK3128, but at some situations we have
+	  to distinguish between RK3126 and RK3128, so this macro gives help.
+	  It is usually selected in rk3126 board defconfig.
+
+config ROCKCHIP_PX3SE
+	bool "Support Rockchip PX3SE"
+	help
+	  PX3SE is a variant of RK3128, it shares codes with RK3128, but we still
+	  need this macro to distinguish PX3SE and RK3128.
+endif
+
+config ROCKCHIP_RK3066
+	bool "Support Rockchip RK3066"
+	select CPU_V7
+	select SUPPORT_SPL
+	select SUPPORT_TPL
+	select SPL
+	select TPL
+	select BOARD_LATE_INIT
+	select ROCKCHIP_BROM_HELPER
+	select SPL_ROCKCHIP_EARLYRETURN_TO_BROM
+	help
+	  The Rockchip RK3066 is a ARM-based SoC with a dual-core Cortex-A9
+	  including NEON and GPU, Mali-400 graphics, several DDR3 options
+	  and video codec support. Peripherals include ethernet, USB2 host
+	  and OTG, SDIO, I2S, UART, SPI, I2C and PWMs.
+
 config ROCKCHIP_RK3188
 	bool "Support Rockchip RK3188"
 	select CPU_V7
 	select SPL_BOARD_INIT if SPL
 	select SUPPORT_SPL
-	select SUPPORT_TPL
 	select SPL
-	select TPL
+	select SPL_CLK
+	select SPL_REGMAP
+	select SPL_SYSCON
+	select SPL_RAM
+	select SPL_DRIVERS_MISC_SUPPORT
+	select SPL_ROCKCHIP_EARLYRETURN_TO_BROM
 	select BOARD_LATE_INIT
 	select ROCKCHIP_BROM_HELPER
 	help
@@ -32,21 +125,63 @@ config ROCKCHIP_RK322X
 	bool "Support Rockchip RK3228/RK3229"
 	select CPU_V7
 	select SUPPORT_SPL
+	select SUPPORT_TPL
 	select SPL
+	select TPL
+	select TPL_NEEDS_SEPARATE_TEXT_BASE if SPL
+	select TPL_NEEDS_SEPARATE_STACK if TPL
+	select SPL_DRIVERS_MISC_SUPPORT
+	imply SPL_SERIAL_SUPPORT
+	imply TPL_SERIAL_SUPPORT
 	select ROCKCHIP_BROM_HELPER
-	select DEBUG_UART_BOARD_INIT
+	select TPL_LIBCOMMON_SUPPORT
+	select TPL_LIBGENERIC_SUPPORT
+	select GICV2
+	select ARM_SMCCC
 	help
 	  The Rockchip RK3229 is a ARM-based SoC with a dual-core Cortex-A7
 	  including NEON and GPU, Mali-400 graphics, several DDR3 options
 	  and video codec support. Peripherals include Gigabit Ethernet,
 	  USB2 host and OTG, SDIO, I2S, UART, SPI, I2C and PWMs.
 
+if ROCKCHIP_RK322X
+
+config ROCKCHIP_RK3128X
+	bool "Support Rockchip RK3128X "
+	help
+	  RK3128X can use most code from RK322X, but at some situations we have
+	  to distinguish between RK3128X and RK322X, so this macro gives help.
+	  It is usually selected in RK3128X board defconfig.
+endif
+
 config ROCKCHIP_RK3288
 	bool "Support Rockchip RK3288"
 	select CPU_V7
 	select SPL_BOARD_INIT if SPL
 	select SUPPORT_SPL
+	select SUPPORT_TPL
 	select SPL
+	select TPL
+	select TPL_NEEDS_SEPARATE_TEXT_BASE if TPL
+	select TPL_NEEDS_SEPARATE_STACK if TPL
+	imply TPL_SERIAL_SUPPORT
+	select GICV2
+	select ARM_SMCCC
+	select SPL_OPTEE
+	select FIT
+	select SPL_LOAD_FIT
+	select TPL_LIBCOMMON_SUPPORT
+	select TPL_LIBGENERIC_SUPPORT
+	select TPL_SYS_MALLOC_SIMPLE
+	select TPL_BOOTROM_SUPPORT
+	select TPL_DRIVERS_MISC_SUPPORT
+	select TPL_OF_CONTROL
+	select TPL_DM
+	select TPL_REGMAP
+	select TPL_SYSCON
+	select TPL_RAM
+	select TPL_CLK
+	select TPL_TINY_MEMSET
 	help
 	  The Rockchip RK3288 is a ARM-based SoC with a quad-core Cortex-A17
 	  including NEON and GPU, 1MB L2 cache, Mali-T7 graphics, two
@@ -54,9 +189,74 @@ config ROCKCHIP_RK3288
 	  and video codec support. Peripherals include Gigabit Ethernet,
 	  USB2 host and OTG, SDIO, I2S, UARTs, SPI, I2C and PWMs.
 
+if ROCKCHIP_RK3288
+config SPL_FIT_GENERATOR
+	default "arch/arm/mach-rockchip/make_fit_optee.sh"
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl.lds"
+
+config TPL_TEXT_BASE
+	default 0xff704000
+
+config TPL_MAX_SIZE
+	default 32768
+
+config TPL_STACK
+	default 0xff718000
+
+endif
+
+config ROCKCHIP_RK3308
+	bool "Support Rockchip RK3308"
+	select ARM64 if !ARM64_BOOT_AARCH32
+	select ARM_SMCCC
+	select GICV2
+	select SUPPORT_SPL if !ARM64_BOOT_AARCH32
+	select SUPPORT_TPL if !ARM64_BOOT_AARCH32
+	select SPL if !ARM64_BOOT_AARCH32
+	select TPL if !ARM64_BOOT_AARCH32
+	imply SPL_CLK
+	imply SPL_REGMAP
+	imply SPL_SYSCON
+	imply SPL_RAM
+	imply SPL_SERIAL_SUPPORT
+	imply TPL_SERIAL_SUPPORT
+	imply SPL_SEPARATE_BSS
+	help
+	  The Rockchip RK3308 is a ARM-based Soc which embeded with quad
+	  Cortex-A35 and highly integrated audio interfaces.
+
+if ROCKCHIP_RK3308
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl-v8.lds"
+
+config TPL_TEXT_BASE
+	default 0xfff81000
+
+config TPL_MAX_SIZE
+	default 10240
+
+config TPL_STACK
+	default 0xfff84000
+
+endif
+
 config ROCKCHIP_RK3328
 	bool "Support Rockchip RK3328"
 	select ARM64
+	select GICV2
+	select SUPPORT_SPL
+	select SUPPORT_TPL
+	select SPL
+	select TPL
+	select TPL_NEEDS_SEPARATE_TEXT_BASE if TPL
+	select TPL_NEEDS_SEPARATE_STACK if TPL
+	imply SPL_SERIAL_SUPPORT
+	imply TPL_SERIAL_SUPPORT
+	imply SPL_SEPARATE_BSS
+	select ARM_SMCCC
 	help
 	  The Rockchip RK3328 is a ARM-based SoC with a quad-core Cortex-A53.
 	  including NEON and GPU, 1MB L2 cache, Mali-T7 graphics, two
@@ -64,6 +264,22 @@ config ROCKCHIP_RK3328
 	  and video codec support. Peripherals include Gigabit Ethernet,
 	  USB2 host and OTG, SDIO, I2S, UARTs, SPI, I2C and PWMs.
 
+if ROCKCHIP_RK3328
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl-v8.lds"
+
+config TPL_TEXT_BASE
+        default 0xff091000
+
+config TPL_MAX_SIZE
+        default 28672
+
+config TPL_STACK
+        default 0xff098000
+
+endif
+
 config ROCKCHIP_RK3368
 	bool "Support Rockchip RK3368"
 	select ARM64
@@ -74,9 +290,8 @@ config ROCKCHIP_RK3368
 	imply SPL_SEPARATE_BSS
 	imply SPL_SERIAL_SUPPORT
 	imply TPL_SERIAL_SUPPORT
-	select ENABLE_ARM_SOC_BOOT0_HOOK
-	select DEBUG_UART_BOARD_INIT
-	select SYS_NS16550
+	select GICV2
+	select ARM_SMCCC
 	help
 	  The Rockchip RK3368 is a ARM-based SoC with a octa-core (organised
 	  into a big and little cluster with 4 cores each) Cortex-A53 including
@@ -90,6 +305,12 @@ config ROCKCHIP_RK3368
 
 if ROCKCHIP_RK3368
 
+config ROCKCHIP_PX5
+	bool "Support Rockchip PX5"
+	help
+	  PX5 is a variant of RK3368, it shares codes with RK3368, but we still
+	  need this macro to distinguish PX5 and RK3368.
+
 config TPL_LDSCRIPT
 	default "arch/arm/mach-rockchip/rk3368/u-boot-tpl.lds"
 
@@ -108,12 +329,31 @@ config ROCKCHIP_RK3399
 	bool "Support Rockchip RK3399"
 	select ARM64
 	select SUPPORT_SPL
+	select SUPPORT_TPL
 	select SPL
+	select TPL
+	select TPL_NEEDS_SEPARATE_TEXT_BASE if TPL
+	select TPL_NEEDS_SEPARATE_STACK if TPL
+	imply TPL_SERIAL_SUPPORT
 	select SPL_SEPARATE_BSS
 	select SPL_SERIAL_SUPPORT
 	select SPL_DRIVERS_MISC_SUPPORT
-	select ENABLE_ARM_SOC_BOOT0_HOOK
-	select DEBUG_UART_BOARD_INIT
+	select GICV3
+	select BOARD_LATE_INIT
+	select ROCKCHIP_BROM_HELPER
+	select ARM_SMCCC
+	select TPL_LIBCOMMON_SUPPORT
+	select TPL_LIBGENERIC_SUPPORT
+	select TPL_SYS_MALLOC_SIMPLE
+	select TPL_BOOTROM_SUPPORT
+	select TPL_DRIVERS_MISC_SUPPORT
+	select TPL_OF_CONTROL
+	select TPL_DM
+	select TPL_REGMAP
+	select TPL_SYSCON
+	select TPL_RAM
+	select TPL_CLK
+	select TPL_TINY_MEMSET
 	help
 	  The Rockchip RK3399 is a ARM-based SoC with a dual-core Cortex-A72
 	  and quad-core Cortex-A53.
@@ -122,13 +362,196 @@ config ROCKCHIP_RK3399
 	  and video codec support. Peripherals include Gigabit Ethernet,
 	  USB2 host and OTG, SDIO, I2S, UARTs, SPI, I2C and PWMs.
 
+if ROCKCHIP_RK3399
+
+config ROCKCHIP_RK3399PRO
+	bool "Support Rockchip RK3399Pro"
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl-v8.lds"
+
+config TPL_TEXT_BASE
+        default 0xff8c2000
+
+config TPL_MAX_SIZE
+        default 188416
+
+config TPL_STACK
+        default 0xff8effff
+
+endif
+
+config ROCKCHIP_RK3568
+	bool "Support Rockchip RK3568"
+	select ARM64 if !ARM64_BOOT_AARCH32
+	select ARM_SMCCC
+	select GICV3 if !ARM64_BOOT_AARCH32 && !SUPPORT_USBPLUG
+	select SUPPORT_TPL if !ARM64_BOOT_AARCH32
+	select SUPPORT_SPL if !ARM64_BOOT_AARCH32
+	select TPL_TINY_FRAMEWORK if TPL
+	select DEBUG_UART_BOARD_INIT
+	imply TPL if !ARM64_BOOT_AARCH32
+	imply SPL if !ARM64_BOOT_AARCH32
+	imply TPL_SERIAL_SUPPORT
+	help
+	  The Rockchip RK3568 is a ARM-based SoC with a quad-core Cortex-A55.
+
+if ROCKCHIP_RK3568
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl-v8.lds"
+
+config TPL_TEXT_BASE
+	default 0xfdcc1000
+
+config TPL_MAX_SIZE
+	default 61440
+
+endif
+
+config ROCKCHIP_RK3588
+	bool "Support Rockchip RK3588"
+	select ARM64 if !ARM64_BOOT_AARCH32
+	select ARM_SMCCC
+	select DEBUG_UART_BOARD_INIT
+	select GICV3 if !ARM64_BOOT_AARCH32 && !SUPPORT_USBPLUG
+	select ROCKCHIP_BROM_HELPER
+	select SUPPORT_SPL if !ARM64_BOOT_AARCH32
+	select SUPPORT_TPL if !ARM64_BOOT_AARCH32
+	select TPL_TINY_FRAMEWORK if TPL
+	imply TPL if !ARM64_BOOT_AARCH32
+	imply SPL if !ARM64_BOOT_AARCH32
+	imply TPL_SERIAL_SUPPORT
+	select DEBUG_UART_BOARD_INIT
+	help
+	  The Rockchip RK3588 is a ARM-based SoC with a quad-core Cortex-A55.
+
+if ROCKCHIP_RK3588
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl-v8.lds"
+
+config TPL_TEXT_BASE
+	default 0xfdcc1000
+
+config TPL_MAX_SIZE
+	default 61440
+endif
+
+config ROCKCHIP_RK1808
+	bool "Support Rockchip RK1808"
+	select ARM64
+	select ARM_SMCCC
+	select GICV3 if !COPROCESSOR_RK1808
+	select SUPPORT_SPL if !COPROCESSOR_RK1808
+	select SUPPORT_TPL if !COPROCESSOR_RK1808
+	help
+	  The Rockchip RK1808 is a ARM-based Soc which embedded with dual
+	  Cortex-A35.
+
+if ROCKCHIP_RK1808
+
+config ROCKCHIP_RK1806
+	bool "Support Rockchip RK1806"
+	help
+	  The Rockchip RK1806 is a ARM-based Soc which embedded with dual
+	  Cortex-A35.
+
+config COPROCESSOR_RK1808
+	bool "RK1808 coprocessor"
+	help
+	  This indicates the RK1808 is working as a coprocessor for another
+	  more powerful SoC.
+
+endif
+
+config ROCKCHIP_RV1106
+	bool "Support Rockchip RV1106"
+	select CPU_V7
+	select ARM_ZERO_CNTVOFF
+	select DEBUG_UART_BOARD_INIT
+	imply SUPPORT_SPL
+	imply SUPPORT_TPL
+	imply SPL
+	imply TPL
+	imply TPL_SERIAL_SUPPORT
+	imply TPL_TINY_FRAMEWORK if TPL
+	imply BOARD_LATE_INIT
+	imply ROCKCHIP_GPIO_V2
+	help
+	  The Rockchip RV1106 is a ARM-based SoC with a Cortex-A7 and
+	  other modules.
+
+if ROCKCHIP_RV1106
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl.lds"
+
+config TPL_TEXT_BASE
+	default 0xff701000
+
+config TPL_MAX_SIZE
+	default 32768
+endif
+
 config ROCKCHIP_RV1108
 	bool "Support Rockchip RV1108"
 	select CPU_V7
+	select SUPPORT_SPL
+	select SUPPORT_TPL
+	select SPL
+	select TPL
+	select BOARD_LATE_INIT
 	help
 	  The Rockchip RV1108 is a ARM-based SoC with a single-core Cortex-A7
 	  and a DSP.
 
+if ROCKCHIP_RV1108
+
+config TPL_LDSCRIPT
+        default "arch/arm/mach-rockchip/u-boot-tpl.lds"
+
+config TPL_TEXT_BASE
+        default 0x10080800
+
+config TPL_MAX_SIZE
+        default 6144
+
+config TPL_STACK
+        default 0x10082000
+
+endif
+
+config ROCKCHIP_RV1126
+	bool "Support Rockchip RV1126"
+	select CPU_V7
+	imply SUPPORT_TPL
+	imply SUPPORT_SPL
+	imply TPL_TINY_FRAMEWORK if TPL
+	select DEBUG_UART_BOARD_INIT
+	imply TPL
+	imply SPL
+	imply GICV2
+	imply ARM_SMCCC
+	imply BOARD_LATE_INIT
+	imply ROCKCHIP_GPIO_V2
+	imply TPL_SERIAL_SUPPORT
+	help
+	  The Rockchip RV1126 is a ARM-based SoC with a quad-core Cortex-A7
+	  and a risc-v core.
+
+if ROCKCHIP_RV1126
+
+config TPL_LDSCRIPT
+	default "arch/arm/mach-rockchip/u-boot-tpl.lds"
+
+config TPL_TEXT_BASE
+	default 0xff701000
+
+config TPL_MAX_SIZE
+	default 32768
+endif
+
 config SPL_ROCKCHIP_BACK_TO_BROM
 	bool "SPL returns to bootrom"
 	default y if ROCKCHIP_RK3036
@@ -141,7 +564,7 @@ config SPL_ROCKCHIP_BACK_TO_BROM
 
 config TPL_ROCKCHIP_BACK_TO_BROM
 	bool "TPL returns to bootrom"
-	default y if ROCKCHIP_RK3368
+	default y
 	select ROCKCHIP_BROM_HELPER
 	depends on TPL
 	help
@@ -149,9 +572,92 @@ config TPL_ROCKCHIP_BACK_TO_BROM
           SPL will return to the boot rom, which will then load the U-Boot
           binary to keep going on.
 
+config ARM64_BOOT_AARCH32
+	bool "Support Boot an ARM64 on AArch32 execution state, ie. U-Boot is in AArch32"
+	select CPU_V7
+	default n
+	help
+	  If you want to boot an ARM64 processor on 32-bit mode, say y here.
+
+config ARM64_SWITCH_TO_AARCH32
+	bool "Support AArch64 U-Boot boot AArch32 kernel"
+	default n
+	help
+	  If you want AArch64 U-Boot to boot AArch32 kernel, say y here.
+	  This feature needs ATF to help switch the PE state.
+
+config ROCKCHIP_BOOT_MODE_REG
+	hex "Rockchip boot mode flag register address"
+	default 0xff010200 if ROCKCHIP_PX30
+	default 0x200081c8 if ROCKCHIP_RK3036
+	default 0x100a0038 if ROCKCHIP_RK3128
+	default 0x20004040 if ROCKCHIP_RK3188
+	default 0x110005c8 if ROCKCHIP_RK322X
+	default 0xff730094 if ROCKCHIP_RK3288
+	default 0xff000500 if ROCKCHIP_RK3308
+	default 0xff1005c8 if ROCKCHIP_RK3328
+	default 0xff738200 if ROCKCHIP_RK3368
+	default 0xff320300 if ROCKCHIP_RK3399
+	default 0xfdc20200 if ROCKCHIP_RK3568
+	default 0xfd588080 if ROCKCHIP_RK3588
+	default 0xfe020200 if ROCKCHIP_RK1808
+	default 0xff020200 if ROCKCHIP_RV1106
+	default 0x10300580 if ROCKCHIP_RV1108
+	default 0xfe020200 if ROCKCHIP_RV1126
+	default 0
+	help
+	  The Soc will enter to different boot mode(defined in asm/arch-rockchip/boot_mode.h)
+	  according to the value from this register.
+
+config ROCKCHIP_STIMER_BASE
+	hex "Rockchip Secure timer base address"
+	default 0xff220020 if ROCKCHIP_PX30
+	default 0x200440a0 if ROCKCHIP_RK3036
+	default 0x2000e000 if ROCKCHIP_RK3066
+	default 0x20018020 if ROCKCHIP_RK3126
+	default 0x200440a0 if ROCKCHIP_RK3128
+	default 0x2000e000 if ROCKCHIP_RK3188
+	default 0x110d0020 if ROCKCHIP_RK322X
+	default 0xff810020 if ROCKCHIP_RK3288
+	default 0xff1b00a0 if ROCKCHIP_RK3308
+	default 0xff1d0020 if ROCKCHIP_RK3328
+	default 0xff830020 if ROCKCHIP_RK3368
+	default 0xff8680a0 if ROCKCHIP_RK3399
+	default 0xfdd1c020 if ROCKCHIP_RK3568
+	default 0xfd8c8000 if ROCKCHIP_RK3588
+	default 0xff590020 if ROCKCHIP_RV1106
+	default 0x10350020 if ROCKCHIP_RV1108
+	default 0xff670020 if ROCKCHIP_RV1126
+	default 0
+	help
+	  The secure timer inited in SPL/TPL in secure word, ARM generic timer
+	  works after this timer work.
+
+config ROCKCHIP_IRAM_START_ADDR
+	hex "Rockchip Secure timer base address"
+	default 0xff0e0000 if ROCKCHIP_PX30
+	default 0x10080000 if ROCKCHIP_RK3036
+	default 0x10080000 if ROCKCHIP_RK3128
+	default 0x10080000 if ROCKCHIP_RK3188
+	default 0x10080000 if ROCKCHIP_RK322X
+	default 0xff700000 if ROCKCHIP_RK3288
+	default 0xfff80000 if ROCKCHIP_RK3308
+	default 0xff091000 if ROCKCHIP_RK3328
+	default 0xff8c0000 if ROCKCHIP_RK3368
+	default 0xff8c0000 if ROCKCHIP_RK3399
+	default 0xfdcc0000 if ROCKCHIP_RK3568
+	default 0xff000000 if ROCKCHIP_RK3588
+	default 0xff6c0000 if ROCKCHIP_RV1106
+	default 0x10080000 if ROCKCHIP_RV1108
+	default 0xff700000 if ROCKCHIP_RV1126
+	default 0
+	help
+	  The IRAM start addr is to locate variant of the boot device from
+	  bootrom.
+
 config ROCKCHIP_SPL_RESERVE_IRAM
 	hex "Size of IRAM reserved in SPL"
-	default 0x4000
+	default 0
 	help
 	  SPL may need reserve memory for firmware loaded by SPL, whose load
 	  address is in IRAM and may overlay with SPL text area if not
@@ -160,8 +666,320 @@ config ROCKCHIP_SPL_RESERVE_IRAM
 config ROCKCHIP_BROM_HELPER
 	bool
 
+config SPL_ROCKCHIP_EARLYRETURN_TO_BROM
+        bool "SPL requires early-return (for RK3188-style BROM) to BROM"
+	depends on SPL && ENABLE_ARM_SOC_BOOT0_HOOK
+	help
+	  Some Rockchip BROM variants (e.g. on the RK3188) load the
+	  first stage in segments and enter multiple times. E.g. on
+	  the RK3188, the first 1KB of the first stage are loaded
+	  first and entered; after returning to the BROM, the
+	  remainder of the first stage is loaded, but the BROM
+	  re-enters at the same address/to the same code as previously.
+
+	  This enables support code in the BOOT0 hook for the SPL stage
+	  to allow multiple entries.
+
+config TPL_ROCKCHIP_EARLYRETURN_TO_BROM
+        bool "TPL requires early-return (for RK3188-style BROM) to BROM"
+	depends on TPL && ENABLE_ARM_SOC_BOOT0_HOOK
+	help
+	  Some Rockchip BROM variants (e.g. on the RK3188) load the
+	  first stage in segments and enter multiple times. E.g. on
+	  the RK3188, the first 1KB of the first stage are loaded
+	  first and entered; after returning to the BROM, the
+	  remainder of the first stage is loaded, but the BROM
+	  re-enters at the same address/to the same code as previously.
+
+	  This enables support code in the BOOT0 hook for the TPL stage
+	  to allow multiple entries.
+
 config SPL_MMC_SUPPORT
-	default y if !SPL_ROCKCHIP_BACK_TO_BROM
+	default y if !SPL_ROCKCHIP_BACK_TO_BROM && MMC
+
+config RKIMG_BOOTLOADER
+	bool "Support for Rockchip platform features"
+	default y
+	help
+	  Actually this is a compatible configure for code compilation.
+
+config RKIMG_ANDROID_BOOTMODE_LEGACY
+	bool "Support set androidboot.mode with legacy rule"
+	depends on RKIMG_BOOTLOADER
+	default n
+	help
+	  Rockchip set "androidboot.mode=" as "charger" or boot media for android,
+	  which is a rockchip private solution(SDK < 8.1) and deprecated.
+
+config ROCKCHIP_RESOURCE_IMAGE
+	bool "Enable support for rockchip resource image"
+	depends on RKIMG_BOOTLOADER
+	default y
+	help
+	  This enables support to get dtb or logo files from
+	  rockchip resource image format partition.
+
+config ROCKCHIP_DTB_VERIFY
+	bool "Enable hash verify for DTB in the resource file"
+	depends on ROCKCHIP_RESOURCE_IMAGE
+	select SHA1 if !DM_CRYPTO
+	select SHA256 if !DM_CRYPTO
+	default y
+	help
+	  This enables the hash verify for DTB in the resource file, it means we
+	  always read DTB from second position even the DTB position is present.
+
+config ROCKCHIP_USB_BOOT
+	bool "Enable support for rockchip U-disk boot"
+	depends on USB
+	default n
+	help
+	  This enables support for rockchip U-disk boot.
+
+config ROCKCHIP_FIT_IMAGE
+	bool "Enable support for FIT image"
+	depends on FIT
+	select CMD_BOOT_FIT
+	default n
+	help
+	  This enables loading dtb from fit image.
+
+config ROCKCHIP_UIMAGE
+	bool "Enable support for legacy uImage"
+	depends on !FIT_SIGNATURE && USING_KERNEL_DTB
+	select CMD_BOOT_UIMAGE
+	default n
+	help
+	  This enables loading dtb from uImage image.
+
+config ROCKCHIP_EARLY_DISTRO_DTB
+	bool "Enable support for distro dtb early"
+	depends on DISTRO_DEFAULTS && USING_KERNEL_DTB && CMD_FS_GENERIC
+	default n
+	help
+	  This enables loading dtb from distro bootable partition when there
+	  is no valid dtb in android boot.img and rockchip resource.img.
+
+if ROCKCHIP_EARLY_DISTRO_DTB
+
+config ROCKCHIP_EARLY_DISTRO_DTB_PATH
+	string "/rk-kernel.dtb"
+	help
+	  "DTB file path in the bootable partition image"
+endif
+
+config ROCKCHIP_HWID_DTB
+	bool "Enable support for selecting DTB by hardware id"
+	depends on ROCKCHIP_RESOURCE_IMAGE
+	default n
+	help
+	  This enables select the expected DTB from sets by hardware id,
+	  i.e. GPIO or ADC value.
+
+config ROCKCHIP_VENDOR_PARTITION
+	bool "Rockchip vendor storage partition support"
+	depends on RKIMG_BOOTLOADER
+	help
+	  This enable support to read/write vendor configuration data from/to
+	  this partition.
+
+config USING_KERNEL_DTB
+	bool "Using dtb from Kernel/resource for U-Boot"
+	depends on RKIMG_BOOTLOADER && OF_LIVE
+	default y
+	help
+	  This enable support to read dtb from resource and use it for U-Boot,
+	  the uart and emmc will still using U-Boot dtb, but other devices like
+	  regulator/pmic, display, usb will use dts node from kernel.
+
+config USING_KERNEL_DTB_V2
+	bool "Version 2 of kernel dtb mechanism"
+	depends on USING_KERNEL_DTB
+	default n
+	help
+	  The V2 mechanism:
+	    - both of U-Boot and kernel's *ALL* devices are exist in dm tree.
+	    - put the necessary U-Boot devices in the head of device uclass list.
+	    - the both existence policy don't require phandle fixup any more.
+	    - it is for the next generation(rk3588 ...) or necessary platforms.
+	  The V1 mechanism(legacy):
+	    - U-Boot: only some necessary U-Boot devices(storage, crypto...) in dm tree.
+	    - kernel: all the devices(except the U-Boot only) in dm tree.
+
+config EMBED_KERNEL_DTB_PATH
+	string "Embeded kernel dtb file path"
+	depends on USING_KERNEL_DTB
+	default "dts/kern.dtb"
+	help
+	  This file will auto be appended to the u-boot.bin.
+
+config EMBED_KERNEL_DTB_ALWAYS
+	bool "Always using embed kernel dtb"
+	depends on USING_KERNEL_DTB
+	default n
+	help
+	  Allow fallback to always use a prepared kernel dtb even USING_KERNEL_DTB
+	  is set. This makes U-Boot stage more stable but not flexible any more to
+	  compatible different boards.
+
+config ROCKCHIP_CRC
+	bool "Rockchip CRC verify images"
+	help
+	  This enable support Rockchip CRC verify images. It takes a lot of time,
+	  so it is better only used for debug.
+
+config ROCKCHIP_SMCCC
+	bool "Rockchip SMCCC"
+	default y if ARM_SMCCC
+	help
+	  This enable support for Rockchip SMC calls
+
+config ROCKCHIP_DEBUGGER
+	bool "Rockchip debugger"
+	depends on IRQ
+	help
+	  This enable support for Rockchip debugger. Now we install a timer interrupt
+	  and dump pt_regs when the timeout event trigger. This helps us to know cpu
+	  state when system hang.
+
+config ROCKCHIP_CRASH_DUMP
+	bool "Rockchip crash dump registers"
+	help
+	  This enable dump registers when system crash, the registers you would like
+	  to dump can be added in show_regs().
+
+config ROCKCHIP_PRELOADER_ATAGS
+	bool "Rockchip pre-loader atags"
+	default y if ARCH_ROCKCHIP
+	help
+	  This enable support Rockchip atags among pre-loaders, i.e. ddr, miniloader, ATF,
+	  tos, U-Boot, etc. It delivers boot and configure information, shared with pre-loaders
+	  and finally ends with U-Boot.
+
+config ROCKCHIP_PRELOADER_SERIAL
+	bool "Rockchip pre-loader serial"
+	default y if ROCKCHIP_PRELOADER_ATAGS
+	help
+	  This enable U-Boot using pre-loader atags serial configure to initialize console.
+	  It denpends on serial aliases to find pre-loader serial number.
+
+config ROCKCHIP_IMAGE_TINY
+	bool "Rockchip tiny Image generation"
+	default n
+	help
+	  This enable tiny image generation
+
+config ROCKCHIP_FIT_IMAGE_PACK
+	bool "Rockchip fit image pack of U-Boot and TEE"
+	depends on ROCKCHIP_FIT_IMAGE
+	default n
+	help
+	  This enable fit image pack of U-Boot and TEE, it's used for make.sh script.
+
+config ROCKCHIP_UART_MUX_SEL_M
+	int "UART mux select"
+	default 0
+	depends on TPL
+	help
+	  This select uart multiplexer for debug uart iomux in board_debug_uart_init.
+
+config ROCKCHIP_REBOOT_TEST
+	bool "Rockchip reboot stress test before kernel"
+	default n
+	help
+	  It's a reboot stress test before kernel stages.
+
+config ROCKCHIP_NEW_IDB
+	bool "Rockchip new IDB header"
+	default n
+	help
+	  The new IDB header was introduced from RK356X.
+
+config GICV2
+	bool "ARM GICv2"
+
+config GICV3
+	bool "ARM GICv3"
+
+config ROCKCHIP_EMMC_IOMUX
+	bool "ROCKCHIP EMMC IOMUX"
+	default n
+	help
+	  This enable U-Boot to config EMMC iomux.
+
+config ROCKCHIP_NAND_IOMUX
+	bool "ROCKCHIP NAND IOMUX"
+	default n
+	help
+	  This enable U-Boot to config NAND iomux.
+
+config ROCKCHIP_SFC_IOMUX
+	bool "ROCKCHIP SFC IOMUX"
+	default n
+	help
+	  This enable U-Boot to config SFC iomux.
+
+config ROCKCHIP_SET_SN
+	bool "Rockchip set serial number"
+	default y
+
+config ROCKCHIP_SET_ETHADDR
+	bool "Rockchip set eth address"
+	default y
+
+config BASE_DEFCONFIG
+	string "Base defconfig of config fragment"
+	default ""
+	help
+	  Indicate the base defconfig of config fragment.
+
+config CHIP_NAME
+	string "Chip label name"
+	default ""
+
+config LOADER_INI
+	string "Name of Loader ini file in rkbin repository"
+	default ""
+	help
+	  The ini file is used to pack loader image.
+
+config TRUST_INI
+	string "Name of Trust ini file in rkbin repository"
+	default ""
+	help
+	  The ini file is used to pack trust image.
+
+if !ROCKCHIP_FIT_IMAGE_PACK
+config UBOOT_SIZE_KB
+	int "Per u-boot.bin Image size, unit: KB"
+	default 1024
+
+config UBOOT_NUM
+	int "Number of u-boot.bin image being packed into trust.img"
+	default 4
+
+config TRUST_SIZE_KB
+	int "Per trust Image size, unit: KB"
+	default 2048
+
+config TRUST_NUM
+	int "Number of trust image being packed into trust.img"
+	default 2
+
+config TRUST_RSA_MODE
+	int "RSA mode of trust.img on ARM64"
+	default 2
+	help
+	  The RSA mode for tools to pack, the mode id can be:
+	  0: none; 1: RSA-1024; 2: RSA-2048; 3: RSA-2048-pss.
+
+config TRUST_SHA_MODE
+	int "SHA mode of trust.img on ARM64"
+	default 3
+	help
+	  The SHA mode for tools to pack, the mode id can be:
+	  0: none; 1: sha1; 2: sha256 RK big endian; 3: sha256 little endian.
+endif
 
 source "arch/arm/mach-rockchip/rk3036/Kconfig"
 source "arch/arm/mach-rockchip/rk3188/Kconfig"
@@ -170,5 +988,9 @@ source "arch/arm/mach-rockchip/rk3288/Kconfig"
 source "arch/arm/mach-rockchip/rk3328/Kconfig"
 source "arch/arm/mach-rockchip/rk3368/Kconfig"
 source "arch/arm/mach-rockchip/rk3399/Kconfig"
+source "arch/arm/mach-rockchip/rk3568/Kconfig"
+source "arch/arm/mach-rockchip/rk3588/Kconfig"
 source "arch/arm/mach-rockchip/rv1108/Kconfig"
+source "arch/arm/mach-rockchip/rv1126/Kconfig"
+
 endif
diff --git a/arch/arm/mach-rockchip/Makefile b/arch/arm/mach-rockchip/Makefile
index 79e9704a2c..c93570277b 100644
--- a/arch/arm/mach-rockchip/Makefile
+++ b/arch/arm/mach-rockchip/Makefile
@@ -8,32 +8,56 @@
 # this may have entered from ATF with the stack-pointer pointing to
 # inaccessible/protected memory (and the bootrom-helper assumes that
 # the stack-pointer is valid before switching to the U-Boot stack).
-obj-spl-$(CONFIG_ROCKCHIP_BROM_HELPER) += bootrom.o save_boot_param.o
-obj-tpl-$(CONFIG_ROCKCHIP_BROM_HELPER) += bootrom.o save_boot_param.o
+obj-spl-$(CONFIG_ROCKCHIP_BROM_HELPER) += bootrom.o
+obj-tpl-$(CONFIG_ROCKCHIP_BROM_HELPER) += bootrom.o
 
-obj-tpl-$(CONFIG_ROCKCHIP_RK3188) += rk3188-board-tpl.o
-obj-tpl-$(CONFIG_ROCKCHIP_RK3368) += rk3368-board-tpl.o
+obj-tpl-y += tpl.o
+ifndef CONFIG_SPL_DECOMP_HEADER
+obj-spl-y += spl.o spl-boot-order.o
+endif
 
-obj-spl-$(CONFIG_ROCKCHIP_RK3036) += rk3036-board-spl.o
-obj-spl-$(CONFIG_ROCKCHIP_RK3188) += rk3188-board-spl.o
-obj-spl-$(CONFIG_ROCKCHIP_RK322X) += rk322x-board-spl.o
-obj-spl-$(CONFIG_ROCKCHIP_RK3288) += rk3288-board-spl.o
-obj-spl-$(CONFIG_ROCKCHIP_RK3368) += rk3368-board-spl.o spl-boot-order.o
-obj-spl-$(CONFIG_ROCKCHIP_RK3399) += rk3399-board-spl.o spl-boot-order.o
+ifndef CONFIG_TPL_BUILD
+obj-$(CONFIG_$(SPL_)FIT) += fit_misc.o
+ifdef CONFIG_SPL_BUILD
+obj-y += spl_boot_mode.o
+endif
+endif
 
 ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
-obj-$(CONFIG_ROCKCHIP_RK3188) += rk3188-board.o
-obj-$(CONFIG_ROCKCHIP_RK322X) += rk322x-board.o
-obj-$(CONFIG_ROCKCHIP_RK3288) += rk3288-board.o
-obj-$(CONFIG_ROCKCHIP_RK3036) += rk3036-board.o
-endif
 
-obj-$(CONFIG_$(SPL_TPL_)RAM) += sdram_common.o
+# Always include boot_mode.o, as we bypass it (i.e. turn it off)
+# inside of boot_mode.c when CONFIG_BOOT_MODE_REG is 0.  This way,
+# we can have the preprocessor correctly recognise both 0x0 and 0
+# meaning "turn it off".
 
-ifndef CONFIG_ARM64
-obj-y += rk_timer.o
+obj-y += chip_info.o
+ifndef CONFIG_SUPPORT_USBPLUG
+obj-y += lowlevel_init.o
+obj-y += boot_mode.o
+obj-y += boot_rkimg.o
+obj-y += board.o
+obj-y += iomem.o
+obj-y += memblk.o
+obj-y += hotkey.o
+else
+obj-y += usbplug.o
 endif
 
+obj-$(CONFIG_USING_KERNEL_DTB) += kernel_dtb.o
+obj-$(CONFIG_ROCKCHIP_FIT_IMAGE) += fit.o
+obj-$(CONFIG_ROCKCHIP_UIMAGE) += uimage.o
+obj-$(CONFIG_ROCKCHIP_SMCCC) += rockchip_smccc.o
+obj-$(CONFIG_ROCKCHIP_VENDOR_PARTITION) += vendor.o vendor_misc.o
+obj-$(CONFIG_ROCKCHIP_RESOURCE_IMAGE) += resource_img.o resource_logo.o
+obj-$(CONFIG_ROCKCHIP_HWID_DTB) += resource_hwid.o
+obj-$(CONFIG_ROCKCHIP_DEBUGGER) += rockchip_debugger.o
+obj-$(CONFIG_FPGA_ROCKCHIP) += fpga.o
+endif
+
+obj-$(CONFIG_RAM) += param.o
+obj-$(CONFIG_$(SPL_TPL_)RAM) += sdram.o
+obj-$(CONFIG_SPL_KERNEL_BOOT) += spl_resource_img.o
+
 obj-$(CONFIG_ROCKCHIP_RK3036) += rk3036/
 ifndef CONFIG_TPL_BUILD
 obj-$(CONFIG_ROCKCHIP_RK3188) += rk3188/
@@ -43,7 +67,10 @@ obj-$(CONFIG_ROCKCHIP_RK3288) += rk3288/
 obj-$(CONFIG_ROCKCHIP_RK3328) += rk3328/
 obj-$(CONFIG_ROCKCHIP_RK3368) += rk3368/
 obj-$(CONFIG_ROCKCHIP_RK3399) += rk3399/
+obj-$(CONFIG_ROCKCHIP_RK3568) += rk3568/
+obj-$(CONFIG_ROCKCHIP_RK3588) += rk3588/
 obj-$(CONFIG_ROCKCHIP_RV1108) += rv1108/
+obj-$(CONFIG_ROCKCHIP_RV1126) += rv1126/
 
 # Clear out SPL objects, in case this is a TPL build
 obj-spl-$(CONFIG_TPL_BUILD) =
@@ -51,3 +78,6 @@ obj-spl-$(CONFIG_TPL_BUILD) =
 # Now add SPL/TPL objects back into the main build
 obj-$(CONFIG_SPL_BUILD) += $(obj-spl-y)
 obj-$(CONFIG_TPL_BUILD) += $(obj-tpl-y)
+
+obj-$(CONFIG_ROCKCHIP_PRELOADER_ATAGS) += rk_atags.o
+obj-$(CONFIG_SET_DFU_ALT_INFO) += dfu_alt_info.o
diff --git a/arch/arm/mach-rockchip/bootrom.c b/arch/arm/mach-rockchip/bootrom.c
index 8380e4e006..81b5c7aecd 100644
--- a/arch/arm/mach-rockchip/bootrom.c
+++ b/arch/arm/mach-rockchip/bootrom.c
@@ -5,12 +5,108 @@
  */
 
 #include <common.h>
-#include <asm/arch/bootrom.h>
+#include <asm/arch-rockchip/bootrom.h>
+#include <asm/arch-rockchip/boot_mode.h>
+#include <asm/io.h>
+#include <asm/setjmp.h>
+#include <asm/system.h>
 
-void back_to_bootrom(void)
+/*
+ * Force the jmp_buf to the data-section, as .bss will not be valid
+ * when save_boot_params is invoked.
+ */
+static jmp_buf brom_ctx __section(".data");
+
+static void _back_to_bootrom(enum rockchip_bootrom_cmd brom_cmd)
+{
+	longjmp(brom_ctx, brom_cmd);
+}
+
+void back_to_bootrom(enum rockchip_bootrom_cmd brom_cmd)
 {
 #if CONFIG_IS_ENABLED(LIBCOMMON_SUPPORT)
 	puts("Returning to boot ROM...\n");
 #endif
-	_back_to_bootrom_s();
+	_back_to_bootrom(brom_cmd);
+}
+
+/*
+ * We back to bootrom download mode if get a
+ * BOOT_BROM_DOWNLOAD flag in boot mode register
+ *
+ * The bootrom never check this register, so we need
+ * to check it and back to bootrom at very early bootstage(before
+ * some basic configurations(such as interrupts) been
+ * changed by TPL/SPL, as the bootrom download operation
+ * relys on many default settings(such as interrupts) by
+ * it's self.
+ * Note: the boot mode register is configured by
+ * application(next stage bootloader, kernel, etc) via command or PC Tool,
+ * cleared by USB download(bootrom mode) or loader(other mode) after the
+ * tag has work.
+ */
+static bool check_back_to_brom_dnl_flag(void)
+{
+	u32 boot_mode, boot_id;
+
+	if (CONFIG_ROCKCHIP_BOOT_MODE_REG && BROM_BOOTSOURCE_ID_ADDR) {
+		boot_mode = readl(CONFIG_ROCKCHIP_BOOT_MODE_REG);
+		boot_id = readl(BROM_BOOTSOURCE_ID_ADDR);
+		if (boot_id == BROM_BOOTSOURCE_USB)
+			writel(0, CONFIG_ROCKCHIP_BOOT_MODE_REG);
+		else if (boot_mode == BOOT_BROM_DOWNLOAD)
+			return true;
+	}
+
+	return false;
+}
+
+/*
+ * All Rockchip BROM implementations enter with a valid stack-pointer,
+ * so this can safely be implemented in C (providing a single
+ * implementation both for ARMv7 and AArch64).
+ */
+int save_boot_params(void)
+{
+	int  ret = setjmp(brom_ctx);
+
+	switch (ret) {
+	case 0:
+		if (check_back_to_brom_dnl_flag())
+			_back_to_bootrom(BROM_BOOT_ENTER_DNL);
+		/*
+		 * This is the initial pass through this function
+		 * (i.e. saving the context), setjmp just setup up the
+		 * brom_ctx: transfer back into the startup-code at
+		 * 'save_boot_params_ret' and let the compiler know
+		 * that this will not return.
+		 */
+		save_boot_params_ret();
+		while (true)
+			/* does not return */;
+		break;
+
+	case BROM_BOOT_NEXTSTAGE:
+		/*
+		 * To instruct the BROM to boot the next stage, we
+		 * need to return 0 to it: i.e. we need to rewrite
+		 * the return code once more.
+		 */
+		ret = 0;
+		break;
+	case BROM_BOOT_ENTER_DNL:
+		/*
+		 * A non-zero return value will instruct the BROM enter
+		 * download mode.
+		 */
+		ret = 1;
+		break;
+	default:
+#if CONFIG_IS_ENABLED(LIBCOMMON_SUPPORT)
+		puts("FATAL: unexpected command to back_to_bootrom()\n");
+#endif
+		hang();
+	};
+
+	return ret;
 }
diff --git a/arch/arm/mach-rockchip/rk_timer.c b/arch/arm/mach-rockchip/rk_timer.c
index 853b986646..f21b582a32 100644
--- a/arch/arm/mach-rockchip/rk_timer.c
+++ b/arch/arm/mach-rockchip/rk_timer.c
@@ -5,7 +5,7 @@
  */
 
 #include <common.h>
-#include <asm/arch/timer.h>
+#include <asm/arch-rockchip/timer.h>
 #include <asm/io.h>
 #include <linux/types.h>
 
diff --git a/arch/arm/mach-rockchip/sdram_common.c b/arch/arm/mach-rockchip/sdram_common.c
index 76dbdc8715..cd5112abb1 100644
--- a/arch/arm/mach-rockchip/sdram_common.c
+++ b/arch/arm/mach-rockchip/sdram_common.c
@@ -8,7 +8,7 @@
 #include <dm.h>
 #include <ram.h>
 #include <asm/io.h>
-#include <asm/arch/sdram_common.h>
+#include <asm/arch-rockchip/sdram_common.h>
 #include <dm/uclass-internal.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/arch/arm/mach-rockchip/spl-boot-order.c b/arch/arm/mach-rockchip/spl-boot-order.c
index 4f78c72720..9b42ea208c 100644
--- a/arch/arm/mach-rockchip/spl-boot-order.c
+++ b/arch/arm/mach-rockchip/spl-boot-order.c
@@ -7,9 +7,28 @@
 #include <common.h>
 #include <dm.h>
 #include <mmc.h>
+#include <nand.h>
 #include <spl.h>
 
-#if CONFIG_IS_ENABLED(OF_CONTROL)
+#if CONFIG_IS_ENABLED(OF_CONTROL) && ! CONFIG_IS_ENABLED(OF_PLATDATA)
+/**
+ * spl_node_to_boot_device() - maps from a DT-node to a SPL boot device
+ * @node:	of_offset of the node
+ *
+ * The SPL framework uses BOOT_DEVICE_... constants to identify its boot
+ * sources.  These may take on a device-specific meaning, depending on
+ * what nodes are enabled in a DTS (e.g. BOOT_DEVICE_MMC1 may refer to
+ * different controllers/block-devices, depending on which SD/MMC controllers
+ * are enabled in any given DTS).  This function maps from a DT-node back
+ * onto a BOOT_DEVICE_... constant, considering the currently active devices.
+ *
+ * Returns
+ *   -ENOENT, if no device matching the node could be found
+ *   -ENOSYS, if the device matching the node can not be mapped onto a
+ *            SPL boot device (e.g. the third MMC device)
+ *   -1, for unspecified failures
+ *   a positive integer (from the BOOT_DEVICE_... family) on succes.
+ */
 static int spl_node_to_boot_device(int node)
 {
 	struct udevice *parent;
@@ -52,11 +71,67 @@ static int spl_node_to_boot_device(int node)
 	 * soon.
 	 */
 	if (!uclass_get_device_by_of_offset(UCLASS_SPI_FLASH, node, &parent))
+#ifndef CONFIG_SPL_MTD_SUPPORT
 		return BOOT_DEVICE_SPI;
+#else
+		return BOOT_DEVICE_MTD_BLK_SPI_NOR;
+
+	if (!uclass_get_device_by_of_offset(UCLASS_MTD, node, &parent)) {
+		struct udevice *dev;
+		struct blk_desc *desc = NULL;
+
+		for (device_find_first_child(parent, &dev);
+		     dev;
+		     device_find_next_child(&dev)) {
+			if (device_get_uclass_id(dev) == UCLASS_BLK) {
+				desc = dev_get_uclass_platdata(dev);
+				break;
+			}
+		}
+
+		if (!desc)
+			return -ENOENT;
+
+		switch (desc->devnum) {
+		case 0:
+			return BOOT_DEVICE_MTD_BLK_NAND;
+		case 1:
+			return BOOT_DEVICE_MTD_BLK_SPI_NAND;
+		default:
+			return -ENOSYS;
+		}
+	}
+#endif
+
+	/*
+	 * This should eventually move into the SPL code, once SPL becomes
+	 * aware of the block-device layer.  Until then (and to avoid unneeded
+	 * delays in getting this feature out, it lives at the board-level).
+	 */
+	if (!uclass_get_device_by_of_offset(UCLASS_RKNAND, node, &parent))
+		return BOOT_DEVICE_RKNAND;
 
 	return -1;
 }
 
+/**
+ * board_spl_was_booted_from() - retrieves the of-path the SPL was loaded from
+ *
+ * To support a 'same-as-spl' specification in the search-order for the next
+ * stage, we need a SoC- or board-specific way to handshake with what 'came
+ * before us' (either a BROM or TPL stage) and map the info retrieved onto
+ * a OF path.
+ *
+ * Returns
+ *   NULL, on failure or if the device could not be identified
+ *   a of_path (a string), on success
+ */
+__weak const char *board_spl_was_booted_from(void)
+{
+	debug("%s: no support for 'same-as-spl' for this board\n", __func__);
+	return NULL;
+}
+
 void board_boot_order(u32 *spl_boot_list)
 {
 	const void *blob = gd->fdt_blob;
@@ -78,8 +153,17 @@ void board_boot_order(u32 *spl_boot_list)
 	     (conf = fdt_stringlist_get(blob, chosen_node,
 					"u-boot,spl-boot-order", elem, NULL));
 	     elem++) {
+		const char *alias;
+
+		/* Handle the case of 'same device the SPL was loaded from' */
+		if (strncmp(conf, "same-as-spl", 11) == 0) {
+			conf = board_spl_was_booted_from();
+			if (!conf)
+				continue;
+		}
+
 		/* First check if the list element is an alias */
-		const char *alias = fdt_get_alias(blob, conf);
+		alias = fdt_get_alias(blob, conf);
 		if (alias)
 			conf = alias;
 
diff --git a/cmd/Kconfig b/cmd/Kconfig
index d6d130edfa..8273ed12ad 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -30,6 +30,14 @@ config SYS_PROMPT
 	  This string is displayed in the command line to the left of the
 	  cursor.
 
+config U_BOOT_CMD_ALWAYS
+	bool "Enable cmd with U_BOOT_CMD_ALWAYS() declared"
+	depends on !CMDLINE
+	help
+	  This function is used to support some special U-Boot commands with
+	  U_BOOT_CMD_ALWAYS() declared even when CONFIG_CMDLINE is disabled.
+	  It reduces the image size and works with simple CLI.
+
 menu "Autoboot options"
 
 config AUTOBOOT
@@ -116,6 +124,9 @@ endmenu
 
 source "cmd/fastboot/Kconfig"
 
+config BUILD_BIN2C
+	bool
+
 comment "Commands"
 
 menu "Info commands"
@@ -228,6 +239,15 @@ config CMD_BOOTMENU
 	help
 	  Add an ANSI terminal boot menu command.
 
+config CMD_DTIMG
+	bool "dtimg"
+	select OF_LIBFDT_OVERLAY
+	help
+	  Android DTB/DTBO image manipulation commands. Read dtb/dtbo files from
+	  image into RAM, dump image structure information, etc. Those dtb/dtbo
+	  files should be merged in one dtb further, which needs to be passed to
+	  the kernel, as part of a boot process.
+
 config CMD_ELF
 	bool "bootelf, bootvx"
 	default y
@@ -520,12 +540,29 @@ config CMD_STRINGS
 	  within the range are displayed. The minimum number of characters
 	  for a sequence to be considered a string can be provided.
 
+config CMD_CRYPTO
+	bool "crypto test"
+	depends on DM_CRYPTO
+	select SHA1
+	select SHA256
+	select SHA512
+	select MD5
+	help
+	  Crypto test.
+
+config CMD_CRYPTO_SUM
+	bool "crypto checksum engine"
+	depends on DM_CRYPTO
+	default y
+	help
+	  Crypto checksum engine for sha1/sha256/sha512/md5.
 endmenu
 
 menu "Compression commands"
 
 config CMD_LZMADEC
 	bool "lzmadec"
+	default y if CMD_BOOTI
 	select LZMA
 	help
 	  Support decompressing an LZMA (Lempel-Ziv-Markov chain algorithm)
@@ -533,6 +570,7 @@ config CMD_LZMADEC
 
 config CMD_UNZIP
 	bool "unzip"
+	default y if CMD_BOOTI
 	help
 	  Uncompress a zip-compressed memory region.
 
@@ -663,10 +701,17 @@ config CMD_GPT
 	bool "GPT (GUID Partition Table) command"
 	select PARTITION_UUIDS
 	select EFI_PARTITION
+	imply RANDOM_UUID
 	help
 	  Enable the 'gpt' command to ready and write GPT style partition
 	  tables.
 
+config RANDOM_UUID
+	bool "GPT Random UUID generation"
+	help
+	  Enable the generation of partitions with random UUIDs if none
+	  are provided.
+
 config CMD_GPT_RENAME
 	bool "GPT partition renaming commands"
 	depends on CMD_GPT
@@ -743,11 +788,75 @@ config CMD_LOADS
 	help
 	  Load an S-Record file over serial line
 
+config CMD_LOAD_ANDROID
+	bool "load_android"
+	default n
+	depends on ANDROID_BOOT_IMAGE
+	help
+	  Load an Android Boot image from storage. The Android Boot images
+	  define the size and kernel address on the header, which are used by
+	  this command.
+
+config CMD_BOOT_ANDROID
+	bool "boot_android"
+	default n
+	depends on ANDROID_BOOTLOADER
+	help
+	  Performs the Android Bootloader boot flow, loading the appropriate
+	  Android image (normal kernel, recovery kernel or "bootloader" mode)
+	  and booting it. The boot mode is determined by the contents of the
+	  Android Bootloader Message.
+
+config CMD_ANDROID_AB_SELECT
+	bool "android_ab_select"
+	default n
+	depends on ANDROID_AB
+	help
+	  On Android devices with more than one boot slot (multiple copies of
+	  the kernel and system images) this provides a command to select which
+	  slot should be used to boot from and register the boot attempt. This
+	  is used by the new A/B update model where one slot is updated in the
+	  background while running from the other slot.
+
+config CMD_BOOT_FIT
+	bool "boot_fit"
+	default n
+	depends on ROCKCHIP_FIT_IMAGE
+	help
+	  Performs the FIT boot flow, loading the appropriate FIT image from
+	  boot/recovery partition containing kernel/fdt/ramdisk images.
+	  Additional that, the IH_TYPE_MULTI can be used for resource file.
+
+config CMD_BOOT_UIMAGE
+	bool "boot_uimage"
+	default n
+	depends on ROCKCHIP_UIMAGE
+	help
+	  Performs the Legacy uImage boot flow, loading the appropriate uImage
+	  file from resource/kernel/boot(recovery) partitions. Additional that,
+	  the resource partition can be fdt or resource(recommand) uImage file.
+
+config CMD_BOOT_ROCKCHIP
+	bool "boot_rockchip"
+	default n
+	depends on RKIMG_BOOTLOADER
+	help
+	  Performs the Rockchip Bootloader boot flow, loading the appropriate
+	  Rockchip image (normal kernel, boot, resource and revocery)
+	  and booting it. The boot mode is determined by the contents of the
+	  Rockchip bootloader helper.
+
 config CMD_MMC
 	bool "mmc"
 	help
 	  MMC memory mapped support.
 
+config CMD_MTD
+	bool "mtd"
+	select MTD_PARTITIONS
+	help
+	  MTD commands support.
+
 config CMD_NAND
 	bool "nand"
 	default y if NAND_SUNXI
@@ -831,6 +940,33 @@ config CMD_REMOTEPROC
 	help
 	  Support for Remote Processor control
 
+config CMD_ROCKUSB
+	bool "rockusb - Command to upgrade Rockchip device"
+	depends on USB_GADGET
+	help
+	  Rockusb command provides a way to upgrade firmware for
+	  Rockchip SoC based devices, its design make use of USB
+	  Bulk-Only Transport based on UMS framework.
+
+config CMD_RKNAND
+	bool "rknand"
+	depends on (RKNAND || RKNANDC_NAND)
+	default y if (RKNAND || RKNANDC_NAND)
+	help
+	    Rockchip NAND FLASH device support
+
+config CMD_RKSFC
+	bool "rksfc"
+	depends on (RKSFC_NOR || RKSFC_NAND)
+	default y if (RKSFC_NOR || RKSFC_NAND)
+	help
+	  Rockchip SFC device support
+
+config CMD_RK_SECURE_STORAGE
+	bool "dump rockchip efuse/otp content"
+	help
+	  Dump the data which is written in OTP or efuse.
+
 config CMD_SATA
 	bool "sata - Access SATA subsystem"
 	select SATA
@@ -924,6 +1060,11 @@ config CMD_ITEST
 	help
 	  Return true/false on integer compare.
 
+config CMD_SCRIPT_UPDATE
+	bool "sd_update/usb_update/tftp_update"
+	help
+	  Auto run sd_update/usb_update/tftp_update.txt from sd/udisk/tftp.
+
 config CMD_SOURCE
 	bool "source"
 	default y
@@ -957,6 +1098,22 @@ config CMD_TFTPPUT
 	help
 	  TFTP put command, for uploading files to a server
 
+config CMD_TFTP_BOOTM
+	bool "tftp download and bootm"
+	help
+	  TFTP bootm command, download and bootm the aosp/uImage/FIT Image.
+
+config CMD_TFTP_FLASH
+	bool "tftp download and flash"
+	help
+	  TFTP flash command, download and flash the Image to partition.
+
+config CMD_TFTP_UPDATE
+	bool "tftp update"
+	help
+	  Update a set of images organized with FIT via network using TFTP protocol
+
+
 config CMD_TFTPSRV
 	bool "tftpsrv"
 	help
@@ -1024,6 +1181,16 @@ config CMD_ETHSW
 
 endmenu
 
+config CMD_MEMTESTER
+	bool "Enable memtester for ddr"
+	help
+	  This enables memtester for ddr.
+
+config CMD_DDR_TEST_TOOL
+	bool "Enable ddr test tool"
+	help
+	  This enable ddr test tool code.
+
 menu "Misc commands"
 
 config CMD_BMP
@@ -1110,6 +1277,13 @@ config CMD_GETTIME
 	  milliseconds. See also the 'bootstage' command which provides more
 	  flexibility for boot timing.
 
+config CMD_RNG
+	bool "rng command"
+	depends on DM_RNG
+	select HEXDUMP
+	help
+	  Print bytes from the hardware random number generator.
+
 # TODO: rename to CMD_SLEEP
 config CMD_MISC
 	bool "sleep"
@@ -1204,6 +1378,23 @@ config CMD_REGULATOR
 	  the limits, which are found in device-tree and are kept in regulator's
 	  uclass platdata structure.
 
+config CMD_CHARGE_DISPLAY
+	bool "Enable Driver Model Charge Display command"
+	depends on DM_CHARGE_DISPLAY
+	default y
+	help
+	  Support U-Boot charge display.
+
+config CMD_DVFS
+	bool "Enable Driver Model DVFS command"
+	depends on DM_DVFS
+	default y
+	help
+	  Support dvfs policy apply API
+	  User interface features:
+	  - dvfs            - apply dvfs policy once
+	  - dvfs repeat     - repeat apply dvfs policy until achieve the target temperature
+
 endmenu
 
 menu "Security commands"
@@ -1348,6 +1539,11 @@ config CMD_EXT4_WRITE
 	help
 	  Enables EXT4 FS write command
 
+config CMD_EXT4_SPARSE_WRITE
+	depends on CMD_EXT4
+	bool "ext4 sparse write command support"
+	help
+
 config CMD_FAT
 	bool "FAT command support"
 	select FS_FAT
@@ -1376,18 +1572,29 @@ config CMD_JFFS2
 
 config CMD_MTDPARTS
 	bool "MTD partition support"
+	select MTD_DEVICE if (CMD_NAND || NAND)
 	help
 	  MTD partition support
 
+config CMD_MTD
+	bool "MTD support"
+	help
+	  MTD support
+
+config CMD_MTD_BLK
+	bool "MTD block support"
+	help
+	  MTD block support
+
 config MTDIDS_DEFAULT
 	string "Default MTD IDs"
-	depends on CMD_MTDPARTS
+	depends on CMD_MTD || CMD_MTDPARTS || CMD_NAND || CMD_FLASH
 	help
 	  Defines a default MTD ID
 
 config MTDPARTS_DEFAULT
 	string "Default MTD partition scheme"
-	depends on CMD_MTDPARTS
+	depends on CMD_MTD || CMD_MTDPARTS || CMD_NAND || CMD_FLASH
 	help
 	  Defines a default MTD partitioning scheme in the Linux MTD command
 	  line partitions format
@@ -1446,6 +1653,12 @@ endmenu
 
 menu "Debug commands"
 
+config CMD_ATAGS
+	bool "atags - Dump all rockchip atags"
+	default y
+	help
+	  This command dump all rockchip atags.
+
 config CMD_BEDBUG
 	bool "bedbug"
 	help
@@ -1478,6 +1691,14 @@ config CMD_KGDB
 	  single-stepping, inspecting variables, etc. This is supported only
 	  on PowerPC at present.
 
+config CMD_LOG
+	bool "log - Generation, control and access to logging"
+	help
+	  This provides access to logging features. It allows the output of
+	  log data to be controlled to a limited extent (setting up the default
+	  maximum log level for emitting of records). It also provides access
+	  to a command used for testing the log system.
+
 config CMD_TRACE
 	bool "trace - Support tracing of function calls and timing"
 	help
diff --git a/cmd/Makefile b/cmd/Makefile
index 2a5b8ce825..3f71a35412 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -14,17 +14,24 @@ obj-y += version.o
 
 # command
 obj-$(CONFIG_CMD_AES) += aes.o
+obj-$(CONFIG_CMD_AMBAPP) += ambapp.o
+obj-$(CONFIG_CMD_ANDROID_AB_SELECT) += android_ab_select.o android_cmds.o
 obj-$(CONFIG_CMD_ARMFLASH) += armflash.o
 obj-y += blk_common.o
+obj-y += blk.o
 obj-$(CONFIG_SOURCE) += source.o
 obj-$(CONFIG_CMD_SOURCE) += source.o
 obj-$(CONFIG_CMD_BDI) += bdinfo.o
 obj-$(CONFIG_CMD_BEDBUG) += bedbug.o
 obj-$(CONFIG_CMD_BLOCK_CACHE) += blkcache.o
 obj-$(CONFIG_CMD_BMP) += bmp.o
+obj-$(CONFIG_CMD_BOOT_ANDROID) += boot_android.o android.o
+obj-$(CONFIG_CMD_BOOT_FIT) += bootfit.o
+obj-$(CONFIG_CMD_BOOT_ROCKCHIP) += bootrkp.o
 obj-$(CONFIG_CMD_BOOTEFI) += bootefi.o
 obj-$(CONFIG_CMD_BOOTMENU) += bootmenu.o
 obj-$(CONFIG_CMD_BOOTSTAGE) += bootstage.o
+obj-$(CONFIG_CMD_BOOT_UIMAGE) += bootuimage.o
 obj-$(CONFIG_CMD_BOOTZ) += bootz.o
 obj-$(CONFIG_CMD_BOOTI) += booti.o
 obj-$(CONFIG_CMD_CACHE) += cache.o
@@ -33,6 +40,9 @@ obj-$(CONFIG_CMD_CLK) += clk.o
 obj-$(CONFIG_CMD_CONFIG) += config.o
 obj-$(CONFIG_CMD_CONSOLE) += console.o
 obj-$(CONFIG_CMD_CPU) += cpu.o
+obj-$(CONFIG_CMD_CHARGE_DISPLAY) += charge.o
+obj-$(CONFIG_CMD_CRYPTO) += crypto.o
+obj-$(CONFIG_CMD_CRYPTO_SUM) += crypto_sum.o
 obj-$(CONFIG_DATAFLASH_MMC_SELECT) += dataflash_mmc_mux.o
 obj-$(CONFIG_CMD_DATE) += date.o
 obj-$(CONFIG_CMD_DEMO) += demo.o
@@ -41,6 +51,7 @@ ifdef CONFIG_POST
 obj-$(CONFIG_CMD_DIAG) += diag.o
 endif
 obj-$(CONFIG_CMD_DISPLAY) += display.o
+obj-$(CONFIG_CMD_DTIMG) += dtimg.o
 obj-$(CONFIG_CMD_ECHO) += echo.o
 obj-$(CONFIG_ENV_IS_IN_EEPROM) += eeprom.o
 obj-$(CONFIG_CMD_EEPROM) += eeprom.o
@@ -74,11 +85,14 @@ obj-$(CONFIG_CMD_CRAMFS) += cramfs.o
 obj-$(CONFIG_LED_STATUS_CMD) += legacy_led.o
 obj-$(CONFIG_CMD_LED) += led.o
 obj-$(CONFIG_CMD_LICENSE) += license.o
-obj-y += load.o
-obj-$(CONFIG_LOGBUFFER) += log.o
+obj-y += load.o download.o
+obj-$(CONFIG_CMD_LOAD_ANDROID) += load_android.o android_cmds.o
+obj-$(CONFIG_CMD_LOG) += log.o
 obj-$(CONFIG_ID_EEPROM) += mac.o
 obj-$(CONFIG_CMD_MD5SUM) += md5sum.o
 obj-$(CONFIG_CMD_MEMORY) += mem.o
+obj-$(CONFIG_CMD_MEMTESTER) += memtester/
+obj-$(CONFIG_CMD_DDR_TEST_TOOL) += ddr_tool/
 obj-$(CONFIG_CMD_IO) += io.o
 obj-$(CONFIG_CMD_MFSL) += mfsl.o
 obj-$(CONFIG_CMD_MII) += mii.o
@@ -89,7 +103,9 @@ obj-$(CONFIG_CMD_MISC) += misc.o
 obj-$(CONFIG_CMD_MMC) += mmc.o
 obj-$(CONFIG_CMD_MMC_SPI) += mmc_spi.o
 obj-$(CONFIG_MP) += mp.o
+obj-$(CONFIG_CMD_MTD) += mtd.o
 obj-$(CONFIG_CMD_MTDPARTS) += mtdparts.o
+obj-$(CONFIG_CMD_MTD_BLK) += mtd_blk.o
 obj-$(CONFIG_CMD_NAND) += nand.o
 obj-$(CONFIG_CMD_NET) += net.o
 obj-$(CONFIG_CMD_ONENAND) += onenand.o
@@ -104,9 +120,14 @@ obj-$(CONFIG_CMD_READ) += read.o
 obj-$(CONFIG_CMD_REGINFO) += reginfo.o
 obj-$(CONFIG_CMD_REISER) += reiser.o
 obj-$(CONFIG_CMD_REMOTEPROC) += remoteproc.o
+obj-$(CONFIG_CMD_RNG) += rng.o
 obj-$(CONFIG_SANDBOX) += host.o
 obj-$(CONFIG_CMD_SATA) += sata.o
 obj-$(CONFIG_CMD_NVME) += nvme.o
+obj-$(CONFIG_CMD_ROCKUSB) += rockusb.o
+obj-$(CONFIG_CMD_RKNAND) += rknand.o
+obj-$(CONFIG_CMD_RKSFC) += rksfc.o
+obj-$(CONFIG_CMD_RK_SECURE_STORAGE) += rk_secure_storage.o
 obj-$(CONFIG_CMD_SF) += sf.o
 obj-$(CONFIG_CMD_SCSI) += scsi.o disk.o
 obj-$(CONFIG_CMD_SHA1SUM) += sha1sum.o
@@ -115,6 +136,7 @@ obj-$(CONFIG_CMD_SPI) += spi.o
 obj-$(CONFIG_CMD_STRINGS) += strings.o
 obj-$(CONFIG_CMD_TERMINAL) += terminal.o
 obj-$(CONFIG_CMD_TIME) += time.o
+obj-$(CONFIG_CMD_TFTP_UPDATE) += tftp_update.o
 obj-$(CONFIG_CMD_TRACE) += trace.o
 obj-$(CONFIG_HUSH_PARSER) += test.o
 obj-$(CONFIG_CMD_TPM) += tpm.o
@@ -126,7 +148,7 @@ obj-$(CONFIG_CMD_UBIFS) += ubifs.o
 obj-$(CONFIG_CMD_UNIVERSE) += universe.o
 obj-$(CONFIG_CMD_UNZIP) += unzip.o
 obj-$(CONFIG_CMD_LZMADEC) += lzmadec.o
-
+obj-$(CONFIG_CMD_SCRIPT_UPDATE) += script_update.o
 obj-$(CONFIG_CMD_USB) += usb.o disk.o
 obj-$(CONFIG_CMD_FASTBOOT) += fastboot.o
 obj-$(CONFIG_CMD_FS_UUID) += fs_uuid.o
@@ -144,11 +166,18 @@ obj-$(CONFIG_CMD_DFU) += dfu.o
 obj-$(CONFIG_CMD_GPT) += gpt.o
 obj-$(CONFIG_CMD_ETHSW) += ethsw.o
 
+obj-$(CONFIG_OPTEE_CLIENT) += optee.o
+
 # Power
 obj-$(CONFIG_CMD_PMIC) += pmic.o
 obj-$(CONFIG_CMD_REGULATOR) += regulator.o
+obj-$(CONFIG_CMD_DVFS) += dvfs.o
 
 obj-$(CONFIG_CMD_BLOB) += blob.o
+
+obj-$(CONFIG_ARCH_ROCKCHIP) += rkimgtest.o
+obj-$(CONFIG_CMD_ATAGS) += atags.o
+
 endif # !CONFIG_SPL_BUILD
 
 # core command
diff --git a/cmd/bdinfo.c b/cmd/bdinfo.c
index 27ffcd55bc..1dc0051778 100644
--- a/cmd/bdinfo.c
+++ b/cmd/bdinfo.c
@@ -180,7 +180,7 @@ int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	print_bi_flash(bd);
 	print_num("sramstart",		bd->bi_sramstart);
 	print_num("sramsize",		bd->bi_sramsize);
-#if	defined(CONFIG_8xx) || defined(CONFIG_E500)
+#if	defined(CONFIG_MPC8xx) || defined(CONFIG_E500)
 	print_num("immr_base",		bd->bi_immr_base);
 #endif
 	print_num("bootflags",		bd->bi_bootflags);
@@ -417,6 +417,21 @@ int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 
+#elif defined(CONFIG_RISCV)
+
+int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	bd_t *bd = gd->bd;
+
+	print_num("arch_number", bd->bi_arch_number);
+	print_bi_boot_params(bd);
+	print_bi_dram(bd);
+	print_eth_ip_addr();
+	print_baudrate();
+
+	return 0;
+}
+
 #elif defined(CONFIG_ARC)
 
 int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
diff --git a/cmd/blk_common.c b/cmd/blk_common.c
index 86c75e78d8..95247f127d 100644
--- a/cmd/blk_common.c
+++ b/cmd/blk_common.c
@@ -68,9 +68,8 @@ int blk_common_cmd(int argc, char * const argv[], enum if_type if_type,
 			ulong cnt = simple_strtoul(argv[4], NULL, 16);
 			ulong n;
 
-			printf("\n%s read: device %d block # %lld, count %ld ... ",
-			       if_name, *cur_devnump, (unsigned long long)blk,
-			       cnt);
+			printf("\n%s read: device %d block # "LBAFU", count %lu ... ",
+			       if_name, *cur_devnump, blk, cnt);
 
 			n = blk_read_devnum(if_type, *cur_devnump, blk, cnt,
 					    (ulong *)addr);
@@ -84,9 +83,8 @@ int blk_common_cmd(int argc, char * const argv[], enum if_type if_type,
 			ulong cnt = simple_strtoul(argv[4], NULL, 16);
 			ulong n;
 
-			printf("\n%s write: device %d block # %lld, count %ld ... ",
-			       if_name, *cur_devnump, (unsigned long long)blk,
-			       cnt);
+			printf("\n%s write: device %d block # "LBAFU", count %lu ... ",
+			       if_name, *cur_devnump, blk, cnt);
 
 			n = blk_write_devnum(if_type, *cur_devnump, blk, cnt,
 					     (ulong *)addr);
@@ -94,11 +92,22 @@ int blk_common_cmd(int argc, char * const argv[], enum if_type if_type,
 			printf("%ld blocks written: %s\n", n,
 			       n == cnt ? "OK" : "ERROR");
 			return n == cnt ? 0 : 1;
+		} else if (strcmp(argv[1], "erase") == 0) {
+			lbaint_t blk = simple_strtoul(argv[2], NULL, 16);
+			ulong cnt = simple_strtoul(argv[3], NULL, 16);
+			ulong n;
+
+			printf("\n%s erase: device %d block # "LBAFU", count %lu ... ",
+			       if_name, *cur_devnump, blk, cnt);
+
+			n = blk_erase_devnum(if_type, *cur_devnump, blk, cnt);
+
+			printf("%ld blocks erased: %s\n", n,
+			       n == cnt ? "OK" : "ERROR");
+			return n == cnt ? 0 : 1;
 		} else {
 			return CMD_RET_USAGE;
 		}
-
-		return 0;
 	}
 }
 #endif
diff --git a/cmd/boot.c b/cmd/boot.c
index 72f2cf362d..4f35283d97 100644
--- a/cmd/boot.c
+++ b/cmd/boot.c
@@ -11,6 +11,8 @@
 #include <common.h>
 #include <command.h>
 #include <net.h>
+#include <asm/io.h>
+#include <asm/arch-rockchip/boot_mode.h>
 
 #ifdef CONFIG_CMD_GO
 
@@ -19,6 +21,10 @@ __attribute__((weak))
 unsigned long do_go_exec(ulong (*entry)(int, char * const []), int argc,
 				 char * const argv[])
 {
+#ifdef CONFIG_CPU_V7
+	ulong addr = (ulong)entry | 1;
+	entry = (void *)addr;
+#endif
 	return entry (argc, argv);
 }
 
@@ -53,15 +59,34 @@ U_BOOT_CMD(
 	"addr [arg ...]\n    - start application at address 'addr'\n"
 	"      passing 'arg' as arguments"
 );
-
 #endif
 
+static int do_reboot_brom(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	writel(BOOT_BROM_DOWNLOAD, CONFIG_ROCKCHIP_BOOT_MODE_REG);
+	do_reset(NULL, 0, 0, NULL);
+
+	return 0;
+}
+
+U_BOOT_CMD_ALWAYS(
+	rbrom, 1, 0,	do_reboot_brom,
+	"Reboot to Maskrom mode",
+	""
+);
+
 U_BOOT_CMD(
-	reset, 1, 0,	do_reset,
+	reset, 2, 0,    do_reset,
 	"Perform RESET of the CPU",
 	""
 );
 
+U_BOOT_CMD(
+        reboot, 2, 0,    do_reset,
+        "Perform RESET of the CPU, alias of 'reset'",
+        ""
+);
+
 #ifdef CONFIG_CMD_POWEROFF
 U_BOOT_CMD(
 	poweroff, 1, 0,	do_poweroff,
diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 3196d86040..1cbcdd51a7 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -11,8 +11,8 @@
 #include <dm.h>
 #include <efi_loader.h>
 #include <errno.h>
-#include <libfdt.h>
-#include <libfdt_env.h>
+#include <linux/libfdt.h>
+#include <linux/libfdt_env.h>
 #include <memalign.h>
 #include <asm/global_data.h>
 #include <asm-generic/sections.h>
@@ -22,97 +22,14 @@ DECLARE_GLOBAL_DATA_PTR;
 
 static uint8_t efi_obj_list_initalized;
 
-/*
- * When booting using the "bootefi" command, we don't know which
- * physical device the file came from. So we create a pseudo-device
- * called "bootefi" with the device path /bootefi.
- *
- * In addition to the originating device we also declare the file path
- * of "bootefi" based loads to be /bootefi.
- */
-static struct efi_device_path_file_path bootefi_image_path[] = {
-	{
-		.dp.type = DEVICE_PATH_TYPE_MEDIA_DEVICE,
-		.dp.sub_type = DEVICE_PATH_SUB_TYPE_FILE_PATH,
-		.dp.length = sizeof(bootefi_image_path[0]),
-		.str = { 'b','o','o','t','e','f','i' },
-	}, {
-		.dp.type = DEVICE_PATH_TYPE_END,
-		.dp.sub_type = DEVICE_PATH_SUB_TYPE_END,
-		.dp.length = sizeof(bootefi_image_path[0]),
-	}
-};
-
-static struct efi_device_path_file_path bootefi_device_path[] = {
-	{
-		.dp.type = DEVICE_PATH_TYPE_MEDIA_DEVICE,
-		.dp.sub_type = DEVICE_PATH_SUB_TYPE_FILE_PATH,
-		.dp.length = sizeof(bootefi_image_path[0]),
-		.str = { 'b','o','o','t','e','f','i' },
-	}, {
-		.dp.type = DEVICE_PATH_TYPE_END,
-		.dp.sub_type = DEVICE_PATH_SUB_TYPE_END,
-		.dp.length = sizeof(bootefi_image_path[0]),
-	}
-};
-
-/* The EFI loaded_image interface for the image executed via "bootefi" */
-static struct efi_loaded_image loaded_image_info = {
-	.device_handle = bootefi_device_path,
-	.file_path = bootefi_image_path,
-};
-
-/* The EFI object struct for the image executed via "bootefi" */
-static struct efi_object loaded_image_info_obj = {
-	.handle = &loaded_image_info,
-	.protocols = {
-		{
-			/*
-			 * When asking for the loaded_image interface, just
-			 * return handle which points to loaded_image_info
-			 */
-			.guid = &efi_guid_loaded_image,
-			.protocol_interface = &loaded_image_info,
-		},
-		{
-			/*
-			 * When asking for the device path interface, return
-			 * bootefi_device_path
-			 */
-			.guid = &efi_guid_device_path,
-			.protocol_interface = bootefi_device_path,
-		},
-		{
-			.guid = &efi_guid_console_control,
-			.protocol_interface = (void *) &efi_console_control
-		},
-		{
-			.guid = &efi_guid_device_path_to_text_protocol,
-			.protocol_interface = (void *) &efi_device_path_to_text
-		},
-	},
-};
-
-/* The EFI object struct for the device the "bootefi" image was loaded from */
-static struct efi_object bootefi_device_obj = {
-	.handle = bootefi_device_path,
-	.protocols = {
-		{
-			/* When asking for the device path interface, return
-			 * bootefi_device_path */
-			.guid = &efi_guid_device_path,
-			.protocol_interface = bootefi_device_path
-		}
-	},
-};
+static struct efi_device_path *bootefi_image_path;
+static struct efi_device_path *bootefi_device_path;
 
 /* Initialize and populate EFI object list */
 static void efi_init_obj_list(void)
 {
 	efi_obj_list_initalized = 1;
 
-	list_add_tail(&loaded_image_info_obj.link, &efi_obj_list);
-	list_add_tail(&bootefi_device_obj.link, &efi_obj_list);
 	efi_console_register();
 #ifdef CONFIG_PARTITIONS
 	efi_disk_register();
@@ -121,13 +38,7 @@ static void efi_init_obj_list(void)
 	efi_gop_register();
 #endif
 #ifdef CONFIG_NET
-	void *nethandle = loaded_image_info.device_handle;
-	efi_net_register(&nethandle);
-
-	if (!memcmp(bootefi_device_path[0].str, "N\0e\0t", 6))
-		loaded_image_info.device_handle = nethandle;
-	else
-		loaded_image_info.device_handle = bootefi_device_path;
+	efi_net_register();
 #endif
 #ifdef CONFIG_GENERATE_SMBIOS_TABLE
 	efi_smbios_register();
@@ -210,14 +121,27 @@ static unsigned long efi_run_in_el2(asmlinkage ulong (*entry)(
  * Load an EFI payload into a newly allocated piece of memory, register all
  * EFI objects it would want to access and jump to it.
  */
-static unsigned long do_bootefi_exec(void *efi, void *fdt)
+static unsigned long do_bootefi_exec(void *efi, void *fdt,
+				     struct efi_device_path *device_path,
+				     struct efi_device_path *image_path)
 {
+	struct efi_loaded_image loaded_image_info = {};
+	struct efi_object loaded_image_info_obj = {};
+	ulong ret;
+
 	ulong (*entry)(void *image_handle, struct efi_system_table *st)
 		asmlinkage;
 	ulong fdt_pages, fdt_size, fdt_start, fdt_end;
 	const efi_guid_t fdt_guid = EFI_FDT_GUID;
 	bootm_headers_t img = { 0 };
 
+	/* Initialize and populate EFI object list */
+	if (!efi_obj_list_initalized)
+		efi_init_obj_list();
+
+	efi_setup_loaded_image(&loaded_image_info, &loaded_image_info_obj,
+			       device_path, image_path);
+
 	/*
 	 * gd lives in a fixed register which may get clobbered while we execute
 	 * the payload. So save it here and restore it on every callback entry
@@ -252,18 +176,18 @@ static unsigned long do_bootefi_exec(void *efi, void *fdt)
 
 	/* Load the EFI payload */
 	entry = efi_load_pe(efi, &loaded_image_info);
-	if (!entry)
-		return -ENOENT;
-
-	/* Initialize and populate EFI object list */
-	if (!efi_obj_list_initalized)
-		efi_init_obj_list();
+	if (!entry) {
+		ret = -ENOENT;
+		goto exit;
+	}
 
 	/* Call our payload! */
 	debug("%s:%d Jumping to 0x%lx\n", __func__, __LINE__, (long)entry);
 
 	if (setjmp(&loaded_image_info.exit_jmp)) {
-		return loaded_image_info.exit_status;
+		ret = loaded_image_info.exit_status;
+		EFI_EXIT(ret);
+		goto exit;
 	}
 
 #ifdef CONFIG_ARM64
@@ -282,7 +206,13 @@ static unsigned long do_bootefi_exec(void *efi, void *fdt)
 	}
 #endif
 
-	return efi_do_enter(&loaded_image_info, &systab, entry);
+	ret = efi_do_enter(&loaded_image_info, &systab, entry);
+
+exit:
+	/* image has returned, loaded-image obj goes *poof*: */
+	list_del(&loaded_image_info_obj.link);
+
+	return ret;
 }
 
 
@@ -299,7 +229,11 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (!strcmp(argv[1], "hello")) {
 		ulong size = __efi_hello_world_end - __efi_hello_world_begin;
 
-		addr = CONFIG_SYS_LOAD_ADDR;
+		saddr = env_get("loadaddr");
+		if (saddr)
+			addr = simple_strtoul(saddr, NULL, 16);
+		else
+			addr = CONFIG_SYS_LOAD_ADDR;
 		memcpy((char *)addr, __efi_hello_world_begin, size);
 	} else
 #endif
@@ -315,7 +249,8 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	}
 
 	printf("## Starting EFI application at %08lx ...\n", addr);
-	r = do_bootefi_exec((void *)addr, (void*)fdt_addr);
+	r = do_bootefi_exec((void *)addr, (void *)fdt_addr,
+			    bootefi_device_path, bootefi_image_path);
 	printf("## Application terminated, r = %lu\n",
 	       r & ~EFI_ERROR_MASK);
 
@@ -344,58 +279,44 @@ U_BOOT_CMD(
 	bootefi_help_text
 );
 
-void efi_set_bootdev(const char *dev, const char *devnr, const char *path)
+static int parse_partnum(const char *devnr)
 {
-	__maybe_unused struct blk_desc *desc;
-	char devname[32] = { 0 }; /* dp->str is u16[32] long */
-	char *colon, *s;
-
-#if defined(CONFIG_BLK) || CONFIG_IS_ENABLED(ISO_PARTITION)
-	desc = blk_get_dev(dev, simple_strtol(devnr, NULL, 10));
-#endif
-
-#ifdef CONFIG_BLK
-	if (desc) {
-		snprintf(devname, sizeof(devname), "%s", desc->bdev->name);
-	} else
-#endif
-
-	{
-		/* Assemble the condensed device name we use in efi_disk.c */
-		snprintf(devname, sizeof(devname), "%s%s", dev, devnr);
+	const char *str = strchr(devnr, ':');
+	if (str) {
+		str++;
+		return simple_strtoul(str, NULL, 16);
 	}
+	return 0;
+}
 
-	colon = strchr(devname, ':');
-
-#if CONFIG_IS_ENABLED(ISO_PARTITION)
-	/* For ISOs we create partition block devices */
-	if (desc && (desc->type != DEV_TYPE_UNKNOWN) &&
-	    (desc->part_type == PART_TYPE_ISO)) {
-		if (!colon)
-			snprintf(devname, sizeof(devname), "%s:1", devname);
+void efi_set_bootdev(const char *dev, const char *devnr, const char *path)
+{
+	char filename[32] = { 0 }; /* dp->str is u16[32] long */
+	char *s;
 
-		colon = NULL;
-	}
-#endif
+	if (strcmp(dev, "Net")) {
+		struct blk_desc *desc;
+		int part;
 
-	if (colon)
-		*colon = '\0';
+		desc = blk_get_dev(dev, simple_strtol(devnr, NULL, 10));
+		part = parse_partnum(devnr);
 
-	/* Patch bootefi_device_path to the target device */
-	memset(bootefi_device_path[0].str, 0, sizeof(bootefi_device_path[0].str));
-	ascii2unicode(bootefi_device_path[0].str, devname);
+		bootefi_device_path = efi_dp_from_part(desc, part);
+	} else {
+#ifdef CONFIG_NET
+		bootefi_device_path = efi_dp_from_eth();
+#endif
+	}
 
-	/* Patch bootefi_image_path to the target file path */
-	memset(bootefi_image_path[0].str, 0, sizeof(bootefi_image_path[0].str));
 	if (strcmp(dev, "Net")) {
 		/* Add leading / to fs paths, because they're absolute */
-		snprintf(devname, sizeof(devname), "/%s", path);
+		snprintf(filename, sizeof(filename), "/%s", path);
 	} else {
-		snprintf(devname, sizeof(devname), "%s", path);
+		snprintf(filename, sizeof(filename), "%s", path);
 	}
 	/* DOS style file path: */
-	s = devname;
+	s = filename;
 	while ((s = strchr(s, '/')))
 		*s++ = '\\';
-	ascii2unicode(bootefi_image_path[0].str, devname);
+	bootefi_image_path = efi_dp_from_file(NULL, 0, filename);
 }
diff --git a/cmd/bootm.c b/cmd/bootm.c
index df0bbe19ca..1eed38ff45 100644
--- a/cmd/bootm.c
+++ b/cmd/bootm.c
@@ -104,6 +104,9 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		relocated = 1;
 	}
 #endif
+	/* board routines */
+	if (board_do_bootm(argc, argv))
+		return -EPERM;
 
 	/* determine if we have a sub command */
 	argc--; argv++;
diff --git a/cmd/eeprom.c b/cmd/eeprom.c
index c61b396a62..7608be10f5 100644
--- a/cmd/eeprom.c
+++ b/cmd/eeprom.c
@@ -68,7 +68,7 @@ __weak int eeprom_write_enable(unsigned dev_addr, int state)
 void eeprom_init(int bus)
 {
 	/* SPI EEPROM */
-#if defined(CONFIG_SPI) && !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
+#if defined(CONFIG_MPC8XX_SPI) && !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
 	spi_init_f();
 #endif
 
@@ -131,7 +131,7 @@ static int eeprom_rw_block(unsigned offset, uchar *addr, unsigned alen,
 	int ret = 0;
 
 	/* SPI */
-#if defined(CONFIG_SPI) && !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
+#if defined(CONFIG_MPC8XX_SPI) && !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
 	if (read)
 		spi_read(addr, alen, buffer, len);
 	else
diff --git a/cmd/ext4.c b/cmd/ext4.c
index 19423d1c81..8074b8d00e 100644
--- a/cmd/ext4.c
+++ b/cmd/ext4.c
@@ -74,6 +74,34 @@ U_BOOT_CMD(ext4write, 7, 1, do_ext4_write,
 
 #endif
 
+#if defined(CONFIG_CMD_EXT4_SPARSE_WRITE)
+int do_ext4_sparse_write(cmd_tbl_t *cmdtp, int flag, int argc,
+			 char *const argv[])
+{
+	struct blk_desc *desc;
+	ulong buf, blk;
+
+	if (argc != 5)
+		return CMD_RET_USAGE;
+
+	desc = blk_get_dev(argv[1], simple_strtoul(argv[2], NULL, 16));
+	if (!desc) {
+		printf("Cannot get %s %s device\n", argv[1], argv[2]);
+		return CMD_RET_FAILURE;
+	}
+
+	buf = simple_strtoul(argv[3], NULL, 16);
+	blk = simple_strtoul(argv[4], NULL, 16);
+
+	return ext4_unsparse(desc, (const u8 *)buf, blk) ?
+				CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(ext4write_sparse, 5, 1, do_ext4_sparse_write,
+	   "Unsparse file and write to block",
+	   "<interface> <dev> <addr> <blk#>");
+#endif
+
 U_BOOT_CMD(
 	ext4size,	4,	0,	do_ext4_size,
 	"determine a file's size",
diff --git a/cmd/fastboot.c b/cmd/fastboot.c
index 488822a2ee..b84887dd61 100644
--- a/cmd/fastboot.c
+++ b/cmd/fastboot.c
@@ -11,23 +11,45 @@
 #include <command.h>
 #include <console.h>
 #include <g_dnl.h>
+#include <net.h>
 #include <usb.h>
+#include <sysmem.h>
 
 static int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
+#ifdef CONFIG_USB_FUNCTION_FASTBOOT
 	int controller_index;
 	char *usb_controller;
 	int ret;
-
+#endif
 	if (argc < 2)
 		return CMD_RET_USAGE;
 
-	usb_controller = argv[1];
+	printf("Enter fastboot...");
+
+	if (!strcmp(argv[1], "udp")) {
+#ifndef CONFIG_UDP_FUNCTION_FASTBOOT
+		pr_err("Fastboot UDP not enabled\n");
+		return -1;
+#else
+		return do_fastboot_udp(cmdtp, flag, argc, argv);
+#endif
+	}
+
+	if (strcmp(argv[1], "usb") || argc < 3)
+		return CMD_RET_USAGE;
+
+#ifndef CONFIG_USB_FUNCTION_FASTBOOT
+	pr_err("Fastboot USB not enabled\n");
+	return -1;
+#else
+
+	usb_controller = argv[2];
 	controller_index = simple_strtoul(usb_controller, NULL, 0);
 
-	ret = board_usb_init(controller_index, USB_INIT_DEVICE);
+	ret = usb_gadget_initialize(controller_index);
 	if (ret) {
-		error("USB init failed: %d", ret);
+		pr_err("USB init failed: %d", ret);
 		return CMD_RET_FAILURE;
 	}
 
@@ -43,6 +65,15 @@ static int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 		goto exit;
 	}
 
+	if (!sysmem_alloc_base(MEM_FASTBOOT,
+			       CONFIG_FASTBOOT_BUF_ADDR,
+			       CONFIG_FASTBOOT_BUF_SIZE)) {
+		printf("The fastboot memory space is unusable!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	printf("OK\n");
+
 	while (1) {
 		if (g_dnl_detach())
 			break;
@@ -54,16 +85,20 @@ static int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 	ret = CMD_RET_SUCCESS;
 
 exit:
+	sysmem_free(CONFIG_FASTBOOT_BUF_ADDR);
 	g_dnl_unregister();
 	g_dnl_clear_detach();
-	board_usb_cleanup(controller_index, USB_INIT_DEVICE);
+	usb_gadget_release(controller_index);
 
 	return ret;
+#endif
 }
 
 U_BOOT_CMD(
-	fastboot, 2, 1, do_fastboot,
-	"use USB Fastboot protocol",
-	"<USB_controller>\n"
-	"    - run as a fastboot usb device"
+	fastboot, 3, 1, do_fastboot,
+	"use USB or UDP Fastboot protocol",
+	"[usb,udp] <USB_controller>\n"
+	" - run as a fastboot usb or udp device\n"
+	"   usb: specify <USB_controller>\n"
+	"   udp: requires ip_addr set and ethernet initialized\n"
 );
diff --git a/cmd/fastboot/Kconfig b/cmd/fastboot/Kconfig
index fb0c5da94c..64ab6c6ee7 100644
--- a/cmd/fastboot/Kconfig
+++ b/cmd/fastboot/Kconfig
@@ -11,17 +11,25 @@ config USB_FUNCTION_FASTBOOT
 	help
 	  This enables the USB part of the fastboot gadget.
 
+config UDP_FUNCTION_FASTBOOT
+	select NET
+	bool "Enable fastboot protocol over UDP"
+	help
+	  This enables the fastboot protocol over UDP.
+
 config CMD_FASTBOOT
 	bool "Enable FASTBOOT command"
+	depends on USB_FUNCTION_FASTBOOT || UDP_FUNCTION_FASTBOOT
 	help
 	  This enables the command "fastboot" which enables the Android
-	  fastboot mode for the platform's USB device. Fastboot is a USB
-	  protocol for downloading images, flashing and device control
-	  used on Android devices.
+	  fastboot mode for the platform. Fastboot is a protocol for
+	  downloading images, flashing and device control used on
+	  Android devices. Fastboot requires either network stack
+	  enabled or support for acting as a USB device.
 
 	  See doc/README.android-fastboot for more information.
 
-if USB_FUNCTION_FASTBOOT
+if USB_FUNCTION_FASTBOOT || UDP_FUNCTION_FASTBOOT
 
 config FASTBOOT_BUF_ADDR
 	hex "Define FASTBOOT buffer address"
@@ -29,8 +37,8 @@ config FASTBOOT_BUF_ADDR
 	default 0x81000000 if ARCH_OMAP2PLUS
 	default 0x42000000 if ARCH_SUNXI && !MACH_SUN9I
 	default 0x22000000 if ARCH_SUNXI && MACH_SUN9I
-	default 0x60800800 if ROCKCHIP_RK3036 || ROCKCHIP_RK3188 || \
-				ROCKCHIP_RK322X
+	default 0x60800800 if ROCKCHIP_RK3036 || ROCKCHIP_RK3066 || \
+				ROCKCHIP_RK3188 || ROCKCHIP_RK322X
 	default 0x800800 if ROCKCHIP_RK3288 || ROCKCHIP_RK3329 || \
 				ROCKCHIP_RK3399
 	default 0x280000 if ROCKCHIP_RK3368
@@ -74,29 +82,21 @@ config FASTBOOT_FLASH_MMC_DEV
 	  regarding the non-volatile storage device. Define this to
 	  the eMMC device that fastboot should use to store the image.
 
-config FASTBOOT_GPT_NAME
-	string "Target name for updating GPT"
-	depends on FASTBOOT_FLASH
-	default "gpt"
+config FASTBOOT_OEM_UNLOCK
+	bool "Enable FASTBOOT OEM UNLOCK command"
+	depends on ANDROID_KEYMASTER_CA
 	help
-	  The fastboot "flash" command supports writing the downloaded
-	  image to the Protective MBR and the Primary GUID Partition
-	  Table. (Additionally, this downloaded image is post-processed
-	  to generate and write the Backup GUID Partition Table.)
-	  This occurs when the specified "partition name" on the
-	  "fastboot flash" command line matches the value defined here.
-	  The default target name for updating GPT is "gpt".
-
-config FASTBOOT_MBR_NAME
-	string "Target name for updating MBR"
-	depends on FASTBOOT_FLASH
-	default "mbr"
+	  This enables the command "fastboot oem unlock" the fastboot
+	  oem unlock command requires tee security storage to store
+	  unlock status. oem unlock status attach to bootargs on boot.
+
+config RK_AVB_LIBAVB_ENABLE_ATH_UNLOCK
+	bool "AVB Authenticated unlock function"
+	depends on ANDROID_AVB
 	help
-	  The fastboot "flash" command allows to write the downloaded image
-	  to the Master Boot Record. This occurs when the "partition name"
-	  specified on the "fastboot flash" command line matches the value
-	  defined here. The default target name for updating MBR is "mbr".
+	  Enabled authenticated unlock function can prevent lock state
+	  from invalid unlock cmd.
 
-endif # USB_FUNCTION_FASTBOOT
+endif # USB_FUNCTION_FASTBOOT || UDP_FUNCTION_FASTBOOT
 
 endif # FASTBOOT
diff --git a/cmd/fdt.c b/cmd/fdt.c
index d7654b2c4f..0a1e725711 100644
--- a/cmd/fdt.c
+++ b/cmd/fdt.c
@@ -13,7 +13,7 @@
 #include <linux/ctype.h>
 #include <linux/types.h>
 #include <asm/global_data.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #include <mapmem.h>
 #include <asm/io.h>
@@ -151,11 +151,9 @@ static int do_fdt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	}
 
 	if (!working_fdt) {
-		puts(
-			"No FDT memory address configured. Please configure\n"
-			"the FDT address via \"fdt addr <address>\" command.\n"
-			"Aborting!\n");
-		return CMD_RET_FAILURE;
+		working_fdt = (void *)gd->fdt_blob;
+		printf("No FDT memory address configured. Default at 0x%08lx\n",
+		       (ulong)gd->fdt_blob);
 	}
 
 	/*
@@ -256,7 +254,7 @@ static int do_fdt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		char *pathp;		/* path */
 		char *prop;		/* property */
 		int  nodeoffset;	/* node offset from libfdt */
-		static char data[SCRATCHPAD];	/* storage for the property */
+		static char data[SCRATCHPAD] __aligned(4);/* property storage */
 		const void *ptmp;
 		int  len;		/* new length of the property */
 		int  ret;		/* return value */
@@ -667,11 +665,10 @@ static int do_fdt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		if (!fdt_valid(&blob))
 			return CMD_RET_FAILURE;
 
-		ret = fdt_overlay_apply(working_fdt, blob);
-		if (ret) {
-			printf("fdt_overlay_apply(): %s\n", fdt_strerror(ret));
+		/* apply method prints messages on error */
+		ret = fdt_overlay_apply_verbose(working_fdt, blob);
+		if (ret)
 			return CMD_RET_FAILURE;
-		}
 	}
 #endif
 	/* resize the fdt */
diff --git a/cmd/flash.c b/cmd/flash.c
index b150940bf3..a2803e8ee4 100644
--- a/cmd/flash.c
+++ b/cmd/flash.c
@@ -11,10 +11,6 @@
 #include <common.h>
 #include <command.h>
 
-#ifdef CONFIG_HAS_DATAFLASH
-#include <dataflash.h>
-#endif
-
 #if defined(CONFIG_CMD_MTDPARTS)
 #include <jffs2/jffs2.h>
 
@@ -279,10 +275,6 @@ static int do_flinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	ulong bank;
 #endif
 
-#ifdef CONFIG_HAS_DATAFLASH
-	dataflash_print_info();
-#endif
-
 #ifdef CONFIG_MTD_NOR_FLASH
 	if (argc == 1) {	/* print info for all FLASH banks */
 		for (bank=0; bank <CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
@@ -451,10 +443,7 @@ static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	u8 dev_type, dev_num, pnum;
 #endif
 #endif /* CONFIG_MTD_NOR_FLASH */
-#ifdef CONFIG_HAS_DATAFLASH
-	int status;
-#endif
-#if defined(CONFIG_MTD_NOR_FLASH) || defined(CONFIG_HAS_DATAFLASH)
+#if defined(CONFIG_MTD_NOR_FLASH)
 	int p;
 	ulong addr_first, addr_last;
 #endif
@@ -462,7 +451,7 @@ static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (argc < 3)
 		return CMD_RET_USAGE;
 
-#if defined(CONFIG_MTD_NOR_FLASH) || defined(CONFIG_HAS_DATAFLASH)
+#if defined(CONFIG_MTD_NOR_FLASH)
 	if (strcmp(argv[1], "off") == 0)
 		p = 0;
 	else if (strcmp(argv[1], "on") == 0)
@@ -471,24 +460,6 @@ static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		return CMD_RET_USAGE;
 #endif
 
-#ifdef CONFIG_HAS_DATAFLASH
-	if ((strcmp(argv[2], "all") != 0) && (strcmp(argv[2], "bank") != 0)) {
-		addr_first = simple_strtoul(argv[2], NULL, 16);
-		addr_last  = simple_strtoul(argv[3], NULL, 16);
-
-		if (addr_dataflash(addr_first) && addr_dataflash(addr_last)) {
-			status = dataflash_real_protect(p,addr_first,addr_last);
-			if (status < 0){
-				puts ("Bad DataFlash sector specification\n");
-				return 1;
-			}
-			printf("%sProtect %d DataFlash Sectors\n",
-				p ? "" : "Un-", status);
-			return 0;
-		}
-	}
-#endif
-
 #ifdef CONFIG_MTD_NOR_FLASH
 	if (strcmp(argv[2], "all") == 0) {
 		for (bank=1; bank<=CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
diff --git a/cmd/fs.c b/cmd/fs.c
index abfe5be172..b7ca1f3ea3 100644
--- a/cmd/fs.c
+++ b/cmd/fs.c
@@ -27,8 +27,10 @@ U_BOOT_CMD(
 static int do_load_wrapper(cmd_tbl_t *cmdtp, int flag, int argc,
 				char * const argv[])
 {
+#ifdef CONFIG_CMD_BOOTEFI
 	efi_set_bootdev(argv[1], (argc > 2) ? argv[2] : "",
 			(argc > 4) ? argv[4] : "");
+#endif
 	return do_load(cmdtp, flag, argc, argv, FS_TYPE_ANY);
 }
 
diff --git a/cmd/gpt.c b/cmd/gpt.c
index 638aa19826..27dd98755a 100644
--- a/cmd/gpt.c
+++ b/cmd/gpt.c
@@ -190,10 +190,9 @@ static void del_gpt_info(void)
 static struct disk_part *allocate_disk_part(disk_partition_t *info, int partnum)
 {
 	struct disk_part *newpart;
-	newpart = malloc(sizeof(*newpart));
+	newpart = calloc(1, sizeof(struct disk_part));
 	if (!newpart)
 		return ERR_PTR(-ENOMEM);
-	memset(newpart, '\0', sizeof(newpart));
 
 	newpart->gpt_part_info.start = info->start;
 	newpart->gpt_part_info.size = info->size;
@@ -403,7 +402,7 @@ static int set_gpt_info(struct blk_desc *dev_desc,
 	if (!val) {
 #ifdef CONFIG_RANDOM_UUID
 		*str_disk_guid = malloc(UUID_STR_LEN + 1);
-		if (str_disk_guid == NULL)
+		if (*str_disk_guid == NULL)
 			return -ENOMEM;
 		gen_rand_uuid_str(*str_disk_guid, UUID_STR_FORMAT_STD);
 #else
@@ -634,6 +633,21 @@ static int do_disk_guid(struct blk_desc *dev_desc, char * const namestr)
 }
 
 #ifdef CONFIG_CMD_GPT_RENAME
+/*
+ * There are 3 malloc() calls in set_gpt_info() and there is no info about which
+ * failed.
+ */
+static void set_gpt_cleanup(char **str_disk_guid,
+			    disk_partition_t **partitions)
+{
+#ifdef CONFIG_RANDOM_UUID
+	if (str_disk_guid)
+		free(str_disk_guid);
+#endif
+	if (partitions)
+		free(partitions);
+}
+
 static int do_rename_gpt_parts(struct blk_desc *dev_desc, char *subcomm,
 			       char *name1, char *name2)
 {
@@ -652,19 +666,27 @@ static int do_rename_gpt_parts(struct blk_desc *dev_desc, char *subcomm,
 	ret = get_disk_guid(dev_desc, disk_guid);
 	if (ret < 0)
 		return ret;
+	/*
+	 * Allocates disk_partitions, requiring matching call to del_gpt_info()
+	 * if successful.
+	 */
 	numparts = get_gpt_info(dev_desc);
 	if (numparts <=  0)
 		return numparts ? numparts : -ENODEV;
 
 	partlistlen = calc_parts_list_len(numparts);
 	partitions_list = malloc(partlistlen);
-	if (partitions_list == NULL)
+	if (!partitions_list) {
+		del_gpt_info();
 		return -ENOMEM;
+	}
 	memset(partitions_list, '\0', partlistlen);
 
 	ret = create_gpt_partitions_list(numparts, disk_guid, partitions_list);
-	if (ret < 0)
+	if (ret < 0) {
+		free(partitions_list);
 		return ret;
+	}
 	/*
 	 * Uncomment the following line to print a string that 'gpt write'
 	 * or 'gpt verify' will accept as input.
@@ -672,15 +694,23 @@ static int do_rename_gpt_parts(struct blk_desc *dev_desc, char *subcomm,
 	debug("OLD partitions_list is %s with %u chars\n", partitions_list,
 	      (unsigned)strlen(partitions_list));
 
+	/* set_gpt_info allocates new_partitions and str_disk_guid */
 	ret = set_gpt_info(dev_desc, partitions_list, &str_disk_guid,
 			   &new_partitions, &part_count);
-	if (ret < 0)
-		return ret;
+	if (ret < 0) {
+		del_gpt_info();
+		free(partitions_list);
+		if (ret == -ENOMEM)
+			set_gpt_cleanup(&str_disk_guid, &new_partitions);
+		else
+			goto out;
+	}
 
 	if (!strcmp(subcomm, "swap")) {
 		if ((strlen(name1) > PART_NAME_LEN) || (strlen(name2) > PART_NAME_LEN)) {
 			printf("Names longer than %d characters are truncated.\n", PART_NAME_LEN);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto out;
 		}
 		list_for_each(pos, &disk_partitions) {
 			curr = list_entry(pos, struct disk_part, list);
@@ -694,21 +724,24 @@ static int do_rename_gpt_parts(struct blk_desc *dev_desc, char *subcomm,
 		}
 		if ((ctr1 + ctr2 < 2) || (ctr1 != ctr2)) {
 			printf("Cannot swap partition names except in pairs.\n");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto out;
 		}
 	} else { /* rename */
 		if (strlen(name2) > PART_NAME_LEN) {
 			printf("Names longer than %d characters are truncated.\n", PART_NAME_LEN);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto out;
 		}
 		partnum = (int)simple_strtol(name1, NULL, 10);
 		if ((partnum < 0) || (partnum > numparts)) {
 			printf("Illegal partition number %s\n", name1);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto out;
 		}
 		ret = part_get_info(dev_desc, partnum, new_partitions);
 		if (ret < 0)
-			return ret;
+			goto out;
 
 		/* U-Boot partition numbering starts at 1 */
 		list_for_each(pos, &disk_partitions) {
@@ -723,33 +756,50 @@ static int do_rename_gpt_parts(struct blk_desc *dev_desc, char *subcomm,
 
 	ret = create_gpt_partitions_list(numparts, disk_guid, partitions_list);
 	if (ret < 0)
-		return ret;
+		goto out;
 	debug("NEW partitions_list is %s with %u chars\n", partitions_list,
 	      (unsigned)strlen(partitions_list));
 
 	ret = set_gpt_info(dev_desc, partitions_list, &str_disk_guid,
 			   &new_partitions, &part_count);
-	if (ret < 0)
-		return ret;
+	/*
+	 * Even though valid pointers are here passed into set_gpt_info(),
+	 * it mallocs again, and there's no way to tell which failed.
+	 */
+	if (ret < 0) {
+		del_gpt_info();
+		free(partitions_list);
+		if (ret == -ENOMEM)
+			set_gpt_cleanup(&str_disk_guid, &new_partitions);
+		else
+			goto out;
+	}
 
 	debug("Writing new partition table\n");
 	ret = gpt_restore(dev_desc, disk_guid, new_partitions, numparts);
 	if (ret < 0) {
 		printf("Writing new partition table failed\n");
-		return ret;
+		goto out;
 	}
 
 	debug("Reading back new partition table\n");
+	/*
+	 * Empty the existing disk_partitions list, as otherwise the memory in
+	 * the original list is unreachable.
+	 */
+	del_gpt_info();
 	numparts = get_gpt_info(dev_desc);
-	if (numparts <=  0)
-		return numparts ? numparts : -ENODEV;
+	if (numparts <=  0) {
+		ret = numparts ? numparts : -ENODEV;
+		goto out;
+	}
 	printf("new partition table with %d partitions is:\n", numparts);
 	print_gpt_info();
-
 	del_gpt_info();
-	free(partitions_list);
-	free(str_disk_guid);
+ out:
 	free(new_partitions);
+	free(str_disk_guid);
+	free(partitions_list);
 	return ret;
 }
 #endif
diff --git a/cmd/i2c.c b/cmd/i2c.c
index 3dd7c6ba4d..bfddf8be1b 100644
--- a/cmd/i2c.c
+++ b/cmd/i2c.c
@@ -1156,7 +1156,10 @@ static int do_sdram (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 	uint	chip;
 	u_char	data[128];
 	u_char	cksum;
-	int	j;
+	int	j, ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	static const char *decode_CAS_DDR2[] = {
 		" TBD", " 6", " 5", " 4", " 3", " 2", " TBD", " TBD"
@@ -1210,7 +1213,14 @@ static int do_sdram (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 	 */
 	chip = simple_strtoul (argv[1], NULL, 16);
 
-	if (i2c_read (chip, 0, 1, data, sizeof (data)) != 0) {
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret)
+		ret = dm_i2c_read(dev, 0, data, sizeof(data));
+#else
+	ret = i2c_read(chip, 0, 1, data, sizeof(data));
+#endif
+	if (ret) {
 		puts ("No SDRAM Serial Presence Detect found.\n");
 		return 1;
 	}
diff --git a/cmd/jffs2.c b/cmd/jffs2.c
index aee2f4513d..13c533cf12 100644
--- a/cmd/jffs2.c
+++ b/cmd/jffs2.c
@@ -80,7 +80,7 @@
 #include <cramfs/cramfs_fs.h>
 
 #if defined(CONFIG_CMD_NAND)
-#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
 #include <nand.h>
 #endif
 
diff --git a/cmd/load.c b/cmd/load.c
index 519c309a61..8f03bac223 100644
--- a/cmd/load.c
+++ b/cmd/load.c
@@ -9,6 +9,7 @@
  * Serial up- and download support
  */
 #include <common.h>
+#include <boot_rkimg.h>
 #include <command.h>
 #include <console.h>
 #include <s_record.h>
@@ -20,6 +21,7 @@ DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_CMD_LOADB)
 static ulong load_serial_ymodem(ulong offset, int mode);
+static ulong load_serial_zmodem(ulong offset);
 #endif
 
 #if defined(CONFIG_CMD_LOADS)
@@ -465,6 +467,12 @@ static int do_load_serial_bin(cmd_tbl_t *cmdtp, int flag, int argc,
 
 		addr = load_serial_ymodem(offset, xyzModem_ymodem);
 
+	} else if (strcmp(argv[0],"loadz")==0) {
+		printf("## Ready for binary (zmodem) download"
+			"to 0x%08lX at %d bps...\n",
+			offset, load_baudrate);
+		addr = load_serial_zmodem(offset);
+
 	} else if (strcmp(argv[0],"loadx")==0) {
 		printf("## Ready for binary (xmodem) download "
 			"to 0x%08lX at %d bps...\n",
@@ -951,6 +959,27 @@ static int getcxmodem(void) {
 		return (getc());
 	return -1;
 }
+
+extern int zmodem_rx(unsigned int addr, int *rxsize);
+static ulong load_serial_zmodem(ulong offset)
+{
+	int size = 0;
+	int res;
+
+	printf("Start to run ZModem\n");
+	res = zmodem_rx(offset, &size);
+	if (res) {
+	       printf("ZModem download error, ret=%d\n", res);
+	       return offset;
+	}
+
+	flush_cache(offset, ALIGN(size, ARCH_DMA_MINALIGN));
+	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
+	env_set_hex("filesize", size);
+
+	return offset;
+}
+
 static ulong load_serial_ymodem(ulong offset, int mode)
 {
 	int size;
@@ -1005,6 +1034,80 @@ static ulong load_serial_ymodem(ulong offset, int mode)
 	return offset;
 }
 
+static int do_loadz_flash(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char * const argv[])
+{
+	struct blk_desc *dev_desc;
+	disk_partition_t part;
+	const char *part_name;
+	char cmd[64];
+	ulong addr, size;
+	int ret, blknum;
+	int baudrate;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	addr = simple_strtol(argv[1], NULL, 16);
+	baudrate = (int)simple_strtoul(argv[2], NULL, 10);
+	part_name = argv[3];
+
+	/* search partition */
+	dev_desc = rockchip_get_bootdev();
+	if (!dev_desc) {
+		printf("No boot device\n");
+		return -ENODEV;
+	}
+
+	ret = part_get_info_by_name(dev_desc, part_name, &part);
+	if (ret < 0) {
+		printf("No partition '%s'\n", part_name);
+		return -EINVAL;
+	}
+
+	snprintf(cmd, 64, "loadz 0x%08lx %d\n", addr, baudrate);
+	ret = run_command(cmd, 0);
+	if (ret) {
+		printf("loadz failed, ret=%d\n", ret);
+		return CMD_RET_FAILURE;
+	}
+
+	size = env_get_ulong("filesize", 16, 0);
+	if (!size) {
+		printf("loadz empty file\n");
+		return CMD_RET_FAILURE;
+	}
+
+	/* flash */
+	blknum = DIV_ROUND_UP(size, dev_desc->blksz);
+	if (blknum > part.size) {
+		printf("File size 0x%lx is too large to flash\n", size);
+		return CMD_RET_FAILURE;
+	}
+
+#ifdef CONFIG_CMD_CRYPTO_SUM
+	snprintf(cmd, 64, "crypto_sum sha256 0x%lx 0x%lx", addr, size);
+	run_command(cmd, 0);
+#elif defined(CONFIG_CMD_HASH)
+	snprintf(cmd, 64, "hash sha256 0x%lx 0x%lx", addr, size);
+	run_command(cmd, 0);
+#endif
+
+	printf("## Flash data to partition %s@0x%lx sector with size 0x%lx ... ",
+		part_name, (ulong)part.start, (ulong)size);
+	if (dev_desc->if_type == IF_TYPE_MTD)
+		dev_desc->op_flag |= BLK_MTD_CONT_WRITE;
+	ret = blk_dwrite(dev_desc, part.start, blknum, (void *)addr);
+	if (dev_desc->if_type == IF_TYPE_MTD)
+		dev_desc->op_flag &= ~(BLK_MTD_CONT_WRITE);
+	if (ret != blknum) {
+		printf("Failed(%d)\n\n", ret);
+		return CMD_RET_FAILURE;
+	}
+	printf("OK\n\n");
+
+	return CMD_RET_SUCCESS;
+}
 #endif
 
 /* -------------------------------------------------------------------- */
@@ -1080,4 +1183,19 @@ U_BOOT_CMD(
 	" with offset 'off' and baudrate 'baud'"
 );
 
+U_BOOT_CMD(
+	loadz, 3, 0,	do_load_serial_bin,
+	"load binary file over serial line (zmodem mode)",
+	"[ off ] [ baud ]\n"
+	"    - load binary file over serial line"
+	" with offset 'off' and baudrate 'baud'"
+);
+
+U_BOOT_CMD(
+	loadzflash, 4, 0, do_loadz_flash,
+	"load binary file over serial line (zmodem mode) and flash to partition",
+	"[ off ] [ baud ] [partition]\n"
+	"    - load binary file over serial line"
+	" with offset 'off' and baudrate 'baud' and flash to 'partition'"
+);
 #endif	/* CONFIG_CMD_LOADB */
diff --git a/cmd/log.c b/cmd/log.c
index 7a3bd5cd69..abc523b497 100644
--- a/cmd/log.c
+++ b/cmd/log.c
@@ -1,313 +1,61 @@
 /*
- * (C) Copyright 2002-2007
- * Detlev Zundel, DENX Software Engineering, dzu@denx.de.
+ * Copyright (c) 2017 Google, Inc
+ * Written by Simon Glass <sjg@chromium.org>
  *
- * Code used from linux/kernel/printk.c
- * Copyright (C) 1991, 1992  Linus Torvalds
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Comments:
- *
- * After relocating the code, the environment variable "loglevel" is
- * copied to console_loglevel.  The functionality is similar to the
- * handling in the Linux kernel, i.e. messages logged with a priority
- * less than console_loglevel are also output to stdout.
- *
- * If you want messages with the default level (e.g. POST messages) to
- * appear on stdout also, make sure the environment variable
- * "loglevel" is set at boot time to a number higher than
- * default_message_loglevel below.
- */
-
-/*
- * Logbuffer handling routines
+ * SPDX-License-Identifier:     GPL-2.0+
  */
 
 #include <common.h>
 #include <command.h>
-#include <stdio_dev.h>
-#include <post.h>
-#include <logbuff.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-/* Local prototypes */
-static void logbuff_putc(struct stdio_dev *dev, const char c);
-static void logbuff_puts(struct stdio_dev *dev, const char *s);
-static int logbuff_printk(const char *line);
-
-static char buf[1024];
-
-/* This combination will not print messages with the default loglevel */
-static unsigned console_loglevel = 3;
-static unsigned default_message_loglevel = 4;
-static unsigned log_version = 1;
-#ifdef CONFIG_ALT_LB_ADDR
-static volatile logbuff_t *log;
-#else
-static logbuff_t *log;
-#endif
-static char *lbuf;
-
-unsigned long __logbuffer_base(void)
-{
-	return CONFIG_SYS_SDRAM_BASE + get_effective_memsize() - LOGBUFF_LEN;
-}
-unsigned long logbuffer_base(void)
-__attribute__((weak, alias("__logbuffer_base")));
+#include <dm.h>
+#include <log.h>
 
-void logbuff_init_ptrs(void)
+static int do_log_level(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
 {
-	unsigned long tag, post_word;
-	char *s;
-
-#ifdef CONFIG_ALT_LB_ADDR
-	log = (logbuff_t *)CONFIG_ALT_LH_ADDR;
-	lbuf = (char *)CONFIG_ALT_LB_ADDR;
-#else
-	log = (logbuff_t *)(logbuffer_base()) - 1;
-	lbuf = (char *)log->buf;
-#endif
-
-	/* Set up log version */
-	s = env_get("logversion");
-	if (s)
-		log_version = (int)simple_strtoul(s, NULL, 10);
-
-	if (log_version == 2)
-		tag = log->v2.tag;
+	if (argc > 1)
+		gd->default_log_level = simple_strtol(argv[1], NULL, 10);
 	else
-		tag = log->v1.tag;
-	post_word = post_word_load();
-#ifdef CONFIG_POST
-	/* The post routines have setup the word so we can simply test it */
-	if (tag != LOGBUFF_MAGIC || (post_word & POST_COLDBOOT))
-		logbuff_reset();
-#else
-	/* No post routines, so we do our own checking                    */
-	if (tag != LOGBUFF_MAGIC || post_word != LOGBUFF_MAGIC) {
-		logbuff_reset ();
-		post_word_store (LOGBUFF_MAGIC);
-	}
-#endif
-	if (log_version == 2 && (long)log->v2.start > (long)log->v2.con)
-		log->v2.start = log->v2.con;
-
-	/* Initialize default loglevel if present */
-	s = env_get("loglevel");
-	if (s)
-		console_loglevel = (int)simple_strtoul(s, NULL, 10);
+		printf("Default log level: %d\n", gd->default_log_level);
 
-	gd->flags |= GD_FLG_LOGINIT;
+	return 0;
 }
 
-void logbuff_reset(void)
-{
-#ifndef CONFIG_ALT_LB_ADDR
-	memset(log, 0, sizeof(logbuff_t));
-#endif
-	if (log_version == 2) {
-		log->v2.tag = LOGBUFF_MAGIC;
-#ifdef CONFIG_ALT_LB_ADDR
-		log->v2.start = 0;
-		log->v2.con = 0;
-		log->v2.end = 0;
-		log->v2.chars = 0;
+static cmd_tbl_t log_sub[] = {
+	U_BOOT_CMD_MKENT(level, CONFIG_SYS_MAXARGS, 1, do_log_level, "", ""),
+#ifdef CONFIG_LOG_TEST
+	U_BOOT_CMD_MKENT(test, 2, 1, do_log_test, "", ""),
 #endif
-	} else {
-		log->v1.tag = LOGBUFF_MAGIC;
-#ifdef CONFIG_ALT_LB_ADDR
-		log->v1.dummy = 0;
-		log->v1.start = 0;
-		log->v1.size = 0;
-		log->v1.chars = 0;
-#endif
-	}
-}
+};
 
-int drv_logbuff_init(void)
+static int do_log(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-	struct stdio_dev logdev;
-	int rc;
-
-	/* Device initialization */
-	memset (&logdev, 0, sizeof (logdev));
-
-	strcpy (logdev.name, "logbuff");
-	logdev.ext   = 0;			/* No extensions */
-	logdev.flags = DEV_FLAGS_OUTPUT;	/* Output only */
-	logdev.putc  = logbuff_putc;		/* 'putc' function */
-	logdev.puts  = logbuff_puts;		/* 'puts' function */
-
-	rc = stdio_register(&logdev);
+	cmd_tbl_t *cp;
 
-	return (rc == 0) ? 1 : rc;
-}
+	if (argc < 2)
+		return CMD_RET_USAGE;
 
-static void logbuff_putc(struct stdio_dev *dev, const char c)
-{
-	char buf[2];
-	buf[0] = c;
-	buf[1] = '\0';
-	logbuff_printk(buf);
-}
+	/* drop initial "log" arg */
+	argc--;
+	argv++;
 
-static void logbuff_puts(struct stdio_dev *dev, const char *s)
-{
-	logbuff_printk (s);
-}
+	cp = find_cmd_tbl(argv[0], log_sub, ARRAY_SIZE(log_sub));
+	if (cp)
+		return cp->cmd(cmdtp, flag, argc, argv);
 
-void logbuff_log(char *msg)
-{
-	if ((gd->flags & GD_FLG_LOGINIT)) {
-		logbuff_printk(msg);
-	} else {
-		/*
-		 * Can happen only for pre-relocated errors as logging
-		 * at that stage should be disabled
-		 */
-		puts (msg);
-	}
+	return CMD_RET_USAGE;
 }
 
-/*
- * Subroutine:  do_log
- *
- * Description: Handler for 'log' command..
- *
- * Inputs:	argv[1] contains the subcommand
- *
- * Return:      None
- *
- */
-int do_log(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	struct stdio_dev *sdev = NULL;
-	char *s;
-	unsigned long i, start, size;
-
-	if (strcmp(argv[1], "append") == 0) {
-		/* Log concatenation of all arguments separated by spaces */
-		for (i = 2; i < argc; i++) {
-			logbuff_printk(argv[i]);
-			logbuff_putc(sdev, (i < argc - 1) ? ' ' : '\n');
-		}
-		return 0;
-	}
-
-	switch (argc) {
-
-	case 2:
-		if (strcmp(argv[1], "show") == 0) {
-			if (log_version == 2) {
-				start = log->v2.start;
-				size = log->v2.end - log->v2.start;
-			} else {
-				start = log->v1.start;
-				size = log->v1.size;
-			}
-			if (size > LOGBUFF_LEN)
-				size = LOGBUFF_LEN;
-			for (i = 0; i < size; i++) {
-				s = lbuf + ((start + i) & LOGBUFF_MASK);
-				putc(*s);
-			}
-			return 0;
-		} else if (strcmp(argv[1], "reset") == 0) {
-			logbuff_reset();
-			return 0;
-		} else if (strcmp(argv[1], "info") == 0) {
-			printf("Logbuffer   at  %08lx\n", (unsigned long)lbuf);
-			if (log_version == 2) {
-				printf("log_start    =  %08lx\n",
-					log->v2.start);
-				printf("log_end      =  %08lx\n", log->v2.end);
-				printf("log_con      =  %08lx\n", log->v2.con);
-				printf("logged_chars =  %08lx\n",
-					log->v2.chars);
-			}
-			else {
-				printf("log_start    =  %08lx\n",
-					log->v1.start);
-				printf("log_size     =  %08lx\n",
-					log->v1.size);
-				printf("logged_chars =  %08lx\n",
-					log->v1.chars);
-			}
-			return 0;
-		}
-		return CMD_RET_USAGE;
-
-	default:
-		return CMD_RET_USAGE;
-	}
-}
+#ifdef CONFIG_SYS_LONGHELP
+static char log_help_text[] =
+	"level - get/set log level\n"
+#ifdef CONFIG_LOG_TEST
+	"log test - run log tests\n"
+#endif
+	;
+#endif
 
 U_BOOT_CMD(
-	log,     255,	1,	do_log,
-	"manipulate logbuffer",
-	"info   - show pointer details\n"
-	"log reset  - clear contents\n"
-	"log show   - show contents\n"
-	"log append <msg> - append <msg> to the logbuffer"
+	log, CONFIG_SYS_MAXARGS, 1, do_log,
+	"log system", log_help_text
 );
-
-static int logbuff_printk(const char *line)
-{
-	int i;
-	char *msg, *p, *buf_end;
-	int line_feed;
-	static signed char msg_level = -1;
-
-	strcpy(buf + 3, line);
-	i = strlen(line);
-	buf_end = buf + 3 + i;
-	for (p = buf + 3; p < buf_end; p++) {
-		msg = p;
-		if (msg_level < 0) {
-			if (
-				p[0] != '<' ||
-				p[1] < '0' ||
-				p[1] > '7' ||
-				p[2] != '>'
-			) {
-				p -= 3;
-				p[0] = '<';
-				p[1] = default_message_loglevel + '0';
-				p[2] = '>';
-			} else {
-				msg += 3;
-			}
-			msg_level = p[1] - '0';
-		}
-		line_feed = 0;
-		for (; p < buf_end; p++) {
-			if (log_version == 2) {
-				lbuf[log->v2.end & LOGBUFF_MASK] = *p;
-				log->v2.end++;
-				if (log->v2.end - log->v2.start > LOGBUFF_LEN)
-					log->v2.start++;
-				log->v2.chars++;
-			} else {
-				lbuf[(log->v1.start + log->v1.size) &
-					 LOGBUFF_MASK] = *p;
-				if (log->v1.size < LOGBUFF_LEN)
-					log->v1.size++;
-				else
-					log->v1.start++;
-				log->v1.chars++;
-			}
-			if (*p == '\n') {
-				line_feed = 1;
-				break;
-			}
-		}
-		if (msg_level < console_loglevel) {
-			printf("%s", msg);
-		}
-		if (line_feed)
-			msg_level = -1;
-	}
-	return i;
-}
diff --git a/cmd/mdio.c b/cmd/mdio.c
index 21dc103736..5c2d91a830 100644
--- a/cmd/mdio.c
+++ b/cmd/mdio.c
@@ -195,6 +195,11 @@ static int do_mdio(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (argc < 2)
 		return CMD_RET_USAGE;
 
+#ifdef CONFIG_DM_MDIO
+	/* probe DM MII device before any operation so they are all accesible */
+	dm_mdio_probe_devices();
+#endif
+
 	/*
 	 * We use the last specified parameters, unless new ones are
 	 * entered.
diff --git a/cmd/mem.c b/cmd/mem.c
index 27075e54a9..6775ab7733 100644
--- a/cmd/mem.c
+++ b/cmd/mem.c
@@ -17,9 +17,6 @@
 #include <cli.h>
 #include <command.h>
 #include <console.h>
-#ifdef CONFIG_HAS_DATAFLASH
-#include <dataflash.h>
-#endif
 #include <hash.h>
 #include <inttypes.h>
 #include <mapmem.h>
@@ -52,10 +49,8 @@ static	ulong	base_address = 0;
 #define DISP_LINE_LEN	16
 static int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-	ulong	addr, length;
-#if defined(CONFIG_HAS_DATAFLASH)
-	ulong	nbytes, linebytes;
-#endif
+	ulong	addr, length, bytes;
+	const void *buf;
 	int	size;
 	int rc = 0;
 
@@ -88,40 +83,13 @@ static int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			length = simple_strtoul(argv[2], NULL, 16);
 	}
 
-#if defined(CONFIG_HAS_DATAFLASH)
-	/* Print the lines.
-	 *
-	 * We buffer all read data, so we can make sure data is read only
-	 * once, and all accesses are with the specified bus width.
-	 */
-	nbytes = length * size;
-	do {
-		char	linebuf[DISP_LINE_LEN];
-		void* p;
-		linebytes = (nbytes>DISP_LINE_LEN)?DISP_LINE_LEN:nbytes;
-
-		rc = read_dataflash(addr, (linebytes/size)*size, linebuf);
-		p = (rc == DATAFLASH_OK) ? linebuf : (void*)addr;
-		print_buffer(addr, p, size, linebytes/size, DISP_LINE_LEN/size);
-
-		nbytes -= linebytes;
-		addr += linebytes;
-		if (ctrlc()) {
-			rc = 1;
-			break;
-		}
-	} while (nbytes > 0);
-#else
-	{
-		ulong bytes = size * length;
-		const void *buf = map_sysmem(addr, bytes);
+	bytes = size * length;
+	buf = map_sysmem(addr, bytes);
 
-		/* Print the lines. */
-		print_buffer(addr, buf, size, length, DISP_LINE_LEN / size);
-		addr += bytes;
-		unmap_sysmem(buf);
-	}
-#endif
+	/* Print the lines. */
+	print_buffer(addr, buf, size, length, DISP_LINE_LEN / size);
+	addr += bytes;
+	unmap_sysmem(buf);
 
 	dp_last_addr = addr;
 	dp_last_length = length;
@@ -286,13 +254,6 @@ static int do_mem_cmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	count = simple_strtoul(argv[3], NULL, 16);
 
-#ifdef CONFIG_HAS_DATAFLASH
-	if (addr_dataflash(addr1) | addr_dataflash(addr2)){
-		puts ("Comparison with DataFlash space not supported.\n\r");
-		return 0;
-	}
-#endif
-
 	bytes = size * count;
 	base = buf1 = map_sysmem(addr1, bytes);
 	buf2 = map_sysmem(addr2, bytes);
@@ -370,11 +331,7 @@ static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 #ifdef CONFIG_MTD_NOR_FLASH
 	/* check if we are copying to Flash */
-	if ( (addr2info(dest) != NULL)
-#ifdef CONFIG_HAS_DATAFLASH
-	   && (!addr_dataflash(dest))
-#endif
-	   ) {
+	if (addr2info(dest) != NULL) {
 		int rc;
 
 		puts ("Copy to Flash... ");
@@ -389,44 +346,6 @@ static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	}
 #endif
 
-#ifdef CONFIG_HAS_DATAFLASH
-	/* Check if we are copying from RAM or Flash to DataFlash */
-	if (addr_dataflash(dest) && !addr_dataflash(addr)){
-		int rc;
-
-		puts ("Copy to DataFlash... ");
-
-		rc = write_dataflash (dest, addr, count*size);
-
-		if (rc != 1) {
-			dataflash_perror (rc);
-			return (1);
-		}
-		puts ("done\n");
-		return 0;
-	}
-
-	/* Check if we are copying from DataFlash to RAM */
-	if (addr_dataflash(addr) && !addr_dataflash(dest)
-#ifdef CONFIG_MTD_NOR_FLASH
-				 && (addr2info(dest) == NULL)
-#endif
-	   ){
-		int rc;
-		rc = read_dataflash(addr, count * size, (char *) dest);
-		if (rc != 1) {
-			dataflash_perror (rc);
-			return (1);
-		}
-		return 0;
-	}
-
-	if (addr_dataflash(addr) && addr_dataflash(dest)){
-		puts ("Unsupported combination of source/destination.\n\r");
-		return 1;
-	}
-#endif
-
 	memcpy((void *)dest, (void *)addr, count * size);
 
 	return 0;
@@ -1072,13 +991,6 @@ mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
 		addr += base_address;
 	}
 
-#ifdef CONFIG_HAS_DATAFLASH
-	if (addr_dataflash(addr)){
-		puts ("Can't modify DataFlash in place. Use cp instead.\n\r");
-		return 0;
-	}
-#endif
-
 	/* Print the address, followed by value.  Then accept input for
 	 * the next value.  A non-converted value exits.
 	 */
diff --git a/cmd/mmc.c b/cmd/mmc.c
index 00697fc1f2..0813330c07 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -4,17 +4,23 @@
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
-
 #include <common.h>
 #include <command.h>
 #include <console.h>
 #include <mmc.h>
+#include <optee_include/OpteeClientInterface.h>
+#include <optee_include/OpteeClientApiLib.h>
+#include <optee_test.h>
 
 static int curr_device = -1;
 
 static void print_mmcinfo(struct mmc *mmc)
 {
 	int i;
+	const char *timing[] = {
+		"Legacy", "High Speed", "High Speed", "SDR12",
+		"SDR25", "SDR50", "SDR104", "DDR50",
+		"DDR52", "HS200", "HS400", "HS400 Enhanced Strobe"};
 
 	printf("Device: %s\n", mmc->cfg->name);
 	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
@@ -23,7 +29,8 @@ static void print_mmcinfo(struct mmc *mmc)
 			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
 			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
 
-	printf("Tran Speed: %d\n", mmc->tran_speed);
+	printf("Timing Interface: %s\n", timing[mmc->timing]);
+	printf("Tran Speed: %d\n", mmc->clock);
 	printf("Rd Block Len: %d\n", mmc->read_bl_len);
 
 	printf("%s version %d.%d", IS_SD(mmc) ? "SD" : "MMC",
@@ -38,7 +45,7 @@ static void print_mmcinfo(struct mmc *mmc)
 	print_size(mmc->capacity, "\n");
 
 	printf("Bus Width: %d-bit%s\n", mmc->bus_width,
-			mmc->ddr_mode ? " DDR" : "");
+			mmc_card_ddr(mmc) ? " DDR" : "");
 
 	puts("Erase Group Size: ");
 	print_size(((u64)mmc->erase_grp_size) << 9, "\n");
@@ -118,7 +125,153 @@ static int do_mmcinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return CMD_RET_SUCCESS;
 }
 
+#ifdef CONFIG_OPTEE_CLIENT
+static int do_mmc_test_secure_storage(cmd_tbl_t *cmdtp,
+				      int flag, int argc, char * const argv[])
+{
+	struct mmc *mmc;
+
+	if (curr_device < 0) {
+		if (get_mmc_num() > 0) {
+			puts("MMC device available\n");
+			curr_device = 0;
+		} else {
+			puts("No MMC device available\n");
+			return 1;
+		}
+	}
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	int i, count = 100;
+
+	for (i = 1; i <= count; i++) {
+		if (test_secure_storage_default() == 0) {
+			printf("test_secure_storage_default success! %d/%d\n", i, count);
+		} else {
+			printf("test_secure_storage_default fail! %d/%d\n", i, count);
+			break;
+		}
+		if (test_secure_storage_security_partition() == 0) {
+			printf("test_secure_storage_security_partition success! %d/%d\n", i, count);
+		} else {
+			printf("test_secure_storage_security_partition fail! %d/%d\n", i, count);
+			break;
+		}
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_mmc_testefuse(cmd_tbl_t *cmdtp,
+		int flag, int argc, char * const argv[])
+{
+	uint32_t outbuf32[8];
+
+	trusty_read_attribute_hash(outbuf32, 8);
+
+	printf(" 0x%x  0x%x  0x%x  0x%x \n",
+		outbuf32[0], outbuf32[1], outbuf32[2], outbuf32[3]);
+	printf(" 0x%x  0x%x  0x%x  0x%x \n",
+		outbuf32[4], outbuf32[5], outbuf32[6], outbuf32[7]);
+
+	return CMD_RET_SUCCESS;
+}
+
+#endif
+
 #ifdef CONFIG_SUPPORT_EMMC_RPMB
+char temp_original_part;
+int init_rpmb(void)
+{
+	struct mmc *mmc;
+
+	if (curr_device < 0) {
+		if (get_mmc_num() > 0) {
+			curr_device = 0;
+		} else {
+			printf("No MMC device available\n");
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	if (!(mmc->version & MMC_VERSION_MMC)) {
+		printf("It is not a EMMC device\n");
+		return CMD_RET_FAILURE;
+	}
+	if (mmc->version < MMC_VERSION_4_41) {
+		printf("RPMB not supported before version 4.41\n");
+		return CMD_RET_FAILURE;
+	}
+
+		/* Switch to the RPMB partition */
+#ifndef CONFIG_BLK
+	temp_original_part = mmc->block_dev.hwpart;
+	debug("mmc->block_dev.hwpart\n");
+#else
+	temp_original_part = mmc_get_blk_desc(mmc)->hwpart;
+	debug("mmc_get_blk_desc(mmc)->hwpart\n");
+#endif
+	debug("init_rpmb temp_original_part = 0x%X\n", temp_original_part);
+	if (blk_select_hwpart_devnum
+		(IF_TYPE_MMC, curr_device, MMC_PART_RPMB) != 0)
+		return CMD_RET_FAILURE;
+
+	return CMD_RET_SUCCESS;
+}
+
+int finish_rpmb(void)
+{
+	/* Return to original partition */
+	debug("finish_rpmb temp_original_part = 0x%X\n", temp_original_part);
+	if (blk_select_hwpart_devnum
+		(IF_TYPE_MMC, curr_device, temp_original_part) != 0)
+		return CMD_RET_FAILURE;
+
+	return CMD_RET_SUCCESS;
+}
+
+int do_readcounter(struct s_rpmb *requestpackets)
+{
+	struct mmc *mmc = find_mmc_device(curr_device);
+
+	return read_counter(mmc, requestpackets);
+}
+
+int do_programkey(struct s_rpmb *requestpackets)
+{
+	struct mmc *mmc = find_mmc_device(curr_device);
+
+	return program_key(mmc, requestpackets);
+}
+
+int do_authenticatedread(struct s_rpmb *requestpackets, uint16_t block_count)
+{
+	struct mmc *mmc = find_mmc_device(curr_device);
+
+	return authenticated_read(mmc, requestpackets, block_count);
+}
+
+int do_authenticatedwrite(struct s_rpmb *requestpackets)
+{
+	struct mmc *mmc = find_mmc_device(curr_device);
+
+	return authenticated_write(mmc, requestpackets);
+}
+
+struct mmc *do_returnmmc(void)
+{
+	struct mmc *mmc = find_mmc_device(curr_device);
+
+	return mmc;
+}
+
 static int confirm_key_prog(void)
 {
 	puts("Warning: Programming authentication key can be done only once !\n"
@@ -293,8 +446,6 @@ static int do_mmc_read(cmd_tbl_t *cmdtp, int flag,
 	       curr_device, blk, cnt);
 
 	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
-	/* flush cache after read */
-	flush_cache((ulong)addr, cnt * 512); /* FIXME */
 	printf("%d blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
 
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
@@ -409,7 +560,7 @@ static int do_mmc_dev(cmd_tbl_t *cmdtp, int flag,
 		return CMD_RET_USAGE;
 	}
 
-	mmc = init_mmc_device(dev, true);
+	mmc = init_mmc_device(dev, false);
 	if (!mmc)
 		return CMD_RET_FAILURE;
 
@@ -800,6 +951,10 @@ static cmd_tbl_t cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(partconf, 5, 0, do_mmc_partconf, "", ""),
 	U_BOOT_CMD_MKENT(rst-function, 3, 0, do_mmc_rst_func, "", ""),
 #endif
+#ifdef CONFIG_OPTEE_CLIENT
+	U_BOOT_CMD_MKENT(testsecurestorage, 1, 0, do_mmc_test_secure_storage, "", ""),
+	U_BOOT_CMD_MKENT(testefuse, 1, 0, do_mmc_testefuse, "", ""),
+#endif
 #ifdef CONFIG_SUPPORT_EMMC_RPMB
 	U_BOOT_CMD_MKENT(rpmb, CONFIG_SYS_MAXARGS, 1, do_mmcrpmb, "", ""),
 #endif
@@ -864,6 +1019,10 @@ U_BOOT_CMD(
 	" - Change the RST_n_FUNCTION field of the specified device\n"
 	"   WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.\n"
 #endif
+#ifdef CONFIG_OPTEE_CLIENT
+	"mmc testsecurestorage - test CA call static TA to store data in security\n"
+	"mmc testefuse - test CA call static TA,and TA read or write efuse\n"
+#endif
 #ifdef CONFIG_SUPPORT_EMMC_RPMB
 	"mmc rpmb read addr blk# cnt [address of auth-key] - block size is 256 bytes\n"
 	"mmc rpmb write addr blk# cnt <address of auth-key> - block size is 256 bytes\n"
@@ -883,3 +1042,4 @@ U_BOOT_CMD(
 	"display MMC info",
 	"- display info of the current MMC device"
 );
+
diff --git a/cmd/mtdparts.c b/cmd/mtdparts.c
index 3275eb919b..ad745e6059 100644
--- a/cmd/mtdparts.c
+++ b/cmd/mtdparts.c
@@ -38,7 +38,7 @@
  * mtdids=<idmap>[,<idmap>,...]
  *
  * <idmap>    := <dev-id>=<mtd-id>
- * <dev-id>   := 'nand'|'nor'|'onenand'<dev-num>
+ * <dev-id>   := 'nand'|'nor'|'onenand'|'spi-nand'<dev-num>
  * <dev-num>  := mtd device number, 0...
  * <mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
  *
@@ -81,7 +81,7 @@
 #include <linux/mtd/mtd.h>
 
 #if defined(CONFIG_CMD_NAND)
-#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
 #include <nand.h>
 #endif
 
@@ -178,13 +178,16 @@ static u64 memsize_parse (const char *const ptr, const char **retptr)
 		case 'G':
 		case 'g':
 			ret <<= 10;
+			/* Fallthrough */
 		case 'M':
 		case 'm':
 			ret <<= 10;
+			/* Fallthrough */
 		case 'K':
 		case 'k':
 			ret <<= 10;
 			(*retptr)++;
+			/* Fallthrough */
 		default:
 			break;
 	}
@@ -337,7 +340,7 @@ static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
 
 	if (!mtd->numeraseregions) {
 		/*
-		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
+		 * Only one eraseregion (NAND, SPI-NAND, OneNAND or uniform NOR),
 		 * checking for alignment is easy here
 		 */
 		offset = part->offset;
@@ -691,7 +694,7 @@ static int part_parse(const char *const partdef, const char **ret, struct part_i
 		part->auto_name = 0;
 	} else {
 		/* auto generated name in form of size@offset */
-		sprintf(part->name, "0x%08llx@0x%08llx", size, offset);
+		snprintf(part->name, name_len, "0x%08llx@0x%08llx", size, offset);
 		part->auto_name = 1;
 	}
 
@@ -873,15 +876,12 @@ static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_
 		return 1;
 	}
 
-#ifdef DEBUG
 	pend = strchr(p, ';');
-#endif
 	debug("dev type = %d (%s), dev num = %d, mtd-id = %s\n",
 			id->type, MTD_DEV_TYPE(id->type),
 			id->num, id->mtd_id);
 	debug("parsing partitions %.*s\n", (int)(pend ? pend - p : strlen(p)), p);
 
-
 	/* parse partitions */
 	num_parts = 0;
 
@@ -1031,7 +1031,7 @@ static struct mtdids* id_find_by_mtd_id(const char *mtd_id, unsigned int mtd_id_
 }
 
 /**
- * Parse device id string <dev-id> := 'nand'|'nor'|'onenand'<dev-num>,
+ * Parse device id string <dev-id> := 'nand'|'nor'|'onenand'|'spi-nand'<dev-num>,
  * return device type and number.
  *
  * @param id string describing device id
@@ -1055,6 +1055,9 @@ int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type,
 	} else if (strncmp(p, "onenand", 7) == 0) {
 		*dev_type = MTD_DEV_TYPE_ONENAND;
 		p += 7;
+	} else if (strncmp(p, "spi-nand", 8) == 0) {
+		*dev_type = MTD_DEV_TYPE_SPINAND;
+		p += 8;
 	} else {
 		printf("incorrect device type in %s\n", id);
 		return 1;
@@ -1637,7 +1640,7 @@ static int parse_mtdids(const char *const ids)
 	while(p && (*p != '\0')) {
 
 		ret = 1;
-		/* parse 'nor'|'nand'|'onenand'<dev-num> */
+		/* parse 'nor'|'nand'|'onenand'|'spi-nand'<dev-num> */
 		if (mtd_id_parse(p, &p, &type, &num) != 0)
 			break;
 
@@ -2113,7 +2116,7 @@ static char mtdparts_help_text[] =
 	"'mtdids' - linux kernel mtd device id <-> u-boot device id mapping\n\n"
 	"mtdids=<idmap>[,<idmap>,...]\n\n"
 	"<idmap>    := <dev-id>=<mtd-id>\n"
-	"<dev-id>   := 'nand'|'nor'|'onenand'<dev-num>\n"
+	"<dev-id>   := 'nand'|'nor'|'onenand'|'spi-nand'<dev-num>\n"
 	"<dev-num>  := mtd device number, 0...\n"
 	"<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)\n\n"
 	"'mtdparts' - partition list\n\n"
diff --git a/cmd/mvebu/bubt.c b/cmd/mvebu/bubt.c
index a1997ac0d3..23fb8cd807 100644
--- a/cmd/mvebu/bubt.c
+++ b/cmd/mvebu/bubt.c
@@ -110,7 +110,7 @@ static ulong get_load_addr(void)
 /********************************************************************
  *     eMMC services
  ********************************************************************/
-#ifdef CONFIG_DM_MMC
+#if CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(MMC_WRITE)
 static int mmc_burn_image(size_t image_size)
 {
 	struct mmc	*mmc;
diff --git a/cmd/net.c b/cmd/net.c
index d7c776aacf..e2e476adad 100644
--- a/cmd/net.c
+++ b/cmd/net.c
@@ -11,6 +11,7 @@
 #include <common.h>
 #include <command.h>
 #include <net.h>
+#include <boot_rkimg.h>
 
 static int netboot_common(enum proto_t, cmd_tbl_t *, int, char * const []);
 
@@ -36,11 +37,117 @@ int do_tftpb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 }
 
 U_BOOT_CMD(
-	tftpboot,	3,	1,	do_tftpb,
-	"boot image via network using TFTP protocol",
+	tftp,		3,	1,	do_tftpb,
+	"download image via network using TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]"
 );
 
+#ifdef CONFIG_CMD_TFTP_BOOTM
+int do_tftpbootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *tftp_argv[] = { "tftp", NULL, NULL };
+	char *bootm_argv[] = { "bootm", NULL };
+	char *fileaddr;
+	ulong filesize;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	/* tftp download */
+	tftp_argv[1] = argv[1];
+	tftp_argv[2] = argv[2];
+	if (do_tftpb(cmdtp, 0, 3, tftp_argv))
+		return -ENOENT;
+
+	fileaddr = env_get("fileaddr");
+	filesize = env_get_ulong("filesize", 16, 0);
+	if (!fileaddr || !filesize)
+		return -ENOENT;
+
+	/* bootm */
+	bootm_argv[1] = fileaddr;
+	printf("## TFTP bootm %s at %s size 0x%lx\n",
+	       argv[2], fileaddr, filesize);
+
+	return do_bootm(NULL, 0, ARRAY_SIZE(bootm_argv), bootm_argv);
+}
+
+U_BOOT_CMD(
+	tftpbootm,	3,	1,	do_tftpbootm,
+	"tftpbootm aosp/uImage/FIT image via network using TFTP protocol",
+	"[loadAddress] [[hostIPaddr:]bootfilename]"
+);
+#endif
+
+#ifdef CONFIG_CMD_TFTP_FLASH
+int do_tftpflash(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *tftp_argv[] = { "tftp", NULL, NULL };
+	struct blk_desc *dev_desc;
+	disk_partition_t part;
+	ulong fileaddr;
+	ulong filesize;
+	char *part_name;
+	int ret, blknum;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	/* search partition */
+	dev_desc = rockchip_get_bootdev();
+	if (!dev_desc) {
+		printf("No boot device\n");
+		return -ENODEV;
+	}
+
+	part_name = argv[3];
+	ret = part_get_info_by_name(dev_desc, part_name, &part);
+	if (ret < 0) {
+		printf("No partition '%s'\n", part_name);
+		return -EINVAL;
+	}
+
+	/* tftp download */
+	tftp_argv[1] = argv[1];
+	tftp_argv[2] = argv[2];
+	if (do_tftpb(cmdtp, 0, ARRAY_SIZE(tftp_argv), tftp_argv))
+		return -ENOENT;
+
+	fileaddr = env_get_ulong("fileaddr", 16, 0);
+	filesize = env_get_ulong("filesize", 16, 0);
+	if (!fileaddr || !filesize)
+		return -ENOENT;
+
+	/* flash */
+	blknum = DIV_ROUND_UP(filesize, dev_desc->blksz);
+	if (blknum > part.size) {
+		printf("File size 0x%lx is too large to flash\n", filesize);
+		return -EINVAL;
+	}
+
+	printf("## TFTP flash %s to partititon '%s' size 0x%lx ... ",
+	       argv[2], part_name, filesize);
+
+	if (dev_desc->if_type == IF_TYPE_MTD)
+		dev_desc->op_flag |= BLK_MTD_CONT_WRITE;
+	ret = blk_dwrite(dev_desc, part.start, blknum, (void *)fileaddr);
+	if (dev_desc->if_type == IF_TYPE_MTD)
+		dev_desc->op_flag &= ~(BLK_MTD_CONT_WRITE);
+	if (ret != blknum)
+		printf("Failed(%d)\n", ret);
+	else
+		printf("OK\n");
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	tftpflash,	4,	0,	do_tftpflash,
+	"flash image via network using TFTP protocol",
+	"[loadAddress] [[hostIPaddr:]bootfilename] [partition]"
+);
+#endif
+
 #ifdef CONFIG_CMD_TFTPPUT
 static int do_tftpput(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -70,6 +177,12 @@ U_BOOT_CMD(
 );
 #endif
 
+#ifdef CONFIG_UDP_FUNCTION_FASTBOOT
+int do_fastboot_udp(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	return netboot_common(FASTBOOT, cmdtp, argc, argv);
+}
+#endif
 
 #ifdef CONFIG_CMD_RARP
 int do_rarpb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
diff --git a/cmd/nvedit.c b/cmd/nvedit.c
index 4033d90c8e..591e5d7990 100644
--- a/cmd/nvedit.c
+++ b/cmd/nvedit.c
@@ -42,7 +42,6 @@ DECLARE_GLOBAL_DATA_PTR;
 
 #if	!defined(CONFIG_ENV_IS_IN_EEPROM)	&& \
 	!defined(CONFIG_ENV_IS_IN_FLASH)	&& \
-	!defined(CONFIG_ENV_IS_IN_DATAFLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_MMC)		&& \
 	!defined(CONFIG_ENV_IS_IN_FAT)		&& \
 	!defined(CONFIG_ENV_IS_IN_EXT4)		&& \
@@ -53,9 +52,10 @@ DECLARE_GLOBAL_DATA_PTR;
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_REMOTE)	&& \
 	!defined(CONFIG_ENV_IS_IN_UBI)		&& \
+	!defined(CONFIG_ENV_IS_IN_BLK_DEV)	&& \
 	!defined(CONFIG_ENV_IS_NOWHERE)
-# error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|DATAFLASH|MMC|FAT|EXT4|\
-NAND|NVRAM|ONENAND|SATA|SPI_FLASH|REMOTE|UBI} or CONFIG_ENV_IS_NOWHERE
+# error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|MMC|FAT|EXT4|\
+NAND|NVRAM|ONENAND|SATA|SPI_FLASH|REMOTE|UBI|BLK_DEV} or CONFIG_ENV_IS_NOWHERE
 #endif
 
 /*
@@ -297,6 +297,393 @@ int env_set(const char *varname, const char *varvalue)
 		return _do_env_set(0, 3, (char * const *)argv, H_PROGRAMMATIC);
 }
 
+static int env_append(const char *varname, const char *varvalue)
+{
+	int len = 0;
+	char *oldvalue, *newvalue;
+
+	debug("%s: varvalue = %s\n", __func__, varvalue);
+
+	/* before import into hashtable */
+	if (!(gd->flags & GD_FLG_ENV_READY) || !varname)
+		return 1;
+
+	if (env_exist(varname, varvalue))
+		return 0;
+
+	debug("%s: reall append: %s\n", __func__, varvalue);
+
+	if (varvalue)
+		len += strlen(varvalue);
+
+	oldvalue = env_get(varname);
+	if (oldvalue)
+		len += strlen(oldvalue);
+
+	newvalue = calloc(1, len + 2);
+	if (!newvalue) {
+		printf("Error: calloc in %s failed!\n", __func__);
+		return 1;
+	}
+
+	*newvalue = '\0';
+
+	if (oldvalue) {
+		strcpy(newvalue, oldvalue);
+		strcat(newvalue, " ");
+	}
+
+	if (varvalue)
+		strcat(newvalue, varvalue);
+
+	debug("%s: newvalue: %s\n", __func__, newvalue);
+	env_set(varname, newvalue);
+	free(newvalue);
+
+	return 0;
+}
+
+static int env_replace(const char *varname, const char *substr,
+		       const char *replacement)
+{
+	char *oldvalue, *newvalue, *dst, *sub;
+	int substr_len, replace_len, oldvalue_len, len;
+
+	/* before import into hashtable */
+	if (!(gd->flags & GD_FLG_ENV_READY) || !varname)
+		return 1;
+
+	oldvalue = env_get(varname);
+	if (!oldvalue)
+		return 1;
+
+	sub = strstr(oldvalue, substr);
+	if (!sub)
+		return 1;
+
+	oldvalue_len = strlen(oldvalue) + 1;
+	substr_len = strlen(substr);
+	replace_len = strlen(replacement);
+
+	if (replace_len >= substr_len)
+		len = oldvalue_len + replace_len - substr_len;
+	else
+		len = oldvalue_len + substr_len - replace_len;
+
+	newvalue = calloc(1, len);
+	if (!newvalue) {
+		printf("Error: calloc in %s failed!\n", __func__);
+		return 1;
+	}
+
+	*newvalue = '\0';
+
+	/*
+	 * Orignal string is splited like format: [str1.. substr str2..]
+	 */
+
+	/* str1.. */
+	dst = newvalue;
+	dst = strncat(dst, oldvalue, sub - oldvalue);
+
+	/* substr */
+	dst += sub - oldvalue;
+	dst = strncat(dst, replacement, replace_len);
+
+	/* str2.. */
+	dst += replace_len;
+	len = oldvalue_len - substr_len - (sub - oldvalue);
+	dst = strncat(dst, sub + substr_len, len);
+
+	env_set(varname, newvalue);
+	free(newvalue);
+
+	return 0;
+}
+
+#define ARGS_ITEM_NUM	50
+
+int env_update_filter(const char *varname, const char *varvalue,
+		      const char *ignore)
+{
+	/* 'a_' means "varargs_'; 'v_' means 'varvalue_' */
+	char *varargs;
+	char *a_title, *v_title;
+	char *a_string_tok, *a_item_tok = NULL;
+	char *v_string_tok, *v_item_tok = NULL;
+	char *a_item, *a_items[ARGS_ITEM_NUM] = { NULL };
+	char *v_item, *v_items[ARGS_ITEM_NUM] = { NULL };
+	bool match = false;
+	int i = 0, j = 0;
+
+	/* Before import into hashtable */
+	if (!(gd->flags & GD_FLG_ENV_READY) || !varname)
+		return 1;
+
+	/* If varname doesn't exist, create it and set varvalue */
+	varargs = env_get(varname);
+	if (!varargs) {
+		env_set(varname, varvalue);
+		if (ignore && strstr(varvalue, ignore))
+			env_delete(varname, ignore, 0);
+		return 0;
+	}
+
+	/* Malloc a temporary varargs for strtok */
+	a_string_tok = strdup(varargs);
+	if (!a_string_tok) {
+		printf("Error: strdup in failed, line=%d\n", __LINE__);
+		return 1;
+	}
+
+	/* Malloc a temporary varvalue for strtok */
+	v_string_tok = strdup(varvalue);
+	if (!v_string_tok) {
+		free(a_string_tok);
+		printf("Error: strdup in failed, line=%d\n", __LINE__);
+		return 1;
+	}
+
+	/* Splite varargs into items containing "=" by the space */
+	a_item = strtok(a_string_tok, " ");
+	while (a_item && i < ARGS_ITEM_NUM) {
+		debug("%s: [a_item %d]: %s\n", __func__, i, a_item);
+		if (strstr(a_item, "="))
+			a_items[i++] = a_item;
+		a_item = strtok(NULL, " ");
+	}
+
+	/*
+	 * Splite varvalue into items containing "=" by the space.
+	 * parse varvalue title, eg: "bootmode=emmc", title is "bootmode"
+	 */
+	v_item = strtok(v_string_tok, " ");
+	while (v_item && j < ARGS_ITEM_NUM) {
+		debug("%s: <v_item %d>: %s ", __func__, j, v_item);
+
+		/* filter ignore string */
+		if (ignore && strstr(v_item, ignore)) {
+			v_item = strtok(NULL, " ");
+			debug("...ignore\n");
+			continue;
+		}
+
+		if (strstr(v_item, "=")) {
+			debug("\n");
+			v_items[j++] = v_item;
+		} else {
+			debug("... do append\n");
+			env_append(varname, v_item);
+		}
+
+		v_item = strtok(NULL, " ");
+	}
+
+	/* For every v_item, search its title */
+	for (j = 0; j < ARGS_ITEM_NUM && v_items[j]; j++) {
+		v_item = v_items[j];
+		/* Malloc a temporary a_item for strtok */
+		v_item_tok = strdup(v_item);
+		if (!v_item_tok) {
+			printf("Error: strdup in failed, line=%d\n", __LINE__);
+			free(a_string_tok);
+			free(v_string_tok);
+			return 1;
+		}
+		v_title = strtok(v_item_tok, "=");
+		debug("%s: <v_title>: %s\n", __func__, v_title);
+
+		/* For every a_item, search its title */
+		for (i = 0; i < ARGS_ITEM_NUM && a_items[i]; i++) {
+			a_item = a_items[i];
+			/* Malloc a temporary a_item for strtok */
+			a_item_tok = strdup(a_item);
+			if (!a_item_tok) {
+				printf("Error: strdup in failed, line=%d\n", __LINE__);
+				free(a_string_tok);
+				free(v_string_tok);
+				free(v_item_tok);
+				return 1;
+			}
+
+			a_title = strtok(a_item_tok, "=");
+			debug("%s: [a_title]: %s\n", __func__, a_title);
+			if (!strcmp(a_title, v_title)) {
+				/* Find! replace it */
+				env_replace(varname, a_item, v_item);
+				free(a_item_tok);
+				match = true;
+				break;
+			}
+			free(a_item_tok);
+		}
+
+		/* Not find, just append */
+		if (!match) {
+			debug("%s: append '%s' to the '%s' end\n",
+			      __func__, v_item, varname);
+			env_append(varname, v_item);
+		}
+		match = false;
+		free(v_item_tok);
+	}
+
+	free(v_string_tok);
+	free(a_string_tok);
+
+	return 0;
+}
+
+int env_update(const char *varname, const char *varvalue)
+{
+	return env_update_filter(varname, varvalue, NULL);
+}
+
+int env_update_extract_subset(const char *varname,
+			      const char *subset_varname,
+			      const char *subset_key)
+{
+	char *subset_varvalue;
+	char *tmp_varvalue;
+	char *new_varvalue;
+	char *varvalue;
+	char *p, *item;
+	int ret = 0;
+	u32 len;
+
+	varvalue = env_get(varname);
+	if (!varvalue)
+		return 0;
+
+	len = strlen(varvalue) + 1;
+	new_varvalue = calloc(1, len);
+	subset_varvalue = calloc(1, len);
+	tmp_varvalue = strdup(varvalue);
+	if (!new_varvalue || !tmp_varvalue || !subset_varvalue) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	item = strtok(tmp_varvalue, " ");
+	while (item) {
+		p = strstr(item, subset_key) ? subset_varvalue : new_varvalue;
+		strcat(p, item);
+		strcat(p, " ");
+		debug("%s: [item]: %s\n", __func__, item);
+		item = strtok(NULL, " ");
+	}
+
+	env_set(varname, new_varvalue);
+	env_set(subset_varname, subset_varvalue);
+out:
+	if (new_varvalue)
+		free(new_varvalue);
+	if (subset_varvalue)
+		free(subset_varvalue);
+	if (tmp_varvalue)
+		free(tmp_varvalue);
+
+	return ret;
+}
+
+char *env_exist(const char *varname, const char *varvalue)
+{
+	char *buf, *ptr = NULL;
+	char *oldvalue, *p;
+	int len;
+
+	/* before import into hashtable */
+	if (!(gd->flags & GD_FLG_ENV_READY) || !varname)
+		return NULL;
+
+	len = strlen(varvalue) + 8; /* extra 8 byte is enough*/
+	buf = calloc(1, len);
+	if (!buf)
+		return NULL;
+
+	oldvalue = env_get(varname);
+	if (oldvalue) {
+		/* Match middle one ? */
+		snprintf(buf, len, " %s ", varvalue);
+		p = strstr(oldvalue, buf);
+		if (p) {
+			debug("%s: '%s' is already exist in '%s'(middle)\n",
+			      __func__, varvalue, varname);
+			ptr = (p + 1);
+			goto out;
+		} else {
+			debug("%s: not find in middle one\n", __func__);
+		}
+
+		/* Match last one ? */
+		snprintf(buf, len, " %s", varvalue);
+		p = strstr(oldvalue, buf);
+		if (p) {
+			if (*(p + strlen(varvalue) + 1) == '\0') {
+				debug("%s: '%s' is already exist in '%s'(last)\n",
+				      __func__, varvalue, varname);
+				ptr = (p + 1);
+				goto out;
+			}
+		} else {
+			debug("%s: not find in last one\n", __func__);
+		}
+
+		/* Match first one ? */
+		snprintf(buf, len, "%s ", varvalue);
+		p = strstr(oldvalue, buf);
+		if (p) {
+			len = strstr(p, " ") - oldvalue;
+			if (len == strlen(varvalue)) {
+				debug("%s: '%s' is already exist in '%s'(first)\n",
+				      __func__, varvalue, varname);
+				ptr = p;
+				goto out;
+			}
+		} else  {
+			debug("%s: not find in first one\n", __func__);
+		}
+	}
+out:
+	free(buf);
+
+	return ptr;
+}
+
+int env_delete(const char *varname, const char *varvalue, int complete_match)
+{
+	const char *str;
+	char *value, *start;
+
+	/* before import into hashtable */
+	if (!(gd->flags & GD_FLG_ENV_READY) || !varname)
+		return 1;
+
+	value = env_get(varname);
+	if (!value)
+		return 0;
+
+	start = complete_match ?
+		env_exist(varname, varvalue) : strstr(value, varvalue);
+	if (!start)
+		return 0;
+
+	/* varvalue is not the last property */
+	str = strstr(start, " ");
+	if (str) {
+		/* Terminate, so cmdline can be dest for strcat() */
+		*start = '\0';
+		/* +1 to skip white space */
+		strcat((char *)value, (str + 1));
+	/* varvalue is the last property */
+	} else {
+		/* skip white space */
+		*(start - 1) = '\0';
+	}
+
+	return 0;
+}
+
 /**
  * Set an environment variable to an integer value
  *
@@ -321,9 +708,9 @@ int env_set_ulong(const char *varname, ulong value)
  */
 int env_set_hex(const char *varname, ulong value)
 {
-	char str[17];
+	char str[19];
 
-	sprintf(str, "%lx", value);
+	sprintf(str, "0x%lx", value);
 	return env_set(varname, str);
 }
 
@@ -393,15 +780,18 @@ int do_env_ask(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		sprintf(message, "Please enter '%s': ", argv[1]);
 	} else {
 		/* env_ask envname message1 ... messagen [size] */
-		for (i = 2, pos = 0; i < argc; i++) {
+		for (i = 2, pos = 0; i < argc && pos+1 < sizeof(message); i++) {
 			if (pos)
 				message[pos++] = ' ';
 
-			strcpy(message + pos, argv[i]);
+			strncpy(message + pos, argv[i], sizeof(message) - pos);
 			pos += strlen(argv[i]);
 		}
-		message[pos++] = ' ';
-		message[pos] = '\0';
+		if (pos < sizeof(message) - 1) {
+			message[pos++] = ' ';
+			message[pos] = '\0';
+		} else
+			message[CONFIG_SYS_CBSIZE - 1] = '\0';
 	}
 
 	if (size >= CONFIG_SYS_CBSIZE)
@@ -702,7 +1092,7 @@ ulong env_get_ulong(const char *name, int base, ulong default_val)
 }
 
 #ifndef CONFIG_SPL_BUILD
-#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+#if defined(CONFIG_CMD_SAVEENV)
 static int do_env_save(cmd_tbl_t *cmdtp, int flag, int argc,
 		       char * const argv[])
 {
@@ -817,6 +1207,15 @@ static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
 	return ret;
 }
 
+static int do_env_update(cmd_tbl_t *cmdtp, int flag,
+			 int argc, char *const argv[])
+{
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	return env_update(argv[1], argv[2]);
+}
+
 #ifdef CONFIG_CMD_EXPORTENV
 /*
  * env export [-t | -b | -c] [-s size] addr [var ...]
@@ -927,7 +1326,7 @@ NXTARG:		;
 				H_MATCH_KEY | H_MATCH_IDENT,
 				&ptr, size, argc, argv);
 		if (len < 0) {
-			error("Cannot export environment: errno = %d\n", errno);
+			pr_err("Cannot export environment: errno = %d\n", errno);
 			return 1;
 		}
 		sprintf(buf, "%zX", (size_t)len);
@@ -947,7 +1346,7 @@ NXTARG:		;
 			H_MATCH_KEY | H_MATCH_IDENT,
 			&res, ENV_SIZE, argc, argv);
 	if (len < 0) {
-		error("Cannot export environment: errno = %d\n", errno);
+		pr_err("Cannot export environment: errno = %d\n", errno);
 		return 1;
 	}
 
@@ -1082,7 +1481,7 @@ static int do_env_import(cmd_tbl_t *cmdtp, int flag,
 
 	if (himport_r(&env_htab, ptr, size, sep, del ? 0 : H_NOCLEAR,
 			crlf_is_lf, 0, NULL) == 0) {
-		error("Environment import failed: errno = %d\n", errno);
+		pr_err("Environment import failed: errno = %d\n", errno);
 		return 1;
 	}
 	gd->flags |= GD_FLG_ENV_READY;
@@ -1122,6 +1521,7 @@ static cmd_tbl_t cmd_env_sub[] = {
 #endif
 	U_BOOT_CMD_MKENT(default, 1, 0, do_env_default, "", ""),
 	U_BOOT_CMD_MKENT(delete, CONFIG_SYS_MAXARGS, 0, do_env_delete, "", ""),
+	U_BOOT_CMD_MKENT(update, 3, 0, do_env_update, "", ""),
 #if defined(CONFIG_CMD_EDITENV)
 	U_BOOT_CMD_MKENT(edit, 2, 0, do_env_edit, "", ""),
 #endif
@@ -1144,7 +1544,7 @@ static cmd_tbl_t cmd_env_sub[] = {
 #if defined(CONFIG_CMD_RUN)
 	U_BOOT_CMD_MKENT(run, CONFIG_SYS_MAXARGS, 1, do_run, "", ""),
 #endif
-#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+#if defined(CONFIG_CMD_SAVEENV)
 	U_BOOT_CMD_MKENT(save, 1, 0, do_env_save, "", ""),
 #endif
 	U_BOOT_CMD_MKENT(set, CONFIG_SYS_MAXARGS, 0, do_env_set, "", ""),
@@ -1190,6 +1590,7 @@ static char env_help_text[] =
 	"default [-f] -a - [forcibly] reset default environment\n"
 	"env default [-f] var [...] - [forcibly] reset variable(s) to their default values\n"
 	"env delete [-f] var [...] - [forcibly] delete variable(s)\n"
+	"env update [name] [value] - add/append/replace variable(s)\n"
 #if defined(CONFIG_CMD_EDITENV)
 	"env edit name - edit environment variable\n"
 #endif
@@ -1216,7 +1617,7 @@ static char env_help_text[] =
 #if defined(CONFIG_CMD_RUN)
 	"env run var [...] - run commands in an environment variable\n"
 #endif
-#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+#if defined(CONFIG_CMD_SAVEENV)
 	"env save - save environment\n"
 #endif
 	"env set [-f] name [arg ...]\n";
diff --git a/cmd/part.c b/cmd/part.c
index 746bf40b2d..834f942446 100644
--- a/cmd/part.c
+++ b/cmd/part.c
@@ -86,7 +86,7 @@ static int do_part_list(int argc, char * const argv[])
 		char str[512] = { '\0', };
 		disk_partition_t info;
 
-		for (p = 1; p < 128; p++) {
+		for (p = 1; p < MAX_SEARCH_PARTITIONS; p++) {
 			char t[5];
 			int r = part_get_info(desc, p, &info);
 
diff --git a/cmd/pxe.c b/cmd/pxe.c
index c5a770a269..7043ad11fd 100644
--- a/cmd/pxe.c
+++ b/cmd/pxe.c
@@ -616,7 +616,7 @@ static int label_localboot(struct pxe_label *label)
 static int label_boot(cmd_tbl_t *cmdtp, struct pxe_label *label)
 {
 	char *bootm_argv[] = { "bootm", NULL, NULL, NULL, NULL };
-	char initrd_str[22];
+	char initrd_str[28];
 	char mac_str[29] = "";
 	char ip_str[68] = "";
 	int bootm_argc = 2;
@@ -648,9 +648,9 @@ static int label_boot(cmd_tbl_t *cmdtp, struct pxe_label *label)
 		}
 
 		bootm_argv[2] = initrd_str;
-		strcpy(bootm_argv[2], env_get("ramdisk_addr_r"));
+		strncpy(bootm_argv[2], env_get("ramdisk_addr_r"), 18);
 		strcat(bootm_argv[2], ":");
-		strcat(bootm_argv[2], env_get("filesize"));
+		strncat(bootm_argv[2], env_get("filesize"), 9);
 	}
 
 	if (get_relfile_envaddr(cmdtp, label->kernel, "kernel_addr_r") < 0) {
@@ -686,16 +686,17 @@ static int label_boot(cmd_tbl_t *cmdtp, struct pxe_label *label)
 			       strlen(ip_str), strlen(mac_str),
 			       sizeof(bootargs));
 			return 1;
+		} else {
+			if (label->append)
+				strncpy(bootargs, label->append,
+					sizeof(bootargs));
+			strcat(bootargs, ip_str);
+			strcat(bootargs, mac_str);
+
+			cli_simple_process_macros(bootargs, finalbootargs);
+			env_set("bootargs", finalbootargs);
+			printf("append: %s\n", finalbootargs);
 		}
-
-		if (label->append)
-			strcpy(bootargs, label->append);
-		strcat(bootargs, ip_str);
-		strcat(bootargs, mac_str);
-
-		cli_simple_process_macros(bootargs, finalbootargs);
-		env_set("bootargs", finalbootargs);
-		printf("append: %s\n", finalbootargs);
 	}
 
 	bootm_argv[1] = env_get("kernel_addr_r");
diff --git a/cmd/regulator.c b/cmd/regulator.c
index 2ef5bc9a82..b605255180 100644
--- a/cmd/regulator.c
+++ b/cmd/regulator.c
@@ -71,7 +71,7 @@ static int curr_dev_and_platdata(struct udevice **devp,
 
 	*uc_pdata = dev_get_uclass_platdata(*devp);
 	if (!*uc_pdata) {
-		error("Regulator: %s - missing platform data!", currdev->name);
+		pr_err("Regulator: %s - missing platform data!", currdev->name);
 		return CMD_RET_FAILURE;
 	}
 
diff --git a/cmd/sf.c b/cmd/sf.c
index f971eec781..66832a7e37 100644
--- a/cmd/sf.c
+++ b/cmd/sf.c
@@ -82,14 +82,13 @@ static int do_spi_flash_probe(int argc, char * const argv[])
 {
 	unsigned int bus = CONFIG_SF_DEFAULT_BUS;
 	unsigned int cs = CONFIG_SF_DEFAULT_CS;
+	/* In DM mode, defaults speed and mode will be taken from DT */
 	unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
 	unsigned int mode = CONFIG_SF_DEFAULT_MODE;
 	char *endp;
 #ifdef CONFIG_DM_SPI_FLASH
 	struct udevice *new, *bus_dev;
 	int ret;
-	/* In DM mode defaults will be taken from DT */
-	speed = 0, mode = 0;
 #else
 	struct spi_flash *new;
 #endif
@@ -442,12 +441,15 @@ static int spi_flash_test(struct spi_flash *flash, uint8_t *buf, ulong len,
 {
 	struct test_info test;
 	int i;
+	int erase_len;
 
 	printf("SPI flash test:\n");
 	memset(&test, '\0', sizeof(test));
 	test.base_ms = get_timer(0);
 	test.bytes = len;
-	if (spi_flash_erase(flash, offset, len)) {
+
+	erase_len = roundup(len, 4096);
+	if (spi_flash_erase(flash, offset, erase_len)) {
 		printf("Erase failed\n");
 		return -1;
 	}
@@ -506,6 +508,8 @@ static int do_spi_flash_test(int argc, char * const argv[])
 	char *endp;
 	uint8_t *vbuf;
 	int ret;
+	int count;
+	int i;
 
 	if (argc < 3)
 		return -1;
@@ -516,6 +520,10 @@ static int do_spi_flash_test(int argc, char * const argv[])
 	if (*argv[2] == 0 || *endp != 0)
 		return -1;
 
+	count = simple_strtoul(argv[3], &endp, 10);
+	if (!count)
+		count = 1;
+
 	vbuf = memalign(ARCH_DMA_MINALIGN, len);
 	if (!vbuf) {
 		printf("Cannot allocate memory (%lu bytes)\n", len);
@@ -530,7 +538,13 @@ static int do_spi_flash_test(int argc, char * const argv[])
 
 	from = map_sysmem(CONFIG_SYS_TEXT_BASE, 0);
 	memcpy(buf, from, len);
-	ret = spi_flash_test(flash, buf, len, offset, vbuf);
+	for (i = 0; i < count; i++) {
+		ret = spi_flash_test(flash, buf, len, offset, vbuf);
+		if (ret < 0) {
+			printf("Test Failed, passed count:%d\n", i);
+			break;
+		}
+	}
 	free(vbuf);
 	free(buf);
 	if (ret) {
diff --git a/cmd/source.c b/cmd/source.c
index a9831b6608..cf820c072a 100644
--- a/cmd/source.c
+++ b/cmd/source.c
@@ -31,7 +31,7 @@ source (ulong addr, const char *fit_uname)
 	const image_header_t *hdr;
 #endif
 	u32		*data;
-	int		verify;
+
 	void *buf;
 #if defined(CONFIG_FIT)
 	const void*	fit_hdr;
@@ -39,9 +39,13 @@ source (ulong addr, const char *fit_uname)
 	const void	*fit_data;
 	size_t		fit_len;
 #endif
-
-	verify = env_get_yesno("verify");
-
+#if defined(CONFIG_IMAGE_FORMAT_LEGACY) || defined(CONFIG_FIT)
+#ifdef CONFIG_FIT_SIGNATURE
+	int		verify = 1;
+#else
+	int		verify = env_get_yesno("verify");
+#endif
+#endif
 	buf = map_sysmem(addr, 0);
 	switch (genimg_get_format(buf)) {
 #if defined(CONFIG_IMAGE_FORMAT_LEGACY)
@@ -113,6 +117,19 @@ source (ulong addr, const char *fit_uname)
 
 		/* verify integrity */
 		if (verify) {
+#ifdef CONFIG_FIT_SIGNATURE
+			int conf_noffset;
+
+			/* NULL for default conf */
+			conf_noffset = fit_conf_get_node(fit_hdr, NULL);
+			if (conf_noffset < 0)
+				return conf_noffset;
+
+			if (fit_config_verify(fit_hdr, conf_noffset)) {
+				puts ("Bad Data Hash\n");
+				return 1;
+			}
+#endif
 			if (!fit_image_verify(fit_hdr, noffset)) {
 				puts ("Bad Data Hash\n");
 				return 1;
diff --git a/cmd/spl.c b/cmd/spl.c
index ad033652d4..593989717f 100644
--- a/cmd/spl.c
+++ b/cmd/spl.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <command.h>
 #include <cmd_spl.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -109,21 +109,23 @@ static int spl_export(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	c = find_cmd_tbl(argv[1], &cmd_spl_export_sub[0],
 		ARRAY_SIZE(cmd_spl_export_sub));
-	if ((c) && ((int)c->cmd <= SPL_EXPORT_LAST)) {
+	if ((c) && ((long)c->cmd <= SPL_EXPORT_LAST)) {
 		argc -= 2;
 		argv += 2;
-		if (call_bootm(argc, argv, subcmd_list[(int)c->cmd]))
+		if (call_bootm(argc, argv, subcmd_list[(long)c->cmd]))
 			return -1;
-		switch ((int)c->cmd) {
+		switch ((long)c->cmd) {
 #ifdef CONFIG_OF_LIBFDT
 		case SPL_EXPORT_FDT:
 			printf("Argument image is now in RAM: 0x%p\n",
 				(void *)images.ft_addr);
 			env_set_addr("fdtargsaddr", images.ft_addr);
 			env_set_hex("fdtargslen", fdt_totalsize(images.ft_addr));
+#ifdef CONFIG_CMD_SPL_WRITE_SIZE
 			if (fdt_totalsize(images.ft_addr) >
 			    CONFIG_CMD_SPL_WRITE_SIZE)
 				puts("WARN: FDT size > CMD_SPL_WRITE_SIZE\n");
+#endif
 			break;
 #endif
 		case SPL_EXPORT_ATAGS:
@@ -153,7 +155,7 @@ static int do_spl(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	c = find_cmd_tbl(argv[1], &cmd_spl_sub[0], ARRAY_SIZE(cmd_spl_sub));
 	if (c) {
-		cmd = (int)c->cmd;
+		cmd = (long)c->cmd;
 		switch (cmd) {
 		case SPL_EXPORT:
 			argc--;
diff --git a/cmd/thordown.c b/cmd/thordown.c
index 436b7f5631..c560cc9c6b 100644
--- a/cmd/thordown.c
+++ b/cmd/thordown.c
@@ -31,9 +31,9 @@ int do_thor_down(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		goto done;
 
 	int controller_index = simple_strtoul(usb_controller, NULL, 0);
-	ret = board_usb_init(controller_index, USB_INIT_DEVICE);
+	ret = usb_gadget_initialize(controller_index);
 	if (ret) {
-		error("USB init failed: %d", ret);
+		pr_err("USB init failed: %d", ret);
 		ret = CMD_RET_FAILURE;
 		goto exit;
 	}
@@ -42,21 +42,21 @@ int do_thor_down(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	ret = thor_init();
 	if (ret) {
-		error("THOR DOWNLOAD failed: %d", ret);
+		pr_err("THOR DOWNLOAD failed: %d", ret);
 		ret = CMD_RET_FAILURE;
 		goto exit;
 	}
 
 	ret = thor_handle();
 	if (ret) {
-		error("THOR failed: %d", ret);
+		pr_err("THOR failed: %d", ret);
 		ret = CMD_RET_FAILURE;
 		goto exit;
 	}
 
 exit:
 	g_dnl_unregister();
-	board_usb_cleanup(controller_index, USB_INIT_DEVICE);
+	usb_gadget_release(controller_index);
 done:
 	dfu_free_entities();
 
diff --git a/cmd/time.c b/cmd/time.c
index de57e3b9dd..2cd8b1a577 100644
--- a/cmd/time.c
+++ b/cmd/time.c
@@ -28,7 +28,7 @@ static int do_time(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	ulong cycles = 0;
 	int retval = 0;
-	int repeatable;
+	int repeatable = 0;
 
 	if (argc == 1)
 		return CMD_RET_USAGE;
diff --git a/cmd/tpm_test.c b/cmd/tpm_test.c
index 3306405948..37ad2ff33d 100644
--- a/cmd/tpm_test.c
+++ b/cmd/tpm_test.c
@@ -303,12 +303,12 @@ static int test_readonly(void)
 	index_0 += 1;
 	if (tpm_nv_write_value(INDEX0, (uint8_t *)&index_0, sizeof(index_0) !=
 		TPM_SUCCESS)) {
-		error("\tcould not write index 0\n");
+		pr_err("\tcould not write index 0\n");
 	}
 	tpm_nv_write_value_lock(INDEX0);
 	if (tpm_nv_write_value(INDEX0, (uint8_t *)&index_0, sizeof(index_0)) ==
 			TPM_SUCCESS)
-		error("\tindex 0 is not locked\n");
+		pr_err("\tindex 0 is not locked\n");
 
 	printf("\tdone\n");
 	return 0;
@@ -471,7 +471,7 @@ static int test_write_limit(void)
 		case TPM_MAXNVWRITES:
 			assert(i >= TPM_MAX_NV_WRITES_NOOWNER);
 		default:
-			error("\tunexpected error code %d (0x%x)\n",
+			pr_err("\tunexpected error code %d (0x%x)\n",
 			      result, result);
 		}
 	}
diff --git a/cmd/usb.c b/cmd/usb.c
index d95bcf5c8e..907debe30f 100644
--- a/cmd/usb.c
+++ b/cmd/usb.c
@@ -349,6 +349,16 @@ static void usb_show_tree_graph(struct usb_device *dev, char *pre)
 	printf(" %s", pre);
 #ifdef CONFIG_DM_USB
 	has_child = device_has_active_children(dev->dev);
+	if (device_get_uclass_id(dev->dev) == UCLASS_MASS_STORAGE) {
+		struct udevice *child;
+
+		for (device_find_first_child(dev->dev, &child);
+		     child;
+		     device_find_next_child(&child)) {
+			if (device_get_uclass_id(child) == UCLASS_BLK)
+				has_child = 0;
+		}
+	}
 #else
 	/* check if the device has connected children */
 	int i;
@@ -414,8 +424,12 @@ static void usb_show_tree_graph(struct usb_device *dev, char *pre)
 
 		udev = dev_get_parent_priv(child);
 
-		/* Ignore emulators, we only want real devices */
-		if (device_get_uclass_id(child) != UCLASS_USB_EMUL) {
+		/*
+		 * Ignore emulators and block child devices, we only want
+		 * real devices
+		 */
+		if ((device_get_uclass_id(child) != UCLASS_USB_EMUL) &&
+		    (device_get_uclass_id(child) != UCLASS_BLK)) {
 			usb_show_tree_graph(udev, pre);
 			pre[index] = 0;
 		}
@@ -605,7 +619,9 @@ static void usb_show_info(struct usb_device *udev)
 	for (device_find_first_child(udev->dev, &child);
 	     child;
 	     device_find_next_child(&child)) {
-		if (device_active(child)) {
+		if (device_active(child) &&
+		    (device_get_uclass_id(child) != UCLASS_USB_EMUL) &&
+		    (device_get_uclass_id(child) != UCLASS_BLK)) {
 			udev = dev_get_parent_priv(child);
 			usb_show_info(udev);
 		}
diff --git a/cmd/usb_gadget_sdp.c b/cmd/usb_gadget_sdp.c
index b1d8b2858e..d7a9035343 100644
--- a/cmd/usb_gadget_sdp.c
+++ b/cmd/usb_gadget_sdp.c
@@ -21,24 +21,24 @@ static int do_sdp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	char *usb_controller = argv[1];
 	int controller_index = simple_strtoul(usb_controller, NULL, 0);
-	board_usb_init(controller_index, USB_INIT_DEVICE);
+	usb_gadget_initialize(controller_index);
 
 	g_dnl_clear_detach();
 	g_dnl_register("usb_dnl_sdp");
 
 	ret = sdp_init(controller_index);
 	if (ret) {
-		error("SDP init failed: %d", ret);
+		pr_err("SDP init failed: %d\n", ret);
 		goto exit;
 	}
 
 	/* This command typically does not return but jumps to an image */
 	sdp_handle(controller_index);
-	error("SDP ended");
+	pr_err("SDP ended\n");
 
 exit:
 	g_dnl_unregister();
-	board_usb_cleanup(controller_index, USB_INIT_DEVICE);
+	usb_gadget_release(controller_index);
 
 	return ret;
 }
diff --git a/cmd/usb_mass_storage.c b/cmd/usb_mass_storage.c
index 3353f95c74..a05504b000 100644
--- a/cmd/usb_mass_storage.c
+++ b/cmd/usb_mass_storage.c
@@ -161,22 +161,22 @@ static int do_usb_mass_storage(cmd_tbl_t *cmdtp, int flag,
 
 	controller_index = (unsigned int)(simple_strtoul(
 				usb_controller,	NULL, 0));
-	if (board_usb_init(controller_index, USB_INIT_DEVICE)) {
-		error("Couldn't init USB controller.");
+	if (usb_gadget_initialize(controller_index)) {
+		pr_err("Couldn't init USB controller.\n");
 		rc = CMD_RET_FAILURE;
 		goto cleanup_ums_init;
 	}
 
 	rc = fsg_init(ums, ums_count);
 	if (rc) {
-		error("fsg_init failed");
+		pr_err("fsg_init failed");
 		rc = CMD_RET_FAILURE;
 		goto cleanup_board;
 	}
 
 	rc = g_dnl_register("usb_dnl_ums");
 	if (rc) {
-		error("g_dnl_register failed");
+		pr_err("g_dnl_register failed");
 		rc = CMD_RET_FAILURE;
 		goto cleanup_board;
 	}
@@ -232,7 +232,7 @@ static int do_usb_mass_storage(cmd_tbl_t *cmdtp, int flag,
 cleanup_register:
 	g_dnl_unregister();
 cleanup_board:
-	board_usb_cleanup(controller_index, USB_INIT_DEVICE);
+	usb_gadget_release(controller_index);
 cleanup_ums_init:
 	ums_fini();
 
diff --git a/common/Kconfig b/common/Kconfig
index 4d8cae9610..2de87b3090 100644
--- a/common/Kconfig
+++ b/common/Kconfig
@@ -111,6 +111,10 @@ config BOOTSTAGE_STASH_SIZE
 	  This should be large enough to hold the bootstage stash. A value of
 	  4096 (4KiB) is normally plenty.
 
+config BOOTSTAGE_PRINTF_TIMESTAMP
+	bool "Support printf timestamp"
+	help
+	  Enabling this will support printf timestamp.
 endmenu
 
 menu "Boot media"
@@ -174,6 +178,13 @@ config SPI_BOOT
 
 endmenu
 
+config PASS_DEVICE_SERIAL_BY_FDT
+	bool "Pass the device serial number to kernel through devicetree"
+	default y
+	help
+	  Enabling this will pass a device serial number to kernel by devicetree
+	  "serial-number" properties.
+
 config BOOTDELAY
 	int "delay in seconds before automatically booting"
 	default 2
@@ -202,6 +213,11 @@ config BOOTARGS
 	  CONFIG_BOOTARGS goes into the environment value "bootargs". Note that
 	  this value will also override the "chosen" node in FDT blob.
 
+config IO_TRACE
+	bool "Enable iotrace"
+	help
+	  This enable iotrace feature.
+
 menu "Console"
 
 config MENU
@@ -222,7 +238,8 @@ config CONSOLE_RECORD
 config CONSOLE_RECORD_OUT_SIZE
 	hex "Output buffer size"
 	depends on CONSOLE_RECORD
-	default 0x400 if CONSOLE_RECORD
+	default 0x400 if CONSOLE_RECORD && !ARCH_ROCKCHIP
+	default 0x2000 if CONSOLE_RECORD && ARCH_ROCKCHIP
 	help
 	  Set the size of the console output buffer. When this fills up, no
 	  more data will be recorded until some is removed. The buffer is
@@ -238,11 +255,43 @@ config CONSOLE_RECORD_IN_SIZE
 	  The buffer is allocated immediately after the malloc() region is
 	  ready.
 
+config CONSOLE_DISABLE_CLI
+	bool "disable ctrlc"
+	default n
+	help
+	  This disable CLI interactive in verified-boot.
+
+config DISABLE_CONSOLE
+	bool "disable console in & out"
+	help
+	 This disable console in & out.
+
 config IDENT_STRING
 	string "Board specific string to be added to uboot version string"
 	help
 	  This options adds the board specific name to u-boot version.
 
+config LOGLEVEL
+	int "loglevel"
+	default 4
+	range 0 8
+	help
+	  All Messages with a loglevel smaller than the console loglevel will
+	  be compiled in. The loglevels are defined as follows:
+
+	  0 (KERN_EMERG)          system is unusable
+	  1 (KERN_ALERT)          action must be taken immediately
+	  2 (KERN_CRIT)           critical conditions
+	  3 (KERN_ERR)            error conditions
+	  4 (KERN_WARNING)        warning conditions
+	  5 (KERN_NOTICE)         normal but significant condition
+	  6 (KERN_INFO)           informational
+	  7 (KERN_DEBUG)          debug-level messages
+
+config SPL_LOGLEVEL
+	int
+	default LOGLEVEL
+
 config SILENT_CONSOLE
 	bool "Support a silent console"
 	help
@@ -384,21 +433,91 @@ config SYS_STDIO_DEREGISTER
 
 endmenu
 
-config DTB_RESELECT
-	bool "Support swapping dtbs at a later point in boot"
-	depends on FIT_EMBED
-	help
-	  It is possible during initial boot you may need to use a generic
-	  dtb until you can fully determine the board your running on. This
-	  config allows boards to implement a function at a later point
-	  during boot to switch to the "correct" dtb.
+menu "Logging"
+
+config LOG
+	bool "Enable logging support"
+	help
+	  This enables support for logging of status and debug messages. These
+	  can be displayed on the console, recorded in a memory buffer, or
+	  discarded if not needed. Logging supports various categories and
+	  levels of severity.
+
+config SPL_LOG
+	bool "Enable logging support in SPL"
+	help
+	  This enables support for logging of status and debug messages. These
+	  can be displayed on the console, recorded in a memory buffer, or
+	  discarded if not needed. Logging supports various categories and
+	  levels of severity.
+
+config LOG_MAX_LEVEL
+	int "Maximum log level to record"
+	depends on LOG
+	default 5
+	help
+	  This selects the maximum log level that will be recorded. Any value
+	  higher than this will be ignored. If possible log statements below
+	  this level will be discarded at build time. Levels:
+
+	    0 - panic
+	    1 - critical
+	    2 - error
+	    3 - warning
+	    4 - note
+	    5 - info
+	    6 - detail
+	    7 - debug
+
+config SPL_LOG_MAX_LEVEL
+	int "Maximum log level to record in SPL"
+	depends on SPL_LOG
+	default 3
+	help
+	  This selects the maximum log level that will be recorded. Any value
+	  higher than this will be ignored. If possible log statements below
+	  this level will be discarded at build time. Levels:
+
+	    0 - panic
+	    1 - critical
+	    2 - error
+	    3 - warning
+	    4 - note
+	    5 - info
+	    6 - detail
+	    7 - debug
+
+config LOG_CONSOLE
+	bool "Allow log output to the console"
+	depends on LOG
+	default y
+	help
+	  Enables a log driver which writes log records to the console.
+	  Generally the console is the serial port or LCD display. Only the
+	  log message is shown - other details like level, category, file and
+	  line number are omitted.
+
+config LOG_SPL_CONSOLE
+	bool "Allow log output to the console in SPL"
+	depends on LOG_SPL
+	default y
+	help
+	  Enables a log driver which writes log records to the console.
+	  Generally the console is the serial port or LCD display. Only the
+	  log message is shown - other details like level, category, file and
+	  line number are omitted.
+
+config LOG_TEST
+	bool "Provide a test for logging"
+	depends on LOG
+	default y if SANDBOX
+	help
+	  This enables a 'log test' command to test logging. It is normally
+	  executed from a pytest and simply outputs logging information
+	  in various different ways to test that the logging system works
+	  correctly with varoius settings.
 
-config FIT_EMBED
-	bool "Support a FIT image embedded in the U-boot image"
-	help
-	  This option provides hooks to allow U-boot to parse an
-	  appended FIT image and enable board specific code to then select
-	  the correct DTB to be used.
+endmenu
 
 config DEFAULT_FDT_FILE
 	string "Default fdt file"
@@ -468,8 +587,89 @@ config BOARD_EARLY_INIT_F
 	  Note that the normal serial console is not yet set up, but the
 	  debug UART will be available if enabled.
 
+config BOARD_EARLY_INIT_R
+	bool "Call board-specific init after relocation"
+	help
+	  Some boards need to perform initialisation as directly after
+	  relocation. With this option, U-Boot calls board_early_init_r()
+	  in the post-relocation init sequence.
+
+endmenu
+
+menu "Android features support"
+config ANDROID_BOOTLOADER
+	bool "Support for Android Bootloader boot flow"
+	default n
+	depends on ANDROID_BOOT_IMAGE
+	help
+	  If enabled, adds support to boot an Android device following the
+	  Android Bootloader boot flow. This flow requires an Android Bootloader
+	  to handle the Android Bootloader Message stored in the Boot Control
+	  Block (BCB), normally in the "misc" partition of an Android device.
+	  The BCB is used to determine the boot mode of the device (normal mode,
+	  recovery mode or bootloader mode) and, if enabled, the slot to boot
+	  from in devices with multiple boot slots (A/B devices).
+
+config ANDROID_AB
+	bool "Support for Android A/B updates"
+	default n
+	help
+	  If enabled, adds support for the new Android A/B update model. This
+	  allows the bootloader to select which slot to boot from based on the
+	  information provided by userspace via the Android boot_ctrl HAL. This
+	  allows a bootloader to try a new version of the system but roll back
+	  to previous version if the new one didn't boot all the way.
+
+config ANDROID_WRITE_KEYBOX
+	bool "Support Write Keybox"
+	default y
+	depends on OPTEE_CLIENT
+	help
+	  This enable support write keybox to secure storage.
+
+config ANDROID_AVB
+	bool"Support Android Verified Boot"
+	default n
+	help
+	  If enabled, adds support the android verified boot. The avb get the
+	  digital signature and key from vemeta. Then use the RSA2048 and sha256
+	  to verify the boot images. The vbmeta must be matched with images,
+	  if not, verify failed.
+
+config ANDROID_AVB_ROLLBACK_INDEX
+	bool"Support Android Verified Boot Rollback Index"
+	default n
+	help
+	  If enabled, support the android verified boot rollback index.
+
+config ANDROID_KEYMASTER_CA
+	bool "Support Keymaster CA"
+	default y
+	depends on OPTEE_CLIENT
+	help
+	 This enable support read/write data in keymaster.
+
+config ANDROID_BOOT_IMAGE
+	bool "Enable support for Android Boot Images"
+	help
+	  This enables support for booting images which use the Android
+	  image format header.
+
+config ANDROID_BOOT_IMAGE_HASH
+	bool "Enable support for Android image hash verify"
+	depends on ANDROID_BOOT_IMAGE
+	select SHA1 if !DM_CRYPTO
+	help
+	  This enables support for Android image hash verify, the mkbootimg always use
+	  SHA1 for images.
 endmenu
 
+config SKIP_RELOCATE_UBOOT
+	bool "Skip U-Boot relocation"
+	default y if !ARM64 && !ARM64_BOOT_AARCH32
+	help
+	  This enable support for skipping U-Boot relocation.
+
 menu "Security support"
 
 config HASH
@@ -483,3 +683,4 @@ config HASH
 endmenu
 
 source "common/spl/Kconfig"
+source "common/usbplug/Kconfig"
diff --git a/common/Makefile b/common/Makefile
index 1b56cf9a70..1901154bb9 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -8,6 +8,8 @@
 # core
 ifndef CONFIG_SPL_BUILD
 obj-y += init/
+obj-$(CONFIG_SUPPORT_USBPLUG) += usbplug/
+
 obj-y += main.o
 obj-y += exports.o
 obj-$(CONFIG_HASH) += hash.o
@@ -21,7 +23,9 @@ endif
 
 # # boards
 obj-y += board_f.o
+ifndef CONFIG_SUPPORT_USBPLUG
 obj-y += board_r.o
+endif
 obj-$(CONFIG_DISPLAY_BOARDINFO) += board_info.o
 obj-$(CONFIG_DISPLAY_BOARDINFO_LATE) += board_info.o
 
@@ -36,7 +40,7 @@ obj-$(CONFIG_MII) += miiphyutil.o
 obj-$(CONFIG_CMD_MII) += miiphyutil.o
 obj-$(CONFIG_PHYLIB) += miiphyutil.o
 
-ifdef CONFIG_CMD_USB
+ifdef CONFIG_USB
 obj-y += usb.o usb_hub.o
 obj-$(CONFIG_USB_STORAGE) += usb_storage.o
 endif
@@ -59,25 +63,30 @@ obj-$(CONFIG_MENU) += menu.o
 obj-$(CONFIG_UPDATE_TFTP) += update.o
 obj-$(CONFIG_DFU_TFTP) += update.o
 obj-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
-obj-$(CONFIG_CMDLINE) += cli_readline.o cli_simple.o
+obj-y += cli_readline.o cli_simple.o
 
 endif # !CONFIG_SPL_BUILD
 
-obj-$(CONFIG_$(SPL_)BOOTSTAGE) += bootstage.o
+obj-$(CONFIG_$(SPL_TPL_)BOOTSTAGE) += bootstage.o
 
 ifdef CONFIG_SPL_BUILD
-obj-$(CONFIG_SPL_DFU_SUPPORT) += dfu.o
-obj-$(CONFIG_SPL_DFU_SUPPORT) += cli_hush.o
+ifndef CONFIG_TPL_BUILD
+ifdef CONFIG_SPL_DFU
+obj-$(CONFIG_DFU_OVER_USB) += dfu.o
+endif
+obj-$(CONFIG_SPL_DFU) += cli_hush.o
 obj-$(CONFIG_SPL_HASH_SUPPORT) += hash.o
 obj-$(CONFIG_SPL_YMODEM_SUPPORT) += xyzModem.o
 obj-$(CONFIG_SPL_LOAD_FIT) += common_fit.o
 obj-$(CONFIG_SPL_NET_SUPPORT) += miiphyutil.o
+endif
 obj-$(CONFIG_$(SPL_TPL_)OF_LIBFDT) += fdt_support.o
 ifdef CONFIG_SPL_USB_HOST_SUPPORT
 obj-$(CONFIG_SPL_USB_SUPPORT) += usb.o usb_hub.o
 obj-$(CONFIG_USB_STORAGE) += usb_storage.o
 endif
 endif
+
 #others
 obj-$(CONFIG_DDR_SPD) += ddr_spd.o
 obj-$(CONFIG_SPD_EEPROM) += ddr_spd.o
@@ -99,16 +108,29 @@ ifneq ($(CONFIG_$(SPL_)SYS_MALLOC_F_LEN),0)
 obj-y += malloc_simple.o
 endif
 endif
+
+ifndef CONFIG_TPL_BUILD
 obj-y += image.o
-obj-$(CONFIG_ANDROID_BOOT_IMAGE) += image-android.o
+endif
+obj-$(CONFIG_$(SPL_TPL_)ANDROID_AB) += android_ab.o
+obj-$(CONFIG_$(SPL_TPL_)ANDROID_BOOT_IMAGE) += image-android.o
+obj-$(CONFIG_$(SPL_TPL_)ANDROID_BOOTLOADER) += android_bootloader.o
+
 obj-$(CONFIG_$(SPL_TPL_)OF_LIBFDT) += image-fdt.o
+ifndef CONFIG_TPL_BUILD
 obj-$(CONFIG_$(SPL_TPL_)FIT) += image-fit.o
-obj-$(CONFIG_FIT_EMBED) += boot_fit.o common_fit.o
+obj-$(CONFIG_$(SPL_)MULTI_DTB_FIT) += boot_fit.o common_fit.o
 obj-$(CONFIG_$(SPL_TPL_)FIT_SIGNATURE) += image-sig.o
-obj-$(CONFIG_IO_TRACE) += iotrace.o
+endif
+
 obj-y += memsize.o
 obj-y += stdio.o
 
+ifdef CONFIG_CMD_DTIMG
+obj-y += image-android-dt.o
+endif
+
+ifndef CONFIG_SPL_BUILD
 # This option is not just y/n - it can have a numeric value
 ifdef CONFIG_FASTBOOT_FLASH
 obj-y += image-sparse.o
@@ -120,6 +142,11 @@ obj-y += fb_nand.o
 endif
 endif
 
+ifneq ($(or $(CONFIG_USB_FUNCTION_FASTBOOT),$(CONFIG_UDP_FUNCTION_FASTBOOT)),)
+obj-y += fb_common.o
+endif
+endif
+
 ifdef CONFIG_CMD_EEPROM_LAYOUT
 obj-y += eeprom/eeprom_field.o eeprom/eeprom_layout.o
 endif
@@ -128,5 +155,14 @@ obj-y += cli.o
 obj-$(CONFIG_FSL_DDR_INTERACTIVE) += cli_simple.o cli_readline.o
 obj-$(CONFIG_CMD_DFU) += dfu.o
 obj-y += command.o
+obj-$(CONFIG_$(SPL_)LOG) += log.o
+obj-$(CONFIG_$(SPL_)LOG_CONSOLE) += log_console.o
 obj-y += s_record.o
-obj-y += xyzModem.o
+
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_CMD_LOADB) += xyzModem.o rbsb.o zm.o zreadline.o lrz.o
+obj-$(CONFIG_IO_TRACE) += iotrace.o
+obj-$(CONFIG_ANDROID_WRITE_KEYBOX) += write_keybox.o
+obj-$(CONFIG_ANDROID_KEYMASTER_CA) += keymaster.o
+obj-$(CONFIG_ANDROID_KEYMASTER_CA) += attestation_key.o
+endif
diff --git a/common/autoboot.c b/common/autoboot.c
index a011865028..c64d566d1c 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -216,13 +216,17 @@ static int __abortboot(int bootdelay)
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
-	printf("Hit any key to stop autoboot: %2d ", bootdelay);
+	printf("Hit key to stop autoboot('CTRL+C'): %2d ", bootdelay);
 #endif
 
+#ifdef CONFIG_ARCH_ROCKCHIP
+	if (!IS_ENABLED(CONFIG_CONSOLE_DISABLE_CLI) && ctrlc()) {	/* we press ctrl+c ? */
+#else
 	/*
 	 * Check if key already pressed
 	 */
 	if (tstc()) {	/* we got a key press	*/
+#endif
 		(void) getc();  /* consume input	*/
 		puts("\b\b\b 0");
 		abort = 1;	/* don't auto boot	*/
@@ -233,13 +237,11 @@ static int __abortboot(int bootdelay)
 		/* delay 1000 ms */
 		ts = get_timer(0);
 		do {
-			if (tstc()) {	/* we got a key press	*/
+			if (ctrlc()) {	/* we got a ctrl+c key press	*/
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
 # ifdef CONFIG_MENUKEY
-				menukey = getc();
-# else
-				(void) getc();  /* consume input	*/
+				menukey = 0x03;	/* ctrl+c key code */
 # endif
 				break;
 			}
@@ -339,6 +341,12 @@ const char *bootdelay_process(void)
 	return s;
 }
 
+/*
+ * Board-specific Platform code can reimplement autoboot_command_fail_handle ()
+ * if needed
+ */
+__weak void autoboot_command_fail_handle(void) {}
+
 void autoboot_command(const char *s)
 {
 	debug("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
@@ -349,6 +357,7 @@ void autoboot_command(const char *s)
 #endif
 
 		run_command_list(s, -1, 0);
+		autoboot_command_fail_handle();
 
 #if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)
 		disable_ctrlc(prev);	/* restore Control C checking */
diff --git a/common/board_f.c b/common/board_f.c
index 104d144f41..caf23f5dc8 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -19,7 +19,6 @@
 #include <i2c.h>
 #include <initcall.h>
 #include <init_helpers.h>
-#include <logbuff.h>
 #include <malloc.h>
 #include <mapmem.h>
 #include <os.h>
@@ -41,6 +40,8 @@
 #include <asm/sections.h>
 #include <dm/root.h>
 #include <linux/errno.h>
+#include <bidram.h>
+#include <sysmem.h>
 
 /*
  * Pointer to initial global data area
@@ -118,7 +119,11 @@ __weak void board_add_ram_info(int use_default)
 
 static int init_baud_rate(void)
 {
-	gd->baudrate = env_get_ulong("baudrate", 10, CONFIG_BAUDRATE);
+	if (gd && gd->serial.baudrate)
+		gd->baudrate = gd->serial.baudrate;
+	else
+		gd->baudrate = env_get_ulong("baudrate", 10, CONFIG_BAUDRATE);
+
 	return 0;
 }
 
@@ -143,9 +148,28 @@ static int display_text_info(void)
 	return 0;
 }
 
+static int announce_serial(void)
+{
+	if (gd && gd->serial.using_pre_serial)
+		printf("PreSerial: %d, ", gd->serial.id);
+	else
+		printf("Serial: ");
+
+#ifdef CONFIG_DEBUG_UART_ALWAYS
+	printf("raw");
+#else
+	printf("console");
+#endif
+	printf(", 0x%lx\n", gd->serial.addr);
+
+	return 0;
+}
+
 static int announce_dram_init(void)
 {
+#ifndef CONFIG_SUPPORT_USBPLUG
 	puts("DRAM:  ");
+#endif
 	return 0;
 }
 
@@ -170,10 +194,15 @@ static int show_dram_config(void)
 	size = gd->ram_size;
 #endif
 
+#ifdef CONFIG_BIDRAM
+	size += bidram_append_size();
+#endif
+
+#ifndef CONFIG_SUPPORT_USBPLUG
 	print_size(size, "");
 	board_add_ram_info(0);
 	putc('\n');
-
+#endif
 	return 0;
 }
 
@@ -219,7 +248,7 @@ static int setup_mon_len(void)
 	gd->mon_len = (ulong)&_end - (ulong)_init;
 #elif defined(CONFIG_NIOS2) || defined(CONFIG_XTENSA)
 	gd->mon_len = CONFIG_SYS_MONITOR_LEN;
-#elif defined(CONFIG_NDS32) || defined(CONFIG_SH)
+#elif defined(CONFIG_NDS32) || defined(CONFIG_SH) || defined(CONFIG_RISCV)
 	gd->mon_len = (ulong)(&__bss_end) - (ulong)(&_start);
 #elif defined(CONFIG_SYS_MONITOR_BASE)
 	/* TODO: use (ulong)&__bss_end - (ulong)&__text_start; ? */
@@ -228,6 +257,11 @@ static int setup_mon_len(void)
 	return 0;
 }
 
+__weak int arch_fpga_init(void)
+{
+	return 0;
+}
+
 __weak int arch_cpu_init(void)
 {
 	return 0;
@@ -296,20 +330,6 @@ static int setup_dest_addr(void)
 	return 0;
 }
 
-#if defined(CONFIG_LOGBUFFER)
-static int reserve_logbuffer(void)
-{
-#ifndef CONFIG_ALT_LB_ADDR
-	/* reserve kernel log buffer */
-	gd->relocaddr -= LOGBUFF_RESERVE;
-	debug("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN,
-		gd->relocaddr);
-#endif
-
-	return 0;
-}
-#endif
-
 #ifdef CONFIG_PRAM
 /* reserve protected RAM */
 static int reserve_pram(void)
@@ -432,6 +452,23 @@ static int reserve_malloc(void)
 	return 0;
 }
 
+#ifdef CONFIG_SYS_NONCACHED_MEMORY
+static int reserve_noncached(void)
+{
+	phys_addr_t start, end;
+	size_t size;
+
+	end = ALIGN(gd->start_addr_sp, MMU_SECTION_SIZE) - MMU_SECTION_SIZE;
+	size = ALIGN(CONFIG_SYS_NONCACHED_MEMORY, MMU_SECTION_SIZE);
+	start = end - size;
+	gd->start_addr_sp = start;
+	debug("Reserving %zu for noncached_alloc() at: %08lx\n",
+	      size, gd->start_addr_sp);
+
+	return 0;
+}
+#endif
+
 /* (permanently) allocate a Board Info struct */
 static int reserve_board(void)
 {
@@ -471,10 +508,21 @@ static int reserve_fdt(void)
 	 * will be relocated with other data.
 	 */
 	if (gd->fdt_blob) {
-		gd->fdt_size = ALIGN(fdt_totalsize(gd->fdt_blob) + 0x1000, 32);
+		u32 extrasize = 0;
 
+		if (gd->fdt_blob_kern)
+			extrasize = fdt_totalsize(gd->fdt_blob_kern);
+		gd->fdt_size = ALIGN(fdt_totalsize(gd->fdt_blob) + extrasize + 0x1000, 32);
 		gd->start_addr_sp -= gd->fdt_size;
+
+		/* 8-byte align */
+		gd->start_addr_sp -= 8;
+		gd->start_addr_sp &= ~0x7;
 		gd->new_fdt = map_sysmem(gd->start_addr_sp, gd->fdt_size);
+
+		if (gd->fdt_blob_kern)
+			gd->fdt_blob_kern = (ulong *)ALIGN((ulong)gd->new_fdt +
+					fdt_totalsize(gd->fdt_blob), 8);
 		debug("Reserving %lu Bytes for FDT at: %08lx\n",
 		      gd->fdt_size, gd->start_addr_sp);
 	}
@@ -597,6 +645,9 @@ static int reloc_fdt(void)
 	if (gd->new_fdt) {
 		memcpy(gd->new_fdt, gd->fdt_blob, gd->fdt_size);
 		gd->fdt_blob = gd->new_fdt;
+#ifdef CONFIG_USING_KERNEL_DTB
+		gd->ufdt_blob = gd->new_fdt;
+#endif
 	}
 #endif
 
@@ -628,6 +679,7 @@ static int setup_reloc(void)
 		return 0;
 	}
 
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
 #ifdef CONFIG_SYS_TEXT_BASE
 #ifdef ARM
 	gd->reloc_off = gd->relocaddr - (unsigned long)__image_copy_start;
@@ -640,10 +692,24 @@ static int setup_reloc(void)
 #else
 	gd->reloc_off = gd->relocaddr - CONFIG_SYS_TEXT_BASE;
 #endif
+#endif
+
+#else
+	gd->reloc_off = 0;
 #endif
 	memcpy(gd->new_gd, (char *)gd, sizeof(gd_t));
 
-	debug("Relocation Offset is: %08lx\n", gd->reloc_off);
+#ifndef CONFIG_SUPPORT_USBPLUG
+	printf("Relocation Offset: %08lx\n", gd->reloc_off);
+
+	printf("Relocation fdt: %08lx - %08lx",  (ulong)gd->new_fdt,
+	       (ulong)gd->new_fdt + fdt_totalsize(gd->fdt_blob));
+	if (gd->fdt_blob_kern) {
+		printf(", kfdt: %08lx - %08lx", (ulong)gd->fdt_blob_kern,
+		  (ulong)gd->fdt_blob_kern + fdt_totalsize(gd->fdt_blob_kern));
+	}
+	puts("\n");
+#endif
 	debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
 	      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
 	      gd->start_addr_sp);
@@ -766,6 +832,7 @@ static const init_fnc_t init_sequence_f[] = {
 	trace_early_init,
 #endif
 	initf_malloc,
+	log_init,
 	initf_bootstage,	/* uses its own timer, so does not need DM */
 	initf_console_record,
 #if defined(CONFIG_HAVE_FSP)
@@ -818,6 +885,8 @@ static const init_fnc_t init_sequence_f[] = {
 #if defined(CONFIG_HARD_SPI)
 	init_func_spi,
 #endif
+	announce_serial,
+
 	announce_dram_init,
 	dram_init,		/* configure available RAM banks */
 #ifdef CONFIG_POST
@@ -846,9 +915,6 @@ static const init_fnc_t init_sequence_f[] = {
 	 *  - board info struct
 	 */
 	setup_dest_addr,
-#if defined(CONFIG_LOGBUFFER)
-	reserve_logbuffer,
-#endif
 #ifdef CONFIG_PRAM
 	reserve_pram,
 #endif
@@ -860,6 +926,9 @@ static const init_fnc_t init_sequence_f[] = {
 	reserve_trace,
 	reserve_uboot,
 	reserve_malloc,
+#ifdef CONFIG_SYS_NONCACHED_MEMORY
+	reserve_noncached,
+#endif
 	reserve_board,
 	setup_machine,
 	reserve_global_data,
@@ -869,6 +938,9 @@ static const init_fnc_t init_sequence_f[] = {
 	reserve_stacks,
 	dram_init_banksize,
 	show_dram_config,
+#ifdef CONFIG_SYSMEM
+	sysmem_init,		/* Validate above reserve memory */
+#endif
 #if defined(CONFIG_M68K) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \
 	defined(CONFIG_SH)
 	setup_board_part1,
@@ -950,8 +1022,13 @@ void board_init_f_r(void)
 	 * The pre-relocation drivers may be using memory that has now gone
 	 * away. Mark serial as unavailable - this will fall back to the debug
 	 * UART if available.
+	 *
+	 * Do the same with log drivers since the memory may not be available.
 	 */
-	gd->flags &= ~GD_FLG_SERIAL_READY;
+	gd->flags &= ~(GD_FLG_SERIAL_READY | GD_FLG_LOG_READY);
+#ifdef CONFIG_TIMER
+	gd->timer = NULL;
+#endif
 
 	/*
 	 * U-Boot has been copied into SDRAM, the BSS has been cleared etc.
diff --git a/common/board_info.c b/common/board_info.c
index aa45e24b34..b48fd1ebc0 100644
--- a/common/board_info.c
+++ b/common/board_info.c
@@ -3,7 +3,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <linux/compiler.h>
 
 int __weak checkboard(void)
@@ -27,5 +27,10 @@ int __weak show_board_info(void)
 		printf("Model: %s\n", model);
 #endif
 
+#ifdef CONFIG_ARM64_BOOT_AARCH32
+	if (!(gd->flags & GD_FLG_RELOC))
+		printf("CPU: AArch32\n");
+#endif
+
 	return checkboard();
 }
diff --git a/common/board_r.c b/common/board_r.c
index 94697e7bc1..cd1eb93ec9 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -18,9 +18,6 @@
 #endif
 #include <command.h>
 #include <console.h>
-#ifdef CONFIG_HAS_DATAFLASH
-#include <dataflash.h>
-#endif
 #include <dm.h>
 #include <environment.h>
 #include <fdtdec.h>
@@ -33,9 +30,9 @@
 #if defined(CONFIG_CMD_KGDB)
 #include <kgdb.h>
 #endif
-#include <logbuff.h>
 #include <malloc.h>
 #include <mapmem.h>
+#include <memalign.h>
 #ifdef CONFIG_BITBANGMII
 #include <miiphy.h>
 #endif
@@ -54,10 +51,15 @@
 #include <asm/mmu.h>
 #endif
 #include <asm/sections.h>
+#include <asm/system.h>
 #include <dm/root.h>
 #include <linux/compiler.h>
 #include <linux/err.h>
 #include <efi_loader.h>
+#include <sysmem.h>
+#include <bidram.h>
+#include <boot_rkimg.h>
+#include <mtd_blk.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -113,10 +115,32 @@ static int initr_reloc(void)
  * Some of these functions are needed purely because the functions they
  * call return void. If we change them to return 0, these stubs can go away.
  */
+
+static void print_cr(void)
+{
+	u32 reg;
+
+#ifdef CONFIG_ARM64
+	reg = get_sctlr();	/* get control reg. */
+#else
+	reg = get_cr();
+#endif
+	puts("CR: ");
+	if (reg & CR_M)
+		puts("M/");
+	if (reg & CR_C)
+		puts("C/");
+	if (reg & CR_I)
+		puts("I");
+	putc('\n');
+}
+
 static int initr_caches(void)
 {
 	/* Enable caches */
 	enable_caches();
+	print_cr();
+
 	return 0;
 }
 #endif
@@ -130,7 +154,7 @@ static int initr_reloc_global_data(void)
 {
 #ifdef __ARM__
 	monitor_flash_len = _end - __image_copy_start;
-#elif defined(CONFIG_NDS32)
+#elif defined(CONFIG_NDS32) || defined(CONFIG_RISCV)
 	monitor_flash_len = (ulong)&_end - (ulong)&_start;
 #elif !defined(CONFIG_SANDBOX) && !defined(CONFIG_NIOS2)
 	monitor_flash_len = (ulong)&__init_end - gd->relocaddr;
@@ -203,19 +227,6 @@ static int initr_addr_map(void)
 }
 #endif
 
-#ifdef CONFIG_LOGBUFFER
-unsigned long logbuffer_base(void)
-{
-	return gd->ram_top - LOGBUFF_LEN;
-}
-
-static int initr_logbuffer(void)
-{
-	logbuff_init_ptrs();
-	return 0;
-}
-#endif
-
 #ifdef CONFIG_POST
 static int initr_post_backlog(void)
 {
@@ -270,7 +281,12 @@ static int initr_malloc(void)
 static int initr_console_record(void)
 {
 #if defined(CONFIG_CONSOLE_RECORD)
-	return console_record_init();
+	int ret;
+
+	ret = console_record_init();
+	if (!ret)
+		console_record_reset_enable();
+	return ret;
 #else
 	return 0;
 #endif
@@ -339,7 +355,15 @@ __weak int power_init_board(void)
 
 static int initr_announce(void)
 {
-	debug("Now running in RAM - U-Boot at: %08lx\n", gd->relocaddr);
+	ulong addr;
+
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
+	addr = gd->relocaddr;
+#else
+	addr = CONFIG_SYS_TEXT_BASE;
+#endif
+	debug("Now running in RAM - U-Boot at: %08lx\n", addr);
+
 	return 0;
 }
 
@@ -406,8 +430,8 @@ static int initr_flash(void)
 #if defined(CONFIG_PPC) && !defined(CONFIG_DM_SPI)
 static int initr_spi(void)
 {
-	/* PPC does this here */
-#ifdef CONFIG_SPI
+	/* MPC8xx does this here */
+#ifdef CONFIG_MPC8XX_SPI
 #if !defined(CONFIG_ENV_IS_IN_EEPROM)
 	spi_init_f();
 #endif
@@ -421,9 +445,11 @@ static int initr_spi(void)
 /* go init the NAND */
 static int initr_nand(void)
 {
+#ifndef CONFIG_USING_KERNEL_DTB
 	puts("NAND:  ");
 	nand_init();
 	printf("%lu MiB\n", nand_size() / 1024);
+#endif
 	return 0;
 }
 #endif
@@ -441,21 +467,33 @@ static int initr_onenand(void)
 #ifdef CONFIG_MMC
 static int initr_mmc(void)
 {
+/*
+ * When CONFIG_USING_KERNEL_DTB is enabled, mmc has been initialized earlier.
+ */
+#ifndef CONFIG_USING_KERNEL_DTB
 	puts("MMC:   ");
 	mmc_initialize(gd->bd);
+#endif
 	return 0;
 }
 #endif
 
-#ifdef CONFIG_HAS_DATAFLASH
-static int initr_dataflash(void)
+#ifdef CONFIG_MTD_BLK
+static int initr_mtd_blk(void)
 {
-	AT91F_DataflashInit();
-	dataflash_print_info();
+#ifndef CONFIG_USING_KERNEL_DTB
+	struct blk_desc *dev_desc;
+
+	puts("mtd_blk:   ");
+	dev_desc = rockchip_get_bootdev();
+	if (dev_desc)
+		mtd_blk_map_partitions(dev_desc);
+#endif
 	return 0;
 }
 #endif
 
+#if !defined(CONFIG_USING_KERNEL_DTB) || !defined(CONFIG_ENV_IS_NOWHERE)
 /*
  * Tell if it's OK to load the environment early in boot.
  *
@@ -494,6 +532,90 @@ static int initr_env(void)
 
 	return 0;
 }
+#endif
+
+#ifdef CONFIG_USING_KERNEL_DTB
+/*
+ * If !defined(CONFIG_ENV_IS_NOWHERE):
+ *
+ * Storage env or kernel dtb load depends on bootdev, while bootdev
+ * depends on env varname: devtype, devnum and rkimg_bootdev, etc.
+ * So we have to use nowhere env firstly and cover the storage env
+ * after it is loaded.
+ *
+ * Providing a minimum and necessary nowhere env for board init to
+ * avoid covering the other varnames in storage env.
+ */
+static int initr_env_nowhere(void)
+{
+#ifdef CONFIG_ENV_IS_NOWHERE
+	set_default_env(NULL);
+#if defined(CONFIG_ENVF)
+	/* init envf and partitiont from envf before any partition query action */
+	env_load();
+#endif
+	return 0;
+#else
+	const char env_minimum[] = {
+		ENV_MEM_LAYOUT_SETTINGS
+#ifdef ENV_MEM_LAYOUT_SETTINGS1
+		ENV_MEM_LAYOUT_SETTINGS1
+#endif
+#ifdef RKIMG_DET_BOOTDEV
+		RKIMG_DET_BOOTDEV
+#endif
+	};
+
+	return set_board_env((char *)env_minimum, ENV_SIZE, 0, true);
+#endif
+}
+
+#if !defined(CONFIG_ENV_IS_NOWHERE)
+/*
+ * storage has been initialized in board_init(), we could switch env
+ * from nowhere to storage, i.e. CONFIG_ENV_IS_IN_xxx=y.
+ */
+static int initr_env_switch(void)
+{
+	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_nowhere, 1);
+	char *data;
+	int ret;
+
+	data = env_get("bootargs");
+	if (data) {
+		env_set("bootargs_tmp", data);
+		env_set("bootargs", NULL);
+	}
+
+	/* Export nowhere env for late use */
+	ret = env_export(env_nowhere);
+	if (ret) {
+		printf("%s: export nowhere env fail, ret=%d\n", __func__, ret);
+		return -EINVAL;
+	}
+
+	/* Destroy nowhere env and import storage env */
+	initr_env();
+
+	/* Append/override nowhere env to storage env */
+	set_board_env((char *)env_nowhere->data, ENV_SIZE, H_NOCLEAR, false);
+
+	/*
+	 * Restore nowhere bootargs to append/override the one in env storage.
+	 *
+	 * Without this, the entire "bootargs" in storage env is replaces by
+	 * the one in env_nowhere->data.
+	 */
+	data = env_get("bootargs_tmp");
+	if (data) {
+		env_update("bootargs", data);
+		env_set("bootargs_tmp", NULL);
+	}
+
+	return 0;
+}
+#endif	/* CONFIG_ENV_IS_NOWHERE */
+#endif	/* CONFIG_USING_KERNEL_DTB */
 
 #ifdef CONFIG_SYS_BOOTPARAMS_LEN
 static int initr_malloc_bootparams(void)
@@ -509,7 +631,9 @@ static int initr_malloc_bootparams(void)
 
 static int initr_jumptable(void)
 {
+#ifndef CONFIG_ROCKCHIP_IMAGE_TINY
 	jumptable_init();
+#endif
 	return 0;
 }
 
@@ -640,7 +764,7 @@ static int initr_ide(void)
 }
 #endif
 
-#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
+#if defined(CONFIG_PRAM)
 /*
  * Export available size of memory for Linux, taking into account the
  * protected RAM at top of memory
@@ -652,10 +776,6 @@ int initr_mem(void)
 
 # ifdef CONFIG_PRAM
 	pram = env_get_ulong("pram", 10, CONFIG_PRAM);
-# endif
-# if defined(CONFIG_LOGBUFFER) && !defined(CONFIG_ALT_LB_ADDR)
-	/* Also take the logbuffer into account (pram is in kB) */
-	pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
 # endif
 	sprintf(memsz, "%ldk", (long int) ((gd->ram_size / 1024) - pram));
 	env_set("mem", memsz);
@@ -682,6 +802,16 @@ static int initr_kbd(void)
 }
 #endif
 
+__weak int interrupt_debugger_init(void)
+{
+	return 0;
+}
+
+__weak int board_initr_caches_fixup(void)
+{
+	return 0;
+}
+
 static int run_main_loop(void)
 {
 #ifdef CONFIG_SANDBOX
@@ -716,25 +846,62 @@ static init_fnc_t init_sequence_r[] = {
 	 */
 #endif
 	initr_reloc_global_data,
+
+	/*
+	 * Some platform requires to reserve memory regions for some firmware
+	 * to avoid kernel touches it, but U-Boot may have communication with
+	 * firmware by share memory. So that we had better reserve firmware
+	 * region after the initr_caches() which enables MMU and init
+	 * translation table, we need firmware region to be mapped as cacheable
+	 * like other regions, otherwise there would be dcache coherence issue
+	 * between firmware and U-Boot.
+	 */
+	board_initr_caches_fixup,
+
 #if defined(CONFIG_SYS_INIT_RAM_LOCK) && defined(CONFIG_E500)
 	initr_unlock_ram_in_cache,
 #endif
 	initr_barrier,
 	initr_malloc,
+#ifdef CONFIG_BIDRAM
+	bidram_initr,
+#endif
+#ifdef CONFIG_SYSMEM
+	sysmem_initr,
+#endif
+	log_init,
 	initr_bootstage,	/* Needs malloc() but has its own timer */
 	initr_console_record,
 #ifdef CONFIG_SYS_NONCACHED_MEMORY
 	initr_noncached,
 #endif
 	bootstage_relocate,
+
+	interrupt_init,
+#ifdef CONFIG_ARM
+	initr_enable_interrupts,
+#endif
+	interrupt_debugger_init,
+
 #ifdef CONFIG_OF_LIVE
 	initr_of_live,
 #endif
 #ifdef CONFIG_DM
 	initr_dm,
 #endif
-#if defined(CONFIG_ARM) || defined(CONFIG_NDS32)
+
+#ifdef CONFIG_USING_KERNEL_DTB
+	initr_env_nowhere,
+#endif
+#if defined(CONFIG_BOARD_EARLY_INIT_R)
+	board_early_init_r,
+#endif
+
+#if defined(CONFIG_ARM) || defined(CONFIG_NDS32) || defined(CONFIG_RISCV)
 	board_init,	/* Setup chipselects */
+#endif
+#if defined(CONFIG_USING_KERNEL_DTB) && !defined(CONFIG_ENV_IS_NOWHERE)
+	initr_env_switch,
 #endif
 	/*
 	 * TODO: printing of the clock inforamtion of the board is now
@@ -760,18 +927,13 @@ static init_fnc_t init_sequence_r[] = {
 #endif
 #ifdef CONFIG_ADDR_MAP
 	initr_addr_map,
-#endif
-#if defined(CONFIG_BOARD_EARLY_INIT_R)
-	board_early_init_r,
 #endif
 	INIT_FUNC_WATCHDOG_RESET
-#ifdef CONFIG_LOGBUFFER
-	initr_logbuffer,
-#endif
 #ifdef CONFIG_POST
 	initr_post_backlog,
 #endif
 	INIT_FUNC_WATCHDOG_RESET
+
 #if defined(CONFIG_PCI) && defined(CONFIG_SYS_EARLY_PCI_INIT)
 	/*
 	 * Do early PCI configuration _before_ the flash gets initialised,
@@ -800,13 +962,16 @@ static init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_CMD_ONENAND
 	initr_onenand,
 #endif
+#ifdef CONFIG_MTD_BLK
+	initr_mtd_blk,
+#endif
 #ifdef CONFIG_MMC
 	initr_mmc,
 #endif
-#ifdef CONFIG_HAS_DATAFLASH
-	initr_dataflash,
-#endif
+#ifndef CONFIG_USING_KERNEL_DTB
 	initr_env,
+#endif
+
 #ifdef CONFIG_SYS_BOOTPARAMS_LEN
 	initr_malloc_bootparams,
 #endif
@@ -842,10 +1007,7 @@ static init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_CMD_KGDB
 	initr_kgdb,
 #endif
-	interrupt_init,
-#ifdef CONFIG_ARM
-	initr_enable_interrupts,
-#endif
+
 #if defined(CONFIG_MICROBLAZE) || defined(CONFIG_M68K)
 	timer_init,		/* initialize timer */
 #endif
@@ -892,7 +1054,7 @@ static init_fnc_t init_sequence_r[] = {
 	INIT_FUNC_WATCHDOG_RESET
 	initr_bedbug,
 #endif
-#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
+#if defined(CONFIG_PRAM)
 	initr_mem,
 #endif
 #ifdef CONFIG_PS2KBD
@@ -920,6 +1082,7 @@ void board_init_r(gd_t *new_gd, ulong dest_addr)
 #if !defined(CONFIG_X86) && !defined(CONFIG_ARM) && !defined(CONFIG_ARM64)
 	gd = new_gd;
 #endif
+	gd->flags &= ~GD_FLG_LOG_READY;
 
 #ifdef CONFIG_NEEDS_MANUAL_RELOC
 	for (i = 0; i < ARRAY_SIZE(init_sequence_r); i++)
diff --git a/common/boot_fit.c b/common/boot_fit.c
index 0a723150b5..4dedd08a8e 100644
--- a/common/boot_fit.c
+++ b/common/boot_fit.c
@@ -11,9 +11,9 @@
 #include <common.h>
 #include <errno.h>
 #include <image.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
-int fdt_offset(void *fit)
+static int fdt_offset(const void *fit)
 {
 	int images, node, fdt_len, fdt_node, fdt_offset;
 	const char *fdt_name;
@@ -55,14 +55,14 @@ int fdt_offset(void *fit)
 	return fdt_offset;
 }
 
-void *locate_dtb_in_fit(void *fit)
+void *locate_dtb_in_fit(const void *fit)
 {
 	struct image_header *header;
 	int size;
 	int ret;
 
 	size = fdt_totalsize(fit);
-	size = (size + 3) & ~3;
+	size = FIT_ALIGN(size);
 
 	header = (struct image_header *)fit;
 
@@ -73,7 +73,7 @@ void *locate_dtb_in_fit(void *fit)
 
 	ret = fdt_offset(fit);
 
-	if (ret <= 0)
+	if (ret < 0)
 		return NULL;
 	else
 		return (void *)fit+size+ret;
diff --git a/common/bootm.c b/common/bootm.c
index 32b3ea8e2d..fcb561d7de 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -30,6 +30,10 @@
 #include <bootm.h>
 #include <image.h>
 
+#ifdef USE_HOSTCC
+#define CONFIG_SYS_BOOTM_LEN	0x4000000
+#endif
+
 #ifndef CONFIG_SYS_BOOTM_LEN
 /* use 8MByte as default max gunzip size */
 #define CONFIG_SYS_BOOTM_LEN	0x800000
@@ -43,6 +47,16 @@ DECLARE_GLOBAL_DATA_PTR;
 
 bootm_headers_t images;		/* pointers to os/initrd/fdt images */
 
+__weak int board_do_bootm(int argc, char * const argv[])
+{
+	return 0;
+}
+
+__weak int bootm_board_start(void)
+{
+	return 0;
+}
+
 static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 				   char * const argv[], bootm_headers_t *images,
 				   ulong *os_data, ulong *os_len);
@@ -50,16 +64,23 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 #ifdef CONFIG_LMB
 static void boot_start_lmb(bootm_headers_t *images)
 {
-	ulong		mem_start;
-	phys_size_t	mem_size;
 
 	lmb_init(&images->lmb);
+#ifdef CONFIG_NR_DRAM_BANKS
+	int i;
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		lmb_add(&images->lmb, gd->bd->bi_dram[i].start,
+			gd->bd->bi_dram[i].size);
+	}
+#else
+	ulong		mem_start;
+	phys_size_t	mem_size;
 
 	mem_start = env_get_bootm_low();
 	mem_size = env_get_bootm_size();
-
 	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
-
+#endif
 	arch_lmb_reserve(&images->lmb);
 	board_lmb_reserve(&images->lmb);
 }
@@ -79,7 +100,7 @@ static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc,
 	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");
 	images.state = BOOTM_STATE_START;
 
-	return 0;
+	return bootm_board_start();
 }
 
 static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,
@@ -155,7 +176,7 @@ static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
 	case IMAGE_FORMAT_ANDROID:
 		images.os.type = IH_TYPE_KERNEL;
-		images.os.comp = IH_COMP_NONE;
+		images.os.comp = android_image_get_comp(os_hdr);
 		images.os.os = IH_OS_LINUX;
 
 		images.os.end = android_image_get_end(os_hdr);
@@ -244,8 +265,11 @@ int bootm_find_images(int flag, int argc, char * const argv[])
 		puts("Could not find a valid device tree\n");
 		return 1;
 	}
+#ifdef CONFIG_CMD_FDT
 	set_working_fdt_addr((ulong)images.ft_addr);
 #endif
+	lmb_reserve(&images.lmb, (ulong)images.ft_addr, (ulong)images.ft_len);
+#endif
 
 #if IMAGE_ENABLE_FIT
 #if defined(CONFIG_FPGA) && defined(CONFIG_FPGA_XILINX)
@@ -291,14 +315,26 @@ static int bootm_find_other(cmd_tbl_t *cmdtp, int flag, int argc,
  * @comp_type:	Compression type being used (IH_COMP_...)
  * @is_xip:	true if the load address matches the image start
  */
-static void print_decomp_msg(int comp_type, int type, bool is_xip)
+static void print_decomp_msg(int comp_type, int type, bool is_xip,
+			     ulong src, ulong dst)
 {
 	const char *name = genimg_get_type_name(type);
+	const char *comp_name[] = {
+		[IH_COMP_NONE]  = "",
+		[IH_COMP_GZIP]  = "GZIP",
+		[IH_COMP_BZIP2] = "BZIP2",
+		[IH_COMP_LZMA]  = "LZMA",
+		[IH_COMP_LZO]   = "LZO",
+		[IH_COMP_LZ4]   = "LZ4",
+		[IH_COMP_ZIMAGE]= "ZIMAGE",
+	};
 
 	if (comp_type == IH_COMP_NONE)
-		printf("   %s %s ... ", is_xip ? "XIP" : "Loading", name);
+		printf("   %s %s from 0x%08lx to 0x%08lx ... ",
+		       is_xip ? "XIP" : "Loading", name, src, dst);
 	else
-		printf("   Uncompressing %s ... ", name);
+		printf("   Uncompressing %s %s from 0x%08lx to 0x%08lx ... ",
+		       comp_name[comp_type], name, src, dst);
 }
 
 /**
@@ -320,7 +356,8 @@ static int handle_decomp_error(int comp_type, size_t uncomp_size,
 	const char *name = genimg_get_comp_name(comp_type);
 
 	if (uncomp_size >= unc_len)
-		printf("Image too large: increase CONFIG_SYS_BOOTM_LEN\n");
+		printf("Image too large(0x%lx >= 0x%lx): increase CONFIG_SYS_BOOTM_LEN\n",
+		       (ulong)uncomp_size, (ulong)unc_len);
 	else
 		printf("%s: uncompress error %d\n", name, ret);
 
@@ -337,6 +374,38 @@ static int handle_decomp_error(int comp_type, size_t uncomp_size,
 	return BOOTM_ERR_RESET;
 }
 
+int bootm_parse_comp(const unsigned char *hdr)
+{
+#if defined(CONFIG_CMD_BOOTZ)
+	ulong start, end;
+
+	if (!bootz_setup((ulong)hdr, &start, &end))
+		return IH_COMP_ZIMAGE;
+#endif
+#if defined(CONFIG_LZ4)
+	if (lz4_is_valid_header(hdr))
+		return IH_COMP_LZ4;
+#endif
+#if defined(CONFIG_LZO)
+	if (lzop_is_valid_header(hdr))
+		return IH_COMP_LZO;
+#endif
+#if defined(CONFIG_GZIP)
+	if (gzip_parse_header(hdr, 0xffff) > 0)
+		return IH_COMP_GZIP;
+#endif
+#if defined(CONFIG_BZIP2)
+	if ((hdr[0] == 'B') && (hdr[1] == 'Z') && (hdr[2] == 'h'))
+		return IH_COMP_BZIP2;
+#endif
+#if defined(CONFIG_LZMA)
+	if (lzma_is_valid(hdr))
+		return IH_COMP_LZMA;
+#endif
+
+	return IH_COMP_NONE;
+}
+
 int bootm_decomp_image(int comp, ulong load, ulong image_start, int type,
 		       void *load_buf, void *image_buf, ulong image_len,
 		       uint unc_len, ulong *load_end)
@@ -344,7 +413,8 @@ int bootm_decomp_image(int comp, ulong load, ulong image_start, int type,
 	int ret = 0;
 
 	*load_end = load;
-	print_decomp_msg(comp, type, load == image_start);
+	print_decomp_msg(comp, type, load == image_start,
+		(ulong)image_buf, (ulong)load_buf);
 
 	/*
 	 * Load the image to the right place, decompressing if needed. After
@@ -419,7 +489,10 @@ int bootm_decomp_image(int comp, ulong load, ulong image_start, int type,
 		return handle_decomp_error(comp, image_len, unc_len, ret);
 	*load_end = load + image_len;
 
-	puts("OK\n");
+	if (comp == IH_COMP_NONE || comp == IH_COMP_ZIMAGE)
+		puts("OK\n");
+	else
+		printf("with %08lx bytes OK\n", image_len);
 
 	return 0;
 }
@@ -449,16 +522,16 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 	}
 	flush_cache(load, ALIGN(*load_end - load, ARCH_DMA_MINALIGN));
 
-	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
+	printf("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
 	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);
 
 	no_overlap = (os.comp == IH_COMP_NONE && load == image_start);
 
 	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
-		debug("images.os.start = 0x%lX, images.os.end = 0x%lx\n",
-		      blob_start, blob_end);
-		debug("images.os.load = 0x%lx, load_end = 0x%lx\n", load,
-		      *load_end);
+		printf("images.os.start = 0x%lX, images.os.end = 0x%lx\n",
+		       blob_start, blob_end);
+		printf("images.os.load = 0x%lx, load_end = 0x%lx\n", load,
+		       *load_end);
 
 		/* Check what type of image this is. */
 		if (images->legacy_hdr_valid) {
@@ -473,6 +546,9 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 		}
 	}
 
+	/* update image len as decompressed kernel size for late use */
+	images->os.image_len = *load_end - load;
+
 	return 0;
 }
 
@@ -486,6 +562,13 @@ ulong bootm_disable_interrupts(void)
 {
 	ulong iflag;
 
+	/*
+	 * Do not go further if usb is boot device,
+	 * We may access usb at late sequence.
+	 */
+	if (!strcmp(env_get("devtype"), "usb"))
+		return 0;
+
 	/*
 	 * We have reached the point of no return: we are going to
 	 * overwrite all exception vector code, so we cannot easily
@@ -606,6 +689,11 @@ int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 	boot_os_fn *boot_fn;
 	ulong iflag = 0;
 	int ret = 0, need_boot_fn;
+	u32 unmask;
+
+	unmask = env_get_ulong("bootm_states_unmask", 16, 0);
+	if (unmask)
+		states &= ~unmask;
 
 	images->state |= states;
 
@@ -637,6 +725,12 @@ int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 			ret = 0;
 	}
 
+	/* Resever memory before any lmb_alloc, as early as possible */
+#if IMAGE_ENABLE_OF_LIBFDT && defined(CONFIG_LMB)
+	if (!ret && ((states & BOOTM_STATE_RAMDISK) ||
+	    (states & BOOTM_STATE_FDT)))
+		boot_fdt_add_mem_rsv_regions(&images->lmb, images->ft_addr);
+#endif
 	/* Relocate the ramdisk */
 #ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
 	if (!ret && (states & BOOTM_STATE_RAMDISK)) {
@@ -652,7 +746,6 @@ int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 #endif
 #if IMAGE_ENABLE_OF_LIBFDT && defined(CONFIG_LMB)
 	if (!ret && (states & BOOTM_STATE_FDT)) {
-		boot_fdt_add_mem_rsv_regions(&images->lmb, images->ft_addr);
 		ret = boot_relocate_fdt(&images->lmb, &images->ft_addr,
 					&images->ft_len);
 	}
@@ -685,6 +778,8 @@ int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 		if (images->os.os == IH_OS_LINUX)
 			fixup_silent_linux();
 #endif
+		arch_preboot_os(BOOTM_STATE_OS_PREP, images);
+
 		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);
 	}
 
@@ -810,9 +905,6 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 
 	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);
 
-	/* copy from dataflash if needed */
-	img_addr = genimg_get_image(img_addr);
-
 	/* check image type, for FIT images get FIT kernel node */
 	*os_data = *os_len = 0;
 	buf = map_sysmem(img_addr, 0);
@@ -841,8 +933,9 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 			*os_len = image_get_data_size(hdr);
 			break;
 		default:
-			printf("Wrong Image Type for %s command\n",
-			       cmdtp->name);
+			if (cmdtp)
+				printf("Wrong Image Type for %s command\n",
+				       cmdtp->name);
 			bootstage_error(BOOTSTAGE_ID_CHECK_IMAGETYPE);
 			return NULL;
 		}
@@ -886,7 +979,9 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 		break;
 #endif
 	default:
-		printf("Wrong Image Format for %s command\n", cmdtp->name);
+		if (cmdtp)
+			printf("Wrong Image Format for %s command\n",
+			       cmdtp->name);
 		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
 		return NULL;
 	}
@@ -903,7 +998,7 @@ void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
 	memmove(to, from, len);
 }
 
-static int bootm_host_load_image(const void *fit, int req_image_type)
+static int bootm_host_load_image(const void *fit, int req_image_type, int index)
 {
 	const char *fit_uname_config = NULL;
 	ulong data, len;
@@ -917,9 +1012,9 @@ static int bootm_host_load_image(const void *fit, int req_image_type)
 
 	memset(&images, '\0', sizeof(images));
 	images.verify = 1;
-	noffset = fit_image_load(&images, (ulong)fit,
+	noffset = fit_image_load_index(&images, (ulong)fit,
 		NULL, &fit_uname_config,
-		IH_ARCH_DEFAULT, req_image_type, -1,
+		IH_ARCH_DEFAULT, req_image_type, index, -1,
 		FIT_LOAD_IGNORED, &data, &len);
 	if (noffset < 0)
 		return noffset;
@@ -946,20 +1041,50 @@ static int bootm_host_load_image(const void *fit, int req_image_type)
 	return 0;
 }
 
-int bootm_host_load_images(const void *fit, int cfg_noffset)
+int bootm_host_load_images(const void *fit, int cfg_noffset, int is_spl)
 {
 	static uint8_t image_types[] = {
 		IH_TYPE_KERNEL,
 		IH_TYPE_FLATDT,
 		IH_TYPE_RAMDISK,
 	};
+#ifdef CONFIG_SPL_ATF
+	static uint8_t image_types_spl[] = {
+		IH_TYPE_FLATDT,
+		IH_TYPE_FIRMWARE,
+		IH_TYPE_LOADABLE,
+		IH_TYPE_LOADABLE,
+		IH_TYPE_LOADABLE,
+	};
+#else
+	static uint8_t image_types_spl[] = {
+		IH_TYPE_FLATDT,
+		IH_TYPE_FIRMWARE,
+		IH_TYPE_LOADABLE,
+	};
+#endif
+	int loadable_index = 0;
 	int err = 0;
+	int index;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(image_types); i++) {
+	for (i = 0; !is_spl && i < ARRAY_SIZE(image_types); i++) {
 		int ret;
 
-		ret = bootm_host_load_image(fit, image_types[i]);
+		ret = bootm_host_load_image(fit, image_types[i], 0);
+		if (!err && ret && ret != -ENOENT)
+			err = ret;
+	}
+
+	for (i = 0; is_spl && i < ARRAY_SIZE(image_types_spl); i++) {
+		int ret;
+
+		if (image_types_spl[i] == IH_TYPE_LOADABLE)
+			index = loadable_index++;
+		else
+			index = 0;
+
+		ret = bootm_host_load_image(fit, image_types_spl[i], index);
 		if (!err && ret && ret != -ENOENT)
 			err = ret;
 	}
diff --git a/common/bootm_os.c b/common/bootm_os.c
index 31b1878dc4..3af6fdd198 100644
--- a/common/bootm_os.c
+++ b/common/bootm_os.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <bootm.h>
 #include <fdt_support.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <vxworks.h>
 
@@ -469,7 +469,7 @@ static boot_os_fn *boot_os[] = {
 };
 
 /* Allow for arch specific config before we boot */
-__weak void arch_preboot_os(void)
+__weak void arch_preboot_os(uint32_t bootm_state, bootm_headers_t *images)
 {
 	/* please define platform specific arch_preboot_os() */
 }
@@ -477,7 +477,7 @@ __weak void arch_preboot_os(void)
 int boot_selected_os(int argc, char * const argv[], int state,
 		     bootm_headers_t *images, boot_os_fn *boot_fn)
 {
-	arch_preboot_os();
+	arch_preboot_os(state, images);
 	boot_fn(state, argc, argv, images);
 
 	/* Stand-alone may return when 'autostart' is 'no' */
diff --git a/common/bootstage.c b/common/bootstage.c
index 61479d7f07..bef293ce4f 100644
--- a/common/bootstage.c
+++ b/common/bootstage.c
@@ -11,7 +11,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <linux/compiler.h>
 
diff --git a/common/cli.c b/common/cli.c
index 57874d8797..d4074a7ef8 100644
--- a/common/cli.c
+++ b/common/cli.c
@@ -18,7 +18,11 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#ifdef CONFIG_CMDLINE
+__weak int board_run_command(const char *cmdline)
+{
+	return cli_simple_run_command_list((char *)cmdline, 0);
+}
+
 /*
  * Run a command using the selected parser.
  *
@@ -69,7 +73,6 @@ int run_command_repeatable(const char *cmd, int flag)
 	return 0;
 #endif
 }
-#endif /* CONFIG_CMDLINE */
 
 int run_command_list(const char *cmd, int len, int flag)
 {
@@ -212,6 +215,7 @@ err:
 }
 #endif /* CONFIG_IS_ENABLED(OF_CONTROL) */
 
+#ifndef CONFIG_CONSOLE_DISABLE_CLI
 void cli_loop(void)
 {
 #ifdef CONFIG_HUSH_PARSER
@@ -224,6 +228,9 @@ void cli_loop(void)
 	printf("## U-Boot command line is disabled. Please enable CONFIG_CMDLINE\n");
 #endif /*CONFIG_HUSH_PARSER*/
 }
+#else
+void cli_loop(void) { }
+#endif
 
 void cli_init(void)
 {
diff --git a/common/command.c b/common/command.c
index e5d9b9cf95..7171557265 100644
--- a/common/command.c
+++ b/common/command.c
@@ -85,7 +85,6 @@ int _do_help(cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t *cmdtp, int flag,
 /* find command table entry for a command */
 cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
 {
-#ifdef CONFIG_CMDLINE
 	cmd_tbl_t *cmdtp;
 	cmd_tbl_t *cmdtp_temp = table;	/* Init value */
 	const char *p;
@@ -112,7 +111,6 @@ cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
 	if (n_found == 1) {			/* exactly one match */
 		return cmdtp_temp;
 	}
-#endif /* CONFIG_CMDLINE */
 
 	return NULL;	/* not found or ambiguous command */
 }
diff --git a/common/common_fit.c b/common/common_fit.c
index 5f5f3f9a44..3fef74084c 100644
--- a/common/common_fit.c
+++ b/common/common_fit.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <errno.h>
 #include <image.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <spl.h>
 
 ulong fdt_getprop_u32(const void *fdt, int node, const char *prop)
@@ -32,6 +32,9 @@ int fit_find_config_node(const void *fdt)
 {
 	const char *name;
 	int conf, node, len;
+	const char *dflt_conf_name;
+	const char *dflt_conf_desc = NULL;
+	int dflt_conf_node = -ENOENT;
 
 	conf = fdt_path_offset(fdt, FIT_CONFS_PATH);
 	if (conf < 0) {
@@ -39,6 +42,9 @@ int fit_find_config_node(const void *fdt)
 		      conf);
 		return -EINVAL;
 	}
+
+	dflt_conf_name = fdt_getprop(fdt, conf, "default", &len);
+
 	for (node = fdt_first_subnode(fdt, conf);
 	     node >= 0;
 	     node = fdt_next_subnode(fdt, node)) {
@@ -50,6 +56,15 @@ int fit_find_config_node(const void *fdt)
 #endif
 			return -EINVAL;
 		}
+
+		if (dflt_conf_name) {
+			const char *node_name = fdt_get_name(fdt, node, NULL);
+			if (strcmp(dflt_conf_name, node_name) == 0) {
+				dflt_conf_node = node;
+				dflt_conf_desc = name;
+			}
+		}
+
 		if (board_fit_config_name_match(name))
 			continue;
 
@@ -58,5 +73,10 @@ int fit_find_config_node(const void *fdt)
 		return node;
 	}
 
+	if (dflt_conf_node != -ENOENT) {
+		debug("Selecting default config '%s'", dflt_conf_desc);
+		return dflt_conf_node;
+	}
+
 	return -ENOENT;
 }
diff --git a/common/console.c b/common/console.c
index f83528ca60..4c25ae0fd0 100644
--- a/common/console.c
+++ b/common/console.c
@@ -19,6 +19,7 @@
 #include <exports.h>
 #include <environment.h>
 #include <watchdog.h>
+#include <vsprintf.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -255,6 +256,18 @@ static inline void console_doenv(int file, struct stdio_dev *dev)
 {
 	iomux_doenv(file, dev->name);
 }
+
+static void console_clear(int file)
+{
+	int i;
+	struct stdio_dev *dev;
+
+	for (i = 0; i < cd_count[file]; i++) {
+		dev = console_devices[file][i];
+		if (dev->clear != NULL)
+			dev->clear(dev);
+	}
+}
 #else
 static inline int console_getc(int file)
 {
@@ -282,6 +295,12 @@ static inline void console_puts(int file, const char *s)
 	stdio_devices[file]->puts(stdio_devices[file], s);
 }
 
+static inline void console_clear(int file)
+{
+	if (stdio_devices[file]->clear)
+		stdio_devices[file]->clear(stdio_devices[file]);
+}
+
 static inline void console_doenv(int file, struct stdio_dev *dev)
 {
 	console_setfile(file, dev);
@@ -360,6 +379,12 @@ void fputs(int file, const char *s)
 		console_puts(file, s);
 }
 
+void fclear(int file)
+{
+	if (file < MAX_FILES)
+		console_clear(file);
+}
+
 int fprintf(int file, const char *fmt, ...)
 {
 	va_list args;
@@ -383,10 +408,8 @@ int fprintf(int file, const char *fmt, ...)
 
 int getc(void)
 {
-#ifdef CONFIG_DISABLE_CONSOLE
-	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
+	if (!gd || gd->flags & GD_FLG_DISABLE_CONSOLE)
 		return 0;
-#endif
 
 	if (!gd->have_console)
 		return 0;
@@ -395,7 +418,7 @@ int getc(void)
 	if (gd->console_in.start) {
 		int ch;
 
-		ch = membuff_getbyte(&gd->console_in);
+		ch = membuff_getbyte((struct membuff *)&gd->console_in);
 		if (ch != -1)
 			return 1;
 	}
@@ -411,16 +434,14 @@ int getc(void)
 
 int tstc(void)
 {
-#ifdef CONFIG_DISABLE_CONSOLE
-	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
+	if (!gd || gd->flags & GD_FLG_DISABLE_CONSOLE)
 		return 0;
-#endif
 
 	if (!gd->have_console)
 		return 0;
 #ifdef CONFIG_CONSOLE_RECORD
 	if (gd->console_in.start) {
-		if (membuff_peekbyte(&gd->console_in) != -1)
+		if (membuff_peekbyte((struct membuff *)&gd->console_in) != -1)
 			return 1;
 	}
 #endif
@@ -433,6 +454,17 @@ int tstc(void)
 	return serial_tstc();
 }
 
+void flushc(void)
+{
+	if (!gd || gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return;
+
+	if (gd->flags & GD_FLG_DEVINIT)
+		fclear(stdout);
+	else
+		serial_clear();
+}
+
 #define PRE_CONSOLE_FLUSHPOINT1_SERIAL			0
 #define PRE_CONSOLE_FLUSHPOINT2_EVERYTHING_BUT_SERIAL	1
 
@@ -482,6 +514,9 @@ static inline void print_pre_console_buffer(int flushpoint) {}
 
 void putc(const char c)
 {
+	if (!gd || gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return;
+
 #ifdef CONFIG_DEBUG_UART
 	/* if we don't have a console yet, use the debug UART */
 	if (!gd || !(gd->flags & GD_FLG_SERIAL_READY)) {
@@ -491,18 +526,13 @@ void putc(const char c)
 #endif
 #ifdef CONFIG_CONSOLE_RECORD
 	if (gd && (gd->flags & GD_FLG_RECORD) && gd->console_out.start)
-		membuff_putbyte(&gd->console_out, c);
+		membuff_putbyte((struct membuff *)&gd->console_out, c);
 #endif
 #ifdef CONFIG_SILENT_CONSOLE
 	if (gd->flags & GD_FLG_SILENT)
 		return;
 #endif
 
-#ifdef CONFIG_DISABLE_CONSOLE
-	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
-		return;
-#endif
-
 	if (!gd->have_console)
 		return pre_console_putc(c);
 
@@ -516,29 +546,72 @@ void putc(const char c)
 	}
 }
 
+#if ((!defined(CONFIG_SPL_BUILD) || !defined(CONFIG_USE_TINY_PRINTF)) && \
+	defined(CONFIG_BOOTSTAGE_PRINTF_TIMESTAMP))
+static void vspfunc(char *buf, size_t size, char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+	vsnprintf(buf, size, format, ap);
+	va_end(ap);
+}
+
+void puts(const char *s)
+{
+	unsigned long ts_sec, ts_msec, ticks;
+	char pr_timestamp[32], *p;
+
+	while (*s) {
+		if (*s == '\n') {
+			gd->new_line = 1;
+			putc(*s++);
+			continue;
+		}
+
+		if (gd->new_line) {
+			gd->new_line = 0;
+			ticks = (get_ticks() / 24ULL);
+			ts_sec = ticks / 1000000;
+			ts_msec = ticks % 1000000;
+			vspfunc(pr_timestamp, sizeof(pr_timestamp),
+				"[%5lu.%06lu] ", ts_sec, ts_msec);
+			p = pr_timestamp;
+			while (*p)
+				putc(*p++);
+		}
+
+		putc(*s++);
+	}
+}
+#else
 void puts(const char *s)
 {
 	while (*s)
 		putc(*s++);
 }
+#endif
+
 
 #ifdef CONFIG_CONSOLE_RECORD
 int console_record_init(void)
 {
 	int ret;
 
-	ret = membuff_new(&gd->console_out, CONFIG_CONSOLE_RECORD_OUT_SIZE);
+	ret = membuff_new((struct membuff *)&gd->console_out,
+			  CONFIG_CONSOLE_RECORD_OUT_SIZE);
 	if (ret)
 		return ret;
-	ret = membuff_new(&gd->console_in, CONFIG_CONSOLE_RECORD_IN_SIZE);
+	ret = membuff_new((struct membuff *)&gd->console_in,
+			  CONFIG_CONSOLE_RECORD_IN_SIZE);
 
 	return ret;
 }
 
 void console_record_reset(void)
 {
-	membuff_purge(&gd->console_out);
-	membuff_purge(&gd->console_in);
+	membuff_purge((struct membuff *)&gd->console_out);
+	membuff_purge((struct membuff *)&gd->console_in);
 }
 
 void console_record_reset_enable(void)
@@ -546,6 +619,28 @@ void console_record_reset_enable(void)
 	console_record_reset();
 	gd->flags |= GD_FLG_RECORD;
 }
+
+/* Print and remove data from buffer */
+void console_record_print_purge(void)
+{
+	unsigned long flags;
+	char c;
+
+	if (!gd || !(gd->flags & GD_FLG_RECORD))
+		return;
+
+	/* Remove some bits to avoid running unexpected branch in putc() */
+	flags = gd->flags;
+	gd->flags &= ~(GD_FLG_RECORD | GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE);
+
+	printf("\n\n## Console Record: \n");
+	while (!membuff_isempty((struct membuff *)&gd->console_out)) {
+		c = membuff_getbyte((struct membuff *)&gd->console_out);
+		putc(c);
+	}
+
+	gd->flags = flags;
+}
 #endif
 
 /* test if ctrl-c was pressed */
@@ -666,10 +761,12 @@ int console_assign(int file, const char *devname)
 static void console_update_silent(void)
 {
 #ifdef CONFIG_SILENT_CONSOLE
-	if (env_get("silent") != NULL)
+	if (env_get("silent") != NULL) {
+		printf("U-Boot: enable silent console\n");
 		gd->flags |= GD_FLG_SILENT;
-	else
+	} else {
 		gd->flags &= ~GD_FLG_SILENT;
+	}
 #endif
 }
 
diff --git a/common/dfu.c b/common/dfu.c
index 546a1ab9b4..30f4dcf827 100644
--- a/common/dfu.c
+++ b/common/dfu.c
@@ -18,21 +18,26 @@
 #include <g_dnl.h>
 #include <usb.h>
 #include <net.h>
+#include <android_avb/rk_avb_ops_user.h>
 
 int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 {
 	bool dfu_reset = false;
 	int ret, i = 0;
+#ifdef CONFIG_ANDROID_AB
+	char select_slot[3] = {0};
+	unsigned int slot_number[2] = {0, 1};
+#endif
 
-	ret = board_usb_init(usbctrl_index, USB_INIT_DEVICE);
+	ret = usb_gadget_initialize(usbctrl_index);
 	if (ret) {
-		error("board usb init failed\n");
+		pr_err("usb_gadget_initialize failed\n");
 		return CMD_RET_FAILURE;
 	}
 	g_dnl_clear_detach();
 	ret = g_dnl_register(usb_dnl_gadget);
 	if (ret) {
-		error("g_dnl_register failed");
+		pr_err("g_dnl_register failed");
 		return CMD_RET_FAILURE;
 	}
 
@@ -45,6 +50,19 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 			 */
 			if (dfu_usb_get_reset()) {
 				dfu_reset = true;
+#ifdef CONFIG_ANDROID_AB
+				if (rk_avb_get_current_slot(select_slot))
+					printf("Obtain current slot failed!\n");
+				/*
+				 * After the firmware is successfully upgrade,
+				 * the device changes the slot priority during
+				 * reboot based on the current slot
+				 */
+				if (strcmp(select_slot, "_a") == 0)
+					rk_avb_set_slot_active(&slot_number[1]);
+				else
+					rk_avb_set_slot_active(&slot_number[0]);
+#endif
 				goto exit;
 			}
 
@@ -75,7 +93,7 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 			ret = dfu_flush(dfu_get_defer_flush(), NULL, 0, 0);
 			dfu_set_defer_flush(NULL);
 			if (ret) {
-				error("Deferred dfu_flush() failed!");
+				pr_err("Deferred dfu_flush() failed!");
 				goto exit;
 			}
 		}
@@ -85,7 +103,7 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 	}
 exit:
 	g_dnl_unregister();
-	board_usb_cleanup(usbctrl_index, USB_INIT_DEVICE);
+	usb_gadget_release(usbctrl_index);
 
 	if (dfu_reset)
 		do_reset(NULL, 0, 0, NULL);
diff --git a/common/dlmalloc.c b/common/dlmalloc.c
index c37979b43f..b395eefbf8 100644
--- a/common/dlmalloc.c
+++ b/common/dlmalloc.c
@@ -149,7 +149,7 @@ gAllocatedSize))
 			{
 				new_address = findRegion (new_address, new_size);
 
-				if (new_address == 0)
+				if (!new_address)
 					return (void*)-1;
 
 				gAddressBase = gNextAddress =
@@ -175,7 +175,7 @@ gAllocatedSize))
 								(size + gNextAddress -
 								 AlignPage (gNextAddress)),
 								MEM_COMMIT, PAGE_READWRITE);
-			if (res == 0)
+			if (!res)
 				return (void*)-1;
 		}
 		tmp = (void*)gNextAddress;
@@ -1461,7 +1461,7 @@ Void_t* mALLOc(bytes) size_t bytes;
 #if HAVE_MMAP
     /* If big and would otherwise need to extend, try to use mmap instead */
     if ((unsigned long)nb >= (unsigned long)mmap_threshold &&
-	(victim = mmap_chunk(nb)) != 0)
+	(victim = mmap_chunk(nb)))
       return chunk2mem(victim);
 #endif
 
@@ -1671,7 +1671,10 @@ Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
   mchunkptr fwd;              /* misc temp for linking */
 
 #ifdef REALLOC_ZERO_BYTES_FREES
-  if (bytes == 0) { fREe(oldmem); return 0; }
+  if (!bytes) {
+	fREe(oldmem);
+	return NULL;
+  }
 #endif
 
   if ((long)bytes < 0) return NULL;
@@ -1703,7 +1706,8 @@ Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
     if(oldsize - SIZE_SZ >= nb) return oldmem; /* do nothing */
     /* Must alloc, copy, free. */
     newmem = mALLOc(bytes);
-    if (newmem == 0) return 0; /* propagate failure */
+    if (!newmem)
+	return NULL; /* propagate failure */
     MALLOC_COPY(newmem, oldmem, oldsize - 2*SIZE_SZ);
     munmap_chunk(oldp);
     return newmem;
diff --git a/common/edid.c b/common/edid.c
index 3d0809ad11..e14997ba83 100644
--- a/common/edid.c
+++ b/common/edid.c
@@ -8,15 +8,1423 @@
  *
  * Contains stolen code from ddcprobe project which is:
  * Copyright (C) Nalin Dahyabhai <bigfun@pobox.com>
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
  */
 
 #include <common.h>
+#include <compiler.h>
+#include <div64.h>
+#include <drm_modes.h>
 #include <edid.h>
 #include <errno.h>
 #include <fdtdec.h>
+#include <hexdump.h>
+#include <malloc.h>
+#include <linux/compat.h>
 #include <linux/ctype.h>
+#include <linux/fb.h>
+#include <linux/hdmi.h>
 #include <linux/string.h>
 
+#define EDID_EST_TIMINGS 16
+#define EDID_STD_TIMINGS 8
+#define EDID_DETAILED_TIMINGS 4
+#define BIT_WORD(nr)             ((nr) / BITS_PER_LONG)
+#define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) & (BITS_PER_LONG - 1)))
+#define BITMAP_LAST_WORD_MASK(nbits) (~0UL >> (-(nbits) & (BITS_PER_LONG - 1)))
+#define EDID_PRODUCT_ID(e) ((e)->prod_code[0] | ((e)->prod_code[1] << 8))
+#define version_greater(edid, maj, min) \
+	(((edid)->version > (maj)) || \
+	 ((edid)->version == (maj) && (edid)->revision > (min)))
+
+/*
+ * EDID blocks out in the wild have a variety of bugs, try to collect
+ * them here (note that userspace may work around broken monitors first,
+ * but fixes should make their way here so that the kernel "just works"
+ * on as many displays as possible).
+ */
+
+/* First detailed mode wrong, use largest 60Hz mode */
+#define EDID_QUIRK_PREFER_LARGE_60		BIT(0)
+/* Reported 135MHz pixel clock is too high, needs adjustment */
+#define EDID_QUIRK_135_CLOCK_TOO_HIGH		BIT(1)
+/* Prefer the largest mode at 75 Hz */
+#define EDID_QUIRK_PREFER_LARGE_75		BIT(2)
+/* Detail timing is in cm not mm */
+#define EDID_QUIRK_DETAILED_IN_CM		BIT(3)
+/* Detailed timing descriptors have bogus size values, so just take the
+ * maximum size and use that.
+ */
+#define EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE	BIT(4)
+/* Monitor forgot to set the first detailed is preferred bit. */
+#define EDID_QUIRK_FIRST_DETAILED_PREFERRED	BIT(5)
+/* use +hsync +vsync for detailed mode */
+#define EDID_QUIRK_DETAILED_SYNC_PP		BIT(6)
+/* Force reduced-blanking timings for detailed modes */
+#define EDID_QUIRK_FORCE_REDUCED_BLANKING	BIT(7)
+/* Force 8bpc */
+#define EDID_QUIRK_FORCE_8BPC			BIT(8)
+/* Force 12bpc */
+#define EDID_QUIRK_FORCE_12BPC			BIT(9)
+/* Force 6bpc */
+#define EDID_QUIRK_FORCE_6BPC			BIT(10)
+/* Force 10bpc */
+#define EDID_QUIRK_FORCE_10BPC			BIT(11)
+
+struct detailed_mode_closure {
+	struct edid *edid;
+	struct hdmi_edid_data *data;
+	bool preferred;
+	u32 quirks;
+	int modes;
+};
+
+#define LEVEL_DMT	0
+#define LEVEL_GTF	1
+#define LEVEL_GTF2	2
+#define LEVEL_CVT	3
+
+static struct edid_quirk {
+	char vendor[4];
+	int product_id;
+	u32 quirks;
+} edid_quirk_list[] = {
+	/* Acer AL1706 */
+	{ "ACR", 44358, EDID_QUIRK_PREFER_LARGE_60 },
+	/* Acer F51 */
+	{ "API", 0x7602, EDID_QUIRK_PREFER_LARGE_60 },
+	/* Unknown Acer */
+	{ "ACR", 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */
+	{ "AEO", 0, EDID_QUIRK_FORCE_6BPC },
+
+	/* Belinea 10 15 55 */
+	{ "MAX", 1516, EDID_QUIRK_PREFER_LARGE_60 },
+	{ "MAX", 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Envision Peripherals, Inc. EN-7100e */
+	{ "EPI", 59264, EDID_QUIRK_135_CLOCK_TOO_HIGH },
+	/* Envision EN2028 */
+	{ "EPI", 8232, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Funai Electronics PM36B */
+	{ "FCM", 13600, EDID_QUIRK_PREFER_LARGE_75 |
+	  EDID_QUIRK_DETAILED_IN_CM },
+
+	/* LGD panel of HP zBook 17 G2, eDP 10 bpc, but reports unknown bpc */
+	{ "LGD", 764, EDID_QUIRK_FORCE_10BPC },
+
+	/* LG Philips LCD LP154W01-A5 */
+	{ "LPL", 0, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
+	{ "LPL", 0x2a00, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
+
+	/* Philips 107p5 CRT */
+	{ "PHL", 57364, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Proview AY765C */
+	{ "PTS", 765, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Samsung SyncMaster 205BW.  Note: irony */
+	{ "SAM", 541, EDID_QUIRK_DETAILED_SYNC_PP },
+	/* Samsung SyncMaster 22[5-6]BW */
+	{ "SAM", 596, EDID_QUIRK_PREFER_LARGE_60 },
+	{ "SAM", 638, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Sony PVM-2541A does up to 12 bpc, but only reports max 8 bpc */
+	{ "SNY", 0x2541, EDID_QUIRK_FORCE_12BPC },
+
+	/* ViewSonic VA2026w */
+	{ "VSC", 5020, EDID_QUIRK_FORCE_REDUCED_BLANKING },
+
+	/* Medion MD 30217 PG */
+	{ "MED", 0x7b8, EDID_QUIRK_PREFER_LARGE_75 },
+
+	/* Panel in Samsung NP700G7A-S01PL notebook reports 6bpc */
+	{ "SEC", 0xd033, EDID_QUIRK_FORCE_8BPC },
+
+	/* Rotel RSX-1058 forwards sink's EDID but only does HDMI 1.1*/
+	{ "ETR", 13896, EDID_QUIRK_FORCE_8BPC },
+};
+
+/*
+ * Probably taken from CEA-861 spec.
+ * This table is converted from xorg's hw/xfree86/modes/xf86EdidModes.c.
+ *
+ * Index using the VIC.
+ */
+static const struct drm_display_mode edid_cea_modes[] = {
+	/* 0 - dummy, VICs start at 1 */
+	{ },
+	/* 1 - 640x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 2 - 720x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 3 - 720x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 4 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 5 - 1920x1080i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 6 - 720(1440)x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 7 - 720(1440)x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 8 - 720(1440)x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 9 - 720(1440)x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 10 - 2880x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 11 - 2880x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 12 - 2880x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 13 - 2880x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 14 - 1440x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,
+		   1596, 1716, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 15 - 1440x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,
+		   1596, 1716, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 16 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 17 - 720x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 18 - 720x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 19 - 1280x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 20 - 1920x1080i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 21 - 720(1440)x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 22 - 720(1440)x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 23 - 720(1440)x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 24 - 720(1440)x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 25 - 2880x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 26 - 2880x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 27 - 2880x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 28 - 2880x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 29 - 1440x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1592, 1728, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 30 - 1440x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1592, 1728, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 31 - 1920x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 32 - 1920x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 33 - 1920x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 34 - 1920x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 35 - 2880x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,
+		   3192, 3432, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 36 - 2880x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,
+		   3192, 3432, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 37 - 2880x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,
+		   3184, 3456, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 38 - 2880x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,
+		   3184, 3456, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 39 - 1920x1080i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 72000, 1920, 1952,
+		   2120, 2304, 1080, 1126, 1136, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 40 - 1920x1080i@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 41 - 1280x720@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 42 - 720x576@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 43 - 720x576@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 44 - 720(1440)x576i@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 45 - 720(1440)x576i@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 46 - 1920x1080i@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 47 - 1280x720@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 48 - 720x480@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 49 - 720x480@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 50 - 720(1440)x480i@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 51 - 720(1440)x480i@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 52 - 720x576@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 53 - 720x576@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 54 - 720(1440)x576i@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 55 - 720(1440)x576i@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 56 - 720x480@240Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 57 - 720x480@240Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 58 - 720(1440)x480i@240 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 59 - 720(1440)x480i@240 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 60 - 1280x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 61 - 1280x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,
+		   3740, 3960, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 62 - 1280x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 63 - 1920x1080@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 64 - 1920x1080@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 65 - 1280x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 66 - 1280x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,
+		   3740, 3960, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 67 - 1280x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 68 - 1280x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 69 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 70 - 1280x720@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 71 - 1280x720@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 72 - 1920x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 73 - 1920x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 74 - 1920x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 75 - 1920x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 76 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 77 - 1920x1080@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 78 - 1920x1080@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 79 - 1680x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1680, 3040,
+		3080, 3300, 720, 725, 730, 750, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 80 - 1680x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1680, 2908,
+		2948, 3168, 720, 725, 730, 750, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 81 - 1680x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1680, 2380,
+		2420, 2640, 720, 725, 730, 750, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 82 - 1680x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 82500, 1680, 1940,
+		1980, 2200, 720, 725, 730, 750, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 83 - 1680x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 99000, 1680, 1940,
+		1980, 2200, 720, 725, 730, 750, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 84 - 1680x720@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 165000, 1680, 1740,
+		1780, 2000, 720, 725, 730, 825, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 85 - 1680x720@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 198000, 1680, 1740,
+		1780, 2000, 720, 725, 730, 825, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 86 - 2560x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 99000, 2560, 3558,
+		3602, 3750, 1080, 1084, 1089, 1100, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 87 - 2560x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 90000, 2560, 3008,
+		3052, 3200, 1080, 1084, 1089, 1125, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 88 - 2560x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 118800, 2560, 3328,
+		3372, 3520, 1080, 1084, 1089, 1125, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 89 - 2560x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 185625, 2560, 3108,
+		3152, 3300, 1080, 1084, 1089, 1125, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 90 - 2560x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 198000, 2560, 2808,
+		2852, 3000, 1080, 1084, 1089, 1100, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 91 - 2560x1080@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 371250, 2560, 2778,
+		2822, 2970, 1080, 1084, 1089, 1250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 92 - 2560x1080@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 495000, 2560, 3108,
+		3152, 3300, 1080, 1084, 1089, 1250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 93 - 3840x2160p@24Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+		5204, 5500, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 94 - 3840x2160p@25Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,
+		4984, 5280, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 95 - 3840x2160p@30Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		4104, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 96 - 3840x2160p@50Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+		4984, 5280, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 97 - 3840x2160p@60Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+		4104, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 98 - 4096x2160p@24Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 5116,
+		5204, 5500, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 99 - 4096x2160p@25Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,
+		5152, 5280, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 100 - 4096x2160p@30Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 4184,
+		4272, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 101 - 4096x2160p@50Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,
+		5152, 5280, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 102 - 4096x2160p@60Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 4184,
+		4272, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 103 - 3840x2160p@24Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+		5204, 5500, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 104 - 3840x2160p@25Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		4104, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 105 - 3840x2160p@30Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		4104, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 106 - 3840x2160p@50Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+		4984, 5280, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 107 - 3840x2160p@60Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+		4104, 4400, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+};
+
+/*
+ * HDMI 1.4 4k modes. Index using the VIC.
+ */
+static const struct drm_display_mode edid_4k_modes[] = {
+	/* 0 - dummy, VICs start at 1 */
+	{ },
+	/* 1 - 3840x2160@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   3840, 4016, 4104, 4400,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, },
+	/* 2 - 3840x2160@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   3840, 4896, 4984, 5280,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, },
+	/* 3 - 3840x2160@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   3840, 5116, 5204, 5500,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, },
+	/* 4 - 4096x2160@24Hz (SMPTE) */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   4096, 5116, 5204, 5500,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, },
+};
+
+/*
+ * Autogenerated from the DMT spec.
+ * This table is copied from xfree86/modes/xf86EdidModes.c.
+ */
+static const struct drm_display_mode drm_dmt_modes[] = {
+	/* 0x01 - 640x350@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 672,
+		   736, 832, 350, 382, 385, 445, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x02 - 640x400@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 672,
+		   736, 832, 400, 401, 404, 445, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x03 - 720x400@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 35500, 720, 756,
+		   828, 936, 400, 401, 404, 446, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x04 - 640x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x05 - 640x480@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 664,
+		   704, 832, 480, 489, 492, 520, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x06 - 640x480@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 656,
+		   720, 840, 480, 481, 484, 500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x07 - 640x480@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 36000, 640, 696,
+		   752, 832, 480, 481, 484, 509, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x08 - 800x600@56Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 36000, 800, 824,
+		   896, 1024, 600, 601, 603, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x09 - 800x600@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 40000, 800, 840,
+		   968, 1056, 600, 601, 605, 628, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0a - 800x600@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 50000, 800, 856,
+		   976, 1040, 600, 637, 643, 666, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0b - 800x600@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 49500, 800, 816,
+		   896, 1056, 600, 601, 604, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0c - 800x600@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 56250, 800, 832,
+		   896, 1048, 600, 601, 604, 631, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0d - 800x600@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 73250, 800, 848,
+		   880, 960, 600, 603, 607, 636, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x0e - 848x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 33750, 848, 864,
+		   976, 1088, 480, 486, 494, 517, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0f - 1024x768@43Hz, interlace */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,
+		   1208, 1264, 768, 768, 772, 817, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE) },
+	/* 0x10 - 1024x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x11 - 1024x768@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,
+		   1184, 1328, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x12 - 1024x768@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,
+		   1136, 1312, 768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x13 - 1024x768@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 94500, 1024, 1072,
+		   1168, 1376, 768, 769, 772, 808, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x14 - 1024x768@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 115500, 1024, 1072,
+		   1104, 1184, 768, 771, 775, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x15 - 1152x864@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,
+		   1344, 1600, 864, 865, 868, 900, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x55 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x16 - 1280x768@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 68250, 1280, 1328,
+		   1360, 1440, 768, 771, 778, 790, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x17 - 1280x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 79500, 1280, 1344,
+		   1472, 1664, 768, 771, 778, 798, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x18 - 1280x768@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 102250, 1280, 1360,
+		   1488, 1696, 768, 771, 778, 805, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x19 - 1280x768@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 117500, 1280, 1360,
+		   1496, 1712, 768, 771, 778, 809, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1a - 1280x768@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 140250, 1280, 1328,
+		   1360, 1440, 768, 771, 778, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x1b - 1280x800@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 71000, 1280, 1328,
+		   1360, 1440, 800, 803, 809, 823, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x1c - 1280x800@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 83500, 1280, 1352,
+		   1480, 1680, 800, 803, 809, 831, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1d - 1280x800@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 106500, 1280, 1360,
+		   1488, 1696, 800, 803, 809, 838, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1e - 1280x800@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 122500, 1280, 1360,
+		   1496, 1712, 800, 803, 809, 843, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1f - 1280x800@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 146250, 1280, 1328,
+		   1360, 1440, 800, 803, 809, 847, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x20 - 1280x960@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1280, 1376,
+		   1488, 1800, 960, 961, 964, 1000, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x21 - 1280x960@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1344,
+		   1504, 1728, 960, 961, 964, 1011, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x22 - 1280x960@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 175500, 1280, 1328,
+		   1360, 1440, 960, 963, 967, 1017, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x23 - 1280x1024@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1280, 1328,
+		   1440, 1688, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x24 - 1280x1024@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,
+		   1440, 1688, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x25 - 1280x1024@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 157500, 1280, 1344,
+		   1504, 1728, 1024, 1025, 1028, 1072, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x26 - 1280x1024@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 187250, 1280, 1328,
+		   1360, 1440, 1024, 1027, 1034, 1084, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x27 - 1360x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 85500, 1360, 1424,
+		   1536, 1792, 768, 771, 777, 795, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x28 - 1360x768@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148250, 1360, 1408,
+		   1440, 1520, 768, 771, 776, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x51 - 1366x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 85500, 1366, 1436,
+		   1579, 1792, 768, 771, 774, 798, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x56 - 1366x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 72000, 1366, 1380,
+		   1436, 1500, 768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x29 - 1400x1050@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 101000, 1400, 1448,
+		   1480, 1560, 1050, 1053, 1057, 1080, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x2a - 1400x1050@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 121750, 1400, 1488,
+		   1632, 1864, 1050, 1053, 1057, 1089, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x2b - 1400x1050@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 156000, 1400, 1504,
+		   1648, 1896, 1050, 1053, 1057, 1099, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x2c - 1400x1050@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 179500, 1400, 1504,
+		   1656, 1912, 1050, 1053, 1057, 1105, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x2d - 1400x1050@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 208000, 1400, 1448,
+		   1480, 1560, 1050, 1053, 1057, 1112, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x2e - 1440x900@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 88750, 1440, 1488,
+		   1520, 1600, 900, 903, 909, 926, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x2f - 1440x900@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 106500, 1440, 1520,
+		   1672, 1904, 900, 903, 909, 934, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x30 - 1440x900@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 136750, 1440, 1536,
+		   1688, 1936, 900, 903, 909, 942, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x31 - 1440x900@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 157000, 1440, 1544,
+		   1696, 1952, 900, 903, 909, 948, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x32 - 1440x900@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 182750, 1440, 1488,
+		   1520, 1600, 900, 903, 909, 953, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x53 - 1600x900@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1600, 1624,
+		   1704, 1800, 900, 901, 904, 1000, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x33 - 1600x1200@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 162000, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x34 - 1600x1200@65Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 175500, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x35 - 1600x1200@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 189000, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x36 - 1600x1200@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 202500, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x37 - 1600x1200@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 229500, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x38 - 1600x1200@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 268250, 1600, 1648,
+		   1680, 1760, 1200, 1203, 1207, 1271, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x39 - 1680x1050@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 119000, 1680, 1728,
+		   1760, 1840, 1050, 1053, 1059, 1080, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x3a - 1680x1050@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 146250, 1680, 1784,
+		   1960, 2240, 1050, 1053, 1059, 1089, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3b - 1680x1050@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 187000, 1680, 1800,
+		   1976, 2272, 1050, 1053, 1059, 1099, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3c - 1680x1050@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 214750, 1680, 1808,
+		   1984, 2288, 1050, 1053, 1059, 1105, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3d - 1680x1050@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 245500, 1680, 1728,
+		   1760, 1840, 1050, 1053, 1059, 1112, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x3e - 1792x1344@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 204750, 1792, 1920,
+		   2120, 2448, 1344, 1345, 1348, 1394, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3f - 1792x1344@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 261000, 1792, 1888,
+		   2104, 2456, 1344, 1345, 1348, 1417, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x40 - 1792x1344@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 333250, 1792, 1840,
+		   1872, 1952, 1344, 1347, 1351, 1423, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x41 - 1856x1392@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 218250, 1856, 1952,
+		   2176, 2528, 1392, 1393, 1396, 1439, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x42 - 1856x1392@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 288000, 1856, 1984,
+		   2208, 2560, 1392, 1393, 1396, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x43 - 1856x1392@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 356500, 1856, 1904,
+		   1936, 2016, 1392, 1395, 1399, 1474, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x52 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x44 - 1920x1200@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 154000, 1920, 1968,
+		   2000, 2080, 1200, 1203, 1209, 1235, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x45 - 1920x1200@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 193250, 1920, 2056,
+		   2256, 2592, 1200, 1203, 1209, 1245, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x46 - 1920x1200@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 245250, 1920, 2056,
+		   2264, 2608, 1200, 1203, 1209, 1255, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x47 - 1920x1200@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 281250, 1920, 2064,
+		   2272, 2624, 1200, 1203, 1209, 1262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x48 - 1920x1200@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 317000, 1920, 1968,
+		   2000, 2080, 1200, 1203, 1209, 1271, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x49 - 1920x1440@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 234000, 1920, 2048,
+		   2256, 2600, 1440, 1441, 1444, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4a - 1920x1440@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2064,
+		   2288, 2640, 1440, 1441, 1444, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4b - 1920x1440@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 380500, 1920, 1968,
+		   2000, 2080, 1440, 1443, 1447, 1525, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x54 - 2048x1152@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 162000, 2048, 2074,
+		   2154, 2250, 1152, 1153, 1156, 1200, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4c - 2560x1600@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 268500, 2560, 2608,
+		   2640, 2720, 1600, 1603, 1609, 1646, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x4d - 2560x1600@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 348500, 2560, 2752,
+		   3032, 3504, 1600, 1603, 1609, 1658, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4e - 2560x1600@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 443250, 2560, 2768,
+		   3048, 3536, 1600, 1603, 1609, 1672, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4f - 2560x1600@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 505250, 2560, 2768,
+		   3048, 3536, 1600, 1603, 1609, 1682, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x50 - 2560x1600@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 552750, 2560, 2608,
+		   2640, 2720, 1600, 1603, 1609, 1694, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x57 - 4096x2160@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 556744, 4096, 4104,
+		   4136, 4176, 2160, 2208, 2216, 2222, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x58 - 4096x2160@59.94Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 556188, 4096, 4104,
+		   4136, 4176, 2160, 2208, 2216, 2222, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+};
+
+/*
+ * These more or less come from the DMT spec.  The 720x400 modes are
+ * inferred from historical 80x25 practice.  The 640x480@67 and 832x624@75
+ * modes are old-school Mac modes.  The EDID spec says the 1152x864@75 mode
+ * should be 1152x870, again for the Mac, but instead we use the x864 DMT
+ * mode.
+ *
+ * The DMT modes have been fact-checked; the rest are mild guesses.
+ */
+static const struct drm_display_mode edid_est_modes[] = {
+	/* 800x600@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 40000, 800, 840,
+		   968, 1056, 600, 601, 605, 628, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@56Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 36000, 800, 824,
+		   896, 1024, 600, 601, 603,  625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 640x480@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 656,
+		   720, 840, 480, 481, 484, 500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 664,
+		   704,  832, 480, 489, 492, 520, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@67Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 30240, 640, 704,
+		   768,  864, 480, 483, 486, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 720x400@88Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 35500, 720, 738,
+		   846, 900, 400, 421, 423,  449, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 720x400@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 28320, 720, 738,
+		   846,  900, 400, 412, 414, 449, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x1024@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,
+		   1440, 1688, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,
+		   1136, 1312,  768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,
+		   1184, 1328, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@43Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,
+		   1208, 1264, 768, 768, 776, 817, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE) },
+	/* 832x624@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 57284, 832, 864,
+		   928, 1152, 624, 625, 628, 667, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 800x600@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 49500, 800, 816,
+		   896, 1056, 600, 601, 604,  625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 50000, 800, 856,
+		   976, 1040, 600, 637, 643, 666, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1152x864@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,
+		   1344, 1600, 864, 865, 868, 900, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+};
+
+#define DRM_BASE_MODE(c, hd, hss, hse, ht, vd, vss, vse, vt, vs, f) \
+	.clock = (c), \
+	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
+	.htotal = (ht), .vdisplay = (vd), \
+	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
+	.vscan = (vs), .flags = (f)
+
+static const struct base_drm_display_mode resolution_white[] = {
+	/* 0. vic:2 - 720x480@60Hz */
+	{ DRM_BASE_MODE(27000, 720, 736,
+			798, 858, 480, 489, 495, 525, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 1. vic:3 - 720x480@60Hz */
+	{ DRM_BASE_MODE(27000, 720, 736,
+			798, 858, 480, 489, 495, 525, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 1024x768@60Hz */
+	{ DRM_BASE_MODE(65000, 1024, 1048,
+			1184, 1344, 768, 771, 777, 806, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 2. vic:4 - 1280x720@60Hz */
+	{ DRM_BASE_MODE(74250, 1280, 1390,
+			1430, 1650, 720, 725, 730, 750, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 3. vic:5 - 1920x1080i@60Hz */
+	{ DRM_BASE_MODE(74250, 1920, 2008,
+			2052, 2200, 1080, 1084, 1094, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 4. vic:6 - 720(1440)x480i@60Hz */
+	{ DRM_BASE_MODE(13500, 720, 739,
+			801, 858, 480, 488, 494, 525, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 5. vic:16 - 1920x1080@60Hz */
+	{ DRM_BASE_MODE(148500, 1920, 2008,
+			2052, 2200, 1080, 1084, 1089, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 6. vic:17 - 720x576@50Hz */
+	{ DRM_BASE_MODE(27000, 720, 732,
+			796, 864, 576, 581, 586, 625, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 7. vic:18 - 720x576@50Hz */
+	{ DRM_BASE_MODE(27000, 720, 732,
+			796, 864, 576, 581, 586, 625, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 8. vic:19 - 1280x720@50Hz */
+	{ DRM_BASE_MODE(74250, 1280, 1720,
+			1760, 1980, 720, 725, 730, 750, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 9. vic:20 - 1920x1080i@50Hz */
+	{ DRM_BASE_MODE(74250, 1920, 2448,
+			2492, 2640, 1080, 1084, 1094, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 10. vic:21 - 720(1440)x576i@50Hz */
+	{ DRM_BASE_MODE(13500, 720, 732,
+			795, 864, 576, 580, 586, 625, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 11. vic:31 - 1920x1080@50Hz */
+	{ DRM_BASE_MODE(148500, 1920, 2448,
+			2492, 2640, 1080, 1084, 1089, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 12. vic:32 - 1920x1080@24Hz */
+	{ DRM_BASE_MODE(74250, 1920, 2558,
+			2602, 2750, 1080, 1084, 1089, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 13. vic:33 - 1920x1080@25Hz */
+	{ DRM_BASE_MODE(74250, 1920, 2448,
+			2492, 2640, 1080, 1084, 1089, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 14. vic:34 - 1920x1080@30Hz */
+	{ DRM_BASE_MODE(74250, 1920, 2008,
+			2052, 2200, 1080, 1084, 1089, 1125, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 15. vic:39 - 1920x1080i@50Hz */
+	{ DRM_BASE_MODE(72000, 1920, 1952,
+			2120, 2304, 1080, 1126, 1136, 1250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 16. vic:60 - 1280x720@24Hz */
+	{ DRM_BASE_MODE(59400, 1280, 3040,
+			3080, 3300, 720, 725, 730, 750, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 17. vic:61 - 1280x720@25Hz */
+	{ DRM_BASE_MODE(74250, 1280, 3700,
+			3740, 3960, 720, 725, 730, 750, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 18. vic:62 - 1280x720@30Hz */
+	{ DRM_BASE_MODE(74250, 1280, 3040,
+			3080, 3300, 720, 725, 730, 750, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 19. vic:93 - 3840x2160p@24Hz 16:9 */
+	{ DRM_BASE_MODE(297000, 3840, 5116,
+			5204, 5500, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 20. vic:94 - 3840x2160p@25Hz 16:9 */
+	{ DRM_BASE_MODE(297000, 3840, 4896,
+			4984, 5280, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 21. vic:95 - 3840x2160p@30Hz 16:9 */
+	{ DRM_BASE_MODE(297000, 3840, 4016,
+			4104, 4400, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 22. vic:96 - 3840x2160p@50Hz 16:9 */
+	{ DRM_BASE_MODE(594000, 3840, 4896,
+			4984, 5280, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 23. vic:97 - 3840x2160p@60Hz 16:9 */
+	{ DRM_BASE_MODE(594000, 3840, 4016,
+			4104, 4400, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 24. vic:98 - 4096x2160p@24Hz 256:135 */
+	{ DRM_BASE_MODE(297000, 4096, 5116,
+			5204, 5500, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 25. vic:99 - 4096x2160p@25Hz 256:135 */
+	{ DRM_BASE_MODE(297000, 4096, 5064,
+			5152, 5280, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 26. vic:100 - 4096x2160p@30Hz 256:135 */
+	{ DRM_BASE_MODE(297000, 4096, 4184,
+			4272, 4400, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 27. vic:101 - 4096x2160p@50Hz 256:135 */
+	{ DRM_BASE_MODE(594000, 4096, 5064,
+			5152, 5280, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 28. vic:102 - 4096x2160p@60Hz 256:135 */
+	{ DRM_BASE_MODE(594000, 4096, 4184,
+			4272, 4400, 2160, 2168, 2178, 2250, 0,
+			DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+};
+
+struct minimode {
+	short w;
+	short h;
+	short r;
+	short rb;
+};
+
+static const struct minimode est3_modes[] = {
+	/* byte 6 */
+	{ 640, 350, 85, 0 },
+	{ 640, 400, 85, 0 },
+	{ 720, 400, 85, 0 },
+	{ 640, 480, 85, 0 },
+	{ 848, 480, 60, 0 },
+	{ 800, 600, 85, 0 },
+	{ 1024, 768, 85, 0 },
+	{ 1152, 864, 75, 0 },
+	/* byte 7 */
+	{ 1280, 768, 60, 1 },
+	{ 1280, 768, 60, 0 },
+	{ 1280, 768, 75, 0 },
+	{ 1280, 768, 85, 0 },
+	{ 1280, 960, 60, 0 },
+	{ 1280, 960, 85, 0 },
+	{ 1280, 1024, 60, 0 },
+	{ 1280, 1024, 85, 0 },
+	/* byte 8 */
+	{ 1360, 768, 60, 0 },
+	{ 1440, 900, 60, 1 },
+	{ 1440, 900, 60, 0 },
+	{ 1440, 900, 75, 0 },
+	{ 1440, 900, 85, 0 },
+	{ 1400, 1050, 60, 1 },
+	{ 1400, 1050, 60, 0 },
+	{ 1400, 1050, 75, 0 },
+	/* byte 9 */
+	{ 1400, 1050, 85, 0 },
+	{ 1680, 1050, 60, 1 },
+	{ 1680, 1050, 60, 0 },
+	{ 1680, 1050, 75, 0 },
+	{ 1680, 1050, 85, 0 },
+	{ 1600, 1200, 60, 0 },
+	{ 1600, 1200, 65, 0 },
+	{ 1600, 1200, 70, 0 },
+	/* byte 10 */
+	{ 1600, 1200, 75, 0 },
+	{ 1600, 1200, 85, 0 },
+	{ 1792, 1344, 60, 0 },
+	{ 1792, 1344, 75, 0 },
+	{ 1856, 1392, 60, 0 },
+	{ 1856, 1392, 75, 0 },
+	{ 1920, 1200, 60, 1 },
+	{ 1920, 1200, 60, 0 },
+	/* byte 11 */
+	{ 1920, 1200, 75, 0 },
+	{ 1920, 1200, 85, 0 },
+	{ 1920, 1440, 60, 0 },
+	{ 1920, 1440, 75, 0 },
+};
+
+static const struct minimode extra_modes[] = {
+	{ 1024, 576,  60, 0 },
+	{ 1366, 768,  60, 0 },
+	{ 1600, 900,  60, 0 },
+	{ 1680, 945,  60, 0 },
+	{ 1920, 1080, 60, 0 },
+	{ 2048, 1152, 60, 0 },
+	{ 2048, 1536, 60, 0 },
+};
+
 int edid_check_info(struct edid1_info *edid_info)
 {
 	if ((edid_info == NULL) || (edid_info->version == 0))
@@ -136,6 +1544,81 @@ static void decode_timing(u8 *buf, struct display_timing *timing)
 	      va + vbl, vborder);
 }
 
+/**
+ * decode_mode() - Decoding an 18-byte detailed timing record
+ *
+ * @buf:	Pointer to EDID detailed timing record
+ * @timing:	Place to put timing
+ */
+static void decode_mode(u8 *buf, struct drm_display_mode *mode)
+{
+	uint x_mm, y_mm;
+	unsigned int ha, hbl, hso, hspw, hborder;
+	unsigned int va, vbl, vso, vspw, vborder;
+	struct edid_detailed_timing *t = (struct edid_detailed_timing *)buf;
+
+	x_mm = (buf[12] + ((buf[14] & 0xf0) << 4));
+	y_mm = (buf[13] + ((buf[14] & 0x0f) << 8));
+	ha = (buf[2] + ((buf[4] & 0xf0) << 4));
+	hbl = (buf[3] + ((buf[4] & 0x0f) << 8));
+	hso = (buf[8] + ((buf[11] & 0xc0) << 2));
+	hspw = (buf[9] + ((buf[11] & 0x30) << 4));
+	hborder = buf[15];
+	va = (buf[5] + ((buf[7] & 0xf0) << 4));
+	vbl = (buf[6] + ((buf[7] & 0x0f) << 8));
+	vso = ((buf[10] >> 4) + ((buf[11] & 0x0c) << 2));
+	vspw = ((buf[10] & 0x0f) + ((buf[11] & 0x03) << 4));
+	vborder = buf[16];
+
+	/* Edid contains pixel clock in terms of 10KHz */
+	mode->clock = (buf[0] + (buf[1] << 8)) * 10;
+	mode->hdisplay = ha;
+	mode->hsync_start = ha + hso;
+	mode->hsync_end = ha + hso + hspw;
+	mode->htotal = ha + hbl;
+	mode->vdisplay = va;
+	mode->vsync_start = va + vso;
+	mode->vsync_end = va + vso + vspw;
+	mode->vtotal = va + vbl;
+
+	mode->flags = EDID_DETAILED_TIMING_FLAG_HSYNC_POLARITY(*t) ?
+		DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |= EDID_DETAILED_TIMING_FLAG_VSYNC_POLARITY(*t) ?
+		DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+
+	if (EDID_DETAILED_TIMING_FLAG_INTERLACED(*t))
+		mode->flags |= DRM_MODE_FLAG_INTERLACE;
+
+	debug("Detailed mode clock %u kHz, %d mm x %d mm, flags[%x]\n"
+	      "     %04d %04d %04d %04d hborder %d\n"
+	      "     %04d %04d %04d %04d vborder %d\n",
+	      mode->clock,
+	      x_mm, y_mm, mode->flags,
+	      mode->hdisplay, mode->hsync_start, mode->hsync_end,
+	      mode->htotal, hborder,
+	      mode->vdisplay, mode->vsync_start, mode->vsync_end,
+	      mode->vtotal, vborder);
+}
+
+/**
+ * edid_vendor - match a string against EDID's obfuscated vendor field
+ * @edid: EDID to match
+ * @vendor: vendor string
+ *
+ * Returns true if @vendor is in @edid, false otherwise
+ */
+static bool edid_vendor(struct edid *edid, char *vendor)
+{
+	char edid_vendor[3];
+
+	edid_vendor[0] = ((edid->mfg_id[0] & 0x7c) >> 2) + '@';
+	edid_vendor[1] = (((edid->mfg_id[0] & 0x3) << 3) |
+			  ((edid->mfg_id[1] & 0xe0) >> 5)) + '@';
+	edid_vendor[2] = (edid->mfg_id[1] & 0x1f) + '@';
+
+	return !strncmp(edid_vendor, vendor, 3);
+}
+
 /**
  * Check if HDMI vendor specific data block is present in CEA block
  * @param info	CEA extension block
@@ -169,6 +1652,80 @@ static bool cea_is_hdmi_vsdb_present(struct edid_cea861_info *info)
 	return false;
 }
 
+static int drm_get_vrefresh(const struct drm_display_mode *mode)
+{
+	int refresh = 0;
+	unsigned int calc_val;
+
+	if (mode->vrefresh > 0) {
+		refresh = mode->vrefresh;
+	} else if (mode->htotal > 0 && mode->vtotal > 0) {
+		int vtotal;
+
+		vtotal = mode->vtotal;
+		/* work out vrefresh the value will be x1000 */
+		calc_val = (mode->clock * 1000);
+		calc_val /= mode->htotal;
+		refresh = (calc_val + vtotal / 2) / vtotal;
+
+		if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+			refresh *= 2;
+		if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+			refresh /= 2;
+		if (mode->vscan > 1)
+			refresh /= mode->vscan;
+	}
+	return refresh;
+}
+
+int edid_get_drm_mode(u8 *buf, int buf_size, struct drm_display_mode *mode,
+		      int *panel_bits_per_colourp)
+{
+	struct edid1_info *edid = (struct edid1_info *)buf;
+	bool timing_done;
+	int i;
+
+	if (buf_size < sizeof(*edid) || edid_check_info(edid)) {
+		debug("%s: Invalid buffer\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!EDID1_INFO_FEATURE_PREFERRED_TIMING_MODE(*edid)) {
+		debug("%s: No preferred timing\n", __func__);
+		return -ENOENT;
+	}
+
+	/* Look for detailed timing */
+	timing_done = false;
+	for (i = 0; i < 4; i++) {
+		struct edid_monitor_descriptor *desc;
+
+		desc = &edid->monitor_details.descriptor[i];
+		if (desc->zero_flag_1 != 0) {
+			decode_mode((u8 *)desc, mode);
+			timing_done = true;
+			break;
+		}
+	}
+	if (!timing_done)
+		return -EINVAL;
+
+	if (!EDID1_INFO_VIDEO_INPUT_DIGITAL(*edid)) {
+		debug("%s: Not a digital display\n", __func__);
+		return -ENOSYS;
+	}
+	if (edid->version != 1 || edid->revision < 4) {
+		debug("%s: EDID version %d.%d does not have required info\n",
+		      __func__, edid->version, edid->revision);
+		*panel_bits_per_colourp = -1;
+	} else  {
+		*panel_bits_per_colourp =
+			((edid->video_input_definition & 0x70) >> 3) + 4;
+	}
+
+	return 0;
+}
+
 int edid_get_timing(u8 *buf, int buf_size, struct display_timing *timing,
 		    int *panel_bits_per_colourp)
 {
@@ -244,7 +1801,7 @@ static char *snip(char *string)
 	s = &string[strlen(string) - 1];
 
 	while (s >= string && (isspace(*s) || *s == '\n' || *s == '\r' ||
-			*s == '\0'))
+	       *s == '\0'))
 		*(s--) = '\0';
 
 	return string;
@@ -284,8 +1841,8 @@ static void edid_print_dtd(struct edid_monitor_descriptor *monitor,
 			       monitor->data.range_data.vertical_max,
 			       monitor->data.range_data.pixel_clock_max * 10);
 	} else {
-		uint32_t pixclock, h_active, h_blanking, v_active, v_blanking;
-		uint32_t h_total, v_total, vfreq;
+		u32 pixclock, h_active, h_blanking, v_active, v_blanking;
+		u32 h_total, v_total, vfreq;
 
 		pixclock = EDID_DETAILED_TIMING_PIXEL_CLOCK(*timing);
 		h_active = EDID_DETAILED_TIMING_HORIZONTAL_ACTIVE(*timing);
@@ -324,7 +1881,7 @@ void edid_print_info(struct edid1_info *edid_info)
 	int i;
 	char manufacturer[4];
 	unsigned int have_timing = 0;
-	uint32_t serial_number;
+	u32 serial_number;
 
 	if (edid_check_info(edid_info)) {
 		printf("Not a valid EDID\n");
@@ -429,7 +1986,7 @@ void edid_print_info(struct edid1_info *edid_info)
 		    ((xres != 0) && (xres != 1)) ||
 		    ((vfreq != 0) && (vfreq != 1))) {
 			switch (EDID1_INFO_STANDARD_TIMING_ASPECT(*edid_info,
-					i)) {
+				i)) {
 			case ASPECT_625:
 				aspect = 6250;
 				break;
@@ -461,3 +2018,4736 @@ void edid_print_info(struct edid1_info *edid_info)
 	if (!have_timing)
 		printf("\tNone\n");
 }
+
+/**
+ * drm_mode_create - create a new display mode
+ *
+ * Create a new, cleared drm_display_mode.
+ *
+ * Returns:
+ * Pointer to new mode on success, NULL on error.
+ */
+static struct drm_display_mode *drm_mode_create(void)
+{
+	struct drm_display_mode *nmode;
+
+	nmode = malloc(sizeof(struct drm_display_mode));
+	memset(nmode, 0, sizeof(struct drm_display_mode));
+	if (!nmode)
+		return NULL;
+
+	return nmode;
+}
+
+/**
+ * drm_mode_destroy - remove a mode
+ * @mode: mode to remove
+ *
+ */
+static void drm_mode_destroy(struct drm_display_mode *mode)
+{
+	if (!mode)
+		return;
+
+	kfree(mode);
+}
+
+/**
+ * drm_cvt_mode -create a modeline based on the CVT algorithm
+ * @hdisplay: hdisplay size
+ * @vdisplay: vdisplay size
+ * @vrefresh: vrefresh rate
+ * @reduced: whether to use reduced blanking
+ * @interlaced: whether to compute an interlaced mode
+ * @margins: whether to add margins (borders)
+ *
+ * This function is called to generate the modeline based on CVT algorithm
+ * according to the hdisplay, vdisplay, vrefresh.
+ * It is based from the VESA(TM) Coordinated Video Timing Generator by
+ * Graham Loveridge April 9, 2003 available at
+ * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls
+ *
+ * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
+ * What I have done is to translate it by using integer calculation.
+ *
+ * Returns:
+ * The modeline based on the CVT algorithm stored in a drm_display_mode object.
+ * The display mode object is allocated with drm_mode_create(). Returns NULL
+ * when no mode could be allocated.
+ */
+static
+struct drm_display_mode *drm_cvt_mode(int hdisplay, int vdisplay, int vrefresh,
+				      bool reduced, bool interlaced,
+				      bool margins)
+{
+#define HV_FACTOR			1000
+	/* 1) top/bottom margin size (% of height) - default: 1.8, */
+#define	CVT_MARGIN_PERCENTAGE		18
+	/* 2) character cell horizontal granularity (pixels) - default 8 */
+#define	CVT_H_GRANULARITY		8
+	/* 3) Minimum vertical porch (lines) - default 3 */
+#define	CVT_MIN_V_PORCH			3
+	/* 4) Minimum number of vertical back porch lines - default 6 */
+#define	CVT_MIN_V_BPORCH		6
+	/* Pixel Clock step (kHz) */
+#define CVT_CLOCK_STEP			250
+	struct drm_display_mode *drm_mode;
+	unsigned int vfieldrate, hperiod;
+	int hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;
+	int interlace;
+
+	/* allocate the drm_display_mode structure. If failure, we will
+	 * return directly
+	 */
+	drm_mode = drm_mode_create();
+	if (!drm_mode)
+		return NULL;
+
+	/* the CVT default refresh rate is 60Hz */
+	if (!vrefresh)
+		vrefresh = 60;
+
+	/* the required field fresh rate */
+	if (interlaced)
+		vfieldrate = vrefresh * 2;
+	else
+		vfieldrate = vrefresh;
+
+	/* horizontal pixels */
+	hdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);
+
+	/* determine the left&right borders */
+	hmargin = 0;
+	if (margins) {
+		hmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;
+		hmargin -= hmargin % CVT_H_GRANULARITY;
+	}
+	/* find the total active pixels */
+	drm_mode->hdisplay = hdisplay_rnd + 2 * hmargin;
+
+	/* find the number of lines per field */
+	if (interlaced)
+		vdisplay_rnd = vdisplay / 2;
+	else
+		vdisplay_rnd = vdisplay;
+
+	/* find the top & bottom borders */
+	vmargin = 0;
+	if (margins)
+		vmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;
+
+	drm_mode->vdisplay = vdisplay + 2 * vmargin;
+
+	/* Interlaced */
+	if (interlaced)
+		interlace = 1;
+	else
+		interlace = 0;
+
+	/* Determine VSync Width from aspect ratio */
+	if (!(vdisplay % 3) && ((vdisplay * 4 / 3) == hdisplay))
+		vsync = 4;
+	else if (!(vdisplay % 9) && ((vdisplay * 16 / 9) == hdisplay))
+		vsync = 5;
+	else if (!(vdisplay % 10) && ((vdisplay * 16 / 10) == hdisplay))
+		vsync = 6;
+	else if (!(vdisplay % 4) && ((vdisplay * 5 / 4) == hdisplay))
+		vsync = 7;
+	else if (!(vdisplay % 9) && ((vdisplay * 15 / 9) == hdisplay))
+		vsync = 7;
+	else /* custom */
+		vsync = 10;
+
+	if (!reduced) {
+		/* simplify the GTF calculation */
+		/* 4) Minimum time of vertical sync + back porch interval
+		 * default 550.0
+		 */
+		int tmp1, tmp2;
+#define CVT_MIN_VSYNC_BP	550
+		/* 3) Nominal HSync width (% of line period) - default 8 */
+#define CVT_HSYNC_PERCENTAGE	8
+		unsigned int hblank_percentage;
+		int vsyncandback_porch, hblank;
+
+		/* estimated the horizontal period */
+		tmp1 = HV_FACTOR * 1000000  -
+				CVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;
+		tmp2 = (vdisplay_rnd + 2 * vmargin + CVT_MIN_V_PORCH) * 2 +
+				interlace;
+		hperiod = tmp1 * 2 / (tmp2 * vfieldrate);
+
+		tmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + 1;
+		/* 9. Find number of lines in sync + backporch */
+		if (tmp1 < (vsync + CVT_MIN_V_PORCH))
+			vsyncandback_porch = vsync + CVT_MIN_V_PORCH;
+		else
+			vsyncandback_porch = tmp1;
+		/* 10. Find number of lines in back porch
+		 *		vback_porch = vsyncandback_porch - vsync;
+		 */
+		drm_mode->vtotal = vdisplay_rnd + 2 * vmargin +
+				vsyncandback_porch + CVT_MIN_V_PORCH;
+		/* 5) Definition of Horizontal blanking time limitation */
+		/* Gradient (%/kHz) - default 600 */
+#define CVT_M_FACTOR	600
+		/* Offset (%) - default 40 */
+#define CVT_C_FACTOR	40
+		/* Blanking time scaling factor - default 128 */
+#define CVT_K_FACTOR	128
+		/* Scaling factor weighting - default 20 */
+#define CVT_J_FACTOR	20
+#define CVT_M_PRIME	(CVT_M_FACTOR * CVT_K_FACTOR / 256)
+#define CVT_C_PRIME	((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \
+			 CVT_J_FACTOR)
+		/* 12. Find ideal blanking duty cycle from formula */
+		hblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *
+					hperiod / 1000;
+		/* 13. Blanking time */
+		if (hblank_percentage < 20 * HV_FACTOR)
+			hblank_percentage = 20 * HV_FACTOR;
+		hblank = drm_mode->hdisplay * hblank_percentage /
+			 (100 * HV_FACTOR - hblank_percentage);
+		hblank -= hblank % (2 * CVT_H_GRANULARITY);
+		/* 14. find the total pixels per line */
+		drm_mode->htotal = drm_mode->hdisplay + hblank;
+		drm_mode->hsync_end = drm_mode->hdisplay + hblank / 2;
+		drm_mode->hsync_start = drm_mode->hsync_end -
+			(drm_mode->htotal * CVT_HSYNC_PERCENTAGE) / 100;
+		drm_mode->hsync_start += CVT_H_GRANULARITY -
+			drm_mode->hsync_start % CVT_H_GRANULARITY;
+		/* fill the Vsync values */
+		drm_mode->vsync_start = drm_mode->vdisplay + CVT_MIN_V_PORCH;
+		drm_mode->vsync_end = drm_mode->vsync_start + vsync;
+	} else {
+		/* Reduced blanking */
+		/* Minimum vertical blanking interval time - default 460 */
+#define CVT_RB_MIN_VBLANK	460
+		/* Fixed number of clocks for horizontal sync */
+#define CVT_RB_H_SYNC		32
+		/* Fixed number of clocks for horizontal blanking */
+#define CVT_RB_H_BLANK		160
+		/* Fixed number of lines for vertical front porch - default 3*/
+#define CVT_RB_VFPORCH		3
+		int vbilines;
+		int tmp1, tmp2;
+		/* 8. Estimate Horizontal period. */
+		tmp1 = HV_FACTOR * 1000000 -
+			CVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;
+		tmp2 = vdisplay_rnd + 2 * vmargin;
+		hperiod = tmp1 / (tmp2 * vfieldrate);
+		/* 9. Find number of lines in vertical blanking */
+		vbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + 1;
+		/* 10. Check if vertical blanking is sufficient */
+		if (vbilines < (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))
+			vbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;
+		/* 11. Find total number of lines in vertical field */
+		drm_mode->vtotal = vdisplay_rnd + 2 * vmargin + vbilines;
+		/* 12. Find total number of pixels in a line */
+		drm_mode->htotal = drm_mode->hdisplay + CVT_RB_H_BLANK;
+		/* Fill in HSync values */
+		drm_mode->hsync_end = drm_mode->hdisplay + CVT_RB_H_BLANK / 2;
+		drm_mode->hsync_start = drm_mode->hsync_end - CVT_RB_H_SYNC;
+		/* Fill in VSync values */
+		drm_mode->vsync_start = drm_mode->vdisplay + CVT_RB_VFPORCH;
+		drm_mode->vsync_end = drm_mode->vsync_start + vsync;
+	}
+	/* 15/13. Find pixel clock frequency (kHz for xf86) */
+	drm_mode->clock = drm_mode->htotal * HV_FACTOR * 1000 / hperiod;
+	drm_mode->clock -= drm_mode->clock % CVT_CLOCK_STEP;
+	/* 18/16. Find actual vertical frame frequency */
+	/* ignore - just set the mode flag for interlaced */
+	if (interlaced) {
+		drm_mode->vtotal *= 2;
+		drm_mode->flags |= DRM_MODE_FLAG_INTERLACE;
+	}
+
+	if (reduced)
+		drm_mode->flags |= (DRM_MODE_FLAG_PHSYNC |
+					DRM_MODE_FLAG_NVSYNC);
+	else
+		drm_mode->flags |= (DRM_MODE_FLAG_PVSYNC |
+					DRM_MODE_FLAG_NHSYNC);
+
+	return drm_mode;
+}
+
+static int
+cea_db_payload_len(const u8 *db)
+{
+	return db[0] & 0x1f;
+}
+
+static int
+cea_db_extended_tag(const u8 *db)
+{
+	return db[1];
+}
+
+static int
+cea_db_tag(const u8 *db)
+{
+	return db[0] >> 5;
+}
+
+#define for_each_cea_db(cea, i, start, end) \
+	for ((i) = (start); (i) < (end) && (i) + \
+	cea_db_payload_len(&(cea)[(i)]) < \
+	(end); (i) += cea_db_payload_len(&(cea)[(i)]) + 1)
+
+static int
+cea_revision(const u8 *cea)
+{
+	return cea[1];
+}
+
+static int
+cea_db_offsets(const u8 *cea, int *start, int *end)
+{
+	/* Data block offset in CEA extension block */
+	*start = 4;
+	*end = cea[2];
+	if (*end == 0)
+		*end = 127;
+	if (*end < 4 || *end > 127)
+		return -ERANGE;
+
+	/*
+	 * XXX: cea[2] is equal to the real value minus one in some sink edid.
+	 */
+	if (*end != 4) {
+		int i;
+
+		i = *start;
+		while (i < (*end) &&
+		       i + cea_db_payload_len(&(cea)[i]) < (*end))
+			i += cea_db_payload_len(&(cea)[i]) + 1;
+
+		if (cea_db_payload_len(&(cea)[i]) &&
+		    i + cea_db_payload_len(&(cea)[i]) == (*end))
+			(*end)++;
+	}
+
+	return 0;
+}
+
+static bool cea_db_is_hdmi_vsdb(const u8 *db)
+{
+	int hdmi_id;
+
+	if (cea_db_tag(db) != EDID_CEA861_DB_VENDOR)
+		return false;
+
+	if (cea_db_payload_len(db) < 5)
+		return false;
+
+	hdmi_id = db[1] | (db[2] << 8) | (db[3] << 16);
+
+	return hdmi_id == HDMI_IEEE_OUI;
+}
+
+static bool cea_db_is_hdmi_forum_vsdb(const u8 *db)
+{
+	unsigned int oui;
+
+	if (cea_db_tag(db) != EDID_CEA861_DB_VENDOR)
+		return false;
+
+	if (cea_db_payload_len(db) < 7)
+		return false;
+
+	oui = db[3] << 16 | db[2] << 8 | db[1];
+
+	return oui == HDMI_FORUM_IEEE_OUI;
+}
+
+static bool cea_db_is_y420cmdb(const u8 *db)
+{
+	if (cea_db_tag(db) != EDID_CEA861_DB_USE_EXTENDED)
+		return false;
+
+	if (!cea_db_payload_len(db))
+		return false;
+
+	if (cea_db_extended_tag(db) != EXT_VIDEO_CAP_BLOCK_Y420CMDB)
+		return false;
+
+	return true;
+}
+
+static bool cea_db_is_y420vdb(const u8 *db)
+{
+	if (cea_db_tag(db) != EDID_CEA861_DB_USE_EXTENDED)
+		return false;
+
+	if (!cea_db_payload_len(db))
+		return false;
+
+	if (cea_db_extended_tag(db) != EXT_VIDEO_DATA_BLOCK_420)
+		return false;
+
+	return true;
+}
+
+static bool drm_valid_hdmi_vic(u8 vic)
+{
+	return vic > 0 && vic < ARRAY_SIZE(edid_4k_modes);
+}
+
+static void drm_add_hdmi_modes(struct hdmi_edid_data *data,
+			       const struct drm_display_mode *mode)
+{
+	struct drm_display_mode *mode_buf = data->mode_buf;
+
+	if (data->modes >= MODE_LEN)
+		return;
+	mode_buf[(data->modes)++] = *mode;
+}
+
+static bool drm_valid_cea_vic(u8 vic)
+{
+	return vic > 0 && vic < ARRAY_SIZE(edid_cea_modes);
+}
+
+static u8 svd_to_vic(u8 svd)
+{
+	/* 0-6 bit vic, 7th bit native mode indicator */
+	if ((svd >= 1 &&  svd <= 64) || (svd >= 129 && svd <= 192))
+		return svd & 127;
+
+	return svd;
+}
+
+static struct drm_display_mode *
+drm_display_mode_from_vic_index(const u8 *video_db, u8 video_len,
+				u8 video_index)
+{
+	struct drm_display_mode *newmode;
+	u8 vic;
+
+	if (!video_db || video_index >= video_len)
+		return NULL;
+
+	/* CEA modes are numbered 1..127 */
+	vic = svd_to_vic(video_db[video_index]);
+	if (!drm_valid_cea_vic(vic))
+		return NULL;
+
+	newmode = drm_mode_create();
+	if (!newmode)
+		return NULL;
+
+	*newmode = edid_cea_modes[vic];
+	newmode->vrefresh = 0;
+
+	return newmode;
+}
+
+static void bitmap_set(unsigned long *map, unsigned int start, int len)
+{
+	unsigned long *p = map + BIT_WORD(start);
+	const unsigned int size = start + len;
+	int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);
+	unsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);
+
+	while (len - bits_to_set >= 0) {
+		*p |= mask_to_set;
+		len -= bits_to_set;
+		bits_to_set = BITS_PER_LONG;
+		mask_to_set = ~0UL;
+		p++;
+	}
+	if (len) {
+		mask_to_set &= BITMAP_LAST_WORD_MASK(size);
+		*p |= mask_to_set;
+	}
+}
+
+static void
+drm_add_cmdb_modes(u8 svd, struct drm_hdmi_info *hdmi)
+{
+	u8 vic = svd_to_vic(svd);
+
+	if (!drm_valid_cea_vic(vic))
+		return;
+
+	bitmap_set(hdmi->y420_cmdb_modes, vic, 1);
+}
+
+int do_cea_modes(struct hdmi_edid_data *data, const u8 *db, u8 len)
+{
+	int i, modes = 0;
+	struct drm_hdmi_info *hdmi = &data->display_info.hdmi;
+
+	for (i = 0; i < len; i++) {
+		struct drm_display_mode *mode;
+
+		mode = drm_display_mode_from_vic_index(db, len, i);
+		if (mode) {
+			/*
+			 * YCBCR420 capability block contains a bitmap which
+			 * gives the index of CEA modes from CEA VDB, which
+			 * can support YCBCR 420 sampling output also (apart
+			 * from RGB/YCBCR444 etc).
+			 * For example, if the bit 0 in bitmap is set,
+			 * first mode in VDB can support YCBCR420 output too.
+			 * Add YCBCR420 modes only if sink is HDMI 2.0 capable.
+			 */
+			if (i < 64 && hdmi->y420_cmdb_map & (1ULL << i))
+				drm_add_cmdb_modes(db[i], hdmi);
+			drm_add_hdmi_modes(data, mode);
+			drm_mode_destroy(mode);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+/*
+ * do_y420vdb_modes - Parse YCBCR 420 only modes
+ * @data: the structure that save parsed hdmi edid data
+ * @svds: start of the data block of CEA YCBCR 420 VDB
+ * @svds_len: length of the CEA YCBCR 420 VDB
+ * @hdmi: runtime information about the connected HDMI sink
+ *
+ * Parse the CEA-861-F YCBCR 420 Video Data Block (Y420VDB)
+ * which contains modes which can be supported in YCBCR 420
+ * output format only.
+ */
+static int
+do_y420vdb_modes(struct hdmi_edid_data *data, const u8 *svds, u8 svds_len)
+{
+	int modes = 0, i;
+	struct drm_hdmi_info *hdmi = &data->display_info.hdmi;
+
+	for (i = 0; i < svds_len; i++) {
+		u8 vic = svd_to_vic(svds[i]);
+
+		if (!drm_valid_cea_vic(vic))
+			continue;
+
+		bitmap_set(hdmi->y420_vdb_modes, vic, 1);
+		drm_add_hdmi_modes(data, &edid_cea_modes[vic]);
+		modes++;
+	}
+
+	return modes;
+}
+
+struct stereo_mandatory_mode {
+	int width, height, vrefresh;
+	unsigned int flags;
+};
+
+static const struct stereo_mandatory_mode stereo_mandatory_modes[] = {
+	{ 1920, 1080, 24, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },
+	{ 1920, 1080, 24, DRM_MODE_FLAG_3D_FRAME_PACKING },
+	{ 1920, 1080, 50,
+	  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },
+	{ 1920, 1080, 60,
+	  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },
+	{ 1280, 720,  50, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },
+	{ 1280, 720,  50, DRM_MODE_FLAG_3D_FRAME_PACKING },
+	{ 1280, 720,  60, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },
+	{ 1280, 720,  60, DRM_MODE_FLAG_3D_FRAME_PACKING }
+};
+
+static bool
+stereo_match_mandatory(const struct drm_display_mode *mode,
+		       const struct stereo_mandatory_mode *stereo_mode)
+{
+	unsigned int interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;
+
+	return mode->hdisplay == stereo_mode->width &&
+	       mode->vdisplay == stereo_mode->height &&
+	       interlaced == (stereo_mode->flags & DRM_MODE_FLAG_INTERLACE) &&
+	       drm_get_vrefresh(mode) == stereo_mode->vrefresh;
+}
+
+static int add_hdmi_mandatory_stereo_modes(struct hdmi_edid_data *data)
+{
+	const struct drm_display_mode *mode;
+	int num = data->modes, modes = 0, i, k;
+
+	for (k = 0; k < num; k++) {
+		mode = &data->mode_buf[k];
+		for (i = 0; i < ARRAY_SIZE(stereo_mandatory_modes); i++) {
+			const struct stereo_mandatory_mode *mandatory;
+			struct drm_display_mode *new_mode;
+
+			if (!stereo_match_mandatory(mode,
+						    &stereo_mandatory_modes[i]))
+				continue;
+
+			mandatory = &stereo_mandatory_modes[i];
+			new_mode = drm_mode_create();
+			if (!new_mode)
+				continue;
+
+			*new_mode = *mode;
+			new_mode->flags |= mandatory->flags;
+			drm_add_hdmi_modes(data, new_mode);
+			drm_mode_destroy(new_mode);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+static int add_3d_struct_modes(struct hdmi_edid_data *data, u16 structure,
+			       const u8 *video_db, u8 video_len, u8 video_index)
+{
+	struct drm_display_mode *newmode;
+	int modes = 0;
+
+	if (structure & (1 << 0)) {
+		newmode = drm_display_mode_from_vic_index(video_db,
+							  video_len,
+							  video_index);
+		if (newmode) {
+			newmode->flags |= DRM_MODE_FLAG_3D_FRAME_PACKING;
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+	if (structure & (1 << 6)) {
+		newmode = drm_display_mode_from_vic_index(video_db,
+							  video_len,
+							  video_index);
+		if (newmode) {
+			newmode->flags |= DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+	if (structure & (1 << 8)) {
+		newmode = drm_display_mode_from_vic_index(video_db,
+							  video_len,
+							  video_index);
+		if (newmode) {
+			newmode->flags |= DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+
+	return modes;
+}
+
+static int add_hdmi_mode(struct hdmi_edid_data *data, u8 vic)
+{
+	if (!drm_valid_hdmi_vic(vic)) {
+		debug("Unknown HDMI VIC: %d\n", vic);
+		return 0;
+	}
+
+	drm_add_hdmi_modes(data, &edid_4k_modes[vic]);
+
+	return 1;
+}
+
+/*
+ * do_hdmi_vsdb_modes - Parse the HDMI Vendor Specific data block
+ * @db: start of the CEA vendor specific block
+ * @len: length of the CEA block payload, ie. one can access up to db[len]
+ *
+ * Parses the HDMI VSDB looking for modes to add to @data. This function
+ * also adds the stereo 3d modes when applicable.
+ */
+static int
+do_hdmi_vsdb_modes(const u8 *db, u8 len, const u8 *video_db, u8 video_len,
+		   struct hdmi_edid_data *data)
+{
+	int modes = 0, offset = 0, i, multi_present = 0, multi_len;
+	u8 vic_len, hdmi_3d_len = 0;
+	u16 mask;
+	u16 structure_all;
+
+	if (len < 8)
+		goto out;
+
+	/* no HDMI_Video_Present */
+	if (!(db[8] & (1 << 5)))
+		goto out;
+
+	/* Latency_Fields_Present */
+	if (db[8] & (1 << 7))
+		offset += 2;
+
+	/* I_Latency_Fields_Present */
+	if (db[8] & (1 << 6))
+		offset += 2;
+
+	/* the declared length is not long enough for the 2 first bytes
+	 * of additional video format capabilities
+	 */
+	if (len < (8 + offset + 2))
+		goto out;
+
+	/* 3D_Present */
+	offset++;
+	if (db[8 + offset] & (1 << 7)) {
+		modes += add_hdmi_mandatory_stereo_modes(data);
+
+		/* 3D_Multi_present */
+		multi_present = (db[8 + offset] & 0x60) >> 5;
+	}
+
+	offset++;
+	vic_len = db[8 + offset] >> 5;
+	hdmi_3d_len = db[8 + offset] & 0x1f;
+
+	for (i = 0; i < vic_len && len >= (9 + offset + i); i++) {
+		u8 vic;
+
+		vic = db[9 + offset + i];
+		modes += add_hdmi_mode(data, vic);
+	}
+
+	offset += 1 + vic_len;
+
+	if (multi_present == 1)
+		multi_len = 2;
+	else if (multi_present == 2)
+		multi_len = 4;
+	else
+		multi_len = 0;
+
+	if (len < (8 + offset + hdmi_3d_len - 1))
+		goto out;
+
+	if (hdmi_3d_len < multi_len)
+		goto out;
+
+	if (multi_present == 1 || multi_present == 2) {
+		/* 3D_Structure_ALL */
+		structure_all = (db[8 + offset] << 8) | db[9 + offset];
+
+		/* check if 3D_MASK is present */
+		if (multi_present == 2)
+			mask = (db[10 + offset] << 8) | db[11 + offset];
+		else
+			mask = 0xffff;
+
+		for (i = 0; i < 16; i++) {
+			if (mask & (1 << i))
+				modes += add_3d_struct_modes(data,
+						structure_all,
+						video_db,
+						video_len, i);
+		}
+	}
+
+	offset += multi_len;
+
+	for (i = 0; i < (hdmi_3d_len - multi_len); i++) {
+		int vic_index;
+		struct drm_display_mode *newmode = NULL;
+		unsigned int newflag = 0;
+		bool detail_present;
+
+		detail_present = ((db[8 + offset + i] & 0x0f) > 7);
+
+		if (detail_present && (i + 1 == hdmi_3d_len - multi_len))
+			break;
+
+		/* 2D_VIC_order_X */
+		vic_index = db[8 + offset + i] >> 4;
+
+		/* 3D_Structure_X */
+		switch (db[8 + offset + i] & 0x0f) {
+		case 0:
+			newflag = DRM_MODE_FLAG_3D_FRAME_PACKING;
+			break;
+		case 6:
+			newflag = DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;
+			break;
+		case 8:
+			/* 3D_Detail_X */
+			if ((db[9 + offset + i] >> 4) == 1)
+				newflag = DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;
+			break;
+		}
+
+		if (newflag != 0) {
+			newmode = drm_display_mode_from_vic_index(
+								  video_db,
+								  video_len,
+								  vic_index);
+
+			if (newmode) {
+				newmode->flags |= newflag;
+				drm_add_hdmi_modes(data, newmode);
+				modes++;
+				drm_mode_destroy(newmode);
+			}
+		}
+
+		if (detail_present)
+			i++;
+	}
+
+out:
+	return modes;
+}
+
+/**
+ * edid_get_quirks - return quirk flags for a given EDID
+ * @edid: EDID to process
+ *
+ * This tells subsequent routines what fixes they need to apply.
+ */
+static u32 edid_get_quirks(struct edid *edid)
+{
+	struct edid_quirk *quirk;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {
+		quirk = &edid_quirk_list[i];
+
+		if (edid_vendor(edid, quirk->vendor) &&
+		    (EDID_PRODUCT_ID(edid) == quirk->product_id))
+			return quirk->quirks;
+	}
+
+	return 0;
+}
+
+static void drm_parse_y420cmdb_bitmap(struct hdmi_edid_data *data,
+				      const u8 *db)
+{
+	struct drm_display_info *info = &data->display_info;
+	struct drm_hdmi_info *hdmi = &info->hdmi;
+	u8 map_len = cea_db_payload_len(db) - 1;
+	u8 count;
+	u64 map = 0;
+
+	if (map_len == 0) {
+		/* All CEA modes support ycbcr420 sampling also.*/
+		hdmi->y420_cmdb_map = U64_MAX;
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB420;
+		return;
+	}
+
+	/*
+	 * This map indicates which of the existing CEA block modes
+	 * from VDB can support YCBCR420 output too. So if bit=0 is
+	 * set, first mode from VDB can support YCBCR420 output too.
+	 * We will parse and keep this map, before parsing VDB itself
+	 * to avoid going through the same block again and again.
+	 *
+	 * Spec is not clear about max possible size of this block.
+	 * Clamping max bitmap block size at 8 bytes. Every byte can
+	 * address 8 CEA modes, in this way this map can address
+	 * 8*8 = first 64 SVDs.
+	 */
+	if (map_len > 8)
+		map_len = 8;
+
+	for (count = 0; count < map_len; count++)
+		map |= (u64)db[2 + count] << (8 * count);
+
+	if (map)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB420;
+
+	hdmi->y420_cmdb_map = map;
+}
+
+static
+void drm_get_max_frl_rate(int max_frl_rate, u8 *max_lanes, u8 *max_rate_per_lane)
+{
+	switch (max_frl_rate) {
+	case 1:
+		*max_lanes = 3;
+		*max_rate_per_lane = 3;
+		break;
+	case 2:
+		*max_lanes = 3;
+		*max_rate_per_lane = 6;
+		break;
+	case 3:
+		*max_lanes = 4;
+		*max_rate_per_lane = 6;
+		break;
+	case 4:
+		*max_lanes = 4;
+		*max_rate_per_lane = 8;
+		break;
+	case 5:
+		*max_lanes = 4;
+		*max_rate_per_lane = 10;
+		break;
+	case 6:
+		*max_lanes = 4;
+		*max_rate_per_lane = 12;
+		break;
+	case 0:
+	default:
+		*max_lanes = 0;
+		*max_rate_per_lane = 0;
+	}
+}
+
+static void drm_parse_ycbcr420_deep_color_info(struct hdmi_edid_data *data,
+					       const u8 *db)
+{
+	u8 dc_mask;
+	struct drm_hdmi_info *hdmi = &data->display_info.hdmi;
+
+	dc_mask = db[7] & DRM_EDID_YCBCR420_DC_MASK;
+	hdmi->y420_dc_modes |= dc_mask;
+}
+
+static void drm_parse_hdmi_forum_vsdb(struct hdmi_edid_data *data,
+				      const u8 *hf_vsdb)
+{
+	struct drm_display_info *display = &data->display_info;
+	struct drm_hdmi_info *hdmi = &display->hdmi;
+
+	if (hf_vsdb[6] & 0x80) {
+		hdmi->scdc.supported = true;
+		if (hf_vsdb[6] & 0x40)
+			hdmi->scdc.read_request = true;
+	}
+
+	/*
+	 * All HDMI 2.0 monitors must support scrambling at rates > 340 MHz.
+	 * And as per the spec, three factors confirm this:
+	 * * Availability of a HF-VSDB block in EDID (check)
+	 * * Non zero Max_TMDS_Char_Rate filed in HF-VSDB (let's check)
+	 * * SCDC support available (let's check)
+	 * Lets check it out.
+	 */
+
+	if (hf_vsdb[5]) {
+		/* max clock is 5000 KHz times block value */
+		u32 max_tmds_clock = hf_vsdb[5] * 5000;
+		struct drm_scdc *scdc = &hdmi->scdc;
+
+		if (max_tmds_clock > 340000) {
+			display->max_tmds_clock = max_tmds_clock;
+			debug("HF-VSDB: max TMDS clock %d kHz\n",
+			      display->max_tmds_clock);
+		}
+
+		if (scdc->supported) {
+			scdc->scrambling.supported = true;
+
+			/* Few sinks support scrambling for cloks < 340M */
+			if ((hf_vsdb[6] & 0x8))
+				scdc->scrambling.low_rates = true;
+		}
+	}
+
+	if (hf_vsdb[7]) {
+		u8 max_frl_rate;
+		u8 dsc_max_frl_rate;
+		u8 dsc_max_slices;
+		struct drm_hdmi_dsc_cap *hdmi_dsc = &hdmi->dsc_cap;
+
+		debug("hdmi_21 sink detected. parsing edid\n");
+		max_frl_rate = (hf_vsdb[7] & DRM_EDID_MAX_FRL_RATE_MASK) >> 4;
+		drm_get_max_frl_rate(max_frl_rate, &hdmi->max_lanes,
+				     &hdmi->max_frl_rate_per_lane);
+		hdmi_dsc->v_1p2 = hf_vsdb[11] & DRM_EDID_DSC_1P2;
+
+		if (hdmi_dsc->v_1p2) {
+			hdmi_dsc->native_420 = hf_vsdb[11] & DRM_EDID_DSC_NATIVE_420;
+			hdmi_dsc->all_bpp = hf_vsdb[11] & DRM_EDID_DSC_ALL_BPP;
+
+			if (hf_vsdb[11] & DRM_EDID_DSC_16BPC)
+				hdmi_dsc->bpc_supported = 16;
+			else if (hf_vsdb[11] & DRM_EDID_DSC_12BPC)
+				hdmi_dsc->bpc_supported = 12;
+			else if (hf_vsdb[11] & DRM_EDID_DSC_10BPC)
+				hdmi_dsc->bpc_supported = 10;
+			else
+				hdmi_dsc->bpc_supported = 0;
+
+			dsc_max_frl_rate = (hf_vsdb[12] & DRM_EDID_DSC_MAX_FRL_RATE_MASK) >> 4;
+			drm_get_max_frl_rate(dsc_max_frl_rate, &hdmi_dsc->max_lanes,
+					     &hdmi_dsc->max_frl_rate_per_lane);
+			hdmi_dsc->total_chunk_kbytes =
+				hf_vsdb[13] & DRM_EDID_DSC_TOTAL_CHUNK_KBYTES;
+
+			dsc_max_slices = hf_vsdb[12] & DRM_EDID_DSC_MAX_SLICES;
+			switch (dsc_max_slices) {
+			case 1:
+				hdmi_dsc->max_slices = 1;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 2:
+				hdmi_dsc->max_slices = 2;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 3:
+				hdmi_dsc->max_slices = 4;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 4:
+				hdmi_dsc->max_slices = 8;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 5:
+				hdmi_dsc->max_slices = 8;
+				hdmi_dsc->clk_per_slice = 400;
+				break;
+			case 6:
+				hdmi_dsc->max_slices = 12;
+				hdmi_dsc->clk_per_slice = 400;
+				break;
+			case 7:
+				hdmi_dsc->max_slices = 16;
+				hdmi_dsc->clk_per_slice = 400;
+				break;
+			case 0:
+			default:
+				hdmi_dsc->max_slices = 0;
+				hdmi_dsc->clk_per_slice = 0;
+			}
+		}
+	}
+
+	drm_parse_ycbcr420_deep_color_info(data, hf_vsdb);
+}
+
+/**
+ * drm_default_rgb_quant_range - default RGB quantization range
+ * @mode: display mode
+ *
+ * Determine the default RGB quantization range for the mode,
+ * as specified in CEA-861.
+ *
+ * Return: The default RGB quantization range for the mode
+ */
+enum hdmi_quantization_range
+drm_default_rgb_quant_range(struct drm_display_mode *mode)
+{
+	/* All CEA modes other than VIC 1 use limited quantization range. */
+	return drm_match_cea_mode(mode) > 1 ?
+		HDMI_QUANTIZATION_RANGE_LIMITED :
+		HDMI_QUANTIZATION_RANGE_FULL;
+}
+
+static void drm_parse_hdmi_deep_color_info(struct hdmi_edid_data *data,
+					   const u8 *hdmi)
+{
+	struct drm_display_info *info = &data->display_info;
+	unsigned int dc_bpc = 0;
+
+	/* HDMI supports at least 8 bpc */
+	info->bpc = 8;
+
+	if (cea_db_payload_len(hdmi) < 6)
+		return;
+
+	if (hdmi[6] & DRM_EDID_HDMI_DC_30) {
+		dc_bpc = 10;
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_30;
+		debug("HDMI sink does deep color 30.\n");
+	}
+
+	if (hdmi[6] & DRM_EDID_HDMI_DC_36) {
+		dc_bpc = 12;
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_36;
+		debug("HDMI sink does deep color 36.\n");
+	}
+
+	if (hdmi[6] & DRM_EDID_HDMI_DC_48) {
+		dc_bpc = 16;
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_48;
+		debug("HDMI sink does deep color 48.\n");
+	}
+
+	if (dc_bpc == 0) {
+		debug("No deep color support on this HDMI sink.\n");
+		return;
+	}
+
+	debug("Assigning HDMI sink color depth as %d bpc.\n", dc_bpc);
+	info->bpc = dc_bpc;
+
+	/* YCRCB444 is optional according to spec. */
+	if (hdmi[6] & DRM_EDID_HDMI_DC_Y444) {
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_Y444;
+		debug("HDMI sink does YCRCB444 in deep color.\n");
+	}
+
+	/*
+	 * Spec says that if any deep color mode is supported at all,
+	 * then deep color 36 bit must be supported.
+	 */
+	if (!(hdmi[6] & DRM_EDID_HDMI_DC_36))
+		debug("HDMI sink should do DC_36, but does not!\n");
+}
+
+/*
+ * Search EDID for CEA extension block.
+ */
+static u8 *drm_find_edid_extension(struct edid *edid, int ext_id)
+{
+	u8 *edid_ext = NULL;
+	int i;
+
+	/* No EDID or EDID extensions */
+	if (!edid || !edid->extensions)
+		return NULL;
+
+	/* Find CEA extension */
+	for (i = 0; i < edid->extensions; i++) {
+		edid_ext = (u8 *)edid + EDID_SIZE * (i + 1);
+		if (edid_ext[0] == ext_id)
+			break;
+	}
+
+	if (i == edid->extensions)
+		return NULL;
+
+	return edid_ext;
+}
+
+static u8 *drm_find_cea_extension(struct edid *edid)
+{
+	return drm_find_edid_extension(edid, 0x02);
+}
+
+#define AUDIO_BLOCK	0x01
+#define VIDEO_BLOCK     0x02
+#define VENDOR_BLOCK    0x03
+#define SPEAKER_BLOCK	0x04
+#define EDID_BASIC_AUDIO BIT(6)
+
+/**
+ * drm_detect_hdmi_monitor - detect whether monitor is HDMI
+ * @edid: monitor EDID information
+ *
+ * Parse the CEA extension according to CEA-861-B.
+ *
+ * Return: True if the monitor is HDMI, false if not or unknown.
+ */
+bool drm_detect_hdmi_monitor(struct edid *edid)
+{
+	u8 *edid_ext;
+	int i;
+	int start_offset, end_offset;
+
+	edid_ext = drm_find_cea_extension(edid);
+	if (!edid_ext)
+		return false;
+
+	if (cea_db_offsets(edid_ext, &start_offset, &end_offset))
+		return false;
+
+	/*
+	 * Because HDMI identifier is in Vendor Specific Block,
+	 * search it from all data blocks of CEA extension.
+	 */
+	for_each_cea_db(edid_ext, i, start_offset, end_offset) {
+		if (cea_db_is_hdmi_vsdb(&edid_ext[i]))
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * drm_detect_monitor_audio - check monitor audio capability
+ * @edid: EDID block to scan
+ *
+ * Monitor should have CEA extension block.
+ * If monitor has 'basic audio', but no CEA audio blocks, it's 'basic
+ * audio' only. If there is any audio extension block and supported
+ * audio format, assume at least 'basic audio' support, even if 'basic
+ * audio' is not defined in EDID.
+ *
+ * Return: True if the monitor supports audio, false otherwise.
+ */
+bool drm_detect_monitor_audio(struct edid *edid)
+{
+	u8 *edid_ext;
+	int i, j;
+	bool has_audio = false;
+	int start_offset, end_offset;
+
+	edid_ext = drm_find_cea_extension(edid);
+	if (!edid_ext)
+		goto end;
+
+	has_audio = ((edid_ext[3] & EDID_BASIC_AUDIO) != 0);
+
+	if (has_audio) {
+		printf("Monitor has basic audio support\n");
+		goto end;
+	}
+
+	if (cea_db_offsets(edid_ext, &start_offset, &end_offset))
+		goto end;
+
+	for_each_cea_db(edid_ext, i, start_offset, end_offset) {
+		if (cea_db_tag(&edid_ext[i]) == AUDIO_BLOCK) {
+			has_audio = true;
+			for (j = 1; j < cea_db_payload_len(&edid_ext[i]) + 1;
+			     j += 3)
+				debug("CEA audio format %d\n",
+				      (edid_ext[i + j] >> 3) & 0xf);
+			goto end;
+		}
+	}
+end:
+	return has_audio;
+}
+
+static void
+drm_parse_hdmi_vsdb_video(struct hdmi_edid_data *data, const u8 *db)
+{
+	struct drm_display_info *info = &data->display_info;
+	u8 len = cea_db_payload_len(db);
+
+	if (len >= 6)
+		info->dvi_dual = db[6] & 1;
+	if (len >= 7)
+		info->max_tmds_clock = db[7] * 5000;
+
+	drm_parse_hdmi_deep_color_info(data, db);
+}
+
+static void drm_parse_cea_ext(struct hdmi_edid_data *data,
+			      struct edid *edid)
+{
+	struct drm_display_info *info = &data->display_info;
+	const u8 *edid_ext;
+	int i, start, end;
+
+	edid_ext = drm_find_cea_extension(edid);
+	if (!edid_ext)
+		return;
+
+	info->cea_rev = edid_ext[1];
+
+	/* The existence of a CEA block should imply RGB support */
+	info->color_formats = DRM_COLOR_FORMAT_RGB444;
+	if (edid_ext[3] & EDID_CEA_YCRCB444)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB444;
+	if (edid_ext[3] & EDID_CEA_YCRCB422)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB422;
+
+	if (cea_db_offsets(edid_ext, &start, &end))
+		return;
+
+	for_each_cea_db(edid_ext, i, start, end) {
+		const u8 *db = &edid_ext[i];
+
+		if (cea_db_is_hdmi_vsdb(db))
+			drm_parse_hdmi_vsdb_video(data, db);
+		if (cea_db_is_hdmi_forum_vsdb(db))
+			drm_parse_hdmi_forum_vsdb(data, db);
+		if (cea_db_is_y420cmdb(db))
+			drm_parse_y420cmdb_bitmap(data, db);
+	}
+}
+
+static void drm_add_display_info(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct drm_display_info *info = &data->display_info;
+
+	info->width_mm = edid->width_cm * 10;
+	info->height_mm = edid->height_cm * 10;
+
+	/* driver figures it out in this case */
+	info->bpc = 0;
+	info->color_formats = 0;
+	info->cea_rev = 0;
+	info->max_tmds_clock = 0;
+	info->dvi_dual = false;
+	info->edid_hdmi_dc_modes = 0;
+
+	memset(&info->hdmi, 0, sizeof(info->hdmi));
+
+	if (edid->revision < 3)
+		return;
+
+	if (!(edid->input & DRM_EDID_INPUT_DIGITAL))
+		return;
+
+	drm_parse_cea_ext(data, edid);
+
+	/*
+	 * Digital sink with "DFP 1.x compliant TMDS" according to EDID 1.3?
+	 *
+	 * For such displays, the DFP spec 1.0, section 3.10 "EDID support"
+	 * tells us to assume 8 bpc color depth if the EDID doesn't have
+	 * extensions which tell otherwise.
+	 */
+	if ((info->bpc == 0) && (edid->revision < 4) &&
+	    (edid->input & DRM_EDID_DIGITAL_TYPE_DVI)) {
+		info->bpc = 8;
+		debug("Assigning DFP sink color depth as %d bpc.\n", info->bpc);
+	}
+
+	/* Only defined for 1.4 with digital displays */
+	if (edid->revision < 4)
+		return;
+
+	switch (edid->input & DRM_EDID_DIGITAL_DEPTH_MASK) {
+	case DRM_EDID_DIGITAL_DEPTH_6:
+		info->bpc = 6;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_8:
+		info->bpc = 8;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_10:
+		info->bpc = 10;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_12:
+		info->bpc = 12;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_14:
+		info->bpc = 14;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_16:
+		info->bpc = 16;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_UNDEF:
+	default:
+		info->bpc = 0;
+		break;
+	}
+
+	debug("Assigning EDID-1.4 digital sink color depth as %d bpc.\n",
+	      info->bpc);
+
+	info->color_formats |= DRM_COLOR_FORMAT_RGB444;
+	if (edid->features & DRM_EDID_FEATURE_RGB_YCRCB444)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB444;
+	if (edid->features & DRM_EDID_FEATURE_RGB_YCRCB422)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB422;
+}
+
+static
+int add_cea_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	const u8 *cea = drm_find_cea_extension(edid);
+	const u8 *db, *hdmi = NULL, *video = NULL;
+	u8 dbl, hdmi_len, video_len = 0;
+	int modes = 0;
+
+	if (cea && cea_revision(cea) >= 3) {
+		int i, start, end;
+
+		if (cea_db_offsets(cea, &start, &end))
+			return 0;
+
+		for_each_cea_db(cea, i, start, end) {
+			db = &cea[i];
+			dbl = cea_db_payload_len(db);
+
+			if (cea_db_tag(db) == EDID_CEA861_DB_VIDEO) {
+				video = db + 1;
+				video_len = dbl;
+				modes += do_cea_modes(data, video, dbl);
+			} else if (cea_db_is_hdmi_vsdb(db)) {
+				hdmi = db;
+				hdmi_len = dbl;
+			} else if (cea_db_is_y420vdb(db)) {
+				const u8 *vdb420 = &db[2];
+
+				/* Add 4:2:0(only) modes present in EDID */
+				modes += do_y420vdb_modes(data, vdb420,
+							  dbl - 1);
+			}
+		}
+	}
+
+	/*
+	 * We parse the HDMI VSDB after having added the cea modes as we will
+	 * be patching their flags when the sink supports stereo 3D.
+	 */
+	if (hdmi)
+		modes += do_hdmi_vsdb_modes(hdmi, hdmi_len, video,
+					    video_len, data);
+
+	return modes;
+}
+
+typedef void detailed_cb(struct detailed_timing *timing, void *closure);
+
+static void
+cea_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)
+{
+	int i, n = 0;
+	u8 d = ext[0x02];
+	u8 *det_base = ext + d;
+
+	n = (127 - d) / 18;
+	for (i = 0; i < n; i++)
+		cb((struct detailed_timing *)(det_base + 18 * i), closure);
+}
+
+static void
+vtb_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)
+{
+	unsigned int i, n = min((int)ext[0x02], 6);
+	u8 *det_base = ext + 5;
+
+	if (ext[0x01] != 1)
+		return; /* unknown version */
+
+	for (i = 0; i < n; i++)
+		cb((struct detailed_timing *)(det_base + 18 * i), closure);
+}
+
+static void
+drm_for_each_detailed_block(u8 *raw_edid, detailed_cb *cb, void *closure)
+{
+	int i;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if (!edid)
+		return;
+
+	for (i = 0; i < EDID_DETAILED_TIMINGS; i++)
+		cb(&edid->detailed_timings[i], closure);
+
+	for (i = 1; i <= raw_edid[0x7e]; i++) {
+		u8 *ext = raw_edid + (i * EDID_SIZE);
+
+		switch (*ext) {
+		case CEA_EXT:
+			cea_for_each_detailed_block(ext, cb, closure);
+			break;
+		case VTB_EXT:
+			vtb_for_each_detailed_block(ext, cb, closure);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/*
+ * EDID is delightfully ambiguous about how interlaced modes are to be
+ * encoded.  Our internal representation is of frame height, but some
+ * HDTV detailed timings are encoded as field height.
+ *
+ * The format list here is from CEA, in frame size.  Technically we
+ * should be checking refresh rate too.  Whatever.
+ */
+static void
+drm_mode_do_interlace_quirk(struct drm_display_mode *mode,
+			    struct detailed_pixel_timing *pt)
+{
+	int i;
+
+	static const struct {
+		int w, h;
+	} cea_interlaced[] = {
+		{ 1920, 1080 },
+		{  720,  480 },
+		{ 1440,  480 },
+		{ 2880,  480 },
+		{  720,  576 },
+		{ 1440,  576 },
+		{ 2880,  576 },
+	};
+
+	if (!(pt->misc & DRM_EDID_PT_INTERLACED))
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(cea_interlaced); i++) {
+		if ((mode->hdisplay == cea_interlaced[i].w) &&
+		    (mode->vdisplay == cea_interlaced[i].h / 2)) {
+			mode->vdisplay *= 2;
+			mode->vsync_start *= 2;
+			mode->vsync_end *= 2;
+			mode->vtotal *= 2;
+			mode->vtotal |= 1;
+		}
+	}
+
+	mode->flags |= DRM_MODE_FLAG_INTERLACE;
+}
+
+/**
+ * drm_mode_detailed - create a new mode from an EDID detailed timing section
+ * @edid: EDID block
+ * @timing: EDID detailed timing info
+ * @quirks: quirks to apply
+ *
+ * An EDID detailed timing block contains enough info for us to create and
+ * return a new struct drm_display_mode.
+ */
+static
+struct drm_display_mode *drm_mode_detailed(struct edid *edid,
+					   struct detailed_timing *timing,
+					   u32 quirks)
+{
+	struct drm_display_mode *mode;
+	struct detailed_pixel_timing *pt = &timing->data.pixel_data;
+	unsigned hactive = (pt->hactive_hblank_hi & 0xf0) << 4 | pt->hactive_lo;
+	unsigned vactive = (pt->vactive_vblank_hi & 0xf0) << 4 | pt->vactive_lo;
+	unsigned hblank = (pt->hactive_hblank_hi & 0xf) << 8 | pt->hblank_lo;
+	unsigned vblank = (pt->vactive_vblank_hi & 0xf) << 8 | pt->vblank_lo;
+	unsigned hsync_offset =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0xc0) << 2 |
+		pt->hsync_offset_lo;
+	unsigned hsync_pulse_width =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0x30) << 4 |
+		pt->hsync_pulse_width_lo;
+	unsigned vsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc) <<
+		2 | pt->vsync_offset_pulse_width_lo >> 4;
+	unsigned vsync_pulse_width =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0x3) << 4 |
+		(pt->vsync_offset_pulse_width_lo & 0xf);
+
+	/* ignore tiny modes */
+	if (hactive < 64 || vactive < 64)
+		return NULL;
+
+	if (pt->misc & DRM_EDID_PT_STEREO) {
+		debug("stereo mode not supported\n");
+		return NULL;
+	}
+	if (!(pt->misc & DRM_EDID_PT_SEPARATE_SYNC))
+		debug("composite sync not supported\n");
+
+	/* it is incorrect if hsync/vsync width is zero */
+	if (!hsync_pulse_width || !vsync_pulse_width) {
+		debug("Incorrect Detailed timing. ");
+		debug("Wrong Hsync/Vsync pulse width\n");
+		return NULL;
+	}
+
+	if (quirks & EDID_QUIRK_FORCE_REDUCED_BLANKING) {
+		mode = drm_cvt_mode(hactive, vactive, 60, true, false, false);
+		if (!mode)
+			return NULL;
+
+		goto set_refresh;
+	}
+
+	mode = drm_mode_create();
+	if (!mode)
+		return NULL;
+
+	if (quirks & EDID_QUIRK_135_CLOCK_TOO_HIGH)
+		timing->pixel_clock = cpu_to_le16(1088);
+
+	mode->clock = le16_to_cpu(timing->pixel_clock) * 10;
+
+	mode->hdisplay = hactive;
+	mode->hsync_start = mode->hdisplay + hsync_offset;
+	mode->hsync_end = mode->hsync_start + hsync_pulse_width;
+	mode->htotal = mode->hdisplay + hblank;
+
+	mode->vdisplay = vactive;
+	mode->vsync_start = mode->vdisplay + vsync_offset;
+	mode->vsync_end = mode->vsync_start + vsync_pulse_width;
+	mode->vtotal = mode->vdisplay + vblank;
+
+	/* Some EDIDs have bogus h/vtotal values */
+	if (mode->hsync_end > mode->htotal)
+		mode->htotal = mode->hsync_end + 1;
+	if (mode->vsync_end > mode->vtotal)
+		mode->vtotal = mode->vsync_end + 1;
+
+	drm_mode_do_interlace_quirk(mode, pt);
+
+	if (quirks & EDID_QUIRK_DETAILED_SYNC_PP)
+		pt->misc |= DRM_EDID_PT_HSYNC_POSITIVE |
+			DRM_EDID_PT_VSYNC_POSITIVE;
+
+	mode->flags |= (pt->misc & DRM_EDID_PT_HSYNC_POSITIVE) ?
+		DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |= (pt->misc & DRM_EDID_PT_VSYNC_POSITIVE) ?
+		DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+
+set_refresh:
+
+	mode->type = DRM_MODE_TYPE_DRIVER;
+	mode->vrefresh = drm_get_vrefresh(mode);
+
+	return mode;
+}
+
+/*
+ * Calculate the alternate clock for the CEA mode
+ * (60Hz vs. 59.94Hz etc.)
+ */
+static unsigned int
+cea_mode_alternate_clock(const struct drm_display_mode *cea_mode)
+{
+	unsigned int clock = cea_mode->clock;
+
+	if (cea_mode->vrefresh % 6 != 0)
+		return clock;
+
+	/*
+	 * edid_cea_modes contains the 59.94Hz
+	 * variant for 240 and 480 line modes,
+	 * and the 60Hz variant otherwise.
+	 */
+	if (cea_mode->vdisplay == 240 || cea_mode->vdisplay == 480)
+		clock = DIV_ROUND_CLOSEST(clock * 1001, 1000);
+	else
+		clock = DIV_ROUND_CLOSEST(clock * 1000, 1001);
+
+	return clock;
+}
+
+/**
+ * drm_mode_equal_no_clocks_no_stereo - test modes for equality
+ * @mode1: first mode
+ * @mode2: second mode
+ *
+ * Check to see if @mode1 and @mode2 are equivalent, but
+ * don't check the pixel clocks nor the stereo layout.
+ *
+ * Returns:
+ * True if the modes are equal, false otherwise.
+ */
+
+static
+bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
+					const struct drm_display_mode *mode2)
+{
+	unsigned int flags_mask =
+		~(DRM_MODE_FLAG_3D_MASK | DRM_MODE_FLAG_420_MASK);
+
+	if (mode1->hdisplay == mode2->hdisplay &&
+	    mode1->hsync_start == mode2->hsync_start &&
+	    mode1->hsync_end == mode2->hsync_end &&
+	    mode1->htotal == mode2->htotal &&
+	    mode1->vdisplay == mode2->vdisplay &&
+	    mode1->vsync_start == mode2->vsync_start &&
+	    mode1->vsync_end == mode2->vsync_end &&
+	    mode1->vtotal == mode2->vtotal &&
+	    mode1->vscan == mode2->vscan &&
+	    (mode1->flags & flags_mask) == (mode2->flags & flags_mask))
+		return true;
+
+	return false;
+}
+
+/**
+ * drm_mode_equal_no_clocks - test modes for equality
+ * @mode1: first mode
+ * @mode2: second mode
+ *
+ * Check to see if @mode1 and @mode2 are equivalent, but
+ * don't check the pixel clocks.
+ *
+ * Returns:
+ * True if the modes are equal, false otherwise.
+ */
+static bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1,
+				     const struct drm_display_mode *mode2)
+{
+	if ((mode1->flags & DRM_MODE_FLAG_3D_MASK) !=
+	    (mode2->flags & DRM_MODE_FLAG_3D_MASK))
+		return false;
+
+	return drm_mode_equal_no_clocks_no_stereo(mode1, mode2);
+}
+
+static
+u8 drm_match_cea_mode_clock_tolerance(const struct drm_display_mode *to_match,
+				      unsigned int clock_tolerance)
+{
+	u8 vic;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (vic = 1; vic < ARRAY_SIZE(edid_cea_modes); vic++) {
+		const struct drm_display_mode *cea_mode = &edid_cea_modes[vic];
+		unsigned int clock1, clock2;
+
+		/* Check both 60Hz and 59.94Hz */
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+
+		if (abs(to_match->clock - clock1) > clock_tolerance &&
+		    abs(to_match->clock - clock2) > clock_tolerance)
+			continue;
+
+		if (drm_mode_equal_no_clocks(to_match, cea_mode))
+			return vic;
+	}
+
+	return 0;
+}
+
+static unsigned int
+hdmi_mode_alternate_clock(const struct drm_display_mode *hdmi_mode)
+{
+	if (hdmi_mode->vdisplay == 4096 && hdmi_mode->hdisplay == 2160)
+		return hdmi_mode->clock;
+
+	return cea_mode_alternate_clock(hdmi_mode);
+}
+
+static
+u8 drm_match_hdmi_mode_clock_tolerance(const struct drm_display_mode *to_match,
+				       unsigned int clock_tolerance)
+{
+	u8 vic;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {
+		const struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];
+		unsigned int clock1, clock2;
+
+		/* Make sure to also match alternate clocks */
+		clock1 = hdmi_mode->clock;
+		clock2 = hdmi_mode_alternate_clock(hdmi_mode);
+
+		if (abs(to_match->clock - clock1) > clock_tolerance &&
+		    abs(to_match->clock - clock2) > clock_tolerance)
+			continue;
+
+		if (drm_mode_equal_no_clocks(to_match, hdmi_mode))
+			return vic;
+	}
+
+	return 0;
+}
+
+static void fixup_detailed_cea_mode_clock(struct drm_display_mode *mode)
+{
+	const struct drm_display_mode *cea_mode;
+	int clock1, clock2, clock;
+	u8 vic;
+	const char *type;
+
+	/*
+	 * allow 5kHz clock difference either way to account for
+	 * the 10kHz clock resolution limit of detailed timings.
+	 */
+	vic = drm_match_cea_mode_clock_tolerance(mode, 5);
+	if (drm_valid_cea_vic(vic)) {
+		type = "CEA";
+		cea_mode = &edid_cea_modes[vic];
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+	} else {
+		vic = drm_match_hdmi_mode_clock_tolerance(mode, 5);
+		if (drm_valid_hdmi_vic(vic)) {
+			type = "HDMI";
+			cea_mode = &edid_4k_modes[vic];
+			clock1 = cea_mode->clock;
+			clock2 = hdmi_mode_alternate_clock(cea_mode);
+		} else {
+			return;
+		}
+	}
+
+	/* pick whichever is closest */
+	if (abs(mode->clock - clock1) < abs(mode->clock - clock2))
+		clock = clock1;
+	else
+		clock = clock2;
+
+	if (mode->clock == clock)
+		return;
+
+	debug("detailed mode matches %s VIC %d, adjusting clock %d -> %d\n",
+	      type, vic, mode->clock, clock);
+	mode->clock = clock;
+}
+
+static void
+do_detailed_mode(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct drm_display_mode *newmode;
+
+	if (timing->pixel_clock) {
+		newmode = drm_mode_detailed(
+					    closure->edid, timing,
+					    closure->quirks);
+		if (!newmode)
+			return;
+
+		if (closure->preferred)
+			newmode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		/*
+		 * Detailed modes are limited to 10kHz pixel clock resolution,
+		 * so fix up anything that looks like CEA/HDMI mode,
+		 * but the clock is just slightly off.
+		 */
+		fixup_detailed_cea_mode_clock(newmode);
+		drm_add_hdmi_modes(closure->data, newmode);
+		drm_mode_destroy(newmode);
+		closure->modes++;
+		closure->preferred = 0;
+	}
+}
+
+/*
+ * add_detailed_modes - Add modes from detailed timings
+ * @data: attached data
+ * @edid: EDID block to scan
+ * @quirks: quirks to apply
+ */
+static int
+add_detailed_modes(struct hdmi_edid_data *data, struct edid *edid,
+		   u32 quirks)
+{
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+		.preferred = 1,
+		.quirks = quirks,
+	};
+
+	if (closure.preferred && !version_greater(edid, 1, 3))
+		closure.preferred =
+			(edid->features & DRM_EDID_FEATURE_PREFERRED_TIMING);
+
+	drm_for_each_detailed_block((u8 *)edid, do_detailed_mode, &closure);
+
+	return closure.modes;
+}
+
+static int drm_cvt_modes(struct hdmi_edid_data *data,
+			 struct detailed_timing *timing)
+{
+	int i, j, modes = 0;
+	struct drm_display_mode *newmode;
+	struct cvt_timing *cvt;
+	const int rates[] = { 60, 85, 75, 60, 50 };
+	const u8 empty[3] = { 0, 0, 0 };
+
+	for (i = 0; i < 4; i++) {
+		int uninitialized_var(width), height;
+
+		cvt = &timing->data.other_data.data.cvt[i];
+
+		if (!memcmp(cvt->code, empty, 3))
+			continue;
+
+		height = (cvt->code[0] + ((cvt->code[1] & 0xf0) << 4) + 1) * 2;
+		switch (cvt->code[1] & 0x0c) {
+		case 0x00:
+			width = height * 4 / 3;
+			break;
+		case 0x04:
+			width = height * 16 / 9;
+			break;
+		case 0x08:
+			width = height * 16 / 10;
+			break;
+		case 0x0c:
+			width = height * 15 / 9;
+			break;
+		}
+
+		for (j = 1; j < 5; j++) {
+			if (cvt->code[2] & (1 << j)) {
+				newmode = drm_cvt_mode(width, height,
+						       rates[j], j == 0,
+						       false, false);
+				if (newmode) {
+					drm_add_hdmi_modes(data, newmode);
+					modes++;
+					drm_mode_destroy(newmode);
+				}
+			}
+		}
+	}
+
+	return modes;
+}
+
+static void
+do_cvt_mode(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+
+	if (data->type == EDID_DETAIL_CVT_3BYTE)
+		closure->modes += drm_cvt_modes(closure->data, timing);
+}
+
+static int
+add_cvt_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	if (version_greater(edid, 1, 2))
+		drm_for_each_detailed_block((u8 *)edid, do_cvt_mode, &closure);
+
+	/* XXX should also look for CVT codes in VTB blocks */
+
+	return closure.modes;
+}
+
+static void
+find_gtf2(struct detailed_timing *t, void *data)
+{
+	u8 *r = (u8 *)t;
+
+	if (r[3] == EDID_DETAIL_MONITOR_RANGE && r[10] == 0x02)
+		*(u8 **)data = r;
+}
+
+/* Secondary GTF curve kicks in above some break frequency */
+static int
+drm_gtf2_hbreak(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? (r[12] * 2) : 0;
+}
+
+static int
+drm_gtf2_2c(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[13] : 0;
+}
+
+static int
+drm_gtf2_m(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? (r[15] << 8) + r[14] : 0;
+}
+
+static int
+drm_gtf2_k(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[16] : 0;
+}
+
+static int
+drm_gtf2_2j(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[17] : 0;
+}
+
+/**
+ * standard_timing_level - get std. timing level(CVT/GTF/DMT)
+ * @edid: EDID block to scan
+ */
+static int standard_timing_level(struct edid *edid)
+{
+	if (edid->revision >= 2) {
+		if (edid->revision >= 4 &&
+		    (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF))
+			return LEVEL_CVT;
+		if (drm_gtf2_hbreak(edid))
+			return LEVEL_GTF2;
+		return LEVEL_GTF;
+	}
+	return LEVEL_DMT;
+}
+
+/*
+ * 0 is reserved.  The spec says 0x01 fill for unused timings.  Some old
+ * monitors fill with ascii space (0x20) instead.
+ */
+static int
+bad_std_timing(u8 a, u8 b)
+{
+	return (a == 0x00 && b == 0x00) ||
+	       (a == 0x01 && b == 0x01) ||
+	       (a == 0x20 && b == 0x20);
+}
+
+static void
+is_rb(struct detailed_timing *t, void *data)
+{
+	u8 *r = (u8 *)t;
+
+	if (r[3] == EDID_DETAIL_MONITOR_RANGE)
+		if (r[15] & 0x10)
+			*(bool *)data = true;
+}
+
+/* EDID 1.4 defines this explicitly.  For EDID 1.3, we guess, badly. */
+static bool
+drm_monitor_supports_rb(struct edid *edid)
+{
+	if (edid->revision >= 4) {
+		bool ret = false;
+
+		drm_for_each_detailed_block((u8 *)edid, is_rb, &ret);
+		return ret;
+	}
+
+	return ((edid->input & DRM_EDID_INPUT_DIGITAL) != 0);
+}
+
+static bool
+mode_is_rb(const struct drm_display_mode *mode)
+{
+	return (mode->htotal - mode->hdisplay == 160) &&
+	       (mode->hsync_end - mode->hdisplay == 80) &&
+	       (mode->hsync_end - mode->hsync_start == 32) &&
+	       (mode->vsync_start - mode->vdisplay == 3);
+}
+
+/*
+ * drm_mode_find_dmt - Create a copy of a mode if present in DMT
+ * @hsize: Mode width
+ * @vsize: Mode height
+ * @fresh: Mode refresh rate
+ * @rb: Mode reduced-blanking-ness
+ *
+ * Walk the DMT mode list looking for a match for the given parameters.
+ *
+ * Return: A newly allocated copy of the mode, or NULL if not found.
+ */
+static struct drm_display_mode *drm_mode_find_dmt(
+					   int hsize, int vsize, int fresh,
+					   bool rb)
+{
+	int i;
+	struct drm_display_mode *newmode;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {
+		const struct drm_display_mode *ptr = &drm_dmt_modes[i];
+
+		if (hsize != ptr->hdisplay)
+			continue;
+		if (vsize != ptr->vdisplay)
+			continue;
+		if (fresh != drm_get_vrefresh(ptr))
+			continue;
+		if (rb != mode_is_rb(ptr))
+			continue;
+
+		newmode = drm_mode_create();
+		*newmode = *ptr;
+		return newmode;
+	}
+
+	return NULL;
+}
+
+static struct drm_display_mode *
+drm_gtf_mode_complex(int hdisplay, int vdisplay,
+		     int vrefresh, bool interlaced, int margins,
+		     int GTF_M, int GTF_2C, int GTF_K, int GTF_2J)
+{	/* 1) top/bottom margin size (% of height) - default: 1.8, */
+#define	GTF_MARGIN_PERCENTAGE		18
+	/* 2) character cell horizontal granularity (pixels) - default 8 */
+#define	GTF_CELL_GRAN			8
+	/* 3) Minimum vertical porch (lines) - default 3 */
+#define	GTF_MIN_V_PORCH			1
+	/* width of vsync in lines */
+#define V_SYNC_RQD			3
+	/* width of hsync as % of total line */
+#define H_SYNC_PERCENT			8
+	/* min time of vsync + back porch (microsec) */
+#define MIN_VSYNC_PLUS_BP		550
+	/* C' and M' are part of the Blanking Duty Cycle computation */
+#define GTF_C_PRIME	((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)
+#define GTF_M_PRIME	(GTF_K * GTF_M / 256)
+	struct drm_display_mode *drm_mode;
+	unsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;
+	int top_margin, bottom_margin;
+	int interlace;
+	unsigned int hfreq_est;
+	int vsync_plus_bp;
+	unsigned int vtotal_lines;
+	int left_margin, right_margin;
+	unsigned int total_active_pixels, ideal_duty_cycle;
+	unsigned int hblank, total_pixels, pixel_freq;
+	int hsync, hfront_porch, vodd_front_porch_lines;
+	unsigned int tmp1, tmp2;
+
+	drm_mode = drm_mode_create();
+	if (!drm_mode)
+		return NULL;
+
+	/* 1. In order to give correct results, the number of horizontal
+	 * pixels requested is first processed to ensure that it is divisible
+	 * by the character size, by rounding it to the nearest character
+	 * cell boundary:
+	 */
+	hdisplay_rnd = (hdisplay + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;
+	hdisplay_rnd = hdisplay_rnd * GTF_CELL_GRAN;
+
+	/* 2. If interlace is requested, the number of vertical lines assumed
+	 * by the calculation must be halved, as the computation calculates
+	 * the number of vertical lines per field.
+	 */
+	if (interlaced)
+		vdisplay_rnd = vdisplay / 2;
+	else
+		vdisplay_rnd = vdisplay;
+
+	/* 3. Find the frame rate required: */
+	if (interlaced)
+		vfieldrate_rqd = vrefresh * 2;
+	else
+		vfieldrate_rqd = vrefresh;
+
+	/* 4. Find number of lines in Top margin: */
+	top_margin = 0;
+	if (margins)
+		top_margin = (vdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /
+				1000;
+	/* 5. Find number of lines in bottom margin: */
+	bottom_margin = top_margin;
+
+	/* 6. If interlace is required, then set variable interlace: */
+	if (interlaced)
+		interlace = 1;
+	else
+		interlace = 0;
+
+	/* 7. Estimate the Horizontal frequency */
+	{
+		tmp1 = (1000000  - MIN_VSYNC_PLUS_BP * vfieldrate_rqd) / 500;
+		tmp2 = (vdisplay_rnd + 2 * top_margin + GTF_MIN_V_PORCH) *
+				2 + interlace;
+		hfreq_est = (tmp2 * 1000 * vfieldrate_rqd) / tmp1;
+	}
+
+	/* 8. Find the number of lines in V sync + back porch */
+	/* [V SYNC+BP] = RINT(([MIN VSYNC+BP] * hfreq_est / 1000000)) */
+	vsync_plus_bp = MIN_VSYNC_PLUS_BP * hfreq_est / 1000;
+	vsync_plus_bp = (vsync_plus_bp + 500) / 1000;
+	/*  9. Find the number of lines in V back porch alone:
+	 *	vback_porch = vsync_plus_bp - V_SYNC_RQD;
+	 */
+	/*  10. Find the total number of lines in Vertical field period: */
+	vtotal_lines = vdisplay_rnd + top_margin + bottom_margin +
+			vsync_plus_bp + GTF_MIN_V_PORCH;
+	/*  11. Estimate the Vertical field frequency:
+	 *  vfieldrate_est = hfreq_est / vtotal_lines;
+	 */
+
+	/*  12. Find the actual horizontal period:
+	 *	hperiod = 1000000 / (vfieldrate_rqd * vtotal_lines);
+	 */
+	/*  13. Find the actual Vertical field frequency:
+	 *	vfield_rate = hfreq_est / vtotal_lines;
+	 */
+	/*  14. Find the Vertical frame frequency:
+	 *	if (interlaced)
+	 *		vframe_rate = vfield_rate / 2;
+	 *	else
+	 *		vframe_rate = vfield_rate;
+	 */
+	/*  15. Find number of pixels in left margin: */
+	if (margins)
+		left_margin = (hdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /
+				1000;
+	else
+		left_margin = 0;
+
+	/* 16.Find number of pixels in right margin: */
+	right_margin = left_margin;
+	/* 17.Find total number of active pixels in image and left and right */
+	total_active_pixels = hdisplay_rnd + left_margin + right_margin;
+	/* 18.Find the ideal blanking duty cycle from blanking duty cycle */
+	ideal_duty_cycle = GTF_C_PRIME * 1000 -
+				(GTF_M_PRIME * 1000000 / hfreq_est);
+	/* 19.Find the number of pixels in the blanking time to the nearest
+	 * double character cell:
+	 */
+	hblank = total_active_pixels * ideal_duty_cycle /
+			(100000 - ideal_duty_cycle);
+	hblank = (hblank + GTF_CELL_GRAN) / (2 * GTF_CELL_GRAN);
+	hblank = hblank * 2 * GTF_CELL_GRAN;
+	/* 20.Find total number of pixels: */
+	total_pixels = total_active_pixels + hblank;
+	/* 21.Find pixel clock frequency: */
+	pixel_freq = total_pixels * hfreq_est / 1000;
+	/* Stage 1 computations are now complete; I should really pass
+	 * the results to another function and do the Stage 2 computations,
+	 * but I only need a few more values so I'll just append the
+	 * computations here for now
+	 */
+
+	/* 17. Find the number of pixels in the horizontal sync period: */
+	hsync = H_SYNC_PERCENT * total_pixels / 100;
+	hsync = (hsync + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;
+	hsync = hsync * GTF_CELL_GRAN;
+	/* 18. Find the number of pixels in horizontal front porch period */
+	hfront_porch = hblank / 2 - hsync;
+	/*  36. Find the number of lines in the odd front porch period: */
+	vodd_front_porch_lines = GTF_MIN_V_PORCH;
+
+	/* finally, pack the results in the mode struct */
+	drm_mode->hdisplay = hdisplay_rnd;
+	drm_mode->hsync_start = hdisplay_rnd + hfront_porch;
+	drm_mode->hsync_end = drm_mode->hsync_start + hsync;
+	drm_mode->htotal = total_pixels;
+	drm_mode->vdisplay = vdisplay_rnd;
+	drm_mode->vsync_start = vdisplay_rnd + vodd_front_porch_lines;
+	drm_mode->vsync_end = drm_mode->vsync_start + V_SYNC_RQD;
+	drm_mode->vtotal = vtotal_lines;
+
+	drm_mode->clock = pixel_freq;
+
+	if (interlaced) {
+		drm_mode->vtotal *= 2;
+		drm_mode->flags |= DRM_MODE_FLAG_INTERLACE;
+	}
+
+	if (GTF_M == 600 && GTF_2C == 80 && GTF_K == 128 && GTF_2J == 40)
+		drm_mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;
+	else
+		drm_mode->flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC;
+
+	return drm_mode;
+}
+
+/**
+ * drm_gtf_mode - create the mode based on the GTF algorithm
+ * @hdisplay: hdisplay size
+ * @vdisplay: vdisplay size
+ * @vrefresh: vrefresh rate.
+ * @interlaced: whether to compute an interlaced mode
+ * @margins: desired margin (borders) size
+ *
+ * return the mode based on GTF algorithm
+ *
+ * This function is to create the mode based on the GTF algorithm.
+ * Generalized Timing Formula is derived from:
+ *	GTF Spreadsheet by Andy Morrish (1/5/97)
+ *	available at http://www.vesa.org
+ *
+ * And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
+ * What I have done is to translate it by using integer calculation.
+ * I also refer to the function of fb_get_mode in the file of
+ * drivers/video/fbmon.c
+ *
+ * Standard GTF parameters:
+ * M = 600
+ * C = 40
+ * K = 128
+ * J = 20
+ *
+ * Returns:
+ * The modeline based on the GTF algorithm stored in a drm_display_mode object.
+ * The display mode object is allocated with drm_mode_create(). Returns NULL
+ * when no mode could be allocated.
+ */
+static struct drm_display_mode *
+drm_gtf_mode(int hdisplay, int vdisplay, int vrefresh,
+	     bool interlaced, int margins)
+{
+	return drm_gtf_mode_complex(hdisplay, vdisplay, vrefresh,
+				    interlaced, margins,
+				    600, 40 * 2, 128, 20 * 2);
+}
+
+/** drm_mode_hsync - get the hsync of a mode
+ * @mode: mode
+ *
+ * Returns:
+ * @modes's hsync rate in kHz, rounded to the nearest integer. Calculates the
+ * value first if it is not yet set.
+ */
+static int drm_mode_hsync(const struct drm_display_mode *mode)
+{
+	unsigned int calc_val;
+
+	if (mode->htotal < 0)
+		return 0;
+
+	calc_val = (mode->clock * 1000) / mode->htotal; /* hsync in Hz */
+	calc_val += 500;				/* round to 1000Hz */
+	calc_val /= 1000;				/* truncate to kHz */
+
+	return calc_val;
+}
+
+/**
+ * drm_mode_std - convert standard mode info (width, height, refresh) into mode
+ * @data: the structure that save parsed hdmi edid data
+ * @edid: EDID block to scan
+ * @t: standard timing params
+ *
+ * Take the standard timing params (in this case width, aspect, and refresh)
+ * and convert them into a real mode using CVT/GTF/DMT.
+ */
+static struct drm_display_mode *
+drm_mode_std(struct hdmi_edid_data *data, struct edid *edid,
+	     struct std_timing *t)
+{
+	struct drm_display_mode *mode = NULL;
+	int i, hsize, vsize;
+	int vrefresh_rate;
+	int num = data->modes;
+	unsigned aspect_ratio = (t->vfreq_aspect & EDID_TIMING_ASPECT_MASK)
+		>> EDID_TIMING_ASPECT_SHIFT;
+	unsigned vfreq = (t->vfreq_aspect & EDID_TIMING_VFREQ_MASK)
+		>> EDID_TIMING_VFREQ_SHIFT;
+	int timing_level = standard_timing_level(edid);
+
+	if (bad_std_timing(t->hsize, t->vfreq_aspect))
+		return NULL;
+
+	/* According to the EDID spec, the hdisplay = hsize * 8 + 248 */
+	hsize = t->hsize * 8 + 248;
+	/* vrefresh_rate = vfreq + 60 */
+	vrefresh_rate = vfreq + 60;
+	/* the vdisplay is calculated based on the aspect ratio */
+	if (aspect_ratio == 0) {
+		if (edid->revision < 3)
+			vsize = hsize;
+		else
+			vsize = (hsize * 10) / 16;
+	} else if (aspect_ratio == 1) {
+		vsize = (hsize * 3) / 4;
+	} else if (aspect_ratio == 2) {
+		vsize = (hsize * 4) / 5;
+	} else {
+		vsize = (hsize * 9) / 16;
+	}
+
+	/* HDTV hack, part 1 */
+	if (vrefresh_rate == 60 &&
+	    ((hsize == 1360 && vsize == 765) ||
+	     (hsize == 1368 && vsize == 769))) {
+		hsize = 1366;
+		vsize = 768;
+	}
+
+	/*
+	 * If we already has a mode for this size and refresh
+	 * rate (because it came from detailed or CVT info), use that
+	 * instead.  This way we don't have to guess at interlace or
+	 * reduced blanking.
+	 */
+	for (i = 0; i < num; i++)
+		if (data->mode_buf[i].hdisplay == hsize &&
+		    data->mode_buf[i].vdisplay == vsize &&
+		    drm_get_vrefresh(&data->mode_buf[i]) == vrefresh_rate)
+			return NULL;
+
+	/* HDTV hack, part 2 */
+	if (hsize == 1366 && vsize == 768 && vrefresh_rate == 60) {
+		mode = drm_cvt_mode(1366, 768, vrefresh_rate, 0, 0,
+				    false);
+		mode->hdisplay = 1366;
+		mode->hsync_start = mode->hsync_start - 1;
+		mode->hsync_end = mode->hsync_end - 1;
+		return mode;
+	}
+
+	/* check whether it can be found in default mode table */
+	if (drm_monitor_supports_rb(edid)) {
+		mode = drm_mode_find_dmt(hsize, vsize, vrefresh_rate,
+					 true);
+		if (mode)
+			return mode;
+	}
+
+	mode = drm_mode_find_dmt(hsize, vsize, vrefresh_rate, false);
+	if (mode)
+		return mode;
+
+	/* okay, generate it */
+	switch (timing_level) {
+	case LEVEL_DMT:
+		break;
+	case LEVEL_GTF:
+		mode = drm_gtf_mode(hsize, vsize, vrefresh_rate, 0, 0);
+		break;
+	case LEVEL_GTF2:
+		/*
+		 * This is potentially wrong if there's ever a monitor with
+		 * more than one ranges section, each claiming a different
+		 * secondary GTF curve.  Please don't do that.
+		 */
+		mode = drm_gtf_mode(hsize, vsize, vrefresh_rate, 0, 0);
+		if (!mode)
+			return NULL;
+		if (drm_mode_hsync(mode) > drm_gtf2_hbreak(edid)) {
+			drm_mode_destroy(mode);
+			mode = drm_gtf_mode_complex(hsize, vsize,
+						    vrefresh_rate, 0, 0,
+						    drm_gtf2_m(edid),
+						    drm_gtf2_2c(edid),
+						    drm_gtf2_k(edid),
+						    drm_gtf2_2j(edid));
+		}
+		break;
+	case LEVEL_CVT:
+		mode = drm_cvt_mode(hsize, vsize, vrefresh_rate, 0, 0,
+				    false);
+		break;
+	}
+
+	return mode;
+}
+
+static void
+do_standard_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+	struct edid *edid = closure->edid;
+
+	if (data->type == EDID_DETAIL_STD_MODES) {
+		int i;
+
+		for (i = 0; i < 6; i++) {
+			struct std_timing *std;
+			struct drm_display_mode *newmode;
+
+			std = &data->data.timings[i];
+			newmode = drm_mode_std(closure->data, edid, std);
+			if (newmode) {
+				drm_add_hdmi_modes(closure->data, newmode);
+				closure->modes++;
+				drm_mode_destroy(newmode);
+			}
+		}
+	}
+}
+
+/**
+ * add_standard_modes - get std. modes from EDID and add them
+ * @data: data to add mode(s) to
+ * @edid: EDID block to scan
+ *
+ * Standard modes can be calculated using the appropriate standard (DMT,
+ * GTF or CVT. Grab them from @edid and add them to the list.
+ */
+static int
+add_standard_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	int i, modes = 0;
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	for (i = 0; i < EDID_STD_TIMINGS; i++) {
+		struct drm_display_mode *newmode;
+
+		newmode = drm_mode_std(data, edid,
+				       &edid->standard_timings[i]);
+		if (newmode) {
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+
+	if (version_greater(edid, 1, 0))
+		drm_for_each_detailed_block((u8 *)edid, do_standard_modes,
+					    &closure);
+
+	/* XXX should also look for standard codes in VTB blocks */
+
+	return modes + closure.modes;
+}
+
+static int
+drm_est3_modes(struct hdmi_edid_data *data, struct detailed_timing *timing)
+{
+	int i, j, m, modes = 0;
+	struct drm_display_mode *mode;
+	u8 *est = ((u8 *)timing) + 6;
+
+	for (i = 0; i < 6; i++) {
+		for (j = 7; j >= 0; j--) {
+			m = (i * 8) + (7 - j);
+			if (m >= ARRAY_SIZE(est3_modes))
+				break;
+			if (est[i] & (1 << j)) {
+				mode = drm_mode_find_dmt(
+							 est3_modes[m].w,
+							 est3_modes[m].h,
+							 est3_modes[m].r,
+							 est3_modes[m].rb);
+				if (mode) {
+					drm_add_hdmi_modes(data, mode);
+					modes++;
+					drm_mode_destroy(mode);
+				}
+			}
+		}
+	}
+
+	return modes;
+}
+
+static void
+do_established_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+
+	if (data->type == EDID_DETAIL_EST_TIMINGS)
+		closure->modes += drm_est3_modes(closure->data, timing);
+}
+
+/**
+ * add_established_modes - get est. modes from EDID and add them
+ * @data: data to add mode(s) to
+ * @edid: EDID block to scan
+ *
+ * Each EDID block contains a bitmap of the supported "established modes" list
+ * (defined above).  Tease them out and add them to the modes list.
+ */
+static int
+add_established_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	unsigned long est_bits = edid->established_timings.t1 |
+		(edid->established_timings.t2 << 8) |
+		((edid->established_timings.mfg_rsvd & 0x80) << 9);
+	int i, modes = 0;
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	for (i = 0; i <= EDID_EST_TIMINGS; i++) {
+		if (est_bits & (1 << i)) {
+			struct drm_display_mode *newmode = drm_mode_create();
+			*newmode = edid_est_modes[i];
+			if (newmode) {
+				drm_add_hdmi_modes(data, newmode);
+				modes++;
+				drm_mode_destroy(newmode);
+			}
+		}
+	}
+
+	if (version_greater(edid, 1, 0))
+		drm_for_each_detailed_block((u8 *)edid,
+					    do_established_modes, &closure);
+
+	return modes + closure.modes;
+}
+
+static u8 drm_match_hdmi_mode(const struct drm_display_mode *to_match)
+{
+	u8 vic;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {
+		const struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];
+		unsigned int clock1, clock2;
+
+		/* Make sure to also match alternate clocks */
+		clock1 = hdmi_mode->clock;
+		clock2 = hdmi_mode_alternate_clock(hdmi_mode);
+
+		if ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||
+		     KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&
+		    drm_mode_equal_no_clocks_no_stereo(to_match, hdmi_mode))
+			return vic;
+	}
+	return 0;
+}
+
+static int
+add_alternate_cea_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct drm_display_mode *mode;
+	int i, num, modes = 0;
+
+	/* Don't add CEA modes if the CEA extension block is missing */
+	if (!drm_find_cea_extension(edid))
+		return 0;
+
+	/*
+	 * Go through all probed modes and create a new mode
+	 * with the alternate clock for certain CEA modes.
+	 */
+	num = data->modes;
+
+	for (i = 0; i < num; i++) {
+		const struct drm_display_mode *cea_mode = NULL;
+		struct drm_display_mode *newmode;
+		u8 vic;
+		unsigned int clock1, clock2;
+
+		mode = &data->mode_buf[i];
+		vic = drm_match_cea_mode(mode);
+
+		if (drm_valid_cea_vic(vic)) {
+			cea_mode = &edid_cea_modes[vic];
+			clock2 = cea_mode_alternate_clock(cea_mode);
+		} else {
+			vic = drm_match_hdmi_mode(mode);
+			if (drm_valid_hdmi_vic(vic)) {
+				cea_mode = &edid_4k_modes[vic];
+				clock2 = hdmi_mode_alternate_clock(cea_mode);
+			}
+		}
+
+		if (!cea_mode)
+			continue;
+
+		clock1 = cea_mode->clock;
+
+		if (clock1 == clock2)
+			continue;
+
+		if (mode->clock != clock1 && mode->clock != clock2)
+			continue;
+
+		newmode = drm_mode_create();
+		*newmode = *cea_mode;
+		if (!newmode)
+			continue;
+
+		/* Carry over the stereo flags */
+		newmode->flags |= mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+		/*
+		 * The current mode could be either variant. Make
+		 * sure to pick the "other" clock for the new mode.
+		 */
+		if (mode->clock != clock1)
+			newmode->clock = clock1;
+		else
+			newmode->clock = clock2;
+
+		drm_add_hdmi_modes(data, newmode);
+		modes++;
+		drm_mode_destroy(newmode);
+	}
+
+	return modes;
+}
+
+static u8 *drm_find_displayid_extension(struct edid *edid)
+{
+	return drm_find_edid_extension(edid, DISPLAYID_EXT);
+}
+
+static int validate_displayid(u8 *displayid, int length, int idx)
+{
+	int i;
+	u8 csum = 0;
+	struct displayid_hdr *base;
+
+	base = (struct displayid_hdr *)&displayid[idx];
+
+	debug("base revision 0x%x, length %d, %d %d\n",
+	      base->rev, base->bytes, base->prod_id, base->ext_count);
+
+	if (base->bytes + 5 > length - idx)
+		return -EINVAL;
+	for (i = idx; i <= base->bytes + 5; i++)
+		csum += displayid[i];
+	if (csum) {
+		debug("DisplayID checksum invalid, remainder is %d\n", csum);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct
+drm_display_mode *drm_displayid_detailed(struct displayid_detailed_timings_1
+					      *timings)
+{
+	struct drm_display_mode *mode;
+	unsigned pixel_clock = (timings->pixel_clock[0] |
+				(timings->pixel_clock[1] << 8) |
+				(timings->pixel_clock[2] << 16));
+	unsigned hactive = (timings->hactive[0] | timings->hactive[1] << 8) + 1;
+	unsigned hblank = (timings->hblank[0] | timings->hblank[1] << 8) + 1;
+	unsigned hsync = (timings->hsync[0] |
+		(timings->hsync[1] & 0x7f) << 8) + 1;
+	unsigned hsync_width = (timings->hsw[0] | timings->hsw[1] << 8) + 1;
+	unsigned vactive = (timings->vactive[0] |
+		timings->vactive[1] << 8) + 1;
+	unsigned vblank = (timings->vblank[0] | timings->vblank[1] << 8) + 1;
+	unsigned vsync = (timings->vsync[0] |
+		(timings->vsync[1] & 0x7f) << 8) + 1;
+	unsigned vsync_width = (timings->vsw[0] | timings->vsw[1] << 8) + 1;
+	bool hsync_positive = (timings->hsync[1] >> 7) & 0x1;
+	bool vsync_positive = (timings->vsync[1] >> 7) & 0x1;
+
+	mode = drm_mode_create();
+	if (!mode)
+		return NULL;
+
+	mode->clock = pixel_clock * 10;
+	mode->hdisplay = hactive;
+	mode->hsync_start = mode->hdisplay + hsync;
+	mode->hsync_end = mode->hsync_start + hsync_width;
+	mode->htotal = mode->hdisplay + hblank;
+
+	mode->vdisplay = vactive;
+	mode->vsync_start = mode->vdisplay + vsync;
+	mode->vsync_end = mode->vsync_start + vsync_width;
+	mode->vtotal = mode->vdisplay + vblank;
+
+	mode->flags = 0;
+	mode->flags |=
+		hsync_positive ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |=
+		vsync_positive ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+	mode->type = DRM_MODE_TYPE_DRIVER;
+
+	if (timings->flags & 0x80)
+		mode->type |= DRM_MODE_TYPE_PREFERRED;
+	mode->vrefresh = drm_get_vrefresh(mode);
+
+	return mode;
+}
+
+static int add_displayid_detailed_1_modes(struct hdmi_edid_data *data,
+					  struct displayid_block *block)
+{
+	struct displayid_detailed_timing_block *det;
+	int i;
+	int num_timings;
+	struct drm_display_mode *newmode;
+	int num_modes = 0;
+
+	det = (struct displayid_detailed_timing_block *)block;
+	/* blocks must be multiple of 20 bytes length */
+	if (block->num_bytes % 20)
+		return 0;
+
+	num_timings = block->num_bytes / 20;
+	for (i = 0; i < num_timings; i++) {
+		struct displayid_detailed_timings_1 *timings =
+			&det->timings[i];
+
+		newmode = drm_displayid_detailed(timings);
+		if (!newmode)
+			continue;
+
+		drm_add_hdmi_modes(data, newmode);
+		num_modes++;
+		drm_mode_destroy(newmode);
+	}
+	return num_modes;
+}
+
+static int add_displayid_detailed_modes(struct hdmi_edid_data *data,
+					struct edid *edid)
+{
+	u8 *displayid;
+	int ret;
+	int idx = 1;
+	int length = EDID_SIZE;
+	struct displayid_block *block;
+	int num_modes = 0;
+
+	displayid = drm_find_displayid_extension(edid);
+	if (!displayid)
+		return 0;
+
+	ret = validate_displayid(displayid, length, idx);
+	if (ret)
+		return 0;
+
+	idx += sizeof(struct displayid_hdr);
+	while (block = (struct displayid_block *)&displayid[idx],
+	       idx + sizeof(struct displayid_block) <= length &&
+	       idx + sizeof(struct displayid_block) + block->num_bytes <=
+	       length && block->num_bytes > 0) {
+		idx += block->num_bytes + sizeof(struct displayid_block);
+		switch (block->tag) {
+		case DATA_BLOCK_TYPE_1_DETAILED_TIMING:
+			num_modes +=
+				add_displayid_detailed_1_modes(data, block);
+			break;
+		}
+	}
+	return num_modes;
+}
+
+static bool
+mode_in_hsync_range(const struct drm_display_mode *mode,
+		    struct edid *edid, u8 *t)
+{
+	int hsync, hmin, hmax;
+
+	hmin = t[7];
+	if (edid->revision >= 4)
+		hmin += ((t[4] & 0x04) ? 255 : 0);
+	hmax = t[8];
+	if (edid->revision >= 4)
+		hmax += ((t[4] & 0x08) ? 255 : 0);
+	hsync = drm_mode_hsync(mode);
+
+	return (hsync <= hmax && hsync >= hmin);
+}
+
+static bool
+mode_in_vsync_range(const struct drm_display_mode *mode,
+		    struct edid *edid, u8 *t)
+{
+	int vsync, vmin, vmax;
+
+	vmin = t[5];
+	if (edid->revision >= 4)
+		vmin += ((t[4] & 0x01) ? 255 : 0);
+	vmax = t[6];
+	if (edid->revision >= 4)
+		vmax += ((t[4] & 0x02) ? 255 : 0);
+	vsync = drm_get_vrefresh(mode);
+
+	return (vsync <= vmax && vsync >= vmin);
+}
+
+static u32
+range_pixel_clock(struct edid *edid, u8 *t)
+{
+	/* unspecified */
+	if (t[9] == 0 || t[9] == 255)
+		return 0;
+
+	/* 1.4 with CVT support gives us real precision, yay */
+	if (edid->revision >= 4 && t[10] == 0x04)
+		return (t[9] * 10000) - ((t[12] >> 2) * 250);
+
+	/* 1.3 is pathetic, so fuzz up a bit */
+	return t[9] * 10000 + 5001;
+}
+
+static bool
+mode_in_range(const struct drm_display_mode *mode, struct edid *edid,
+	      struct detailed_timing *timing)
+{
+	u32 max_clock;
+	u8 *t = (u8 *)timing;
+
+	if (!mode_in_hsync_range(mode, edid, t))
+		return false;
+
+	if (!mode_in_vsync_range(mode, edid, t))
+		return false;
+
+	max_clock = range_pixel_clock(edid, t);
+	if (max_clock)
+		if (mode->clock > max_clock)
+			return false;
+
+	/* 1.4 max horizontal check */
+	if (edid->revision >= 4 && t[10] == 0x04)
+		if (t[13] && mode->hdisplay > 8 *
+		    (t[13] + (256 * (t[12] & 0x3))))
+			return false;
+
+	if (mode_is_rb(mode) && !drm_monitor_supports_rb(edid))
+		return false;
+
+	return true;
+}
+
+static bool valid_inferred_mode(struct hdmi_edid_data *data,
+				const struct drm_display_mode *mode)
+{
+	const struct drm_display_mode *m;
+	bool ok = false;
+	int i;
+
+	for (i = 0; i < data->modes; i++) {
+		m = &data->mode_buf[i];
+		if (mode->hdisplay == m->hdisplay &&
+		    mode->vdisplay == m->vdisplay &&
+		    drm_get_vrefresh(mode) == drm_get_vrefresh(m))
+			return false; /* duplicated */
+		if (mode->hdisplay <= m->hdisplay &&
+		    mode->vdisplay <= m->vdisplay)
+			ok = true;
+	}
+	return ok;
+}
+
+static int
+drm_dmt_modes_for_range(struct hdmi_edid_data *data, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {
+		if (mode_in_range(drm_dmt_modes + i, edid, timing) &&
+		    valid_inferred_mode(data, drm_dmt_modes + i)) {
+			drm_add_hdmi_modes(data, &drm_dmt_modes[i]);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+/* fix up 1366x768 mode from 1368x768;
+ * GFT/CVT can't express 1366 width which isn't dividable by 8
+ */
+static void fixup_mode_1366x768(struct drm_display_mode *mode)
+{
+	if (mode->hdisplay == 1368 && mode->vdisplay == 768) {
+		mode->hdisplay = 1366;
+		mode->hsync_start--;
+		mode->hsync_end--;
+	}
+}
+
+static int
+drm_gtf_modes_for_range(struct hdmi_edid_data *data, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct drm_display_mode *newmode;
+
+	for (i = 0; i < ARRAY_SIZE(extra_modes); i++) {
+		const struct minimode *m = &extra_modes[i];
+
+		newmode = drm_gtf_mode(m->w, m->h, m->r, 0, 0);
+		if (!newmode)
+			return modes;
+
+		fixup_mode_1366x768(newmode);
+		if (!mode_in_range(newmode, edid, timing) ||
+		    !valid_inferred_mode(data, newmode)) {
+			drm_mode_destroy(newmode);
+			continue;
+		}
+
+		drm_add_hdmi_modes(data, newmode);
+		modes++;
+		drm_mode_destroy(newmode);
+	}
+
+	return modes;
+}
+
+static int
+drm_cvt_modes_for_range(struct hdmi_edid_data *data, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct drm_display_mode *newmode;
+	bool rb = drm_monitor_supports_rb(edid);
+
+	for (i = 0; i < ARRAY_SIZE(extra_modes); i++) {
+		const struct minimode *m = &extra_modes[i];
+
+		newmode = drm_cvt_mode(m->w, m->h, m->r, rb, 0, 0);
+		if (!newmode)
+			return modes;
+
+		fixup_mode_1366x768(newmode);
+		if (!mode_in_range(newmode, edid, timing) ||
+		    !valid_inferred_mode(data, newmode)) {
+			drm_mode_destroy(newmode);
+			continue;
+		}
+
+		drm_add_hdmi_modes(data, newmode);
+		modes++;
+		drm_mode_destroy(newmode);
+	}
+
+	return modes;
+}
+
+static void
+do_inferred_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+	struct detailed_data_monitor_range *range = &data->data.range;
+
+	if (data->type != EDID_DETAIL_MONITOR_RANGE)
+		return;
+
+	closure->modes += drm_dmt_modes_for_range(closure->data,
+						  closure->edid,
+						  timing);
+
+	if (!version_greater(closure->edid, 1, 1))
+		return; /* GTF not defined yet */
+
+	switch (range->flags) {
+	case 0x02: /* secondary gtf, XXX could do more */
+	case 0x00: /* default gtf */
+		closure->modes += drm_gtf_modes_for_range(closure->data,
+							  closure->edid,
+							  timing);
+		break;
+	case 0x04: /* cvt, only in 1.4+ */
+		if (!version_greater(closure->edid, 1, 3))
+			break;
+
+		closure->modes += drm_cvt_modes_for_range(closure->data,
+							  closure->edid,
+							  timing);
+		break;
+	case 0x01: /* just the ranges, no formula */
+	default:
+		break;
+	}
+}
+
+static int
+add_inferred_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	if (version_greater(edid, 1, 0))
+		drm_for_each_detailed_block((u8 *)edid, do_inferred_modes,
+					    &closure);
+
+	return closure.modes;
+}
+
+#define MODE_SIZE(m) ((m)->hdisplay * (m)->vdisplay)
+#define MODE_REFRESH_DIFF(c, t) (abs((c) - (t)))
+
+/**
+ * edid_fixup_preferred - set preferred modes based on quirk list
+ * @data: the structure that save parsed hdmi edid data
+ * @quirks: quirks list
+ *
+ * Walk the mode list, clearing the preferred status
+ * on existing modes and setting it anew for the right mode ala @quirks.
+ */
+static void edid_fixup_preferred(struct hdmi_edid_data *data,
+				 u32 quirks)
+{
+	struct drm_display_mode *cur_mode, *preferred_mode;
+	int i, target_refresh = 0;
+	int num = data->modes;
+	int cur_vrefresh, preferred_vrefresh;
+
+	if (!num)
+		return;
+
+	preferred_mode = data->preferred_mode;
+
+	if (quirks & EDID_QUIRK_PREFER_LARGE_60)
+		target_refresh = 60;
+	if (quirks & EDID_QUIRK_PREFER_LARGE_75)
+		target_refresh = 75;
+
+	for (i = 0; i < num; i++) {
+		cur_mode = &data->mode_buf[i];
+		cur_mode->type &= ~DRM_MODE_TYPE_PREFERRED;
+
+		if (cur_mode == preferred_mode)
+			continue;
+
+		/* Largest mode is preferred */
+		if (MODE_SIZE(cur_mode) > MODE_SIZE(preferred_mode))
+			preferred_mode = cur_mode;
+
+		cur_vrefresh = cur_mode->vrefresh ?
+		cur_mode->vrefresh : drm_get_vrefresh(cur_mode);
+		preferred_vrefresh = preferred_mode->vrefresh ?
+		preferred_mode->vrefresh : drm_get_vrefresh(preferred_mode);
+		/* At a given size, try to get closest to target refresh */
+		if ((MODE_SIZE(cur_mode) == MODE_SIZE(preferred_mode)) &&
+		    MODE_REFRESH_DIFF(cur_vrefresh, target_refresh) <
+		    MODE_REFRESH_DIFF(preferred_vrefresh, target_refresh)) {
+			preferred_mode = cur_mode;
+		}
+	}
+	preferred_mode->type |= DRM_MODE_TYPE_PREFERRED;
+	data->preferred_mode = preferred_mode;
+}
+
+static const u8 edid_header[] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
+};
+
+/**
+ * drm_edid_header_is_valid - sanity check the header of the base EDID block
+ * @raw_edid: pointer to raw base EDID block
+ *
+ * Sanity check the header of the base EDID block.
+ *
+ * Return: 8 if the header is perfect, down to 0 if it's totally wrong.
+ */
+static int drm_edid_header_is_valid(const u8 *raw_edid)
+{
+	int i, score = 0;
+
+	for (i = 0; i < sizeof(edid_header); i++)
+		if (raw_edid[i] == edid_header[i])
+			score++;
+
+	return score;
+}
+
+static int drm_edid_block_checksum(const u8 *raw_edid)
+{
+	int i;
+	u8 csum = 0;
+
+	for (i = 0; i < EDID_SIZE; i++)
+		csum += raw_edid[i];
+
+	return csum;
+}
+
+static bool drm_edid_is_zero(const u8 *in_edid, int length)
+{
+	if (memchr_inv(in_edid, 0, length))
+		return false;
+
+	return true;
+}
+
+/**
+ * drm_edid_block_valid - Sanity check the EDID block (base or extension)
+ * @raw_edid: pointer to raw EDID block
+ * @block: type of block to validate (0 for base, extension otherwise)
+ * @print_bad_edid: if true, dump bad EDID blocks to the console
+ * @edid_corrupt: if true, the header or checksum is invalid
+ *
+ * Validate a base or extension EDID block and optionally dump bad blocks to
+ * the console.
+ *
+ * Return: True if the block is valid, false otherwise.
+ */
+static
+bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
+			  bool *edid_corrupt)
+{
+	u8 csum;
+	int edid_fixup = 6;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if ((!raw_edid))
+		return false;
+
+	if (block == 0) {
+		int score = drm_edid_header_is_valid(raw_edid);
+
+		if (score == 8) {
+			if (edid_corrupt)
+				*edid_corrupt = false;
+		} else if (score >= edid_fixup) {
+			/* Displayport Link CTS Core 1.2 rev1.1 test 4.2.2.6
+			 * The corrupt flag needs to be set here otherwise, the
+			 * fix-up code here will correct the problem, the
+			 * checksum is correct and the test fails
+			 */
+			if (edid_corrupt)
+				*edid_corrupt = true;
+			debug("Fixing header, your hardware may be failing\n");
+			memcpy(raw_edid, edid_header, sizeof(edid_header));
+		} else {
+			if (edid_corrupt)
+				*edid_corrupt = true;
+			goto bad;
+		}
+	}
+
+	csum = drm_edid_block_checksum(raw_edid);
+	if (csum) {
+		if (print_bad_edid) {
+			debug("EDID checksum is invalid, remainder is %d\n",
+			      csum);
+		}
+
+		if (edid_corrupt)
+			*edid_corrupt = true;
+
+		/* allow CEA to slide through, switches mangle this */
+		if (raw_edid[0] != 0x02)
+			goto bad;
+	}
+
+	/* per-block-type checks */
+	switch (raw_edid[0]) {
+	case 0: /* base */
+		if (edid->version != 1) {
+			debug("EDID has major version %d, instead of 1\n",
+			      edid->version);
+			goto bad;
+		}
+
+		if (edid->revision > 4)
+			debug("minor > 4, assuming backward compatibility\n");
+		break;
+
+	default:
+		break;
+	}
+
+	return true;
+
+bad:
+	if (print_bad_edid) {
+		if (drm_edid_is_zero(raw_edid, EDID_SIZE)) {
+			debug("EDID block is all zeroes\n");
+		} else {
+			debug("Raw EDID:\n");
+			print_hex_dump("", DUMP_PREFIX_NONE, 16, 1,
+				       raw_edid, EDID_SIZE, false);
+		}
+	}
+	return false;
+}
+
+/**
+ * drm_edid_is_valid - sanity check EDID data
+ * @edid: EDID data
+ *
+ * Sanity-check an entire EDID record (including extensions)
+ *
+ * Return: True if the EDID data is valid, false otherwise.
+ */
+static bool drm_edid_is_valid(struct edid *edid)
+{
+	int i;
+	u8 *raw = (u8 *)edid;
+
+	if (!edid)
+		return false;
+
+	for (i = 0; i <= edid->extensions; i++)
+		if (!drm_edid_block_valid(raw + i * EDID_SIZE, i, true, NULL))
+			return false;
+
+	return true;
+}
+
+/**
+ * drm_add_edid_modes - add modes from EDID data, if available
+ * @data: data we're probing
+ * @edid: EDID data
+ *
+ * Add the specified modes to the data's mode list.
+ *
+ * Return: The number of modes added or 0 if we couldn't find any.
+ */
+int drm_add_edid_modes(struct hdmi_edid_data *data, u8 *raw_edid)
+{
+	int num_modes = 0;
+	u32 quirks;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if (!edid) {
+		debug("no edid\n");
+		return 0;
+	}
+
+	if (!drm_edid_is_valid(edid)) {
+		debug("EDID invalid\n");
+		return 0;
+	}
+
+	if (!data->mode_buf) {
+		debug("mode buff is null\n");
+		return 0;
+	}
+
+	quirks = edid_get_quirks(edid);
+	/*
+	 * CEA-861-F adds ycbcr capability map block, for HDMI 2.0 sinks.
+	 * To avoid multiple parsing of same block, lets parse that map
+	 * from sink info, before parsing CEA modes.
+	 */
+	drm_add_display_info(data, edid);
+
+	/*
+	 * EDID spec says modes should be preferred in this order:
+	 * - preferred detailed mode
+	 * - other detailed modes from base block
+	 * - detailed modes from extension blocks
+	 * - CVT 3-byte code modes
+	 * - standard timing codes
+	 * - established timing codes
+	 * - modes inferred from GTF or CVT range information
+	 *
+	 * We get this pretty much right.
+	 *
+	 * XXX order for additional mode types in extension blocks?
+	 */
+	num_modes += add_detailed_modes(data, edid, quirks);
+	num_modes += add_cvt_modes(data, edid);
+	num_modes += add_standard_modes(data, edid);
+	num_modes += add_established_modes(data, edid);
+	num_modes += add_cea_modes(data, edid);
+	num_modes += add_alternate_cea_modes(data, edid);
+	num_modes += add_displayid_detailed_modes(data, edid);
+
+	if (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF)
+		num_modes += add_inferred_modes(data, edid);
+
+	if (num_modes > 0)
+		data->preferred_mode = &data->mode_buf[0];
+
+	if (quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))
+		edid_fixup_preferred(data, quirks);
+
+	if (quirks & EDID_QUIRK_FORCE_6BPC)
+		data->display_info.bpc = 6;
+
+	if (quirks & EDID_QUIRK_FORCE_8BPC)
+		data->display_info.bpc = 8;
+
+	if (quirks & EDID_QUIRK_FORCE_10BPC)
+		data->display_info.bpc = 10;
+
+	if (quirks & EDID_QUIRK_FORCE_12BPC)
+		data->display_info.bpc = 12;
+
+	return num_modes;
+}
+
+u8 drm_match_cea_mode(struct drm_display_mode *to_match)
+{
+	u8 vic;
+
+	if (!to_match->clock) {
+		printf("can't find to match\n");
+		return 0;
+	}
+
+	for (vic = 1; vic < ARRAY_SIZE(edid_cea_modes); vic++) {
+		const struct drm_display_mode *cea_mode = &edid_cea_modes[vic];
+		unsigned int clock1, clock2;
+
+		/* Check both 60Hz and 59.94Hz */
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+		if ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||
+		     KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&
+		    drm_mode_equal_no_clocks_no_stereo(to_match, cea_mode))
+			return vic;
+	}
+
+	return 0;
+}
+
+static enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code)
+{
+	return edid_cea_modes[video_code].picture_aspect_ratio;
+}
+
+int
+drm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,
+					 struct drm_display_mode *mode,
+					 bool is_hdmi2_sink)
+{
+	int err;
+
+	if (!frame || !mode)
+		return -EINVAL;
+
+	err = hdmi_avi_infoframe_init(frame);
+	if (err < 0)
+		return err;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		frame->pixel_repeat = 1;
+
+	frame->video_code = drm_match_cea_mode(mode);
+
+	/*
+	 * HDMI 1.4 VIC range: 1 <= VIC <= 64 (CEA-861-D) but
+	 * HDMI 2.0 VIC range: 1 <= VIC <= 107 (CEA-861-F). So we
+	 * have to make sure we dont break HDMI 1.4 sinks.
+	 */
+	if (!is_hdmi2_sink && frame->video_code > 64)
+		frame->video_code = 0;
+
+	/*
+	 * HDMI spec says if a mode is found in HDMI 1.4b 4K modes
+	 * we should send its VIC in vendor infoframes, else send the
+	 * VIC in AVI infoframes. Lets check if this mode is present in
+	 * HDMI 1.4b 4K modes
+	 */
+	if (frame->video_code) {
+		u8 vendor_if_vic = drm_match_hdmi_mode(mode);
+		bool is_s3d = mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+		if (drm_valid_hdmi_vic(vendor_if_vic) && !is_s3d)
+			frame->video_code = 0;
+	}
+
+	frame->picture_aspect = HDMI_PICTURE_ASPECT_NONE;
+
+	/*
+	 * Populate picture aspect ratio from either
+	 * user input (if specified) or from the CEA mode list.
+	 */
+	if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3 ||
+	    mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9)
+		frame->picture_aspect = mode->picture_aspect_ratio;
+	else if (frame->video_code > 0)
+		frame->picture_aspect = drm_get_cea_aspect_ratio(
+						frame->video_code);
+
+	if (frame->picture_aspect > HDMI_PICTURE_ASPECT_16_9)
+		frame->picture_aspect = HDMI_PICTURE_ASPECT_NONE;
+	frame->active_aspect = HDMI_ACTIVE_ASPECT_PICTURE;
+	frame->scan_mode = HDMI_SCAN_MODE_UNDERSCAN;
+
+	return 0;
+}
+
+/**
+ * hdmi_vendor_infoframe_init() - initialize an HDMI vendor infoframe
+ * @frame: HDMI vendor infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_vendor_infoframe_init(struct hdmi_vendor_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_VENDOR;
+	frame->version = 1;
+
+	frame->oui = HDMI_IEEE_OUI;
+
+	/*
+	 * 0 is a valid value for s3d_struct, so we use a special "not set"
+	 * value
+	 */
+	frame->s3d_struct = HDMI_3D_STRUCTURE_INVALID;
+
+	return 0;
+}
+
+/**
+ * drm_hdmi_avi_infoframe_quant_range() - fill the HDMI AVI infoframe
+ *                                        quantization range information
+ * @frame: HDMI AVI infoframe
+ * @rgb_quant_range: RGB quantization range (Q)
+ * @rgb_quant_range_selectable: Sink support selectable RGB quantization range (QS)
+ */
+void
+drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
+				   struct drm_display_mode *mode,
+				   enum hdmi_quantization_range rgb_quant_range,
+				   bool rgb_quant_range_selectable)
+{
+	/*
+	 * CEA-861:
+	 * "A Source shall not send a non-zero Q value that does not correspond
+	 *  to the default RGB Quantization Range for the transmitted Picture
+	 *  unless the Sink indicates support for the Q bit in a Video
+	 *  Capabilities Data Block."
+	 *
+	 * HDMI 2.0 recommends sending non-zero Q when it does match the
+	 * default RGB quantization range for the mode, even when QS=0.
+	 */
+	if (rgb_quant_range_selectable ||
+	    rgb_quant_range == drm_default_rgb_quant_range(mode))
+		frame->quantization_range = rgb_quant_range;
+	else
+		frame->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+
+	/*
+	 * CEA-861-F:
+	 * "When transmitting any RGB colorimetry, the Source should set the
+	 *  YQ-field to match the RGB Quantization Range being transmitted
+	 *  (e.g., when Limited Range RGB, set YQ=0 or when Full Range RGB,
+	 *  set YQ=1) and the Sink shall ignore the YQ-field."
+	 */
+	if (rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)
+		frame->ycc_quantization_range =
+			HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+	else
+		frame->ycc_quantization_range =
+			HDMI_YCC_QUANTIZATION_RANGE_FULL;
+}
+
+static enum hdmi_3d_structure
+s3d_structure_from_display_mode(const struct drm_display_mode *mode)
+{
+	u32 layout = mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+	switch (layout) {
+	case DRM_MODE_FLAG_3D_FRAME_PACKING:
+		return HDMI_3D_STRUCTURE_FRAME_PACKING;
+	case DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE:
+		return HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE;
+	case DRM_MODE_FLAG_3D_LINE_ALTERNATIVE:
+		return HDMI_3D_STRUCTURE_LINE_ALTERNATIVE;
+	case DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL:
+		return HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL;
+	case DRM_MODE_FLAG_3D_L_DEPTH:
+		return HDMI_3D_STRUCTURE_L_DEPTH;
+	case DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH:
+		return HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH;
+	case DRM_MODE_FLAG_3D_TOP_AND_BOTTOM:
+		return HDMI_3D_STRUCTURE_TOP_AND_BOTTOM;
+	case DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF:
+		return HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF;
+	default:
+		return HDMI_3D_STRUCTURE_INVALID;
+	}
+}
+
+int
+drm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,
+					    struct drm_display_mode *mode)
+{
+	int err;
+	u32 s3d_flags;
+	u8 vic;
+
+	if (!frame || !mode)
+		return -EINVAL;
+
+	vic = drm_match_hdmi_mode(mode);
+
+	s3d_flags = mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+	if (!vic && !s3d_flags)
+		return -EINVAL;
+
+	if (vic && s3d_flags)
+		return -EINVAL;
+
+	err = hdmi_vendor_infoframe_init(frame);
+	if (err < 0)
+		return err;
+
+	if (vic)
+		frame->vic = vic;
+	else
+		frame->s3d_struct = s3d_structure_from_display_mode(mode);
+
+	return 0;
+}
+
+static u8 hdmi_infoframe_checksum(u8 *ptr, size_t size)
+{
+	u8 csum = 0;
+	size_t i;
+
+	/* compute checksum */
+	for (i = 0; i < size; i++)
+		csum += ptr[i];
+
+	return 256 - csum;
+}
+
+static void hdmi_infoframe_set_checksum(void *buffer, size_t size)
+{
+	u8 *ptr = buffer;
+
+	ptr[3] = hdmi_infoframe_checksum(buffer, size);
+}
+
+/**
+ * hdmi_avi_infoframe_init() - initialize an HDMI AVI infoframe
+ * @frame: HDMI AVI infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_avi_infoframe_init(struct hdmi_avi_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_AVI;
+	frame->version = 2;
+	frame->length = HDMI_AVI_INFOFRAME_SIZE;
+
+	return 0;
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_init);
+
+/**
+ * hdmi_avi_infoframe_pack() - write HDMI AVI infoframe to binary buffer
+ * @frame: HDMI AVI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_avi_infoframe_pack(struct hdmi_avi_infoframe *frame, void *buffer,
+				size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = ((frame->colorspace & 0x3) << 5) | (frame->scan_mode & 0x3);
+
+	/*
+	 * Data byte 1, bit 4 has to be set if we provide the active format
+	 * aspect ratio
+	 */
+	if (frame->active_aspect & 0xf)
+		ptr[0] |= BIT(4);
+
+	/* Bit 3 and 2 indicate if we transmit horizontal/vertical bar data */
+	if (frame->top_bar || frame->bottom_bar)
+		ptr[0] |= BIT(3);
+
+	if (frame->left_bar || frame->right_bar)
+		ptr[0] |= BIT(2);
+
+	ptr[1] = ((frame->colorimetry & 0x3) << 6) |
+		 ((frame->picture_aspect & 0x3) << 4) |
+		 (frame->active_aspect & 0xf);
+
+	ptr[2] = ((frame->extended_colorimetry & 0x7) << 4) |
+		 ((frame->quantization_range & 0x3) << 2) |
+		 (frame->nups & 0x3);
+
+	if (frame->itc)
+		ptr[2] |= BIT(7);
+
+	ptr[3] = frame->video_code & 0x7f;
+
+	ptr[4] = ((frame->ycc_quantization_range & 0x3) << 6) |
+		 ((frame->content_type & 0x3) << 4) |
+		 (frame->pixel_repeat & 0xf);
+
+	ptr[5] = frame->top_bar & 0xff;
+	ptr[6] = (frame->top_bar >> 8) & 0xff;
+	ptr[7] = frame->bottom_bar & 0xff;
+	ptr[8] = (frame->bottom_bar >> 8) & 0xff;
+	ptr[9] = frame->left_bar & 0xff;
+	ptr[10] = (frame->left_bar >> 8) & 0xff;
+	ptr[11] = frame->right_bar & 0xff;
+	ptr[12] = (frame->right_bar >> 8) & 0xff;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_pack);
+
+static int hdmi_avi_infoframe_check_only(const struct hdmi_avi_infoframe *frame)
+{
+	if (frame->type != HDMI_INFOFRAME_TYPE_AVI ||
+	    frame->version != 2 ||
+	    frame->length != HDMI_AVI_INFOFRAME_SIZE)
+		return -EINVAL;
+
+	if (frame->picture_aspect > HDMI_PICTURE_ASPECT_16_9)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * hdmi_avi_infoframe_check() - check a HDMI AVI infoframe
+ * @frame: HDMI AVI infoframe
+ *
+ * Validates that the infoframe is consistent and updates derived fields
+ * (eg. length) based on other fields.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_avi_infoframe_check(struct hdmi_avi_infoframe *frame)
+{
+	return hdmi_avi_infoframe_check_only(frame);
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_check);
+
+/**
+ * hdmi_avi_infoframe_pack_only() - write HDMI AVI infoframe to binary buffer
+ * @frame: HDMI AVI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_avi_infoframe_pack_only(const struct hdmi_avi_infoframe *frame,
+				     void *buffer, size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+	int ret;
+
+	ret = hdmi_avi_infoframe_check_only(frame);
+	if (ret)
+		return ret;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = ((frame->colorspace & 0x3) << 5) | (frame->scan_mode & 0x3);
+
+	/*
+	 * Data byte 1, bit 4 has to be set if we provide the active format
+	 * aspect ratio
+	 */
+	if (frame->active_aspect & 0xf)
+		ptr[0] |= BIT(4);
+
+	/* Bit 3 and 2 indicate if we transmit horizontal/vertical bar data */
+	if (frame->top_bar || frame->bottom_bar)
+		ptr[0] |= BIT(3);
+
+	if (frame->left_bar || frame->right_bar)
+		ptr[0] |= BIT(2);
+
+	ptr[1] = ((frame->colorimetry & 0x3) << 6) |
+		 ((frame->picture_aspect & 0x3) << 4) |
+		 (frame->active_aspect & 0xf);
+
+	ptr[2] = ((frame->extended_colorimetry & 0x7) << 4) |
+		 ((frame->quantization_range & 0x3) << 2) |
+		 (frame->nups & 0x3);
+
+	if (frame->itc)
+		ptr[2] |= BIT(7);
+
+	ptr[3] = frame->video_code & 0xff;
+
+	ptr[4] = ((frame->ycc_quantization_range & 0x3) << 6) |
+		 ((frame->content_type & 0x3) << 4) |
+		 (frame->pixel_repeat & 0xf);
+
+	ptr[5] = frame->top_bar & 0xff;
+	ptr[6] = (frame->top_bar >> 8) & 0xff;
+	ptr[7] = frame->bottom_bar & 0xff;
+	ptr[8] = (frame->bottom_bar >> 8) & 0xff;
+	ptr[9] = frame->left_bar & 0xff;
+	ptr[10] = (frame->left_bar >> 8) & 0xff;
+	ptr[11] = frame->right_bar & 0xff;
+	ptr[12] = (frame->right_bar >> 8) & 0xff;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_pack_only);
+
+/**
+ * hdmi_spd_infoframe_init() - initialize an HDMI SPD infoframe
+ * @frame: HDMI SPD infoframe
+ * @vendor: vendor string
+ * @product: product string
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_spd_infoframe_init(struct hdmi_spd_infoframe *frame,
+			    const char *vendor, const char *product)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_SPD;
+	frame->version = 1;
+	frame->length = HDMI_SPD_INFOFRAME_SIZE;
+
+	strncpy(frame->vendor, vendor, sizeof(frame->vendor));
+	strncpy(frame->product, product, sizeof(frame->product));
+
+	return 0;
+}
+EXPORT_SYMBOL(hdmi_spd_infoframe_init);
+
+/**
+ * hdmi_spd_infoframe_pack() - write HDMI SPD infoframe to binary buffer
+ * @frame: HDMI SPD infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_spd_infoframe_pack(struct hdmi_spd_infoframe *frame, void *buffer,
+				size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	memcpy(ptr, frame->vendor, sizeof(frame->vendor));
+	memcpy(ptr + 8, frame->product, sizeof(frame->product));
+
+	ptr[24] = frame->sdi;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+EXPORT_SYMBOL(hdmi_spd_infoframe_pack);
+
+/**
+ * hdmi_audio_infoframe_init() - initialize an HDMI audio infoframe
+ * @frame: HDMI audio infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_audio_infoframe_init(struct hdmi_audio_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_AUDIO;
+	frame->version = 1;
+	frame->length = HDMI_AUDIO_INFOFRAME_SIZE;
+
+	return 0;
+}
+
+/**
+ * hdmi_audio_infoframe_pack() - write HDMI audio infoframe to binary buffer
+ * @frame: HDMI audio infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_audio_infoframe_pack(struct hdmi_audio_infoframe *frame,
+				  void *buffer, size_t size)
+{
+	unsigned char channels;
+	char *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	if (frame->channels >= 2)
+		channels = frame->channels - 1;
+	else
+		channels = 0;
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = ((frame->coding_type & 0xf) << 4) | (channels & 0x7);
+	ptr[1] = ((frame->sample_frequency & 0x7) << 2) |
+		 (frame->sample_size & 0x3);
+	ptr[2] = frame->coding_type_ext & 0x1f;
+	ptr[3] = frame->channel_allocation;
+	ptr[4] = (frame->level_shift_value & 0xf) << 3;
+
+	if (frame->downmix_inhibit)
+		ptr[4] |= BIT(7);
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+
+/**
+ * hdmi_vendor_infoframe_pack() - write a HDMI vendor infoframe to binary buffer
+ * @frame: HDMI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_vendor_infoframe_pack(struct hdmi_vendor_infoframe *frame,
+				   void *buffer, size_t size)
+{
+	char *ptr = buffer;
+	size_t length;
+
+	/* empty info frame */
+	if (frame->vic == 0 && frame->s3d_struct == HDMI_3D_STRUCTURE_INVALID)
+		return -EINVAL;
+
+	/* only one of those can be supplied */
+	if (frame->vic != 0 && frame->s3d_struct != HDMI_3D_STRUCTURE_INVALID)
+		return -EINVAL;
+
+	/* for side by side (half) we also need to provide 3D_Ext_Data */
+	if (frame->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)
+		frame->length = 6;
+	else
+		frame->length = 5;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* HDMI OUI */
+	ptr[4] = 0x03;
+	ptr[5] = 0x0c;
+	ptr[6] = 0x00;
+
+	if (frame->vic) {
+		ptr[7] = 0x1 << 5;	/* video format */
+		ptr[8] = frame->vic;
+	} else {
+		ptr[7] = 0x2 << 5;	/* video format */
+		ptr[8] = (frame->s3d_struct & 0xf) << 4;
+		if (frame->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)
+			ptr[9] = (frame->s3d_ext_data & 0xf) << 4;
+	}
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+
+/**
+ * hdmi_drm_infoframe_init() - initialize an HDMI Dynaminc Range and
+ * mastering infoframe
+ * @frame: HDMI DRM infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_drm_infoframe_init(struct hdmi_drm_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_DRM;
+	frame->version = 1;
+
+	return 0;
+}
+
+/**
+ * hdmi_drm_infoframe_pack() - write HDMI DRM infoframe to binary buffer
+ * @frame: HDMI DRM infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_drm_infoframe_pack(struct hdmi_drm_infoframe *frame, void *buffer,
+				size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = frame->eotf;
+	ptr[1] = frame->metadata_type;
+
+	ptr[2] = frame->display_primaries_x[0] & 0xff;
+	ptr[3] = frame->display_primaries_x[0] >> 8;
+
+	ptr[4] = frame->display_primaries_x[1] & 0xff;
+	ptr[5] = frame->display_primaries_x[1] >> 8;
+
+	ptr[6] = frame->display_primaries_x[2] & 0xff;
+	ptr[7] = frame->display_primaries_x[2] >> 8;
+
+	ptr[9] = frame->display_primaries_y[0] & 0xff;
+	ptr[10] = frame->display_primaries_y[0] >> 8;
+
+	ptr[11] = frame->display_primaries_y[1] & 0xff;
+	ptr[12] = frame->display_primaries_y[1] >> 8;
+
+	ptr[13] = frame->display_primaries_y[2] & 0xff;
+	ptr[14] = frame->display_primaries_y[2] >> 8;
+
+	ptr[15] = frame->white_point_x & 0xff;
+	ptr[16] = frame->white_point_x >> 8;
+
+	ptr[17] = frame->white_point_y & 0xff;
+	ptr[18] = frame->white_point_y >> 8;
+
+	ptr[19] = frame->max_mastering_display_luminance & 0xff;
+	ptr[20] = frame->max_mastering_display_luminance >> 8;
+
+	ptr[21] = frame->min_mastering_display_luminance & 0xff;
+	ptr[22] = frame->min_mastering_display_luminance >> 8;
+
+	ptr[23] = frame->max_cll & 0xff;
+	ptr[24] = frame->max_cll >> 8;
+
+	ptr[25] = frame->max_fall & 0xff;
+	ptr[26] = frame->max_fall >> 8;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+
+/*
+ * hdmi_vendor_any_infoframe_pack() - write a vendor infoframe to binary buffer
+ */
+static ssize_t
+hdmi_vendor_any_infoframe_pack(union hdmi_vendor_any_infoframe *frame,
+			       void *buffer, size_t size)
+{
+	/* we only know about HDMI vendor infoframes */
+	if (frame->any.oui != HDMI_IEEE_OUI)
+		return -EINVAL;
+
+	return hdmi_vendor_infoframe_pack(&frame->hdmi, buffer, size);
+}
+
+/**
+ * hdmi_infoframe_pack() - write a HDMI infoframe to binary buffer
+ * @frame: HDMI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t
+hdmi_infoframe_pack(union hdmi_infoframe *frame, void *buffer, size_t size)
+{
+	ssize_t length;
+
+	switch (frame->any.type) {
+	case HDMI_INFOFRAME_TYPE_AVI:
+		length = hdmi_avi_infoframe_pack(&frame->avi, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_DRM:
+		length = hdmi_drm_infoframe_pack(&frame->drm, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_SPD:
+		length = hdmi_spd_infoframe_pack(&frame->spd, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_AUDIO:
+		length = hdmi_audio_infoframe_pack(&frame->audio, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_VENDOR:
+		length = hdmi_vendor_any_infoframe_pack(&frame->vendor,
+							buffer, size);
+		break;
+	default:
+		printf("Bad infoframe type %d\n", frame->any.type);
+		length = -EINVAL;
+	}
+
+	return length;
+}
+
+/**
+ * hdmi_avi_infoframe_unpack() - unpack binary buffer to a HDMI AVI infoframe
+ * @buffer: source buffer
+ * @frame: HDMI AVI infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Auxiliary Video (AVI) information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int hdmi_avi_infoframe_unpack(struct hdmi_avi_infoframe *frame,
+				     void *buffer)
+{
+	u8 *ptr = buffer;
+	int ret;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_AVI ||
+	    ptr[1] != 2 ||
+	    ptr[2] != HDMI_AVI_INFOFRAME_SIZE)
+		return -EINVAL;
+
+	if (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(AVI)) != 0)
+		return -EINVAL;
+
+	ret = hdmi_avi_infoframe_init(frame);
+	if (ret)
+		return ret;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	frame->colorspace = (ptr[0] >> 5) & 0x3;
+	if (ptr[0] & 0x10)
+		frame->active_aspect = ptr[1] & 0xf;
+	if (ptr[0] & 0x8) {
+		frame->top_bar = (ptr[5] << 8) + ptr[6];
+		frame->bottom_bar = (ptr[7] << 8) + ptr[8];
+	}
+	if (ptr[0] & 0x4) {
+		frame->left_bar = (ptr[9] << 8) + ptr[10];
+		frame->right_bar = (ptr[11] << 8) + ptr[12];
+	}
+	frame->scan_mode = ptr[0] & 0x3;
+
+	frame->colorimetry = (ptr[1] >> 6) & 0x3;
+	frame->picture_aspect = (ptr[1] >> 4) & 0x3;
+	frame->active_aspect = ptr[1] & 0xf;
+
+	frame->itc = ptr[2] & 0x80 ? true : false;
+	frame->extended_colorimetry = (ptr[2] >> 4) & 0x7;
+	frame->quantization_range = (ptr[2] >> 2) & 0x3;
+	frame->nups = ptr[2] & 0x3;
+
+	frame->video_code = ptr[3] & 0x7f;
+	frame->ycc_quantization_range = (ptr[4] >> 6) & 0x3;
+	frame->content_type = (ptr[4] >> 4) & 0x3;
+
+	frame->pixel_repeat = ptr[4] & 0xf;
+
+	return 0;
+}
+
+/**
+ * hdmi_spd_infoframe_unpack() - unpack binary buffer to a HDMI SPD infoframe
+ * @buffer: source buffer
+ * @frame: HDMI SPD infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Source Product Description (SPD) information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int hdmi_spd_infoframe_unpack(struct hdmi_spd_infoframe *frame,
+				     void *buffer)
+{
+	char *ptr = buffer;
+	int ret;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_SPD ||
+	    ptr[1] != 1 ||
+	    ptr[2] != HDMI_SPD_INFOFRAME_SIZE) {
+		return -EINVAL;
+	}
+
+	if (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(SPD)) != 0)
+		return -EINVAL;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ret = hdmi_spd_infoframe_init(frame, ptr, ptr + 8);
+	if (ret)
+		return ret;
+
+	frame->sdi = ptr[24];
+
+	return 0;
+}
+
+/**
+ * hdmi_audio_infoframe_unpack() - unpack binary buffer to a HDMI AUDIO infoframe
+ * @buffer: source buffer
+ * @frame: HDMI Audio infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Audio information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int hdmi_audio_infoframe_unpack(struct hdmi_audio_infoframe *frame,
+				       void *buffer)
+{
+	u8 *ptr = buffer;
+	int ret;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_AUDIO ||
+	    ptr[1] != 1 ||
+	    ptr[2] != HDMI_AUDIO_INFOFRAME_SIZE) {
+		return -EINVAL;
+	}
+
+	if (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(AUDIO)) != 0)
+		return -EINVAL;
+
+	ret = hdmi_audio_infoframe_init(frame);
+	if (ret)
+		return ret;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	frame->channels = ptr[0] & 0x7;
+	frame->coding_type = (ptr[0] >> 4) & 0xf;
+	frame->sample_size = ptr[1] & 0x3;
+	frame->sample_frequency = (ptr[1] >> 2) & 0x7;
+	frame->coding_type_ext = ptr[2] & 0x1f;
+	frame->channel_allocation = ptr[3];
+	frame->level_shift_value = (ptr[4] >> 3) & 0xf;
+	frame->downmix_inhibit = ptr[4] & 0x80 ? true : false;
+
+	return 0;
+}
+
+/**
+ * hdmi_vendor_infoframe_unpack() - unpack binary buffer to a HDMI vendor infoframe
+ * @buffer: source buffer
+ * @frame: HDMI Vendor infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Vendor information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int
+hdmi_vendor_any_infoframe_unpack(union hdmi_vendor_any_infoframe *frame,
+				 void *buffer)
+{
+	u8 *ptr = buffer;
+	size_t length;
+	int ret;
+	u8 hdmi_video_format;
+	struct hdmi_vendor_infoframe *hvf = &frame->hdmi;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_VENDOR ||
+	    ptr[1] != 1 ||
+	    (ptr[2] != 4 && ptr[2] != 5 && ptr[2] != 6))
+		return -EINVAL;
+
+	length = ptr[2];
+
+	if (hdmi_infoframe_checksum(buffer,
+				    HDMI_INFOFRAME_HEADER_SIZE + length) != 0)
+		return -EINVAL;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	/* HDMI OUI */
+	if (ptr[0] != 0x03 ||
+	    ptr[1] != 0x0c ||
+	    ptr[2] != 0x00)
+		return -EINVAL;
+
+	hdmi_video_format = ptr[3] >> 5;
+
+	if (hdmi_video_format > 0x2)
+		return -EINVAL;
+
+	ret = hdmi_vendor_infoframe_init(hvf);
+	if (ret)
+		return ret;
+
+	hvf->length = length;
+
+	if (hdmi_video_format == 0x2) {
+		if (length != 5 && length != 6)
+			return -EINVAL;
+		hvf->s3d_struct = ptr[4] >> 4;
+		if (hvf->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF) {
+			if (length != 6)
+				return -EINVAL;
+			hvf->s3d_ext_data = ptr[5] >> 4;
+		}
+	} else if (hdmi_video_format == 0x1) {
+		if (length != 5)
+			return -EINVAL;
+		hvf->vic = ptr[4];
+	} else {
+		if (length != 4)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * hdmi_infoframe_unpack() - unpack binary buffer to a HDMI infoframe
+ * @buffer: source buffer
+ * @frame: HDMI infoframe
+ *
+ * Unpacks the information contained in binary buffer @buffer into a structured
+ * @frame of a HDMI infoframe.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_infoframe_unpack(union hdmi_infoframe *frame, void *buffer)
+{
+	int ret;
+	u8 *ptr = buffer;
+
+	switch (ptr[0]) {
+	case HDMI_INFOFRAME_TYPE_AVI:
+		ret = hdmi_avi_infoframe_unpack(&frame->avi, buffer);
+		break;
+	case HDMI_INFOFRAME_TYPE_SPD:
+		ret = hdmi_spd_infoframe_unpack(&frame->spd, buffer);
+		break;
+	case HDMI_INFOFRAME_TYPE_AUDIO:
+		ret = hdmi_audio_infoframe_unpack(&frame->audio, buffer);
+		break;
+	case HDMI_INFOFRAME_TYPE_VENDOR:
+		ret = hdmi_vendor_any_infoframe_unpack(&frame->vendor, buffer);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+bool drm_mode_equal(const struct base_drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2)
+{
+	if (mode1->clock == mode2->clock &&
+	    mode1->hdisplay == mode2->hdisplay &&
+	    mode1->hsync_start == mode2->hsync_start &&
+	    mode1->hsync_end == mode2->hsync_end &&
+	    mode1->htotal == mode2->htotal &&
+	    mode1->vdisplay == mode2->vdisplay &&
+	    mode1->vsync_start == mode2->vsync_start &&
+	    mode1->vsync_end == mode2->vsync_end &&
+	    mode1->vtotal == mode2->vtotal &&
+	    mode1->flags == mode2->flags)
+		return true;
+
+	return false;
+}
+
+/**
+ * drm_mode_sort - sort mode list
+ * @edid_data: modes structures to sort
+ *
+ * Sort @edid_data by favorability, moving good modes to the head of the list.
+ */
+void drm_mode_sort(struct hdmi_edid_data *edid_data)
+{
+	struct drm_display_mode *a, *b;
+	struct drm_display_mode c;
+	int diff, i, j;
+
+	for (i = 0; i < (edid_data->modes - 1); i++) {
+		a = &edid_data->mode_buf[i];
+		for (j = i + 1; j < edid_data->modes; j++) {
+			b = &edid_data->mode_buf[j];
+			diff = ((b->type & DRM_MODE_TYPE_PREFERRED) != 0) -
+				((a->type & DRM_MODE_TYPE_PREFERRED) != 0);
+			if (diff) {
+				if (diff > 0) {
+					c = *a;
+					*a = *b;
+					*b = c;
+				}
+				continue;
+			}
+
+			diff = b->hdisplay * b->vdisplay
+				- a->hdisplay * a->vdisplay;
+			if (diff) {
+				if (diff > 0) {
+					c = *a;
+					*a = *b;
+					*b = c;
+				}
+				continue;
+			}
+
+			diff = b->vrefresh - a->vrefresh;
+			if (diff) {
+				if (diff > 0) {
+					c = *a;
+					*a = *b;
+					*b = c;
+				}
+				continue;
+			}
+
+			diff = b->clock - a->clock;
+			if (diff > 0) {
+				c = *a;
+				*a = *b;
+				*b = c;
+			}
+		}
+	}
+	edid_data->preferred_mode = &edid_data->mode_buf[0];
+}
+
+/**
+ * drm_mode_prune_invalid - remove invalid modes from mode list
+ * @edid_data: structure store mode list
+ * Returns:
+ * Number of valid modes.
+ */
+int drm_mode_prune_invalid(struct hdmi_edid_data *edid_data)
+{
+	int i, j;
+	int num = edid_data->modes;
+	int len = sizeof(struct drm_display_mode);
+	struct drm_display_mode *mode_buf = edid_data->mode_buf;
+
+	for (i = 0; i < num; i++) {
+		if (mode_buf[i].invalid) {
+			/* If mode is invalid, delete it. */
+			for (j = i; j < num - 1; j++)
+				memcpy(&mode_buf[j], &mode_buf[j + 1], len);
+
+			num--;
+			i--;
+		}
+	}
+	/* Clear redundant modes of mode_buf. */
+	memset(&mode_buf[num], 0, len * (edid_data->modes - num));
+
+	edid_data->modes = num;
+	return num;
+}
+
+/**
+ * drm_rk_filter_whitelist - mark modes out of white list from mode list
+ * @edid_data: structure store mode list
+ */
+void drm_rk_filter_whitelist(struct hdmi_edid_data *edid_data)
+{
+	int i, j, white_len;
+
+	if (sizeof(resolution_white)) {
+		white_len = sizeof(resolution_white) /
+			sizeof(resolution_white[0]);
+		for (i = 0; i < edid_data->modes; i++) {
+			for (j = 0; j < white_len; j++) {
+				if (drm_mode_equal(&resolution_white[j],
+						   &edid_data->mode_buf[i]))
+					break;
+			}
+
+			if (j == white_len)
+				edid_data->mode_buf[i].invalid = true;
+		}
+	}
+}
+
+void drm_rk_select_mode(struct hdmi_edid_data *edid_data,
+			struct base_screen_info *screen_info)
+{
+	int i;
+	const struct base_drm_display_mode *base_mode;
+
+	if (!screen_info) {
+		/* define init resolution here */
+	} else {
+		base_mode = &screen_info->mode;
+		for (i = 0; i < edid_data->modes; i++) {
+			if (drm_mode_equal(base_mode,
+					   &edid_data->mode_buf[i])) {
+				edid_data->preferred_mode =
+					&edid_data->mode_buf[i];
+				break;
+			}
+		}
+	}
+}
+
+/**
+ * drm_do_probe_ddc_edid() - get EDID information via I2C
+ * @adap: ddc adapter
+ * @buf: EDID data buffer to be filled
+ * @block: 128 byte EDID block to start fetching from
+ * @len: EDID data buffer length to fetch
+ *
+ * Try to fetch EDID information by calling I2C driver functions.
+ *
+ * Return: 0 on success or -1 on failure.
+ */
+static int
+drm_do_probe_ddc_edid(struct ddc_adapter *adap, u8 *buf, unsigned int block,
+		      size_t len)
+{
+	unsigned char start = block * HDMI_EDID_BLOCK_SIZE;
+	unsigned char segment = block >> 1;
+	unsigned char xfers = segment ? 3 : 2;
+	int ret, retries = 5;
+
+	do {
+		struct i2c_msg msgs[] = {
+			{
+				.addr	= DDC_SEGMENT_ADDR,
+				.flags	= 0,
+				.len	= 1,
+				.buf	= &segment,
+			}, {
+				.addr	= DDC_ADDR,
+				.flags	= 0,
+				.len	= 1,
+				.buf	= &start,
+			}, {
+				.addr	= DDC_ADDR,
+				.flags	= I2C_M_RD,
+				.len	= len,
+				.buf	= buf,
+			}
+		};
+
+		if (adap->ops) {
+			ret = adap->ops->xfer(adap->i2c_bus, &msgs[3 - xfers],
+					      xfers);
+			if (!ret)
+				ret = xfers;
+		} else {
+			ret = adap->ddc_xfer(adap, &msgs[3 - xfers], xfers);
+		}
+	} while (ret != xfers && --retries);
+
+	/* All msg transfer successfully. */
+	return ret == xfers ? 0 : -1;
+}
+
+int drm_do_get_edid(struct ddc_adapter *adap, u8 *edid)
+{
+	int i, j, block_num, block = 0;
+	bool edid_corrupt;
+#ifdef DEBUG
+	u8 *buff;
+#endif
+
+	/* base block fetch */
+	for (i = 0; i < 4; i++) {
+		if (drm_do_probe_ddc_edid(adap, edid, 0, HDMI_EDID_BLOCK_SIZE))
+			goto err;
+		if (drm_edid_block_valid(edid, 0, true,
+					 &edid_corrupt))
+			break;
+		if (i == 0 && drm_edid_is_zero(edid, HDMI_EDID_BLOCK_SIZE)) {
+			printf("edid base block is 0, get edid failed\n");
+			goto err;
+		}
+	}
+
+	if (i == 4)
+		goto err;
+
+	block++;
+	/* get the number of extensions */
+	block_num = edid[0x7e];
+
+	for (j = 1; j <= block_num; j++) {
+		for (i = 0; i < 4; i++) {
+			if (drm_do_probe_ddc_edid(adap, &edid[0x80 * j], j,
+						  HDMI_EDID_BLOCK_SIZE))
+				goto err;
+			if (drm_edid_block_valid(&edid[0x80 * j], j,
+						 true, NULL))
+				break;
+		}
+
+		if (i == 4)
+			goto err;
+		block++;
+	}
+
+#ifdef DEBUG
+	printf("RAW EDID:\n");
+	for (i = 0; i < block_num + 1; i++) {
+		buff = &edid[0x80 * i];
+		for (j = 0; j < HDMI_EDID_BLOCK_SIZE; j++) {
+			if (j % 16 == 0)
+				printf("\n");
+			printf("0x%02x, ", buff[j]);
+		}
+		printf("\n");
+	}
+#endif
+
+	return 0;
+
+err:
+	printf("can't get edid block:%d\n", block);
+	/* clear all read edid block, include invalid block */
+	memset(edid, 0, HDMI_EDID_BLOCK_SIZE * (block + 1));
+	return -EFAULT;
+}
+
+static ssize_t hdmi_ddc_read(struct ddc_adapter *adap, u16 addr, u8 offset,
+			     void *buffer, size_t size)
+{
+	struct i2c_msg msgs[2] = {
+		{
+			.addr = addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &offset,
+		}, {
+			.addr = addr,
+			.flags = I2C_M_RD,
+			.len = size,
+			.buf = buffer,
+		}
+	};
+
+	return adap->ddc_xfer(adap, msgs, ARRAY_SIZE(msgs));
+}
+
+static ssize_t hdmi_ddc_write(struct ddc_adapter *adap, u16 addr, u8 offset,
+			      const void *buffer, size_t size)
+{
+	struct i2c_msg msg = {
+		.addr = addr,
+		.flags = 0,
+		.len = 1 + size,
+		.buf = NULL,
+	};
+	void *data;
+	int err;
+
+	data = malloc(1 + size);
+	if (!data)
+		return -ENOMEM;
+
+	msg.buf = data;
+
+	memcpy(data, &offset, sizeof(offset));
+	memcpy(data + 1, buffer, size);
+
+	err = adap->ddc_xfer(adap, &msg, 1);
+
+	free(data);
+
+	return err;
+}
+
+/**
+ * drm_scdc_readb - read a single byte from SCDC
+ * @adap: ddc adapter
+ * @offset: offset of register to read
+ * @value: return location for the register value
+ *
+ * Reads a single byte from SCDC. This is a convenience wrapper around the
+ * drm_scdc_read() function.
+ *
+ * Returns:
+ * 0 on success or a negative error code on failure.
+ */
+u8 drm_scdc_readb(struct ddc_adapter *adap, u8 offset,
+		  u8 *value)
+{
+	return hdmi_ddc_read(adap, SCDC_I2C_SLAVE_ADDRESS, offset, value,
+			     sizeof(*value));
+}
+
+/**
+ * drm_scdc_writeb - write a single byte to SCDC
+ * @adap: ddc adapter
+ * @offset: offset of register to read
+ * @value: return location for the register value
+ *
+ * Writes a single byte to SCDC. This is a convenience wrapper around the
+ * drm_scdc_write() function.
+ *
+ * Returns:
+ * 0 on success or a negative error code on failure.
+ */
+u8 drm_scdc_writeb(struct ddc_adapter *adap, u8 offset,
+		   u8 value)
+{
+	return hdmi_ddc_write(adap, SCDC_I2C_SLAVE_ADDRESS, offset, &value,
+			      sizeof(value));
+}
+
diff --git a/common/fb_mmc.c b/common/fb_mmc.c
old mode 100644
new mode 100755
index 26d60b88d0..e083daa0e4
--- a/common/fb_mmc.c
+++ b/common/fb_mmc.c
@@ -15,7 +15,9 @@
 #include <div64.h>
 #include <linux/compat.h>
 #include <android_image.h>
-
+#ifdef CONFIG_RKIMG_BOOTLOADER
+#include <boot_rkimg.h>
+#endif
 /*
  * FIXME: Ensure we always set these names via Kconfig once xxx_PARTITION is
  * migrated
@@ -30,6 +32,8 @@
 #endif
 
 #define BOOT_PARTITION_NAME "boot"
+#define FASTBOOT_MAX_BLK_WRITE 16384
+static ulong timer;
 
 struct fb_mmc_sparse {
 	struct blk_desc	*dev_desc;
@@ -57,13 +61,37 @@ static int part_get_info_by_name_or_alias(struct blk_desc *dev_desc,
 	return ret;
 }
 
+static lbaint_t fb_mmc_blk_write(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt, const void *buffer)
+{
+	lbaint_t blk = start;
+	lbaint_t blks_written;
+	lbaint_t cur_blkcnt;
+	lbaint_t blks = 0;
+	int i;
+	for (i = 0; i < blkcnt; i += FASTBOOT_MAX_BLK_WRITE) {
+		cur_blkcnt = min((int)blkcnt-i, FASTBOOT_MAX_BLK_WRITE);
+		if (buffer != NULL) {
+			timed_send_info(&timer, "writing");
+			blks_written = blk_dwrite(block_dev, blk, cur_blkcnt,
+					buffer+(i*block_dev->blksz));
+		} else {
+			timed_send_info(&timer, "erasing");
+			blks_written = blk_derase(block_dev, blk, cur_blkcnt);
+		}
+		blk += blks_written;
+		blks += blks_written;
+	}
+	return blks;
+}
+
 static lbaint_t fb_mmc_sparse_write(struct sparse_storage *info,
 		lbaint_t blk, lbaint_t blkcnt, const void *buffer)
 {
 	struct fb_mmc_sparse *sparse = info->priv;
 	struct blk_desc *dev_desc = sparse->dev_desc;
 
-	return blk_dwrite(dev_desc, blk, blkcnt, buffer);
+	return fb_mmc_blk_write(dev_desc, blk, blkcnt, buffer);
 }
 
 static lbaint_t fb_mmc_sparse_reserve(struct sparse_storage *info,
@@ -74,7 +102,7 @@ static lbaint_t fb_mmc_sparse_reserve(struct sparse_storage *info,
 
 static void write_raw_image(struct blk_desc *dev_desc, disk_partition_t *info,
 		const char *part_name, void *buffer,
-		unsigned int download_bytes)
+		unsigned int download_bytes, char *response)
 {
 	lbaint_t blkcnt;
 	lbaint_t blks;
@@ -84,23 +112,23 @@ static void write_raw_image(struct blk_desc *dev_desc, disk_partition_t *info,
 	blkcnt = lldiv(blkcnt, info->blksz);
 
 	if (blkcnt > info->size) {
-		error("too large for partition: '%s'\n", part_name);
-		fastboot_fail("too large for partition");
+		pr_err("too large for partition: '%s'\n", part_name);
+		fastboot_fail("too large for partition", response);
 		return;
 	}
 
 	puts("Flashing Raw Image\n");
 
-	blks = blk_dwrite(dev_desc, info->start, blkcnt, buffer);
+	blks = fb_mmc_blk_write(dev_desc, info->start, blkcnt, buffer);
 	if (blks != blkcnt) {
-		error("failed writing to device %d\n", dev_desc->devnum);
-		fastboot_fail("failed writing to device");
+		pr_err("failed writing to device %d\n", dev_desc->devnum);
+		fastboot_fail("failed writing to device", response);
 		return;
 	}
 
 	printf("........ wrote " LBAFU " bytes to '%s'\n", blkcnt * info->blksz,
 	       part_name);
-	fastboot_okay("");
+	fastboot_okay("", response);
 }
 
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
@@ -115,7 +143,8 @@ static void write_raw_image(struct blk_desc *dev_desc, disk_partition_t *info,
  */
 static lbaint_t fb_mmc_get_boot_header(struct blk_desc *dev_desc,
 				       disk_partition_t *info,
-				       struct andr_img_hdr *hdr)
+				       struct andr_img_hdr *hdr,
+				       char *response)
 {
 	ulong sector_size;		/* boot partition sector size */
 	lbaint_t hdr_sectors;		/* boot image header sectors count */
@@ -125,24 +154,24 @@ static lbaint_t fb_mmc_get_boot_header(struct blk_desc *dev_desc,
 	sector_size = info->blksz;
 	hdr_sectors = DIV_ROUND_UP(sizeof(struct andr_img_hdr), sector_size);
 	if (hdr_sectors == 0) {
-		error("invalid number of boot sectors: 0");
-		fastboot_fail("invalid number of boot sectors: 0");
+		pr_err("invalid number of boot sectors: 0");
+		fastboot_fail("invalid number of boot sectors: 0", response);
 		return 0;
 	}
 
 	/* Read the boot image header */
 	res = blk_dread(dev_desc, info->start, hdr_sectors, (void *)hdr);
 	if (res != hdr_sectors) {
-		error("cannot read header from boot partition");
-		fastboot_fail("cannot read header from boot partition");
+		pr_err("cannot read header from boot partition");
+		fastboot_fail("cannot read header from boot partition", response);
 		return 0;
 	}
 
 	/* Check boot header magic string */
 	res = android_image_check_header(hdr);
 	if (res != 0) {
-		error("bad boot image magic");
-		fastboot_fail("boot partition not initialized");
+		pr_err("bad boot image magic");
+		fastboot_fail("boot partition not initialized", response);
 		return 0;
 	}
 
@@ -160,7 +189,8 @@ static lbaint_t fb_mmc_get_boot_header(struct blk_desc *dev_desc,
  */
 static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 				void *download_buffer,
-				unsigned int download_bytes)
+				unsigned int download_bytes,
+				char *response)
 {
 	uintptr_t hdr_addr;			/* boot image header address */
 	struct andr_img_hdr *hdr;		/* boot image header */
@@ -179,8 +209,8 @@ static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 	/* Get boot partition info */
 	res = part_get_info_by_name(dev_desc, BOOT_PARTITION_NAME, &info);
 	if (res < 0) {
-		error("cannot find boot partition");
-		fastboot_fail("cannot find boot partition");
+		pr_err("cannot find boot partition");
+		fastboot_fail("cannot find boot partition", response);
 		return -1;
 	}
 
@@ -189,17 +219,17 @@ static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 	hdr = (struct andr_img_hdr *)hdr_addr;
 
 	/* Read boot image header */
-	hdr_sectors = fb_mmc_get_boot_header(dev_desc, &info, hdr);
+	hdr_sectors = fb_mmc_get_boot_header(dev_desc, &info, hdr, response);
 	if (hdr_sectors == 0) {
-		error("unable to read boot image header");
-		fastboot_fail("unable to read boot image header");
+		pr_err("unable to read boot image header");
+		fastboot_fail("unable to read boot image header", response);
 		return -1;
 	}
 
 	/* Check if boot image has second stage in it (we don't support it) */
 	if (hdr->second_size > 0) {
-		error("moving second stage is not supported yet");
-		fastboot_fail("moving second stage is not supported yet");
+		pr_err("moving second stage is not supported yet");
+		fastboot_fail("moving second stage is not supported yet", response);
 		return -1;
 	}
 
@@ -216,8 +246,8 @@ static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 	res = blk_dread(dev_desc, ramdisk_sector_start, ramdisk_sectors,
 			ramdisk_buffer);
 	if (res != ramdisk_sectors) {
-		error("cannot read ramdisk from boot partition");
-		fastboot_fail("cannot read ramdisk from boot partition");
+		pr_err("cannot read ramdisk from boot partition");
+		fastboot_fail("cannot read ramdisk from boot partition", response);
 		return -1;
 	}
 
@@ -225,8 +255,8 @@ static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 	hdr->kernel_size = download_bytes;
 	res = blk_dwrite(dev_desc, info.start, hdr_sectors, (void *)hdr);
 	if (res == 0) {
-		error("cannot writeback boot image header");
-		fastboot_fail("cannot write back boot image header");
+		pr_err("cannot writeback boot image header");
+		fastboot_fail("cannot write back boot image header", response);
 		return -1;
 	}
 
@@ -237,8 +267,8 @@ static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 	res = blk_dwrite(dev_desc, kernel_sector_start, kernel_sectors,
 			 download_buffer);
 	if (res == 0) {
-		error("cannot write new kernel");
-		fastboot_fail("cannot write new kernel");
+		pr_err("cannot write new kernel");
+		fastboot_fail("cannot write new kernel", response);
 		return -1;
 	}
 
@@ -249,27 +279,38 @@ static int fb_mmc_update_zimage(struct blk_desc *dev_desc,
 	res = blk_dwrite(dev_desc, ramdisk_sector_start, ramdisk_sectors,
 			 ramdisk_buffer);
 	if (res == 0) {
-		error("cannot write back original ramdisk");
-		fastboot_fail("cannot write back original ramdisk");
+		pr_err("cannot write back original ramdisk");
+		fastboot_fail("cannot write back original ramdisk", response);
 		return -1;
 	}
 
 	puts("........ zImage was updated in boot partition\n");
-	fastboot_okay("");
+	fastboot_okay("", response);
 	return 0;
 }
 #endif
 
 void fb_mmc_flash_write(const char *cmd, void *download_buffer,
-			unsigned int download_bytes)
+			unsigned int download_bytes, char *response)
 {
 	struct blk_desc *dev_desc;
 	disk_partition_t info;
-
+#if CONFIG_IS_ENABLED(EFI_PARTITION)
+	u64 disksize = 0;
+	char reason[128] = {0};
+#endif
+#ifdef CONFIG_RKIMG_BOOTLOADER
+	dev_desc = rockchip_get_bootdev();
+	if (!dev_desc) {
+		printf("%s: dev_desc is NULL!\n", __func__);
+		return;
+	}
+#else
 	dev_desc = blk_get_dev("mmc", CONFIG_FASTBOOT_FLASH_MMC_DEV);
+#endif
 	if (!dev_desc || dev_desc->type == DEV_TYPE_UNKNOWN) {
-		error("invalid mmc device\n");
-		fastboot_fail("invalid mmc device");
+		pr_err("invalid mmc device\n");
+		fastboot_fail("invalid mmc device", response);
 		return;
 	}
 
@@ -280,16 +321,24 @@ void fb_mmc_flash_write(const char *cmd, void *download_buffer,
 		if (is_valid_gpt_buf(dev_desc, download_buffer)) {
 			printf("%s: invalid GPT - refusing to write to flash\n",
 			       __func__);
-			fastboot_fail("invalid GPT partition");
+			disksize = dev_desc->blksz * cpu_to_le64(dev_desc->lba);
+			snprintf(reason, ARRAY_SIZE(reason),
+				 "%s - %s '%lld.%lld MiB')",
+					"invalid GPT partition",
+					"Actual Disk Size",
+					disksize/0x100000,
+					disksize%0x100000);
+			fastboot_fail(reason, response);
 			return;
 		}
 		if (write_mbr_and_gpt_partitions(dev_desc, download_buffer)) {
 			printf("%s: writing GPT partitions failed\n", __func__);
-			fastboot_fail("writing GPT partitions failed");
+			fastboot_fail(
+				      "writing GPT partitions failed", response);
 			return;
 		}
 		printf("........ success\n");
-		fastboot_okay("");
+		fastboot_okay("", response);
 		return;
 	}
 #endif
@@ -300,30 +349,30 @@ void fb_mmc_flash_write(const char *cmd, void *download_buffer,
 		if (is_valid_dos_buf(download_buffer)) {
 			printf("%s: invalid MBR - refusing to write to flash\n",
 			       __func__);
-			fastboot_fail("invalid MBR partition");
+			fastboot_fail("invalid MBR partition", response);
 			return;
 		}
 		if (write_mbr_partition(dev_desc, download_buffer)) {
 			printf("%s: writing MBR partition failed\n", __func__);
-			fastboot_fail("writing MBR partition failed");
+			fastboot_fail("writing MBR partition failed", response);
 			return;
 		}
 		printf("........ success\n");
-		fastboot_okay("");
+		fastboot_okay("", response);
 		return;
 	}
 #endif
 
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
 	if (strncasecmp(cmd, "zimage", 6) == 0) {
-		fb_mmc_update_zimage(dev_desc, download_buffer, download_bytes);
+		fb_mmc_update_zimage(dev_desc, download_buffer, download_bytes, response);
 		return;
 	}
 #endif
 
 	if (part_get_info_by_name_or_alias(dev_desc, cmd, &info) < 0) {
-		error("cannot find partition: '%s'\n", cmd);
-		fastboot_fail("cannot find partition");
+		pr_err("cannot find partition: '%s'\n", cmd);
+		fastboot_fail("cannot find partition", response);
 		return;
 	}
 
@@ -344,14 +393,14 @@ void fb_mmc_flash_write(const char *cmd, void *download_buffer,
 
 		sparse.priv = &sparse_priv;
 		write_sparse_image(&sparse, cmd, download_buffer,
-				   download_bytes);
+				   download_bytes, response);
 	} else {
 		write_raw_image(dev_desc, &info, cmd, download_buffer,
-				download_bytes);
+				download_bytes, response);
 	}
 }
 
-void fb_mmc_erase(const char *cmd)
+void fb_mmc_erase(const char *cmd, char *response)
 {
 	int ret;
 	struct blk_desc *dev_desc;
@@ -360,22 +409,30 @@ void fb_mmc_erase(const char *cmd)
 	struct mmc *mmc = find_mmc_device(CONFIG_FASTBOOT_FLASH_MMC_DEV);
 
 	if (mmc == NULL) {
-		error("invalid mmc device");
-		fastboot_fail("invalid mmc device");
+		pr_err("invalid mmc device");
+		fastboot_fail("invalid mmc device", response);
 		return;
 	}
 
+#ifdef CONFIG_RKIMG_BOOTLOADER
+	dev_desc = rockchip_get_bootdev();
+	if (!dev_desc) {
+		printf("%s: dev_desc is NULL!\n", __func__);
+		return;
+	}
+#else
 	dev_desc = blk_get_dev("mmc", CONFIG_FASTBOOT_FLASH_MMC_DEV);
+#endif
 	if (!dev_desc || dev_desc->type == DEV_TYPE_UNKNOWN) {
-		error("invalid mmc device");
-		fastboot_fail("invalid mmc device");
+		pr_err("invalid mmc device");
+		fastboot_fail("invalid mmc device", response);
 		return;
 	}
 
 	ret = part_get_info_by_name_or_alias(dev_desc, cmd, &info);
 	if (ret < 0) {
-		error("cannot find partition: '%s'", cmd);
-		fastboot_fail("cannot find partition");
+		pr_err("cannot find partition: '%s'", cmd);
+		fastboot_fail("cannot find partition", response);
 		return;
 	}
 
@@ -391,14 +448,30 @@ void fb_mmc_erase(const char *cmd)
 	printf("Erasing blocks " LBAFU " to " LBAFU " due to alignment\n",
 	       blks_start, blks_start + blks_size);
 
-	blks = blk_derase(dev_desc, blks_start, blks_size);
+	blks = fb_mmc_blk_write(dev_desc, blks_start, blks_size, NULL);
 	if (blks != blks_size) {
-		error("failed erasing from device %d", dev_desc->devnum);
-		fastboot_fail("failed erasing from device");
+		pr_err("failed erasing from device %d", dev_desc->devnum);
+		fastboot_fail("failed erasing from device", response);
 		return;
 	}
 
 	printf("........ erased " LBAFU " bytes from '%s'\n",
 	       blks_size * info.blksz, cmd);
-	fastboot_okay("");
+	fastboot_okay("", response);
+}
+
+lbaint_t fb_mmc_get_erase_grp_size(void)
+{
+	lbaint_t grp_size;
+
+	struct mmc *mmc = find_mmc_device(CONFIG_FASTBOOT_FLASH_MMC_DEV);
+
+	if (!mmc) {
+		pr_err("invalid mmc device");
+		return -1;
+	}
+
+	grp_size = mmc->erase_grp_size << 9;
+
+	return  grp_size;
 }
diff --git a/common/fb_nand.c b/common/fb_nand.c
index 3d027d4375..c530623393 100644
--- a/common/fb_nand.c
+++ b/common/fb_nand.c
@@ -32,7 +32,8 @@ __weak int board_fastboot_write_partition_setup(char *name)
 
 static int fb_nand_lookup(const char *partname,
 			  struct mtd_info **mtd,
-			  struct part_info **part)
+			  struct part_info **part
+			  char *response)
 {
 	struct mtd_device *dev;
 	int ret;
@@ -40,22 +41,22 @@ static int fb_nand_lookup(const char *partname,
 
 	ret = mtdparts_init();
 	if (ret) {
-		error("Cannot initialize MTD partitions\n");
-		fastboot_fail("cannot init mtdparts");
+		pr_err("Cannot initialize MTD partitions\n");
+		fastboot_fail("cannot init mtdparts", response);
 		return ret;
 	}
 
 	ret = find_dev_and_part(partname, &dev, &pnum, part);
 	if (ret) {
-		error("cannot find partition: '%s'", partname);
-		fastboot_fail("cannot find partition");
+		pr_err("cannot find partition: '%s'", partname);
+		fastboot_fail("cannot find partition", response);
 		return ret;
 	}
 
 	if (dev->id->type != MTD_DEV_TYPE_NAND) {
-		error("partition '%s' is not stored on a NAND device",
+		pr_err("partition '%s' is not stored on a NAND device",
 		      partname);
-		fastboot_fail("not a NAND device");
+		fastboot_fail("not a NAND device", response);
 		return -EINVAL;
 	}
 
@@ -146,16 +147,16 @@ static lbaint_t fb_nand_sparse_reserve(struct sparse_storage *info,
 }
 
 void fb_nand_flash_write(const char *cmd, void *download_buffer,
-			 unsigned int download_bytes)
+			 unsigned int download_bytes, char *response)
 {
 	struct part_info *part;
 	struct mtd_info *mtd = NULL;
 	int ret;
 
-	ret = fb_nand_lookup(cmd, &mtd, &part);
+	ret = fb_nand_lookup(cmd, &mtd, &part, response);
 	if (ret) {
-		error("invalid NAND device");
-		fastboot_fail("invalid NAND device");
+		pr_err("invalid NAND device");
+		fastboot_fail("invalid NAND device", response);
 		return;
 	}
 
@@ -181,7 +182,7 @@ void fb_nand_flash_write(const char *cmd, void *download_buffer,
 
 		sparse.priv = &sparse_priv;
 		write_sparse_image(&sparse, cmd, download_buffer,
-				   download_bytes);
+				   download_bytes, response);
 	} else {
 		printf("Flashing raw image at offset 0x%llx\n",
 		       part->offset);
@@ -194,23 +195,23 @@ void fb_nand_flash_write(const char *cmd, void *download_buffer,
 	}
 
 	if (ret) {
-		fastboot_fail("error writing the image");
+		fastboot_fail("pr_err writing the image", response);
 		return;
 	}
 
-	fastboot_okay("");
+	fastboot_okay("", response);
 }
 
-void fb_nand_erase(const char *cmd)
+void fb_nand_erase(const char *cmd, char *response)
 {
 	struct part_info *part;
 	struct mtd_info *mtd = NULL;
 	int ret;
 
-	ret = fb_nand_lookup(cmd, &mtd, &part);
+	ret = fb_nand_lookup(cmd, &mtd, &part, response);
 	if (ret) {
-		error("invalid NAND device");
-		fastboot_fail("invalid NAND device");
+		pr_err("invalid NAND device");
+		fastboot_fail("invalid NAND device", response);
 		return;
 	}
 
@@ -220,10 +221,10 @@ void fb_nand_erase(const char *cmd)
 
 	ret = _fb_nand_erase(mtd, part);
 	if (ret) {
-		error("failed erasing from device %s", mtd->name);
-		fastboot_fail("failed erasing from device");
+		pr_err("failed erasing from device %s", mtd->name);
+		fastboot_fail("failed erasing from device", response);
 		return;
 	}
 
-	fastboot_okay("");
+	fastboot_okay("", response);
 }
diff --git a/common/fdt_support.c b/common/fdt_support.c
index 916a448c11..6ccd09c667 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -8,15 +8,23 @@
  */
 
 #include <common.h>
+#include <android_image.h>
+#include <exports.h>
+#include <fdt_support.h>
+#include <fdtdec.h>
 #include <inttypes.h>
+#include <malloc.h>
+#ifdef CONFIG_MTD_BLK
+#include <mtd_blk.h>
+#endif
 #include <stdio_dev.h>
+#include <asm/arch-rockchip/hotkey.h>
+#include <asm/global_data.h>
 #include <linux/ctype.h>
+#include <linux/libfdt.h>
 #include <linux/types.h>
-#include <asm/global_data.h>
-#include <libfdt.h>
-#include <fdt_support.h>
-#include <exports.h>
-#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
 
 /**
  * fdt_getprop_u32_default_node - Return a node's property or a default
@@ -177,8 +185,8 @@ static int fdt_fixup_stdout(void *fdt, int chosenoff)
 }
 #endif
 
-static inline int fdt_setprop_uxx(void *fdt, int nodeoffset, const char *name,
-				  uint64_t val, int is_u64)
+int fdt_setprop_uxx(void *fdt, int nodeoffset, const char *name,
+		    uint64_t val, int is_u64)
 {
 	if (is_u64)
 		return fdt_setprop_u64(fdt, nodeoffset, name, val);
@@ -272,6 +280,78 @@ int fdt_initrd(void *fdt, ulong initrd_start, ulong initrd_end)
 	return 0;
 }
 
+int fdt_bootargs_append(void *fdt, char *data)
+{
+	const char *arr_bootargs[] = { "bootargs", "bootargs_ext" };
+	int nodeoffset, len;
+	const char *bootargs;
+	char *str;
+	int i, ret = 0;
+
+	if (!data)
+		return 0;
+
+	/* find or create "/chosen" node. */
+	nodeoffset = fdt_find_or_add_subnode(fdt, 0, "chosen");
+	if (nodeoffset < 0)
+		return nodeoffset;
+
+	for (i = 0; i < ARRAY_SIZE(arr_bootargs); i++) {
+		bootargs = fdt_getprop(fdt, nodeoffset,
+				       arr_bootargs[i], NULL);
+		if (bootargs) {
+			len = strlen(bootargs) + strlen(data) + 2;
+			str = malloc(len);
+			if (!str)
+				return -ENOMEM;
+
+			fdt_increase_size(fdt, 512);
+			snprintf(str, len, "%s %s", bootargs, data);
+			ret = fdt_setprop(fdt, nodeoffset, arr_bootargs[i],
+					  str, len);
+			if (ret < 0)
+				printf("WARNING: could not set bootargs %s.\n", fdt_strerror(ret));
+
+			free(str);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+int fdt_bootargs_append_ab(void *fdt, char *slot)
+{
+	char *str;
+	int len, ret = 0;
+
+	if (!slot)
+		return 0;
+
+	len = strlen(ANDROID_ARG_SLOT_SUFFIX) + strlen(slot) + 1;
+	str = malloc(len);
+	if (!str)
+		return -ENOMEM;
+
+	snprintf(str, len, "%s%s", ANDROID_ARG_SLOT_SUFFIX, slot);
+	ret = fdt_bootargs_append(fdt, str);
+	if (ret)
+		printf("Apend slot info to bootargs fail");
+
+	free(str);
+
+	return ret;
+}
+
+/**
+ * board_fdt_chosen_bootargs - boards may override this function to use
+ *                             alternative kernel command line arguments
+ */
+__weak char *board_fdt_chosen_bootargs(void *fdt)
+{
+	return env_get("bootargs");
+}
+
 int fdt_chosen(void *fdt)
 {
 	int   nodeoffset;
@@ -289,7 +369,7 @@ int fdt_chosen(void *fdt)
 	if (nodeoffset < 0)
 		return nodeoffset;
 
-	str = env_get("bootargs");
+	str = board_fdt_chosen_bootargs(fdt);
 	if (str) {
 		err = fdt_setprop(fdt, nodeoffset, "bootargs", str,
 				  strlen(str) + 1);
@@ -381,7 +461,6 @@ void do_fixup_by_compat_u32(void *fdt, const char *compat,
 	do_fixup_by_compat(fdt, compat, prop, &tmp, 4, create);
 }
 
-#ifdef CONFIG_ARCH_FIXUP_FDT_MEMORY
 /*
  * fdt_pack_reg - pack address and size array into the "reg"-suitable stream
  */
@@ -410,11 +489,52 @@ static int fdt_pack_reg(const void *fdt, void *buf, u64 *address, u64 *size,
 	return p - (char *)buf;
 }
 
+int fdt_record_loadable(void *blob, u32 index, const char *name,
+			uintptr_t load_addr, u32 size, uintptr_t entry_point,
+			const char *type, const char *os)
+{
+	int err, node;
+
+	err = fdt_check_header(blob);
+	if (err < 0) {
+		printf("%s: %s\n", __func__, fdt_strerror(err));
+		return err;
+	}
+
+	/* find or create "/fit-images" node */
+	node = fdt_find_or_add_subnode(blob, 0, "fit-images");
+	if (node < 0)
+			return node;
+
+	/* find or create "/fit-images/<name>" node */
+	node = fdt_find_or_add_subnode(blob, node, name);
+	if (node < 0)
+		return node;
+
+	/*
+	 * We record these as 32bit entities, possibly truncating addresses.
+	 * However, spl_fit.c is not 64bit safe either: i.e. we should not
+	 * have an issue here.
+	 */
+	fdt_setprop_u32(blob, node, "load-addr", load_addr);
+	if (entry_point != -1)
+		fdt_setprop_u32(blob, node, "entry-point", entry_point);
+	fdt_setprop_u32(blob, node, "size", size);
+	if (type)
+		fdt_setprop_string(blob, node, "type", type);
+	if (os)
+		fdt_setprop_string(blob, node, "os", os);
+
+	return node;
+}
+
 #ifdef CONFIG_NR_DRAM_BANKS
 #define MEMORY_BANKS_MAX CONFIG_NR_DRAM_BANKS
 #else
 #define MEMORY_BANKS_MAX 4
 #endif
+
+#ifdef CONFIG_ARCH_FIXUP_FDT_MEMORY
 int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks)
 {
 	int err, nodeoffset;
@@ -437,7 +557,7 @@ int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks)
 	/* find or create "/memory" node. */
 	nodeoffset = fdt_find_or_add_subnode(blob, 0, "memory");
 	if (nodeoffset < 0)
-			return nodeoffset;
+		return nodeoffset;
 
 	err = fdt_setprop(blob, nodeoffset, "device_type", "memory",
 			sizeof("memory"));
@@ -460,6 +580,29 @@ int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks)
 	}
 	return 0;
 }
+#else
+int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks)
+{
+	struct fdt_resource res;
+	int i, nodeoffset;
+
+	/* show memory */
+	nodeoffset = fdt_subnode_offset(blob, 0, "memory");
+	if (nodeoffset > 0) {
+		for (i = 0; i < MEMORY_BANKS_MAX; i++) {
+			if (fdt_get_resource(blob, nodeoffset, "reg", i, &res))
+				break;
+			res.end += 1;
+			if (!res.start && !res.end)
+				break;
+			printf("fixed bank: 0x%08llx - 0x%08llx (size: 0x%08llx)\n",
+			       (u64)res.start, (u64)res.end, (u64)res.end - (u64)res.start);
+		}
+	}
+
+	return 0;
+}
+
 #endif
 
 int fdt_fixup_memory(void *blob, u64 start, u64 size)
@@ -467,14 +610,41 @@ int fdt_fixup_memory(void *blob, u64 start, u64 size)
 	return fdt_fixup_memory_banks(blob, &start, &size, 1);
 }
 
+int fdt_update_reserved_memory(void *blob, char *name, u64 start, u64 size)
+{
+	int nodeoffset, len, err;
+	u8 tmp[16]; /* Up to 64-bit address + 64-bit size */
+
+	nodeoffset = fdt_node_offset_by_compatible(blob, 0, name);
+	if (nodeoffset < 0)
+		debug("Can't find nodeoffset: %d\n", nodeoffset);
+
+	if (!size)
+		return nodeoffset;
+
+	len = fdt_pack_reg(blob, tmp, &start, &size, 1);
+	err = fdt_setprop(blob, nodeoffset, "reg", tmp, len);
+	if (err < 0) {
+		printf("WARNING: could not set %s %s.\n",
+				"reg", fdt_strerror(err));
+		return err;
+	}
+
+	return nodeoffset;
+}
+
 void fdt_fixup_ethernet(void *fdt)
 {
-	int i, j, prop;
+	int i = 0, j, prop;
 	char *tmp, *end;
 	char mac[16];
 	const char *path;
 	unsigned char mac_addr[ARP_HLEN];
 	int offset;
+#ifdef FDT_SEQ_MACADDR_FROM_ENV
+	int nodeoff;
+	const struct fdt_property *fdt_prop;
+#endif
 
 	if (fdt_path_offset(fdt, "/aliases") < 0)
 		return;
@@ -487,7 +657,7 @@ void fdt_fixup_ethernet(void *fdt)
 		offset = fdt_first_property_offset(fdt,
 			fdt_path_offset(fdt, "/aliases"));
 		/* Select property number 'prop' */
-		for (i = 0; i < prop; i++)
+		for (j = 0; j < prop; j++)
 			offset = fdt_next_property_offset(fdt, offset);
 
 		if (offset < 0)
@@ -496,11 +666,16 @@ void fdt_fixup_ethernet(void *fdt)
 		path = fdt_getprop_by_offset(fdt, offset, &name, NULL);
 		if (!strncmp(name, "ethernet", 8)) {
 			/* Treat plain "ethernet" same as "ethernet0". */
-			if (!strcmp(name, "ethernet"))
+			if (!strcmp(name, "ethernet")
+#ifdef FDT_SEQ_MACADDR_FROM_ENV
+			 || !strcmp(name, "ethernet0")
+#endif
+			)
 				i = 0;
+#ifndef FDT_SEQ_MACADDR_FROM_ENV
 			else
 				i = trailing_strtol(name);
-
+#endif
 			if (i != -1) {
 				if (i == 0)
 					strcpy(mac, "ethaddr");
@@ -509,6 +684,14 @@ void fdt_fixup_ethernet(void *fdt)
 			} else {
 				continue;
 			}
+#ifdef FDT_SEQ_MACADDR_FROM_ENV
+			nodeoff = fdt_path_offset(fdt, path);
+			fdt_prop = fdt_get_property(fdt, nodeoff, "status",
+						    NULL);
+			if (fdt_prop && !strcmp(fdt_prop->data, "disabled"))
+				continue;
+			i++;
+#endif
 			tmp = env_get(mac);
 			if (!tmp)
 				continue;
@@ -1655,3 +1838,34 @@ int fdt_fixup_display(void *blob, const char *path, const char *display)
 	}
 	return toff;
 }
+
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+/**
+ * fdt_overlay_apply_verbose - Apply an overlay with verbose error reporting
+ *
+ * @fdt: ptr to device tree
+ * @fdto: ptr to device tree overlay
+ *
+ * Convenience function to apply an overlay and display helpful messages
+ * in the case of an error
+ */
+int fdt_overlay_apply_verbose(void *fdt, void *fdto)
+{
+	int err;
+	bool has_symbols;
+
+	err = fdt_path_offset(fdt, "/__symbols__");
+	has_symbols = err >= 0;
+
+	err = fdt_overlay_apply(fdt, fdto);
+	if (err < 0) {
+		printf("failed on fdt_overlay_apply(): %s\n",
+				fdt_strerror(err));
+		if (!has_symbols) {
+			printf("base fdt does did not have a /__symbols__ node\n");
+			printf("make sure you've compiled with -@\n");
+		}
+	}
+	return err;
+}
+#endif
diff --git a/common/flash.c b/common/flash.c
index 587ef60158..876677493f 100644
--- a/common/flash.c
+++ b/common/flash.c
@@ -112,7 +112,7 @@ addr2info (ulong addr)
  * and no protected sectors are hit.
  * Returns:
  * ERR_OK          0 - OK
- * ERR_TIMOUT      1 - write timeout
+ * ERR_TIMEOUT     1 - write timeout
  * ERR_NOT_ERASED  2 - Flash not erased
  * ERR_PROTECTED   4 - target range includes protected sectors
  * ERR_INVAL       8 - target address not in Flash memory
@@ -185,7 +185,7 @@ void flash_perror (int err)
 	switch (err) {
 	case ERR_OK:
 		break;
-	case ERR_TIMOUT:
+	case ERR_TIMEOUT:
 		puts ("Timeout writing to Flash\n");
 		break;
 	case ERR_NOT_ERASED:
diff --git a/common/image-android.c b/common/image-android.c
index e74d0aafca..24e6a897c3 100644
--- a/common/image-android.c
+++ b/common/image-android.c
@@ -7,12 +7,57 @@
 #include <common.h>
 #include <image.h>
 #include <android_image.h>
+#include <android_bootloader.h>
 #include <malloc.h>
+#include <mapmem.h>
 #include <errno.h>
+#include <boot_rkimg.h>
+#include <crypto.h>
+#include <sysmem.h>
+#include <u-boot/sha1.h>
+#ifdef CONFIG_RKIMG_BOOTLOADER
+#include <asm/arch-rockchip/resource_img.h>
+#endif
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+#include <android_avb/avb_slot_verify.h>
+#include <android_avb/avb_ops_user.h>
+#include <android_avb/rk_avb_ops_user.h>
+#endif
+#include <optee_include/OpteeClientInterface.h>
+
+DECLARE_GLOBAL_DATA_PTR;
 
 #define ANDROID_IMAGE_DEFAULT_KERNEL_ADDR	0x10008000
+#define ANDROID_Q_VER				10
+#define ANDROID_PARTITION_VENDOR_BOOT		"vendor_boot"
+
+#define BLK_CNT(_num_bytes, _block_size)	\
+		((_num_bytes + _block_size - 1) / _block_size)
 
 static char andr_tmp_str[ANDR_BOOT_ARGS_SIZE + 1];
+static u32 android_kernel_comp_type = IH_COMP_NONE;
+
+u32 android_image_major_version(void)
+{
+	/* MSB 7-bits */
+	return gd->bd->bi_andr_version >> 25;
+}
+
+u32 android_bcb_msg_sector_offset(void)
+{
+	/*
+	 * Rockchip platforms defines BCB message at the 16KB offset of
+	 * misc partition while the Google defines it at 0x00 offset.
+	 *
+	 * From Android-Q, the 0x00 offset is mandary on Google VTS, so that
+	 * this is a compatibility according to android image 'os_version'.
+	 */
+#ifdef CONFIG_RKIMG_BOOTLOADER
+	return (android_image_major_version() >= ANDROID_Q_VER) ? 0x00 : 0x20;
+#else
+	return 0x00;
+#endif
+}
 
 static ulong android_image_get_kernel_addr(const struct andr_img_hdr *hdr)
 {
@@ -21,7 +66,7 @@ static ulong android_image_get_kernel_addr(const struct andr_img_hdr *hdr)
 	 * address as the default.
 	 *
 	 * Even though it doesn't really make a lot of sense, and it
-	 * might be valid on some platforms, we treat that adress as
+	 * might be valid on some platforms, we treat that address as
 	 * the default value for this field, and try to execute the
 	 * kernel in place in such a case.
 	 *
@@ -30,7 +75,41 @@ static ulong android_image_get_kernel_addr(const struct andr_img_hdr *hdr)
 	if (hdr->kernel_addr == ANDROID_IMAGE_DEFAULT_KERNEL_ADDR)
 		return (ulong)hdr + hdr->page_size;
 
+#ifdef CONFIG_ARCH_ROCKCHIP
+	/*
+	 * If kernel is compressed, kernel_addr is set as decompressed address
+	 * after compressed being loaded to ram, so let's use it.
+	 */
+	if (android_kernel_comp_type != IH_COMP_NONE &&
+	    android_kernel_comp_type != IH_COMP_ZIMAGE)
+		return hdr->kernel_addr;
+
+	/*
+	 * Compatble with rockchip legacy packing with kernel/ramdisk/second
+	 * address base from 0x60000000(SDK versiont < 8.1), these are invalid
+	 * address, so we calc it by real size.
+	 */
+	return (ulong)hdr + hdr->page_size;
+#else
 	return hdr->kernel_addr;
+#endif
+
+}
+
+void android_image_set_comp(struct andr_img_hdr *hdr, u32 comp)
+{
+	android_kernel_comp_type = comp;
+}
+
+u32 android_image_get_comp(const struct andr_img_hdr *hdr)
+{
+	return android_kernel_comp_type;
+}
+
+int android_image_parse_kernel_comp(const struct andr_img_hdr *hdr)
+{
+	ulong kaddr = android_image_get_kernel_addr(hdr);
+	return bootm_parse_comp((const unsigned char *)kaddr);
 }
 
 /**
@@ -52,7 +131,8 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 			     ulong *os_data, ulong *os_len)
 {
 	u32 kernel_addr = android_image_get_kernel_addr(hdr);
-
+	const char *cmdline = hdr->header_version < 3 ?
+			      hdr->cmdline : hdr->total_cmdline;
 	/*
 	 * Not all Android tools use the id field for signing the image with
 	 * sha1 (or anything) so we don't check it. It is not obvious that the
@@ -63,13 +143,14 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 	if (strlen(andr_tmp_str))
 		printf("Android's image name: %s\n", andr_tmp_str);
 
-	printf("Kernel load addr 0x%08x size %u KiB\n",
-	       kernel_addr, DIV_ROUND_UP(hdr->kernel_size, 1024));
+	printf("Kernel: 0x%08x - 0x%08x (%u KiB)\n",
+	       kernel_addr, kernel_addr + hdr->kernel_size,
+	       DIV_ROUND_UP(hdr->kernel_size, 1024));
 
 	int len = 0;
-	if (*hdr->cmdline) {
-		printf("Kernel command line: %s\n", hdr->cmdline);
-		len += strlen(hdr->cmdline);
+	if (cmdline) {
+		debug("Kernel command line: %s\n", cmdline);
+		len += strlen(cmdline);
 	}
 
 	char *bootargs = env_get("bootargs");
@@ -87,8 +168,8 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 		strcpy(newbootargs, bootargs);
 		strcat(newbootargs, " ");
 	}
-	if (*hdr->cmdline)
-		strcat(newbootargs, hdr->cmdline);
+	if (cmdline)
+		strcat(newbootargs, cmdline);
 
 	env_set("bootargs", newbootargs);
 
@@ -114,14 +195,37 @@ ulong android_image_get_end(const struct andr_img_hdr *hdr)
 	 * on page boundary
 	 */
 	end = (ulong)hdr;
-	end += hdr->page_size;
-	end += ALIGN(hdr->kernel_size, hdr->page_size);
-	end += ALIGN(hdr->ramdisk_size, hdr->page_size);
-	end += ALIGN(hdr->second_size, hdr->page_size);
+	if (hdr->header_version < 3) {
+		end += hdr->page_size;
+		end += ALIGN(hdr->kernel_size, hdr->page_size);
+		end += ALIGN(hdr->ramdisk_size, hdr->page_size);
+		end += ALIGN(hdr->second_size, hdr->page_size);
+		if (hdr->header_version == 1) {
+			end += ALIGN(hdr->recovery_dtbo_size, hdr->page_size);
+		} else if (hdr->header_version == 2) {
+			end += ALIGN(hdr->recovery_dtbo_size, hdr->page_size);
+			end += ALIGN(hdr->dtb_size, hdr->page_size);
+		}
+	} else {
+		/* boot_img_hdr_v34 */
+		end += hdr->page_size;
+		end += ALIGN(hdr->kernel_size, hdr->page_size);
+		end += ALIGN(hdr->ramdisk_size, hdr->page_size);
+	}
 
 	return end;
 }
 
+u32 android_image_get_ksize(const struct andr_img_hdr *hdr)
+{
+	return hdr->kernel_size;
+}
+
+void android_image_set_kload(struct andr_img_hdr *hdr, u32 load_address)
+{
+	hdr->kernel_addr = load_address;
+}
+
 ulong android_image_get_kload(const struct andr_img_hdr *hdr)
 {
 	return android_image_get_kernel_addr(hdr);
@@ -130,22 +234,947 @@ ulong android_image_get_kload(const struct andr_img_hdr *hdr)
 int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
 			      ulong *rd_data, ulong *rd_len)
 {
+	ulong ramdisk_addr_r;
+	ulong start, end;
+
 	if (!hdr->ramdisk_size) {
 		*rd_data = *rd_len = 0;
 		return -1;
 	}
 
-	printf("RAM disk load addr 0x%08x size %u KiB\n",
-	       hdr->ramdisk_addr, DIV_ROUND_UP(hdr->ramdisk_size, 1024));
-
-	*rd_data = (unsigned long)hdr;
-	*rd_data += hdr->page_size;
-	*rd_data += ALIGN(hdr->kernel_size, hdr->page_size);
+	/* Have been loaded by android_image_load_separate() on ramdisk_addr_r */
+	ramdisk_addr_r = env_get_ulong("ramdisk_addr_r", 16, 0);
+	if (!ramdisk_addr_r) {
+		printf("No Found Ramdisk Load Address.\n");
+		return -1;
+	}
 
+	*rd_data = ramdisk_addr_r;
 	*rd_len = hdr->ramdisk_size;
+	if (hdr->header_version >= 3)
+		*rd_len += hdr->vendor_ramdisk_size;
+	if (hdr->header_version >= 4) {
+		 *rd_len += hdr->vendor_bootconfig_size +
+		  ANDROID_ADDITION_BOOTCONFIG_PARAMS_MAX_SIZE;
+	}
+
+	/* just for print msg */
+	start = ramdisk_addr_r;
+	if (hdr->header_version >= 3) {
+		end = start + (ulong)hdr->vendor_ramdisk_size;
+		printf("v-ramdisk:  0x%08lx - 0x%08lx (%u KiB)\n",
+		       start, end, DIV_ROUND_UP(hdr->vendor_ramdisk_size, 1024));
+		start = end;
+	}
+	{
+		end = start + (ulong)hdr->ramdisk_size;
+		printf("ramdisk:    0x%08lx - 0x%08lx (%u KiB)\n",
+		       start, end, DIV_ROUND_UP(hdr->ramdisk_size, 1024));
+		start = end;
+	}
+	if (hdr->header_version >= 4) {
+		end = start + (ulong)hdr->vendor_bootconfig_size;
+		printf("bootconfig: 0x%08lx - 0x%08lx (%u KiB)\n",
+		       start, end, DIV_ROUND_UP(hdr->vendor_bootconfig_size, 1024));
+		start = end;
+		end = start + ANDROID_ADDITION_BOOTCONFIG_PARAMS_MAX_SIZE;
+		printf("bootparams: 0x%08lx - 0x%08lx\n", start, end);
+	}
+
+	return 0;
+}
+
+int android_image_get_fdt(const struct andr_img_hdr *hdr,
+			      ulong *rd_data)
+{
+	ulong fdt_addr_r;
+
+	if (!hdr->second_size) {
+		*rd_data = 0;
+		return -1;
+	}
+
+	/* Have been loaded by android_image_load_separate() on fdt_addr_r */
+	fdt_addr_r = env_get_ulong("fdt_addr_r", 16, 0);
+	if (!fdt_addr_r) {
+		printf("No Found FDT Load Address.\n");
+		return -1;
+	}
+
+	*rd_data = fdt_addr_r;
+
+	debug("FDT load addr 0x%08x size %u KiB\n",
+	      hdr->second_addr, DIV_ROUND_UP(hdr->second_size, 1024));
+
 	return 0;
 }
 
+#ifdef CONFIG_ANDROID_BOOT_IMAGE_HASH
+static void print_hash(const char *label, u8 *hash, int len)
+{
+	int i;
+
+	printf("%s:\n    0x", label ? : "Hash");
+	for (i = 0; i < len; i++)
+		printf("%02x", hash[i]);
+	printf("\n");
+}
+#endif
+
+typedef enum {
+	IMG_KERNEL,
+	IMG_RAMDISK,
+	IMG_SECOND,
+	IMG_RECOVERY_DTBO,
+	IMG_RK_DTB,	/* within resource.img in second position */
+	IMG_DTB,
+	IMG_VENDOR_RAMDISK,
+	IMG_BOOTCONFIG,
+	IMG_MAX,
+} img_t;
+
+#if defined(CONFIG_ANDROID_BOOT_IMAGE_HASH) && !defined(CONFIG_DM_CRYPTO)
+static sha1_context sha1_ctx;
+#endif
+
+static int image_load(img_t img, struct andr_img_hdr *hdr,
+		      ulong blkstart, void *ram_base,
+		      struct udevice *crypto)
+{
+	struct blk_desc *desc = rockchip_get_bootdev();
+	disk_partition_t part_vendor_boot;
+	__maybe_unused u32 typesz;
+	ulong pgsz = hdr->page_size;
+	ulong blksz = desc->blksz;
+	ulong blkcnt, blkoff;
+	ulong memmove_dst = 0;
+	ulong bsoffs = 0;
+	ulong extra = 0;
+	ulong length;
+	void *buffer;
+	int ret = 0;
+
+	switch (img) {
+	case IMG_KERNEL:
+		bsoffs = 0; /* include a page_size(image header) */
+		length = hdr->kernel_size + pgsz;
+		buffer = (void *)env_get_ulong("android_addr_r", 16, 0);
+		blkcnt = DIV_ROUND_UP(hdr->kernel_size + pgsz, blksz);
+		typesz = sizeof(hdr->kernel_size);
+		if (!sysmem_alloc_base(MEM_KERNEL,
+			(phys_addr_t)buffer, blkcnt * blksz))
+			return -ENOMEM;
+		break;
+	case IMG_VENDOR_RAMDISK:
+		if (part_get_info_by_name(desc,
+					  ANDROID_PARTITION_VENDOR_BOOT,
+					  &part_vendor_boot) < 0) {
+			printf("No vendor boot partition\n");
+			return -ENOENT;
+		}
+		/* Always load vendor boot from storage: avb full load boot/recovery */
+		blkstart = part_vendor_boot.start;
+		pgsz = hdr->vendor_page_size;
+		ram_base = 0;
+
+		bsoffs = ALIGN(VENDOR_BOOT_HDRv3_SIZE, pgsz);
+		length = hdr->vendor_ramdisk_size;
+		buffer = (void *)env_get_ulong("ramdisk_addr_r", 16, 0);
+		blkcnt = DIV_ROUND_UP(hdr->vendor_ramdisk_size, blksz);
+		typesz = sizeof(hdr->vendor_ramdisk_size);
+		/*
+		 * Add extra memory for generic ramdisk space.
+		 *
+		 * In case of unaligned vendor ramdisk size, reserve
+		 * 1 more blksz.
+		 *
+		 * Reserve 8KB for bootloader cmdline.
+		 */
+		if (hdr->header_version >= 3)
+			extra += ALIGN(hdr->ramdisk_size, blksz) + blksz;
+		if (hdr->header_version >= 4)
+			extra += ALIGN(hdr->vendor_bootconfig_size, blksz) +
+				 ANDROID_ADDITION_BOOTCONFIG_PARAMS_MAX_SIZE;
+		if (length && !sysmem_alloc_base(MEM_RAMDISK,
+			(phys_addr_t)buffer, blkcnt * blksz + extra))
+			return -ENOMEM;
+		break;
+	case IMG_RAMDISK:
+		bsoffs = pgsz + ALIGN(hdr->kernel_size, pgsz);
+		length = hdr->ramdisk_size;
+		buffer = (void *)env_get_ulong("ramdisk_addr_r", 16, 0);
+		blkcnt = DIV_ROUND_UP(hdr->ramdisk_size, blksz);
+		typesz = sizeof(hdr->ramdisk_size);
+
+		/*
+		 * ramdisk_addr_r v012:
+		 *	|----------------|
+		 *	|    ramdisk     |
+		 *	|----------------|
+		 *
+		 * ramdisk_addr_r v3:
+		 *	|----------------|---------|
+		 *	| vendor-ramdisk | ramdisk |
+		 *	|----------------|---------|
+		 *
+		 * ramdisk_addr_r v4:
+		 *	|----------------|---------|------------|------------|
+		 *	| vendor-ramdisk | ramdisk | bootconfig | bootparams |
+		 *	|----------------|---------|------------|------------|
+		 */
+		if (hdr->header_version >= 3) {
+			buffer += hdr->vendor_ramdisk_size;
+			if (!IS_ALIGNED((ulong)buffer, blksz)) {
+				memmove_dst = (ulong)buffer;
+				buffer = (void *)ALIGN(memmove_dst, blksz);
+			}
+		}
+		/* sysmem has been alloced by vendor ramdisk */
+		if (hdr->header_version < 3) {
+			if (length && !sysmem_alloc_base(MEM_RAMDISK,
+				(phys_addr_t)buffer, blkcnt * blksz))
+				return -ENOMEM;
+		}
+		break;
+	case IMG_BOOTCONFIG:
+		if (hdr->header_version < 4)
+			return 0;
+		if (part_get_info_by_name(desc,
+					  ANDROID_PARTITION_VENDOR_BOOT,
+					  &part_vendor_boot) < 0) {
+			printf("No vendor boot partition\n");
+			return -ENOENT;
+		}
+
+		blkstart = part_vendor_boot.start;
+		pgsz = hdr->vendor_page_size;
+		ram_base = 0;
+
+		bsoffs = ALIGN(VENDOR_BOOT_HDRv4_SIZE, pgsz) +
+			 ALIGN(hdr->vendor_ramdisk_size, pgsz) +
+			 ALIGN(hdr->dtb_size, pgsz) +
+			 ALIGN(hdr->vendor_ramdisk_table_size, pgsz);
+		length = hdr->vendor_bootconfig_size;
+		buffer = (void *)env_get_ulong("ramdisk_addr_r", 16, 0);
+		blkcnt = DIV_ROUND_UP(hdr->vendor_bootconfig_size, blksz);
+		typesz = sizeof(hdr->vendor_bootconfig_size);
+
+		buffer += hdr->vendor_ramdisk_size + hdr->ramdisk_size;
+		if (!IS_ALIGNED((ulong)buffer, blksz)) {
+			memmove_dst = (ulong)buffer;
+			buffer = (void *)ALIGN(memmove_dst, blksz);
+		}
+		break;
+	case IMG_SECOND:
+		bsoffs = pgsz +
+			 ALIGN(hdr->kernel_size, pgsz) +
+			 ALIGN(hdr->ramdisk_size, pgsz);
+		length = hdr->second_size;
+		blkcnt = DIV_ROUND_UP(hdr->second_size, blksz);
+		buffer = malloc(blkcnt * blksz);
+		typesz = sizeof(hdr->second_size);
+		break;
+	case IMG_RECOVERY_DTBO:
+		bsoffs = pgsz +
+			 ALIGN(hdr->kernel_size, pgsz) +
+			 ALIGN(hdr->ramdisk_size, pgsz) +
+			 ALIGN(hdr->second_size, pgsz);
+		length = hdr->recovery_dtbo_size;
+		blkcnt = DIV_ROUND_UP(hdr->recovery_dtbo_size, blksz);
+		buffer = malloc(blkcnt * blksz);
+		typesz = sizeof(hdr->recovery_dtbo_size);
+		break;
+	case IMG_DTB:
+		bsoffs = pgsz +
+			 ALIGN(hdr->kernel_size, pgsz) +
+			 ALIGN(hdr->ramdisk_size, pgsz) +
+			 ALIGN(hdr->second_size, pgsz) +
+			 ALIGN(hdr->recovery_dtbo_size, pgsz);
+		length = hdr->dtb_size;
+		blkcnt = DIV_ROUND_UP(hdr->dtb_size, blksz);
+		buffer = malloc(blkcnt * blksz);
+		typesz = sizeof(hdr->dtb_size);
+		break;
+	case IMG_RK_DTB:
+#ifdef CONFIG_RKIMG_BOOTLOADER
+		/* No going further, it handles DTBO, HW-ID, etc */
+		buffer = (void *)env_get_ulong("fdt_addr_r", 16, 0);
+		if (gd->fdt_blob != (void *)buffer)
+			ret = rockchip_read_dtb_file(buffer);
+#endif
+		return ret < 0 ? ret : 0;
+	default:
+		return -EINVAL;
+	}
+
+	if (!buffer) {
+		printf("No memory for image(%d)\n", img);
+		return -ENOMEM;
+	}
+
+	if (!blksz || !length)
+		goto crypto_calc;
+
+	/* load */
+	if (ram_base) {
+		memcpy(buffer, (char *)((ulong)ram_base + bsoffs), length);
+	} else {
+		blkoff = DIV_ROUND_UP(bsoffs, blksz);
+		ret = blk_dread(desc, blkstart + blkoff, blkcnt, buffer);
+		if (ret != blkcnt) {
+			printf("Failed to read img(%d), ret=%d\n", img, ret);
+			return -EIO;
+		}
+	}
+
+	if (memmove_dst)
+		memmove((char *)memmove_dst, buffer, length);
+
+crypto_calc:
+	if (img == IMG_KERNEL) {
+		buffer += pgsz;
+		length -= pgsz;
+	}
+
+	/* sha1 */
+#ifdef CONFIG_ANDROID_BOOT_IMAGE_HASH
+#ifdef CONFIG_DM_CRYPTO
+	crypto_sha_update(crypto, (u32 *)buffer, length);
+	crypto_sha_update(crypto, (u32 *)&length, typesz);
+#else
+	sha1_update(&sha1_ctx, (void *)buffer, length);
+	sha1_update(&sha1_ctx, (void *)&length, typesz);
+#endif
+#endif
+
+	return 0;
+}
+
+static int images_load_verify(struct andr_img_hdr *hdr, ulong part_start,
+			      void *ram_base, struct udevice *crypto)
+{
+	/* load, never change order ! */
+	if (image_load(IMG_KERNEL, hdr, part_start, ram_base, crypto))
+		return -1;
+	if (image_load(IMG_RAMDISK, hdr, part_start, ram_base, crypto))
+		return -1;
+	if (image_load(IMG_SECOND, hdr, part_start, ram_base, crypto))
+		return -1;
+	if (hdr->header_version > 0) {
+		if (image_load(IMG_RECOVERY_DTBO, hdr, part_start,
+			       ram_base, crypto))
+			return -1;
+	}
+	if (hdr->header_version > 1) {
+		if (image_load(IMG_DTB, hdr, part_start, ram_base, crypto))
+			return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * @ram_base: !NULL means require memcpy for an exist full android image.
+ */
+static int android_image_separate(struct andr_img_hdr *hdr,
+				  const disk_partition_t *part,
+				  void *load_address,
+				  void *ram_base)
+{
+	ulong bstart;
+	int ret;
+
+	if (android_image_check_header(hdr)) {
+		printf("Bad android image header\n");
+		return -EINVAL;
+	}
+
+	/* set for image_load(IMG_KERNEL, ...) */
+	env_set_hex("android_addr_r", (ulong)load_address);
+	bstart = part ? part->start : 0;
+
+	/*
+	 * 1. Load images to their individual target ram position
+	 *    in order to disable fdt/ramdisk relocation.
+	 */
+
+	/* load rk-kernel.dtb alone */
+	if (image_load(IMG_RK_DTB, hdr, bstart, ram_base, NULL))
+		return -1;
+
+#ifdef CONFIG_ANDROID_BOOT_IMAGE_HASH
+	if (hdr->header_version < 3) {
+		struct udevice *dev = NULL;
+		uchar hash[20];
+#ifdef CONFIG_DM_CRYPTO
+		sha_context ctx;
+
+		ctx.length = 0;
+		ctx.algo = CRYPTO_SHA1;
+		dev = crypto_get_device(ctx.algo);
+		if (!dev) {
+			printf("Can't find crypto device for SHA1\n");
+			return -ENODEV;
+		}
+
+		/* v1 & v2: requires total length before sha init */
+		ctx.length += hdr->kernel_size + sizeof(hdr->kernel_size) +
+			      hdr->ramdisk_size + sizeof(hdr->ramdisk_size) +
+			      hdr->second_size + sizeof(hdr->second_size);
+		if (hdr->header_version > 0)
+			ctx.length += hdr->recovery_dtbo_size +
+						sizeof(hdr->recovery_dtbo_size);
+		if (hdr->header_version > 1)
+			ctx.length += hdr->dtb_size + sizeof(hdr->dtb_size);
+		crypto_sha_init(dev, &ctx);
+#else
+		sha1_starts(&sha1_ctx);
+#endif
+		ret = images_load_verify(hdr, bstart, ram_base, dev);
+		if (ret)
+			return ret;
+
+#ifdef CONFIG_DM_CRYPTO
+		crypto_sha_final(dev, &ctx, hash);
+#else
+		sha1_finish(&sha1_ctx, hash);
+#endif
+		if (memcmp(hash, hdr->id, 20)) {
+			print_hash("Hash from header", (u8 *)hdr->id, 20);
+			print_hash("Hash real", (u8 *)hash, 20);
+			return -EBADFD;
+		} else {
+			printf("ANDROID: Hash OK\n");
+		}
+	} else
+#endif
+	{
+		ret = images_load_verify(hdr, bstart, ram_base, NULL);
+		if (ret)
+			return ret;
+	}
+
+	/* 2. Disable fdt/ramdisk relocation, it saves boot time */
+	env_set("bootm-no-reloc", "y");
+
+	return 0;
+}
+
+static int android_image_separate_v34(struct andr_img_hdr *hdr,
+				      const disk_partition_t *part,
+				      void *load_address, void *ram_base)
+{
+	ulong bstart;
+
+	if (android_image_check_header(hdr)) {
+		printf("Bad android image header\n");
+		return -EINVAL;
+	}
+
+	/* set for image_load(IMG_KERNEL, ...) */
+	env_set_hex("android_addr_r", (ulong)load_address);
+	bstart = part ? part->start : 0;
+
+	/*
+	 * 1. Load images to their individual target ram position
+	 *    in order to disable fdt/ramdisk relocation.
+	 */
+	if (image_load(IMG_RK_DTB,  hdr, bstart, ram_base, NULL))
+		return -1;
+	if (image_load(IMG_KERNEL,  hdr, bstart, ram_base, NULL))
+		return -1;
+	if (image_load(IMG_VENDOR_RAMDISK, hdr, bstart, ram_base, NULL))
+		return -1;
+	if (image_load(IMG_RAMDISK, hdr, bstart, ram_base, NULL))
+		return -1;
+	if (image_load(IMG_BOOTCONFIG, hdr, bstart, ram_base, NULL))
+		return -1;
+	/*
+	 * Copy the populated hdr to load address after image_load(IMG_KERNEL)
+	 *
+	 * The image_load(IMG_KERNEL) only reads boot_img_hdr_v34 while
+	 * vendor_boot_img_hdr_v34 is not included, so fix it here.
+	 */
+	memcpy((char *)load_address, hdr, hdr->page_size);
+
+	/* 2. Disable fdt/ramdisk relocation, it saves boot time */
+	env_set("bootm-no-reloc", "y");
+
+	return 0;
+}
+
+static ulong android_image_get_comp_addr(struct andr_img_hdr *hdr, int comp)
+{
+	ulong kernel_addr_c;
+	ulong load_addr = 0;
+
+	kernel_addr_c = env_get_ulong("kernel_addr_c", 16, 0);
+
+#ifdef CONFIG_ARM64
+	/*
+	 * On 64-bit kernel, assuming use IMAGE by default.
+	 *
+	 * kernel_addr_c is for LZ4-IMAGE but maybe not defined.
+	 * kernel_addr_r is for IMAGE.
+	 */
+	if (comp != IH_COMP_NONE) {
+		ulong comp_addr;
+
+		if (kernel_addr_c) {
+			comp_addr = kernel_addr_c;
+		} else {
+			printf("Warn: No \"kernel_addr_c\"\n");
+			comp_addr = CONFIG_SYS_SDRAM_BASE + 0x2000000;/* 32M */
+			env_set_hex("kernel_addr_c", comp_addr);
+		}
+
+		load_addr = comp_addr - hdr->page_size;
+	}
+#else
+	/*
+	 * On 32-bit kernel:
+	 *
+	 * The input load_addr is from env value: "kernel_addr_r", it has
+	 * different role depends on whether kernel_addr_c is defined:
+	 *
+	 * - kernel_addr_r is for lz4/zImage if kernel_addr_c if [not] defined.
+	 * - kernel_addr_r is for IMAGE if kernel_addr_c is defined.
+	 */
+	if (comp == IH_COMP_NONE) {
+		if (kernel_addr_c) {
+			/* input load_addr is for Image, nothing to do */
+		} else {
+			/* input load_addr is for lz4/zImage, set default addr for Image */
+			load_addr = CONFIG_SYS_SDRAM_BASE + 0x8000;
+			env_set_hex("kernel_addr_r", load_addr);
+
+			load_addr -= hdr->page_size;
+		}
+	} else {
+		if (kernel_addr_c) {
+			/* input load_addr is for Image, so use another for lz4/zImage */
+			load_addr = kernel_addr_c - hdr->page_size;
+		} else {
+			/* input load_addr is for lz4/zImage, nothing to do */
+		}
+	}
+#endif
+
+	return load_addr;
+}
+
+void android_image_set_decomp(struct andr_img_hdr *hdr, int comp)
+{
+	ulong kernel_addr_r;
+
+	env_set_ulong("os_comp", comp);
+
+	/* zImage handles decompress itself */
+	if (comp != IH_COMP_NONE && comp != IH_COMP_ZIMAGE) {
+		kernel_addr_r = env_get_ulong("kernel_addr_r", 16, 0x02080000);
+		android_image_set_kload(hdr, kernel_addr_r);
+		android_image_set_comp(hdr, comp);
+	} else {
+		android_image_set_comp(hdr, IH_COMP_NONE);
+	}
+}
+
+static int android_image_load_separate(struct andr_img_hdr *hdr,
+				       const disk_partition_t *part,
+				       void *load_addr)
+{
+	if (hdr->header_version < 3)
+		return android_image_separate(hdr, part, load_addr, NULL);
+	else
+		return android_image_separate_v34(hdr, part, load_addr, NULL);
+}
+
+int android_image_memcpy_separate(struct andr_img_hdr *hdr, ulong *load_addr)
+{
+	ulong comp_addr;
+	int comp;
+
+	comp = bootm_parse_comp((void *)(ulong)hdr + hdr->page_size);
+	comp_addr = android_image_get_comp_addr(hdr, comp);
+
+	/* non-compressed image: already in-place */
+	if ((ulong)hdr == *load_addr)
+		return 0;
+
+	/* compressed image */
+	if (comp_addr) {
+		*load_addr = comp_addr;
+		if ((ulong)hdr == comp_addr)	/* already in-place */
+			return 0;
+	}
+
+	/*
+	 * The most possible reason to arrive here is:
+	 *
+	 * VBoot=1 and AVB load full partition to a temp memory buffer, now we
+	 * separate(memcpy) subimages from boot.img to where they should be.
+	 */
+	if (hdr->header_version < 3) {
+		if (android_image_separate(hdr, NULL, (void *)(*load_addr), hdr))
+			return -1;
+	} else {
+		if (android_image_separate_v34(hdr, NULL, (void *)(*load_addr), hdr))
+			return -1;
+	}
+
+	android_image_set_decomp((void *)(*load_addr), comp);
+
+	return 0;
+}
+
+long android_image_load(struct blk_desc *dev_desc,
+			const disk_partition_t *part_info,
+			unsigned long load_address,
+			unsigned long max_size) {
+	struct andr_img_hdr *hdr;
+	ulong comp_addr;
+	int comp, ret;
+	int blk_off;
+
+	if (max_size < part_info->blksz)
+		return -1;
+
+	hdr = populate_andr_img_hdr(dev_desc, (disk_partition_t *)part_info);
+	if (!hdr) {
+		printf("No valid android hdr\n");
+		return -1;
+	}
+
+	/*
+	 * create the layout:
+	 *
+	 * |<- page_size ->|1-blk |
+	 * |-----|---------|------|-----|
+	 * | hdr |   ...   |   kernel   |
+	 * |-----|----- ---|------------|
+	 *
+	 * Alloc page_size and 1 more blk for reading kernel image to
+	 * get it's compression type, then fill the android hdr what
+	 * we have populated before.
+	 *
+	 * Why? see: android_image_get_kernel_addr().
+	 */
+	blk_off = BLK_CNT(hdr->page_size, dev_desc->blksz);
+	hdr = (struct andr_img_hdr *)
+			realloc(hdr, (blk_off + 1) * dev_desc->blksz);
+	if (!hdr)
+		return -1;
+
+	if (blk_dread(dev_desc, part_info->start + blk_off, 1,
+		      (char *)hdr + hdr->page_size) != 1) {
+		free(hdr);
+		return -1;
+	}
+
+	/* Changed to compressed address ? */
+	comp = bootm_parse_comp((void *)(ulong)hdr + hdr->page_size);
+	comp_addr = android_image_get_comp_addr(hdr, comp);
+	if (comp_addr)
+		load_address = comp_addr;
+	else
+		load_address -= hdr->page_size;
+
+	ret = android_image_load_separate(hdr, part_info, (void *)load_address);
+	if (ret) {
+		printf("Failed to load android image\n");
+		goto fail;
+	}
+	android_image_set_decomp((void *)load_address, comp);
+
+	debug("Loading Android Image to 0x%08lx\n", load_address);
+
+	free(hdr);
+	return load_address;
+
+fail:
+	free(hdr);
+	return -1;
+}
+
+static struct andr_img_hdr *
+extract_boot_image_v012_header(struct blk_desc *dev_desc,
+			       const disk_partition_t *boot_img)
+{
+	struct andr_img_hdr *hdr;
+	long blk_cnt, blks_read;
+
+	blk_cnt = BLK_CNT(sizeof(struct andr_img_hdr), dev_desc->blksz);
+	hdr = (struct andr_img_hdr *)malloc(blk_cnt * dev_desc->blksz);
+
+	if (!blk_cnt || !hdr)
+		return NULL;
+
+	blks_read = blk_dread(dev_desc, boot_img->start, blk_cnt, hdr);
+	if (blks_read != blk_cnt) {
+		debug("boot img header blk cnt is %ld and blks read is %ld\n",
+		      blk_cnt, blks_read);
+		return NULL;
+	}
+
+	if (android_image_check_header((void *)hdr)) {
+		printf("boot header magic is invalid.\n");
+		return NULL;
+	}
+
+	if (hdr->page_size < sizeof(*hdr)) {
+		printf("android hdr is over size\n");
+		return NULL;
+	}
+
+	return hdr;
+}
+
+static struct boot_img_hdr_v34 *
+extract_boot_image_v34_header(struct blk_desc *dev_desc,
+			      const disk_partition_t *boot_img)
+{
+	struct boot_img_hdr_v34 *boot_hdr;
+	long blk_cnt, blks_read;
+
+	blk_cnt = BLK_CNT(sizeof(struct boot_img_hdr_v34), dev_desc->blksz);
+	boot_hdr = (struct boot_img_hdr_v34 *)malloc(blk_cnt * dev_desc->blksz);
+
+	if (!blk_cnt || !boot_hdr)
+		return NULL;
+
+	blks_read = blk_dread(dev_desc, boot_img->start, blk_cnt, boot_hdr);
+	if (blks_read != blk_cnt) {
+		debug("boot img header blk cnt is %ld and blks read is %ld\n",
+		      blk_cnt, blks_read);
+		return NULL;
+	}
+
+	if (android_image_check_header((void *)boot_hdr)) {
+		printf("boot header magic is invalid.\n");
+		return NULL;
+	}
+
+	if (boot_hdr->header_version < 3) {
+		printf("boot header %d, is not >= v3.\n",
+		       boot_hdr->header_version);
+		return NULL;
+	}
+
+	return boot_hdr;
+}
+
+static struct vendor_boot_img_hdr_v34 *
+extract_vendor_boot_image_v34_header(struct blk_desc *dev_desc,
+				     const disk_partition_t *part_vendor_boot)
+{
+	struct vendor_boot_img_hdr_v34 *vboot_hdr;
+	long blk_cnt, blks_read;
+
+	blk_cnt = BLK_CNT(sizeof(struct vendor_boot_img_hdr_v34),
+				part_vendor_boot->blksz);
+	vboot_hdr = (struct vendor_boot_img_hdr_v34 *)
+				malloc(blk_cnt * part_vendor_boot->blksz);
+
+	if (!blk_cnt || !vboot_hdr)
+		return NULL;
+
+	blks_read = blk_dread(dev_desc, part_vendor_boot->start,
+			      blk_cnt, vboot_hdr);
+	if (blks_read != blk_cnt) {
+		debug("vboot img header blk cnt is %ld and blks read is %ld\n",
+		      blk_cnt, blks_read);
+		return NULL;
+	}
+
+	if (strncmp(VENDOR_BOOT_MAGIC, (void *)vboot_hdr->magic,
+		    VENDOR_BOOT_MAGIC_SIZE)) {
+		printf("vendor boot header is invalid.\n");
+		return NULL;
+	}
+
+	if (vboot_hdr->header_version < 3) {
+		printf("vendor boot header %d, is not >= v3.\n",
+		       vboot_hdr->header_version);
+		return NULL;
+	}
+
+	return vboot_hdr;
+}
+
+static int populate_boot_info(const struct boot_img_hdr_v34 *boot_hdr,
+			      const struct vendor_boot_img_hdr_v34 *vendor_hdr,
+			      struct andr_img_hdr *hdr)
+{
+	memset(hdr->magic, 0, ANDR_BOOT_MAGIC_SIZE);
+	memcpy(hdr->magic, boot_hdr->magic, ANDR_BOOT_MAGIC_SIZE);
+
+	hdr->kernel_size = boot_hdr->kernel_size;
+	/* don't use vendor_hdr->kernel_addr, we prefer "hdr + hdr->page_size" */
+	hdr->kernel_addr = ANDROID_IMAGE_DEFAULT_KERNEL_ADDR;
+	/* generic ramdisk: immediately following the vendor ramdisk */
+	hdr->boot_ramdisk_size = boot_hdr->ramdisk_size;
+	hdr->ramdisk_size = boot_hdr->ramdisk_size;
+
+	/* actually, useless */
+	hdr->ramdisk_addr = env_get_ulong("ramdisk_addr_r", 16, 0);
+
+	/* removed in v3 */
+	hdr->second_size = 0;
+	hdr->second_addr = 0;
+
+	hdr->tags_addr = vendor_hdr->tags_addr;
+
+	/* fixed in v3 */
+	hdr->page_size = 4096;
+	hdr->header_version = boot_hdr->header_version;
+	hdr->os_version = boot_hdr->os_version;
+
+	memset(hdr->name, 0, ANDR_BOOT_NAME_SIZE);
+	strncpy(hdr->name, (const char *)vendor_hdr->name, ANDR_BOOT_NAME_SIZE);
+
+	/* removed in v3 */
+	memset(hdr->cmdline, 0, ANDR_BOOT_ARGS_SIZE);
+	memset(hdr->id, 0, 32);
+	memset(hdr->extra_cmdline, 0, ANDR_BOOT_EXTRA_ARGS_SIZE);
+	hdr->recovery_dtbo_size = 0;
+	hdr->recovery_dtbo_offset = 0;
+
+	hdr->header_size = boot_hdr->header_size;
+	hdr->dtb_size = vendor_hdr->dtb_size;
+	hdr->dtb_addr = vendor_hdr->dtb_addr;
+
+	/* boot_img_hdr_v34 fields */
+	hdr->vendor_ramdisk_size = vendor_hdr->vendor_ramdisk_size;
+	hdr->vendor_page_size = vendor_hdr->page_size;
+	hdr->vendor_header_version = vendor_hdr->header_version;
+	hdr->vendor_header_size = vendor_hdr->header_size;
+
+	hdr->total_cmdline = calloc(1, TOTAL_BOOT_ARGS_SIZE);
+	if (!hdr->total_cmdline)
+		return -ENOMEM;
+	strncpy(hdr->total_cmdline, (const char *)boot_hdr->cmdline,
+		sizeof(boot_hdr->cmdline));
+	strncat(hdr->total_cmdline, " ", 1);
+	strncat(hdr->total_cmdline, (const char *)vendor_hdr->cmdline,
+		sizeof(vendor_hdr->cmdline));
+
+	/* new for header v4 */
+	if (vendor_hdr->header_version > 3) {
+		hdr->vendor_ramdisk_table_size =
+				vendor_hdr->vendor_ramdisk_table_size;
+		hdr->vendor_ramdisk_table_entry_num =
+				vendor_hdr->vendor_ramdisk_table_entry_num;
+		hdr->vendor_ramdisk_table_entry_size =
+				vendor_hdr->vendor_ramdisk_table_entry_size;
+		/*
+		 * If we place additional "androidboot.xxx" parameters after
+		 * bootconfig, this field value should be increased,
+		 * but not over than ANDROID_ADDITION_BOOTCONFIG_PARAMS_MAX_SIZE.
+		 */
+		hdr->vendor_bootconfig_size =
+				vendor_hdr->vendor_bootconfig_size;
+	} else {
+		hdr->vendor_ramdisk_table_size = 0;
+		hdr->vendor_ramdisk_table_entry_num = 0;
+		hdr->vendor_ramdisk_table_entry_size = 0;
+		hdr->vendor_bootconfig_size = 0;
+	}
+
+	if (hdr->page_size < sizeof(*hdr)) {
+		printf("android hdr is over size\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * The possible cases of boot.img + recovery.img:
+ *
+ * [N]: 0, 1, 2
+ * [M]: 0, 1, 2, 3, 4
+ *
+ * |--------------------|---------------------|
+ * |   boot.img         |    recovery.img     |
+ * |--------------------|---------------------|
+ * | boot_img_hdr_v[N]  |  boot_img_hdr_v[N]  | <= if A/B is not required
+ * |--------------------|---------------------|
+ * | boot_img_hdr_v34   |  boot_img_hdr_v2    | <= if A/B is not required
+ * |------------------------------------------|
+ * | boot_img_hdr_v[M], no recovery.img       | <= if A/B is required
+ * |------------------------------------------|
+ */
+struct andr_img_hdr *populate_andr_img_hdr(struct blk_desc *dev_desc,
+					   disk_partition_t *part_boot)
+{
+	disk_partition_t part_vendor_boot;
+	struct vendor_boot_img_hdr_v34 *vboot_hdr;
+	struct boot_img_hdr_v34 *boot_hdr;
+	struct andr_img_hdr *andr_hdr;
+	int header_version;
+
+	if (!dev_desc || !part_boot)
+		return NULL;
+
+	andr_hdr = (struct andr_img_hdr *)malloc(1 * dev_desc->blksz);
+	if (!andr_hdr)
+		return NULL;
+
+	if (blk_dread(dev_desc, part_boot->start, 1, andr_hdr) != 1) {
+		free(andr_hdr);
+		return NULL;
+	}
+
+	if (android_image_check_header(andr_hdr)) {
+		free(andr_hdr);
+		return NULL;
+	}
+
+	header_version = andr_hdr->header_version;
+	free(andr_hdr);
+
+	if (header_version < 3) {
+		return extract_boot_image_v012_header(dev_desc, part_boot);
+	} else {
+		if (part_get_info_by_name(dev_desc,
+					  ANDROID_PARTITION_VENDOR_BOOT,
+					  &part_vendor_boot) < 0) {
+			printf("No vendor boot partition\n");
+			return NULL;
+		}
+		boot_hdr = extract_boot_image_v34_header(dev_desc, part_boot);
+		vboot_hdr = extract_vendor_boot_image_v34_header(dev_desc,
+							&part_vendor_boot);
+		if (!boot_hdr || !vboot_hdr)
+			goto image_load_exit;
+
+		andr_hdr = (struct andr_img_hdr *)
+				malloc(sizeof(struct andr_img_hdr));
+		if (!andr_hdr) {
+			printf("No memory for andr hdr\n");
+			goto image_load_exit;
+		}
+
+		if (populate_boot_info(boot_hdr, vboot_hdr, andr_hdr)) {
+			printf("populate boot info failed\n");
+			goto image_load_exit;
+		}
+
+		free(boot_hdr);
+		free(vboot_hdr);
+
+		return andr_hdr;
+
+image_load_exit:
+		free(boot_hdr);
+		free(vboot_hdr);
+
+		return NULL;
+	}
+
+	return NULL;
+}
+
 #if !defined(CONFIG_SPL_BUILD)
 /**
  * android_print_contents - prints out the contents of the Android format image
@@ -164,15 +1193,17 @@ void android_print_contents(const struct andr_img_hdr *hdr)
 	/* os_version = ver << 11 | lvl */
 	u32 os_ver = hdr->os_version >> 11;
 	u32 os_lvl = hdr->os_version & ((1U << 11) - 1);
+	u32 header_version = hdr->header_version;
 
 	printf("%skernel size:      %x\n", p, hdr->kernel_size);
 	printf("%skernel address:   %x\n", p, hdr->kernel_addr);
 	printf("%sramdisk size:     %x\n", p, hdr->ramdisk_size);
-	printf("%sramdisk addrress: %x\n", p, hdr->ramdisk_addr);
+	printf("%sramdisk address: %x\n", p, hdr->ramdisk_addr);
 	printf("%ssecond size:      %x\n", p, hdr->second_size);
 	printf("%ssecond address:   %x\n", p, hdr->second_addr);
 	printf("%stags address:     %x\n", p, hdr->tags_addr);
 	printf("%spage size:        %x\n", p, hdr->page_size);
+	printf("%sheader_version:   %x\n", p, header_version);
 	/* ver = A << 14 | B << 7 | C         (7 bits for each of A, B, C)
 	 * lvl = ((Y - 2000) & 127) << 4 | M  (7 bits for Y, 4 bits for M) */
 	printf("%sos_version:       %x (ver: %u.%u.%u, level: %u.%u)\n",
@@ -181,5 +1212,35 @@ void android_print_contents(const struct andr_img_hdr *hdr)
 	       (os_lvl >> 4) + 2000, os_lvl & 0x0F);
 	printf("%sname:             %s\n", p, hdr->name);
 	printf("%scmdline:          %s\n", p, hdr->cmdline);
+
+	if (header_version == 1 || header_version == 2) {
+		printf("%srecovery dtbo size:    %x\n", p, hdr->recovery_dtbo_size);
+		printf("%srecovery dtbo offset:  %llx\n", p, hdr->recovery_dtbo_offset);
+		printf("%sheader size:           %x\n", p, hdr->header_size);
+	}
+
+	if (header_version == 2 || header_version == 3) {
+		printf("%sdtb size:              %x\n", p, hdr->dtb_size);
+		printf("%sdtb addr:              %llx\n", p, hdr->dtb_addr);
+	}
+
+	if (header_version >= 3) {
+		printf("%scmdline:               %s\n", p, hdr->total_cmdline);
+		printf("%svendor ramdisk size:   %x\n", p, hdr->vendor_ramdisk_size);
+		printf("%svendor page size:      %x\n", p, hdr->vendor_page_size);
+		printf("%svendor header version: %d\n", p, hdr->vendor_header_version);
+		printf("%svendor header size:    %x\n", p, hdr->vendor_header_size);
+	}
+
+	if (header_version >= 4) {
+		printf("%svendor ramdisk table size:        %x\n",
+		       p, hdr->vendor_ramdisk_table_size);
+		printf("%svendor ramdisk table entry num:   %x\n",
+		       p, hdr->vendor_ramdisk_table_entry_num);
+		printf("%svendor ramdisk table entry size:  %x\n",
+		       p, hdr->vendor_ramdisk_table_entry_size);
+		printf("%svendor bootconfig size:           %d\n",
+		       p, hdr->vendor_bootconfig_size);
+	}
 }
 #endif
diff --git a/common/image-fdt.c b/common/image-fdt.c
index da4d007081..2c79b960aa 100644
--- a/common/image-fdt.c
+++ b/common/image-fdt.c
@@ -10,17 +10,22 @@
  */
 
 #include <common.h>
+#include <fdtdec.h>
 #include <fdt_support.h>
 #include <errno.h>
 #include <image.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <mapmem.h>
 #include <asm/io.h>
+#include <sysmem.h>
 
 #ifndef CONFIG_SYS_FDT_PAD
 #define CONFIG_SYS_FDT_PAD 0x3000
 #endif
 
+/* adding a ramdisk needs 0x44 bytes in version 2008.10 */
+#define FDT_RAMDISK_OVERHEAD	0x80
+
 DECLARE_GLOBAL_DATA_PTR;
 
 static void fdt_error(const char *msg)
@@ -49,10 +54,18 @@ static const image_header_t *image_get_fdt(ulong fdt_addr)
 	}
 	puts("OK\n");
 
+	/*
+	 * default image mkimage conflicts with fit mkimage on param: -T "flat_dt".
+	 *
+	 * error message:
+	 * "./tools/mkimage: Can't set header for FIT Image support: Success"
+	 */
+#if 0
 	if (!image_check_type(fdt_hdr, IH_TYPE_FLATDT)) {
 		fdt_error("uImage is not a fdt");
 		return NULL;
 	}
+#endif
 	if (image_get_comp(fdt_hdr) != IH_COMP_NONE) {
 		fdt_error("uImage is compressed");
 		return NULL;
@@ -78,10 +91,18 @@ void boot_fdt_add_mem_rsv_regions(struct lmb *lmb, void *fdt_blob)
 {
 	uint64_t addr, size;
 	int i, total;
-
-	if (fdt_check_header(fdt_blob) != 0)
+	int rsv_offset, offset;
+	fdt_size_t rsv_size;
+	fdt_addr_t rsv_addr;
+	/* we needn't repeat do reserve, do_bootm_linux would call this again */
+	static int rsv_done;
+	const void *prop;
+
+	if (fdt_check_header(fdt_blob) != 0 || rsv_done)
 		return;
 
+	rsv_done = 1;
+
 	total = fdt_num_mem_rsv(fdt_blob);
 	for (i = 0; i < total; i++) {
 		if (fdt_get_mem_rsv(fdt_blob, i, &addr, &size) != 0)
@@ -90,8 +111,95 @@ void boot_fdt_add_mem_rsv_regions(struct lmb *lmb, void *fdt_blob)
 		       (unsigned long long)addr, (unsigned long long)size);
 		lmb_reserve(lmb, addr, size);
 	}
+
+	rsv_offset = fdt_subnode_offset(fdt_blob, 0, "reserved-memory");
+	if (rsv_offset == -FDT_ERR_NOTFOUND)
+		return;
+
+	for (offset = fdt_first_subnode(fdt_blob, rsv_offset);
+	     offset >= 0;
+	     offset = fdt_next_subnode(fdt_blob, offset)) {
+		prop = fdt_getprop(fdt_blob, offset, "status", NULL);
+		if (prop && !strcmp(prop, "disabled"))
+			continue;
+
+		rsv_addr = fdtdec_get_addr_size_auto_noparent(fdt_blob, offset,
+							      "reg", 0,
+							      &rsv_size, false);
+		if (rsv_addr == FDT_ADDR_T_NONE || !rsv_size)
+			continue;
+		printf("  'reserved-memory' %s: addr=%llx size=%llx\n",
+			fdt_get_name(fdt_blob, offset, NULL),
+			(unsigned long long)rsv_addr, (unsigned long long)rsv_size);
+		lmb_reserve(lmb, rsv_addr, rsv_size);
+	}
 }
 
+#ifdef CONFIG_SYSMEM
+/**
+ * boot_fdt_add_mem_rsv_regions - Mark the memreserve sections as unusable
+ * @sysmem: pointer to sysmem handle, will be used for memory mgmt
+ * @fdt_blob: pointer to fdt blob base address
+ */
+int boot_fdt_add_sysmem_rsv_regions(void *fdt_blob)
+{
+	uint64_t addr, size;
+	int i, total;
+	int rsv_offset, offset;
+	fdt_size_t rsv_size;
+	fdt_addr_t rsv_addr;
+	static int rsv_done;
+	char resvname[32];
+	const void *prop;
+
+	if (fdt_check_header(fdt_blob) != 0 || rsv_done)
+		return -EINVAL;
+
+	rsv_done = 1;
+
+	total = fdt_num_mem_rsv(fdt_blob);
+	for (i = 0; i < total; i++) {
+		if (fdt_get_mem_rsv(fdt_blob, i, &addr, &size) != 0)
+			continue;
+		debug("   sysmem: reserving fdt memory region: addr=%llx size=%llx\n",
+		      (unsigned long long)addr, (unsigned long long)size);
+		sprintf(resvname, "fdt-memory-reserved%d", i);
+		if (!sysmem_fdt_reserve_alloc_base(resvname, addr, size))
+			return -ENOMEM;
+	}
+
+	rsv_offset = fdt_subnode_offset(fdt_blob, 0, "reserved-memory");
+	if (rsv_offset == -FDT_ERR_NOTFOUND)
+		return -EINVAL;
+
+	for (offset = fdt_first_subnode(fdt_blob, rsv_offset);
+	     offset >= 0;
+	     offset = fdt_next_subnode(fdt_blob, offset)) {
+		prop = fdt_getprop(fdt_blob, offset, "status", NULL);
+		if (prop && !strcmp(prop, "disabled"))
+			continue;
+
+		rsv_addr = fdtdec_get_addr_size_auto_noparent(fdt_blob, offset,
+							      "reg", 0,
+							      &rsv_size, false);
+		/*
+		 * kernel will alloc reserved memory dynamically for the node
+		 * with start address from 0.
+		 */
+		if (rsv_addr == FDT_ADDR_T_NONE || !rsv_addr || !rsv_size)
+			continue;
+		debug("  sysmem: 'reserved-memory' %s: addr=%llx size=%llx\n",
+		      fdt_get_name(fdt_blob, offset, NULL),
+		      (unsigned long long)rsv_addr, (unsigned long long)rsv_size);
+		if (!sysmem_fdt_reserve_alloc_base(fdt_get_name(fdt_blob, offset, NULL),
+					           rsv_addr, rsv_size))
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+#endif
+
 /**
  * boot_relocate_fdt - relocate flat device tree
  * @lmb: pointer to lmb handle, will be used for memory mgmt
@@ -142,6 +250,10 @@ int boot_relocate_fdt(struct lmb *lmb, char **of_flat_tree, ulong *of_size)
 			lmb_reserve(lmb, (ulong)of_start, of_len);
 			disable_relocation = 1;
 		} else if (desired_addr) {
+
+			if (desired_addr && env_get_yesno("bootm-reloc-at"))
+				desired_addr += of_len;
+
 			of_start =
 			    (void *)(ulong) lmb_alloc_base(lmb, of_len, 0x1000,
 							   (ulong)desired_addr);
@@ -191,7 +303,9 @@ int boot_relocate_fdt(struct lmb *lmb, char **of_flat_tree, ulong *of_size)
 	*of_flat_tree = of_start;
 	*of_size = of_len;
 
+#ifdef CONFIG_CMD_FDT
 	set_working_fdt_addr((ulong)*of_flat_tree);
+#endif
 	return 0;
 
 error:
@@ -294,9 +408,6 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 		debug("## Checking for 'FDT'/'FDT Image' at %08lx\n",
 		      fdt_addr);
 
-		/* copy from dataflash if needed */
-		fdt_addr = genimg_get_image(fdt_addr);
-
 		/*
 		 * Check if there is an FDT image at the
 		 * address provided in the second bootm argument
@@ -356,17 +467,16 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 			if (fit_check_format(buf)) {
 				ulong load, len;
 
-				fdt_noffset = fit_image_load(images,
+				fdt_noffset = boot_get_fdt_fit(images,
 					fdt_addr, &fit_uname_fdt,
 					&fit_uname_config,
-					arch, IH_TYPE_FLATDT,
-					BOOTSTAGE_ID_FIT_FDT_START,
-					FIT_LOAD_OPTIONAL, &load, &len);
+					arch, &load, &len);
 
 				images->fit_hdr_fdt = map_sysmem(fdt_addr, 0);
 				images->fit_uname_fdt = fit_uname_fdt;
 				images->fit_noffset_fdt = fdt_noffset;
 				fdt_addr = load;
+
 				break;
 			} else
 #endif
@@ -375,7 +485,7 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 				 * FDT blob
 				 */
 				debug("*  fdt: raw FDT blob\n");
-				printf("## Flattened Device Tree blob at %08lx\n",
+				printf("## Flattened Device Tree blob at %#010lx\n",
 				       (long)fdt_addr);
 			}
 			break;
@@ -384,7 +494,7 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 			goto no_fdt;
 		}
 
-		printf("   Booting using the fdt blob at %#08lx\n", fdt_addr);
+		printf("   Booting using the fdt blob at %#010lx\n", fdt_addr);
 		fdt_blob = map_sysmem(fdt_addr, 0);
 	} else if (images->legacy_hdr_valid &&
 			image_check_type(&images->legacy_hdr_os_copy,
@@ -458,6 +568,11 @@ __weak int ft_verify_fdt(void *fdt)
 	return 1;
 }
 
+__weak int arch_fixup_fdt(void *blob)
+{
+	return 0;
+}
+
 int image_setup_libfdt(bootm_headers_t *images, void *blob,
 		       int of_size, struct lmb *lmb)
 {
@@ -466,18 +581,22 @@ int image_setup_libfdt(bootm_headers_t *images, void *blob,
 	int ret = -EPERM;
 	int fdt_ret;
 
+	if (arch_fixup_fdt(blob) < 0) {
+		printf("ERROR: arch-specific fdt fixup failed\n");
+		goto err;
+	}
+
+#if defined(CONFIG_PASS_DEVICE_SERIAL_BY_FDT)
 	if (fdt_root(blob) < 0) {
 		printf("ERROR: root node setup failed\n");
 		goto err;
 	}
+#endif
 	if (fdt_chosen(blob) < 0) {
 		printf("ERROR: /chosen node create failed\n");
 		goto err;
 	}
-	if (arch_fixup_fdt(blob) < 0) {
-		printf("ERROR: arch-specific fdt fixup failed\n");
-		goto err;
-	}
+
 	/* Update ethernet nodes */
 	fdt_fixup_ethernet(blob);
 	if (IMAGE_OF_BOARD_SETUP) {
diff --git a/common/image-fit.c b/common/image-fit.c
index 109ecfaacc..d364788c2f 100644
--- a/common/image-fit.c
+++ b/common/image-fit.c
@@ -19,6 +19,9 @@
 #include <errno.h>
 #include <mapmem.h>
 #include <asm/io.h>
+#include <malloc.h>
+#include <crypto.h>
+
 DECLARE_GLOBAL_DATA_PTR;
 #endif /* !USE_HOSTCC*/
 
@@ -29,6 +32,9 @@ DECLARE_GLOBAL_DATA_PTR;
 #include <u-boot/sha1.h>
 #include <u-boot/sha256.h>
 
+#define __round_mask(x, y) ((__typeof__(x))((y)-1))
+#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)
+
 /*****************************************************************************/
 /* New uImage format routines */
 /*****************************************************************************/
@@ -434,6 +440,10 @@ void fit_image_print(const void *fit, int image_noffset, const char *p)
 			printf("0x%08lx\n", load);
 	}
 
+	/* optional load address for FDT */
+	if (type == IH_TYPE_FLATDT && !fit_image_get_load(fit, image_noffset, &load))
+		printf("%s  Load Address: 0x%08lx\n", p, load);
+
 	if ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||
 	    (type == IH_TYPE_RAMDISK)) {
 		ret = fit_image_get_entry(fit, image_noffset, &entry);
@@ -517,6 +527,29 @@ int fit_get_timestamp(const void *fit, int noffset, time_t *timestamp)
 	return 0;
 }
 
+/**
+ * fit_get_totalsize - get node totalsize property.
+ *
+ * @fit: pointer to the FIT image header
+ * @totalsize: holds the /totalsize property
+ *
+ * returns:
+ *     0, on success
+ *     -ENOENT if the property could not be found
+ */
+int fit_get_totalsize(const void *fit, int *totalsize)
+{
+	const fdt32_t *val;
+
+	val = fdt_getprop(fit, 0, FIT_TOTALSIZE_PROP, NULL);
+	if (!val)
+		return -ENOENT;
+
+	*totalsize = fdt32_to_cpu(*val);
+
+	return 0;
+}
+
 /**
  * fit_image_get_node - get node offset for component image of a given unit name
  * @fit: pointer to the FIT format image header
@@ -678,6 +711,23 @@ int fit_image_get_comp(const void *fit, int noffset, uint8_t *comp)
 	return 0;
 }
 
+bool fit_image_is_preload(const void *fit, int noffset)
+{
+	int len;
+	int *data;
+
+	data = (int *)fdt_getprop(fit, noffset, FIT_PRE_LOAD_PROP, &len);
+	if (data == NULL || len != sizeof(int)) {
+		fit_get_debug(fit, noffset, FIT_PRE_LOAD_PROP, len);
+		return false;
+	}
+
+	if (fdt32_to_cpu(*data) != 1)
+		return false;
+
+	return true;
+}
+
 static int fit_image_get_address(const void *fit, int noffset, char *name,
 			  ulong *load)
 {
@@ -706,6 +756,34 @@ static int fit_image_get_address(const void *fit, int noffset, char *name,
 
 	return 0;
 }
+
+static int fit_image_set_address(const void *fit, int noffset, char *name,
+				 ulong addr)
+{
+	int len, cell_len;
+	const fdt32_t *cell;
+
+	cell = fdt_getprop(fit, noffset, name, &len);
+	if (cell == NULL) {
+		fit_get_debug(fit, noffset, name, len);
+		return -1;
+	}
+
+	if (len > sizeof(ulong)) {
+		printf("Unsupported %s address size\n", name);
+		return -1;
+	}
+
+	cell_len = len >> 2;
+	/* Use load64 to avoid compiling warning for 32-bit target */
+	while (cell_len--) {
+		*(fdt32_t *)cell = cpu_to_uimage(addr >> (32 * cell_len));
+		cell++;
+	}
+
+	return 0;
+}
+
 /**
  * fit_image_get_load() - get load addr property for given component image node
  * @fit: pointer to the FIT format image header
@@ -724,6 +802,42 @@ int fit_image_get_load(const void *fit, int noffset, ulong *load)
 	return fit_image_get_address(fit, noffset, FIT_LOAD_PROP, load);
 }
 
+/**
+ * fit_image_get_comp_addr() - get compress addr property for given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @comp: pointer to the uint32_t, will hold load address
+ *
+ * fit_image_get_comp_addr() finds compress address property in a given component
+ * image node. If the property is found, its value is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_comp_addr(const void *fit, int noffset, ulong *comp)
+{
+	return fit_image_get_address(fit, noffset, FIT_COMP_ADDR_PROP, comp);
+}
+
+/**
+ * fit_image_set_load() - set load addr property for given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @load: uint32_t value, will hold load address
+ *
+ * fit_image_set_load() finds and set load address property in a given component
+ * image node. If the property is found, its value is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_set_load(const void *fit, int noffset, ulong load)
+{
+	return fit_image_set_address(fit, noffset, FIT_LOAD_PROP, load);
+}
+
 /**
  * fit_image_get_entry() - get entry point address property
  * @fit: pointer to the FIT format image header
@@ -746,6 +860,28 @@ int fit_image_get_entry(const void *fit, int noffset, ulong *entry)
 	return fit_image_get_address(fit, noffset, FIT_ENTRY_PROP, entry);
 }
 
+/**
+ * fit_image_set_entry() - set entry point address property
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @entry: uint32_t value, will hold entry point address
+ *
+ * This sets the entry point address property for a given component image
+ * node.
+ *
+ * fit_image_set_entry() finds and set entry point address property in a given
+ * component image node.  If the property is found, its value is returned
+ * to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_set_entry(const void *fit, int noffset, ulong entry)
+{
+	return fit_image_set_address(fit, noffset, FIT_ENTRY_PROP, entry);
+}
+
 /**
  * fit_image_get_data - get data property and its size for a given component image node
  * @fit: pointer to the FIT format image header
@@ -764,17 +900,38 @@ int fit_image_get_entry(const void *fit, int noffset, ulong *entry)
 int fit_image_get_data(const void *fit, int noffset,
 		const void **data, size_t *size)
 {
+	ulong data_off = 0;
+	ulong data_pos = 0;
 	int len;
 
+	/* data */
 	*data = fdt_getprop(fit, noffset, FIT_DATA_PROP, &len);
-	if (*data == NULL) {
-		fit_get_debug(fit, noffset, FIT_DATA_PROP, len);
-		*size = 0;
-		return -1;
+	if (*data) {
+		*size = len;
+		return 0;
 	}
 
-	*size = len;
-	return 0;
+	/* data-size */
+	if (fit_image_get_data_size(fit, noffset, &len))
+		return -ENOENT;
+
+	/* data-offset */
+	if (!fit_image_get_data_offset(fit, noffset, (int *)&data_off)) {
+		data_off += (ulong)fit + FIT_ALIGN(fdt_totalsize(fit));
+		*data = (void *)data_off;
+		*size = len;
+		return 0;
+	}
+
+	/* data-position */
+	if (!fit_image_get_data_position(fit, noffset, (int *)&data_pos)) {
+		*data = (void *)(data_pos + (ulong)fit);
+		*size = len;
+		return 0;
+	}
+
+	*size = 0;
+	return -1;
 }
 
 /**
@@ -801,6 +958,31 @@ int fit_image_get_data_offset(const void *fit, int noffset, int *data_offset)
 	return 0;
 }
 
+/**
+ * Get 'data-position' property from a given image node.
+ *
+ * @fit: pointer to the FIT image header
+ * @noffset: component image node offset
+ * @data_position: holds the data-position property
+ *
+ * returns:
+ *     0, on success
+ *     -ENOENT if the property could not be found
+ */
+int fit_image_get_data_position(const void *fit, int noffset,
+				int *data_position)
+{
+	const fdt32_t *val;
+
+	val = fdt_getprop(fit, noffset, FIT_DATA_POSITION_PROP, NULL);
+	if (!val)
+		return -ENOENT;
+
+	*data_position = fdt32_to_cpu(*val);
+
+	return 0;
+}
+
 /**
  * Get 'data-size' property from a given image node.
  *
@@ -825,6 +1007,30 @@ int fit_image_get_data_size(const void *fit, int noffset, int *data_size)
 	return 0;
 }
 
+/**
+ * Get 'rollback-index' property from a given image node.
+ *
+ * @fit: pointer to the FIT image header
+ * @noffset: component image node offset
+ * @index: holds the rollback-index property
+ *
+ * returns:
+ *     0, on success
+ *     -ENOENT if the property could not be found
+ */
+int fit_image_get_rollback_index(const void *fit, int noffset, uint32_t *index)
+{
+	const fdt32_t *val;
+
+	val = fdt_getprop(fit, noffset, FIT_ROLLBACK_PROP, NULL);
+	if (!val)
+		return -ENOENT;
+
+	*index = fdt32_to_cpu(*val);
+
+	return 0;
+}
+
 /**
  * fit_image_hash_get_algo - get hash algorithm name
  * @fit: pointer to the FIT format image header
@@ -946,43 +1152,59 @@ int fit_set_timestamp(void *fit, int noffset, time_t timestamp)
 	return 0;
 }
 
-/**
- * calculate_hash - calculate and return hash for provided input data
- * @data: pointer to the input data
- * @data_len: data length
- * @algo: requested hash algorithm
- * @value: pointer to the char, will hold hash value data (caller must
- * allocate enough free space)
- * value_len: length of the calculated hash
- *
- * calculate_hash() computes input data hash according to the requested
- * algorithm.
- * Resulting hash value is placed in caller provided 'value' buffer, length
- * of the calculated hash is returned via value_len pointer argument.
- *
- * returns:
- *     0, on success
- *    -1, when algo is unsupported
- */
-int calculate_hash(const void *data, int data_len, const char *algo,
-			uint8_t *value, int *value_len)
+int fit_set_totalsize(void *fit, int noffset, int totalsize)
+{
+	uint32_t t;
+	int ret;
+
+	t = cpu_to_uimage(totalsize);
+	ret = fdt_setprop(fit, noffset, FIT_TOTALSIZE_PROP, &t,
+				sizeof(uint32_t));
+	if (ret)
+		return ret == -FDT_ERR_NOSPACE ? -ENOSPC : -1;
+
+	return 0;
+}
+
+int fit_set_version(void *fit, int noffset, int version)
+{
+	uint32_t v;
+	int ret;
+
+	v = cpu_to_uimage(version);
+	ret = fdt_setprop(fit, noffset, FIT_VERSION_PROP, &v, sizeof(uint32_t));
+	if (ret)
+		return ret == -FDT_ERR_NOSPACE ? -ENOSPC : -1;
+
+	return 0;
+}
+
+int fit_calculate_hash(const void *data, int data_len,
+		       const char *algo, uint8_t *value,
+		       int *value_len)
 {
 	if (IMAGE_ENABLE_CRC32 && strcmp(algo, "crc32") == 0) {
 		*((uint32_t *)value) = crc32_wd(0, data, data_len,
 							CHUNKSZ_CRC32);
 		*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));
 		*value_len = 4;
+#ifdef CONFIG_SHA1
 	} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, "sha1") == 0) {
 		sha1_csum_wd((unsigned char *)data, data_len,
 			     (unsigned char *)value, CHUNKSZ_SHA1);
 		*value_len = 20;
+#endif
+#ifdef CONFIG_SHA256
 	} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, "sha256") == 0) {
 		sha256_csum_wd((unsigned char *)data, data_len,
 			       (unsigned char *)value, CHUNKSZ_SHA256);
 		*value_len = SHA256_SUM_LEN;
+#endif
+#ifdef CONFIG_MD5
 	} else if (IMAGE_ENABLE_MD5 && strcmp(algo, "md5") == 0) {
 		md5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);
 		*value_len = 16;
+#endif
 	} else {
 		debug("Unsupported hash alogrithm\n");
 		return -1;
@@ -990,8 +1212,92 @@ int calculate_hash(const void *data, int data_len, const char *algo,
 	return 0;
 }
 
-static int fit_image_check_hash(const void *fit, int noffset, const void *data,
-				size_t size, char **err_msgp)
+#ifndef USE_HOSTCC
+#if CONFIG_IS_ENABLED(FIT_HW_CRYPTO)
+static int crypto_csum(u32 cap, const char *data, int len, u8 *output)
+{
+	struct udevice *dev;
+	sha_context csha_ctx;
+
+	dev = crypto_get_device(cap);
+	if (!dev) {
+		printf("Can't find expected crypto device\n");
+		return -ENODEV;
+	}
+
+	csha_ctx.algo = cap;
+	csha_ctx.length = len;
+
+	return crypto_sha_csum(dev, &csha_ctx, (char *)data, len, output);
+}
+
+static int hw_fit_calculate_hash(const void *data, int data_len,
+				 const char *algo, uint8_t *value,
+				 int *value_len)
+{
+	int ret = 0;
+
+	if (IMAGE_ENABLE_CRC32 && strcmp(algo, "crc32") == 0) {
+		*((uint32_t *)value) = crc32_wd(0, data, data_len,
+							CHUNKSZ_CRC32);
+		*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));
+		*value_len = 4;
+	} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, "sha1") == 0) {
+		ret = crypto_csum(CRYPTO_SHA1, data, data_len, value);
+		*value_len = 20;
+	} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, "sha256") == 0) {
+		ret = crypto_csum(CRYPTO_SHA256, data, data_len, value);
+		*value_len = SHA256_SUM_LEN;
+	} else if (IMAGE_ENABLE_MD5 && strcmp(algo, "md5") == 0) {
+		ret = crypto_csum(CRYPTO_MD5, data, data_len, value);
+		*value_len = 16;
+	} else {
+		debug("Unsupported hash alogrithm\n");
+		return -1;
+	}
+
+	if (ret)
+		printf("%s: algo %s failed, ret=%d\n", __func__, algo, ret);
+
+	return ret;
+}
+#endif
+#endif
+
+/**
+ * calculate_hash - calculate and return hash for provided input data
+ * @data: pointer to the input data
+ * @data_len: data length
+ * @algo: requested hash algorithm
+ * @value: pointer to the char, will hold hash value data (caller must
+ * allocate enough free space)
+ * value_len: length of the calculated hash
+ *
+ * calculate_hash() computes input data hash according to the requested
+ * algorithm.
+ * Resulting hash value is placed in caller provided 'value' buffer, length
+ * of the calculated hash is returned via value_len pointer argument.
+ *
+ * returns:
+ *     0, on success
+ *    -1, when algo is unsupported
+ */
+int calculate_hash(const void *data, int data_len, const char *algo,
+		   uint8_t *value, int *value_len)
+{
+#if defined(USE_HOSTCC)
+	return fit_calculate_hash(data, data_len, algo, value, value_len);
+#else
+#if !CONFIG_IS_ENABLED(FIT_HW_CRYPTO)
+	return fit_calculate_hash(data, data_len, algo, value, value_len);
+#else
+	return hw_fit_calculate_hash(data, data_len, algo, value, value_len);
+#endif
+#endif
+}
+
+int fit_image_check_hash(const void *fit, int noffset, const void *data,
+			 size_t size, char **err_msgp)
 {
 	uint8_t value[FIT_MAX_HASH_LEN];
 	int value_len;
@@ -999,6 +1305,7 @@ static int fit_image_check_hash(const void *fit, int noffset, const void *data,
 	uint8_t *fit_value;
 	int fit_value_len;
 	int ignore;
+	int i;
 
 	*err_msgp = NULL;
 
@@ -1031,41 +1338,33 @@ static int fit_image_check_hash(const void *fit, int noffset, const void *data,
 		*err_msgp = "Bad hash value len";
 		return -1;
 	} else if (memcmp(value, fit_value, value_len) != 0) {
+		printf(" Bad hash: ");
+		for (i = 0; i < value_len; i++)
+			printf("%02x", value[i]);
+		printf("\n");
+
 		*err_msgp = "Bad hash value";
 		return -1;
 	}
 
+#ifdef CONFIG_SPL_BUILD
+	printf("(");
+	for (i = 0; i < 5; i++)
+		printf("%02x", value[i]);
+	printf("...) ");
+#endif
+
 	return 0;
 }
 
-/**
- * fit_image_verify - verify data integrity
- * @fit: pointer to the FIT format image header
- * @image_noffset: component image node offset
- *
- * fit_image_verify() goes over component image hash nodes,
- * re-calculates each data hash and compares with the value stored in hash
- * node.
- *
- * returns:
- *     1, if all hashes are valid
- *     0, otherwise (or on error)
- */
-int fit_image_verify(const void *fit, int image_noffset)
+int fit_image_verify_with_data(const void *fit, int image_noffset,
+			       const void *data, size_t size)
 {
-	const void	*data;
-	size_t		size;
 	int		noffset = 0;
 	char		*err_msg = "";
 	int verify_all = 1;
 	int ret;
 
-	/* Get image data and data length */
-	if (fit_image_get_data(fit, image_noffset, &data, &size)) {
-		err_msg = "Can't get image data/size";
-		goto error;
-	}
-
 	/* Verify all required signatures */
 	if (IMAGE_ENABLE_VERIFY &&
 	    fit_image_verify_required_sigs(fit, image_noffset, data, size,
@@ -1113,7 +1412,7 @@ int fit_image_verify(const void *fit, int image_noffset)
 		goto error;
 	}
 
-	return 1;
+	return 1; /* success */
 
 error:
 	printf(" error!\n%s for '%s' hash node in '%s' image node\n",
@@ -1122,6 +1421,38 @@ error:
 	return 0;
 }
 
+/**
+ * fit_image_verify - verify data integrity
+ * @fit: pointer to the FIT format image header
+ * @image_noffset: component image node offset
+ *
+ * fit_image_verify() goes over component image hash nodes,
+ * re-calculates each data hash and compares with the value stored in hash
+ * node.
+ *
+ * returns:
+ *     1, if all hashes are valid
+ *     0, otherwise (or on error)
+ */
+int fit_image_verify(const void *fit, int image_noffset)
+{
+	const void	*data;
+	size_t		size;
+	int		noffset = 0;
+	char		*err_msg = "";
+
+	/* Get image data and data length */
+	if (fit_image_get_data(fit, image_noffset, &data, &size)) {
+		err_msg = "Can't get image data/size";
+		printf("error!\n%s for '%s' hash node in '%s' image node\n",
+		       err_msg, fit_get_name(fit, noffset, NULL),
+		       fit_get_name(fit, image_noffset, NULL));
+		return 0;
+	}
+
+	return fit_image_verify_with_data(fit, image_noffset, data, size);
+}
+
 /**
  * fit_all_image_verify - verify data integrity for all images
  * @fit: pointer to the FIT format image header
@@ -1454,6 +1785,8 @@ int fit_conf_get_node(const void *fit, const char *conf_uname)
 {
 	int noffset, confs_noffset;
 	int len;
+	const char *s;
+	char *conf_uname_copy = NULL;
 
 	confs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);
 	if (confs_noffset < 0) {
@@ -1475,29 +1808,58 @@ int fit_conf_get_node(const void *fit, const char *conf_uname)
 		debug("Found default configuration: '%s'\n", conf_uname);
 	}
 
+	s = strchr(conf_uname, '#');
+	if (s) {
+		len = s - conf_uname;
+		conf_uname_copy = malloc(len + 1);
+		if (!conf_uname_copy) {
+			debug("Can't allocate uname copy: '%s'\n",
+					conf_uname);
+			return -ENOMEM;
+		}
+		memcpy(conf_uname_copy, conf_uname, len);
+		conf_uname_copy[len] = '\0';
+		conf_uname = conf_uname_copy;
+	}
+
 	noffset = fdt_subnode_offset(fit, confs_noffset, conf_uname);
 	if (noffset < 0) {
 		debug("Can't get node offset for configuration unit name: '%s' (%s)\n",
 		      conf_uname, fdt_strerror(noffset));
 	}
 
+	if (conf_uname_copy)
+		free(conf_uname_copy);
+
 	return noffset;
 }
 
-int fit_conf_get_prop_node(const void *fit, int noffset,
+int fit_conf_get_prop_node_count(const void *fit, int noffset,
 		const char *prop_name)
 {
-	char *uname;
+	return fdt_stringlist_count(fit, noffset, prop_name);
+}
+
+int fit_conf_get_prop_node_index(const void *fit, int noffset,
+		const char *prop_name, int index)
+{
+	const char *uname;
 	int len;
 
 	/* get kernel image unit name from configuration kernel property */
-	uname = (char *)fdt_getprop(fit, noffset, prop_name, &len);
+	uname = fdt_stringlist_get(fit, noffset, prop_name, index, &len);
 	if (uname == NULL)
 		return len;
 
 	return fit_image_get_node(fit, uname);
 }
 
+int fit_conf_get_prop_node(const void *fit, int noffset,
+		const char *prop_name)
+{
+	return fit_conf_get_prop_node_index(fit, noffset, prop_name, 0);
+}
+
 /**
  * fit_conf_print - prints out the FIT configuration details
  * @fit: pointer to the FIT format image header
@@ -1515,7 +1877,7 @@ void fit_conf_print(const void *fit, int noffset, const char *p)
 	char *desc;
 	const char *uname;
 	int ret;
-	int loadables_index;
+	int fdt_index, loadables_index;
 
 	/* Mandatory properties */
 	ret = fit_get_desc(fit, noffset, &desc);
@@ -1537,9 +1899,21 @@ void fit_conf_print(const void *fit, int noffset, const char *p)
 	if (uname)
 		printf("%s  Init Ramdisk: %s\n", p, uname);
 
-	uname = fdt_getprop(fit, noffset, FIT_FDT_PROP, NULL);
+	uname = fdt_getprop(fit, noffset, FIT_FIRMWARE_PROP, NULL);
 	if (uname)
-		printf("%s  FDT:          %s\n", p, uname);
+		printf("%s  Firmware:     %s\n", p, uname);
+
+	for (fdt_index = 0;
+	     uname = fdt_stringlist_get(fit, noffset, FIT_FDT_PROP,
+					fdt_index, NULL), uname;
+	     fdt_index++) {
+
+		if (fdt_index == 0)
+			printf("%s  FDT:          ", p);
+		else
+			printf("%s                ", p);
+		printf("%s\n", uname);
+	}
 
 	uname = fdt_getprop(fit, noffset, FIT_FPGA_PROP, NULL);
 	if (uname)
@@ -1561,8 +1935,13 @@ void fit_conf_print(const void *fit, int noffset, const char *p)
 
 static int fit_image_select(const void *fit, int rd_noffset, int verify)
 {
+#ifdef USE_HOSTCC
 	fit_image_print(fit, rd_noffset, "   ");
-
+#else
+#if CONFIG_IS_ENABLED(FIT_PRINT)
+	fit_image_print(fit, rd_noffset, "   ");
+#endif
+#endif
 	if (verify) {
 		puts("   Verifying Hash Integrity ... ");
 		if (!fit_image_verify(fit, rd_noffset)) {
@@ -1622,25 +2001,37 @@ static const char *fit_get_image_type_property(int type)
 		return FIT_KERNEL_PROP;
 	case IH_TYPE_RAMDISK:
 		return FIT_RAMDISK_PROP;
+	case IH_TYPE_FIRMWARE:
+		return FIT_FIRMWARE_PROP;
 	case IH_TYPE_X86_SETUP:
 		return FIT_SETUP_PROP;
 	case IH_TYPE_LOADABLE:
 		return FIT_LOADABLE_PROP;
 	case IH_TYPE_FPGA:
 		return FIT_FPGA_PROP;
+	case IH_TYPE_STANDALONE:
+		return FIT_STANDALONE_PROP;
 	}
 
 	return "unknown";
 }
 
-int fit_image_load(bootm_headers_t *images, ulong addr,
-		   const char **fit_unamep, const char **fit_uname_configp,
-		   int arch, int image_type, int bootstage_id,
-		   enum fit_load_op load_op, ulong *datap, ulong *lenp)
+#ifndef USE_HOSTCC
+__weak int fit_board_verify_required_sigs(void)
+{
+	return 0;
+}
+#endif
+
+int fit_image_load_index(bootm_headers_t *images, ulong addr,
+			 const char **fit_unamep, const char **fit_uname_configp,
+			 int arch, int image_type, int image_index, int bootstage_id,
+			 enum fit_load_op load_op, ulong *datap, ulong *lenp)
 {
 	int cfg_noffset, noffset;
 	const char *fit_uname;
 	const char *fit_uname_config;
+	const char *fit_base_uname_config;
 	const void *fit;
 	const void *buf;
 	size_t size;
@@ -1656,6 +2047,7 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 	fit = map_sysmem(addr, 0);
 	fit_uname = fit_unamep ? *fit_unamep : NULL;
 	fit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;
+	fit_base_uname_config = NULL;
 	prop_name = fit_get_image_type_property(image_type);
 	printf("## Loading %s from FIT Image at %08lx ...\n", prop_name, addr);
 
@@ -1689,12 +2081,20 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 					BOOTSTAGE_SUB_NO_UNIT_NAME);
 			return -ENOENT;
 		}
-		fit_uname_config = fdt_get_name(fit, cfg_noffset, NULL);
-		printf("   Using '%s' configuration\n", fit_uname_config);
+		fit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL);
+		printf("   Using '%s' configuration\n", fit_base_uname_config);
 		if (image_type == IH_TYPE_KERNEL) {
+#ifndef USE_HOSTCC
+			/* If board required sigs, check self */
+			if (fit_board_verify_required_sigs() &&
+			    !IS_ENABLED(CONFIG_FIT_SIGNATURE)) {
+				printf("Verified-boot requires CONFIG_FIT_SIGNATURE enabled\n");
+				hang();
+			}
+#endif
 			/* Remember (and possibly verify) this config */
-			images->fit_uname_cfg = fit_uname_config;
-			if (IMAGE_ENABLE_VERIFY && images->verify) {
+			images->fit_uname_cfg = fit_base_uname_config;
+			if (IMAGE_ENABLE_VERIFY) {
 				puts("   Verifying Hash Integrity ... ");
 				if (fit_config_verify(fit, cfg_noffset)) {
 					puts("Bad Data Hash\n");
@@ -1703,12 +2103,30 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 					return -EACCES;
 				}
 				puts("OK\n");
+
+#ifdef CONFIG_FIT_ROLLBACK_PROTECT
+				uint32_t this_index, min_index;
+
+				puts("   Verifying Rollback-index ... ");
+				if (fit_rollback_index_verify(fit,
+						FIT_ROLLBACK_INDEX,
+						&this_index, &min_index)) {
+					puts("Failed to get index\n");
+					return ret;
+				} else if (this_index < min_index) {
+					printf("Reject index %d < %d(min)\n",
+					       this_index, min_index);
+					return -EINVAL;
+				}
+
+				printf("%d >= %d(min), OK\n", this_index, min_index);
+#endif
 			}
 			bootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);
 		}
 
-		noffset = fit_conf_get_prop_node(fit, cfg_noffset,
-						 prop_name);
+		noffset = fit_conf_get_prop_node_index(fit, cfg_noffset,
+						       prop_name, image_index);
 		fit_uname = fit_get_name(fit, noffset, NULL);
 	}
 	if (noffset < 0) {
@@ -1754,6 +2172,8 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 	os_ok = image_type == IH_TYPE_FLATDT ||
 		image_type == IH_TYPE_FPGA ||
 		fit_image_check_os(fit, noffset, IH_OS_LINUX) ||
+		fit_image_check_os(fit, noffset, IH_OS_ARM_TRUSTED_FIRMWARE) ||
+		fit_image_check_os(fit, noffset, IH_OS_OP_TEE) ||
 		fit_image_check_os(fit, noffset, IH_OS_U_BOOT) ||
 		fit_image_check_os(fit, noffset, IH_OS_OPENRTOS);
 
@@ -1782,8 +2202,13 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 	}
 
 #if !defined(USE_HOSTCC) && defined(CONFIG_FIT_IMAGE_POST_PROCESS)
+	ret = fit_image_get_load(fit, noffset, &load);
+	if (ret < 0)
+		return ret;
+
 	/* perform any post-processing on the image data */
-	board_fit_image_post_process((void **)&buf, &size);
+	board_fit_image_post_process((void *)fit, noffset,
+				     &load, (ulong **)&buf, &size, NULL);
 #endif
 
 	len = (ulong)size;
@@ -1849,11 +2274,22 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 	if (fit_unamep)
 		*fit_unamep = (char *)fit_uname;
 	if (fit_uname_configp)
-		*fit_uname_configp = (char *)fit_uname_config;
+		*fit_uname_configp = (char *)(fit_uname_config ? :
+					      fit_base_uname_config);
 
 	return noffset;
 }
 
+int fit_image_load(bootm_headers_t *images, ulong addr,
+		   const char **fit_unamep, const char **fit_uname_configp,
+		   int arch, int image_type, int bootstage_id,
+		   enum fit_load_op load_op, ulong *datap, ulong *lenp)
+{
+	return fit_image_load_index(images, addr,fit_unamep, fit_uname_configp,
+				    arch, image_type, 0, bootstage_id,
+				    load_op, datap, lenp);
+}
+
 int boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,
 			ulong *setup_start, ulong *setup_len)
 {
@@ -1873,3 +2309,144 @@ int boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,
 
 	return ret;
 }
+
+#ifndef USE_HOSTCC
+int boot_get_fdt_fit(bootm_headers_t *images, ulong addr,
+		   const char **fit_unamep, const char **fit_uname_configp,
+		   int arch, ulong *datap, ulong *lenp)
+{
+	int fdt_noffset, cfg_noffset, count;
+	const void *fit;
+	const char *fit_uname = NULL;
+	const char *fit_uname_config = NULL;
+	char *fit_uname_config_copy = NULL;
+	char *next_config = NULL;
+	ulong load, len;
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+	ulong image_start, image_end;
+	ulong ovload, ovlen;
+	const char *uconfig;
+	const char *uname;
+	void *base, *ov;
+	int i, err, noffset, ov_noffset;
+#endif
+
+	fit_uname = fit_unamep ? *fit_unamep : NULL;
+
+	if (fit_uname_configp && *fit_uname_configp) {
+		fit_uname_config_copy = strdup(*fit_uname_configp);
+		if (!fit_uname_config_copy)
+			return -ENOMEM;
+
+		next_config = strchr(fit_uname_config_copy, '#');
+		if (next_config)
+			*next_config++ = '\0';
+		if (next_config - 1 > fit_uname_config_copy)
+			fit_uname_config = fit_uname_config_copy;
+	}
+
+	fdt_noffset = fit_image_load(images,
+		addr, &fit_uname, &fit_uname_config,
+		arch, IH_TYPE_FLATDT,
+		BOOTSTAGE_ID_FIT_FDT_START,
+		FIT_LOAD_OPTIONAL, &load, &len);
+
+	if (fdt_noffset < 0)
+		goto out;
+
+	debug("fit_uname=%s, fit_uname_config=%s\n",
+			fit_uname ? fit_uname : "<NULL>",
+			fit_uname_config ? fit_uname_config : "<NULL>");
+
+	fit = map_sysmem(addr, 0);
+
+	cfg_noffset = fit_conf_get_node(fit, fit_uname_config);
+
+	/* single blob, or error just return as well */
+	count = fit_conf_get_prop_node_count(fit, cfg_noffset, FIT_FDT_PROP);
+	if (count <= 1 && !next_config)
+		goto out;
+
+	/* we need to apply overlays */
+
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+	image_start = addr;
+	image_end = addr + fit_get_size(fit);
+	/* verify that relocation took place by load address not being in fit */
+	if (load >= image_start && load < image_end) {
+		/* check is simplified; fit load checks for overlaps */
+		printf("Overlayed FDT requires relocation\n");
+		fdt_noffset = -EBADF;
+		goto out;
+	}
+
+	base = map_sysmem(load, len);
+
+	/* apply extra configs in FIT first, followed by args */
+	for (i = 1; ; i++) {
+		if (i < count) {
+			noffset = fit_conf_get_prop_node_index(fit, cfg_noffset,
+							       FIT_FDT_PROP, i);
+			uname = fit_get_name(fit, noffset, NULL);
+			uconfig = NULL;
+		} else {
+			if (!next_config)
+				break;
+			uconfig = next_config;
+			next_config = strchr(next_config, '#');
+			if (next_config)
+				*next_config++ = '\0';
+			uname = NULL;
+		}
+
+		debug("%d: using uname=%s uconfig=%s\n", i, uname, uconfig);
+
+		ov_noffset = fit_image_load(images,
+			addr, &uname, &uconfig,
+			arch, IH_TYPE_FLATDT,
+			BOOTSTAGE_ID_FIT_FDT_START,
+			FIT_LOAD_REQUIRED, &ovload, &ovlen);
+		if (ov_noffset < 0) {
+			printf("load of %s failed\n", uname);
+			continue;
+		}
+		debug("%s loaded at 0x%08lx len=0x%08lx\n",
+				uname, ovload, ovlen);
+		ov = map_sysmem(ovload, ovlen);
+
+		base = map_sysmem(load, len + ovlen);
+		err = fdt_open_into(base, base, len + ovlen);
+		if (err < 0) {
+			printf("failed on fdt_open_into\n");
+			fdt_noffset = err;
+			goto out;
+		}
+		/* the verbose method prints out messages on error */
+		err = fdt_overlay_apply_verbose(base, ov);
+		if (err < 0) {
+			fdt_noffset = err;
+			goto out;
+		}
+		fdt_pack(base);
+		len = fdt_totalsize(base);
+	}
+#else
+	printf("config with overlays but CONFIG_OF_LIBFDT_OVERLAY not set\n");
+	fdt_noffset = -EBADF;
+#endif
+
+out:
+	if (datap)
+		*datap = load;
+	if (lenp)
+		*lenp = len;
+	if (fit_unamep)
+		*fit_unamep = fit_uname;
+	if (fit_uname_configp)
+		*fit_uname_configp = fit_uname_config;
+
+	if (fit_uname_config_copy)
+		free(fit_uname_config_copy);
+	return fdt_noffset;
+}
+#endif
diff --git a/common/image-sig.c b/common/image-sig.c
index 455f2b9629..cc0d2b2f2f 100644
--- a/common/image-sig.c
+++ b/common/image-sig.c
@@ -10,6 +10,7 @@
 #else
 #include <common.h>
 #include <malloc.h>
+#include <optee_include/OpteeClientInterface.h>
 DECLARE_GLOBAL_DATA_PTR;
 #endif /* !USE_HOSTCC*/
 #include <image.h>
@@ -30,48 +31,72 @@ void *image_get_host_blob(void)
 }
 #endif
 
+static const uint8_t sha1_der_prefix_data[SHA1_DER_LEN] = {
+	0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e,
+	0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14
+};
+
+static const uint8_t sha256_der_prefix_data[SHA256_DER_LEN] = {
+	0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+	0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
+	0x00, 0x04, 0x20
+};
+
 struct checksum_algo checksum_algos[] = {
 	{
-		"sha1",
-		SHA1_SUM_LEN,
-		SHA1_DER_LEN,
-		sha1_der_prefix,
+		.name = "sha1",
+		.checksum_len = SHA1_SUM_LEN,
+		.der_len = SHA1_DER_LEN,
+		.der_prefix = sha1_der_prefix_data,
 #if IMAGE_ENABLE_SIGN
-		EVP_sha1,
+		.calculate_sign = EVP_sha1,
 #endif
-		hash_calculate,
+		.calculate = hash_calculate,
 	},
 	{
-		"sha256",
-		SHA256_SUM_LEN,
-		SHA256_DER_LEN,
-		sha256_der_prefix,
+		.name = "sha256",
+		.checksum_len = SHA256_SUM_LEN,
+		.der_len = SHA256_DER_LEN,
+		.der_prefix = sha256_der_prefix_data,
 #if IMAGE_ENABLE_SIGN
-		EVP_sha256,
+		.calculate_sign = EVP_sha256,
 #endif
-		hash_calculate,
+		.calculate = hash_calculate,
 	}
 
 };
 
 struct crypto_algo crypto_algos[] = {
 	{
-		"rsa2048",
-		RSA2048_BYTES,
-		rsa_sign,
-		rsa_add_verify_data,
-		rsa_verify,
+		.name = "rsa2048",
+		.key_len = RSA2048_BYTES,
+		.sign = rsa_sign,
+		.add_verify_data = rsa_add_verify_data,
+		.verify = rsa_verify,
 	},
 	{
-		"rsa4096",
-		RSA4096_BYTES,
-		rsa_sign,
-		rsa_add_verify_data,
-		rsa_verify,
+		.name = "rsa4096",
+		.key_len = RSA4096_BYTES,
+		.sign = rsa_sign,
+		.add_verify_data = rsa_add_verify_data,
+		.verify = rsa_verify,
 	}
 
 };
 
+struct padding_algo padding_algos[] = {
+	{
+		.name = "pkcs-1.5",
+		.verify = padding_pkcs_15_verify,
+	},
+#ifdef CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT
+	{
+		.name = "pss",
+		.verify = padding_pss_verify,
+	}
+#endif /* CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT */
+};
+
 struct checksum_algo *image_get_checksum_algo(const char *full_name)
 {
 	int i;
@@ -107,6 +132,21 @@ struct crypto_algo *image_get_crypto_algo(const char *full_name)
 	return NULL;
 }
 
+struct padding_algo *image_get_padding_algo(const char *name)
+{
+	int i;
+
+	if (!name)
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(padding_algos); i++) {
+		if (!strcmp(padding_algos[i].name, name))
+			return &padding_algos[i];
+	}
+
+	return NULL;
+}
+
 /**
  * fit_region_make_list() - Make a list of image regions
  *
@@ -156,11 +196,17 @@ static int fit_image_setup_verify(struct image_sign_info *info,
 		char **err_msgp)
 {
 	char *algo_name;
+	const char *padding_name;
 
 	if (fit_image_hash_get_algo(fit, noffset, &algo_name)) {
 		*err_msgp = "Can't get hash algo property";
 		return -1;
 	}
+
+	padding_name = fdt_getprop(fit, noffset, "padding", NULL);
+	if (!padding_name)
+		padding_name = RSA_DEFAULT_PADDING_NAME;
+
 	memset(info, '\0', sizeof(*info));
 	info->keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
 	info->fit = (void *)fit;
@@ -168,6 +214,7 @@ static int fit_image_setup_verify(struct image_sign_info *info,
 	info->name = algo_name;
 	info->checksum = image_get_checksum_algo(algo_name);
 	info->crypto = image_get_crypto_algo(algo_name);
+	info->padding = image_get_padding_algo(padding_name);
 	info->fdt_blob = gd_fdt_blob();
 	info->required_keynode = required_keynode;
 	printf("%s:%s", algo_name, info->keyname);
@@ -242,7 +289,8 @@ static int fit_image_verify_sig(const void *fit, int image_noffset,
 		goto error;
 	}
 
-	return verified ? 0 : -EPERM;
+	if (verified)
+		return 0;
 
 error:
 	printf(" error!\n%s for '%s' hash node in '%s' image node\n",
@@ -263,9 +311,8 @@ int fit_image_verify_required_sigs(const void *fit, int image_noffset,
 	*no_sigsp = 1;
 	sig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);
 	if (sig_node < 0) {
-		debug("%s: No signature node found: %s\n", __func__,
-		      fdt_strerror(sig_node));
-		return 0;
+		printf("No RSA key found\n");
+		return -EINVAL;
 	}
 
 	fdt_for_each_subnode(noffset, sig_blob, sig_node) {
@@ -388,6 +435,13 @@ int fit_config_check_sig(const void *fit, int noffset, int required_keynode,
 		*err_msgp = "Verification failed";
 		return -1;
 	}
+	/* Get the secure flag here and write the secure data and the secure flag */
+#if !defined(USE_HOSTCC)
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_FIT_HW_CRYPTO) && \
+    defined(CONFIG_SPL_ROCKCHIP_SECURE_OTP)
+	rsa_burn_key_hash(&info);
+#endif
+#endif
 
 	return 0;
 }
@@ -423,7 +477,8 @@ static int fit_config_verify_sig(const void *fit, int conf_noffset,
 		goto error;
 	}
 
-	return verified ? 0 : -EPERM;
+	if (verified)
+		return 0;
 
 error:
 	printf(" error!\n%s for '%s' hash node in '%s' config node\n",
@@ -441,9 +496,8 @@ int fit_config_verify_required_sigs(const void *fit, int conf_noffset,
 	/* Work out what we need to verify */
 	sig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);
 	if (sig_node < 0) {
-		debug("%s: No signature node found: %s\n", __func__,
-		      fdt_strerror(sig_node));
-		return 0;
+		printf("No RSA key found\n");
+		return -EINVAL;
 	}
 
 	fdt_for_each_subnode(noffset, sig_blob, sig_node) {
@@ -458,7 +512,18 @@ int fit_config_verify_required_sigs(const void *fit, int conf_noffset,
 		if (ret) {
 			printf("Failed to verify required signature '%s'\n",
 			       fit_get_name(sig_blob, noffset, NULL));
+#ifndef USE_HOSTCC
+			/*
+			 * Allow bring up if enable FIT_SIGNATURE but
+			 * not enable the device secure boot.
+			 *
+			 * return value: 1: device secure boot is enabled.
+			 */
+			if (fit_board_verify_required_sigs())
+				return ret;
+#else
 			return ret;
+#endif
 		}
 	}
 
@@ -470,3 +535,22 @@ int fit_config_verify(const void *fit, int conf_noffset)
 	return fit_config_verify_required_sigs(fit, conf_noffset,
 					       gd_fdt_blob());
 }
+
+#ifndef USE_HOSTCC
+#if CONFIG_IS_ENABLED(FIT_ROLLBACK_PROTECT)
+__weak int fit_read_otp_rollback_index(uint32_t fit_index, uint32_t *otp_index)
+{
+	*otp_index = 0;
+
+	return 0;
+}
+__weak int fit_rollback_index_verify(const void *fit, uint32_t rollback_fd,
+				     uint32_t *this_index, uint32_t *min_index)
+{
+	*this_index = 0;
+	*min_index = 0;
+
+	return 0;
+}
+#endif
+#endif
diff --git a/common/image-sparse.c b/common/image-sparse.c
index ddf5772cf8..f1382bd351 100644
--- a/common/image-sparse.c
+++ b/common/image-sparse.c
@@ -51,7 +51,7 @@
 
 void write_sparse_image(
 		struct sparse_storage *info, const char *part_name,
-		void *data, unsigned sz)
+		void *data, unsigned sz, char *response)
 {
 	lbaint_t blk;
 	lbaint_t blkcnt;
@@ -101,7 +101,7 @@ void write_sparse_image(
 	if (offset) {
 		printf("%s: Sparse image block size issue [%u]\n",
 		       __func__, sparse_header->blk_sz);
-		fastboot_fail("sparse image block size issue");
+		fastboot_fail("sparse image block size issue", response);
 		return;
 	}
 
@@ -137,7 +137,7 @@ void write_sparse_image(
 			if (chunk_header->total_sz !=
 			    (sparse_header->chunk_hdr_sz + chunk_data_sz)) {
 				fastboot_fail(
-					"Bogus chunk size for chunk type Raw");
+					"Bogus chunk size for chunk type Raw", response);
 				return;
 			}
 
@@ -146,7 +146,7 @@ void write_sparse_image(
 				    "%s: Request would exceed partition size!\n",
 				    __func__);
 				fastboot_fail(
-				    "Request would exceed partition size!");
+				    "Request would exceed partition size!", response);
 				return;
 			}
 
@@ -157,7 +157,7 @@ void write_sparse_image(
 				       __func__, "Write failed, block #",
 				       blk, blks);
 				fastboot_fail(
-					      "flash write failure");
+					      "flash write failure", response);
 				return;
 			}
 			blk += blks;
@@ -170,7 +170,7 @@ void write_sparse_image(
 			if (chunk_header->total_sz !=
 			    (sparse_header->chunk_hdr_sz + sizeof(uint32_t))) {
 				fastboot_fail(
-					"Bogus chunk size for chunk type FILL");
+					"Bogus chunk size for chunk type FILL", response);
 				return;
 			}
 
@@ -181,7 +181,7 @@ void write_sparse_image(
 						ARCH_DMA_MINALIGN));
 			if (!fill_buf) {
 				fastboot_fail(
-					"Malloc failed for: CHUNK_TYPE_FILL");
+					"Malloc failed for: CHUNK_TYPE_FILL", response);
 				return;
 			}
 
@@ -199,7 +199,7 @@ void write_sparse_image(
 				    "%s: Request would exceed partition size!\n",
 				    __func__);
 				fastboot_fail(
-				    "Request would exceed partition size!");
+				    "Request would exceed partition size!", response);
 				return;
 			}
 
@@ -215,7 +215,7 @@ void write_sparse_image(
 					       "Write failed, block #",
 					       blk, j);
 					fastboot_fail(
-						      "flash write failure");
+						      "flash write failure", response);
 					free(fill_buf);
 					return;
 				}
@@ -236,7 +236,7 @@ void write_sparse_image(
 			if (chunk_header->total_sz !=
 			    sparse_header->chunk_hdr_sz) {
 				fastboot_fail(
-					"Bogus chunk size for chunk type Dont Care");
+					"Bogus chunk size for chunk type Dont Care", response);
 				return;
 			}
 			total_blocks += chunk_header->chunk_sz;
@@ -246,7 +246,7 @@ void write_sparse_image(
 		default:
 			printf("%s: Unknown chunk type: %x\n", __func__,
 			       chunk_header->chunk_type);
-			fastboot_fail("Unknown chunk type");
+			fastboot_fail("Unknown chunk type", response);
 			return;
 		}
 	}
@@ -256,9 +256,9 @@ void write_sparse_image(
 	printf("........ wrote %u bytes to '%s'\n", bytes_written, part_name);
 
 	if (total_blocks != sparse_header->total_blks)
-		fastboot_fail("sparse image write failure");
+		fastboot_fail("sparse image write failure", response);
 	else
-		fastboot_okay("");
+		fastboot_okay("", response);
 
 	return;
 }
diff --git a/common/image.c b/common/image.c
index a058eb85e1..4518a8f960 100644
--- a/common/image.c
+++ b/common/image.c
@@ -15,14 +15,6 @@
 #include <status_led.h>
 #endif
 
-#ifdef CONFIG_HAS_DATAFLASH
-#include <dataflash.h>
-#endif
-
-#ifdef CONFIG_LOGBUFFER
-#include <logbuff.h>
-#endif
-
 #include <rtc.h>
 
 #include <environment.h>
@@ -30,7 +22,7 @@
 #include <mapmem.h>
 
 #if IMAGE_ENABLE_FIT || IMAGE_ENABLE_OF_LIBFDT
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #include <fpga.h>
 #include <xilinx.h>
@@ -94,11 +86,14 @@ static const table_entry_t uimage_arch[] = {
 	{	IH_ARCH_ARC,		"arc",		"ARC",		},
 	{	IH_ARCH_X86_64,		"x86_64",	"AMD x86_64",	},
 	{	IH_ARCH_XTENSA,		"xtensa",	"Xtensa",	},
+	{	IH_ARCH_RISCV,		"riscv",	"RISC-V",	},
 	{	-1,			"",		"",		},
 };
 
 static const table_entry_t uimage_os[] = {
 	{	IH_OS_INVALID,	"invalid",	"Invalid OS",		},
+	{       IH_OS_OP_TEE, "op-tee", "OP-TEE"  },
+	{       IH_OS_ARM_TRUSTED_FIRMWARE, "arm-trusted-firmware", "ARM Trusted Firmware"  },
 	{	IH_OS_LINUX,	"linux",	"Linux",		},
 #if defined(CONFIG_LYNXKDI) || defined(USE_HOSTCC)
 	{	IH_OS_LYNXOS,	"lynxos",	"LynxOS",		},
@@ -167,6 +162,8 @@ static const table_entry_t uimage_type[] = {
 	{	IH_TYPE_FPGA,       "fpga",       "FPGA Image" },
 	{       IH_TYPE_TEE,        "tee",        "Trusted Execution Environment Image",},
 	{	IH_TYPE_FIRMWARE_IVT, "firmware_ivt", "Firmware with HABv4 IVT" },
+	{       IH_TYPE_PMMC,        "pmmc",        "TI Power Management Micro-Controller Firmware",},
+	{	IH_TYPE_RKNAND,     "rknand",     "Rockchip NAND Boot Image" },
 	{	-1,		    "",		  "",			},
 };
 
@@ -196,6 +193,26 @@ static const struct table_info table_info[IH_COUNT] = {
 /*****************************************************************************/
 /* Legacy format routines */
 /*****************************************************************************/
+#ifndef USE_HOSTCC
+#ifndef CONFIG_SPL_BUILD
+uint32_t image_get_load(const image_header_t *hdr)
+{
+	uint32_t load = uimage_to_cpu(hdr->ih_load);
+
+	return (load == IMAGE_PARAM_INVAL) ?
+		env_get_ulong("kernel_addr_r", 16, 0) : load;
+}
+
+uint32_t image_get_ep(const image_header_t *hdr)
+{
+	uint32_t ep = uimage_to_cpu(hdr->ih_ep);
+
+	return (ep == IMAGE_PARAM_INVAL) ?
+		env_get_ulong("kernel_addr_r", 16, 0) : ep;
+}
+#endif
+#endif
+
 int image_check_hcrc(const image_header_t *hdr)
 {
 	ulong hcrc;
@@ -243,7 +260,7 @@ ulong image_multi_count(const image_header_t *hdr)
 	size = (uint32_t *)image_get_data(hdr);
 
 	/* count non empty slots */
-	for (i = 0; size[i]; ++i)
+	for (i = 0; size[i] != IMAGE_PARAM_INVAL; ++i)
 		count++;
 
 	return count;
@@ -388,9 +405,6 @@ void image_print_contents(const void *ptr)
  * flag. Verification done covers data and header integrity and os/type/arch
  * fields checking.
  *
- * If dataflash support is enabled routine checks for dataflash addresses
- * and handles required dataflash reads.
- *
  * returns:
  *     pointer to a ramdisk image header, if image was found and valid
  *     otherwise, return NULL
@@ -888,81 +902,6 @@ int genimg_get_format(const void *img_addr)
 	return IMAGE_FORMAT_INVALID;
 }
 
-/**
- * genimg_get_image - get image from special storage (if necessary)
- * @img_addr: image start address
- *
- * genimg_get_image() checks if provided image start address is located
- * in a dataflash storage. If so, image is moved to a system RAM memory.
- *
- * returns:
- *     image start address after possible relocation from special storage
- */
-ulong genimg_get_image(ulong img_addr)
-{
-	ulong ram_addr = img_addr;
-
-#ifdef CONFIG_HAS_DATAFLASH
-	ulong h_size, d_size;
-
-	if (addr_dataflash(img_addr)) {
-		void *buf;
-
-		/* ger RAM address */
-		ram_addr = CONFIG_SYS_LOAD_ADDR;
-
-		/* get header size */
-		h_size = image_get_header_size();
-#if IMAGE_ENABLE_FIT
-		if (sizeof(struct fdt_header) > h_size)
-			h_size = sizeof(struct fdt_header);
-#endif
-
-		/* read in header */
-		debug("   Reading image header from dataflash address "
-			"%08lx to RAM address %08lx\n", img_addr, ram_addr);
-
-		buf = map_sysmem(ram_addr, 0);
-		read_dataflash(img_addr, h_size, buf);
-
-		/* get data size */
-		switch (genimg_get_format(buf)) {
-#if defined(CONFIG_IMAGE_FORMAT_LEGACY)
-		case IMAGE_FORMAT_LEGACY:
-			d_size = image_get_data_size(buf);
-			debug("   Legacy format image found at 0x%08lx, "
-					"size 0x%08lx\n",
-					ram_addr, d_size);
-			break;
-#endif
-#if IMAGE_ENABLE_FIT
-		case IMAGE_FORMAT_FIT:
-			d_size = fit_get_size(buf) - h_size;
-			debug("   FIT/FDT format image found at 0x%08lx, "
-					"size 0x%08lx\n",
-					ram_addr, d_size);
-			break;
-#endif
-		default:
-			printf("   No valid image found at 0x%08lx\n",
-				img_addr);
-			return ram_addr;
-		}
-
-		/* read in image data */
-		debug("   Reading image remaining data from dataflash address "
-			"%08lx to RAM address %08lx\n", img_addr + h_size,
-			ram_addr + h_size);
-
-		read_dataflash(img_addr + h_size, d_size,
-				(char *)(buf + h_size));
-
-	}
-#endif /* CONFIG_HAS_DATAFLASH */
-
-	return ram_addr;
-}
-
 /**
  * fit_has_config - check if there is a valid FIT configuration
  * @images: pointer to the bootm command headers structure
@@ -1095,9 +1034,6 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 		}
 #endif
 
-		/* copy from dataflash if needed */
-		rd_addr = genimg_get_image(rd_addr);
-
 		/*
 		 * Check if there is an initrd image at the
 		 * address provided in the second bootm argument
@@ -1237,11 +1173,6 @@ int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
 	}
 
 
-#ifdef CONFIG_LOGBUFFER
-	/* Prevent initrd from overwriting logbuffer */
-	lmb_reserve(lmb, logbuffer_base() - LOGBUFF_OVERHEAD, LOGBUFF_RESERVE);
-#endif
-
 	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
 			initrd_high, initrd_copy_to_ram);
 
@@ -1252,6 +1183,9 @@ int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
 			*initrd_end = rd_data + rd_len;
 			lmb_reserve(lmb, rd_data, rd_len);
 		} else {
+			if (initrd_high && env_get_yesno("bootm-reloc-at"))
+				initrd_high += rd_len;
+
 			if (initrd_high)
 				*initrd_start = (ulong)lmb_alloc_base(lmb,
 						rd_len, 0x1000, initrd_high);
@@ -1329,10 +1263,8 @@ int boot_get_fpga(int argc, char * const argv[], bootm_headers_t *images,
 
 	/*
 	 * Obtain the os FIT header from the images struct
-	 * copy from dataflash if needed
 	 */
 	tmp_img_addr = map_to_sysmem(images->fit_hdr_os);
-	tmp_img_addr = genimg_get_image(tmp_img_addr);
 	buf = map_sysmem(tmp_img_addr, 0);
 	/*
 	 * Check image type. For FIT images get FIT node
@@ -1441,10 +1373,8 @@ int boot_get_loadable(int argc, char * const argv[], bootm_headers_t *images,
 
 	/*
 	 * Obtain the os FIT header from the images struct
-	 * copy from dataflash if needed
 	 */
 	tmp_img_addr = map_to_sysmem(images->fit_hdr_os);
-	tmp_img_addr = genimg_get_image(tmp_img_addr);
 	buf = map_sysmem(tmp_img_addr, 0);
 	/*
 	 * Check image type. For FIT images get FIT node
diff --git a/common/init/board_init.c b/common/init/board_init.c
index 4a391beba9..3d83bbf8aa 100644
--- a/common/init/board_init.c
+++ b/common/init/board_init.c
@@ -129,6 +129,19 @@ void board_init_f_init_reserve(ulong base)
 #endif
 }
 
+/*
+ * Board-specific Platform code can init boot flags if needed
+ */
+__weak int board_init_f_boot_flags(void)
+{
+	gd->baudrate = CONFIG_BAUDRATE;
+	gd->serial.baudrate = CONFIG_BAUDRATE;
+	gd->serial.addr = CONFIG_DEBUG_UART_BASE;
+	gd->serial.using_pre_serial = 0;
+
+	return 0;
+}
+
 /*
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
diff --git a/common/iotrace.c b/common/iotrace.c
index 2725563e8f..b9b035c01d 100644
--- a/common/iotrace.c
+++ b/common/iotrace.c
@@ -89,16 +89,20 @@ u32 iotrace_readl(const void *ptr)
 {
 	u32 v;
 
+	printf("[iotrace]: read  addr 0x%08lx... ", (ulong)ptr);
 	v = readl(ptr);
 	add_record(IOT_32 | IOT_READ, ptr, v);
+	printf("OK\n");
 
 	return v;
 }
 
 void iotrace_writel(ulong value, const void *ptr)
 {
+	printf("[iotrace]: write addr 0x%08lx value 0x%08lx... ", (ulong)ptr, value);
 	add_record(IOT_32 | IOT_WRITE, ptr, value);
 	writel(value, ptr);
+	printf("OK\n");
 }
 
 u16 iotrace_readw(const void *ptr)
diff --git a/common/lcd_simplefb.c b/common/lcd_simplefb.c
index d7e9fc9f65..81f3f42191 100644
--- a/common/lcd_simplefb.c
+++ b/common/lcd_simplefb.c
@@ -11,7 +11,7 @@
 #include <dm.h>
 #include <lcd.h>
 #include <fdt_support.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <video.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/common/malloc_simple.c b/common/malloc_simple.c
index 611400265b..7b4bbaed49 100644
--- a/common/malloc_simple.c
+++ b/common/malloc_simple.c
@@ -40,7 +40,7 @@ void *memalign_simple(size_t align, size_t bytes)
 	addr = ALIGN(gd->malloc_base + gd->malloc_ptr, align);
 	new_ptr = addr + bytes - gd->malloc_base;
 	if (new_ptr > gd->malloc_limit) {
-		debug("space exhausted\n");
+		printf("sys malloc pool space exhausted\n");
 		return NULL;
 	}
 
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index b05ec21ed6..49596a4460 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -18,6 +18,18 @@ config SPL
 
 if SPL
 
+config SPL_ADC_SUPPORT
+	bool "Support ADC driver in SPL"
+	depends on SPL
+	help
+	  The adc drive can be used to measure voltage in spl if need.
+
+config SPL_DECOMP_HEADER
+        bool "Support SPL DECOMP header"
+        default n
+        help
+          Support to build SPL as decomp header.
+
 config SPL_LDSCRIPT
 	string "Linker script for the SPL stage"
 	default "arch/$(ARCH)/cpu/u-boot-spl.lds"
@@ -125,6 +137,19 @@ config SPL_DISPLAY_PRINT
 	  banner ("U-Boot SPL ..."). This function should be provided by
 	  the board.
 
+config SPL_SKIP_RELOCATE
+	bool "Skip code relocation in SPL"
+	default y
+	help
+	  The SPL code will be relocated to a high memory if you say no here.
+	  Only ARM64 and PowerPC SPL support relocate now.
+
+config SPL_RELOC_TEXT_BASE
+	hex "Address the SPL relocate to"
+	depends on !SPL_SKIP_RELOCATE
+	help
+	  The address on the ram where the SPL relocate to.
+
 config SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR
 	bool "MMC raw mode: by sector"
 	default y if ARCH_SUNXI || ARCH_DAVINCI || ARCH_UNIPHIER ||ARCH_MX6 || \
@@ -141,17 +166,19 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR
 	default 0x50 if ARCH_SUNXI
 	default 0x75 if ARCH_DAVINCI
 	default 0x8a if ARCH_MX6
-	default 0x100 if ARCH_ROCKCHIP || ARCH_UNIPHIER
+	default 0x100 if ARCH_UNIPHIER
 	default 0x140 if ARCH_MVEBU
 	default 0x200 if ARCH_SOCFPGA || ARCH_AT91
 	default 0x300 if ARCH_ZYNQ || ARCH_KEYSTONE || OMAP34XX || OMAP44XX || \
 		         OMAP54XX || AM33XX || AM43XX
+	default 0x4000 if ARCH_ROCKCHIP
 	help
 	  Address on the MMC to load U-Boot from, when the MMC is being used
 	  in raw mode. Units: MMC sectors (1 sector = 512 bytes).
 
 config SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
 	bool "MMC Raw mode: by partition"
+	depends on SPL_LIBDISK_SUPPORT
 	help
 	  Use a partition for loading U-Boot when using MMC/SD in raw mode.
 
@@ -171,6 +198,14 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION_TYPE
 	  raw mode. U-Boot will be loaded from the first partition of this
 	  type to be found.
 
+config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_NAME
+	string "Partition Name on the MMC to load U-Boot from"
+	depends on SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
+	default "uboot"
+	help
+          Partition Name on the MMC to load U-Boot from, when the MMC is being
+          used in raw mode.
+
 config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_TYPE
 	hex "Partition Type on the MMC to load U-Boot from"
 	depends on SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION_TYPE
@@ -178,6 +213,11 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_TYPE
 	  Partition Type on the MMC to load U-Boot from, when the MMC is being
 	  used in raw mode.
 
+config SPL_MISC_SECTOR
+	hex "Sector address to load misc in SPL"
+	depends on !SPL_LIBDISK_SUPPORT && SPL_KERNEL_BOOT
+	default 0x8000
+
 config SPL_CRC32_SUPPORT
 	bool "Support CRC32"
 	depends on SPL_FIT
@@ -226,6 +266,22 @@ config SPL_SHA256_SUPPORT
 	  SHA256 variant is supported: SHA512 and others are not currently
 	  supported in U-Boot.
 
+config SPL_FIT_IMAGE_TINY
+	bool "Remove functionality from SPL FIT loading to reduce size"
+	depends on SPL_FIT
+	default y if MACH_SUN50I || MACH_SUN50I_H5
+	default y if ARCH_OMAP2PLUS
+	help
+	  Enable this to reduce the size of the FIT image loading code
+	  in SPL, if space for the SPL binary is very tight.
+
+	  This removes the detection of image types (which forces the
+	  first image to be treated as having a U-Boot style calling
+	  convention) and skips the recording of each loaded payload
+	  (i.e. loadable) into the FDT (modifying the loaded FDT to
+	  ensure this information is available to the next image
+	  invoked).
+
 config SPL_CPU_SUPPORT
 	bool "Support CPU drivers"
 	help
@@ -284,6 +340,7 @@ config SPL_ENV_SUPPORT
 config SPL_SAVEENV
 	bool "Support save environment"
 	depends on SPL_ENV_SUPPORT
+	select SPL_MMC_WRITE if ENV_IS_IN_MMC
 	help
 	  Enable save environment support in SPL after setenv. By default
 	  the saveenv option is not provided in SPL, but some boards need
@@ -398,6 +455,14 @@ config SPL_MMC_SUPPORT
 	  this option to build the drivers in drivers/mmc as part of an SPL
 	  build.
 
+config SPL_MMC_WRITE
+	bool "MMC/SD/SDIO card support for write operations in SPL"
+	depends on SPL_MMC_SUPPORT
+	default n
+	help
+	  Enable write access to MMC and SD Cards in SPL
+
+
 config SPL_MPC8XXX_INIT_DDR_SUPPORT
 	bool "Support MPC8XXX DDR init"
 	help
@@ -415,6 +480,21 @@ config SPL_MTD_SUPPORT
 	  devices. See SPL_NAND_SUPPORT and SPL_ONENAND_SUPPORT for how
 	  to enable specific MTD drivers.
 
+config MTD_BLK_U_BOOT_OFFS
+	hex "Location in MTD block to read U-Boot from"
+	default 0x4000
+	depends on SPL_MTD_SUPPORT
+	help
+	  Set the offset from the start of the nand,spi nand and nor flash where
+	  u-boot should be loaded from.
+
+config SPL_MTD_WRITE
+	bool "nand & spi nand & spi nor support for write operations in SPL"
+	depends on SPL_MTD_SUPPORT
+	default n
+	help
+	  Enable write access to nand & spi nand & spi nor in SPL
+
 config SPL_MUSB_NEW_SUPPORT
 	bool "Support new Mentor Graphics USB"
 	help
@@ -428,7 +508,7 @@ config SPL_NAND_SUPPORT
 	help
 	  Enable support for NAND (Negative AND) flash in SPL. NAND flash
 	  can be used to allow SPL to load U-Boot from supported devices.
-	  This enables the drivers in drivers/mtd/nand as part of an SPL
+	  This enables the drivers in drivers/mtd/nand/raw as part of an SPL
 	  build.
 
 config SPL_NET_SUPPORT
@@ -539,6 +619,13 @@ config SPL_POWER_SUPPORT
 	  in drivers/power, drivers/power/pmic and drivers/power/regulator
 	  as part of an SPL build.
 
+config SPL_PWM_SUPPORT
+	bool "Support PWM driver"
+	depends on SPL
+	help
+	  Enable support for pwm in SPL. This allows use pwm to control
+	  somethings, for example control voltage.
+
 config SPL_RAM_SUPPORT
 	bool "Support booting from RAM"
 	default y if MICROBLAZE || ARCH_SOCFPGA || TEGRA || ARCH_ZYNQ
@@ -593,6 +680,50 @@ config SPL_SPI_FLASH_SUPPORT
 	  lines). This enables the drivers in drivers/mtd/spi as part of an
 	  SPL build. This normally requires SPL_SPI_SUPPORT.
 
+config SPL_RKNAND_SUPPORT
+	bool "Rockchip NAND FLASH device support"
+	depends on BLK
+	select RKNAND
+	select ZFTL if (ROCKCHIP_PX30 || ROCKCHIP_RK3568)
+	help
+	  This option enables support for Rockchip NAND FLASH devices.
+	  It supports block interface(with rk ftl) to read and write NAND FLASH.
+
+config RKNAND_BLK_U_BOOT_OFFS
+	hex "Location in RKNAND block to read U-Boot from"
+	default 0x4000
+	depends on SPL_RKNAND_SUPPORT
+	help
+	  Set the offset from the start of the rknand device where
+	  u-boot should be loaded from.
+
+if SPL_SPI_FLASH_SUPPORT
+
+config SPL_SPI_FLASH_TINY
+	bool "Enable low footprint SPL SPI Flash support"
+	depends on !SPI_FLASH_BAR
+	help
+	 Enable lightweight SPL SPI Flash support that supports just reading
+	 data/images from flash. No support to write/erase flash. Enable
+	 this if you have SPL size limitations and don't need full
+	 fledged SPI flash support.
+
+config SPL_SPI_FLASH_SFDP_SUPPORT
+	bool "SFDP table parsing support for SPI NOR flashes"
+	depends on !SPI_FLASH_BAR && !SPL_SPI_FLASH_TINY
+	help
+	 Enable support for parsing and auto discovery of parameters for
+	 SPI NOR flashes using Serial Flash Discoverable Parameters (SFDP)
+	 tables as per JESD216 standard in SPL.
+
+config SPL_SPI_LOAD
+	bool "Support loading from SPI flash"
+	help
+	  Enable support for loading next stage, U-Boot or otherwise, from
+	  SPI NOR in U-Boot SPL.
+
+endif # SPL_SPI_FLASH_SUPPORT
+
 config SPL_SPI_SUPPORT
 	bool "Support SPI drivers"
 	help
@@ -623,13 +754,13 @@ config SPL_USB_SUPPORT
 	  config options. This enables loading from USB using a configured
 	  device.
 
-config SPL_USB_GADGET_SUPPORT
+config SPL_USB_GADGET
 	bool "Suppport USB Gadget drivers"
 	help
 	  Enable USB Gadget API which allows to enable USB device functions
 	  in SPL.
 
-if SPL_USB_GADGET_SUPPORT
+if SPL_USB_GADGET
 
 config SPL_USBETH_SUPPORT
 	bool "Support USB Ethernet drivers"
@@ -641,8 +772,8 @@ config SPL_USBETH_SUPPORT
 	  since the network stack uses a number of environment variables.
 	  See also SPL_NET_SUPPORT and SPL_ETH_SUPPORT.
 
-config SPL_DFU_SUPPORT
-	bool "Support DFU (Device Firmware Upgarde)"
+config SPL_DFU
+	bool "Support DFU (Device Firmware Upgrade)"
 	select SPL_HASH_SUPPORT
 	select SPL_DFU_NO_RESET
 	depends on SPL_RAM_SUPPORT
@@ -656,11 +787,11 @@ config SPL_DFU_SUPPORT
 
 choice
 	bool "DFU device selection"
-	depends on SPL_DFU_SUPPORT
+	depends on SPL_DFU
 
 config SPL_DFU_RAM
 	bool "RAM device"
-	depends on SPL_DFU_SUPPORT && SPL_RAM_SUPPORT
+	depends on SPL_DFU && SPL_RAM_SUPPORT
 	help
 	 select RAM/DDR memory device for loading binary images
 	 (u-boot/kernel) to the selected device partition using
@@ -692,19 +823,138 @@ config SPL_YMODEM_SUPPORT
 	  means of transmitting U-Boot over a serial line for using in SPL,
 	  with a checksum to ensure correctness.
 
-config SPL_ATF_SUPPORT
+config SPL_ATF
 	bool "Support ARM Trusted Firmware"
 	depends on ARM64
 	help
-	  ATF(ARM Trusted Firmware) is a component for ARM arch64 which
-	  is loaded by SPL(which is considered as BL2 in ATF terminology).
+	  ATF(ARM Trusted Firmware) is a component for ARM AArch64 which
+	  is loaded by SPL (which is considered as BL2 in ATF terminology).
 	  More detail at: https://github.com/ARM-software/arm-trusted-firmware
 
-config SPL_ATF_TEXT_BASE
-	depends on SPL_ATF_SUPPORT
-	hex "ATF BL31 base address"
+config SPL_OPTEE_SUPPORT
+	bool "Support OP-TEE Trusted OS"
+	depends on ARM
+	help
+	  OP-TEE is an open source Trusted OS  which is loaded by SPL.
+	  More detail at: https://github.com/OP-TEE/optee_os
+
+config SPL_ATF_NO_PLATFORM_PARAM
+        bool "Pass no platform parameter"
+	depends on SPL_ATF
+	help
+	  While we expect to call a pointer to a valid FDT (or NULL)
+	  as the platform parameter to an ATF, some ATF versions are
+	  not U-Boot aware and have an insufficiently robust parameter
+	  validation to gracefully reject a FDT being passed.
+
+	  If this option is enabled, the spl_atf os-type handler will
+	  always pass NULL for the platform parameter.
+
+	  If your ATF is affected, say Y.
+
+config SPL_OPTEE
+	bool "Support OP-TEE Trusted OS"
+	depends on ARM
 	help
-	  This is the base address in memory for ATF BL31 text and entry point.
+	  OP-TEE is an open source Trusted OS  which is loaded by SPL.
+	  More detail at: https://github.com/OP-TEE/optee_os
+
+config SPL_AB
+	bool "Support AB system boot"
+	depends on SPL && SPL_EFI_PARTITION
+	help
+	  Enable this config to support AB system boot.
+
+config SPL_LOAD_RKFW
+	bool "SPL support load rockchip firmware images"
+	depends on SPL
+	help
+	  This enables SPL support load rockchip firmware images.
+	  Please define both RKFW_TRUST_SECTOR and RKFW_U_BOOT_SECTOR
+	  for trust and U-Boot images.
+
+config RKFW_TRUST_SECTOR
+	hex "rockchip trust image load sector"
+	depends on SPL_LOAD_RKFW
+	default 0x6000
+
+config RKFW_U_BOOT_SECTOR
+	hex "rockchip uboot image load sector"
+	depends on SPL_LOAD_RKFW
+	default 0x4000
+
+config RKFW_BOOT_SECTOR
+        hex "rockchip boot image load sector"
+        depends on SPL_LOAD_RKFW
+        default 0xa000
+
+config SPL_KERNEL_BOOT
+	bool "Enable boot kernel in SPL"
+	depends on SPL
+	help
+	  Enable boot kernel in SPL.
+
+config SPL_KERNEL_BOOT_SECTOR
+	hex "Sector address to load kernel in SPL"
+	depends on SPL_KERNEL_BOOT
+	depends on !SPL_LIBDISK_SUPPORT
+	default 0xa000
+
+if SPL_LOAD_RKFW
+config SPL_KERNEL_ADDR
+	hex "Kernel load address in spl"
+	depends on SPL
+	default 0x280000
+	help
+	  Define the kernel address where load kernel image to.
+	  This is used to boot kernel in spl.
+
+config SPL_KERNEL_COMPRESS_ADDR
+	hex "The compressed kernel in spl"
+	depends on SPL && SPL_ROCKCHIP_HW_DECOMPRESS
+	help
+	  Load compressed kernel in this address, then call the
+	  decompress process to decompress the firmware.
+
+config SPL_KERNEL_DECOM_LIMIT_SIZE
+        hex "The decompress limit size"
+        depends on SPL && SPL_ROCKCHIP_HW_DECOMPRESS
+	default 0x1ff8000
+        help
+          Define kernel maximum decompressible size that prevent
+          memory overrun.
+
+config SPL_FDT_ADDR
+	hex "Device tree blob load address in spl"
+	depends on SPL
+	default 0x01f00000
+	help
+	  Define the fdt address where load dtb image to.
+	  This is used to boot kernel in spl.
+
+config SPL_RAMDISK_ADDR
+	hex "Ramdisk load address in spl"
+	depends on SPL
+	default 0x0a200000
+	help
+	  Define the ramdisk address where load ramdisk image to.
+	  This is used to boot kernel in spl.
+
+config SPL_RAMDISK_COMPRESS_ADDR
+	hex "The compressed ramdisk in spl"
+	depends on SPL && SPL_ROCKCHIP_HW_DECOMPRESS
+	help
+	  Load compressed ramdisk in this address, then call the
+	  decompress process to decompress the firmware.
+
+config SPL_RAMDISK_DECOM_LIMIT_SIZE
+	hex "The decompress limit size"
+	depends on SPL && SPL_ROCKCHIP_HW_DECOMPRESS
+	default 0x3000000
+	help
+	  Define ramdisk maximum decompressible size that prevent
+	  memory overrun.
+endif
 
 config TPL
 	bool
@@ -715,6 +965,13 @@ config TPL
 
 if TPL
 
+config TPL_BOARD_INIT
+	bool "Call board-specific initialization in TPL"
+	help
+	  If this option is enabled, U-Boot will call the function
+	  spl_board_init() from board_init_r(). This function should be
+	  provided by the board.
+
 config TPL_LDSCRIPT
         string "Linker script for the TPL stage"
 	depends on TPL
@@ -806,6 +1063,11 @@ config TPL_LIBGENERIC_SUPPORT
 	  Enable support for generic U-Boot libraries within TPL. See
 	  SPL_LIBGENERIC_SUPPORT for details.
 
+config TPL_TINY_FRAMEWORK
+	bool "Support not to use spl framework in TPL"
+	help
+	  Enable support for not using spl framework in TPL, to reduce the TPL size.
+
 config TPL_MPC8XXX_INIT_DDR_SUPPORT
 	bool "Support MPC8XXX DDR init"
 	help
diff --git a/common/spl/Makefile b/common/spl/Makefile
index e229947b53..3bab93f6c3 100644
--- a/common/spl/Makefile
+++ b/common/spl/Makefile
@@ -8,10 +8,31 @@
 # Based on common/Makefile.
 #
 
+ifeq ($(CONFIG_TPL_BUILD), y)
+ifndef CONFIG_TPL_TINY_FRAMEWORK
+obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
+endif
+else
 ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_DECOMP_HEADER
+obj-y += spl_decomp.o
+else
 obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
+endif
+endif
+endif
+
+ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_$(SPL_TPL_)BOOTROM_SUPPORT) += spl_bootrom.o
+ifdef CONFIG_SPL_KERNEL_BOOT
+ifdef CONFIG_ARM64
+obj-$(CONFIG_$(SPL_TPL_)LOAD_FIT) += spl_fit_tb_arm64.o
+else
+obj-$(CONFIG_$(SPL_TPL_)LOAD_FIT) += spl_fit_tb_arm32.o
+endif
+else
 obj-$(CONFIG_$(SPL_TPL_)LOAD_FIT) += spl_fit.o
+endif
 obj-$(CONFIG_$(SPL_TPL_)NOR_SUPPORT) += spl_nor.o
 obj-$(CONFIG_$(SPL_TPL_)XIP_SUPPORT) += spl_xip.o
 obj-$(CONFIG_$(SPL_TPL_)YMODEM_SUPPORT) += spl_ymodem.o
@@ -22,12 +43,17 @@ endif
 obj-$(CONFIG_$(SPL_TPL_)UBI) += spl_ubi.o
 obj-$(CONFIG_$(SPL_TPL_)NET_SUPPORT) += spl_net.o
 obj-$(CONFIG_$(SPL_TPL_)MMC_SUPPORT) += spl_mmc.o
-obj-$(CONFIG_$(SPL_TPL_)ATF_SUPPORT) += spl_atf.o
+obj-$(CONFIG_$(SPL_TPL_)MTD_SUPPORT) += spl_mtd_blk.o
+obj-$(CONFIG_$(SPL_TPL_)RKNAND_SUPPORT) += spl_rknand.o
+obj-$(CONFIG_$(SPL_TPL_)ATF) += spl_atf.o
+obj-$(CONFIG_$(SPL_TPL_)OPTEE) += spl_optee.o
+obj-$(CONFIG_$(SPL_TPL_)LOAD_RKFW) += spl_rkfw.o
+obj-$(CONFIG_$(SPL_TPL_)AB) += spl_ab.o
 obj-$(CONFIG_$(SPL_TPL_)USB_SUPPORT) += spl_usb.o
 obj-$(CONFIG_$(SPL_TPL_)FAT_SUPPORT) += spl_fat.o
 obj-$(CONFIG_$(SPL_TPL_)EXT_SUPPORT) += spl_ext.o
 obj-$(CONFIG_$(SPL_TPL_)SATA_SUPPORT) += spl_sata.o
-obj-$(CONFIG_$(SPL_TPL_)DFU_SUPPORT) += spl_dfu.o
+obj-$(CONFIG_$(SPL_TPL_)DFU) += spl_dfu.o
 obj-$(CONFIG_$(SPL_TPL_)SPI_LOAD) += spl_spi.o
 obj-$(CONFIG_$(SPL_TPL_)RAM_SUPPORT) += spl_ram.o
 obj-$(CONFIG_$(SPL_TPL_)USB_SDP_SUPPORT) += spl_sdp.o
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 8b219ba690..6836796b4e 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -10,6 +10,7 @@
 #include <common.h>
 #include <dm.h>
 #include <spl.h>
+#include <asm/sections.h>
 #include <asm/u-boot.h>
 #include <nand.h>
 #include <fat.h>
@@ -76,6 +77,29 @@ int __weak bootz_setup(ulong image, ulong *start, ulong *end)
 }
 #endif
 
+/* Weak default function for arch/board-specific fixups to the spl_image_info */
+void __weak spl_perform_fixups(struct spl_image_info *spl_image)
+{
+}
+
+/* Get the next stage process */
+__weak void spl_next_stage(struct spl_image_info *spl)
+{
+	spl->next_stage = SPL_NEXT_STAGE_UBOOT;
+}
+
+/* Weak default function for arch/board-specific preppare before jumping */
+int __weak spl_board_prepare_for_jump(struct spl_image_info *spl_image)
+{
+	return 0;
+}
+
+/* Fix storages, like iomux  */
+__weak void spl_board_storages_fixup(struct spl_image_loader *loader)
+{
+	/* Nothing to do! */
+}
+
 void spl_fixup_fdt(void)
 {
 #if defined(CONFIG_SPL_OF_LIBFDT) && defined(CONFIG_SYS_SPL_ARGS_ADDR)
@@ -154,11 +178,11 @@ int spl_parse_image_header(struct spl_image_info *spl_image,
 		spl_image->os = image_get_os(header);
 		spl_image->name = image_get_name(header);
 		debug("spl: payload image: %.*s load addr: 0x%lx size: %d\n",
-			(int)sizeof(spl_image->name), spl_image->name,
+			IH_NMLEN, spl_image->name,
 			spl_image->load_addr, spl_image->size);
 #else
 		/* LEGACY image not supported */
-		debug("Legacy boot image support not enabled, proceeding to other boot methods");
+		debug("Legacy boot image support not enabled, proceeding to other boot methods\n");
 		return -EINVAL;
 #endif
 	} else {
@@ -196,7 +220,7 @@ int spl_parse_image_header(struct spl_image_info *spl_image,
 		spl_set_header_raw_uboot(spl_image);
 #else
 		/* RAW image not supported, proceed to other boot methods. */
-		debug("Raw boot image support not enabled, proceeding to other boot methods");
+		debug("Raw boot image support not enabled, proceeding to other boot methods\n");
 		return -EINVAL;
 #endif
 	}
@@ -215,6 +239,45 @@ __weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 	image_entry();
 }
 
+/*
+ * 64-bit: No special operation.
+ *
+ * 32-bit: Initial gd->bd->bi_dram[] to active dcache attr of memory.
+ *	   Assuming 256MB is enough for SPL(MMU still maps 4GB size).
+ */
+#ifndef CONFIG_SPL_SYS_DCACHE_OFF
+static int spl_dcache_enable(void)
+{
+	bool free_bd = false;
+
+#ifndef CONFIG_ARM64
+	if (!gd->bd) {
+		gd->bd = calloc(1, sizeof(bd_t));
+		if (!gd->bd) {
+			debug("spl: no bd_t memory\n");
+			return -ENOMEM;
+		}
+		gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+		gd->bd->bi_dram[0].size  = SZ_256M;
+		free_bd = true;
+	}
+#endif
+	/* TLB memory should be SZ_16K base align and 4KB end align */
+	gd->arch.tlb_size = PGTABLE_SIZE;
+	gd->arch.tlb_addr = (ulong)memalign(SZ_16K, ALIGN(PGTABLE_SIZE, SZ_4K));
+	if (!gd->arch.tlb_addr) {
+		debug("spl: no TLB memory\n");
+		return -ENOMEM;
+	}
+
+	dcache_enable();
+	if (free_bd)
+		free(gd->bd);
+
+	return 0;
+}
+#endif
+
 static int spl_common_init(bool setup_malloc)
 {
 	int ret;
@@ -230,6 +293,18 @@ static int spl_common_init(bool setup_malloc)
 		gd->malloc_ptr = 0;
 	}
 #endif
+
+	/*
+	 * setup D-cache as early as possible after malloc setup
+	 * I-cache has been setup at early assembly code by default.
+	 */
+#ifndef CONFIG_SPL_SYS_DCACHE_OFF
+	ret = spl_dcache_enable();
+	if (ret) {
+		debug("spl_dcache_enable() return error %d\n", ret);
+		return ret;
+	}
+#endif
 	ret = bootstage_init(true);
 	if (ret) {
 		debug("%s: Failed to set up bootstage: ret=%d\n", __func__,
@@ -258,6 +333,34 @@ static int spl_common_init(bool setup_malloc)
 	return 0;
 }
 
+#if !defined(CONFIG_SPL_SKIP_RELOCATE) && !defined(CONFIG_TPL_BUILD)
+static void spl_setup_relocate(void)
+{
+	gd->relocaddr = CONFIG_SPL_RELOC_TEXT_BASE;
+	gd->new_gd = (gd_t *)gd;
+	gd->start_addr_sp = gd->relocaddr;
+	gd->fdt_size = ALIGN(fdt_totalsize(gd->fdt_blob) + 0x1000, 32);
+
+	gd->start_addr_sp -= gd->fdt_size;
+	gd->new_fdt = (void *)gd->start_addr_sp;
+	memcpy(gd->new_fdt, gd->fdt_blob, gd->fdt_size);
+	gd->fdt_blob = gd->new_fdt;
+
+	gd->reloc_off = gd->relocaddr - (unsigned long)__image_copy_start;
+}
+#else
+static void spl_setup_relocate(void)
+{
+
+}
+#endif
+
+void spl_set_bd(void)
+{
+	if (!gd->bd)
+		gd->bd = &bdata;
+}
+
 int spl_early_init(void)
 {
 	int ret;
@@ -267,6 +370,8 @@ int spl_early_init(void)
 		return ret;
 	gd->flags |= GD_FLG_SPL_EARLY_INIT;
 
+	spl_setup_relocate();
+
 	return 0;
 }
 
@@ -346,13 +451,58 @@ static int boot_from_devices(struct spl_image_info *spl_image,
 		else
 			puts("SPL: Unsupported Boot Device!\n");
 #endif
-		if (loader && !spl_load_image(spl_image, loader))
+		if (loader && !spl_load_image(spl_image, loader)) {
+			spl_image->boot_device = spl_boot_list[i];
 			return 0;
+		}
+
+		spl_board_storages_fixup(loader);
 	}
 
 	return -ENODEV;
 }
 
+#if defined(CONFIG_DM) && !defined(CONFIG_SPL_SKIP_RELOCATE) && !defined(CONFIG_TPL_BUILD)
+static int spl_initr_dm(void)
+{
+	int ret;
+
+	/* Save the pre-reloc driver model and start a new one */
+	gd->dm_root_f = gd->dm_root;
+	gd->dm_root = NULL;
+	bootstage_start(BOOTSTATE_ID_ACCUM_DM_R, "dm_r");
+	ret = dm_init_and_scan(false);
+	bootstage_accum(BOOTSTATE_ID_ACCUM_DM_R);
+	if (ret)
+		return ret;
+
+#if defined(CONFIG_TIMER)
+	gd->timer = NULL;
+#endif
+	serial_init();
+
+	return 0;
+}
+#else
+static int spl_initr_dm(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_SPL_KERNEL_BOOT) && !defined(CONFIG_ARM64)
+static void boot_jump_linux(struct spl_image_info *spl_image)
+{
+	void (*kernel_entry)(int zero, int arch, ulong params);
+
+	printf("Jumping to %s(0x%08lx)\n", "Kernel",
+	       (ulong)spl_image->entry_point_os);
+	spl_cleanup_before_jump(spl_image);
+	kernel_entry = (void (*)(int, int, ulong))spl_image->entry_point_os;
+	kernel_entry(0, 0, (ulong)spl_image->fdt_addr);
+}
+#endif
+
 void board_init_r(gd_t *dummy1, ulong dummy2)
 {
 	u32 spl_boot_list[] = {
@@ -365,7 +515,11 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	struct spl_image_info spl_image;
 
 	debug(">>spl:board_init_r()\n");
-	gd->bd = &bdata;
+
+	spl_initr_dm();
+
+	spl_set_bd();
+
 #ifdef CONFIG_SPL_OS_BOOT
 	dram_init_banksize();
 #endif
@@ -387,36 +541,81 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	timer_init();
 #endif
 
-#ifdef CONFIG_SPL_BOARD_INIT
+#if CONFIG_IS_ENABLED(BOARD_INIT)
 	spl_board_init();
 #endif
 
 	memset(&spl_image, '\0', sizeof(spl_image));
+
+#if CONFIG_IS_ENABLED(ATF)
+	/*
+	 * Bl32 ep is optional, initial it as an invalid value.
+	 * BL33 ep is mandatory, but initial it as a default value is better.
+	 */
+	spl_image.entry_point_bl32 = -1;
+	spl_image.entry_point_bl33 = CONFIG_SYS_TEXT_BASE;
+#endif
+
+#if CONFIG_IS_ENABLED(OPTEE)
+	/* default address */
+	spl_image.entry_point_os = CONFIG_SYS_TEXT_BASE;
+#endif
+
 #ifdef CONFIG_SYS_SPL_ARGS_ADDR
 	spl_image.arg = (void *)CONFIG_SYS_SPL_ARGS_ADDR;
 #endif
+	spl_image.boot_device = BOOT_DEVICE_NONE;
 	board_boot_order(spl_boot_list);
-
+	spl_next_stage(&spl_image);
 	if (boot_from_devices(&spl_image, spl_boot_list,
 			      ARRAY_SIZE(spl_boot_list))) {
 		puts("SPL: failed to boot from all boot devices\n");
 		hang();
 	}
 
+	spl_perform_fixups(&spl_image);
+
 #ifdef CONFIG_CPU_V7M
 	spl_image.entry_point |= 0x1;
 #endif
 	switch (spl_image.os) {
 	case IH_OS_U_BOOT:
 		debug("Jumping to U-Boot\n");
+		spl_cleanup_before_jump(&spl_image);
 		break;
-#ifdef CONFIG_SPL_OS_BOOT
+#if CONFIG_IS_ENABLED(ATF)
+	case IH_OS_ARM_TRUSTED_FIRMWARE:
+		printf("Jumping to %s(0x%08lx) via ARM Trusted Firmware(0x%08lx)\n",
+		       spl_image.next_stage == SPL_NEXT_STAGE_UBOOT ? "U-Boot" :
+		       (spl_image.next_stage == SPL_NEXT_STAGE_KERNEL ? "Kernel" : "Unknown"),
+		       (ulong)spl_image.entry_point_bl33,
+		       (ulong)spl_image.entry_point);
+		spl_invoke_atf(&spl_image);
+		break;
+#endif
+#if CONFIG_IS_ENABLED(OPTEE)
+	case IH_OS_OP_TEE:
+		printf("Jumping to %s(0x%08lx) via OP-TEE(0x%08lx)\n",
+		       spl_image.next_stage == SPL_NEXT_STAGE_UBOOT ? "U-Boot" :
+		       (spl_image.next_stage == SPL_NEXT_STAGE_KERNEL ? "Kernel" : "Unknown"),
+		       (ulong)spl_image.entry_point_os,
+		       (ulong)spl_image.entry_point);
+		spl_cleanup_before_jump(&spl_image);
+		spl_optee_entry(NULL, (void *)spl_image.entry_point_os,
+				(void *)spl_image.fdt_addr,
+				(void *)spl_image.entry_point);
+		break;
+#endif
 	case IH_OS_LINUX:
+#ifdef CONFIG_SPL_OS_BOOT
 		debug("Jumping to Linux\n");
 		spl_fixup_fdt();
 		spl_board_prepare_for_linux();
 		jump_to_image_linux(&spl_image);
+#elif defined(CONFIG_SPL_KERNEL_BOOT) && !defined(CONFIG_ARM64)
+		boot_jump_linux(&spl_image);
 #endif
+		break;
 	default:
 		debug("Unsupported OS image.. Jumping nevertheless..\n");
 	}
@@ -425,11 +624,6 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	      gd->malloc_ptr / 1024);
 #endif
 
-	if (CONFIG_IS_ENABLED(ATF_SUPPORT)) {
-		debug("loaded - jumping to U-Boot via ATF BL31.\n");
-		bl31_entry();
-	}
-
 	debug("loaded - jumping to U-Boot...\n");
 #ifdef CONFIG_BOOTSTAGE_STASH
 	int ret;
@@ -440,6 +634,8 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	if (ret)
 		debug("Failed to stash bootstage: err=%d\n", ret);
 #endif
+
+	printf("Jumping to U-Boot(0x%08lx)\n", spl_image.entry_point);
 	spl_board_prepare_for_boot();
 	jump_to_image_no_args(&spl_image);
 }
@@ -510,3 +706,37 @@ ulong spl_relocate_stack_gd(void)
 	return 0;
 #endif
 }
+
+/* cleanup before jump to next stage */
+void spl_cleanup_before_jump(struct spl_image_info *spl_image)
+{
+	ulong us;
+
+	spl_board_prepare_for_jump(spl_image);
+
+	disable_interrupts();
+
+#ifdef CONFIG_ARM64
+	disable_serror();
+#else
+	disable_async_abort();
+#endif
+	/*
+	 * Turn off I-cache and invalidate it
+	 */
+	icache_disable();
+	invalidate_icache_all();
+
+	/*
+	 * Turn off D-cache
+	 * dcache_disable() in turn flushes the d-cache and disables MMU
+	 */
+	dcache_disable();
+	invalidate_dcache_all();
+
+	dsb();
+	isb();
+
+	us = (get_ticks() - gd->sys_start_tick) / 24UL;
+	printf("Total: %ld.%ld ms\n\n", us / 1000, us % 1000);
+}
diff --git a/common/spl/spl_atf.c b/common/spl/spl_atf.c
index 6e8f928044..a0b8666cc9 100644
--- a/common/spl/spl_atf.c
+++ b/common/spl/spl_atf.c
@@ -5,6 +5,7 @@
  * reserved.
  * Copyright (C) 2016 Rockchip Electronic Co.,Ltd
  * Written by Kever Yang <kever.yang@rock-chips.com>
+ * Copyright (C) 2017 Theobroma Systems Design und Consulting GmbH
  *
  * SPDX-License-Identifier:     BSD-3-Clause
  */
@@ -30,8 +31,11 @@ static struct bl31_params *bl2_to_bl31_params;
  *
  * @return bl31 params structure pointer
  */
-struct bl31_params *bl2_plat_get_bl31_params(void)
+static struct bl31_params *bl2_plat_get_bl31_params(struct spl_image_info *spl_image,
+						    uintptr_t bl32_entry,
+						    uintptr_t bl33_entry)
 {
+	struct entry_point_info *bl32_ep_info;
 	struct entry_point_info *bl33_ep_info;
 
 	/*
@@ -48,16 +52,24 @@ struct bl31_params *bl2_plat_get_bl31_params(void)
 	SET_PARAM_HEAD(bl2_to_bl31_params->bl31_image_info,
 		       ATF_PARAM_IMAGE_BINARY, ATF_VERSION_1, 0);
 
-	/* Fill BL32 related information if it exists */
-#ifdef BL32_BASE
+	if (bl32_entry == -1)
+		goto bl33_setup;
+
+	/* Fill BL32 related information */
 	bl2_to_bl31_params->bl32_ep_info = &bl31_params_mem.bl32_ep_info;
-	SET_PARAM_HEAD(bl2_to_bl31_params->bl32_ep_info, ATF_PARAM_EP,
-		       ATF_VERSION_1, 0);
+	bl32_ep_info = &bl31_params_mem.bl32_ep_info;
+	SET_PARAM_HEAD(bl32_ep_info, ATF_PARAM_EP, ATF_VERSION_1,
+		       ATF_EP_SECURE);
+
+	bl32_ep_info->pc = bl32_entry;
+	bl32_ep_info->spsr = SPSR_64(MODE_EL1, MODE_SP_ELX,
+				     DISABLE_ALL_EXECPTIONS);
+
 	bl2_to_bl31_params->bl32_image_info = &bl31_params_mem.bl32_image_info;
 	SET_PARAM_HEAD(bl2_to_bl31_params->bl32_image_info,
 		       ATF_PARAM_IMAGE_BINARY, ATF_VERSION_1, 0);
-#endif /* BL32_BASE */
 
+bl33_setup:
 	/* Fill BL33 related information */
 	bl2_to_bl31_params->bl33_ep_info = &bl31_params_mem.bl33_ep_info;
 	bl33_ep_info = &bl31_params_mem.bl33_ep_info;
@@ -66,10 +78,22 @@ struct bl31_params *bl2_plat_get_bl31_params(void)
 
 	/* BL33 expects to receive the primary CPU MPID (through x0) */
 	bl33_ep_info->args.arg0 = 0xffff & read_mpidr();
-	bl33_ep_info->pc = CONFIG_SYS_TEXT_BASE;
+	bl33_ep_info->pc = bl33_entry;
 	bl33_ep_info->spsr = SPSR_64(MODE_EL2, MODE_SP_ELX,
 				     DISABLE_ALL_EXECPTIONS);
 
+	/*
+	 * Reference: arch/arm/lib/bootm.c
+	 * boot_jump_linux(bootm_headers_t *images, int flag)
+	 * {
+	 * 	......
+	 * 	armv8_switch_to_el2((u64)images->ft_addr, 0, 0, 0,
+	 * 			   images->ep, ES_TO_AARCH64);
+	 * }
+	 */
+	if (spl_image->next_stage == SPL_NEXT_STAGE_KERNEL)
+		bl33_ep_info->args.arg0 = (unsigned long)spl_image->fdt_addr;
+
 	bl2_to_bl31_params->bl33_image_info = &bl31_params_mem.bl33_image_info;
 	SET_PARAM_HEAD(bl2_to_bl31_params->bl33_image_info,
 		       ATF_PARAM_IMAGE_BINARY, ATF_VERSION_1, 0);
@@ -77,21 +101,108 @@ struct bl31_params *bl2_plat_get_bl31_params(void)
 	return bl2_to_bl31_params;
 }
 
-void raw_write_daif(unsigned int daif)
+static inline void raw_write_daif(unsigned int daif)
 {
 	__asm__ __volatile__("msr DAIF, %0\n\t" : : "r" (daif) : "memory");
 }
 
-void bl31_entry(void)
+typedef void (*atf_entry_t)(struct bl31_params *params, void *plat_params);
+
+void bl31_entry(struct spl_image_info *spl_image,
+		uintptr_t bl31_entry, uintptr_t bl32_entry,
+		uintptr_t bl33_entry, uintptr_t fdt_addr)
 {
 	struct bl31_params *bl31_params;
-	void (*entry)(struct bl31_params *params, void *plat_params) = NULL;
+	atf_entry_t  atf_entry = (atf_entry_t)bl31_entry;
+
+	bl31_params = bl2_plat_get_bl31_params(spl_image, bl32_entry, bl33_entry);
+
+	atf_entry((void *)bl31_params, (void *)fdt_addr);
+}
+
+static int spl_fit_images_find(void *blob, int os)
+{
+	int parent, node;
+	const void *data;
+
+	if (!blob)
+		return -FDT_ERR_BADMAGIC;
+
+	parent = fdt_path_offset(blob, "/fit-images");
+	if (parent < 0)
+		return -FDT_ERR_NOTFOUND;
+
+	fdt_for_each_subnode(node, blob, parent) {
+		data = fdt_getprop(blob, node, FIT_OS_PROP, NULL);
+		if (!data)
+			continue;
+
+		if (genimg_get_os_id(data) == os)
+			return node;
+	}
+
+	return -FDT_ERR_NOTFOUND;
+}
+
+uintptr_t spl_fit_images_get_entry(void *blob, int node)
+{
+	ulong  val;
+
+	val = fdt_getprop_u32(blob, node, "entry-point");
+	if (val == FDT_ERROR)
+		val = fdt_getprop_u32(blob, node, "load-addr");
+
+	debug("%s: entry point 0x%lx\n", __func__, val);
+	return val;
+}
+
+void spl_invoke_atf(struct spl_image_info *spl_image)
+{
+	uintptr_t bl32_entry, bl33_entry;
+	void *blob = spl_image->fdt_addr;
+	uintptr_t platform_param = (uintptr_t)blob;
+	int node;
+
+	/*
+	 * Find the OP-TEE binary (in /fit-images) load address or
+	 * entry point (if different) and pass it as the BL3-2 entry
+	 * point, this is optional.
+	 * This will need to be extended to support Falcon mode.
+	 */
+	node = spl_fit_images_find(blob, IH_OS_OP_TEE);
+	if (node >= 0)
+		bl32_entry = spl_fit_images_get_entry(blob, node);
+	else
+		bl32_entry = spl_image->entry_point_bl32; /* optional */
 
-	bl31_params = bl2_plat_get_bl31_params();
-	entry = (void *)CONFIG_SPL_ATF_TEXT_BASE;
+	/*
+	 * Find the U-Boot binary (in /fit-images) load addreess or
+	 * entry point (if different) and pass it as the BL3-3 entry
+	 * point.
+	 * This will need to be extended to support Falcon mode.
+	 */
+	node = spl_fit_images_find(blob, IH_OS_U_BOOT);
+	if (node >= 0)
+		bl33_entry = spl_fit_images_get_entry(blob, node);
+	else
+		bl33_entry = spl_image->entry_point_bl33;
 
-	raw_write_daif(SPSR_EXCEPTION_MASK);
-	dcache_disable();
+	/*
+	 * If ATF_NO_PLATFORM_PARAM is set, we override the platform
+	 * parameter and always pass 0.  This is a workaround for
+	 * older ATF versions that have insufficiently robust (or
+	 * overzealous) argument validation.
+	 */
+	if (CONFIG_IS_ENABLED(ATF_NO_PLATFORM_PARAM))
+		platform_param = 0;
+
+	/* do cleanup */
+	spl_cleanup_before_jump(spl_image);
 
-	entry(bl31_params, NULL);
+	/*
+	 * We don't provide a BL3-2 entry yet, but this will be possible
+	 * using similar logic.
+	 */
+	bl31_entry(spl_image, spl_image->entry_point, bl32_entry,
+		   bl33_entry, platform_param);
 }
diff --git a/common/spl/spl_dfu.c b/common/spl/spl_dfu.c
index 2c974735b1..05bb21035d 100644
--- a/common/spl/spl_dfu.c
+++ b/common/spl/spl_dfu.c
@@ -42,13 +42,13 @@ int spl_dfu_cmd(int usbctrl, char *dfu_alt_info, char *interface, char *devstr)
 	set_default_env(0);
 	str_env = env_get(dfu_alt_info);
 	if (!str_env) {
-		error("\"dfu_alt_info\" env variable not defined!\n");
+		pr_err("\"dfu_alt_info\" env variable not defined!\n");
 		return -EINVAL;
 	}
 
 	ret = env_set("dfu_alt_info", str_env);
 	if (ret) {
-		error("unable to set env variable \"dfu_alt_info\"!\n");
+		pr_err("unable to set env variable \"dfu_alt_info\"!\n");
 		return -EINVAL;
 	}
 
diff --git a/common/spl/spl_fat.c b/common/spl/spl_fat.c
index 60b85f082d..10cbdba468 100644
--- a/common/spl/spl_fat.c
+++ b/common/spl/spl_fat.c
@@ -15,7 +15,7 @@
 #include <fat.h>
 #include <errno.h>
 #include <image.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 static int fat_registered;
 
@@ -71,8 +71,14 @@ int spl_load_image_fat(struct spl_image_info *spl_image,
 	if (err <= 0)
 		goto end;
 
+#ifdef CONFIG_SPL_FIT_IMAGE_MULTIPLE
+	if ((IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	     image_get_magic(header) == FDT_MAGIC) ||
+	     CONFIG_SPL_FIT_IMAGE_MULTIPLE > 1) {
+#else
 	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 	    image_get_magic(header) == FDT_MAGIC) {
+#endif
 		struct spl_load_info load;
 
 		debug("Found FIT\n");
diff --git a/common/spl/spl_fit.c b/common/spl/spl_fit.c
index d2a352ecbe..b19e0c6a33 100644
--- a/common/spl/spl_fit.c
+++ b/common/spl/spl_fit.c
@@ -2,32 +2,43 @@
  * Copyright (C) 2016 Google, Inc
  * Written by Simon Glass <sjg@chromium.org>
  *
- * SPDX-License-Identifier:     GPL-2.0+
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
+#include <boot_rkimg.h>
 #include <errno.h>
+#include <fdt_support.h>
 #include <image.h>
-#include <libfdt.h>
+#include <malloc.h>
+#include <mtd_blk.h>
 #include <spl.h>
+#include <spl_ab.h>
+#include <linux/libfdt.h>
+
+#ifndef CONFIG_SYS_BOOTM_LEN
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)
+#endif
 
 /**
- * spl_fit_get_image_node(): By using the matching configuration subnode,
+ * spl_fit_get_image_name(): By using the matching configuration subnode,
  * retrieve the name of an image, specified by a property name and an index
  * into that.
  * @fit:	Pointer to the FDT blob.
  * @images:	Offset of the /images subnode.
  * @type:	Name of the property within the configuration subnode.
  * @index:	Index into the list of strings in this property.
+ * @outname:	Name of the image
  *
- * Return:	the node offset of the respective image node or a negative
- * 		error number.
+ * Return:	0 on success, or a negative error number
  */
-static int spl_fit_get_image_node(const void *fit, int images,
-				  const char *type, int index)
+static int spl_fit_get_image_name(const void *fit, int images,
+				  const char *type, int index,
+				  char **outname)
 {
 	const char *name, *str;
-	int node, conf_node;
+	__maybe_unused int node;
+	int conf_node;
 	int len, i;
 
 	conf_node = fit_find_config_node(fit);
@@ -59,7 +70,35 @@ static int spl_fit_get_image_node(const void *fit, int images,
 		}
 	}
 
+	*outname = (char *)str;
+	return 0;
+}
+
+/**
+ * spl_fit_get_image_node(): By using the matching configuration subnode,
+ * retrieve the name of an image, specified by a property name and an index
+ * into that.
+ * @fit:	Pointer to the FDT blob.
+ * @images:	Offset of the /images subnode.
+ * @type:	Name of the property within the configuration subnode.
+ * @index:	Index into the list of strings in this property.
+ *
+ * Return:	the node offset of the respective image node or a negative
+ *		error number.
+ */
+static int spl_fit_get_image_node(const void *fit, int images,
+				  const char *type, int index)
+{
+	char *str;
+	int err;
+	int node;
+
+	err = spl_fit_get_image_name(fit, images, type, index, &str);
+	if (err)
+		return err;
+
 	debug("%s: '%s'\n", type, str);
+
 	node = fdt_subnode_offset(fit, images, str);
 	if (node < 0) {
 		debug("cannot find image node '%s': %d\n", str, node);
@@ -112,15 +151,15 @@ static int get_aligned_image_size(struct spl_load_info *info, int data_size,
  * @info:	points to information about the device to load data from
  * @sector:	the start sector of the FIT image on the device
  * @fit:	points to the flattened device tree blob describing the FIT
- * 		image
+ *		image
  * @base_offset: the beginning of the data area containing the actual
  *		image data, relative to the beginning of the FIT
  * @node:	offset of the DT node describing the image to load (relative
- * 		to @fit)
+ *		to @fit)
  * @image_info:	will be filled with information about the loaded image
- * 		If the FIT node does not contain a "load" (address) property,
- * 		the image gets loaded to the address pointed to by the
- * 		load_addr member in this struct.
+ *		If the FIT node does not contain a "load" (address) property,
+ *		the image gets loaded to the address pointed to by the
+ *		load_addr member in this struct.
  *
  * Return:	0 on success or a negative error number.
  */
@@ -128,41 +167,124 @@ static int spl_load_fit_image(struct spl_load_info *info, ulong sector,
 			      void *fit, ulong base_offset, int node,
 			      struct spl_image_info *image_info)
 {
-	ulong offset;
+	int offset;
 	size_t length;
-	ulong load_addr, load_ptr;
+	int len;
+	ulong size;
+	ulong comp_addr, load_addr, load_ptr;
 	void *src;
 	ulong overhead;
 	int nr_sectors;
 	int align_len = ARCH_DMA_MINALIGN - 1;
+	uint8_t image_comp = -1, type = -1;
+	const void *data;
+	bool external_data = false;
+
+	if (IS_ENABLED(CONFIG_SPL_OS_BOOT) && IS_ENABLED(CONFIG_SPL_GZIP)) {
+		if (fit_image_get_comp(fit, node, &image_comp))
+			puts("Cannot get image compression format.\n");
+		else
+			debug("%s ", genimg_get_comp_name(image_comp));
+
+		if (fit_image_get_type(fit, node, &type))
+			puts("Cannot get image type.\n");
+		else
+			debug("%s ", genimg_get_type_name(type));
+	} else {
+		fit_image_get_comp(fit, node, &image_comp);
+	}
 
-	offset = fdt_getprop_u32(fit, node, "data-offset");
-	if (offset == FDT_ERROR)
-		return -ENOENT;
-	offset += base_offset;
-	length = fdt_getprop_u32(fit, node, "data-size");
-	if (length == FDT_ERROR)
-		return -ENOENT;
-	load_addr = fdt_getprop_u32(fit, node, "load");
-	if (load_addr == FDT_ERROR && image_info)
+	if (fit_image_get_load(fit, node, &load_addr))
 		load_addr = image_info->load_addr;
-	load_ptr = (load_addr + align_len) & ~align_len;
 
-	overhead = get_aligned_image_overhead(info, offset);
-	nr_sectors = get_aligned_image_size(info, length, offset);
+	if (image_comp != IH_COMP_NONE && image_comp != IH_COMP_ZIMAGE) {
+		/* Empirically, 2MB is enough for U-Boot, tee and atf */
+		if (fit_image_get_comp_addr(fit, node, &comp_addr))
+			comp_addr = load_addr + FIT_MAX_SPL_IMAGE_SZ;
+	} else {
+		comp_addr = load_addr;
+	}
 
-	if (info->read(info, sector + get_aligned_image_offset(info, offset),
-		       nr_sectors, (void*)load_ptr) != nr_sectors)
-		return -EIO;
-	debug("image: dst=%lx, offset=%lx, size=%lx\n", load_ptr, offset,
-	      (unsigned long)length);
+	if (!fit_image_get_data_position(fit, node, &offset)) {
+		external_data = true;
+	} else if (!fit_image_get_data_offset(fit, node, &offset)) {
+		offset += base_offset;
+		external_data = true;
+	}
 
-	src = (void *)load_ptr + overhead;
-#ifdef CONFIG_SPL_FIT_IMAGE_POST_PROCESS
-	board_fit_image_post_process(&src, &length);
+	if (external_data) {
+		/* External data */
+		if (fit_image_get_data_size(fit, node, &len))
+			return -ENOENT;
+
+		load_ptr = (comp_addr + align_len) & ~align_len;
+#if  defined(CONFIG_ARCH_ROCKCHIP)
+		if ((load_ptr < CONFIG_SYS_SDRAM_BASE) ||
+		     (load_ptr >= CONFIG_SYS_SDRAM_BASE + SDRAM_MAX_SIZE))
+			load_ptr = (ulong)memalign(ARCH_DMA_MINALIGN, len);
 #endif
+		length = len;
+
+		overhead = get_aligned_image_overhead(info, offset);
+		nr_sectors = get_aligned_image_size(info, length, offset);
+
+		if (info->read(info,
+			       sector + get_aligned_image_offset(info, offset),
+			       nr_sectors, (void *)load_ptr) != nr_sectors)
+			return -EIO;
+
+		debug("External data: dst=%lx, offset=%x, size=%lx\n",
+		      load_ptr, offset, (unsigned long)length);
+		src = (void *)load_ptr + overhead;
+	} else {
+		/* Embedded data */
+		if (fit_image_get_data(fit, node, &data, &length)) {
+			puts("Cannot get image data/size\n");
+			return -ENOENT;
+		}
+		debug("Embedded data: dst=%lx, size=%lx\n", load_addr,
+		      (unsigned long)length);
+		src = (void *)data;
+	}
 
-	memcpy((void*)load_addr, src, length);
+	/* Check hashes and signature */
+	if (image_comp != IH_COMP_NONE && image_comp != IH_COMP_ZIMAGE)
+		printf("## Checking %s 0x%08lx (%s @0x%08lx) ... ",
+		       fit_get_name(fit, node, NULL), load_addr,
+		       (char *)fdt_getprop(fit, node, FIT_COMP_PROP, NULL),
+		       (long)src);
+	else
+		printf("## Checking %s 0x%08lx ... ",
+		       fit_get_name(fit, node, NULL), load_addr);
+
+#ifdef CONFIG_FIT_SPL_PRINT
+	printf("\n");
+	fit_image_print(fit, node, "");
+#endif
+	if (!fit_image_verify_with_data(fit, node,
+					 src, length))
+		return -EPERM;
+
+#ifdef CONFIG_SPL_FIT_IMAGE_POST_PROCESS
+	board_fit_image_post_process(fit, node, (ulong *)&load_addr,
+				     (ulong **)&src, &length, info);
+#endif
+	puts("OK\n");
+
+	if (IS_ENABLED(CONFIG_SPL_OS_BOOT)	&&
+	    IS_ENABLED(CONFIG_SPL_GZIP)		&&
+	    image_comp == IH_COMP_GZIP		&&
+	    type == IH_TYPE_KERNEL) {
+		size = length;
+		if (gunzip((void *)load_addr, CONFIG_SYS_BOOTM_LEN,
+			   src, &size)) {
+			puts("Uncompressing error\n");
+			return -EIO;
+		}
+		length = size;
+	} else {
+		memcpy((void *)load_addr, src, length);
+	}
 
 	if (image_info) {
 		image_info->load_addr = load_addr;
@@ -173,24 +295,113 @@ static int spl_load_fit_image(struct spl_load_info *info, ulong sector,
 	return 0;
 }
 
-int spl_load_simple_fit(struct spl_image_info *spl_image,
-			struct spl_load_info *info, ulong sector, void *fit)
+static int spl_fit_append_fdt(struct spl_image_info *spl_image,
+			      struct spl_load_info *info, ulong sector,
+			      void *fit, int images, ulong base_offset)
 {
-	int sectors;
-	ulong size;
-	unsigned long count;
 	struct spl_image_info image_info;
-	int node, images, ret;
-	int base_offset, align_len = ARCH_DMA_MINALIGN - 1;
-	int index = 0;
+	int node, ret;
+
+	/* Figure out which device tree the board wants to use */
+	node = spl_fit_get_image_node(fit, images, FIT_FDT_PROP, 0);
+	if (node < 0) {
+		debug("%s: cannot find FDT node\n", __func__);
+		return node;
+	}
 
 	/*
-	 * Figure out where the external images start. This is the base for the
-	 * data-offset properties in each image.
+	 * Read the device tree and place it after the image.
+	 * Align the destination address to ARCH_DMA_MINALIGN.
 	 */
-	size = fdt_totalsize(fit);
-	size = (size + 3) & ~3;
-	base_offset = (size + 3) & ~3;
+	image_info.load_addr = spl_image->load_addr + spl_image->size;
+	ret = spl_load_fit_image(info, sector, fit, base_offset, node,
+				 &image_info);
+
+	if (ret < 0)
+		return ret;
+
+	/* Make the load-address of the FDT available for the SPL framework */
+	spl_image->fdt_addr = (void *)image_info.load_addr;
+#if !CONFIG_IS_ENABLED(FIT_IMAGE_TINY)
+	/* Try to make space, so we can inject details on the loadables */
+	ret = fdt_shrink_to_minimum(spl_image->fdt_addr, 8192);
+#endif
+
+	/*
+	 * If need, load kernel FDT right after U-Boot FDT.
+	 *
+	 * kernel FDT is for U-Boot if there is not valid one
+	 * from images, ie: resource.img, boot.img or recovery.img.
+	 */
+	node = spl_fit_get_image_node(fit, images, FIT_FDT_PROP, 1);
+	if (node < 0) {
+		debug("%s: cannot find FDT node\n", __func__);
+		return ret;
+	}
+
+	image_info.load_addr =
+		(ulong)spl_image->fdt_addr + fdt_totalsize(spl_image->fdt_addr);
+	ret = spl_load_fit_image(info, sector, fit, base_offset, node,
+				 &image_info);
+
+	return ret;
+}
+
+static int spl_fit_record_loadable(const void *fit, int images, int index,
+				   void *blob, struct spl_image_info *image)
+{
+	int ret = 0;
+#if !CONFIG_IS_ENABLED(FIT_IMAGE_TINY)
+	char *name;
+	int node;
+
+	ret = spl_fit_get_image_name(fit, images, "loadables",
+				     index, &name);
+	if (ret < 0)
+		return ret;
+
+	node = spl_fit_get_image_node(fit, images, "loadables", index);
+
+	ret = fdt_record_loadable(blob, index, name, image->load_addr,
+				  image->size, image->entry_point,
+				  fdt_getprop(fit, node, "type", NULL),
+				  fdt_getprop(fit, node, "os", NULL));
+#endif
+	return ret;
+}
+
+static int spl_fit_image_get_os(const void *fit, int noffset, uint8_t *os)
+{
+#if CONFIG_IS_ENABLED(FIT_IMAGE_TINY)
+	return -ENOTSUPP;
+#else
+	return fit_image_get_os(fit, noffset, os);
+#endif
+}
+
+__weak int spl_fit_standalone_release(char *id, uintptr_t entry_point)
+{
+	return 0;
+}
+
+static void *spl_fit_load_blob(struct spl_load_info *info,
+			       ulong sector, void *fit_header,
+			       int *base_offset)
+{
+	int align_len = ARCH_DMA_MINALIGN - 1;
+	ulong count;
+	ulong size;
+	int sectors;
+	void *fit;
+
+	/*
+	 * For FIT with external data, figure out where the external images
+	 * start. This is the base for the data-offset properties in each
+	 * image.
+	 */
+	size = fdt_totalsize(fit_header);
+	size = FIT_ALIGN(size);
+	*base_offset = FIT_ALIGN(size);
 
 	/*
 	 * So far we only have one block of data from the FIT. Read the entire
@@ -205,15 +416,181 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 	 *
 	 * In fact the FIT has its own load address, but we assume it cannot
 	 * be before CONFIG_SYS_TEXT_BASE.
+	 *
+	 * For FIT with data embedded, data is loaded as part of FIT image.
+	 * For FIT with external data, data is not loaded in this step.
 	 */
 	fit = (void *)((CONFIG_SYS_TEXT_BASE - size - info->bl_len -
 			align_len) & ~align_len);
 	sectors = get_aligned_image_size(info, size, 0);
 	count = info->read(info, sector, sectors, fit);
+#ifdef CONFIG_MTD_BLK
+	mtd_blk_map_fit(info->dev, sector, fit);
+#endif
 	debug("fit read sector %lx, sectors=%d, dst=%p, count=%lu\n",
 	      sector, sectors, fit, count);
 	if (count == 0)
+		return NULL;
+
+	return fit;
+}
+
+#ifdef CONFIG_SPL_KERNEL_BOOT
+#ifdef CONFIG_SPL_LIBDISK_SUPPORT
+__weak const char *spl_kernel_partition(struct spl_image_info *spl,
+					struct spl_load_info *info)
+{
+	return PART_BOOT;
+}
+#endif
+
+static int spl_load_kernel_fit(struct spl_image_info *spl_image,
+			       struct spl_load_info *info)
+{
+	/*
+	 * Never change the image order.
+	 *
+	 * Considering thunder-boot feature, there maybe asynchronous
+	 * loading operation of these images and ramdisk is usually to
+	 * be the last one.
+	 *
+	 * The .its content rule of kernel fit image follows U-Boot proper.
+	 */
+	const char *images[] = { FIT_FDT_PROP, FIT_KERNEL_PROP, FIT_RAMDISK_PROP, };
+	struct spl_image_info image_info;
+	char fit_header[info->bl_len];
+	int images_noffset;
+	int base_offset;
+	int sector;
+	int node, ret, i;
+	void *fit;
+
+	if (spl_image->next_stage != SPL_NEXT_STAGE_KERNEL)
+		return 0;
+
+#ifdef CONFIG_SPL_LIBDISK_SUPPORT
+	const char *part_name = PART_BOOT;
+	disk_partition_t part_info;
+
+	part_name = spl_kernel_partition(spl_image, info);
+	if (part_get_info_by_name(info->dev, part_name, &part_info) <= 0) {
+		printf("%s: no partition\n", __func__);
+		return -EINVAL;
+	}
+	sector = part_info.start;
+#else
+	sector = CONFIG_SPL_KERNEL_BOOT_SECTOR;
+#endif
+	if (info->read(info, sector, 1, &fit_header) != 1) {
+		debug("%s: Failed to read header\n", __func__);
 		return -EIO;
+	}
+
+	if (image_get_magic((void *)&fit_header) != FDT_MAGIC) {
+		printf("%s: Not fit magic\n", __func__);
+		return -EINVAL;
+	}
+
+	fit = spl_fit_load_blob(info, sector, fit_header, &base_offset);
+	if (!fit) {
+		debug("%s: Cannot load blob\n", __func__);
+		return -ENODEV;
+	}
+
+	/* verify the configure node by keys, if required */
+#ifdef CONFIG_SPL_FIT_SIGNATURE
+	int conf_noffset;
+
+	conf_noffset = fit_conf_get_node(fit, NULL);
+	if (conf_noffset <= 0) {
+		printf("No default config node\n");
+		return -EINVAL;
+	}
+
+	ret = fit_config_verify(fit, conf_noffset);
+	if (ret) {
+		printf("fit verify configure failed, ret=%d\n", ret);
+		return ret;
+	}
+	printf("\n");
+#endif
+	images_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);
+	if (images_noffset < 0) {
+		debug("%s: Cannot find /images node: %d\n",
+		      __func__, images_noffset);
+		return images_noffset;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(images); i++) {
+		node = spl_fit_get_image_node(fit, images_noffset,
+					      images[i], 0);
+		if (node < 0) {
+			debug("No image: %s\n", images[i]);
+			continue;
+		}
+
+		ret = spl_load_fit_image(info, sector, fit, base_offset,
+					 node, &image_info);
+		if (ret)
+			return ret;
+
+		/* initial addr or entry point */
+		if (!strcmp(images[i], FIT_FDT_PROP)) {
+			spl_image->fdt_addr = (void *)image_info.load_addr;
+#ifdef CONFIG_SPL_AB
+			char slot_suffix[3] = {0};
+
+			if (!spl_get_current_slot(info->dev, "misc", slot_suffix))
+				fdt_bootargs_append_ab((void *)image_info.load_addr, slot_suffix);
+#endif
+
+#ifdef CONFIG_SPL_MTD_SUPPORT
+			struct blk_desc *desc = info->dev;
+
+			if (desc->devnum == BLK_MTD_SPI_NAND)
+				fdt_bootargs_append((void *)image_info.load_addr, mtd_part_parse(desc));
+#endif
+		} else if (!strcmp(images[i], FIT_KERNEL_PROP)) {
+#if CONFIG_IS_ENABLED(OPTEE)
+			spl_image->entry_point_os = image_info.load_addr;
+#endif
+#if CONFIG_IS_ENABLED(ATF)
+			spl_image->entry_point_bl33 = image_info.load_addr;
+#endif
+		}
+	}
+
+	debug("fdt_addr=0x%08lx, entry_point=0x%08lx, entry_point_os=0x%08lx\n",
+	      (ulong)spl_image->fdt_addr,
+	      spl_image->entry_point,
+#if CONFIG_IS_ENABLED(OPTEE)
+	      spl_image->entry_point_os);
+#endif
+#if CONFIG_IS_ENABLED(ATF)
+	      spl_image->entry_point_bl33);
+#endif
+
+	return 0;
+}
+#endif
+
+static int spl_internal_load_simple_fit(struct spl_image_info *spl_image,
+					struct spl_load_info *info,
+					ulong sector, void *fit_header)
+{
+	struct spl_image_info image_info;
+	char *desc;
+	int base_offset;
+	int images, ret;
+	int index = 0;
+	int node = -1;
+	void *fit;
+
+	fit = spl_fit_load_blob(info, sector, fit_header, &base_offset);
+	if (!fit) {
+		debug("%s: Cannot load blob\n", __func__);
+		return -1;
+	}
 
 	/* find the node holding the images information */
 	images = fdt_path_offset(fit, FIT_IMAGES_PATH);
@@ -222,8 +599,95 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 		return -1;
 	}
 
-	/* find the U-Boot image */
-	node = spl_fit_get_image_node(fit, images, "firmware", 0);
+	/* if board sigs verify required, check self */
+	if (fit_board_verify_required_sigs() &&
+	    !IS_ENABLED(CONFIG_SPL_FIT_SIGNATURE)) {
+		printf("Verified-boot requires CONFIG_SPL_FIT_SIGNATURE enabled\n");
+		hang();
+	}
+
+	/* verify the configure node by keys, if required */
+#ifdef CONFIG_SPL_FIT_SIGNATURE
+	int conf_noffset;
+
+	conf_noffset = fit_conf_get_node(fit, NULL);
+	if (conf_noffset <= 0) {
+		printf("No default config node\n");
+		return -EINVAL;
+	}
+
+	ret = fit_config_verify(fit, conf_noffset);
+	if (ret) {
+		printf("fit verify configure failed, ret=%d\n", ret);
+		return ret;
+	}
+	printf("\n");
+
+#ifdef CONFIG_SPL_FIT_ROLLBACK_PROTECT
+	uint32_t this_index, min_index;
+
+	ret = fit_rollback_index_verify(fit, FIT_ROLLBACK_INDEX_SPL,
+					&this_index, &min_index);
+	if (ret) {
+		printf("fit failed to get rollback index, ret=%d\n", ret);
+		return ret;
+	} else if (this_index < min_index) {
+		printf("fit reject rollback: %d < %d(min)\n",
+		       this_index, min_index);
+		return -EINVAL;
+	}
+
+	printf("rollback index: %d >= %d(min), OK\n", this_index, min_index);
+#endif
+#endif
+
+	/*
+	 * If required to start the other core before load "loadables"
+	 * firmwares, use the config "standalone" to load the other core's
+	 * firmware, then start it.
+	 * Normally, different cores' firmware is attach to the config
+	 * "loadables" and load them together.
+	 */
+	for (; ; index++) {
+		node = spl_fit_get_image_node(fit, images,
+					      FIT_STANDALONE_PROP, index);
+		if (node < 0)
+			break;
+
+		ret = spl_load_fit_image(info, sector, fit, base_offset,
+					 node, &image_info);
+		if (ret)
+			return ret;
+
+		ret = fit_get_desc(fit, node, &desc);
+		if (ret)
+			return ret;
+
+		if (image_info.entry_point == FDT_ERROR)
+			image_info.entry_point = image_info.load_addr;
+
+		ret = spl_fit_standalone_release(desc, image_info.entry_point);
+		if (ret)
+			printf("%s: start standalone fail, ret=%d\n", desc, ret);
+	}
+
+	/* standalone is special one, continue to find others */
+	node = -1;
+	index = 0;
+
+	/*
+	 * Find the U-Boot image using the following search order:
+	 *   - start at 'firmware' (e.g. an ARM Trusted Firmware)
+	 *   - fall back 'kernel' (e.g. a Falcon-mode OS boot
+	 *   - fall back to using the first 'loadables' entry
+	 */
+	if (node < 0)
+		node = spl_fit_get_image_node(fit, images, FIT_FIRMWARE_PROP,
+					      0);
+#ifdef CONFIG_SPL_OS_BOOT
+	if (node < 0)
+		node = spl_fit_get_image_node(fit, images, FIT_KERNEL_PROP, 0);
+#endif
 	if (node < 0) {
 		debug("could not find firmware image, trying loadables...\n");
 		node = spl_fit_get_image_node(fit, images, "loadables", 0);
@@ -245,35 +709,56 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 	if (ret)
 		return ret;
 
-	spl_image->os = IH_OS_U_BOOT;
-
-	/* Figure out which device tree the board wants to use */
-	node = spl_fit_get_image_node(fit, images, FIT_FDT_PROP, 0);
-	if (node < 0) {
-		debug("%s: cannot find FDT node\n", __func__);
-		return node;
-	}
+	/*
+	 * For backward compatibility, we treat the first node that is
+	 * as a U-Boot image, if no OS-type has been declared.
+	 */
+	if (!spl_fit_image_get_os(fit, node, &spl_image->os))
+		debug("Image OS is %s\n", genimg_get_os_name(spl_image->os));
+#if !defined(CONFIG_SPL_OS_BOOT)
+	else
+		spl_image->os = IH_OS_U_BOOT;
+#endif
 
 	/*
-	 * Read the device tree and place it after the image.
-	 * Align the destination address to ARCH_DMA_MINALIGN.
+	 * Booting a next-stage U-Boot may require us to append the FDT.
+	 * We allow this to fail, as the U-Boot image might embed its FDT.
 	 */
-	image_info.load_addr = spl_image->load_addr + spl_image->size;
-	ret = spl_load_fit_image(info, sector, fit, base_offset, node,
-				 &image_info);
-	if (ret < 0)
-		return ret;
+	if (spl_image->os == IH_OS_U_BOOT)
+		spl_fit_append_fdt(spl_image, info, sector, fit,
+				   images, base_offset);
 
 	/* Now check if there are more images for us to load */
 	for (; ; index++) {
+		uint8_t os_type = IH_OS_INVALID;
+
 		node = spl_fit_get_image_node(fit, images, "loadables", index);
 		if (node < 0)
 			break;
 
+		if (!spl_fit_image_get_os(fit, node, &os_type))
+			debug("Loadable is %s\n", genimg_get_os_name(os_type));
+
+		/* skip U-Boot ? */
+		if (spl_image->next_stage == SPL_NEXT_STAGE_KERNEL &&
+		    os_type == IH_OS_U_BOOT)
+		    continue;
+
 		ret = spl_load_fit_image(info, sector, fit, base_offset, node,
 					 &image_info);
 		if (ret < 0)
-			continue;
+			return ret;
+
+		if (os_type == IH_OS_U_BOOT) {
+#if CONFIG_IS_ENABLED(ATF)
+			spl_image->entry_point_bl33 = image_info.load_addr;
+#elif CONFIG_IS_ENABLED(OPTEE)
+			spl_image->entry_point_os = image_info.load_addr;
+#endif
+			spl_fit_append_fdt(&image_info, info, sector,
+					   fit, images, base_offset);
+			spl_image->fdt_addr = image_info.fdt_addr;
+		}
 
 		/*
 		 * If the "firmware" image did not provide an entry point,
@@ -282,6 +767,12 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 		if (spl_image->entry_point == FDT_ERROR &&
 		    image_info.entry_point != FDT_ERROR)
 			spl_image->entry_point = image_info.entry_point;
+
+		/* Record our loadables into the FDT */
+		if (spl_image->fdt_addr)
+			spl_fit_record_loadable(fit, images, index,
+						spl_image->fdt_addr,
+						&image_info);
 	}
 
 	/*
@@ -294,3 +785,50 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 
 	return 0;
 }
+
+int spl_load_simple_fit(struct spl_image_info *spl_image,
+			struct spl_load_info *info, ulong sector, void *fit)
+{
+	ulong sector_offs = sector;
+	int ret = -EINVAL;
+	int i;
+
+	printf("Trying fit image at 0x%lx sector\n", sector_offs);
+	for (i = 0; i < CONFIG_SPL_FIT_IMAGE_MULTIPLE; i++) {
+		if (i > 0) {
+			sector_offs +=
+			   i * ((CONFIG_SPL_FIT_IMAGE_KB << 10) / info->bl_len);
+			printf("Trying fit image at 0x%lx sector\n", sector_offs);
+			if (info->read(info, sector_offs, 1, fit) != 1) {
+				printf("IO error\n");
+				continue;
+			}
+		}
+
+		if (image_get_magic(fit) != FDT_MAGIC) {
+			printf("Not fit magic\n");
+			continue;
+		}
+
+		ret = spl_internal_load_simple_fit(spl_image, info,
+						   sector_offs, fit);
+		if (!ret) {
+#ifdef CONFIG_SPL_KERNEL_BOOT
+			ret = spl_load_kernel_fit(spl_image, info);
+#endif
+			break;
+		}
+	}
+#ifdef CONFIG_SPL_AB
+	/*
+	 * If boot fail in spl, spl must decrease 1. If boot
+	 * successfully, it is no need to do that and U-boot will
+	 * always to decrease 1. If in thunderboot process,
+	 * always need to decrease 1.
+	 */
+	if (IS_ENABLED(CONFIG_SPL_KERNEL_BOOT) || ret)
+		spl_ab_decrease_tries(info->dev);
+#endif
+	return ret;
+}
+
diff --git a/common/spl/spl_mmc.c b/common/spl/spl_mmc.c
index b2cccc6c6e..d1be98b8ae 100644
--- a/common/spl/spl_mmc.c
+++ b/common/spl/spl_mmc.c
@@ -7,8 +7,11 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
+#include <boot_rkimg.h>
 #include <dm.h>
+#include <part.h>
 #include <spl.h>
+#include <spl_rkfw.h>
 #include <linux/compiler.h>
 #include <errno.h>
 #include <asm/u-boot.h>
@@ -47,13 +50,12 @@ static int mmc_load_legacy(struct spl_image_info *spl_image, struct mmc *mmc,
 static ulong h_spl_load_read(struct spl_load_info *load, ulong sector,
 			     ulong count, void *buf)
 {
-	struct mmc *mmc = load->dev;
-
-	return blk_dread(mmc_get_blk_desc(mmc), sector, count, buf);
+	return blk_dread(load->dev, sector, count, buf);
 }
 
-static int mmc_load_image_raw_sector(struct spl_image_info *spl_image,
-				     struct mmc *mmc, unsigned long sector)
+static __maybe_unused
+int mmc_load_image_raw_sector(struct spl_image_info *spl_image,
+			      struct mmc *mmc, unsigned long sector)
 {
 	unsigned long count;
 	struct image_header *header;
@@ -70,12 +72,18 @@ static int mmc_load_image_raw_sector(struct spl_image_info *spl_image,
 		goto end;
 	}
 
+#ifdef CONFIG_SPL_FIT_IMAGE_MULTIPLE
+	if ((IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	     image_get_magic(header) == FDT_MAGIC) ||
+	     CONFIG_SPL_FIT_IMAGE_MULTIPLE > 1) {
+#else
 	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 	    image_get_magic(header) == FDT_MAGIC) {
+#endif
 		struct spl_load_info load;
 
 		debug("Found FIT\n");
-		load.dev = mmc;
+		load.dev = mmc_get_blk_desc(mmc);
 		load.priv = NULL;
 		load.filename = NULL;
 		load.bl_len = mmc->read_bl_len;
@@ -88,7 +96,7 @@ static int mmc_load_image_raw_sector(struct spl_image_info *spl_image,
 end:
 	if (ret) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
-		puts("mmc_load_image_raw_sector: mmc block read error\n");
+		debug("mmc_load_image_raw_sector error: ret is %d\n", ret);
 #endif
 		return -1;
 	}
@@ -113,11 +121,8 @@ static int spl_mmc_get_device_index(u32 boot_device)
 	return -ENODEV;
 }
 
-static int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
+int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
 {
-#if CONFIG_IS_ENABLED(DM_MMC)
-	struct udevice *dev;
-#endif
 	int err, mmc_dev;
 
 	mmc_dev = spl_mmc_get_device_index(boot_device);
@@ -132,14 +137,8 @@ static int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
 		return err;
 	}
 
-#if CONFIG_IS_ENABLED(DM_MMC)
-	err = uclass_get_device(UCLASS_MMC, mmc_dev, &dev);
-	if (!err)
-		*mmcp = mmc_get_mmc_dev(dev);
-#else
 	*mmcp = find_mmc_device(mmc_dev);
 	err = *mmcp ? 0 : -ENODEV;
-#endif
 	if (err) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
 		printf("spl: could not find mmc device. error: %d\n", err);
@@ -152,7 +151,9 @@ static int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
 
 #ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
 static int mmc_load_image_raw_partition(struct spl_image_info *spl_image,
-					struct mmc *mmc, int partition)
+					struct mmc *mmc,
+					const char *partition_name,
+					int partition)
 {
 	disk_partition_t info;
 	int err;
@@ -171,21 +172,19 @@ static int mmc_load_image_raw_partition(struct spl_image_info *spl_image,
 		}
 	}
 #endif
-
-	err = part_get_info(mmc_get_blk_desc(mmc), partition, &info);
-	if (err) {
+	if (strcmp(partition_name, ""))
+		err = part_get_info_by_name(mmc_get_blk_desc(mmc),
+					    partition_name, &info);
+	else
+		err = part_get_info(mmc_get_blk_desc(mmc), partition, &info);
+	if (err < 0) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
 		puts("spl: partition error\n");
 #endif
 		return -1;
 	}
 
-#ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR
-	return mmc_load_image_raw_sector(spl_image, mmc,
-			info.start + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR);
-#else
 	return mmc_load_image_raw_sector(spl_image, mmc, info.start);
-#endif
 }
 #endif
 
@@ -300,6 +299,19 @@ int spl_mmc_load_image(struct spl_image_info *spl_image,
 		return err;
 	}
 
+#ifdef CONFIG_SPL_LOAD_RKFW
+	struct spl_load_info load;
+
+	load.dev = mmc_get_blk_desc(mmc);
+	load.priv = NULL;
+	load.filename = NULL;
+	load.bl_len = mmc->read_bl_len;
+	load.read = h_spl_load_read;
+
+	err = spl_load_rkfw_image(spl_image, &load);
+	if (!err || err != -EAGAIN)
+		return err;
+#endif
 	boot_mode = spl_boot_mode(bootdev->boot_device);
 	err = -EINVAL;
 	switch (boot_mode) {
@@ -336,6 +348,7 @@ int spl_mmc_load_image(struct spl_image_info *spl_image,
 		}
 #ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
 		err = mmc_load_image_raw_partition(spl_image, mmc,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_NAME,
 			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION);
 		if (!err)
 			return err;
diff --git a/common/spl/spl_nand.c b/common/spl/spl_nand.c
index cd39f9be9d..4e3f9a2f9a 100644
--- a/common/spl/spl_nand.c
+++ b/common/spl/spl_nand.c
@@ -7,9 +7,10 @@
 #include <common.h>
 #include <config.h>
 #include <spl.h>
+#include <spl_rkfw.h>
 #include <asm/io.h>
 #include <nand.h>
-#include <libfdt_env.h>
+#include <linux/libfdt_env.h>
 #include <fdt.h>
 
 #if defined(CONFIG_SPL_NAND_RAW_ONLY)
@@ -40,17 +41,51 @@ static ulong spl_nand_fit_read(struct spl_load_info *load, ulong offs,
 		return 0;
 }
 
+#ifdef CONFIG_SPL_LOAD_RKFW
+static ulong spl_nand_rkfw_read(struct spl_load_info *load, ulong offs,
+				ulong size, void *dst)
+{
+	int ret;
+
+	ret = nand_spl_load_image(offs * 512, size * 512, dst);
+	if (!ret)
+		return size;
+	else
+		return 0;
+}
+#endif
+
 static int spl_nand_load_element(struct spl_image_info *spl_image,
 				 int offset, struct image_header *header)
 {
 	int err;
 
+#ifdef CONFIG_SPL_LOAD_RKFW
+	struct spl_load_info load;
+	int ret;
+
+	load.dev = NULL;
+	load.priv = NULL;
+	load.filename = NULL;
+	load.bl_len = 1;
+	load.read = spl_nand_rkfw_read;
+
+	ret = spl_load_rkfw_image(spl_image, &load);
+	if (!ret || ret != -EAGAIN)
+		return ret;
+#endif
 	err = nand_spl_load_image(offset, sizeof(*header), (void *)header);
 	if (err)
 		return err;
 
+#ifdef CONFIG_SPL_FIT_IMAGE_MULTIPLE
+	if ((IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	     image_get_magic(header) == FDT_MAGIC) ||
+	     CONFIG_SPL_FIT_IMAGE_MULTIPLE > 1) {
+#else
 	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 	    image_get_magic(header) == FDT_MAGIC) {
+#endif
 		struct spl_load_info load;
 
 		debug("Found FIT\n");
diff --git a/common/spl/spl_net.c b/common/spl/spl_net.c
index 88831097fa..f2d27434b4 100644
--- a/common/spl/spl_net.c
+++ b/common/spl/spl_net.c
@@ -11,7 +11,7 @@
 #include <errno.h>
 #include <spl.h>
 #include <net.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -47,8 +47,14 @@ static int spl_net_load_image(struct spl_image_info *spl_image,
 		return rv;
 	}
 
+#ifdef CONFIG_SPL_FIT_IMAGE_MULTIPLE
+	if ((IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	     image_get_magic(header) == FDT_MAGIC) ||
+	     CONFIG_SPL_FIT_IMAGE_MULTIPLE > 1) {
+#else
 	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 	    image_get_magic(header) == FDT_MAGIC) {
+#endif
 		struct spl_load_info load;
 
 		debug("Found FIT\n");
diff --git a/common/spl/spl_ram.c b/common/spl/spl_ram.c
index b2645a1948..86136fce47 100644
--- a/common/spl/spl_ram.c
+++ b/common/spl/spl_ram.c
@@ -12,7 +12,7 @@
  */
 #include <common.h>
 #include <spl.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 #ifndef CONFIG_SPL_LOAD_FIT_ADDRESS
 # define CONFIG_SPL_LOAD_FIT_ADDRESS	0
@@ -34,13 +34,19 @@ static int spl_ram_load_image(struct spl_image_info *spl_image,
 
 	header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS;
 
-#if defined(CONFIG_SPL_DFU_SUPPORT)
+#if CONFIG_IS_ENABLED(DFU)
 	if (bootdev->boot_device == BOOT_DEVICE_DFU)
 		spl_dfu_cmd(0, "dfu_alt_info_ram", "ram", "0");
 #endif
 
+#ifdef CONFIG_SPL_FIT_IMAGE_MULTIPLE
+	if ((IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	     image_get_magic(header) == FDT_MAGIC) ||
+	     CONFIG_SPL_FIT_IMAGE_MULTIPLE > 1) {
+#else
 	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 	    image_get_magic(header) == FDT_MAGIC) {
+#endif
 		struct spl_load_info load;
 
 		debug("Found FIT\n");
@@ -66,7 +72,7 @@ static int spl_ram_load_image(struct spl_image_info *spl_image,
 #if defined(CONFIG_SPL_RAM_DEVICE)
 SPL_LOAD_IMAGE_METHOD("RAM", 0, BOOT_DEVICE_RAM, spl_ram_load_image);
 #endif
-#if defined(CONFIG_SPL_DFU_SUPPORT)
+#if CONFIG_IS_ENABLED(DFU)
 SPL_LOAD_IMAGE_METHOD("DFU", 0, BOOT_DEVICE_DFU, spl_ram_load_image);
 #endif
 
diff --git a/common/spl/spl_sdp.c b/common/spl/spl_sdp.c
index 350bcdb056..859b48bf35 100644
--- a/common/spl/spl_sdp.c
+++ b/common/spl/spl_sdp.c
@@ -24,14 +24,18 @@ static int spl_sdp_load_image(struct spl_image_info *spl_image,
 
 	ret = sdp_init(controller_index);
 	if (ret) {
-		error("SDP init failed: %d", ret);
+		pr_err("SDP init failed: %d\n", ret);
 		return -ENODEV;
 	}
 
-	/* This command typically does not return but jumps to an image */
-	sdp_handle(controller_index);
-	error("SDP ended");
+	/*
+	 * This command either loads a legacy image, jumps and never returns,
+	 * or it loads a FIT image and returns it to be handled by the SPL
+	 * code.
+	 */
+	ret = spl_sdp_handle(controller_index, spl_image);
+	debug("SDP ended\n");
 
-	return -EINVAL;
+	return ret;
 }
 SPL_LOAD_IMAGE_METHOD("USB SDP", 0, BOOT_DEVICE_BOARD, spl_sdp_load_image);
diff --git a/common/spl/spl_spi.c b/common/spl/spl_spi.c
index 42880d56b9..bda318cc49 100644
--- a/common/spl/spl_spi.c
+++ b/common/spl/spl_spi.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2011 OMICRON electronics GmbH
  *
- * based on drivers/mtd/nand/nand_spl_load.c
+ * based on drivers/mtd/nand/raw/nand_spl_load.c
  *
  * Copyright (C) 2011
  * Heiko Schocher, DENX Software Engineering, hs@denx.de.
@@ -78,6 +78,8 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 
 	/*
 	 * Load U-Boot image from SPI flash into RAM
+	 * In DM mode: defaults speed and mode will be
+	 * taken from DT when available
 	 */
 
 	flash = spi_flash_probe(CONFIG_SF_DEFAULT_BUS,
@@ -111,8 +113,14 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 			return err;
 		}
 
+#ifdef CONFIG_SPL_FIT_IMAGE_MULTIPLE
+		if ((IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+		     image_get_magic(header) == FDT_MAGIC) ||
+		     CONFIG_SPL_FIT_IMAGE_MULTIPLE > 1) {
+#else
 		if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
-			image_get_magic(header) == FDT_MAGIC) {
+		    image_get_magic(header) == FDT_MAGIC) {
+#endif
 			struct spl_load_info load;
 
 			debug("Found FIT\n");
diff --git a/common/spl/spl_ymodem.c b/common/spl/spl_ymodem.c
index ff8085b795..4ab3dcd624 100644
--- a/common/spl/spl_ymodem.c
+++ b/common/spl/spl_ymodem.c
@@ -14,7 +14,7 @@
 #include <xyzModem.h>
 #include <asm/u-boot.h>
 #include <asm/utils.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 #define BUF_SIZE 1024
 
diff --git a/common/splash_source.c b/common/splash_source.c
index e0defdebd6..6a987eaa83 100644
--- a/common/splash_source.c
+++ b/common/splash_source.c
@@ -358,7 +358,7 @@ static int splash_load_fit(struct splash_location *location, u32 bmp_load_addr)
 
 	/* Align data offset to 4-byte boundrary */
 	fit_size = fdt_totalsize(fit_header);
-	fit_size = (fit_size + 3) & ~3;
+	fit_size = FIT_ALIGN(fit_size);
 
 	/* Read in the splash data */
 	location->offset = (location->offset + fit_size + splash_offset);
diff --git a/common/stdio.c b/common/stdio.c
index ee4f0bda9e..fbf06e29f0 100644
--- a/common/stdio.c
+++ b/common/stdio.c
@@ -17,9 +17,6 @@
 #include <malloc.h>
 #include <stdio_dev.h>
 #include <serial.h>
-#ifdef CONFIG_LOGBUFFER
-#include <logbuff.h>
-#endif
 
 #if defined(CONFIG_SYS_I2C)
 #include <i2c.h>
@@ -57,6 +54,11 @@ static int nulldev_input(struct stdio_dev *dev)
 	/* nulldev is empty! */
 	return 0;
 }
+
+static void nulldev_clear(struct stdio_dev *dev)
+{
+	/* nulldev is empty! */
+}
 #endif
 
 static void stdio_serial_putc(struct stdio_dev *dev, const char c)
@@ -79,6 +81,11 @@ static int stdio_serial_tstc(struct stdio_dev *dev)
 	return serial_tstc();
 }
 
+static void stdio_serial_clear(struct stdio_dev *dev)
+{
+	serial_clear();
+}
+
 /**************************************************************************
  * SYSTEM DRIVERS
  **************************************************************************
@@ -96,6 +103,7 @@ static void drv_system_init (void)
 	dev.puts = stdio_serial_puts;
 	dev.getc = stdio_serial_getc;
 	dev.tstc = stdio_serial_tstc;
+	dev.clear = stdio_serial_clear;
 	stdio_register (&dev);
 
 #ifdef CONFIG_SYS_DEVICE_NULLDEV
@@ -107,6 +115,7 @@ static void drv_system_init (void)
 	dev.puts = nulldev_puts;
 	dev.getc = nulldev_input;
 	dev.tstc = nulldev_input;
+	dev.clear = nulldev_clear;
 
 	stdio_register (&dev);
 #endif
@@ -380,9 +389,6 @@ int stdio_add_devices(void)
 #endif /* CONFIG_DM_VIDEO */
 #if defined(CONFIG_KEYBOARD) && !defined(CONFIG_DM_KEYBOARD)
 	drv_keyboard_init ();
-#endif
-#ifdef CONFIG_LOGBUFFER
-	drv_logbuff_init ();
 #endif
 	drv_system_init ();
 	serial_stdio_init ();
diff --git a/common/update.c b/common/update.c
index 974f4655e7..33bffaa89e 100644
--- a/common/update.c
+++ b/common/update.c
@@ -242,7 +242,7 @@ int update_tftp(ulong addr, char *interface, char *devstring)
 	} else if (interface && devstring) {
 		update_tftp_dfu = true;
 	} else {
-		error("Interface: %s and devstring: %s not supported!\n",
+		pr_err("Interface: %s and devstring: %s not supported!\n",
 		      interface, devstring);
 		return -EINVAL;
 	}
diff --git a/common/usb.c b/common/usb.c
old mode 100644
new mode 100755
index 0904259757..5537d8ddc3
--- a/common/usb.c
+++ b/common/usb.c
@@ -43,7 +43,7 @@
 static int asynch_allowed;
 char usb_started; /* flag for the started/stopped USB status */
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 static struct usb_device usb_dev[USB_MAX_DEVICE];
 static int dev_index;
 
@@ -184,7 +184,7 @@ int usb_disable_asynch(int disable)
 	asynch_allowed = !disable;
 	return old_value;
 }
-#endif /* !CONFIG_DM_USB */
+#endif /* !CONFIG_IS_ENABLED(DM_USB) */
 
 
 /*-------------------------------------------------------------------
@@ -193,12 +193,15 @@ int usb_disable_asynch(int disable)
  */
 
 /*
- * submits an Interrupt Message
+ * submits an Interrupt Message. Some drivers may implement non-blocking
+ * polling: when non-block is true and the device is not responding return
+ * -EAGAIN instead of waiting for device to respond.
  */
-int usb_submit_int_msg(struct usb_device *dev, unsigned long pipe,
-			void *buffer, int transfer_len, int interval)
+int usb_int_msg(struct usb_device *dev, unsigned long pipe,
+		void *buffer, int transfer_len, int interval, bool nonblock)
 {
-	return submit_int_msg(dev, pipe, buffer, transfer_len, interval);
+	return submit_int_msg(dev, pipe, buffer, transfer_len, interval,
+			      nonblock);
 }
 
 /*
@@ -253,6 +256,9 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 	if (dev->status)
 		return -1;
 
+	if(dev->descriptor.idVendor == 0x058f && dev->descriptor.idProduct == 0x6387)
+		udelay(200);
+
 	return dev->act_len;
 
 }
@@ -514,6 +520,20 @@ static int usb_parse_config(struct usb_device *dev,
 		index += head->bLength;
 		head = (struct usb_descriptor_header *)&buffer[index];
 	}
+
+	/**
+	 * Some odd devices respond the Endpoint descriptor items are less
+	 * then the bNumEndpoints in Interface descriptor, so fix it here.
+	 */
+	for (ifno = 0; ifno < dev->config.no_of_if; ifno++) {
+		if_desc = &dev->config.if_desc[ifno];
+		if (if_desc->desc.bNumEndpoints != if_desc->no_of_ep) {
+			printf("WARN: interface %d has %d endpoint descriptor, "
+			       "different from the interface descriptor's value: %d\n",
+			       ifno, if_desc->no_of_ep, if_desc->desc.bNumEndpoints);
+			if_desc->desc.bNumEndpoints = if_desc->no_of_ep;
+		}
+	}
 	return 0;
 }
 
@@ -849,7 +869,7 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
  * the USB device are static allocated [USB_MAX_DEVICE].
  */
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 
 /* returns a pointer to the device with the index [index].
  * if the device is not assigned (dev->devnum==-1) returns NULL
@@ -906,7 +926,7 @@ __weak int usb_alloc_device(struct usb_device *udev)
 {
 	return 0;
 }
-#endif /* !CONFIG_DM_USB */
+#endif /* !CONFIG_IS_ENABLED(DM_USB) */
 
 static int usb_hub_port_reset(struct usb_device *dev, struct usb_device *hub)
 {
@@ -969,23 +989,24 @@ static int usb_setup_descriptor(struct usb_device *dev, bool do_read)
 	dev->epmaxpacketin[0] = dev->descriptor.bMaxPacketSize0;
 	dev->epmaxpacketout[0] = dev->descriptor.bMaxPacketSize0;
 
-	if (do_read) {
+	if (do_read && dev->speed == USB_SPEED_FULL) {
 		int err;
 
 		/*
-		 * Validate we've received only at least 8 bytes, not that we've
-		 * received the entire descriptor. The reasoning is:
-		 * - The code only uses fields in the first 8 bytes, so that's all we
-		 *   need to have fetched at this stage.
-		 * - The smallest maxpacket size is 8 bytes. Before we know the actual
-		 *   maxpacket the device uses, the USB controller may only accept a
-		 *   single packet. Consequently we are only guaranteed to receive 1
-		 *   packet (at least 8 bytes) even in a non-error case.
+		 * Validate we've received only at least 8 bytes, not that
+		 * we've received the entire descriptor. The reasoning is:
+		 * - The code only uses fields in the first 8 bytes, so
+		 *   that's all we need to have fetched at this stage.
+		 * - The smallest maxpacket size is 8 bytes. Before we know
+		 *   the actual maxpacket the device uses, the USB controller
+		 *   may only accept a single packet. Consequently we are only
+		 *   guaranteed to receive 1 packet (at least 8 bytes) even in
+		 *   a non-error case.
 		 *
-		 * At least the DWC2 controller needs to be programmed with the number
-		 * of packets in addition to the number of bytes. A request for 64
-		 * bytes of data with the maxpacket guessed as 64 (above) yields a
-		 * request for 1 packet.
+		 * At least the DWC2 controller needs to be programmed with
+		 * the number of packets in addition to the number of bytes.
+		 * A request for 64 bytes of data with the maxpacket guessed
+		 * as 64 (above) yields a request for 1 packet.
 		 */
 		err = get_descriptor_len(dev, 64, 8);
 		if (err)
@@ -1008,7 +1029,7 @@ static int usb_setup_descriptor(struct usb_device *dev, bool do_read)
 		dev->maxpacketsize = PACKET_SIZE_64;
 		break;
 	default:
-		printf("usb_new_device: invalid max packet size\n");
+		printf("%s: invalid max packet size\n", __func__);
 		return -EIO;
 	}
 
@@ -1050,6 +1071,17 @@ static int usb_prepare_device(struct usb_device *dev, int addr, bool do_read,
 
 	mdelay(10);	/* Let the SET_ADDRESS settle */
 
+	/*
+	 * If we haven't read device descriptor before, read it here
+	 * after device is assigned an address. This is only applicable
+	 * to xHCI so far.
+	 */
+	if (!do_read) {
+		err = usb_setup_descriptor(dev, true);
+		if (err)
+			return err;
+	}
+
 	return 0;
 }
 
@@ -1154,7 +1186,7 @@ int usb_setup_device(struct usb_device *dev, bool do_read,
 	return ret;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 /*
  * By the time we get here, the device has gotten a new device ID
  * and is in the default state. We need to identify the thing and
@@ -1203,14 +1235,14 @@ int board_usb_cleanup(int index, enum usb_init_type init)
 
 bool usb_device_has_child_on_port(struct usb_device *parent, int port)
 {
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	return false;
 #else
 	return parent->children[port] != NULL;
 #endif
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 void usb_find_usb2_hub_address_port(struct usb_device *udev,
 			       uint8_t *hub_address, uint8_t *hub_port)
 {
diff --git a/common/usb_hub.c b/common/usb_hub.c
index 86a3477664..4a33aa36b6 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -57,7 +57,7 @@ struct usb_device_scan {
 
 static LIST_HEAD(usb_scan_list);
 
-__weak void usb_hub_reset_devices(int port)
+__weak void usb_hub_reset_devices(struct usb_hub_device *hub, int port)
 {
 	return;
 }
@@ -67,7 +67,7 @@ static inline bool usb_hub_is_superspeed(struct usb_device *hdev)
 	return hdev->descriptor.bDeviceProtocol == 3;
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 bool usb_hub_is_root_hub(struct udevice *hub)
 {
 	if (device_get_uclass_id(hub->parent) != UCLASS_USB_HUB)
@@ -128,7 +128,7 @@ int usb_get_port_status(struct usb_device *dev, int port, void *data)
 			USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port,
 			data, sizeof(struct usb_port_status), USB_CNTL_TIMEOUT);
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	if (ret < 0)
 		return ret;
 
@@ -212,7 +212,7 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 	      max(100, (int)pgood_delay) + 1000);
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 static struct usb_hub_device hub_dev[USB_MAX_HUB];
 static int usb_hub_index;
 
@@ -276,7 +276,7 @@ static int usb_hub_port_reset(struct usb_device *dev, int port,
 	unsigned short portstatus, portchange;
 	int delay = HUB_SHORT_RESET_TIME; /* start with short reset delay */
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	debug("%s: resetting '%s' port %d...\n", __func__, dev->dev->name,
 	      port + 1);
 #else
@@ -397,7 +397,7 @@ int usb_hub_port_connect_change(struct usb_device *dev, int port)
 		break;
 	}
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	struct udevice *child;
 
 	ret = usb_scan_device(dev->dev, port + 1, speed, &child);
@@ -489,6 +489,17 @@ static int usb_scan_port(struct usb_device_scan *usb_scan)
 		return 0;
 	}
 
+	if (portchange & USB_PORT_STAT_C_RESET) {
+		debug("port %d reset change\n", i + 1);
+		usb_clear_port_feature(dev, i + 1, USB_PORT_FEAT_C_RESET);
+	}
+
+	if ((portchange & USB_SS_PORT_STAT_C_BH_RESET) &&
+	    usb_hub_is_superspeed(dev)) {
+		debug("port %d BH reset change\n", i + 1);
+		usb_clear_port_feature(dev, i + 1, USB_SS_PORT_FEAT_C_BH_RESET);
+	}
+
 	/* A new USB device is ready at this point */
 	debug("devnum=%d port=%d: USB dev found\n", dev->devnum, i + 1);
 
@@ -543,11 +554,6 @@ static int usb_scan_port(struct usb_device_scan *usb_scan)
 		       hub->overcurrent_count[i]);
 	}
 
-	if (portchange & USB_PORT_STAT_C_RESET) {
-		debug("port %d reset change\n", i + 1);
-		usb_clear_port_feature(dev, i + 1, USB_PORT_FEAT_C_RESET);
-	}
-
 	/*
 	 * We're done with this device, so let's remove this device from
 	 * scanning list
@@ -601,7 +607,7 @@ static struct usb_hub_device *usb_get_hub_device(struct usb_device *dev)
 {
 	struct usb_hub_device *hub;
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 	/* "allocate" Hub device */
 	hub = usb_hub_allocate();
 #else
@@ -619,7 +625,7 @@ static int usb_hub_configure(struct usb_device *dev)
 	short hubCharacteristics;
 	struct usb_hub_descriptor *descriptor;
 	struct usb_hub_device *hub;
-	__maybe_unused struct usb_hub_status *hubsts;
+	struct usb_hub_status *hubsts;
 	int ret;
 
 	hub = usb_get_hub_device(dev);
@@ -773,9 +779,7 @@ static int usb_hub_configure(struct usb_device *dev)
 		return ret;
 	}
 
-#ifdef DEBUG
 	hubsts = (struct usb_hub_status *)buffer;
-#endif
 
 	debug("get_hub_status returned status %X, change %X\n",
 	      le16_to_cpu(hubsts->wHubStatus),
@@ -787,7 +791,7 @@ static int usb_hub_configure(struct usb_device *dev)
 	      (le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
 	      "" : "no ");
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	/*
 	 * Update USB host controller's internal representation of this hub
 	 * after the hub descriptor is fetched.
@@ -847,7 +851,7 @@ static int usb_hub_configure(struct usb_device *dev)
 	 * should occur in the board file of the device.
 	 */
 	for (i = 0; i < dev->maxchild; i++)
-		usb_hub_reset_devices(i + 1);
+		usb_hub_reset_devices(hub, i + 1);
 
 	/*
 	 * Only add the connected USB devices, including potential hubs,
@@ -929,7 +933,7 @@ int usb_hub_probe(struct usb_device *dev, int ifnum)
 	return ret;
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 int usb_hub_scan(struct udevice *hub)
 {
 	struct usb_device *udev = dev_get_parent_priv(hub);
diff --git a/common/usb_kbd.c b/common/usb_kbd.c
index 8cbdba6ac2..fe8cf23795 100644
--- a/common/usb_kbd.c
+++ b/common/usb_kbd.c
@@ -15,6 +15,7 @@
 #include <memalign.h>
 #include <stdio_dev.h>
 #include <asm/byteorder.h>
+#include <linux/input.h>
 
 #include <usb.h>
 
@@ -74,13 +75,12 @@ static const unsigned char usb_kbd_num_keypad[] = {
 	'.', 0, 0, 0, '='
 };
 
-/*
- * map arrow keys to ^F/^B ^N/^P, can't really use the proper
- * ANSI sequence for arrow keys because the queuing code breaks
- * when a single keypress expands to 3 queue elements
- */
-static const unsigned char usb_kbd_arrow[] = {
-	0x6, 0x2, 0xe, 0x10
+static const u8 usb_special_keys[] = {
+#ifdef CONFIG_USB_KEYBOARD_FN_KEYS
+	'2', 'H', '5', '3', 'F', '6', 'C', 'D', 'B', 'A'
+#else
+	'C', 'D', 'B', 'A'
+#endif
 };
 
 /*
@@ -126,7 +126,7 @@ extern int __maybe_unused net_busy_flag;
 static unsigned long __maybe_unused kbd_testc_tms;
 
 /* Puts character in the queue and sets up the in and out pointer. */
-static void usb_kbd_put_queue(struct usb_kbd_pdata *data, char c)
+static void usb_kbd_put_queue(struct usb_kbd_pdata *data, u8 c)
 {
 	if (data->usb_in_pointer == USB_KBD_BUFFER_LEN - 1) {
 		/* Check for buffer full. */
@@ -207,10 +207,6 @@ static int usb_kbd_translate(struct usb_kbd_pdata *data, unsigned char scancode,
 			keycode = usb_kbd_numkey[scancode - 0x1e];
 	}
 
-	/* Arrow keys */
-	if ((scancode >= 0x4f) && (scancode <= 0x52))
-		keycode = usb_kbd_arrow[scancode - 0x4f];
-
 	/* Numeric keypad */
 	if ((scancode >= 0x54) && (scancode <= 0x67))
 		keycode = usb_kbd_num_keypad[scancode - 0x54];
@@ -238,9 +234,55 @@ static int usb_kbd_translate(struct usb_kbd_pdata *data, unsigned char scancode,
 	if (keycode) {
 		debug("%c", keycode);
 		usb_kbd_put_queue(data, keycode);
+		return 0;
 	}
 
+#ifdef CONFIG_USB_KEYBOARD_FN_KEYS
+	if (scancode < 0x3a || scancode > 0x52 ||
+	    scancode == 0x46 || scancode == 0x47)
+		return 1;
+
+	usb_kbd_put_queue(data, 0x1b);
+	if (scancode < 0x3e) {
+		/* F1 - F4 */
+		usb_kbd_put_queue(data, 0x4f);
+		usb_kbd_put_queue(data, scancode - 0x3a + 'P');
+		return 0;
+	}
+	usb_kbd_put_queue(data, '[');
+	if (scancode < 0x42) {
+		/* F5 - F8 */
+		usb_kbd_put_queue(data, '1');
+		if (scancode == 0x3e)
+			--scancode;
+		keycode = scancode - 0x3f + '7';
+	} else if (scancode < 0x49) {
+		/* F9 - F12 */
+		usb_kbd_put_queue(data, '2');
+		if (scancode > 0x43)
+			++scancode;
+		keycode = scancode - 0x42 + '0';
+	} else {
+		/*
+		 * INSERT, HOME, PAGE UP, DELETE, END, PAGE DOWN,
+		 * RIGHT, LEFT, DOWN, UP
+		 */
+		keycode = usb_special_keys[scancode - 0x49];
+	}
+	usb_kbd_put_queue(data, keycode);
+	if (scancode < 0x4f && scancode != 0x4a && scancode != 0x4d)
+		usb_kbd_put_queue(data, '~');
 	return 0;
+#else
+	/* Left, Right, Up, Down */
+	if (scancode > 0x4e && scancode < 0x53) {
+		usb_kbd_put_queue(data, 0x1b);
+		usb_kbd_put_queue(data, '[');
+		usb_kbd_put_queue(data, usb_special_keys[scancode - 0x4f]);
+		return 0;
+	}
+	return 1;
+#endif /* CONFIG_USB_KEYBOARD_FN_KEYS */
 }
 
 static uint32_t usb_kbd_service_key(struct usb_device *dev, int i, int up)
@@ -316,11 +358,10 @@ static inline void usb_kbd_poll_for_event(struct usb_device *dev)
 #if defined(CONFIG_SYS_USB_EVENT_POLL)
 	struct usb_kbd_pdata *data = dev->privptr;
 
-	/* Submit a interrupt transfer request */
-	usb_submit_int_msg(dev, data->intpipe, &data->new[0], data->intpktsize,
-			   data->intinterval);
-
-	usb_kbd_irq_worker(dev);
+	/* Submit an interrupt transfer request */
+	if (usb_int_msg(dev, data->intpipe, &data->new[0],
+			data->intpktsize, data->intinterval, true) >= 0)
+		usb_kbd_irq_worker(dev);
 #elif defined(CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP) || \
       defined(CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE)
 #if defined(CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP)
@@ -480,8 +521,8 @@ static int usb_kbd_probe_dev(struct usb_device *dev, unsigned int ifnum)
 	if (usb_get_report(dev, iface->desc.bInterfaceNumber,
 			   1, 0, data->new, USB_KBD_BOOT_REPORT_SIZE) < 0) {
 #else
-	if (usb_submit_int_msg(dev, data->intpipe, data->new, data->intpktsize,
-			       data->intinterval) < 0) {
+	if (usb_int_msg(dev, data->intpipe, data->new, data->intpktsize,
+			data->intinterval, false) < 0) {
 #endif
 		printf("Failed to get keyboard state from device %04x:%04x\n",
 		       dev->descriptor.idVendor, dev->descriptor.idProduct);
@@ -537,7 +578,7 @@ static int probe_usb_keyboard(struct usb_device *dev)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 /* Search for keyboard and register it if found. */
 int drv_usb_kbd_init(void)
 {
@@ -600,7 +641,62 @@ int usb_kbd_deregister(int force)
 
 #endif
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
+
+int usb_kbd_recv_fn(int key_fn)
+{
+	char ch[5];
+	int i;
+
+	if (!ftstc(stdin)) {
+		debug("No char\n");
+		return 0;
+	}
+
+	memset(ch, 0, 5);
+	for (i = 0; i < 5; i++) {
+		if (!ftstc(stdin))
+			break;
+		ch[i] = fgetc(stdin);
+		debug("char[%d]: 0x%x, %d\n", i, ch[i], ch[i]);
+	}
+
+	if (ch[0] != 0x1b) {
+		debug("Invalid 0x1b\n");
+		return 0;
+	}
+
+	switch (key_fn) {
+	case KEY_F1:
+	case KEY_F2:
+	case KEY_F3:
+	case KEY_F4:
+		if (ch[1] != 0x4f)
+			return 0;
+		return (ch[2] - 21 == key_fn);
+	case KEY_F5:
+	case KEY_F6:
+	case KEY_F7:
+	case KEY_F8:
+		if (ch[1] != '[' || ch[2] != '1' || ch[4] != '~')
+			return 0;
+		return (ch[3] + 9 == key_fn);
+	case KEY_F9:
+	case KEY_F10:
+		if (ch[1] != '[' || ch[2] != '2' || ch[4] != '~')
+			return 0;
+		return (ch[3] + 19 == key_fn);
+	case KEY_F11:
+	case KEY_F12:
+		if (ch[1] != '[' || ch[2] != '2' || ch[4] != '~')
+			return 0;
+		return (ch[3] + 36 == key_fn);
+	default:
+		return 0;
+	}
+
+	return 0;
+}
 
 static int usb_kbd_probe(struct udevice *dev)
 {
diff --git a/common/usb_storage.c b/common/usb_storage.c
index df0b057308..a5a780b35a 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -98,19 +98,9 @@ struct us_data {
 	struct scsi_cmd	*srb;			/* current srb */
 	trans_reset	transport_reset;	/* reset routine */
 	trans_cmnd	transport;		/* transport routine */
+	unsigned short	max_xfer_blk;		/* maximum transfer blocks */
 };
 
-#ifdef CONFIG_USB_EHCI_HCD
-/*
- * The U-Boot EHCI driver can handle any transfer length as long as there is
- * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
- * limited to 65535 blocks.
- */
-#define USB_MAX_XFER_BLK	65535
-#else
-#define USB_MAX_XFER_BLK	20
-#endif
-
 #ifndef CONFIG_BLK
 static struct us_data usb_stor[USB_MAX_STOR_DEV];
 #endif
@@ -313,7 +303,7 @@ int usb_stor_scan(int mode)
 	if (mode == 1)
 		printf("       scanning usb for storage devices... ");
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 	unsigned char i;
 
 	usb_disable_asynch(1); /* asynch transfer not allowed */
@@ -664,8 +654,8 @@ static int usb_stor_CBI_get_status(struct scsi_cmd *srb, struct us_data *us)
 	int timeout;
 
 	us->ip_wanted = 1;
-	submit_int_msg(us->pusb_dev, us->irqpipe,
-			(void *) &us->ip_data, us->irqmaxp, us->irqinterval);
+	usb_int_msg(us->pusb_dev, us->irqpipe,
+		    (void *)&us->ip_data, us->irqmaxp, us->irqinterval, false);
 	timeout = 1000;
 	while (timeout--) {
 		if (us->ip_wanted == 0)
@@ -949,6 +939,39 @@ do_retry:
 	return USB_STOR_TRANSPORT_FAILED;
 }
 
+static void usb_stor_set_max_xfer_blk(struct usb_device *udev,
+				      struct us_data *us)
+{
+	/*
+	 * Limit the total size of a transfer to 120 KB.
+	 *
+	 * Some devices are known to choke with anything larger. It seems like
+	 * the problem stems from the fact that original IDE controllers had
+	 * only an 8-bit register to hold the number of sectors in one transfer
+	 * and even those couldn't handle a full 256 sectors.
+	 *
+	 * Because we want to make sure we interoperate with as many devices as
+	 * possible, we will maintain a 240 sector transfer size limit for USB
+	 * Mass Storage devices.
+	 *
+	 * Tests show that other operating have similar limits with Microsoft
+	 * Windows 7 limiting transfers to 128 sectors for both USB2 and USB3
+	 * and Apple Mac OS X 10.11 limiting transfers to 256 sectors for USB2
+	 * and 2048 for USB3 devices.
+	 */
+	unsigned short blk = 240;
+
+#if CONFIG_IS_ENABLED(DM_USB)
+	size_t size;
+	int ret;
+
+	ret = usb_get_max_xfer_size(udev, (size_t *)&size);
+	if ((ret >= 0) && (size < blk * 512))
+		blk = size / 512;
+#endif
+
+	us->max_xfer_blk = blk;
+}
 
 static int usb_inquiry(struct scsi_cmd *srb, struct us_data *ss)
 {
@@ -1150,12 +1173,12 @@ static unsigned long usb_stor_read(struct blk_desc *block_dev, lbaint_t blknr,
 		/* XXX need some comment here */
 		retry = 2;
 		srb->pdata = (unsigned char *)buf_addr;
-		if (blks > USB_MAX_XFER_BLK)
-			smallblks = USB_MAX_XFER_BLK;
+		if (blks > ss->max_xfer_blk)
+			smallblks = ss->max_xfer_blk;
 		else
 			smallblks = (unsigned short) blks;
 retry_it:
-		if (smallblks == USB_MAX_XFER_BLK)
+		if (smallblks == ss->max_xfer_blk)
 			usb_show_progress();
 		srb->datalen = block_dev->blksz * smallblks;
 		srb->pdata = (unsigned char *)buf_addr;
@@ -1178,7 +1201,7 @@ retry_it:
 	      start, smallblks, buf_addr);
 
 	usb_disable_asynch(0); /* asynch transfer allowed */
-	if (blkcnt >= USB_MAX_XFER_BLK)
+	if (blkcnt >= ss->max_xfer_blk)
 		debug("\n");
 	return blkcnt;
 }
@@ -1236,12 +1259,12 @@ static unsigned long usb_stor_write(struct blk_desc *block_dev, lbaint_t blknr,
 		 */
 		retry = 2;
 		srb->pdata = (unsigned char *)buf_addr;
-		if (blks > USB_MAX_XFER_BLK)
-			smallblks = USB_MAX_XFER_BLK;
+		if (blks > ss->max_xfer_blk)
+			smallblks = ss->max_xfer_blk;
 		else
 			smallblks = (unsigned short) blks;
 retry_it:
-		if (smallblks == USB_MAX_XFER_BLK)
+		if (smallblks == ss->max_xfer_blk)
 			usb_show_progress();
 		srb->datalen = block_dev->blksz * smallblks;
 		srb->pdata = (unsigned char *)buf_addr;
@@ -1263,7 +1286,7 @@ retry_it:
 	      PRIxPTR "\n", start, smallblks, buf_addr);
 
 	usb_disable_asynch(0); /* asynch transfer allowed */
-	if (blkcnt >= USB_MAX_XFER_BLK)
+	if (blkcnt >= ss->max_xfer_blk)
 		debug("\n");
 	return blkcnt;
 
@@ -1384,6 +1407,10 @@ int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
 		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
 		dev->irq_handle = usb_stor_irq;
 	}
+
+	/* Set the maximum transfer size per host controller setting */
+	usb_stor_set_max_xfer_blk(dev, ss);
+
 	dev->privptr = (void *)ss;
 	return 1;
 }
@@ -1474,7 +1501,7 @@ int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
 	return 1;
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 
 static int usb_mass_storage_probe(struct udevice *dev)
 {
diff --git a/common/xyzModem.c b/common/xyzModem.c
index a0c5dfeece..386a1951a5 100644
--- a/common/xyzModem.c
+++ b/common/xyzModem.c
@@ -52,14 +52,15 @@ static struct
   unsigned long file_length, read_length;
 } xyz;
 
-#define xyzModem_CHAR_TIMEOUT            2000	/* 2 seconds */
+#define _xyzModem_CHAR_TIMEOUT            2000	/* 2 seconds */
 #define xyzModem_MAX_RETRIES             20
 #define xyzModem_MAX_RETRIES_WITH_CRC    10
 #define xyzModem_CAN_COUNT                3	/* Wait for 3 CAN before quitting */
 
+int xyzModem_CHAR_TIMEOUT = _xyzModem_CHAR_TIMEOUT;
 
 typedef int cyg_int32;
-static int
+int
 CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
 {
 
@@ -77,7 +78,7 @@ CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
   return 0;
 }
 
-static void
+void
 CYGACC_COMM_IF_PUTC (char x, char y)
 {
   putc (y);
diff --git a/disk/Kconfig b/disk/Kconfig
index 9396562120..cce5fe6b20 100644
--- a/disk/Kconfig
+++ b/disk/Kconfig
@@ -4,6 +4,10 @@ menu "Partition Types"
 config PARTITIONS
 	bool "Enable Partition Labels (disklabels) support"
 	default y
+	select SPL_SPRINTF if SPL
+	select TPL_SPRINTF if TPL
+	select SPL_STRTO if SPL
+	select TPL_STRTO if TPL
 	help
 	  Partition Labels (disklabels) Supported:
 	  Zero or more of the following:
@@ -78,6 +82,20 @@ config EFI_PARTITION
 	  common when EFI is the bootloader.  Note 2TB partition limit;
 	  see disk/part_efi.c
 
+config EFI_PARTITION_ENTRIES_NUMBERS
+	int "Number of the EFI partition entries"
+	depends on EFI_PARTITION
+	default 56 if ARCH_SUNXI
+	default 128
+	help
+	  Specify the number of partition entries in the GPT. This is
+	  meant to allow less than the standard specifies for devices
+	  that might need to place their first-stage bootloader in the
+	  middle of a regular GPT.
+
+	  If unsure, leave at 128 entries, which is the standard
+	  number.
+
 config EFI_PARTITION_ENTRIES_OFF
         int "Offset (in bytes) of the EFI partition entries"
 	depends on EFI_PARTITION
@@ -117,4 +135,35 @@ config PARTITION_TYPE_GUID
 	  Activate the configuration of GUID type
 	  for EFI partition
 
+config ENV_PARTITION
+	bool "Enable ENV partition table support"
+	depends on PARTITIONS
+	help
+	  Say Y here if you would like to use ENV partition table.
+
+config SPL_ENV_PARTITION
+	bool "Enable ENV partition table support in SPL"
+	depends on SPL && PARTITIONS
+	default y if ENV_PARTITION
+	help
+	  Say Y here if you would like to use ENV partition table in SPL.
+
+config RKPARM_PARTITION
+	bool "Enable Rockchip parameter partition table"
+	depends on PARTITIONS
+	help
+	  Say Y here if you would like to use device under U-Boot which
+	  were partitioned using Rockchip parameter.
+
+config RKRAM_PARTITION
+	bool "Enable Rockchip ram partition table"
+	depends on PARTITIONS && DM_RAMDISK
+	depends on ROCKCHIP_PRELOADER_ATAGS
+	help
+	  Say Y here if you would like to use device under U-Boot which
+	  were partitioned using Rockchip atags.
+
+config SPL_ROCKCHIP_PARTITION
+	bool "Enable Rockchip partition table for SPL"
+
 endmenu
diff --git a/disk/Makefile b/disk/Makefile
index 12c0531689..607b6df76f 100644
--- a/disk/Makefile
+++ b/disk/Makefile
@@ -8,8 +8,13 @@
 #ccflags-y += -DET_DEBUG -DDEBUG
 
 obj-$(CONFIG_PARTITIONS) 	+= part.o
+ifndef CONFIG_TPL_BUILD
 obj-$(CONFIG_$(SPL_)MAC_PARTITION)   += part_mac.o
 obj-$(CONFIG_$(SPL_)DOS_PARTITION)   += part_dos.o
 obj-$(CONFIG_$(SPL_)ISO_PARTITION)   += part_iso.o
 obj-$(CONFIG_$(SPL_)AMIGA_PARTITION) += part_amiga.o
 obj-$(CONFIG_$(SPL_)EFI_PARTITION)   += part_efi.o
+obj-$(CONFIG_$(SPL_)ENV_PARTITION)   += part_env.o
+obj-$(CONFIG_$(SPL_)RKPARM_PARTITION)   += part_rkparm.o
+obj-$(CONFIG_$(SPL_)RKRAM_PARTITION)   += part_rkram.o
+endif
diff --git a/disk/part.c b/disk/part.c
index c67fdacc79..116a1ae796 100644
--- a/disk/part.c
+++ b/disk/part.c
@@ -11,7 +11,14 @@
 #include <ide.h>
 #include <malloc.h>
 #include <part.h>
+#ifdef CONFIG_SPL_AB
+#include <spl_ab.h>
+#endif
 #include <ubifs_uboot.h>
+#ifdef CONFIG_ANDROID_AB
+#include <android_avb/avb_ops_user.h>
+#include <android_avb/rk_avb_ops_user.h>
+#endif
 
 #undef	PART_DEBUG
 
@@ -24,16 +31,28 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 #ifdef HAVE_BLOCK_DEVICE
-static struct part_driver *part_driver_lookup_type(int part_type)
+static struct part_driver *part_driver_lookup_type(struct blk_desc *dev_desc)
 {
 	struct part_driver *drv =
 		ll_entry_start(struct part_driver, part_driver);
 	const int n_ents = ll_entry_count(struct part_driver, part_driver);
 	struct part_driver *entry;
 
-	for (entry = drv; entry != drv + n_ents; entry++) {
-		if (part_type == entry->part_type)
-			return entry;
+	if (dev_desc->part_type == PART_TYPE_UNKNOWN) {
+		for (entry = drv; entry != drv + n_ents; entry++) {
+			int ret;
+
+			ret = entry->test(dev_desc);
+			if (!ret) {
+				dev_desc->part_type = entry->part_type;
+				return entry;
+			}
+		}
+	} else {
+		for (entry = drv; entry != drv + n_ents; entry++) {
+			if (dev_desc->part_type == entry->part_type)
+				return entry;
+		}
 	}
 
 	/* Not found */
@@ -131,12 +150,16 @@ void dev_print (struct blk_desc *dev_desc)
 		break;
 	case IF_TYPE_SD:
 	case IF_TYPE_MMC:
+	case IF_TYPE_MTD:
 	case IF_TYPE_USB:
 	case IF_TYPE_NVME:
-		printf ("Vendor: %s Rev: %s Prod: %s\n",
-			dev_desc->vendor,
-			dev_desc->revision,
-			dev_desc->product);
+	case IF_TYPE_RKNAND:
+	case IF_TYPE_SPINAND:
+	case IF_TYPE_SPINOR:
+		printf("Vendor: %s Rev: %s Prod: %s\n",
+		       dev_desc->vendor,
+		       dev_desc->revision,
+		       dev_desc->product);
 		break;
 	case IF_TYPE_DOC:
 		puts("device type DOC\n");
@@ -263,12 +286,24 @@ static void print_part_header(const char *type, struct blk_desc *dev_desc)
 	case IF_TYPE_MMC:
 		puts ("MMC");
 		break;
+	case IF_TYPE_MTD:
+		puts("MTD");
+		break;
 	case IF_TYPE_HOST:
 		puts ("HOST");
 		break;
 	case IF_TYPE_NVME:
 		puts ("NVMe");
 		break;
+	case IF_TYPE_RKNAND:
+		puts("RKNAND");
+		break;
+	case IF_TYPE_SPINAND:
+		puts("SPINAND");
+		break;
+	case IF_TYPE_SPINOR:
+		puts("SPINOR");
+		break;
 	default:
 		puts ("UNKNOWN");
 		break;
@@ -282,7 +317,7 @@ void part_print(struct blk_desc *dev_desc)
 {
 	struct part_driver *drv;
 
-	drv = part_driver_lookup_type(dev_desc->part_type);
+	drv = part_driver_lookup_type(dev_desc);
 	if (!drv) {
 		printf("## Unknown partition table type %x\n",
 		       dev_desc->part_type);
@@ -295,6 +330,19 @@ void part_print(struct blk_desc *dev_desc)
 		drv->print(dev_desc);
 }
 
+const char *part_get_type(struct blk_desc *dev_desc)
+{
+	struct part_driver *drv;
+
+	drv = part_driver_lookup_type(dev_desc);
+	if (!drv) {
+		printf("## Unknown partition table type %x\n",
+		       dev_desc->part_type);
+		return NULL;
+	}
+
+	return drv->name;
+}
 #endif /* HAVE_BLOCK_DEVICE */
 
 int part_get_info(struct blk_desc *dev_desc, int part,
@@ -311,7 +359,7 @@ int part_get_info(struct blk_desc *dev_desc, int part,
 	info->type_guid[0] = 0;
 #endif
 
-	drv = part_driver_lookup_type(dev_desc->part_type);
+	drv = part_driver_lookup_type(dev_desc);
 	if (!drv) {
 		debug("## Unknown partition table type %x\n",
 		      dev_desc->part_type);
@@ -331,6 +379,24 @@ int part_get_info(struct blk_desc *dev_desc, int part,
 	return -1;
 }
 
+int part_get_info_whole_disk(struct blk_desc *dev_desc, disk_partition_t *info)
+{
+	info->start = 0;
+	info->size = dev_desc->lba;
+	info->blksz = dev_desc->blksz;
+	info->bootable = 0;
+	strcpy((char *)info->type, BOOT_PART_TYPE);
+	strcpy((char *)info->name, "Whole Disk");
+#if CONFIG_IS_ENABLED(PARTITION_UUIDS)
+	info->uuid[0] = 0;
+#endif
+#ifdef CONFIG_PARTITION_TYPE_GUID
+	info->type_guid[0] = 0;
+#endif
+
+	return 0;
+}
+
 int blk_get_device_by_str(const char *ifname, const char *dev_hwpart_str,
 			  struct blk_desc **dev_desc)
 {
@@ -523,18 +589,7 @@ int blk_get_device_part_str(const char *ifname, const char *dev_part_str,
 
 		(*dev_desc)->log2blksz = LOG2((*dev_desc)->blksz);
 
-		info->start = 0;
-		info->size = (*dev_desc)->lba;
-		info->blksz = (*dev_desc)->blksz;
-		info->bootable = 0;
-		strcpy((char *)info->type, BOOT_PART_TYPE);
-		strcpy((char *)info->name, "Whole Disk");
-#if CONFIG_IS_ENABLED(PARTITION_UUIDS)
-		info->uuid[0] = 0;
-#endif
-#ifdef CONFIG_PARTITION_TYPE_GUID
-		info->type_guid[0] = 0;
-#endif
+		part_get_info_whole_disk(*dev_desc, info);
 
 		ret = 0;
 		goto cleanup;
@@ -619,32 +674,85 @@ cleanup:
 	return ret;
 }
 
-int part_get_info_by_name(struct blk_desc *dev_desc, const char *name,
-	disk_partition_t *info)
+/*
+ * For android A/B system, we append the current slot suffix quietly,
+ * this takes over the responsibility of slot suffix appending from
+ * developer to framework.
+ */
+static int part_get_info_by_name_option(struct blk_desc *dev_desc,
+					const char *name,
+					disk_partition_t *info,
+					bool strict)
 {
-	struct part_driver *first_drv =
-		ll_entry_start(struct part_driver, part_driver);
-	const int n_drvs = ll_entry_count(struct part_driver, part_driver);
 	struct part_driver *part_drv;
+	char name_slot[32] = {0};
+	int none_slot_try = 1;
+	int ret, i;
+
+	part_drv = part_driver_lookup_type(dev_desc);
+	if (!part_drv)
+		return -1;
+
+	if (strict) {
+		none_slot_try = 0;
+		strcpy(name_slot, name);
+		goto lookup;
+	}
 
-	for (part_drv = first_drv; part_drv != first_drv + n_drvs; part_drv++) {
-		int ret;
-		int i;
-		for (i = 1; i < part_drv->max_entries; i++) {
-			ret = part_drv->get_info(dev_desc, i, info);
-			if (ret != 0) {
-				/* no more entries in table */
-				break;
-			}
-			if (strcmp(name, (const char *)info->name) == 0) {
-				/* matched */
-				return i;
-			}
+#if defined(CONFIG_ANDROID_AB) || defined(CONFIG_SPL_AB)
+	char *name_suffix = (char *)name + strlen(name) - 2;
+
+	/* Fix can not find partition with suffix "_a" & "_b". If with them, clear */
+	if (!memcmp(name_suffix, "_a", strlen("_a")) ||
+	    !memcmp(name_suffix, "_b", strlen("_b")))
+		memset(name_suffix, 0, 2);
+#endif
+#if defined(CONFIG_ANDROID_AB) && !defined(CONFIG_SPL_BUILD)
+	/* 1. Query partition with A/B slot suffix */
+	if (rk_avb_append_part_slot(name, name_slot))
+		return -1;
+#elif defined(CONFIG_SPL_AB) && defined(CONFIG_SPL_BUILD)
+	if (spl_ab_append_part_slot(dev_desc, name, name_slot))
+		return -1;
+#else
+	strcpy(name_slot, name);
+#endif
+lookup:
+	debug("## Query partition(%d): %s\n", none_slot_try, name_slot);
+	for (i = 1; i < part_drv->max_entries; i++) {
+		ret = part_drv->get_info(dev_desc, i, info);
+		if (ret != 0) {
+			/* no more entries in table */
+			break;
+		}
+		if (strcmp(name_slot, (const char *)info->name) == 0) {
+			/* matched */
+			return i;
 		}
 	}
+
+	/* 2. Query partition without A/B slot suffix if above failed */
+	if (none_slot_try) {
+		none_slot_try = 0;
+		strcpy(name_slot, name);
+		goto lookup;
+	}
+
 	return -1;
 }
 
+int part_get_info_by_name(struct blk_desc *dev_desc, const char *name,
+			  disk_partition_t *info)
+{
+	return part_get_info_by_name_option(dev_desc, name, info, false);
+}
+
+int part_get_info_by_name_strict(struct blk_desc *dev_desc, const char *name,
+				 disk_partition_t *info)
+{
+	return part_get_info_by_name_option(dev_desc, name, info, true);
+}
+
 void part_set_generic_name(const struct blk_desc *dev_desc,
 	int part_num, char *name)
 {
diff --git a/disk/part_dos.c b/disk/part_dos.c
index 7ede15ec26..850a538e83 100644
--- a/disk/part_dos.c
+++ b/disk/part_dos.c
@@ -89,14 +89,20 @@ static int test_block_type(unsigned char *buffer)
 
 static int part_test_dos(struct blk_desc *dev_desc)
 {
-	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
+	ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);
 
-	if (blk_dread(dev_desc, 0, 1, (ulong *)buffer) != 1)
+	if (blk_dread(dev_desc, 0, 1, (ulong *)mbr) != 1)
 		return -1;
 
-	if (test_block_type(buffer) != DOS_MBR)
+	if (test_block_type((unsigned char *)mbr) != DOS_MBR)
 		return -1;
 
+	if (dev_desc->sig_type == SIG_TYPE_NONE &&
+	    mbr->unique_mbr_signature != 0) {
+		dev_desc->sig_type = SIG_TYPE_MBR;
+		dev_desc->mbr_sig = mbr->unique_mbr_signature;
+	}
+
 	return 0;
 }
 
diff --git a/disk/part_efi.c b/disk/part_efi.c
index 2973d52f6a..c8297162dc 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -72,6 +72,7 @@ static inline int is_bootable(gpt_entry *p)
 			sizeof(efi_guid_t));
 }
 
+#define FACTORY_UNKNOWN_LBA (0xffffffff - 34)
 static int validate_gpt_header(gpt_header *gpt_h, lbaint_t lba,
 		lbaint_t lastlba)
 {
@@ -80,10 +81,11 @@ static int validate_gpt_header(gpt_header *gpt_h, lbaint_t lba,
 
 	/* Check the GPT header signature */
 	if (le64_to_cpu(gpt_h->signature) != GPT_HEADER_SIGNATURE) {
-		printf("%s signature is wrong: 0x%llX != 0x%llX\n",
-		       "GUID Partition Table Header",
-		       le64_to_cpu(gpt_h->signature),
-		       GPT_HEADER_SIGNATURE);
+		if (le64_to_cpu(gpt_h->signature) != 0)
+			printf("%s signature is wrong: 0x%llX != 0x%llX\n",
+			       "GUID Partition Table Header",
+			       le64_to_cpu(gpt_h->signature),
+			       GPT_HEADER_SIGNATURE);
 		return -1;
 	}
 
@@ -123,6 +125,16 @@ static int validate_gpt_header(gpt_header *gpt_h, lbaint_t lba,
 		return -1;
 	}
 	if (le64_to_cpu(gpt_h->last_usable_lba) > lastlba) {
+		if (le64_to_cpu(gpt_h->last_usable_lba) == FACTORY_UNKNOWN_LBA) {
+#ifdef CONFIG_SPL_BUILD
+			printf("GPT: SPL workaround factory last_usable_lba\n");
+			gpt_h->last_usable_lba = lastlba - 34;
+			return 0;
+#else
+			printf("GPT: last_usable_lba need repair\n");
+			return 0;
+#endif
+		}
 		printf("GPT: last_usable_lba incorrect: %llX > " LBAF "\n",
 		       le64_to_cpu(gpt_h->last_usable_lba), lastlba);
 		return -1;
@@ -269,8 +281,21 @@ void part_print_efi(struct blk_desc *dev_desc)
 int part_get_info_efi(struct blk_desc *dev_desc, int part,
 		      disk_partition_t *info)
 {
-	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
-	gpt_entry *gpt_pte = NULL;
+	static gpt_entry *gpt_pte = NULL;
+	static gpt_header *gpt_head = NULL;
+
+	if (!gpt_head)
+		gpt_head = memalign(ARCH_DMA_MINALIGN, dev_desc->blksz);
+
+	/*
+	 * We suppose different dev have different size, eg. emmc vs sd
+	 * free the pte first if exist and then will malloc and init a new one.
+	 */
+	if (gpt_head && (gpt_head->last_usable_lba + 0x22) != dev_desc->lba) {
+		if (gpt_pte)
+			free(gpt_pte);
+		gpt_pte = NULL;
+	}
 
 	/* "part" argument must be at least 1 */
 	if (part < 1) {
@@ -297,7 +322,6 @@ int part_get_info_efi(struct blk_desc *dev_desc, int part,
 	    !is_pte_valid(&gpt_pte[part - 1])) {
 		debug("%s: *** ERROR: Invalid partition number %d ***\n",
 			__func__, part);
-		free(gpt_pte);
 		return -1;
 	}
 
@@ -324,21 +348,162 @@ int part_get_info_efi(struct blk_desc *dev_desc, int part,
 	debug("%s: start 0x" LBAF ", size 0x" LBAF ", name %s\n", __func__,
 	      info->start, info->size, info->name);
 
-	/* Remember to free pte */
-	free(gpt_pte);
 	return 0;
 }
 
+#ifdef CONFIG_RKIMG_BOOTLOADER
+#if defined(CONFIG_SPL_KERNEL_BOOT) || !defined(CONFIG_SPL_BUILD)
+static void gpt_entry_modify(struct blk_desc *dev_desc,
+			     gpt_entry *gpt_pte,
+			     gpt_header *gpt_head)
+{
+	int i;
+	uint32_t calc_crc32;
+
+	for (i = 0; i < gpt_head->num_partition_entries; i++) {
+		if (!is_pte_valid(&gpt_pte[i]))
+			break;
+	}
+
+	if (gpt_pte[i - 1].ending_lba <= (dev_desc->lba - 0x22))
+		return;
+	/* The last partition size need align to 4KB, here align to 32KB. */
+	gpt_pte[i - 1].ending_lba = dev_desc->lba - 0x40;
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_pte,
+			       le32_to_cpu(gpt_head->num_partition_entries) *
+			       le32_to_cpu(gpt_head->sizeof_partition_entry));
+	gpt_head->partition_entry_array_crc32 = calc_crc32;
+}
+
+static int part_efi_repair(struct blk_desc *dev_desc, gpt_entry *gpt_pte,
+			   gpt_header *gpt_head, int head_gpt_valid,
+			   int backup_gpt_valid)
+{
+	uint32_t calc_crc32;
+	size_t count = 0, blk_cnt;
+	lbaint_t blk;
+
+	if (head_gpt_valid == 1 && backup_gpt_valid == 1) {
+		return 0;
+	} else if (head_gpt_valid == 0 && backup_gpt_valid == 0) {
+		return -1;
+	} else if (head_gpt_valid == 1 && backup_gpt_valid == 0) {
+		gpt_head->header_crc32 = 0;
+		gpt_head->my_lba = dev_desc->lba - 1;
+		gpt_head->alternate_lba = 1;
+		gpt_head->partition_entry_lba = dev_desc->lba - 0x21;
+		gpt_head->last_usable_lba = cpu_to_le64(dev_desc->lba - 34);
+		gpt_entry_modify(dev_desc, gpt_pte, gpt_head);
+		calc_crc32 = efi_crc32((const unsigned char *)gpt_head,
+				       le32_to_cpu(gpt_head->header_size));
+		gpt_head->header_crc32 = calc_crc32;
+		if (blk_dwrite(dev_desc, dev_desc->lba - 1, 1, gpt_head) != 1) {
+			printf("*** ERROR: Can't write GPT header ***\n");
+			return -1;
+		}
+		count = le32_to_cpu(gpt_head->num_partition_entries) *
+			le32_to_cpu(gpt_head->sizeof_partition_entry);
+		blk = le64_to_cpu(gpt_head->partition_entry_lba);
+		blk_cnt = BLOCK_CNT(count, dev_desc);
+		if (blk_dwrite(dev_desc, blk, (lbaint_t)blk_cnt, gpt_pte) !=
+		    blk_cnt) {
+			printf("*** ERROR: Can't write entry partitions ***\n");
+			return -1;
+		}
+		printf("Repair the backup gpt table OK!\n");
+	} else if (head_gpt_valid == 0 && backup_gpt_valid == 1) {
+		gpt_head->header_crc32 = 0;
+		gpt_head->my_lba = 1;
+		gpt_head->alternate_lba = dev_desc->lba - 1;
+		gpt_head->partition_entry_lba = 0x2;
+		gpt_head->last_usable_lba = cpu_to_le64(dev_desc->lba - 34);
+		gpt_entry_modify(dev_desc, gpt_pte, gpt_head);
+		calc_crc32 = efi_crc32((const unsigned char *)gpt_head,
+				       le32_to_cpu(gpt_head->header_size));
+		gpt_head->header_crc32 = calc_crc32;
+		if (blk_dwrite(dev_desc, 1, 1, gpt_head) != 1) {
+			printf("*** ERROR: Can't write GPT header ***\n");
+			return -1;
+		}
+		count = le32_to_cpu(gpt_head->num_partition_entries) *
+			le32_to_cpu(gpt_head->sizeof_partition_entry);
+		blk = le64_to_cpu(gpt_head->partition_entry_lba);
+		blk_cnt = BLOCK_CNT(count, dev_desc);
+		if (blk_dwrite(dev_desc, blk, (lbaint_t)blk_cnt, gpt_pte) !=
+		    blk_cnt) {
+			printf("*** ERROR: Can't write entry partitions ***\n");
+			return -1;
+		}
+		printf("Repair the Primary gpt table OK!\n");
+	}
+
+	return 0;
+}
+#endif
+#endif
+
 static int part_test_efi(struct blk_desc *dev_desc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER_PAD(legacy_mbr, legacymbr, 1, dev_desc->blksz);
+	int ret = 0;
 
 	/* Read legacy MBR from block 0 and validate it */
 	if ((blk_dread(dev_desc, 0, 1, (ulong *)legacymbr) != 1)
 		|| (is_pmbr_valid(legacymbr) != 1)) {
 		return -1;
 	}
-	return 0;
+#ifdef CONFIG_RKIMG_BOOTLOADER
+#if defined(CONFIG_SPL_KERNEL_BOOT) || !defined(CONFIG_SPL_BUILD)
+	gpt_entry *h_gpt_pte = NULL;
+	gpt_header *h_gpt_head = NULL;
+	gpt_entry *b_gpt_pte = NULL;
+	gpt_header *b_gpt_head = NULL;
+	int head_gpt_valid = 0;
+	int backup_gpt_valid = 0;
+
+	if (!h_gpt_head)
+		h_gpt_head = memalign(ARCH_DMA_MINALIGN, dev_desc->blksz);
+	if (!b_gpt_head)
+		b_gpt_head = memalign(ARCH_DMA_MINALIGN, dev_desc->blksz);
+
+	head_gpt_valid = is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				      h_gpt_head, &h_gpt_pte);
+	backup_gpt_valid = is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+					b_gpt_head, &b_gpt_pte);
+
+	if ((head_gpt_valid == 1) &&
+	    (le64_to_cpu(h_gpt_head->last_usable_lba)
+	     == FACTORY_UNKNOWN_LBA)) {
+		if (part_efi_repair(dev_desc, h_gpt_pte, h_gpt_head,
+				    0, 1))
+			printf("Primary GPT repair fail!\n");
+		/* Force repair backup GPT for factory or ota upgrade. */
+		backup_gpt_valid = 0;
+	}
+
+	if (head_gpt_valid == 1 && backup_gpt_valid == 0) {
+		if (part_efi_repair(dev_desc, h_gpt_pte, h_gpt_head,
+				    head_gpt_valid, backup_gpt_valid))
+			printf("Backup GPT repair fail!\n");
+	} else if (head_gpt_valid == 0 && backup_gpt_valid == 1) {
+		if (part_efi_repair(dev_desc, b_gpt_pte, b_gpt_head,
+				    head_gpt_valid, backup_gpt_valid))
+			printf("Primary GPT repair fail!\n");
+	} else if (head_gpt_valid == 0 && backup_gpt_valid == 0) {
+		ret = -1;
+	}
+
+	free(h_gpt_pte);
+	h_gpt_pte = NULL;
+	free(h_gpt_head);
+	h_gpt_head = NULL;
+	free(b_gpt_pte);
+	b_gpt_pte = NULL;
+	free(b_gpt_head);
+	b_gpt_head = NULL;
+#endif
+#endif
+	return ret;
 }
 
 /**
@@ -360,7 +525,7 @@ static int set_protective_mbr(struct blk_desc *dev_desc)
 
 	/* Read MBR to backup boot code if it exists */
 	if (blk_dread(dev_desc, 0, 1, p_mbr) != 1) {
-		error("** Can't read from device %d **\n", dev_desc->devnum);
+		pr_err("** Can't read from device %d **\n", dev_desc->devnum);
 		return -1;
 	}
 
@@ -469,8 +634,8 @@ int gpt_fill_pte(struct blk_desc *dev_desc,
 		 * If our partition overlaps with either the GPT
 		 * header, or the partition entry, reject it.
 		 */
-		if (((start <= hdr_end && hdr_start <= (start + size)) ||
-		     (start <= pte_end && pte_start <= (start + size)))) {
+		if (((start < hdr_end && hdr_start < (start + size)) ||
+		     (start < pte_end && pte_start < (start + size)))) {
 			printf("Partition overlap\n");
 			return -1;
 		}
@@ -622,25 +787,27 @@ int gpt_fill_header(struct blk_desc *dev_desc, gpt_header *gpt_h,
 int gpt_restore(struct blk_desc *dev_desc, char *str_disk_guid,
 		disk_partition_t *partitions, int parts_count)
 {
-	int ret;
-
-	gpt_header *gpt_h = calloc(1, PAD_TO_BLOCKSIZE(sizeof(gpt_header),
-						       dev_desc));
+	gpt_header *gpt_h;
 	gpt_entry *gpt_e;
+	int ret, size;
 
+	size = PAD_TO_BLOCKSIZE(sizeof(gpt_header), dev_desc);
+	gpt_h = malloc_cache_aligned(size);
 	if (gpt_h == NULL) {
 		printf("%s: calloc failed!\n", __func__);
 		return -1;
 	}
+	memset(gpt_h, 0, size);
 
-	gpt_e = calloc(1, PAD_TO_BLOCKSIZE(GPT_ENTRY_NUMBERS
-					       * sizeof(gpt_entry),
-					       dev_desc));
+	size = PAD_TO_BLOCKSIZE(GPT_ENTRY_NUMBERS * sizeof(gpt_entry),
+				dev_desc);
+	gpt_e = malloc_cache_aligned(size);
 	if (gpt_e == NULL) {
 		printf("%s: calloc failed!\n", __func__);
 		free(gpt_h);
 		return -1;
 	}
+	memset(gpt_e, 0, size);
 
 	/* Generate Primary GPT header (LBA1) */
 	ret = gpt_fill_header(dev_desc, gpt_h, str_disk_guid, parts_count);
@@ -661,9 +828,18 @@ err:
 	return ret;
 }
 
-static void gpt_convert_efi_name_to_char(char *s, efi_char16_t *es, int n)
+/**
+ * gpt_convert_efi_name_to_char() - convert u16 string to char string
+ *
+ * TODO: this conversion only supports ANSI characters
+ *
+ * @s:	target buffer
+ * @es:	u16 string to be converted
+ * @n:	size of target buffer
+ */
+static void gpt_convert_efi_name_to_char(char *s, void *es, int n)
 {
-	char *ess = (char *)es;
+	char *ess = es;
 	int i, j;
 
 	memset(s, '\0', n);
@@ -716,7 +892,7 @@ int gpt_verify_partitions(struct blk_desc *dev_desc,
 
 	for (i = 0; i < parts; i++) {
 		if (i == gpt_head->num_partition_entries) {
-			error("More partitions than allowed!\n");
+			pr_err("More partitions than allowed!\n");
 			return -1;
 		}
 
@@ -729,7 +905,7 @@ int gpt_verify_partitions(struct blk_desc *dev_desc,
 
 		if (strncmp(efi_str, (char *)partitions[i].name,
 			    sizeof(partitions->name))) {
-			error("Partition name: %s does not match %s!\n",
+			pr_err("Partition name: %s does not match %s!\n",
 			      efi_str, (char *)partitions[i].name);
 			return -1;
 		}
@@ -746,7 +922,7 @@ int gpt_verify_partitions(struct blk_desc *dev_desc,
 			if ((i == parts - 1) && (partitions[i].size == 0))
 				continue;
 
-			error("Partition %s size: %llu does not match %llu!\n",
+			pr_err("Partition %s size: %llu does not match %llu!\n",
 			      efi_str, (unsigned long long)gpt_part_size,
 			      (unsigned long long)partitions[i].size);
 			return -1;
@@ -767,7 +943,7 @@ int gpt_verify_partitions(struct blk_desc *dev_desc,
 		      (unsigned long long)partitions[i].start);
 
 		if (le64_to_cpu(gpt_e[i].starting_lba) != partitions[i].start) {
-			error("Partition %s start: %llu does not match %llu!\n",
+			pr_err("Partition %s start: %llu does not match %llu!\n",
 			      efi_str, le64_to_cpu(gpt_e[i].starting_lba),
 			      (unsigned long long)partitions[i].start);
 			return -1;
@@ -785,6 +961,14 @@ int is_valid_gpt_buf(struct blk_desc *dev_desc, void *buf)
 	/* determine start of GPT Header in the buffer */
 	gpt_h = buf + (GPT_PRIMARY_PARTITION_TABLE_LBA *
 		       dev_desc->blksz);
+
+	if ((le64_to_cpu(gpt_h->alternate_lba) + 1)
+			!= cpu_to_le64(dev_desc->lba)) {
+		printf("%s: failed checking '%s'\n", __func__,
+		       "invalid GPT Disk Size");
+		return -1;
+	}
+
 	if (validate_gpt_header(gpt_h, GPT_PRIMARY_PARTITION_TABLE_LBA,
 				dev_desc->lba))
 		return -1;
@@ -899,6 +1083,18 @@ static int is_pmbr_valid(legacy_mbr * mbr)
 {
 	int i = 0;
 
+#ifdef CONFIG_RKIMG_BOOTLOADER
+	/*
+	 * In sd-update card, we use RKPARM partition in bootloader to load
+	 * firmware, and use MS-DOS partition in recovery to update system.
+	 * Now, we want to use gpt in bootloader and abandon the RKPARM
+	 * partition. So in new sd-update card, we write the MS-DOS partition
+	 * table and gpt to sd card. Then we must return 1 directly when test
+	 * the mbr sector otherwise the gpt is unavailable.
+	 */
+	return 1;
+#endif
+
 	if (!mbr || le16_to_cpu(mbr->signature) != MSDOS_MBR_SIGNATURE)
 		return 0;
 
@@ -923,11 +1119,24 @@ static int is_pmbr_valid(legacy_mbr * mbr)
 static int is_gpt_valid(struct blk_desc *dev_desc, u64 lba,
 			gpt_header *pgpt_head, gpt_entry **pgpt_pte)
 {
+	/* Confirm valid arguments prior to allocation. */
 	if (!dev_desc || !pgpt_head) {
 		printf("%s: Invalid Argument(s)\n", __func__);
 		return 0;
 	}
 
+	/* Re-use pte if it's not NULL */
+	if (*pgpt_pte)
+		return 1;
+
+	ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);
+
+	/* Read MBR Header from device */
+	if (blk_dread(dev_desc, 0, 1, (ulong *)mbr) != 1) {
+		printf("*** ERROR: Can't read MBR header ***\n");
+		return 0;
+	}
+
 	/* Read GPT Header from device */
 	if (blk_dread(dev_desc, (lbaint_t)lba, 1, pgpt_head) != 1) {
 		printf("*** ERROR: Can't read GPT header ***\n");
@@ -937,6 +1146,18 @@ static int is_gpt_valid(struct blk_desc *dev_desc, u64 lba,
 	if (validate_gpt_header(pgpt_head, (lbaint_t)lba, dev_desc->lba))
 		return 0;
 
+	if (dev_desc->sig_type == SIG_TYPE_NONE) {
+		efi_guid_t empty = {};
+		if (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {
+			dev_desc->sig_type = SIG_TYPE_GUID;
+			memcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,
+			      sizeof(empty));
+		} else if (mbr->unique_mbr_signature != 0) {
+			dev_desc->sig_type = SIG_TYPE_MBR;
+			dev_desc->mbr_sig = mbr->unique_mbr_signature;
+		}
+	}
+
 	/* Read and allocate Partition Table Entries */
 	*pgpt_pte = alloc_read_gpt_entries(dev_desc, pgpt_head);
 	if (*pgpt_pte == NULL) {
@@ -946,6 +1167,7 @@ static int is_gpt_valid(struct blk_desc *dev_desc, u64 lba,
 
 	if (validate_gpt_entries(pgpt_head, *pgpt_pte)) {
 		free(*pgpt_pte);
+		*pgpt_pte = NULL;
 		return 0;
 	}
 
diff --git a/disk/part_iso.c b/disk/part_iso.c
index 8aef251f4e..4036b00b25 100644
--- a/disk/part_iso.c
+++ b/disk/part_iso.c
@@ -202,7 +202,7 @@ found:
 static int part_get_info_iso(struct blk_desc *dev_desc, int part_num,
 				  disk_partition_t *info)
 {
-	return part_get_info_iso_verb(dev_desc, part_num, info, 1);
+	return part_get_info_iso_verb(dev_desc, part_num, info, 0);
 }
 
 static void part_print_iso(struct blk_desc *dev_desc)
@@ -228,7 +228,7 @@ static int part_test_iso(struct blk_desc *dev_desc)
 {
 	disk_partition_t info;
 
-	return part_get_info_iso_verb(dev_desc, 1, &info, 1);
+	return part_get_info_iso_verb(dev_desc, 1, &info, 0);
 }
 
 U_BOOT_PART_TYPE(iso) = {
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 613e60235d..21ed0cf56c 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -10,12 +10,16 @@ source "drivers/ata/Kconfig"
 
 source "drivers/block/Kconfig"
 
+source "drivers/bootcount/Kconfig"
+
 source "drivers/clk/Kconfig"
 
 source "drivers/cpu/Kconfig"
 
 source "drivers/crypto/Kconfig"
 
+source "drivers/rng/Kconfig"
+
 source "drivers/ddr/Kconfig"
 
 source "drivers/demo/Kconfig"
@@ -72,6 +76,10 @@ source "drivers/remoteproc/Kconfig"
 
 source "drivers/reset/Kconfig"
 
+source "drivers/rknand/Kconfig"
+
+source "drivers/rkflash/Kconfig"
+
 source "drivers/rtc/Kconfig"
 
 source "drivers/scsi/Kconfig"
@@ -98,6 +106,8 @@ source "drivers/video/Kconfig"
 
 source "drivers/watchdog/Kconfig"
 
+source "drivers/irq/Kconfig"
+
 config PHYS_TO_BUS
 	bool "Custom physical to bus address mapping"
 	help
diff --git a/drivers/Makefile b/drivers/Makefile
index dab5c182c2..3a9a55ad84 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -4,11 +4,14 @@
 
 obj-$(CONFIG_$(SPL_TPL_)CLK) += clk/
 obj-$(CONFIG_$(SPL_TPL_)DM) += core/
+obj-$(CONFIG_$(SPL_TPL_)DM_CRYPTO) += crypto/
+obj-$(CONFIG_$(SPL_TPL_)DM_RNG) += rng/
 obj-$(CONFIG_$(SPL_TPL_)DRIVERS_MISC_SUPPORT) += misc/ sysreset/ firmware/
 obj-$(CONFIG_$(SPL_TPL_)I2C_SUPPORT) += i2c/
 obj-$(CONFIG_$(SPL_TPL_)LED) += led/
+obj-$(CONFIG_$(SPL_TPL_)INPUT) += input/
 obj-$(CONFIG_$(SPL_TPL_)MMC_SUPPORT) += mmc/
-obj-$(CONFIG_$(SPL_TPL_)NAND_SUPPORT) += mtd/nand/
+obj-$(CONFIG_$(SPL_TPL_)NAND_SUPPORT) += mtd/nand/raw/
 obj-$(CONFIG_$(SPL_TPL_)PHY) += phy/
 obj-$(CONFIG_$(SPL_TPL_)PINCTRL) += pinctrl/
 obj-$(CONFIG_$(SPL_TPL_)RAM) += ram/
@@ -16,10 +19,11 @@ obj-$(CONFIG_$(SPL_TPL_)SERIAL_SUPPORT) += serial/
 obj-$(CONFIG_$(SPL_TPL_)SPI_FLASH_SUPPORT) += mtd/spi/
 obj-$(CONFIG_$(SPL_TPL_)SPI_SUPPORT) += spi/
 obj-$(CONFIG_$(SPL_TPL_)TIMER) += timer/
+obj-$(CONFIG_$(SPL_TPL_)IRQ) += irq/
 
 ifndef CONFIG_TPL_BUILD
 ifdef CONFIG_SPL_BUILD
-
+obj-$(CONFIG_SPL_ADC_SUPPORT) += adc/
 obj-$(CONFIG_SPL_CPU_SUPPORT) += cpu/
 obj-$(CONFIG_SPL_CRYPTO_SUPPORT) += crypto/
 obj-$(CONFIG_SPL_GPIO_SUPPORT) += gpio/
@@ -27,8 +31,12 @@ obj-$(CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT) += ddr/fsl/
 obj-$(CONFIG_ARMADA_38X) += ddr/marvell/a38x/
 obj-$(CONFIG_ARMADA_XP) += ddr/marvell/axp/
 obj-$(CONFIG_ALTERA_SDRAM) += ddr/altera/
-obj-$(CONFIG_SPL_POWER_SUPPORT) += power/ power/pmic/
-obj-$(CONFIG_SPL_POWER_SUPPORT) += power/regulator/
+obj-$(CONFIG_SPL_POWER_SUPPORT) += power/
+obj-$(CONFIG_SPL_DM_PMIC) += power/pmic/
+obj-$(CONFIG_SPL_DM_REGULATOR) += power/regulator/
+obj-$(CONFIG_SPL_DM_FUEL_GAUGE) += power/fuel_gauge/
+obj-$(CONFIG_SPL_DM_FUEL_GAUGE) += power/charge/
+obj-$(CONFIG_SPL_PWM_SUPPORT) += pwm/
 obj-$(CONFIG_SPL_MTD_SUPPORT) += mtd/
 obj-$(CONFIG_SPL_ONENAND_SUPPORT) += mtd/onenand/
 obj-$(CONFIG_SPL_UBI) += mtd/ubispl/
@@ -40,17 +48,22 @@ obj-$(CONFIG_SPL_PCI_SUPPORT) += pci/
 obj-$(CONFIG_SPL_PCH_SUPPORT) += pch/
 obj-$(CONFIG_SPL_RTC_SUPPORT) += rtc/
 obj-$(CONFIG_SPL_MUSB_NEW_SUPPORT) += usb/musb-new/
-obj-$(CONFIG_SPL_USB_GADGET_SUPPORT) += usb/gadget/
-obj-$(CONFIG_SPL_USB_GADGET_SUPPORT) += usb/gadget/udc/
-obj-$(CONFIG_SPL_DFU_SUPPORT) += dfu/
+obj-$(CONFIG_SPL_USB_GADGET) += usb/gadget/
+obj-$(CONFIG_SPL_USB_GADGET) += usb/gadget/udc/
+obj-$(CONFIG_SPL_USB_GADGET) += usb/gadget/
+obj-$(CONFIG_SPL_USB_GADGET) += usb/common/
+obj-$(CONFIG_SPL_USB_GADGET) += usb/gadget/udc/
+obj-$(CONFIG_SPL_DFU) += dfu/
 obj-$(CONFIG_SPL_WATCHDOG_SUPPORT) += watchdog/
 obj-$(CONFIG_SPL_USB_HOST_SUPPORT) += usb/host/
 obj-$(CONFIG_OMAP_USB_PHY) += usb/phy/
 obj-$(CONFIG_SPL_SATA_SUPPORT) += ata/ scsi/
 obj-$(CONFIG_SPL_USB_HOST_SUPPORT) += block/
 obj-$(CONFIG_SPL_MMC_SUPPORT) += block/
+obj-$(CONFIG_SPL_MTD_SUPPORT) += block/
 obj-$(CONFIG_SPL_FPGA_SUPPORT) += fpga/
-
+obj-$(CONFIG_SPL_RKNAND_SUPPORT) += rknand/
+obj-$(CONFIG_SPL_RKNAND_SUPPORT) += block/
 endif
 endif
 
@@ -75,7 +88,10 @@ obj-$(CONFIG_FPGA) += fpga/
 obj-y += misc/
 obj-$(CONFIG_MMC) += mmc/
 obj-$(CONFIG_NVME) += nvme/
+obj-$(CONFIG_RKNAND) += rknand/
+obj-$(CONFIG_RKFLASH) += rkflash/
 obj-y += pcmcia/
+obj-$(CONFIG_DM_POWER_DELIVERY) += power/power_delivery/
 obj-y += dfu/
 obj-$(CONFIG_X86) += pch/
 obj-y += phy/marvell/
@@ -92,7 +108,6 @@ obj-$(CONFIG_U_QE) += qe/
 obj-y += mailbox/
 obj-y += memory/
 obj-y += pwm/
-obj-y += reset/
 obj-y += input/
 # SOC specific infrastructure drivers.
 obj-y += soc/
@@ -101,3 +116,6 @@ obj-y += thermal/
 
 obj-$(CONFIG_MACH_PIC32) += ddr/microchip/
 endif
+
+obj-$(CONFIG_$(SPL_TPL_)DM_RESET) += reset/
+
diff --git a/drivers/adc/Kconfig b/drivers/adc/Kconfig
index e5335f7234..007dadc837 100644
--- a/drivers/adc/Kconfig
+++ b/drivers/adc/Kconfig
@@ -11,6 +11,13 @@ config ADC
 	  - support supply's phandle with auto-enable
 	  - supply polarity setting in fdt
 
+config ADC_REQ_REGULATOR
+	bool "Enable regulator control for ADC drivers"
+	depends on ADC
+	default n
+	help
+	  ADC may depend on regulator power supply and require control.
+
 config ADC_EXYNOS
 	bool "Enable Exynos 54xx ADC driver"
 	help
@@ -28,3 +35,21 @@ config ADC_SANDBOX
 	  - 4 analog input channels
 	  - 16-bit resolution
 	  - single and multi-channel conversion mode
+
+config SARADC_ROCKCHIP
+	bool "Enable Rockchip SARADC driver"
+	help
+	  This enables driver for Rockchip SARADC.
+	  It provides:
+	  - 2~6 analog input channels
+	  - 1O or 12 bits resolution
+	  - Up to 1MSPS of sample rate
+
+config SARADC_ROCKCHIP_V2
+	bool "Enable Rockchip SARADC v2 driver"
+	help
+	  This enables driver for Rockchip SARADC v2.
+	  It provides:
+	  - 8 analog input channels
+	  - 12 bits resolution
+	  - Up to 1MSPS of sample rate
diff --git a/drivers/adc/Makefile b/drivers/adc/Makefile
index cebf26de07..3c0d9b066a 100644
--- a/drivers/adc/Makefile
+++ b/drivers/adc/Makefile
@@ -8,3 +8,5 @@
 obj-$(CONFIG_ADC) += adc-uclass.o
 obj-$(CONFIG_ADC_EXYNOS) += exynos-adc.o
 obj-$(CONFIG_ADC_SANDBOX) += sandbox.o
+obj-$(CONFIG_SARADC_ROCKCHIP) += rockchip-saradc.o
+obj-$(CONFIG_SARADC_ROCKCHIP_V2) += rockchip-saradc-v2.o
diff --git a/drivers/adc/adc-uclass.c b/drivers/adc/adc-uclass.c
index a5ef722d21..e8c7262b09 100644
--- a/drivers/adc/adc-uclass.c
+++ b/drivers/adc/adc-uclass.c
@@ -47,6 +47,7 @@ static int check_channel(struct udevice *dev, int value, bool number_or_mask,
 	return -EINVAL;
 }
 
+#ifdef CONFIG_ADC_REQ_REGULATOR
 static int adc_supply_enable(struct udevice *dev)
 {
 	struct adc_uclass_platdata *uc_pdata = dev_get_uclass_platdata(dev);
@@ -64,10 +65,13 @@ static int adc_supply_enable(struct udevice *dev)
 	}
 
 	if (ret)
-		error("%s: can't enable %s-supply!", dev->name, supply_type);
+		pr_err("%s: can't enable %s-supply!", dev->name, supply_type);
 
 	return ret;
 }
+#else
+static inline int adc_supply_enable(struct udevice *dev) { return 0; }
+#endif
 
 int adc_data_mask(struct udevice *dev, unsigned int *data_mask)
 {
@@ -256,6 +260,7 @@ try_manual:
 	return _adc_channels_single_shot(dev, channel_mask, channels);
 }
 
+#ifdef CONFIG_ADC_REQ_REGULATOR
 static int adc_vdd_platdata_update(struct udevice *dev)
 {
 	struct adc_uclass_platdata *uc_pdata = dev_get_uclass_platdata(dev);
@@ -280,7 +285,11 @@ static int adc_vdd_platdata_update(struct udevice *dev)
 
 	return 0;
 }
+#else
+static inline int adc_vdd_platdata_update(struct udevice *dev) { return 0; }
+#endif
 
+#ifdef CONFIG_ADC_REQ_REGULATOR
 static int adc_vss_platdata_update(struct udevice *dev)
 {
 	struct adc_uclass_platdata *uc_pdata = dev_get_uclass_platdata(dev);
@@ -299,6 +308,9 @@ static int adc_vss_platdata_update(struct udevice *dev)
 
 	return 0;
 }
+#else
+static inline int adc_vss_platdata_update(struct udevice *dev) { return 0; }
+#endif
 
 int adc_vdd_value(struct udevice *dev, int *uV)
 {
@@ -389,12 +401,12 @@ static int adc_pre_probe(struct udevice *dev)
 	/* Set ADC VDD platdata: polarity, uV, regulator (phandle). */
 	ret = adc_vdd_platdata_set(dev);
 	if (ret)
-		error("%s: Can't update Vdd. Error: %d", dev->name, ret);
+		pr_err("%s: Can't update Vdd. Error: %d", dev->name, ret);
 
 	/* Set ADC VSS platdata: polarity, uV, regulator (phandle). */
 	ret = adc_vss_platdata_set(dev);
 	if (ret)
-		error("%s: Can't update Vss. Error: %d", dev->name, ret);
+		pr_err("%s: Can't update Vss. Error: %d", dev->name, ret);
 
 	return 0;
 }
diff --git a/drivers/adc/exynos-adc.c b/drivers/adc/exynos-adc.c
index 324d72f3a9..3bb065d215 100644
--- a/drivers/adc/exynos-adc.c
+++ b/drivers/adc/exynos-adc.c
@@ -22,7 +22,7 @@ int exynos_adc_channel_data(struct udevice *dev, int channel,
 	struct exynos_adc_v2 *regs = priv->regs;
 
 	if (channel != priv->active_channel) {
-		error("Requested channel is not active!");
+		pr_err("Requested channel is not active!");
 		return -EINVAL;
 	}
 
@@ -80,7 +80,7 @@ int exynos_adc_probe(struct udevice *dev)
 
 	/* Check HW version */
 	if (readl(&regs->version) != ADC_V2_VERSION) {
-		error("This driver supports only ADC v2!");
+		pr_err("This driver supports only ADC v2!");
 		return -ENXIO;
 	}
 
@@ -109,7 +109,7 @@ int exynos_adc_ofdata_to_platdata(struct udevice *dev)
 
 	priv->regs = (struct exynos_adc_v2 *)devfdt_get_addr(dev);
 	if (priv->regs == (struct exynos_adc_v2 *)FDT_ADDR_T_NONE) {
-		error("Dev: %s - can't get address!", dev->name);
+		pr_err("Dev: %s - can't get address!", dev->name);
 		return -ENODATA;
 	}
 
diff --git a/drivers/adc/sandbox.c b/drivers/adc/sandbox.c
index 371892237a..80e8e3701a 100644
--- a/drivers/adc/sandbox.c
+++ b/drivers/adc/sandbox.c
@@ -61,7 +61,7 @@ int sandbox_adc_channel_data(struct udevice *dev, int channel,
 	/* For single-channel conversion mode, check if channel was selected */
 	if ((priv->conversion_mode == SANDBOX_ADC_MODE_SINGLE_CHANNEL) &&
 	    !(priv->active_channel_mask & (1 << channel))) {
-		error("Request for an inactive channel!");
+		pr_err("Request for an inactive channel!");
 		return -EINVAL;
 	}
 
@@ -82,12 +82,12 @@ int sandbox_adc_channels_data(struct udevice *dev, unsigned int channel_mask,
 
 	/* Return error for single-channel conversion mode */
 	if (priv->conversion_mode == SANDBOX_ADC_MODE_SINGLE_CHANNEL) {
-		error("ADC in single-channel mode!");
+		pr_err("ADC in single-channel mode!");
 		return -EPERM;
 	}
 	/* Check channel selection */
 	if (!(priv->active_channel_mask & channel_mask)) {
-		error("Request for an inactive channel!");
+		pr_err("Request for an inactive channel!");
 		return -EINVAL;
 	}
 	/* The conversion must be started before reading the data */
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 803064aaf1..a587349a52 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -20,6 +20,17 @@ config SATA
 
 	  See also CMD_SATA which provides command-line support.
 
+config LIBATA
+	bool
+	help
+	  Select this to build and link the libata helper functions.
+
+config SCSI_AHCI
+	bool "Enable SCSI interface to SATA devices"
+	select LIBATA
+	help
+	  Enable this to allow interfacing SATA devices via the SCSI layer.
+
 menu "SATA/SCSI device support"
 
 config AHCI_PCI
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 5e4df19386..ad952f8ddf 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -1,15 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) Freescale Semiconductor, Inc. 2006.
  * Author: Jason Jin<Jason.jin@freescale.com>
  *         Zhang Wei<wei.zhang@freescale.com>
  *
- * SPDX-License-Identifier:	GPL-2.0+
- *
  * with the reference on libata and ahci drvier in kernel
  *
  * This driver provides a SCSI interface to SATA.
  */
 #include <common.h>
+#include <blk.h>
+#include <log.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
 
 #include <command.h>
 #include <dm.h>
@@ -51,22 +54,13 @@ struct ahci_uc_priv *probe_ent = NULL;
 #define WAIT_MS_FLUSH	5000
 #define WAIT_MS_LINKUP	200
 
+#define AHCI_CAP_S64A BIT(31)
+
 __weak void __iomem *ahci_port_base(void __iomem *base, u32 port)
 {
 	return base + 0x100 + (port * 0x80);
 }
 
-
-static void ahci_setup_port(struct ahci_ioports *port, void __iomem *base,
-			    unsigned int port_idx)
-{
-	base = ahci_port_base(base, port_idx);
-
-	port->cmd_addr = base;
-	port->scr_addr = base + PORT_SCR;
-}
-
-
 #define msleep(a) udelay(a * 1000)
 
 static void ahci_dcache_flush_range(unsigned long begin, unsigned long len)
@@ -231,15 +225,16 @@ static int ahci_host_init(struct ahci_uc_priv *uc_priv)
 	debug("cap 0x%x  port_map 0x%x  n_ports %d\n",
 	      uc_priv->cap, uc_priv->port_map, uc_priv->n_ports);
 
+#if !defined(CONFIG_DM_SCSI)
 	if (uc_priv->n_ports > CONFIG_SYS_SCSI_MAX_SCSI_ID)
 		uc_priv->n_ports = CONFIG_SYS_SCSI_MAX_SCSI_ID;
+#endif
 
 	for (i = 0; i < uc_priv->n_ports; i++) {
 		if (!(port_map & (1 << i)))
 			continue;
 		uc_priv->port[i].port_mmio = ahci_port_base(mmio, i);
 		port_mmio = (u8 *)uc_priv->port[i].port_mmio;
-		ahci_setup_port(&uc_priv->port[i], mmio, i);
 
 		/* make sure port is not active */
 		tmp = readl(port_mmio + PORT_CMD);
@@ -514,9 +509,15 @@ static int ahci_fill_sg(struct ahci_uc_priv *uc_priv, u8 port,
 	}
 
 	for (i = 0; i < sg_count; i++) {
-		ahci_sg->addr =
-		    cpu_to_le32((unsigned long) buf + i * MAX_DATA_BYTE_COUNT);
-		ahci_sg->addr_hi = 0;
+		/* We assume virt=phys */
+		phys_addr_t pa = (unsigned long)buf + i * MAX_DATA_BYTE_COUNT;
+
+		ahci_sg->addr = cpu_to_le32(lower_32_bits(pa));
+		ahci_sg->addr_hi = cpu_to_le32(upper_32_bits(pa));
+		if (ahci_sg->addr_hi && !(uc_priv->cap & AHCI_CAP_S64A)) {
+			printf("Error: DMA address too high\n");
+			return -1;
+		}
 		ahci_sg->flags_size = cpu_to_le32(0x3fffff &
 					  (buf_len < MAX_DATA_BYTE_COUNT
 					   ? (buf_len - 1)
@@ -559,6 +560,7 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 {
 	struct ahci_ioports *pp = &(uc_priv->port[port]);
 	void __iomem *port_mmio = pp->port_mmio;
+	u64 dma_addr;
 	u32 port_status;
 	void __iomem *mem;
 
@@ -570,15 +572,12 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 		return -1;
 	}
 
-	mem = malloc(AHCI_PORT_PRIV_DMA_SZ + 2048);
+	mem = memalign(2048, AHCI_PORT_PRIV_DMA_SZ);
 	if (!mem) {
 		free(pp);
 		printf("%s: No mem for table!\n", __func__);
 		return -ENOMEM;
 	}
-
-	/* Aligned to 2048-bytes */
-	mem = memalign(2048, AHCI_PORT_PRIV_DMA_SZ);
 	memset(mem, 0, AHCI_PORT_PRIV_DMA_SZ);
 
 	/*
@@ -607,10 +606,12 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 	pp->cmd_tbl_sg =
 			(struct ahci_sg *)(uintptr_t)virt_to_phys((void *)mem);
 
-	writel_with_flush((unsigned long)pp->cmd_slot,
-			  port_mmio + PORT_LST_ADDR);
-
-	writel_with_flush(pp->rx_fis, port_mmio + PORT_FIS_ADDR);
+	dma_addr = (ulong)pp->cmd_slot;
+	writel_with_flush(dma_addr, port_mmio + PORT_LST_ADDR);
+	writel_with_flush(dma_addr >> 32, port_mmio + PORT_LST_ADDR_HI);
+	dma_addr = (ulong)pp->rx_fis;
+	writel_with_flush(dma_addr, port_mmio + PORT_FIS_ADDR);
+	writel_with_flush(dma_addr >> 32, port_mmio + PORT_FIS_ADDR_HI);
 
 #ifdef CONFIG_SUNXI_AHCI
 	sunxi_dma_init(port_mmio);
@@ -981,7 +982,7 @@ static int ahci_start_ports(struct ahci_uc_priv *uc_priv)
 
 	linkmap = uc_priv->link_port_map;
 
-	for (i = 0; i < CONFIG_SYS_SCSI_MAX_SCSI_ID; i++) {
+	for (i = 0; i < uc_priv->n_ports; i++) {
 		if (((linkmap >> i) & 0x01)) {
 			if (ahci_port_start(uc_priv, (u8) i)) {
 				printf("Can not start port %d\n", i);
@@ -1181,6 +1182,17 @@ int ahci_probe_scsi(struct udevice *ahci_dev, ulong base)
 	if (ret)
 		return ret;
 
+	/*
+	 * scsi_scan_dev() scans devices up-to the number of max_id.
+	 * Update max_id if the number of detected ports exceeds max_id.
+	 * This allows SCSI to scan all detected ports.
+	 */
+	uc_plat->max_id = max_t(unsigned long, uc_priv->n_ports,
+				uc_plat->max_id);
+	/* If port count is less than max_id, update max_id */
+	if (uc_priv->n_ports < uc_plat->max_id)
+		uc_plat->max_id = uc_priv->n_ports;
+
 	return 0;
 }
 
diff --git a/drivers/ata/dwc_ahci.c b/drivers/ata/dwc_ahci.c
index f6147989b1..f1af56b28e 100644
--- a/drivers/ata/dwc_ahci.c
+++ b/drivers/ata/dwc_ahci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * DWC SATA platform driver
  *
@@ -5,8 +6,6 @@
  *     Texas Instruments Incorporated, <www.ti.com>
  *
  * Author: Mugunthan V N <mugunthanvnm@ti.com>
- *
- * SPDX-License-Identifier:     GPL-2.0+
  */
 
 #include <common.h>
@@ -14,29 +13,27 @@
 #include <ahci.h>
 #include <scsi.h>
 #include <sata.h>
-#include <asm/arch/sata.h>
 #include <asm/io.h>
 #include <generic-phy.h>
 
-DECLARE_GLOBAL_DATA_PTR;
-
 struct dwc_ahci_priv {
 	void *base;
 	void *wrapper_base;
 };
 
+static int dwc_ahci_bind(struct udevice *dev)
+{
+	struct udevice *scsi_dev;
+
+	return ahci_bind_scsi(dev, &scsi_dev);
+}
+
 static int dwc_ahci_ofdata_to_platdata(struct udevice *dev)
 {
 	struct dwc_ahci_priv *priv = dev_get_priv(dev);
-	struct scsi_platdata *plat = dev_get_uclass_platdata(dev);
 	fdt_addr_t addr;
 
-	plat->max_id = fdtdec_get_uint(gd->fdt_blob, dev_of_offset(dev),
-				       "max-id", CONFIG_SYS_SCSI_MAX_SCSI_ID);
-	plat->max_lun = fdtdec_get_uint(gd->fdt_blob, dev_of_offset(dev),
-					"max-lun", CONFIG_SYS_SCSI_MAX_LUN);
-
-	priv->base = map_physmem(devfdt_get_addr(dev), sizeof(void *),
+	priv->base = map_physmem(dev_read_addr(dev), sizeof(void *),
 				 MAP_NOCACHE);
 
 	addr = devfdt_get_addr_index(dev, 1);
@@ -58,34 +55,23 @@ static int dwc_ahci_probe(struct udevice *dev)
 
 	ret = generic_phy_get_by_name(dev, "sata-phy", &phy);
 	if (ret) {
-		error("can't get the phy from DT\n");
+		pr_err("can't get the phy from DT\n");
 		return ret;
 	}
 
 	ret = generic_phy_init(&phy);
 	if (ret) {
-		error("unable to initialize the sata phy\n");
+		pr_err("unable to initialize the sata phy\n");
 		return ret;
 	}
 
 	ret = generic_phy_power_on(&phy);
 	if (ret) {
-		error("unable to power on the sata phy\n");
+		pr_err("unable to power on the sata phy\n");
 		return ret;
 	}
 
-	if (priv->wrapper_base) {
-		u32 val = TI_SATA_IDLE_NO | TI_SATA_STANDBY_NO;
-
-		/* Enable SATA module, No Idle, No Standby */
-		writel(val, priv->wrapper_base + TI_SATA_SYSCONFIG);
-	}
-
-	ret = ahci_init_dm(dev, priv->base);
-	if (ret)
-		return ret;
-
-	return achi_start_ports_dm(dev);
+	return ahci_probe_scsi(dev, (ulong)priv->base);
 }
 
 static const struct udevice_id dwc_ahci_ids[] = {
@@ -95,11 +81,11 @@ static const struct udevice_id dwc_ahci_ids[] = {
 
 U_BOOT_DRIVER(dwc_ahci) = {
 	.name	= "dwc_ahci",
-	.id	= UCLASS_SCSI,
+	.id	= UCLASS_AHCI,
 	.of_match = dwc_ahci_ids,
+	.bind	= dwc_ahci_bind,
 	.ofdata_to_platdata = dwc_ahci_ofdata_to_platdata,
 	.ops	= &scsi_ops,
 	.probe	= dwc_ahci_probe,
-	.priv_auto_alloc_size = sizeof(struct dwc_ahci_priv),
-	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+	.priv_auto_alloc_size	= sizeof(struct dwc_ahci_priv),
 };
diff --git a/drivers/ata/sata_dwc.c b/drivers/ata/sata_dwc.c
index a226ca2dec..2f3b2ddb41 100644
--- a/drivers/ata/sata_dwc.c
+++ b/drivers/ata/sata_dwc.c
@@ -26,6 +26,7 @@
 #include <command.h>
 #include <pci.h>
 #include <asm/processor.h>
+#include <linux/dma-direction.h>
 #include <linux/errno.h>
 #include <asm/io.h>
 #include <malloc.h>
diff --git a/drivers/ata/sata_dwc.h b/drivers/ata/sata_dwc.h
index e2d9e0c1fc..17fb20cf43 100644
--- a/drivers/ata/sata_dwc.h
+++ b/drivers/ata/sata_dwc.h
@@ -401,13 +401,6 @@ struct ata_device {
 #endif
 };
 
-enum dma_data_direction {
-	DMA_BIDIRECTIONAL = 0,
-	DMA_TO_DEVICE = 1,
-	DMA_FROM_DEVICE = 2,
-	DMA_NONE = 3,
-};
-
 struct ata_link {
 	struct ata_port		*ap;
 	int			pmp;
diff --git a/drivers/bios_emulator/include/x86emu/x86emui.h b/drivers/bios_emulator/include/x86emu/x86emui.h
index a74957d992..3537255539 100644
--- a/drivers/bios_emulator/include/x86emu/x86emui.h
+++ b/drivers/bios_emulator/include/x86emu/x86emui.h
@@ -72,9 +72,6 @@
 #include <string.h>
 #endif
 
-#define printk printf
-
-
 /*--------------------------- Inline Functions ----------------------------*/
 
 #ifdef  __cplusplus
diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 26760895f9..209fb5ebe6 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -22,6 +22,15 @@ config SPL_BLK
 	  be partitioned into several areas, called 'partitions' in U-Boot.
 	  A filesystem can be placed in each partition.
 
+config SPL_BLK_READ_PREPARE
+	bool "Support block devices prepare to read data in SPL"
+	depends on SPL_BLK
+	help
+	  Enable support for block devices to prefetch data. MMC and mtd_blk
+	  devices can be attached to block devices. It is applied to prefetch
+	  data in the background and the device run some other process in the
+	  same time.
+
 config BLOCK_CACHE
 	bool "Use block device cache"
 	default n
diff --git a/drivers/block/blk-uclass.c b/drivers/block/blk-uclass.c
index 3c5a87b60a..35bdd8d6a0 100644
--- a/drivers/block/blk-uclass.c
+++ b/drivers/block/blk-uclass.c
@@ -10,6 +10,7 @@
 #include <dm.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
+#include <dm/uclass-internal.h>
 
 static const char *if_typename_str[IF_TYPE_COUNT] = {
 	[IF_TYPE_IDE]		= "ide",
@@ -23,6 +24,11 @@ static const char *if_typename_str[IF_TYPE_COUNT] = {
 	[IF_TYPE_HOST]		= "host",
 	[IF_TYPE_SYSTEMACE]	= "ace",
 	[IF_TYPE_NVME]		= "nvme",
+	[IF_TYPE_RKNAND]	= "rknand",
+	[IF_TYPE_SPINAND]	= "spinand",
+	[IF_TYPE_SPINOR]	= "spinor",
+	[IF_TYPE_RAMDISK]	= "ramdisk",
+	[IF_TYPE_MTD]		= "mtd",
 };
 
 static enum uclass_id if_type_uclass_id[IF_TYPE_COUNT] = {
@@ -36,10 +42,15 @@ static enum uclass_id if_type_uclass_id[IF_TYPE_COUNT] = {
 	[IF_TYPE_SATA]		= UCLASS_AHCI,
 	[IF_TYPE_HOST]		= UCLASS_ROOT,
 	[IF_TYPE_NVME]		= UCLASS_NVME,
+	[IF_TYPE_RKNAND]	= UCLASS_RKNAND,
+	[IF_TYPE_SPINAND]	= UCLASS_SPI_FLASH,
+	[IF_TYPE_SPINOR]	= UCLASS_SPI_FLASH,
+	[IF_TYPE_RAMDISK]	= UCLASS_RAMDISK,
+	[IF_TYPE_MTD]		= UCLASS_MTD,
 	[IF_TYPE_SYSTEMACE]	= UCLASS_INVALID,
 };
 
-static enum if_type if_typename_to_iftype(const char *if_typename)
+enum if_type if_typename_to_iftype(const char *if_typename)
 {
 	int i;
 
@@ -115,9 +126,31 @@ struct blk_desc *blk_get_devnum_by_typename(const char *if_typename, int devnum)
 
 		/* Find out the parent device uclass */
 		if (device_get_uclass_id(dev->parent) != uclass_id) {
+#ifdef CONFIG_MTD_BLK
+			/*
+			 * The normal mtd block attachment steps are
+			 * UCLASS_BLK -> UCLASS_MTD -> UCLASS_(SPI or NAND).
+			 * Since the spi flash frame is attached to
+			 * UCLASS_SPI_FLASH, this make mistake to find
+			 * the UCLASS_MTD when find the mtd block device.
+			 * Fix it here when enable CONFIG_MTD_BLK.
+			 */
+			if (device_get_uclass_id(dev->parent) == UCLASS_SPI_FLASH &&
+			    if_type == IF_TYPE_MTD &&
+			    devnum == BLK_MTD_SPI_NOR) {
+				debug("Fix the spi flash uclass different\n");
+			} else {
+				debug("%s: parent uclass %d, this dev %d\n",
+				      __func__,
+				      device_get_uclass_id(dev->parent),
+				      uclass_id);
+				continue;
+			}
+#else
 			debug("%s: parent uclass %d, this dev %d\n", __func__,
 			      device_get_uclass_id(dev->parent), uclass_id);
 			continue;
+#endif
 		}
 
 		if (device_probe(dev))
@@ -294,9 +327,6 @@ ulong blk_read_devnum(enum if_type if_type, int devnum, lbaint_t start,
 	if (IS_ERR_VALUE(n))
 		return n;
 
-	/* flush cache after read */
-	flush_cache((ulong)buffer, blkcnt * desc->blksz);
-
 	return n;
 }
 
@@ -312,6 +342,18 @@ ulong blk_write_devnum(enum if_type if_type, int devnum, lbaint_t start,
 	return blk_dwrite(desc, start, blkcnt, buffer);
 }
 
+ulong blk_erase_devnum(enum if_type if_type, int devnum, lbaint_t start,
+		       lbaint_t blkcnt)
+{
+	struct blk_desc *desc;
+	int ret;
+
+	ret = get_desc(if_type, devnum, &desc);
+	if (ret)
+		return ret;
+	return blk_derase(desc, start, blkcnt);
+}
+
 int blk_select_hwpart(struct udevice *dev, int hwpart)
 {
 	const struct blk_ops *ops = blk_get_ops(dev);
@@ -334,7 +376,7 @@ int blk_first_device(int if_type, struct udevice **devp)
 	struct blk_desc *desc;
 	int ret;
 
-	ret = uclass_first_device(UCLASS_BLK, devp);
+	ret = uclass_find_first_device(UCLASS_BLK, devp);
 	if (ret)
 		return ret;
 	if (!*devp)
@@ -343,7 +385,7 @@ int blk_first_device(int if_type, struct udevice **devp)
 		desc = dev_get_uclass_platdata(*devp);
 		if (desc->if_type == if_type)
 			return 0;
-		ret = uclass_next_device(devp);
+		ret = uclass_find_next_device(devp);
 		if (ret)
 			return ret;
 	} while (*devp);
@@ -359,7 +401,7 @@ int blk_next_device(struct udevice **devp)
 	desc = dev_get_uclass_platdata(*devp);
 	if_type = desc->if_type;
 	do {
-		ret = uclass_next_device(devp);
+		ret = uclass_find_next_device(devp);
 		if (ret)
 			return ret;
 		if (!*devp)
@@ -536,7 +578,17 @@ static int blk_claim_devnum(enum if_type if_type, int devnum)
 
 			if (next < 0)
 				return next;
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+			/*
+			 * Not allow devnum to be forced distributed.
+			 * See commit (e48eeb9ea3 dm: blk: Improve block device claiming).
+			 *
+			 * fix like: "Device 'dwmmc@fe2b0000': seq 0 is in use by 'sdhci@fe310000'"
+			 */
+			if (!(gd->flags & GD_FLG_KDTB_READY))
+#endif
 			desc->devnum = next;
+
 			return 0;
 		}
 	}
diff --git a/drivers/block/blk_legacy.c b/drivers/block/blk_legacy.c
index 981872ecb3..16d3bfe7f2 100644
--- a/drivers/block/blk_legacy.c
+++ b/drivers/block/blk_legacy.c
@@ -232,9 +232,6 @@ ulong blk_read_devnum(enum if_type if_type, int devnum, lbaint_t start,
 	if (IS_ERR_VALUE(n))
 		return n;
 
-	/* flush cache after read */
-	flush_cache((ulong)buffer, blkcnt * desc->blksz);
-
 	return n;
 }
 
diff --git a/drivers/bootcount/Makefile b/drivers/bootcount/Makefile
index ed9659ad97..45445d24bf 100644
--- a/drivers/bootcount/Makefile
+++ b/drivers/bootcount/Makefile
@@ -9,3 +9,4 @@ obj-$(CONFIG_BOOTCOUNT_AM33XX)	+= bootcount_davinci.o
 obj-$(CONFIG_BOOTCOUNT_RAM)	+= bootcount_ram.o
 obj-$(CONFIG_BOOTCOUNT_ENV)	+= bootcount_env.o
 obj-$(CONFIG_BOOTCOUNT_I2C)	+= bootcount_i2c.o
+obj-$(CONFIG_BOOTCOUNT_EXT)	+= bootcount_ext.o
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 7765148876..0dccb39835 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -12,7 +12,7 @@ config CLK
 
 config SPL_CLK
 	bool "Enable clock support in SPL"
-	depends on CLK && SPL_DM
+	depends on CLK && SPL && SPL_DM
 	help
 	  The clock subsystem adds a small amount of overhead to the image.
 	  If this is acceptable and you have a need to use clock drivers in
@@ -61,10 +61,27 @@ config CLK_ZYNQMP
 	  This clock driver adds support for clock realted settings for
 	  ZynqMP platform.
 
+config CLK_SCMI
+	bool "Enable SCMI clock driver"
+	depends on SCMI_FIRMWARE
+	help
+	  Enable this option if you want to support clock devices exposed
+	  by a SCMI agent based on SCMI clock protocol communication
+	  with a SCMI server.
+
+config SPL_CLK_SCMI
+	bool "Enable SCMI clock driver in SPL"
+	depends on SPL_SCMI_FIRMWARE
+	help
+	  Enable this option in SPL if you want to support clock devices exposed
+	  by a SCMI agent based on SCMI clock protocol communication
+	  with a SCMI server.
+
 source "drivers/clk/tegra/Kconfig"
 source "drivers/clk/uniphier/Kconfig"
 source "drivers/clk/exynos/Kconfig"
 source "drivers/clk/at91/Kconfig"
 source "drivers/clk/renesas/Kconfig"
+source "drivers/clk/rockchip/Kconfig"
 
 endmenu
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index b7735933be..92d3ad47b3 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -9,6 +9,9 @@ obj-$(CONFIG_$(SPL_TPL_)CLK) += clk-uclass.o clk_fixed_rate.o
 obj-$(CONFIG_ARCH_ROCKCHIP) += rockchip/
 obj-$(CONFIG_SANDBOX) += clk_sandbox.o
 obj-$(CONFIG_SANDBOX) += clk_sandbox_test.o
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_CLK_SCMI) += clk_scmi.o
+endif
 obj-$(CONFIG_MACH_PIC32) += clk_pic32.o
 obj-$(CONFIG_CLK_RENESAS) += renesas/
 obj-$(CONFIG_CLK_ZYNQ) += clk_zynq.o
diff --git a/drivers/clk/clk-uclass.c b/drivers/clk/clk-uclass.c
index e68d9279b9..a4938c18ad 100644
--- a/drivers/clk/clk-uclass.c
+++ b/drivers/clk/clk-uclass.c
@@ -2,6 +2,7 @@
  * Copyright (C) 2015 Google, Inc
  * Written by Simon Glass <sjg@chromium.org>
  * Copyright (c) 2016, NVIDIA CORPORATION.
+ * Copyright (c) 2018, Theobroma Systems Design und Consulting GmbH
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,20 +11,20 @@
 #include <clk.h>
 #include <clk-uclass.h>
 #include <dm.h>
+#include <dm/device-internal.h>
+#include <dm/read.h>
 #include <dt-structs.h>
 #include <errno.h>
 
-DECLARE_GLOBAL_DATA_PTR;
-
-static inline struct clk_ops *clk_dev_ops(struct udevice *dev)
+static inline const struct clk_ops *clk_dev_ops(struct udevice *dev)
 {
-	return (struct clk_ops *)dev->driver->ops;
+	return (const struct clk_ops *)dev->driver->ops;
 }
 
 #if CONFIG_IS_ENABLED(OF_CONTROL)
 # if CONFIG_IS_ENABLED(OF_PLATDATA)
 int clk_get_by_index_platdata(struct udevice *dev, int index,
-			      struct phandle_2_cell *cells, struct clk *clk)
+			      struct phandle_1_arg *cells, struct clk *clk)
 {
 	int ret;
 
@@ -32,7 +33,7 @@ int clk_get_by_index_platdata(struct udevice *dev, int index,
 	ret = uclass_get_device(UCLASS_CLK, 0, &clk->dev);
 	if (ret)
 		return ret;
-	clk->id = cells[0].id;
+	clk->id = cells[0].arg[0];
 
 	return 0;
 }
@@ -55,20 +56,21 @@ static int clk_of_xlate_default(struct clk *clk,
 	return 0;
 }
 
-int clk_get_by_index(struct udevice *dev, int index, struct clk *clk)
+static int clk_get_by_indexed_prop(struct udevice *dev, const char *prop_name,
+				   int index, struct clk *clk)
 {
 	int ret;
 	struct ofnode_phandle_args args;
 	struct udevice *dev_clk;
-	struct clk_ops *ops;
+	const struct clk_ops *ops;
 
 	debug("%s(dev=%p, index=%d, clk=%p)\n", __func__, dev, index, clk);
 
 	assert(clk);
 	clk->dev = NULL;
 
-	ret = dev_read_phandle_with_args(dev, "clocks", "#clock-cells", 0,
-					  index, &args);
+	ret = dev_read_phandle_with_args(dev, prop_name, "#clock-cells", 0,
+					 index, &args);
 	if (ret) {
 		debug("%s: fdtdec_parse_phandle_with_args failed: err=%d\n",
 		      __func__, ret);
@@ -97,6 +99,160 @@ int clk_get_by_index(struct udevice *dev, int index, struct clk *clk)
 
 	return clk_request(dev_clk, clk);
 }
+
+int clk_get_by_index(struct udevice *dev, int index, struct clk *clk)
+{
+	return clk_get_by_indexed_prop(dev, "clocks", index, clk);
+}
+
+int clk_get_bulk(struct udevice *dev, struct clk_bulk *bulk)
+{
+	int i, ret, err, count;
+	
+	bulk->count = 0;
+
+	count = dev_count_phandle_with_args(dev, "clocks", "#clock-cells");
+	if (!count)
+		return 0;
+
+	bulk->clks = devm_kcalloc(dev, count, sizeof(struct clk), GFP_KERNEL);
+	if (!bulk->clks)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		ret = clk_get_by_index(dev, i, &bulk->clks[i]);
+		if (ret < 0)
+			goto bulk_get_err;
+
+		++bulk->count;
+	}
+
+	return 0;
+
+bulk_get_err:
+	err = clk_release_all(bulk->clks, bulk->count);
+	if (err)
+		debug("%s: could release all clocks for %p\n",
+		      __func__, dev);
+
+	return ret;
+}
+
+static int clk_set_default_parents(struct udevice *dev)
+{
+	struct clk clk, parent_clk;
+	int index;
+	int num_parents;
+	int ret;
+
+	num_parents = dev_count_phandle_with_args(dev, "assigned-clock-parents",
+						  "#clock-cells");
+	if (num_parents < 0) {
+		debug("%s: could not read assigned-clock-parents for %p\n",
+		      __func__, dev);
+		return 0;
+	}
+
+	for (index = 0; index < num_parents; index++) {
+		ret = clk_get_by_indexed_prop(dev, "assigned-clock-parents",
+					      index, &parent_clk);
+		if (ret) {
+			debug("%s: could not get parent clock %d for %s\n",
+			      __func__, index, dev_read_name(dev));
+			return ret;
+		}
+
+		ret = clk_get_by_indexed_prop(dev, "assigned-clocks",
+					      index, &clk);
+		if (ret) {
+			debug("%s: could not get assigned clock %d for %s\n",
+			      __func__, index, dev_read_name(dev));
+			return ret;
+		}
+
+		ret = clk_set_parent(&clk, &parent_clk);
+
+		/*
+		 * Not all drivers may support clock-reparenting (as of now).
+		 * Ignore errors due to this.
+		 */
+		if (ret == -ENOSYS)
+			continue;
+
+		if (ret) {
+			debug("%s: failed to reparent clock %d for %s\n",
+			      __func__, index, dev_read_name(dev));
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int clk_set_default_rates(struct udevice *dev)
+{
+	struct clk clk;
+	int index;
+	int num_rates;
+	int size;
+	int ret = 0;
+	u32 *rates = NULL;
+
+	size = dev_read_size(dev, "assigned-clock-rates");
+	if (size < 0)
+		return 0;
+
+	num_rates = size / sizeof(u32);
+	rates = calloc(num_rates, sizeof(u32));
+	if (!rates)
+		return -ENOMEM;
+
+	ret = dev_read_u32_array(dev, "assigned-clock-rates", rates, num_rates);
+	if (ret)
+		goto fail;
+
+	for (index = 0; index < num_rates; index++) {
+		ret = clk_get_by_indexed_prop(dev, "assigned-clocks",
+					      index, &clk);
+		if (ret) {
+			debug("%s: could not get assigned clock %d for %s\n",
+			      __func__, index, dev_read_name(dev));
+			continue;
+		}
+
+		ret = clk_set_rate(&clk, rates[index]);
+		if (ret < 0) {
+			debug("%s: failed to set rate on clock %d for %s\n",
+			      __func__, index, dev_read_name(dev));
+			continue;
+		}
+	}
+
+fail:
+	free(rates);
+	return ret;
+}
+
+int clk_set_defaults(struct udevice *dev)
+{
+	int ret;
+
+	/* If this is running pre-reloc state, don't take any action. */
+	if (!(gd->flags & GD_FLG_RELOC))
+		return 0;
+
+	debug("%s(%s)\n", __func__, dev_read_name(dev));
+
+	ret = clk_set_default_parents(dev);
+	if (ret)
+		return ret;
+
+	ret = clk_set_default_rates(dev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
 # endif /* OF_PLATDATA */
 
 int clk_get_by_name(struct udevice *dev, const char *name, struct clk *clk)
@@ -142,7 +298,7 @@ int clk_release_all(struct clk *clk, int count)
 
 int clk_request(struct udevice *dev, struct clk *clk)
 {
-	struct clk_ops *ops = clk_dev_ops(dev);
+	const struct clk_ops *ops = clk_dev_ops(dev);
 
 	debug("%s(dev=%p, clk=%p)\n", __func__, dev, clk);
 
@@ -156,7 +312,7 @@ int clk_request(struct udevice *dev, struct clk *clk)
 
 int clk_free(struct clk *clk)
 {
-	struct clk_ops *ops = clk_dev_ops(clk->dev);
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
 
 	debug("%s(clk=%p)\n", __func__, clk);
 
@@ -168,7 +324,7 @@ int clk_free(struct clk *clk)
 
 ulong clk_get_rate(struct clk *clk)
 {
-	struct clk_ops *ops = clk_dev_ops(clk->dev);
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
 
 	debug("%s(clk=%p)\n", __func__, clk);
 
@@ -180,7 +336,7 @@ ulong clk_get_rate(struct clk *clk)
 
 ulong clk_set_rate(struct clk *clk, ulong rate)
 {
-	struct clk_ops *ops = clk_dev_ops(clk->dev);
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
 
 	debug("%s(clk=%p, rate=%lu)\n", __func__, clk, rate);
 
@@ -190,9 +346,41 @@ ulong clk_set_rate(struct clk *clk, ulong rate)
 	return ops->set_rate(clk, rate);
 }
 
+int clk_get_phase(struct clk *clk)
+{
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
+
+	if (!ops->get_phase)
+		return -ENOSYS;
+
+	return ops->get_phase(clk);
+}
+
+int clk_set_phase(struct clk *clk, int degrees)
+{
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
+
+	if (!ops->set_phase)
+		return -ENOSYS;
+
+	return ops->set_phase(clk, degrees);
+}
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
+
+	debug("%s(clk=%p, parent=%p)\n", __func__, clk, parent);
+
+	if (!ops->set_parent)
+		return -ENOSYS;
+
+	return ops->set_parent(clk, parent);
+}
+
 int clk_enable(struct clk *clk)
 {
-	struct clk_ops *ops = clk_dev_ops(clk->dev);
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
 
 	debug("%s(clk=%p)\n", __func__, clk);
 
@@ -202,9 +390,22 @@ int clk_enable(struct clk *clk)
 	return ops->enable(clk);
 }
 
+int clk_enable_bulk(struct clk_bulk *bulk)
+{
+	int i, ret;
+
+	for (i = 0; i < bulk->count; i++) {
+		ret = clk_enable(&bulk->clks[i]);
+		if (ret < 0 && ret != -ENOSYS)
+			return ret;
+	}
+
+	return 0;
+}
+
 int clk_disable(struct clk *clk)
 {
-	struct clk_ops *ops = clk_dev_ops(clk->dev);
+	const struct clk_ops *ops = clk_dev_ops(clk->dev);
 
 	debug("%s(clk=%p)\n", __func__, clk);
 
@@ -214,6 +415,38 @@ int clk_disable(struct clk *clk)
 	return ops->disable(clk);
 }
 
+int clk_disable_bulk(struct clk_bulk *bulk)
+{
+	int i, ret;
+
+	for (i = 0; i < bulk->count; i++) {
+		ret = clk_disable(&bulk->clks[i]);
+		if (ret < 0 && ret != -ENOSYS)
+			return ret;
+	}
+
+	return 0;
+}
+
+int clks_probe(void)
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret;
+
+	ret = uclass_get(UCLASS_CLK, &uc);
+	if (ret)
+		return ret;
+
+	uclass_foreach_dev(dev, uc) {
+		ret = device_probe(dev);
+		if (ret)
+			printf("%s - probe failed: %d\n", dev->name, ret);
+	}
+
+	return 0;
+}
+
 UCLASS_DRIVER(clk) = {
 	.id		= UCLASS_CLK,
 	.name		= "clk",
diff --git a/drivers/clk/clk_boston.c b/drivers/clk/clk_boston.c
index 78f1b759d8..5c05e3d78d 100644
--- a/drivers/clk/clk_boston.c
+++ b/drivers/clk/clk_boston.c
@@ -67,13 +67,13 @@ static int clk_boston_ofdata_to_platdata(struct udevice *dev)
 	err = uclass_get_device_by_phandle(UCLASS_SYSCON, dev,
 					   "regmap", &syscon);
 	if (err) {
-		error("unable to find syscon device\n");
+		pr_err("unable to find syscon device\n");
 		return err;
 	}
 
 	state->regmap = syscon_get_regmap(syscon);
 	if (!state->regmap) {
-		error("unable to find regmap\n");
+		pr_err("unable to find regmap\n");
 		return -ENODEV;
 	}
 
diff --git a/drivers/clk/clk_fixed_rate.c b/drivers/clk/clk_fixed_rate.c
index 63565b6ed8..aefc64ed5d 100644
--- a/drivers/clk/clk_fixed_rate.c
+++ b/drivers/clk/clk_fixed_rate.c
@@ -8,8 +8,6 @@
 #include <clk-uclass.h>
 #include <dm.h>
 
-DECLARE_GLOBAL_DATA_PTR;
-
 struct clk_fixed_rate {
 	unsigned long fixed_rate;
 };
diff --git a/drivers/clk/clk_pic32.c b/drivers/clk/clk_pic32.c
index f6eef314ec..177803943d 100644
--- a/drivers/clk/clk_pic32.c
+++ b/drivers/clk/clk_pic32.c
@@ -197,8 +197,8 @@ static ulong pic32_set_refclk(struct pic32_clk_priv *priv, int periph,
 	writel(REFO_ON | REFO_OE, reg + _CLR_OFFSET);
 
 	/* wait till previous src change is active */
-	wait_for_bit(__func__, reg, REFO_DIVSW_EN | REFO_ACTIVE,
-		     false, CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(reg, REFO_DIVSW_EN | REFO_ACTIVE,
+			  false, CONFIG_SYS_HZ, false);
 
 	/* parent_id */
 	v = readl(reg);
@@ -223,8 +223,8 @@ static ulong pic32_set_refclk(struct pic32_clk_priv *priv, int periph,
 	writel(REFO_DIVSW_EN, reg + _SET_OFFSET);
 
 	/* wait for divider switching to complete */
-	return wait_for_bit(__func__, reg, REFO_DIVSW_EN, false,
-			    CONFIG_SYS_HZ, false);
+	return wait_for_bit_le32(reg, REFO_DIVSW_EN, false,
+				 CONFIG_SYS_HZ, false);
 }
 
 static ulong pic32_get_refclk(struct pic32_clk_priv *priv, int periph)
@@ -311,8 +311,8 @@ static int pic32_mpll_init(struct pic32_clk_priv *priv)
 
 	/* Wait for ready */
 	mask = MPLL_RDY | MPLL_VREG_RDY;
-	return wait_for_bit(__func__, priv->syscfg_base + CFGMPLL, mask,
-			    true, get_tbclk(), false);
+	return wait_for_bit_le32(priv->syscfg_base + CFGMPLL, mask,
+				 true, get_tbclk(), false);
 }
 
 static void pic32_clk_init(struct udevice *dev)
diff --git a/drivers/clk/clk_sandbox_test.c b/drivers/clk/clk_sandbox_test.c
index 999100de9d..ee69eed690 100644
--- a/drivers/clk/clk_sandbox_test.c
+++ b/drivers/clk/clk_sandbox_test.c
@@ -11,6 +11,7 @@
 
 struct sandbox_clk_test {
 	struct clk clks[SANDBOX_CLK_TEST_ID_COUNT];
+	struct clk_bulk bulk;
 };
 
 static const char * const sandbox_clk_test_names[] = {
@@ -34,6 +35,13 @@ int sandbox_clk_test_get(struct udevice *dev)
 	return 0;
 }
 
+int sandbox_clk_test_get_bulk(struct udevice *dev)
+{
+	struct sandbox_clk_test *sbct = dev_get_priv(dev);
+
+	return clk_get_bulk(dev, &sbct->bulk);
+}
+
 ulong sandbox_clk_test_get_rate(struct udevice *dev, int id)
 {
 	struct sandbox_clk_test *sbct = dev_get_priv(dev);
@@ -64,6 +72,13 @@ int sandbox_clk_test_enable(struct udevice *dev, int id)
 	return clk_enable(&sbct->clks[id]);
 }
 
+int sandbox_clk_test_enable_bulk(struct udevice *dev)
+{
+	struct sandbox_clk_test *sbct = dev_get_priv(dev);
+
+	return clk_enable_bulk(&sbct->bulk);
+}
+
 int sandbox_clk_test_disable(struct udevice *dev, int id)
 {
 	struct sandbox_clk_test *sbct = dev_get_priv(dev);
@@ -74,6 +89,13 @@ int sandbox_clk_test_disable(struct udevice *dev, int id)
 	return clk_disable(&sbct->clks[id]);
 }
 
+int sandbox_clk_test_disable_bulk(struct udevice *dev)
+{
+	struct sandbox_clk_test *sbct = dev_get_priv(dev);
+
+	return clk_disable_bulk(&sbct->bulk);
+}
+
 int sandbox_clk_test_free(struct udevice *dev)
 {
 	struct sandbox_clk_test *sbct = dev_get_priv(dev);
@@ -88,6 +110,26 @@ int sandbox_clk_test_free(struct udevice *dev)
 	return 0;
 }
 
+int sandbox_clk_test_release_bulk(struct udevice *dev)
+{
+	struct sandbox_clk_test *sbct = dev_get_priv(dev);
+
+	return clk_release_bulk(&sbct->bulk);
+}
+
+int sandbox_clk_test_valid(struct udevice *dev)
+{
+	struct sandbox_clk_test *sbct = dev_get_priv(dev);
+	int i;
+
+	for (i = 0; i < SANDBOX_CLK_TEST_ID_COUNT; i++) {
+		if (!clk_valid(&sbct->clks[i]))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 static const struct udevice_id sandbox_clk_test_ids[] = {
 	{ .compatible = "sandbox,clk-test" },
 	{ }
diff --git a/drivers/clk/clk_stm32f7.c b/drivers/clk/clk_stm32f7.c
index 255a583c95..ad3cafc49f 100644
--- a/drivers/clk/clk_stm32f7.c
+++ b/drivers/clk/clk_stm32f7.c
@@ -224,7 +224,7 @@ static unsigned long stm32_clk_get_rate(struct clk *clk)
 		return sysclk >>= shift;
 		break;
 	default:
-		error("clock index %ld out of range\n", clk->id);
+		pr_err("clock index %ld out of range\n", clk->id);
 		return -EINVAL;
 		break;
 	}
diff --git a/drivers/clk/renesas/clk-rcar-gen3.c b/drivers/clk/renesas/clk-rcar-gen3.c
index 4e74856940..e520e53766 100644
--- a/drivers/clk/renesas/clk-rcar-gen3.c
+++ b/drivers/clk/renesas/clk-rcar-gen3.c
@@ -768,8 +768,8 @@ static int gen3_clk_endisable(struct clk *clk, bool enable)
 
 	if (enable) {
 		clrbits_le32(priv->base + SMSTPCR(reg), bitmask);
-		return wait_for_bit("MSTP", priv->base + MSTPSR(reg),
-				    bitmask, 0, 100, 0);
+		return wait_for_bit_le32(priv->base + MSTPSR(reg),
+					 bitmask, 0, 100, 0);
 	} else {
 		setbits_le32(priv->base + SMSTPCR(reg), bitmask);
 		return 0;
diff --git a/drivers/clk/rockchip/Makefile b/drivers/clk/rockchip/Makefile
index c50aff2e93..260b24e932 100644
--- a/drivers/clk/rockchip/Makefile
+++ b/drivers/clk/rockchip/Makefile
@@ -1,14 +1,24 @@
 #
-# Copyright (c) 2016 Google, Inc
+# Copyright (c) 2017 Rockchip Electronics Co., Ltd
 #
 # SPDX-License-Identifier:      GPL-2.0+
 #
 
+obj-$(CONFIG_ROCKCHIP_CLK_PLL)	+= clk_pll.o
+obj-$(CONFIG_ROCKCHIP_PX30) += clk_px30.o
+obj-$(CONFIG_ROCKCHIP_RK1808) += clk_rk1808.o
 obj-$(CONFIG_ROCKCHIP_RK3036) += clk_rk3036.o
+obj-$(CONFIG_ROCKCHIP_RK3066) += clk_rk3066.o
+obj-$(CONFIG_ROCKCHIP_RK3128) += clk_rk3128.o
 obj-$(CONFIG_ROCKCHIP_RK3188) += clk_rk3188.o
 obj-$(CONFIG_ROCKCHIP_RK322X) += clk_rk322x.o
 obj-$(CONFIG_ROCKCHIP_RK3288) += clk_rk3288.o
+obj-$(CONFIG_ROCKCHIP_RK3308) += clk_rk3308.o
 obj-$(CONFIG_ROCKCHIP_RK3328) += clk_rk3328.o
 obj-$(CONFIG_ROCKCHIP_RK3368) += clk_rk3368.o
 obj-$(CONFIG_ROCKCHIP_RK3399) += clk_rk3399.o
+obj-$(CONFIG_ROCKCHIP_RK3568) += clk_rk3568.o
+obj-$(CONFIG_ROCKCHIP_RK3588) += clk_rk3588.o
+obj-$(CONFIG_ROCKCHIP_RV1106) += clk_rv1106.o
 obj-$(CONFIG_ROCKCHIP_RV1108) += clk_rv1108.o
+obj-$(CONFIG_ROCKCHIP_RV1126) += clk_rv1126.o
diff --git a/drivers/clk/rockchip/clk_rk3036.c b/drivers/clk/rockchip/clk_rk3036.c
index 83f4ae6ca3..f394c392f0 100644
--- a/drivers/clk/rockchip/clk_rk3036.c
+++ b/drivers/clk/rockchip/clk_rk3036.c
@@ -10,9 +10,9 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3036.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3036.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <dm/lists.h>
 #include <dt-bindings/clock/rk3036-cru.h>
 #include <linux/log2.h>
@@ -26,6 +26,21 @@ enum {
 	OUTPUT_MIN_HZ	= 24 * 1000000,
 };
 
+#ifndef CONFIG_SPL_BUILD
+#define RK3036_CLK_DUMP(_id, _name, _iscru)	\
+{						\
+	.id = _id,				\
+	.name = _name,				\
+	.is_cru = _iscru,			\
+}
+
+static const struct rk3036_clk_info clks_dump[] = {
+	RK3036_CLK_DUMP(PLL_APLL, "apll", true),
+	RK3036_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK3036_CLK_DUMP(PLL_GPLL, "gpll", true),
+};
+#endif
+
 #define RATE_TO_DIV(input_rate, output_rate) \
 	((input_rate) / (output_rate) - 1);
 
@@ -64,6 +79,9 @@ static int rkclk_set_pll(struct rk3036_cru *cru, enum rk_clk_id clk_id,
 	/* use integer mode */
 	rk_setreg(&pll->con1, 1 << PLL_DSMPD_SHIFT);
 
+	/* Power down */
+	rk_setreg(&pll->con1, 1 << PLL_PD_SHIFT);
+
 	rk_clrsetreg(&pll->con0,
 		     PLL_POSTDIV1_MASK | PLL_FBDIV_MASK,
 		     (div->postdiv1 << PLL_POSTDIV1_SHIFT) | div->fbdiv);
@@ -71,6 +89,9 @@ static int rkclk_set_pll(struct rk3036_cru *cru, enum rk_clk_id clk_id,
 		     (div->postdiv2 << PLL_POSTDIV2_SHIFT |
 		     div->refdiv << PLL_REFDIV_SHIFT));
 
+	/* Power Up */
+	rk_clrreg(&pll->con1, 1 << PLL_PD_SHIFT);
+
 	/* waiting for pll lock */
 	while (readl(&pll->con1) & (1 << PLL_LOCK_STATUS_SHIFT))
 		udelay(1);
@@ -83,6 +104,7 @@ static void rkclk_init(struct rk3036_cru *cru)
 	u32 aclk_div;
 	u32 hclk_div;
 	u32 pclk_div;
+	u32 nandc_div;
 
 	/* pll enter slow-mode */
 	rk_clrsetreg(&cru->cru_mode_con,
@@ -100,10 +122,10 @@ static void rkclk_init(struct rk3036_cru *cru)
 	 * core hz : apll = 1:1
 	 */
 	aclk_div = APLL_HZ / CORE_ACLK_HZ - 1;
-	assert((aclk_div + 1) * CORE_ACLK_HZ == APLL_HZ && aclk_div < 0x7);
+	assert((aclk_div + 1) * CORE_ACLK_HZ <= APLL_HZ && aclk_div < 0x7);
 
 	pclk_div = APLL_HZ / CORE_PERI_HZ - 1;
-	assert((pclk_div + 1) * CORE_PERI_HZ == APLL_HZ && pclk_div < 0xf);
+	assert((pclk_div + 1) * CORE_PERI_HZ <= APLL_HZ && pclk_div < 0xf);
 
 	rk_clrsetreg(&cru->cru_clksel_con[0],
 		     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
@@ -116,17 +138,17 @@ static void rkclk_init(struct rk3036_cru *cru)
 		     pclk_div << CORE_PERI_DIV_SHIFT);
 
 	/*
-	 * select apll as pd_bus bus clock source and
+	 * select gpll as pd_bus bus clock source and
 	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
 	 */
 	aclk_div = GPLL_HZ / BUS_ACLK_HZ - 1;
-	assert((aclk_div + 1) * BUS_ACLK_HZ == GPLL_HZ && aclk_div <= 0x1f);
+	assert((aclk_div + 1) * BUS_ACLK_HZ <= GPLL_HZ && aclk_div <= 0x1f);
 
-	pclk_div = GPLL_HZ / BUS_PCLK_HZ - 1;
-	assert((pclk_div + 1) * BUS_PCLK_HZ == GPLL_HZ && pclk_div <= 0x7);
+	pclk_div = BUS_ACLK_HZ / BUS_PCLK_HZ - 1;
+	assert((pclk_div + 1) * BUS_PCLK_HZ <= BUS_ACLK_HZ && pclk_div <= 0x7);
 
-	hclk_div = GPLL_HZ / BUS_HCLK_HZ - 1;
-	assert((hclk_div + 1) * BUS_HCLK_HZ == GPLL_HZ && hclk_div <= 0x3);
+	hclk_div = BUS_ACLK_HZ / BUS_HCLK_HZ - 1;
+	assert((hclk_div + 1) * BUS_HCLK_HZ <= BUS_ACLK_HZ && hclk_div <= 0x3);
 
 	rk_clrsetreg(&cru->cru_clksel_con[0],
 		     BUS_ACLK_PLL_SEL_MASK | BUS_ACLK_DIV_MASK,
@@ -143,14 +165,14 @@ static void rkclk_init(struct rk3036_cru *cru)
 	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
 	 */
 	aclk_div = GPLL_HZ / PERI_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PERI_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
+	assert((aclk_div + 1) * PERI_ACLK_HZ <= GPLL_HZ && aclk_div < 0x1f);
 
 	hclk_div = ilog2(PERI_ACLK_HZ / PERI_HCLK_HZ);
-	assert((1 << hclk_div) * PERI_HCLK_HZ ==
+	assert((1 << hclk_div) * PERI_HCLK_HZ <=
 		PERI_ACLK_HZ && (hclk_div < 0x4));
 
 	pclk_div = ilog2(PERI_ACLK_HZ / PERI_PCLK_HZ);
-	assert((1 << pclk_div) * PERI_PCLK_HZ ==
+	assert((1 << pclk_div) * PERI_PCLK_HZ <=
 		PERI_ACLK_HZ && pclk_div < 0x8);
 
 	rk_clrsetreg(&cru->cru_clksel_con[10],
@@ -161,6 +183,13 @@ static void rkclk_init(struct rk3036_cru *cru)
 		     hclk_div << PERI_HCLK_DIV_SHIFT |
 		     aclk_div << PERI_ACLK_DIV_SHIFT);
 
+	nandc_div = DIV_ROUND_UP(GPLL_HZ, 150 * 1000000);
+
+	rk_clrsetreg(&cru->cru_clksel_con[16],
+		     NANDC_PLL_MASK | NANDC_DIV_MASK,
+		     NANDC_SEL_GPLL << NANDC_PLL_SHIFT |
+		     nandc_div << NANDC_DIV_SHIFT);
+
 	/* PLL enter normal-mode */
 	rk_clrsetreg(&cru->cru_mode_con,
 		     GPLL_MODE_MASK | APLL_MODE_MASK,
@@ -279,13 +308,109 @@ static ulong rockchip_mmc_set_clk(struct rk3036_cru *cru, uint clk_general_rate,
 	return rockchip_mmc_get_clk(cru, clk_general_rate, periph);
 }
 
+static ulong rk3036_spi_get_clk(struct rk3036_cru *cru, uint clk_general_rate)
+{
+	u32 div, con;
+
+	con = readl(&cru->cru_clksel_con[25]);
+	div = (con & SPI_DIV_MASK) >> SPI_DIV_SHIFT;
+
+	return DIV_TO_RATE(clk_general_rate, div);
+}
+
+static ulong  rk3036_spi_set_clk(struct rk3036_cru *cru,
+				 uint clk_general_rate,
+				 ulong hz)
+{
+	int div;
+
+	div = DIV_ROUND_UP(clk_general_rate, hz);
+	assert(div - 1 < 128);
+	rk_clrsetreg(&cru->cru_clksel_con[25],
+		     SPI_PLL_SEL_MASK | SPI_DIV_MASK,
+		     SPI_PLL_SEL_GPLL << SPI_PLL_SEL_SHIFT |
+		     (div - 1) << SPI_DIV_SHIFT);
+	return  rk3036_spi_get_clk(cru, clk_general_rate);
+}
+
+static ulong rockchip_dclk_lcdc_get_clk(struct rk3036_cru *cru,
+					uint clk_general_rate)
+{
+	u32 con, div, sel, parent;
+
+	con = readl(&cru->cru_clksel_con[28]);
+	div = (con & LCDC_DCLK_DIV_MASK) >> LCDC_DCLK_DIV_SHIFT;
+	sel = (con & LCDC_DCLK_SEL_MASK) >> LCDC_DCLK_SEL_SHIFT;
+	if (sel == LCDC_DCLK_SEL_GPLL)
+		parent = clk_general_rate;
+	else
+		return -ENOENT;
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rockchip_dclk_lcdc_set_clk(struct rk3036_cru *cru,
+					uint clk_general_rate, uint freq)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(clk_general_rate, freq);
+	assert(src_clk_div - 1 <= 255);
+
+	rk_clrsetreg(&cru->cru_clksel_con[28],
+		     LCDC_DCLK_SEL_MASK | LCDC_DCLK_DIV_MASK,
+		     LCDC_DCLK_SEL_GPLL << LCDC_DCLK_SEL_SHIFT |
+		     (src_clk_div - 1) << LCDC_DCLK_DIV_SHIFT);
+
+	return rockchip_dclk_lcdc_get_clk(cru, clk_general_rate);
+}
+
+static ulong rockchip_aclk_lcdc_get_clk(struct rk3036_cru *cru,
+					uint clk_general_rate)
+{
+	u32 con, div, sel, parent;
+
+	con = readl(&cru->cru_clksel_con[31]);
+	div = (con & LCDC_ACLK_DIV_MASK) >> LCDC_ACLK_DIV_SHIFT;
+	sel = (con & LCDC_ACLK_SEL_MASK) >> LCDC_ACLK_SEL_SHIFT;
+	if (sel == LCDC_ACLK_SEL_GPLL)
+		parent = clk_general_rate;
+	else
+		return -ENOENT;
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rockchip_aclk_lcdc_set_clk(struct rk3036_cru *cru,
+					uint clk_general_rate, uint freq)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(clk_general_rate, freq);
+	assert(src_clk_div - 1 <= 31);
+
+	rk_clrsetreg(&cru->cru_clksel_con[31],
+		     LCDC_ACLK_SEL_MASK | LCDC_ACLK_DIV_MASK,
+		     LCDC_ACLK_SEL_GPLL << LCDC_ACLK_SEL_SHIFT |
+		     (src_clk_div - 1) << LCDC_ACLK_DIV_SHIFT);
+
+	return rockchip_aclk_lcdc_get_clk(cru, clk_general_rate);
+}
+
 static ulong rk3036_clk_get_rate(struct clk *clk)
 {
 	struct rk3036_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong gclk_rate = rkclk_pll_get_rate(priv->cru, CLK_GENERAL);
 
 	switch (clk->id) {
 	case 0 ... 63:
 		return rkclk_pll_get_rate(priv->cru, clk->id);
+	case SCLK_LCDC:
+		return rockchip_dclk_lcdc_get_clk(priv->cru, gclk_rate);
+	case ACLK_LCDC:
+		return rockchip_aclk_lcdc_get_clk(priv->cru, gclk_rate);
+	case SCLK_SPI:
+		return rk3036_spi_get_clk(priv->cru, gclk_rate);
 	default:
 		return -ENOENT;
 	}
@@ -305,6 +430,18 @@ static ulong rk3036_clk_set_rate(struct clk *clk, ulong rate)
 		new_rate = rockchip_mmc_set_clk(priv->cru, gclk_rate,
 						clk->id, rate);
 		break;
+	case SCLK_LCDC:
+		new_rate = rockchip_dclk_lcdc_set_clk(priv->cru, gclk_rate,
+						      rate);
+		break;
+	case ACLK_LCDC:
+		new_rate = rockchip_aclk_lcdc_set_clk(priv->cru, gclk_rate,
+						      rate);
+		break;
+	case SCLK_SPI:
+		new_rate = rk3036_spi_set_clk(priv->cru, gclk_rate,
+					      rate);
+		break;
 	default:
 		return -ENOENT;
 	}
@@ -317,12 +454,27 @@ static struct clk_ops rk3036_clk_ops = {
 	.set_rate	= rk3036_clk_set_rate,
 };
 
+static int rk3036_clk_ofdata_to_platdata(struct udevice *dev)
+{
+	struct rk3036_clk_priv *priv = dev_get_priv(dev);
+
+	priv->cru = dev_read_addr_ptr(dev);
+
+	return 0;
+}
+
 static int rk3036_clk_probe(struct udevice *dev)
 {
 	struct rk3036_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk3036_cru *)devfdt_get_addr(dev);
+	priv->sync_kernel = false;
+	if (!priv->armclk_enter_hz)
+		priv->armclk_enter_hz = rkclk_pll_get_rate(priv->cru,
+							   CLK_ARM);
 	rkclk_init(priv->cru);
+	if (!priv->armclk_init_hz)
+		priv->armclk_init_hz = rkclk_pll_get_rate(priv->cru,
+							  CLK_ARM);
 
 	return 0;
 }
@@ -330,11 +482,35 @@ static int rk3036_clk_probe(struct udevice *dev)
 static int rk3036_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk3036_sysreset", "reset", &dev);
-	if (ret)
-		debug("Warning: No RK3036 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3036_cru,
+						    cru_glb_srst_fst_value);
+		priv->glb_srst_snd_value = offsetof(struct rk3036_cru,
+						    cru_glb_srst_snd_value);
+		sys_child->priv = priv;
+	}
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3036_cru,
+						    cru_softrst_con[0]);
+		sf_priv->sf_reset_num = 9;
+		sf_child->priv = sf_priv;
+	}
 
 	return 0;
 }
@@ -349,7 +525,74 @@ U_BOOT_DRIVER(rockchip_rk3036_cru) = {
 	.id		= UCLASS_CLK,
 	.of_match	= rk3036_clk_ids,
 	.priv_auto_alloc_size = sizeof(struct rk3036_clk_priv),
+	.ofdata_to_platdata = rk3036_clk_ofdata_to_platdata,
 	.ops		= &rk3036_clk_ops,
 	.bind		= rk3036_clk_bind,
 	.probe		= rk3036_clk_probe,
 };
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev;
+	struct rk3036_clk_priv *priv;
+	const struct rk3036_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk3036_cru),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arm: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armclk_enter_hz / 1000,
+	       priv->armclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
diff --git a/drivers/clk/rockchip/clk_rk3188.c b/drivers/clk/rockchip/clk_rk3188.c
index 8c2c9bc1d8..731d3ddba4 100644
--- a/drivers/clk/rockchip/clk_rk3188.c
+++ b/drivers/clk/rockchip/clk_rk3188.c
@@ -13,10 +13,11 @@
 #include <mapmem.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3188.h>
-#include <asm/arch/grf_rk3188.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3188.h>
+#include <asm/arch-rockchip/grf_rk3188.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <bitfield.h>
 #include <dt-bindings/clock/rk3188-cru.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
@@ -36,6 +37,22 @@ struct rk3188_clk_plat {
 #endif
 };
 
+#ifndef CONFIG_SPL_BUILD
+#define RK3188_CLK_DUMP(_id, _name, _iscru)	\
+{						\
+	.id = _id,				\
+	.name = _name,				\
+	.is_cru = _iscru,			\
+}
+
+static const struct rk3188_clk_info clks_dump[] = {
+	RK3188_CLK_DUMP(PLL_APLL, "apll", true),
+	RK3188_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK3188_CLK_DUMP(PLL_CPLL, "cpll", true),
+	RK3188_CLK_DUMP(PLL_GPLL, "gpll", true),
+};
+#endif
+
 struct pll_div {
 	u32 nr;
 	u32 nf;
@@ -371,6 +388,30 @@ static ulong rockchip_spi_set_clk(struct rk3188_cru *cru, uint gclk_rate,
 	return rockchip_spi_get_clk(cru, gclk_rate, periph);
 }
 
+static ulong rk3188_saradc_get_clk(struct rk3188_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->cru_clksel_con[24]);
+	div = bitfield_extract(val, SARADC_DIV_SHIFT, SARADC_DIV_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3188_saradc_set_clk(struct rk3188_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->cru_clksel_con[24],
+		     SARADC_DIV_MASK,
+		     src_clk_div << SARADC_DIV_SHIFT);
+
+	return rk3188_saradc_get_clk(cru);
+}
+
 #ifdef CONFIG_SPL_BUILD
 static void rkclk_init(struct rk3188_cru *cru, struct rk3188_grf *grf,
 		       bool has_bwadj)
@@ -400,7 +441,7 @@ static void rkclk_init(struct rk3188_cru *cru, struct rk3188_grf *grf,
 	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
 	 */
 	aclk_div = DIV_ROUND_UP(GPLL_HZ, CPU_ACLK_HZ) - 1;
-	assert((aclk_div + 1) * CPU_ACLK_HZ == GPLL_HZ && aclk_div <= 0x1f);
+	assert((aclk_div + 1) * CPU_ACLK_HZ <= GPLL_HZ && aclk_div <= 0x1f);
 
 	rk_clrsetreg(&cru->cru_clksel_con[0],
 		     CPU_ACLK_PLL_MASK << CPU_ACLK_PLL_SHIFT |
@@ -409,11 +450,11 @@ static void rkclk_init(struct rk3188_cru *cru, struct rk3188_grf *grf,
 		     aclk_div << A9_CPU_DIV_SHIFT);
 
 	hclk_div = ilog2(CPU_ACLK_HZ / CPU_HCLK_HZ);
-	assert((1 << hclk_div) * CPU_HCLK_HZ == CPU_ACLK_HZ && hclk_div < 0x3);
+	assert((1 << hclk_div) * CPU_HCLK_HZ <= CPU_ACLK_HZ && hclk_div < 0x3);
 	pclk_div = ilog2(CPU_ACLK_HZ / CPU_PCLK_HZ);
-	assert((1 << pclk_div) * CPU_PCLK_HZ == CPU_ACLK_HZ && pclk_div < 0x4);
+	assert((1 << pclk_div) * CPU_PCLK_HZ <= CPU_ACLK_HZ && pclk_div < 0x4);
 	h2p_div = ilog2(CPU_HCLK_HZ / CPU_H2P_HZ);
-	assert((1 << h2p_div) * CPU_H2P_HZ == CPU_HCLK_HZ && pclk_div < 0x3);
+	assert((1 << h2p_div) * CPU_H2P_HZ <= CPU_HCLK_HZ && pclk_div < 0x3);
 
 	rk_clrsetreg(&cru->cru_clksel_con[1],
 		     AHB2APB_DIV_MASK << AHB2APB_DIV_SHIFT |
@@ -428,14 +469,14 @@ static void rkclk_init(struct rk3188_cru *cru, struct rk3188_grf *grf,
 	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
 	 */
 	aclk_div = GPLL_HZ / PERI_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PERI_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
+	assert((aclk_div + 1) * PERI_ACLK_HZ <= GPLL_HZ && aclk_div < 0x1f);
 
 	hclk_div = ilog2(PERI_ACLK_HZ / PERI_HCLK_HZ);
-	assert((1 << hclk_div) * PERI_HCLK_HZ ==
+	assert((1 << hclk_div) * PERI_HCLK_HZ <=
 		PERI_ACLK_HZ && (hclk_div < 0x4));
 
 	pclk_div = ilog2(PERI_ACLK_HZ / PERI_PCLK_HZ);
-	assert((1 << pclk_div) * PERI_PCLK_HZ ==
+	assert((1 << pclk_div) * PERI_PCLK_HZ <=
 		PERI_ACLK_HZ && (pclk_div < 0x4));
 
 	rk_clrsetreg(&cru->cru_clksel_con[10],
@@ -488,6 +529,8 @@ static ulong rk3188_clk_get_rate(struct clk *clk)
 	case PCLK_I2C3:
 	case PCLK_I2C4:
 		return gclk_rate;
+	case SCLK_SARADC:
+                new_rate =  rk3188_saradc_get_clk(priv->cru);
 	default:
 		return -ENOENT;
 	}
@@ -524,6 +567,9 @@ static ulong rk3188_clk_set_rate(struct clk *clk, ulong rate)
 		new_rate = rockchip_spi_set_clk(cru, PERI_PCLK_HZ,
 						clk->id, rate);
 		break;
+	case SCLK_SARADC:
+		new_rate = rk3188_saradc_set_clk(priv->cru, rate);
+		break;
 	default:
 		return -ENOENT;
 	}
@@ -541,7 +587,7 @@ static int rk3188_clk_ofdata_to_platdata(struct udevice *dev)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3188_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk3188_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
 #endif
 
 	return 0;
@@ -563,8 +609,14 @@ static int rk3188_clk_probe(struct udevice *dev)
 
 	priv->cru = map_sysmem(plat->dtd.reg[0], plat->dtd.reg[1]);
 #endif
-
+	priv->sync_kernel = false;
+	if (!priv->armclk_enter_hz)
+		priv->armclk_enter_hz = rkclk_pll_get_rate(priv->cru,
+							   CLK_ARM);
 	rkclk_init(priv->cru, priv->grf, priv->has_bwadj);
+	if (!priv->armclk_init_hz)
+		priv->armclk_init_hz = rkclk_pll_get_rate(priv->cru,
+							  CLK_ARM);
 #endif
 
 	return 0;
@@ -573,11 +625,35 @@ static int rk3188_clk_probe(struct udevice *dev)
 static int rk3188_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk3188_sysreset", "reset", &dev);
-	if (ret)
-		debug("Warning: No rk3188 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3188_cru,
+						    cru_glb_srst_fst_value);
+		priv->glb_srst_snd_value = offsetof(struct rk3188_cru,
+						    cru_glb_srst_snd_value);
+		sys_child->priv = priv;
+	}
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3188_cru,
+						    cru_softrst_con[0]);
+		sf_priv->sf_reset_num = 9;
+		sf_child->priv = sf_priv;
+	}
 
 	return 0;
 }
@@ -599,3 +675,69 @@ U_BOOT_DRIVER(rockchip_rk3188_cru) = {
 	.ofdata_to_platdata	= rk3188_clk_ofdata_to_platdata,
 	.probe			= rk3188_clk_probe,
 };
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev;
+	struct rk3188_clk_priv *priv;
+	const struct rk3188_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk3188_cru),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arm: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armclk_enter_hz / 1000,
+	       priv->armclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
diff --git a/drivers/clk/rockchip/clk_rk322x.c b/drivers/clk/rockchip/clk_rk322x.c
index d7f6a3c313..9ba6663ab0 100644
--- a/drivers/clk/rockchip/clk_rk322x.c
+++ b/drivers/clk/rockchip/clk_rk322x.c
@@ -10,209 +10,137 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk322x.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk322x.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <dm/lists.h>
 #include <dt-bindings/clock/rk3228-cru.h>
 #include <linux/log2.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
-enum {
-	VCO_MAX_HZ	= 3200U * 1000000,
-	VCO_MIN_HZ	= 800 * 1000000,
-	OUTPUT_MAX_HZ	= 3200U * 1000000,
-	OUTPUT_MIN_HZ	= 24 * 1000000,
-};
-
 #define DIV_TO_RATE(input_rate, div)	((input_rate) / ((div) + 1))
 
-#define PLL_DIVISORS(hz, _refdiv, _postdiv1, _postdiv2) {\
-	.refdiv = _refdiv,\
-	.fbdiv = (u32)((u64)hz * _refdiv * _postdiv1 * _postdiv2 / OSC_HZ), \
-	.postdiv1 = _postdiv1, .postdiv2 = _postdiv2};\
-	_Static_assert(((u64)hz * _refdiv * _postdiv1 * _postdiv2 / OSC_HZ) * \
-			 OSC_HZ / (_refdiv * _postdiv1 * _postdiv2) == hz, \
-			 #hz "Hz cannot be hit with PLL "\
-			 "divisors on line " __stringify(__LINE__));
-
-/* use integer mode*/
-static const struct pll_div apll_init_cfg = PLL_DIVISORS(APLL_HZ, 1, 3, 1);
-static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 2, 2, 1);
-
-static int rkclk_set_pll(struct rk322x_cru *cru, enum rk_clk_id clk_id,
-			 const struct pll_div *div)
-{
-	int pll_id = rk_pll_id(clk_id);
-	struct rk322x_pll *pll = &cru->pll[pll_id];
-
-	/* All PLLs have same VCO and output frequency range restrictions. */
-	uint vco_hz = OSC_HZ / 1000 * div->fbdiv / div->refdiv * 1000;
-	uint output_hz = vco_hz / div->postdiv1 / div->postdiv2;
-
-	debug("PLL at %p: fb=%d, ref=%d, pst1=%d, pst2=%d, vco=%u Hz, output=%u Hz\n",
-	      pll, div->fbdiv, div->refdiv, div->postdiv1,
-	      div->postdiv2, vco_hz, output_hz);
-	assert(vco_hz >= VCO_MIN_HZ && vco_hz <= VCO_MAX_HZ &&
-	       output_hz >= OUTPUT_MIN_HZ && output_hz <= OUTPUT_MAX_HZ);
-
-	/* use integer mode */
-	rk_setreg(&pll->con1, 1 << PLL_DSMPD_SHIFT);
-	/* Power down */
-	rk_setreg(&pll->con1, 1 << PLL_PD_SHIFT);
-
-	rk_clrsetreg(&pll->con0,
-		     PLL_POSTDIV1_MASK | PLL_FBDIV_MASK,
-		     (div->postdiv1 << PLL_POSTDIV1_SHIFT) | div->fbdiv);
-	rk_clrsetreg(&pll->con1, PLL_POSTDIV2_MASK | PLL_REFDIV_MASK,
-		     (div->postdiv2 << PLL_POSTDIV2_SHIFT |
-		     div->refdiv << PLL_REFDIV_SHIFT));
-
-	/* Power Up */
-	rk_clrreg(&pll->con1, 1 << PLL_PD_SHIFT);
-
-	/* waiting for pll lock */
-	while (readl(&pll->con1) & (1 << PLL_LOCK_STATUS_SHIFT))
-		udelay(1);
+#ifndef CONFIG_SPL_BUILD
+#define RK322x_CLK_DUMP(_id, _name, _iscru)	\
+{						\
+	.id = _id,				\
+	.name = _name,				\
+	.is_cru = _iscru,			\
+}
+#endif
+
+static struct rockchip_pll_rate_table rk322x_pll_rates[] = {
+	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
+	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
+#ifndef CONFIG_SPL_BUILD
+	RK3036_PLL_RATE(1188000000, 1, 99, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
+#endif
+	RK3036_PLL_RATE(816000000, 1, 68, 2, 1, 1, 0),
+	RK3036_PLL_RATE(800000000, 1, 100, 3, 1, 1, 0),
+	RK3036_PLL_RATE(600000000, 1, 75, 3, 1, 1, 0),
+#ifndef CONFIG_SPL_BUILD
+	RK3036_PLL_RATE(594000000, 2, 99, 2, 1, 1, 0),
+	RK3036_PLL_RATE(500000000, 1, 125, 6, 1, 1, 0),
+	RK3036_PLL_RATE(400000000, 1, 50, 3, 1, 1, 0),
+#endif
+	{ /* sentinel */ },
+};
 
-	return 0;
+#define RK322x_CPUCLK_RATE(_rate, _aclk_div, _pclk_div)		\
+{								\
+	.rate	= _rate##U,					\
+	.aclk_div = _aclk_div,					\
+	.pclk_div = _pclk_div,					\
 }
 
-static void rkclk_init(struct rk322x_cru *cru)
-{
-	u32 aclk_div;
-	u32 hclk_div;
-	u32 pclk_div;
+static struct rockchip_cpu_rate_table rk322x_cpu_rates[] = {
+	RK322x_CPUCLK_RATE(1200000000, 1, 5),
+	RK322x_CPUCLK_RATE(1008000000, 1, 5),
+	RK322x_CPUCLK_RATE(816000000, 1, 3),
+	RK322x_CPUCLK_RATE(600000000, 1, 3),
+};
 
-	/* pll enter slow-mode */
-	rk_clrsetreg(&cru->cru_mode_con,
-		     GPLL_MODE_MASK | APLL_MODE_MASK,
-		     GPLL_MODE_SLOW << GPLL_MODE_SHIFT |
-		     APLL_MODE_SLOW << APLL_MODE_SHIFT);
+#ifndef CONFIG_SPL_BUILD
+static const struct rk322x_clk_info clks_dump[] = {
+	RK322x_CLK_DUMP(PLL_APLL, "apll", true),
+	RK322x_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK322x_CLK_DUMP(PLL_CPLL, "cpll", true),
+	RK322x_CLK_DUMP(PLL_GPLL, "gpll", true),
+	RK322x_CLK_DUMP(ARMCLK, "armclk", true),
+	RK322x_CLK_DUMP(ACLK_CPU, "aclk_bus", true),
+	RK322x_CLK_DUMP(HCLK_CPU, "hclk_bus", true),
+	RK322x_CLK_DUMP(PCLK_CPU, "pclk_bus", true),
+	RK322x_CLK_DUMP(ACLK_PERI, "aclk_peri", true),
+	RK322x_CLK_DUMP(HCLK_PERI, "hclk_peri", true),
+	RK322x_CLK_DUMP(PCLK_PERI, "pclk_peri", true),
+};
+#endif
+
+static struct rockchip_pll_clock rk322x_pll_clks[] = {
+	[APLL] = PLL(pll_rk3036, PLL_APLL, RK2928_PLL_CON(0),
+		     RK2928_MODE_CON, 0, 10, 0, rk322x_pll_rates),
+	[DPLL] = PLL(pll_rk3036, PLL_DPLL, RK2928_PLL_CON(3),
+		     RK2928_MODE_CON, 4, 10, 0, rk322x_pll_rates),
+	[CPLL] = PLL(pll_rk3036, PLL_CPLL, RK2928_PLL_CON(6),
+		    RK2928_MODE_CON, 8, 10, 0, rk322x_pll_rates),
+	[GPLL] = PLL(pll_rk3036, PLL_GPLL, RK2928_PLL_CON(9),
+		     RK2928_MODE_CON, 12, 10, 0, rk322x_pll_rates),
+};
+
+static ulong rk322x_armclk_set_clk(struct rk322x_clk_priv *priv, ulong hz)
+{
+	struct rk322x_cru *cru = priv->cru;
+	const struct rockchip_cpu_rate_table *rate;
+	ulong old_rate;
 
-	/* init pll */
-	rkclk_set_pll(cru, CLK_ARM, &apll_init_cfg);
-	rkclk_set_pll(cru, CLK_GENERAL, &gpll_init_cfg);
+	rate = rockchip_get_cpu_settings(rk322x_cpu_rates, hz);
+	if (!rate) {
+		printf("%s unsupported rate\n", __func__);
+		return -EINVAL;
+	}
 
 	/*
 	 * select apll as cpu/core clock pll source and
 	 * set up dependent divisors for PERI and ACLK clocks.
 	 * core hz : apll = 1:1
 	 */
-	aclk_div = APLL_HZ / CORE_ACLK_HZ - 1;
-	assert((aclk_div + 1) * CORE_ACLK_HZ == APLL_HZ && aclk_div < 0x7);
-
-	pclk_div = APLL_HZ / CORE_PERI_HZ - 1;
-	assert((pclk_div + 1) * CORE_PERI_HZ == APLL_HZ && pclk_div < 0xf);
-
-	rk_clrsetreg(&cru->cru_clksel_con[0],
-		     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
-		     CORE_CLK_PLL_SEL_APLL << CORE_CLK_PLL_SEL_SHIFT |
-		     0 << CORE_DIV_CON_SHIFT);
-
-	rk_clrsetreg(&cru->cru_clksel_con[1],
-		     CORE_ACLK_DIV_MASK | CORE_PERI_DIV_MASK,
-		     aclk_div << CORE_ACLK_DIV_SHIFT |
-		     pclk_div << CORE_PERI_DIV_SHIFT);
-
-	/*
-	 * select apll as pd_bus bus clock source and
-	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
-	 */
-	aclk_div = GPLL_HZ / BUS_ACLK_HZ - 1;
-	assert((aclk_div + 1) * BUS_ACLK_HZ == GPLL_HZ && aclk_div <= 0x1f);
-
-	pclk_div = GPLL_HZ / BUS_PCLK_HZ - 1;
-	assert((pclk_div + 1) * BUS_PCLK_HZ == GPLL_HZ && pclk_div <= 0x7);
-
-	hclk_div = GPLL_HZ / BUS_HCLK_HZ - 1;
-	assert((hclk_div + 1) * BUS_HCLK_HZ == GPLL_HZ && hclk_div <= 0x3);
-
-	rk_clrsetreg(&cru->cru_clksel_con[0],
-		     BUS_ACLK_PLL_SEL_MASK | BUS_ACLK_DIV_MASK,
-		     BUS_ACLK_PLL_SEL_GPLL << BUS_ACLK_PLL_SEL_SHIFT |
-		     aclk_div << BUS_ACLK_DIV_SHIFT);
-
-	rk_clrsetreg(&cru->cru_clksel_con[1],
-		     BUS_PCLK_DIV_MASK | BUS_HCLK_DIV_MASK,
-		     pclk_div << BUS_PCLK_DIV_SHIFT |
-		     hclk_div << BUS_HCLK_DIV_SHIFT);
-
-	/*
-	 * select gpll as pd_peri bus clock source and
-	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
-	 */
-	aclk_div = GPLL_HZ / PERI_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PERI_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
-
-	hclk_div = ilog2(PERI_ACLK_HZ / PERI_HCLK_HZ);
-	assert((1 << hclk_div) * PERI_HCLK_HZ ==
-		PERI_ACLK_HZ && (hclk_div < 0x4));
-
-	pclk_div = ilog2(PERI_ACLK_HZ / PERI_PCLK_HZ);
-	assert((1 << pclk_div) * PERI_PCLK_HZ ==
-		PERI_ACLK_HZ && pclk_div < 0x8);
-
-	rk_clrsetreg(&cru->cru_clksel_con[10],
-		     PERI_PLL_SEL_MASK | PERI_PCLK_DIV_MASK |
-		     PERI_HCLK_DIV_MASK | PERI_ACLK_DIV_MASK,
-		     PERI_PLL_GPLL << PERI_PLL_SEL_SHIFT |
-		     pclk_div << PERI_PCLK_DIV_SHIFT |
-		     hclk_div << PERI_HCLK_DIV_SHIFT |
-		     aclk_div << PERI_ACLK_DIV_SHIFT);
-
-	/* PLL enter normal-mode */
-	rk_clrsetreg(&cru->cru_mode_con,
-		     GPLL_MODE_MASK | APLL_MODE_MASK,
-		     GPLL_MODE_NORM << GPLL_MODE_SHIFT |
-		     APLL_MODE_NORM << APLL_MODE_SHIFT);
-}
-
-/* Get pll rate by id */
-static uint32_t rkclk_pll_get_rate(struct rk322x_cru *cru,
-				   enum rk_clk_id clk_id)
-{
-	uint32_t refdiv, fbdiv, postdiv1, postdiv2;
-	uint32_t con;
-	int pll_id = rk_pll_id(clk_id);
-	struct rk322x_pll *pll = &cru->pll[pll_id];
-	static u8 clk_shift[CLK_COUNT] = {
-		0xff, APLL_MODE_SHIFT, DPLL_MODE_SHIFT, 0xff,
-		GPLL_MODE_SHIFT, 0xff
-	};
-	static u32 clk_mask[CLK_COUNT] = {
-		0xff, APLL_MODE_MASK, DPLL_MODE_MASK, 0xff,
-		GPLL_MODE_MASK, 0xff
-	};
-	uint shift;
-	uint mask;
-
-	con = readl(&cru->cru_mode_con);
-	shift = clk_shift[clk_id];
-	mask = clk_mask[clk_id];
-
-	switch ((con & mask) >> shift) {
-	case GPLL_MODE_SLOW:
-		return OSC_HZ;
-	case GPLL_MODE_NORM:
-
-		/* normal mode */
-		con = readl(&pll->con0);
-		postdiv1 = (con & PLL_POSTDIV1_MASK) >> PLL_POSTDIV1_SHIFT;
-		fbdiv = (con & PLL_FBDIV_MASK) >> PLL_FBDIV_SHIFT;
-		con = readl(&pll->con1);
-		postdiv2 = (con & PLL_POSTDIV2_MASK) >> PLL_POSTDIV2_SHIFT;
-		refdiv = (con & PLL_REFDIV_MASK) >> PLL_REFDIV_SHIFT;
-		return (24 * fbdiv / (refdiv * postdiv1 * postdiv2)) * 1000000;
-	default:
-		return 32768;
+	old_rate = rockchip_pll_get_rate(&rk322x_pll_clks[APLL],
+					 priv->cru, APLL);
+	if (old_rate > hz) {
+		if (rockchip_pll_set_rate(&rk322x_pll_clks[APLL],
+					  priv->cru, APLL, hz))
+			return -EINVAL;
+		rk_clrsetreg(&cru->cru_clksel_con[0],
+			     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
+			     CORE_CLK_PLL_SEL_APLL << CORE_CLK_PLL_SEL_SHIFT |
+			     0 << CORE_DIV_CON_SHIFT);
+		rk_clrsetreg(&cru->cru_clksel_con[1],
+			     CORE_ACLK_DIV_MASK | CORE_PERI_DIV_MASK,
+			     rate->aclk_div << CORE_ACLK_DIV_SHIFT |
+			     rate->pclk_div << CORE_PERI_DIV_SHIFT);
+	} else if (old_rate < hz) {
+		rk_clrsetreg(&cru->cru_clksel_con[1],
+			     CORE_ACLK_DIV_MASK | CORE_PERI_DIV_MASK,
+			     rate->aclk_div << CORE_ACLK_DIV_SHIFT |
+			     rate->pclk_div << CORE_PERI_DIV_SHIFT);
+		rk_clrsetreg(&cru->cru_clksel_con[0],
+			     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
+			     CORE_CLK_PLL_SEL_APLL << CORE_CLK_PLL_SEL_SHIFT |
+			     0 << CORE_DIV_CON_SHIFT);
+		if (rockchip_pll_set_rate(&rk322x_pll_clks[APLL],
+					  priv->cru, APLL, hz))
+			return -EINVAL;
 	}
+
+	return rockchip_pll_get_rate(&rk322x_pll_clks[APLL], priv->cru, APLL);
 }
 
-static ulong rockchip_mmc_get_clk(struct rk322x_cru *cru, uint clk_general_rate,
-				  int periph)
+static ulong rk322x_mmc_get_clk(struct rk322x_clk_priv *priv,
+				int periph)
 {
+	struct rk322x_cru *cru = priv->cru;
 	uint src_rate;
 	uint div, mux;
 	u32 con;
@@ -220,6 +148,7 @@ static ulong rockchip_mmc_get_clk(struct rk322x_cru *cru, uint clk_general_rate,
 	switch (periph) {
 	case HCLK_EMMC:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 		con = readl(&cru->cru_clksel_con[11]);
 		mux = (con & EMMC_PLL_MASK) >> EMMC_PLL_SHIFT;
 		con = readl(&cru->cru_clksel_con[12]);
@@ -227,28 +156,73 @@ static ulong rockchip_mmc_get_clk(struct rk322x_cru *cru, uint clk_general_rate,
 		break;
 	case HCLK_SDMMC:
 	case SCLK_SDMMC:
+	case SCLK_SDMMC_SAMPLE:
 		con = readl(&cru->cru_clksel_con[11]);
 		mux = (con & MMC0_PLL_MASK) >> MMC0_PLL_SHIFT;
 		div = (con & MMC0_DIV_MASK) >> MMC0_DIV_SHIFT;
 		break;
+	case SCLK_SDIO:
+	case SCLK_SDIO_SAMPLE:
+		con = readl(&cru->cru_clksel_con[11]);
+		mux = (con & SDIO_PLL_MASK) >> SDIO_PLL_SHIFT;
+		con = readl(&cru->cru_clksel_con[12]);
+		div = (con & SDIO_DIV_MASK) >> SDIO_DIV_SHIFT;
+		break;
 	default:
 		return -EINVAL;
 	}
 
-	src_rate = mux == EMMC_SEL_24M ? OSC_HZ : clk_general_rate;
+	src_rate = mux == EMMC_SEL_24M ? OSC_HZ : priv->gpll_hz;
 	return DIV_TO_RATE(src_rate, div) / 2;
 }
 
-static ulong rockchip_mmc_set_clk(struct rk322x_cru *cru, uint clk_general_rate,
-				  int periph, uint freq)
+#ifndef CONFIG_SPL_BUILD
+static ulong rk322x_mac_set_clk(struct rk322x_clk_priv *priv, uint freq)
+{
+	struct rk322x_cru *cru = priv->cru;
+	ulong ret;
+
+	/*
+	 * The gmac clock can be derived either from an external clock
+	 * or can be generated from internally by a divider from SCLK_MAC.
+	 */
+	if (readl(&cru->cru_clksel_con[5]) & BIT(5)) {
+		/* An external clock will always generate the right rate... */
+		ret = freq;
+	} else {
+		u32 con = readl(&cru->cru_clksel_con[5]);
+		ulong pll_rate;
+		u8 div;
+
+		if (con & MAC_PLL_SEL_MASK)
+			pll_rate = priv->gpll_hz;
+		else
+			/* CPLL is not set */
+			return -EPERM;
+
+		div = DIV_ROUND_UP(pll_rate, freq) - 1;
+		if (div <= 0x1f)
+			rk_clrsetreg(&cru->cru_clksel_con[5], CLK_MAC_DIV_MASK,
+				     div << CLK_MAC_DIV_SHIFT);
+		else
+			debug("Unsupported div for gmac:%d\n", div);
+
+		return DIV_TO_RATE(pll_rate, div);
+	}
+
+	return ret;
+}
+#endif
+
+static ulong rk322x_mmc_set_clk(struct rk322x_clk_priv *priv,
+				int periph, uint freq)
 {
+	struct rk322x_cru *cru = priv->cru;
 	int src_clk_div;
 	int mux;
 
-	debug("%s: clk_general_rate=%u\n", __func__, clk_general_rate);
-
 	/* mmc clock defaulg div 2 internal, need provide double in cru */
-	src_clk_div = DIV_ROUND_UP(clk_general_rate / 2, freq);
+	src_clk_div = DIV_ROUND_UP(priv->gpll_hz / 2, freq);
 
 	if (src_clk_div > 128) {
 		src_clk_div = DIV_ROUND_UP(OSC_HZ / 2, freq);
@@ -261,6 +235,7 @@ static ulong rockchip_mmc_set_clk(struct rk322x_cru *cru, uint clk_general_rate,
 	switch (periph) {
 	case HCLK_EMMC:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 		rk_clrsetreg(&cru->cru_clksel_con[11],
 			     EMMC_PLL_MASK,
 			     mux << EMMC_PLL_SHIFT);
@@ -270,64 +245,388 @@ static ulong rockchip_mmc_set_clk(struct rk322x_cru *cru, uint clk_general_rate,
 		break;
 	case HCLK_SDMMC:
 	case SCLK_SDMMC:
+	case SCLK_SDMMC_SAMPLE:
 		rk_clrsetreg(&cru->cru_clksel_con[11],
 			     MMC0_PLL_MASK | MMC0_DIV_MASK,
 			     mux << MMC0_PLL_SHIFT |
 			     (src_clk_div - 1) << MMC0_DIV_SHIFT);
 		break;
+	case SCLK_SDIO:
+	case SCLK_SDIO_SAMPLE:
+		rk_clrsetreg(&cru->cru_clksel_con[11],
+			     SDIO_PLL_MASK,
+			     mux << SDIO_PLL_SHIFT);
+		rk_clrsetreg(&cru->cru_clksel_con[12],
+			     SDIO_DIV_MASK,
+			     (src_clk_div - 1) << SDIO_DIV_SHIFT);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return rk322x_mmc_get_clk(priv, periph);
+}
+
+static ulong rk322x_bus_get_clk(struct rk322x_clk_priv *priv, ulong clk_id)
+{
+	struct rk322x_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_CPU:
+		con = readl(&cru->cru_clksel_con[0]);
+		div = (con & BUS_ACLK_DIV_MASK) >> BUS_ACLK_DIV_SHIFT;
+		parent = priv->gpll_hz;
+		break;
+	case HCLK_CPU:
+		con = readl(&cru->cru_clksel_con[1]);
+		div = (con & BUS_HCLK_DIV_MASK) >> BUS_HCLK_DIV_SHIFT;
+		parent = rk322x_bus_get_clk(priv, ACLK_CPU);
+		break;
+	case PCLK_CPU:
+	case PCLK_I2C0:
+	case PCLK_I2C1:
+	case PCLK_I2C2:
+	case PCLK_I2C3:
+	case PCLK_PWM:
+		con = readl(&cru->cru_clksel_con[1]);
+		div = (con & BUS_PCLK_DIV_MASK) >> BUS_PCLK_DIV_SHIFT;
+		parent = rk322x_bus_get_clk(priv, ACLK_CPU);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk322x_bus_set_clk(struct rk322x_clk_priv *priv,
+				ulong clk_id, ulong hz)
+{
+	struct rk322x_cru *cru = priv->cru;
+	int src_clk_div;
+
+	/*
+	 * select gpll as pd_bus bus clock source and
+	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
+	 */
+	switch (clk_id) {
+	case ACLK_CPU:
+		src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+		assert(src_clk_div - 1 < 32);
+		rk_clrsetreg(&cru->cru_clksel_con[0],
+			     BUS_ACLK_PLL_SEL_MASK | BUS_ACLK_DIV_MASK,
+			     BUS_ACLK_PLL_SEL_GPLL << BUS_ACLK_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << BUS_ACLK_DIV_SHIFT);
+		break;
+	case HCLK_CPU:
+		src_clk_div = DIV_ROUND_UP(rk322x_bus_get_clk(priv,
+							      ACLK_CPU),
+					   hz);
+		assert(src_clk_div - 1 < 4);
+		rk_clrsetreg(&cru->cru_clksel_con[1],
+			     BUS_HCLK_DIV_MASK,
+			     (src_clk_div - 1) << BUS_HCLK_DIV_SHIFT);
+		break;
+	case PCLK_CPU:
+		src_clk_div = DIV_ROUND_UP(rk322x_bus_get_clk(priv,
+							      ACLK_CPU),
+					   hz);
+		assert(src_clk_div - 1 < 8);
+		rk_clrsetreg(&cru->cru_clksel_con[1],
+			     BUS_PCLK_DIV_MASK,
+			     (src_clk_div - 1) << BUS_PCLK_DIV_SHIFT);
+		break;
 	default:
+		printf("do not support this bus freq\n");
 		return -EINVAL;
 	}
 
-	return rockchip_mmc_get_clk(cru, clk_general_rate, periph);
+	return rk322x_bus_get_clk(priv, clk_id);
 }
 
-static int rk322x_ddr_set_clk(struct rk322x_cru *cru, unsigned int set_rate)
+static ulong rk322x_peri_get_clk(struct rk322x_clk_priv *priv, ulong clk_id)
 {
-	struct pll_div dpll_cfg;
+	struct rk322x_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_PERI:
+		con = readl(&cru->cru_clksel_con[10]);
+		div = (con & PERI_ACLK_DIV_MASK) >> PERI_ACLK_DIV_SHIFT;
+		parent = priv->gpll_hz;
+		break;
+	case HCLK_PERI:
+		con = readl(&cru->cru_clksel_con[10]);
+		div = (con & PERI_HCLK_DIV_MASK) >> PERI_HCLK_DIV_SHIFT;
+		parent = rk322x_peri_get_clk(priv, ACLK_PERI);
+		break;
+	case PCLK_PERI:
+		con = readl(&cru->cru_clksel_con[10]);
+		div = (con & PERI_PCLK_DIV_MASK) >> PERI_PCLK_DIV_SHIFT;
+		parent = rk322x_peri_get_clk(priv, ACLK_PERI);
+		break;
+	default:
+		return -ENOENT;
+	}
 
-	/*  clk_ddrc == DPLL = 24MHz / refdiv * fbdiv / postdiv1 / postdiv2 */
-	switch (set_rate) {
-	case 400*MHz:
-		dpll_cfg = (struct pll_div)
-		{.refdiv = 1, .fbdiv = 50, .postdiv1 = 3, .postdiv2 = 1};
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk322x_peri_set_clk(struct rk322x_clk_priv *priv,
+				 ulong clk_id, ulong hz)
+{
+	struct rk322x_cru *cru = priv->cru;
+	int src_clk_div;
+
+	/*
+	 * select gpll as pd_bus bus clock source and
+	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
+	 */
+	switch (clk_id) {
+	case ACLK_PERI:
+		src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+		assert(src_clk_div - 1 < 32);
+		rk_clrsetreg(&cru->cru_clksel_con[10],
+			     PERI_PLL_SEL_MASK | PERI_ACLK_DIV_MASK,
+			     PERI_PLL_GPLL << PERI_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << PERI_ACLK_DIV_SHIFT);
 		break;
-	case 600*MHz:
-		dpll_cfg = (struct pll_div)
-		{.refdiv = 1, .fbdiv = 75, .postdiv1 = 3, .postdiv2 = 1};
+	case HCLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rk322x_peri_get_clk(priv,
+							       ACLK_PERI),
+					   hz);
+		assert(src_clk_div - 1 < 4);
+		rk_clrsetreg(&cru->cru_clksel_con[10],
+			     PERI_HCLK_DIV_MASK,
+			     (src_clk_div - 1) << PERI_HCLK_DIV_SHIFT);
 		break;
-	case 800*MHz:
-		dpll_cfg = (struct pll_div)
-		{.refdiv = 1, .fbdiv = 100, .postdiv1 = 3, .postdiv2 = 1};
+	case PCLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rk322x_peri_get_clk(priv,
+							       ACLK_PERI),
+					   hz);
+		assert(src_clk_div - 1 < 8);
+		rk_clrsetreg(&cru->cru_clksel_con[10],
+			     PERI_PCLK_DIV_MASK,
+			     (src_clk_div - 1) << PERI_PCLK_DIV_SHIFT);
 		break;
+	default:
+		printf("do not support this bus freq\n");
+		return -EINVAL;
 	}
 
-	/* pll enter slow-mode */
-	rk_clrsetreg(&cru->cru_mode_con, DPLL_MODE_MASK,
-		     DPLL_MODE_SLOW << DPLL_MODE_SHIFT);
-	rkclk_set_pll(cru, CLK_DDR, &dpll_cfg);
-	/* PLL enter normal-mode */
-	rk_clrsetreg(&cru->cru_mode_con, DPLL_MODE_MASK,
-		     DPLL_MODE_NORM << DPLL_MODE_SHIFT);
+	return rk322x_peri_get_clk(priv, clk_id);
+}
+
+static ulong rk322x_spi_get_clk(struct rk322x_clk_priv *priv)
+{
+	struct rk322x_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	con = readl(&cru->cru_clksel_con[25]);
+	div = (con & SPI_DIV_MASK) >> SPI_DIV_SHIFT;
+	parent = priv->gpll_hz;
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk322x_spi_set_clk(struct rk322x_clk_priv *priv, ulong hz)
+{
+	struct rk322x_cru *cru = priv->cru;
+	int div;
+
+	div = DIV_ROUND_UP(priv->gpll_hz, hz);
+	assert(div - 1 < 128);
+	rk_clrsetreg(&cru->cru_clksel_con[25],
+		     SPI_PLL_SEL_MASK | SPI_DIV_MASK,
+		     SPI_PLL_SEL_GPLL << SPI_PLL_SEL_SHIFT |
+		     (div - 1) << SPI_DIV_SHIFT);
+	return rk322x_spi_get_clk(priv);
+}
+
+#ifndef CONFIG_SPL_BUILD
+static ulong rk322x_vop_get_clk(struct rk322x_clk_priv *priv, ulong clk_id)
+{
+	struct rk322x_cru *cru = priv->cru;
+	u32 div, con, sel, parent;
+
+	switch (clk_id) {
+	case ACLK_VOP:
+		con = readl(&cru->cru_clksel_con[33]);
+		div = (con & ACLK_VOP_DIV_CON_MASK) >> ACLK_VOP_DIV_CON_SHIFT;
+		parent = priv->gpll_hz;
+		break;
+	case DCLK_VOP:
+		con = readl(&cru->cru_clksel_con[27]);
+		con = (con & DCLK_LCDC_SEL_MASK) >> DCLK_LCDC_SEL_SHIFT;
+		if (con) {
+			sel = readl(&cru->cru_clksel_con[27]);
+			sel = (sel & DCLK_LCDC_PLL_SEL_MASK) >>
+				 DCLK_LCDC_PLL_SEL_SHIFT;
+			if (sel)
+				parent = priv->cpll_hz;
+			else
+				parent = priv->gpll_hz;
+
+			con = readl(&cru->cru_clksel_con[27]);
+			div = (con & DCLK_LCDC_DIV_CON_MASK) >>
+			      DCLK_LCDC_DIV_CON_SHIFT;
+		} else {
+			parent = priv->cpll_hz;
+			div = 1;
+		}
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk322x_vop_set_clk(struct rk322x_clk_priv *priv,
+				ulong clk_id, uint hz)
+{
+	struct rk322x_cru *cru = priv->cru;
+	int src_clk_div;
+	u32 con, parent;
+
+	switch (clk_id) {
+	case ACLK_VOP:
+		src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+		assert(src_clk_div - 1 < 32);
+		rk_clrsetreg(&cru->cru_clksel_con[33],
+			     ACLK_VOP_PLL_SEL_MASK | ACLK_VOP_DIV_CON_MASK,
+			     ACLK_VOP_PLL_SEL_GPLL << ACLK_VOP_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_VOP_DIV_CON_SHIFT);
+		break;
+	case DCLK_VOP:
+		con = readl(&cru->cru_clksel_con[27]);
+		con = (con & DCLK_LCDC_SEL_MASK) >> DCLK_LCDC_SEL_SHIFT;
+		if (con) {
+			parent = readl(&cru->cru_clksel_con[27]);
+			parent = (parent & DCLK_LCDC_PLL_SEL_MASK) >>
+				 DCLK_LCDC_PLL_SEL_SHIFT;
+			if (parent)
+				src_clk_div = DIV_ROUND_UP(priv->cpll_hz, hz);
+			else
+				src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+
+			assert(src_clk_div - 1 < 256);
+			rk_clrsetreg(&cru->cru_clksel_con[27],
+				     DCLK_LCDC_DIV_CON_MASK,
+				     (src_clk_div - 1) <<
+				     DCLK_LCDC_DIV_CON_SHIFT);
+		}
+		break;
+	default:
+		printf("do not support this vop freq\n");
+		return -EINVAL;
+	}
+
+	return rk322x_vop_get_clk(priv, clk_id);
+}
+
+static ulong rk322x_crypto_get_clk(struct rk322x_clk_priv *priv, ulong clk_id)
+{
+	struct rk322x_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case SCLK_CRYPTO:
+		con = readl(&cru->cru_clksel_con[24]);
+		div = (con & CRYPTO_DIV_MASK) >> CRYPTO_DIV_SHIFT;
+		parent = priv->gpll_hz;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk322x_crypto_set_clk(struct rk322x_clk_priv *priv, ulong clk_id,
+				   ulong hz)
+{
+	struct rk322x_cru *cru = priv->cru;
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+	assert(src_clk_div - 1 <= 31);
 
-	return set_rate;
+	/*
+	 * select gpll as crypto clock source and
+	 * set up dependent divisors for crypto clocks.
+	 */
+	switch (clk_id) {
+	case SCLK_CRYPTO:
+		rk_clrsetreg(&cru->cru_clksel_con[24],
+			     CRYPTO_PLL_SEL_MASK | CRYPTO_DIV_MASK,
+			     CRYPTO_PLL_SEL_GPLL << CRYPTO_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << CRYPTO_DIV_SHIFT);
+		break;
+	default:
+		printf("do not support this peri freq\n");
+		return -EINVAL;
+	}
+
+	return rk322x_crypto_get_clk(priv, clk_id);
 }
+#endif
+
 static ulong rk322x_clk_get_rate(struct clk *clk)
 {
 	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
-	ulong rate, gclk_rate;
+	ulong rate;
 
-	gclk_rate = rkclk_pll_get_rate(priv->cru, CLK_GENERAL);
 	switch (clk->id) {
-	case 0 ... 63:
-		rate = rkclk_pll_get_rate(priv->cru, clk->id);
+	case PLL_APLL:
+	case PLL_DPLL:
+	case PLL_CPLL:
+	case PLL_GPLL:
+		rate = rockchip_pll_get_rate(&rk322x_pll_clks[clk->id - 1],
+					     priv->cru, clk->id - 1);
+		break;
+	case ARMCLK:
+		rate = rockchip_pll_get_rate(&rk322x_pll_clks[APLL],
+					     priv->cru, APLL);
 		break;
 	case HCLK_EMMC:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 	case HCLK_SDMMC:
 	case SCLK_SDMMC:
-		rate = rockchip_mmc_get_clk(priv->cru, gclk_rate, clk->id);
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO:
+	case SCLK_SDIO_SAMPLE:
+		rate = rk322x_mmc_get_clk(priv, clk->id);
+		break;
+	case SCLK_SPI0:
+		rate = rk322x_spi_get_clk(priv);
+		break;
+	case ACLK_CPU:
+	case HCLK_CPU:
+	case PCLK_CPU:
+	case PCLK_I2C0:
+	case PCLK_I2C1:
+	case PCLK_I2C2:
+	case PCLK_I2C3:
+	case PCLK_PWM:
+		rate = rk322x_bus_get_clk(priv, clk->id);
+		break;
+	case ACLK_PERI:
+	case HCLK_PERI:
+	case PCLK_PERI:
+		rate = rk322x_peri_get_clk(priv, clk->id);
 		break;
+#ifndef CONFIG_SPL_BUILD
+	case DCLK_VOP:
+	case ACLK_VOP:
+		rate = rk322x_vop_get_clk(priv, clk->id);
+		break;
+	case SCLK_CRYPTO:
+		rate = rk322x_crypto_get_clk(priv, clk->id);
+		break;
+#endif
 	default:
 		return -ENOENT;
 	}
@@ -338,58 +637,437 @@ static ulong rk322x_clk_get_rate(struct clk *clk)
 static ulong rk322x_clk_set_rate(struct clk *clk, ulong rate)
 {
 	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
-	ulong new_rate, gclk_rate;
+	ulong ret = 0;
 
-	gclk_rate = rkclk_pll_get_rate(priv->cru, CLK_GENERAL);
 	switch (clk->id) {
+	case PLL_APLL:
+	case PLL_DPLL:
+		ret = rockchip_pll_set_rate(&rk322x_pll_clks[clk->id - 1],
+					    priv->cru, clk->id - 1, rate);
+		break;
+	case PLL_CPLL:
+		ret = rockchip_pll_set_rate(&rk322x_pll_clks[CPLL],
+					    priv->cru, CPLL, rate);
+		priv->cpll_hz = rate;
+		break;
+	case PLL_GPLL:
+		ret = rockchip_pll_set_rate(&rk322x_pll_clks[GPLL],
+					    priv->cru, GPLL, rate);
+		priv->gpll_hz = rate;
+		break;
+	case ARMCLK:
+		if (priv->armclk_hz)
+			ret = rk322x_armclk_set_clk(priv, rate);
+		priv->armclk_hz = rate;
+		break;
 	case HCLK_EMMC:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 	case HCLK_SDMMC:
 	case SCLK_SDMMC:
-		new_rate = rockchip_mmc_set_clk(priv->cru, gclk_rate,
-						clk->id, rate);
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO:
+	case SCLK_SDIO_SAMPLE:
+		ret = rk322x_mmc_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_DDRC:
+		ret = rockchip_pll_set_rate(&rk322x_pll_clks[DPLL],
+					    priv->cru, DPLL, rate);
+		break;
+	case SCLK_SPI0:
+		rate = rk322x_spi_set_clk(priv, rate);
+		break;
+	case ACLK_CPU:
+	case HCLK_CPU:
+	case PCLK_CPU:
+		ret = rk322x_bus_set_clk(priv, clk->id, rate);
+		break;
+	case ACLK_PERI:
+	case HCLK_PERI:
+	case PCLK_PERI:
+		ret = rk322x_peri_set_clk(priv, clk->id, rate);
+		break;
+#ifndef CONFIG_SPL_BUILD
+	case SCLK_MAC_SRC:
+	case SCLK_MAC:
+		ret = rk322x_mac_set_clk(priv, rate);
+		break;
+	case DCLK_VOP:
+	case ACLK_VOP:
+		ret = rk322x_vop_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_CRYPTO:
+		ret = rk322x_crypto_set_clk(priv, clk->id, rate);
+		break;
+#endif
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+#ifndef CONFIG_SPL_BUILD
+static int rk322x_gmac_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk322x_cru *cru = priv->cru;
+
+	/*
+	 * If the requested parent is in the same clock-controller and the id
+	 * is SCLK_MAC_SRC ("sclk_gmac_src"), switch to the internal clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC_SRC)) {
+		debug("%s: switching RGMII to SCLK_MAC_SRC\n", __func__);
+		rk_clrsetreg(&cru->cru_clksel_con[5], BIT(5), 0);
+		return 0;
+	}
+
+	/*
+	 * If the requested parent is in the same clock-controller and the id
+	 * is SCLK_MAC_EXTCLK (sclk_mac_extclk), switch to the external clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC_EXTCLK)) {
+		debug("%s: switching RGMII to SCLK_MAC_EXTCLK\n", __func__);
+		rk_clrsetreg(&cru->cru_clksel_con[5], BIT(5), BIT(5));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int rk322x_gmac_extclk_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
+	const char *clock_output_name;
+	struct rk322x_cru *cru = priv->cru;
+	int ret;
+
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	if (!strcmp(clock_output_name, "ext_gmac")) {
+		debug("%s: switching gmac extclk to ext_gmac\n", __func__);
+		rk_clrsetreg(&cru->cru_clksel_con[29], BIT(10), 0);
+		return 0;
+	} else if (!strcmp(clock_output_name, "phy_50m_out")) {
+		debug("%s: switching gmac extclk to phy_50m_out\n", __func__);
+		rk_clrsetreg(&cru->cru_clksel_con[29], BIT(10), BIT(10));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int rk322x_lcdc_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
+
+	if (parent->id == HDMIPHY)
+		rk_clrsetreg(&priv->cru->cru_clksel_con[27],
+			     DCLK_LCDC_SEL_MASK,
+			     DCLK_LCDC_SEL_HDMIPHY << DCLK_LCDC_SEL_SHIFT);
+	else if (parent->id == PLL_CPLL)
+		rk_clrsetreg(&priv->cru->cru_clksel_con[27],
+			     DCLK_LCDC_SEL_MASK | DCLK_LCDC_PLL_SEL_MASK,
+			     (DCLK_LCDC_SEL_PLL << DCLK_LCDC_SEL_SHIFT) |
+			     (DCLK_LCDC_PLL_SEL_CPLL <<
+			     DCLK_LCDC_PLL_SEL_SHIFT));
+	else
+		rk_clrsetreg(&priv->cru->cru_clksel_con[27],
+			     DCLK_LCDC_SEL_MASK | DCLK_LCDC_PLL_SEL_MASK,
+			     (DCLK_LCDC_SEL_PLL << DCLK_LCDC_SEL_SHIFT) |
+			     (DCLK_LCDC_PLL_SEL_GPLL <<
+			     DCLK_LCDC_PLL_SEL_SHIFT));
+
+	return 0;
+}
+#endif
+
+static int rk322x_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	switch (clk->id) {
+#ifndef CONFIG_SPL_BUILD
+	case SCLK_MAC:
+		return rk322x_gmac_set_parent(clk, parent);
+	case SCLK_MAC_EXTCLK:
+		return rk322x_gmac_extclk_set_parent(clk, parent);
+	case DCLK_VOP:
+		return rk322x_lcdc_set_parent(clk, parent);
+#endif
+	}
+
+	debug("%s: unsupported clk %ld\n", __func__, clk->id);
+	return -ENOENT;
+}
+
+#define ROCKCHIP_MMC_DELAY_SEL		BIT(10)
+#define ROCKCHIP_MMC_DEGREE_MASK	0x3
+#define ROCKCHIP_MMC_DELAYNUM_OFFSET	2
+#define ROCKCHIP_MMC_DELAYNUM_MASK	(0xff << ROCKCHIP_MMC_DELAYNUM_OFFSET)
+
+#define PSECS_PER_SEC 1000000000000LL
+/*
+ * Each fine delay is between 44ps-77ps. Assume each fine delay is 60ps to
+ * simplify calculations. So 45degs could be anywhere between 33deg and 57.8deg.
+ */
+#define ROCKCHIP_MMC_DELAY_ELEMENT_PSEC 60
+
+int rk322x_mmc_get_phase(struct clk *clk)
+{
+	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk322x_cru *cru = priv->cru;
+	u32 raw_value, delay_num;
+	u16 degrees = 0;
+	ulong rate;
+
+	rate = rk322x_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		raw_value = readl(&cru->cru_emmc_con[1]);
+	else if (clk->id == SCLK_SDMMC_SAMPLE)
+		raw_value = readl(&cru->cru_sdmmc_con[1]);
+	else
+		raw_value = readl(&cru->cru_sdio_con[1]);
+
+	raw_value >>= 1;
+	degrees = (raw_value & ROCKCHIP_MMC_DEGREE_MASK) * 90;
+
+	if (raw_value & ROCKCHIP_MMC_DELAY_SEL) {
+		/* degrees/delaynum * 10000 */
+		unsigned long factor = (ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10) *
+					36 * (rate / 1000000);
+
+		delay_num = (raw_value & ROCKCHIP_MMC_DELAYNUM_MASK);
+		delay_num >>= ROCKCHIP_MMC_DELAYNUM_OFFSET;
+		degrees += DIV_ROUND_CLOSEST(delay_num * factor, 10000);
+	}
+
+	return degrees % 360;
+}
+
+int rk322x_mmc_set_phase(struct clk *clk, u32 degrees)
+{
+	struct rk322x_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk322x_cru *cru = priv->cru;
+	u8 nineties, remainder, delay_num;
+	u32 raw_value, delay;
+	ulong rate;
+
+	rate = rk322x_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	nineties = degrees / 90;
+	remainder = (degrees % 90);
+
+	/*
+	 * Convert to delay; do a little extra work to make sure we
+	 * don't overflow 32-bit / 64-bit numbers.
+	 */
+	delay = 10000000; /* PSECS_PER_SEC / 10000 / 10 */
+	delay *= remainder;
+	delay = DIV_ROUND_CLOSEST(delay, (rate / 1000) * 36 *
+				(ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10));
+
+	delay_num = (u8)min_t(u32, delay, 255);
+
+	raw_value = delay_num ? ROCKCHIP_MMC_DELAY_SEL : 0;
+	raw_value |= delay_num << ROCKCHIP_MMC_DELAYNUM_OFFSET;
+	raw_value |= nineties;
+
+	raw_value <<= 1;
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->cru_emmc_con[1]);
+	else if (clk->id == SCLK_SDMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->cru_sdmmc_con[1]);
+	else
+		writel(raw_value | 0xffff0000, &cru->cru_sdio_con[1]);
+
+	debug("mmc set_phase(%d) delay_nums=%u reg=%#x actual_degrees=%d\n",
+	      degrees, delay_num, raw_value, rk322x_mmc_get_phase(clk));
+
+	return 0;
+}
+
+static int rk322x_clk_get_phase(struct clk *clk)
+{
+	int ret;
+
+	debug("%s %ld\n", __func__, clk->id);
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO_SAMPLE:
+		ret = rk322x_mmc_get_phase(clk);
 		break;
-	case CLK_DDR:
-		new_rate = rk322x_ddr_set_clk(priv->cru, rate);
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+static int rk322x_clk_set_phase(struct clk *clk, int degrees)
+{
+	int ret;
+
+	debug("%s %ld\n", __func__, clk->id);
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO_SAMPLE:
+		ret = rk322x_mmc_set_phase(clk, degrees);
 		break;
 	default:
 		return -ENOENT;
 	}
 
-	return new_rate;
+	return ret;
 }
 
 static struct clk_ops rk322x_clk_ops = {
 	.get_rate	= rk322x_clk_get_rate,
 	.set_rate	= rk322x_clk_set_rate,
+	.set_parent	= rk322x_clk_set_parent,
+	.get_phase	= rk322x_clk_get_phase,
+	.set_phase	= rk322x_clk_set_phase,
 };
 
 static int rk322x_clk_ofdata_to_platdata(struct udevice *dev)
 {
 	struct rk322x_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk322x_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
 
 	return 0;
 }
 
+#ifndef CONFIG_TPL_BUILD
+static void rkclk_init(struct rk322x_clk_priv *priv)
+{
+	struct rk322x_cru *cru = priv->cru;
+
+	if (rockchip_pll_get_rate(&rk322x_pll_clks[APLL],
+				  priv->cru, APLL) != APLL_HZ)
+		rk322x_armclk_set_clk(priv, APLL_HZ);
+
+	priv->gpll_hz = rockchip_pll_get_rate(&rk322x_pll_clks[GPLL],
+					      priv->cru, GPLL);
+	priv->cpll_hz = rockchip_pll_get_rate(&rk322x_pll_clks[CPLL],
+					      priv->cru, CPLL);
+
+	/* before set pll set child div first */
+	rk322x_bus_set_clk(priv, ACLK_CPU, ACLK_BUS_HZ / 4);
+	rk322x_peri_set_clk(priv, ACLK_PERI, ACLK_PERI_HZ / 4);
+	rk322x_mmc_set_clk(priv, SCLK_EMMC, 50000000);
+	rk322x_mmc_set_clk(priv, SCLK_SDMMC, 50000000);
+	rk322x_mmc_set_clk(priv, SCLK_SDIO, 50000000);
+	rk_clrsetreg(&cru->cru_clksel_con[2], (0x1 << 14) |
+		     (0x1f << 8), (1 << 14) | (0xb << 8));
+	rk_clrsetreg(&cru->cru_clksel_con[23], (0x1f << 0) | (0x1f << 8),
+		     (0x1f << 0) | (5 << 8));
+	rk_clrsetreg(&cru->cru_clksel_con[33],
+		     ACLK_VOP_PLL_SEL_MASK | ACLK_VOP_DIV_CON_MASK,
+		     ACLK_VOP_PLL_SEL_GPLL << ACLK_VOP_PLL_SEL_SHIFT |
+		     3 << ACLK_VOP_DIV_CON_SHIFT);
+	rk_clrsetreg(&cru->cru_clksel_con[22], 0x1f << 0, 5 << 0);
+	rk_clrsetreg(&cru->cru_clksel_con[24], 0x1f << 0, 0xb << 0);
+	rk_clrsetreg(&cru->cru_clksel_con[28], (0x1f << 8) | (0x1f << 0),
+		     (5 << 8) | (5 << 0));
+	rk_clrsetreg(&cru->cru_clksel_con[31], (0x1f << 8) | (0x1f << 0),
+		     (5 << 8) | (5 << 0));
+	rk_clrsetreg(&cru->cru_clksel_con[32], 0x1f << 0, 5 << 0);
+	rk_clrsetreg(&cru->cru_clksel_con[33], (0x1f << 8) | (0x1f << 0),
+		     (5 << 8) | (5 << 0));
+	rk_clrsetreg(&cru->cru_clksel_con[34], (0x1f << 8) | (0x1f << 0),
+		     (5 << 8) | (3 << 0));
+
+	rockchip_pll_set_rate(&rk322x_pll_clks[GPLL],
+			      priv->cru, GPLL, GPLL_HZ);
+	priv->gpll_hz = GPLL_HZ;
+
+	rockchip_pll_set_rate(&rk322x_pll_clks[CPLL],
+			      priv->cru, CPLL, CPLL_HZ);
+	priv->cpll_hz = CPLL_HZ;
+
+	rk322x_bus_set_clk(priv, ACLK_CPU, ACLK_BUS_HZ);
+	rk322x_bus_set_clk(priv, HCLK_CPU, ACLK_BUS_HZ / 2);
+	rk322x_bus_set_clk(priv, PCLK_CPU, ACLK_BUS_HZ / 2);
+	rk322x_peri_set_clk(priv, ACLK_PERI, ACLK_PERI_HZ);
+	rk322x_peri_set_clk(priv, HCLK_PERI, ACLK_PERI_HZ / 2);
+	rk322x_peri_set_clk(priv, PCLK_PERI, ACLK_PERI_HZ / 2);
+	/*rk322x_mmc_set_clk(priv, SCLK_EMMC, rate);*/
+
+	/* set usbphy and hdmiphy from phy */
+	rk_clrsetreg(&cru->cru_misc_con, (0x1 << 13) |
+		     (0x1 << 15), (0 << 15) | (0 << 13));
+}
+#endif
+
 static int rk322x_clk_probe(struct udevice *dev)
 {
+#ifndef CONFIG_TPL_BUILD
 	struct rk322x_clk_priv *priv = dev_get_priv(dev);
-
-	rkclk_init(priv->cru);
-
+	int ret = 0;
+
+	priv->sync_kernel = false;
+	if (!priv->armclk_enter_hz)
+		priv->armclk_enter_hz =
+		rockchip_pll_get_rate(&rk322x_pll_clks[APLL],
+				      priv->cru, APLL);
+	rkclk_init(priv);
+	if (!priv->armclk_init_hz)
+		priv->armclk_init_hz =
+		rockchip_pll_get_rate(&rk322x_pll_clks[APLL],
+				      priv->cru, APLL);
+	ret = clk_set_defaults(dev);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+	else
+		priv->sync_kernel = true;
+#endif
 	return 0;
 }
 
 static int rk322x_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk322x_sysreset", "reset", &dev);
-	if (ret)
-		debug("Warning: No RK3036 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk322x_cru,
+						    cru_glb_srst_fst_value);
+		priv->glb_srst_snd_value = offsetof(struct rk322x_cru,
+						    cru_glb_srst_snd_value);
+		sys_child->priv = priv;
+	}
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk322x_cru,
+						    cru_softrst_con[0]);
+		sf_priv->sf_reset_num = 9;
+		sf_child->priv = sf_priv;
+	}
 
 	return 0;
 }
@@ -409,3 +1087,69 @@ U_BOOT_DRIVER(rockchip_rk322x_cru) = {
 	.bind		= rk322x_clk_bind,
 	.probe		= rk322x_clk_probe,
 };
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev;
+	struct rk322x_clk_priv *priv;
+	const struct rk322x_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk322x_cru),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arm: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armclk_enter_hz / 1000,
+	       priv->armclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
diff --git a/drivers/clk/rockchip/clk_rk3288.c b/drivers/clk/rockchip/clk_rk3288.c
index 478195b10b..4f4a34f63e 100644
--- a/drivers/clk/rockchip/clk_rk3288.c
+++ b/drivers/clk/rockchip/clk_rk3288.c
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <bitfield.h>
 #include <clk-uclass.h>
 #include <dm.h>
 #include <dt-structs.h>
@@ -12,10 +13,10 @@
 #include <mapmem.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3288.h>
-#include <asm/arch/grf_rk3288.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3288.h>
+#include <asm/arch-rockchip/grf_rk3288.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <dt-bindings/clock/rk3288-cru.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
@@ -31,11 +32,47 @@ struct rk3288_clk_plat {
 };
 
 struct pll_div {
+	ulong rate;
 	u32 nr;
 	u32 nf;
 	u32 no;
+	u32 nb;
 };
 
+#define RK3288_PLL_RATE(_rate, _nr, _nf, _no, _nb)	\
+{							\
+	.rate	= _rate##U,				\
+	.nr = _nr,					\
+	.nf = _nf,					\
+	.no = _no,					\
+	.nb = _nb,					\
+}
+
+static struct pll_div rk3288_pll_rates[] = {
+	/* _mhz,  _nr, _nf, _no, _nb */
+	RK3288_PLL_RATE(1188000000, 1, 99, 2, 16),
+	RK3288_PLL_RATE(594000000, 1, 99, 4, 16),
+	RK3288_PLL_RATE(297000000, 1, 99, 8, 16),
+};
+
+#ifndef CONFIG_SPL_BUILD
+#define RK3288_CLK_DUMP(_id, _name, _iscru)	\
+{						\
+	.id = _id,				\
+	.name = _name,				\
+	.is_cru = _iscru,			\
+}
+
+static const struct rk3288_clk_info clks_dump[] = {
+	RK3288_CLK_DUMP(PLL_APLL, "apll", true),
+	RK3288_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK3288_CLK_DUMP(PLL_CPLL, "cpll", true),
+	RK3288_CLK_DUMP(PLL_GPLL, "gpll", true),
+	RK3288_CLK_DUMP(PLL_NPLL, "npll", true),
+	RK3288_CLK_DUMP(ACLK_CPU, "aclk_bus", true),
+};
+#endif
+
 enum {
 	VCO_MAX_HZ	= 2200U * 1000000,
 	VCO_MIN_HZ	= 440 * 1000000,
@@ -69,7 +106,8 @@ enum {
 	M0_DIV_MASK		= 0xf << M0_DIV_SHIFT,
 
 	/* CLKSEL1: pd bus clk pll sel: codec or general */
-	PD_BUS_SEL_PLL_MASK	= 15,
+	PD_BUS_SEL_PLL_SHIFT	= 15,
+	PD_BUS_SEL_PLL_MASK	= 1 << PD_BUS_SEL_PLL_SHIFT,
 	PD_BUS_SEL_CPLL		= 0,
 	PD_BUS_SEL_GPLL,
 
@@ -87,6 +125,11 @@ enum {
 	PD_BUS_ACLK_DIV1_SHIFT	= 0,
 	PD_BUS_ACLK_DIV1_MASK	= 0x7 << PD_BUS_ACLK_DIV1_SHIFT,
 
+	/* CLKSEL2: tsadc */
+	CLK_TSADC_DIV_CON_SHIFT	= 0,
+	CLK_TSADC_DIV_CON_MASK		= GENMASK(5, 0),
+	CLK_TSADC_DIV_CON_WIDTH	= 6,
+
 	/*
 	 * CLKSEL10
 	 * peripheral bus pclk div:
@@ -111,6 +154,52 @@ enum {
 	PERI_ACLK_DIV_SHIFT	= 0,
 	PERI_ACLK_DIV_MASK	= 0x1f << PERI_ACLK_DIV_SHIFT,
 
+	/*
+	 * CLKSEL24
+	 * saradc_div_con:
+	 * clk_saradc=24MHz/(saradc_div_con+1)
+	 */
+	CLK_SARADC_DIV_CON_SHIFT	= 8,
+	CLK_SARADC_DIV_CON_MASK		= GENMASK(15, 8),
+	CLK_SARADC_DIV_CON_WIDTH	= 8,
+
+	/* CLKSEL26 */
+	CLK_CRYPTO_DIV_CON_SHIFT	= 6,
+	CLK_CRYPTO_DIV_CON_MASK		= GENMASK(7, 6),
+
+	/* CLKSEL33 */
+	PCLK_ALIVE_DIV_CON_SHIFT	= 8,
+	PCLK_ALIVE_DIV_CON_MASK		= 0x1f << PCLK_ALIVE_DIV_CON_SHIFT,
+
+	/* CLKSEL39 */
+	ACLK_HEVC_SEL_PLL_SHIFT		= 14,
+	ACLK_HEVC_SEL_PLL_MASK		= 0x3 << ACLK_HEVC_SEL_PLL_SHIFT,
+	ACLK_HEVC_SEL_CPLL		= 0,
+	ACLK_HEVC_SEL_GPLL,
+	ACLK_HEVC_DIV_CON_SHIFT		= 8,
+	ACLK_HEVC_DIV_CON_MASK		= 0x1f << ACLK_HEVC_DIV_CON_SHIFT,
+
+	/* CLKSEL42 */
+	CLK_HEVC_CORE_SEL_PLL_SHIFT	= 14,
+	CLK_HEVC_CORE_SEL_PLL_MASK	= 0x3 << CLK_HEVC_CORE_SEL_PLL_SHIFT,
+	CLK_HEVC_CORE_SEL_CPLL		= 0,
+	CLK_HEVC_CORE_SEL_GPLL,
+	CLK_HEVC_CORE_DIV_CON_SHIFT	= 8,
+	CLK_HEVC_CORE_DIV_CON_MASK	= 0x1f << CLK_HEVC_CORE_DIV_CON_SHIFT,
+	CLK_HEVC_CABAC_SEL_PLL_SHIFT	= 6,
+	CLK_HEVC_CABAC_SEL_PLL_MASK	= 0x3 << CLK_HEVC_CABAC_SEL_PLL_SHIFT,
+	CLK_HEVC_CABAC_SEL_CPLL		= 0,
+	CLK_HEVC_CABAC_SEL_GPLL,
+	CLK_HEVC_CABAC_DIV_CON_SHIFT	= 0,
+	CLK_HEVC_CABAC_DIV_CON_MASK	= 0x1f << CLK_HEVC_CABAC_DIV_CON_SHIFT,
+
+	/* MISC */
+	CLK_TEST_SRC_SEL_SHIFT		= 8,
+	CLK_TEST_SRC_SEL_MASK		= 0xf << CLK_TEST_SRC_SEL_SHIFT,
+	CLK_TEST_SRC_SEL_24M		= 8,
+	CLK_TEST_SRC_SEL_27M,
+	CLK_TEST_SRC_SEL_32k,
+
 	SOCSTS_DPLL_LOCK	= 1 << 5,
 	SOCSTS_APLL_LOCK	= 1 << 6,
 	SOCSTS_CPLL_LOCK	= 1 << 7,
@@ -128,9 +217,21 @@ enum {
 
 /* Keep divisors as low as possible to reduce jitter and power usage */
 static const struct pll_div apll_init_cfg = PLL_DIVISORS(APLL_HZ, 1, 1);
-static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 2, 2);
+static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 1, 4);
 static const struct pll_div cpll_init_cfg = PLL_DIVISORS(CPLL_HZ, 1, 2);
 
+struct pll_div *rkclk_get_pll_config(ulong freq_hz)
+{
+	unsigned int rate_count = ARRAY_SIZE(rk3288_pll_rates);
+	int i;
+
+	for (i = 0; i < rate_count; i++) {
+		if (freq_hz == rk3288_pll_rates[i].rate)
+			return &rk3288_pll_rates[i];
+	}
+	return NULL;
+}
+
 static int rkclk_set_pll(struct rk3288_cru *cru, enum rk_clk_id clk_id,
 			 const struct pll_div *div)
 {
@@ -142,9 +243,6 @@ static int rkclk_set_pll(struct rk3288_cru *cru, enum rk_clk_id clk_id,
 
 	debug("PLL at %x: nf=%d, nr=%d, no=%d, vco=%u Hz, output=%u Hz\n",
 	      (uint)pll, div->nf, div->nr, div->no, vco_hz, output_hz);
-	assert(vco_hz >= VCO_MIN_HZ && vco_hz <= VCO_MAX_HZ &&
-	       output_hz >= OUTPUT_MIN_HZ && output_hz <= OUTPUT_MAX_HZ &&
-	       (div->no == 1 || !(div->no % 2)));
 
 	/* enter reset */
 	rk_setreg(&pll->con3, 1 << PLL_RESET_SHIFT);
@@ -152,7 +250,12 @@ static int rkclk_set_pll(struct rk3288_cru *cru, enum rk_clk_id clk_id,
 	rk_clrsetreg(&pll->con0, CLKR_MASK | PLL_OD_MASK,
 		     ((div->nr - 1) << CLKR_SHIFT) | (div->no - 1));
 	rk_clrsetreg(&pll->con1, CLKF_MASK, div->nf - 1);
-	rk_clrsetreg(&pll->con2, PLL_BWADJ_MASK, (div->nf >> 1) - 1);
+
+	/* adjust pll bw for better clock jitter */
+	if (div->nb)
+		rk_clrsetreg(&pll->con2, PLL_BWADJ_MASK, div->nb - 1);
+	else
+		rk_clrsetreg(&pll->con2, PLL_BWADJ_MASK, (div->nf >> 1) - 1);
 
 	udelay(10);
 
@@ -162,6 +265,40 @@ static int rkclk_set_pll(struct rk3288_cru *cru, enum rk_clk_id clk_id,
 	return 0;
 }
 
+/* Get pll rate by id */
+static u32 rkclk_pll_get_rate(struct rk3288_cru *cru,
+			      enum rk_clk_id clk_id)
+{
+	u32 nr, no, nf;
+	u32 con;
+	int pll_id = rk_pll_id(clk_id);
+	struct rk3288_pll *pll = &cru->pll[pll_id];
+	static u8 clk_shift[CLK_COUNT] = {
+		0xff, APLL_MODE_SHIFT, DPLL_MODE_SHIFT, CPLL_MODE_SHIFT,
+		GPLL_MODE_SHIFT, NPLL_MODE_SHIFT
+	};
+	uint shift;
+
+	con = readl(&cru->cru_mode_con);
+	shift = clk_shift[clk_id];
+	switch ((con >> shift) & CRU_MODE_MASK) {
+	case APLL_MODE_SLOW:
+		return OSC_HZ;
+	case APLL_MODE_NORMAL:
+		/* normal mode */
+		con = readl(&pll->con0);
+		no = ((con & CLKOD_MASK) >> CLKOD_SHIFT) + 1;
+		nr = ((con & CLKR_MASK) >> CLKR_SHIFT) + 1;
+		con = readl(&pll->con1);
+		nf = ((con & CLKF_MASK) >> CLKF_SHIFT) + 1;
+
+		return (24 * nf / (nr * no)) * 1000000;
+	case APLL_MODE_DEEP:
+	default:
+		return 32768;
+	}
+}
+
 static int rkclk_configure_ddr(struct rk3288_cru *cru, struct rk3288_grf *grf,
 			       unsigned int hz)
 {
@@ -213,9 +350,11 @@ static int rkclk_configure_ddr(struct rk3288_cru *cru, struct rk3288_grf *grf,
 #define VCO_MIN_KHZ	440000
 #define FREF_MAX_KHZ	2200000
 #define FREF_MIN_KHZ	269
+#define PLL_LIMIT_FREQ	594000000
 
 static int pll_para_config(ulong freq_hz, struct pll_div *div, uint *ext_div)
 {
+	struct pll_div *best_div = NULL;
 	uint ref_khz = OSC_HZ / 1000, nr, nf = 0;
 	uint fref_khz;
 	uint diff_khz, best_diff_khz;
@@ -231,10 +370,19 @@ static int pll_para_config(ulong freq_hz, struct pll_div *div, uint *ext_div)
 
 	no = DIV_ROUND_UP(VCO_MIN_KHZ, freq_khz);
 	if (ext_div) {
-		*ext_div = DIV_ROUND_UP(no, max_no);
+		*ext_div = DIV_ROUND_UP(PLL_LIMIT_FREQ, freq_hz);
 		no = DIV_ROUND_UP(no, *ext_div);
 	}
 
+	best_div = rkclk_get_pll_config(freq_hz * (*ext_div));
+	if (best_div) {
+		div->nr = best_div->nr;
+		div->nf = best_div->nf;
+		div->no = best_div->no;
+		div->nb = best_div->nb;
+		return 0;
+	}
+
 	/* only even divisors (and 1) are supported */
 	if (no > 1)
 		no = DIV_ROUND_UP(no, 2) * 2;
@@ -285,51 +433,150 @@ static int pll_para_config(ulong freq_hz, struct pll_div *div, uint *ext_div)
 	return 0;
 }
 
-static int rockchip_mac_set_clk(struct rk3288_cru *cru,
-				  int periph, uint freq)
+static int rockchip_mac_set_clk(struct rk3288_cru *cru, uint freq)
 {
-	/* Assuming mac_clk is fed by an external clock */
-	rk_clrsetreg(&cru->cru_clksel_con[21],
-		     RMII_EXTCLK_MASK,
-		     RMII_EXTCLK_SELECT_EXT_CLK << RMII_EXTCLK_SHIFT);
+	ulong ret;
 
-	 return 0;
+	/*
+	 * The gmac clock can be derived either from an external clock
+	 * or can be generated from internally by a divider from SCLK_MAC.
+	 */
+	if (readl(&cru->cru_clksel_con[21]) & RMII_EXTCLK_MASK) {
+		/* An external clock will always generate the right rate... */
+		ret = freq;
+	} else {
+		u32 con = readl(&cru->cru_clksel_con[21]);
+		ulong pll_rate;
+		u8 div;
+
+		if (((con >> EMAC_PLL_SHIFT) & EMAC_PLL_MASK) ==
+		    EMAC_PLL_SELECT_GENERAL)
+			pll_rate = GPLL_HZ;
+		else if (((con >> EMAC_PLL_SHIFT) & EMAC_PLL_MASK) ==
+			 EMAC_PLL_SELECT_CODEC)
+			pll_rate = CPLL_HZ;
+		else
+			pll_rate = NPLL_HZ;
+
+		div = DIV_ROUND_UP(pll_rate, freq) - 1;
+		if (div <= 0x1f)
+			rk_clrsetreg(&cru->cru_clksel_con[21], MAC_DIV_CON_MASK,
+				     div << MAC_DIV_CON_SHIFT);
+		else
+			debug("Unsupported div for gmac:%d\n", div);
+
+		return DIV_TO_RATE(pll_rate, div);
+	}
+
+	return ret;
 }
 
 static int rockchip_vop_set_clk(struct rk3288_cru *cru, struct rk3288_grf *grf,
 				int periph, unsigned int rate_hz)
 {
-	struct pll_div npll_config = {0};
-	u32 lcdc_div;
+	struct pll_div cpll_config = {0};
+	u32 lcdc_div, parent;
 	int ret;
+	unsigned int gpll_rate, npll_rate;
 
-	ret = pll_para_config(rate_hz, &npll_config, &lcdc_div);
-	if (ret)
-		return ret;
-
-	rk_clrsetreg(&cru->cru_mode_con, NPLL_MODE_MASK,
-		     NPLL_MODE_SLOW << NPLL_MODE_SHIFT);
-	rkclk_set_pll(cru, CLK_NEW, &npll_config);
-
-	/* waiting for pll lock */
-	while (1) {
-		if (readl(&grf->soc_status[1]) & SOCSTS_NPLL_LOCK)
-			break;
-		udelay(1);
-	}
-
-	rk_clrsetreg(&cru->cru_mode_con, NPLL_MODE_MASK,
-		     NPLL_MODE_NORMAL << NPLL_MODE_SHIFT);
+	gpll_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+	npll_rate = rkclk_pll_get_rate(cru, CLK_NEW);
 
-	/* vop dclk source clk: npll,dclk_div: 1 */
+	/* vop dclk source clk: cpll,dclk_div: 1 */
 	switch (periph) {
 	case DCLK_VOP0:
-		rk_clrsetreg(&cru->cru_clksel_con[27], 0xff << 8 | 3 << 0,
-			     (lcdc_div - 1) << 8 | 2 << 0);
+		ret = (readl(&cru->cru_clksel_con[27]) & DCLK_VOP0_PLL_MASK) >>
+		      DCLK_VOP0_PLL_SHIFT;
+		if (ret == DCLK_VOP0_SELECT_CPLL) {
+			ret = pll_para_config(rate_hz, &cpll_config, &lcdc_div);
+			if (ret)
+				return ret;
+
+			rk_clrsetreg(&cru->cru_mode_con, CPLL_MODE_MASK,
+				     CPLL_MODE_SLOW << CPLL_MODE_SHIFT);
+			rkclk_set_pll(cru, CLK_CODEC, &cpll_config);
+
+			/* waiting for pll lock */
+			while (1) {
+				if (readl(&grf->soc_status[1]) &
+					  SOCSTS_CPLL_LOCK)
+					break;
+				udelay(1);
+			}
+
+			rk_clrsetreg(&cru->cru_mode_con, CPLL_MODE_MASK,
+				     CPLL_MODE_NORMAL << CPLL_MODE_SHIFT);
+			parent = DCLK_VOP0_SELECT_CPLL;
+		} else if (ret == DCLK_VOP0_SELECT_GPLL) {
+			parent = DCLK_VOP0_SELECT_GPLL;
+			lcdc_div = DIV_ROUND_UP(gpll_rate,
+						rate_hz);
+		} else {
+			parent = DCLK_VOP0_SELECT_NPLL;
+			lcdc_div = DIV_ROUND_UP(npll_rate,
+						rate_hz);
+		}
+		rk_clrsetreg(&cru->cru_clksel_con[27],
+			     DCLK_VOP0_DIV_MASK | DCLK_VOP0_PLL_MASK,
+			     ((lcdc_div - 1) << DCLK_VOP0_DIV_SHIFT) |
+			     (parent << DCLK_VOP0_PLL_SHIFT));
 		break;
 	case DCLK_VOP1:
-		rk_clrsetreg(&cru->cru_clksel_con[29], 0xff << 8 | 3 << 6,
-			     (lcdc_div - 1) << 8 | 2 << 6);
+		ret = (readl(&cru->cru_clksel_con[29]) & DCLK_VOP1_PLL_MASK) >>
+		      DCLK_VOP1_PLL_SHIFT;
+		if (ret == DCLK_VOP1_SELECT_CPLL) {
+			ret = pll_para_config(rate_hz, &cpll_config, &lcdc_div);
+			if (ret)
+				return ret;
+
+			rk_clrsetreg(&cru->cru_mode_con, CPLL_MODE_MASK,
+				     CPLL_MODE_SLOW << CPLL_MODE_SHIFT);
+			rkclk_set_pll(cru, CLK_CODEC, &cpll_config);
+
+			/* waiting for pll lock */
+			while (1) {
+				if (readl(&grf->soc_status[1]) &
+				    SOCSTS_CPLL_LOCK)
+					break;
+				udelay(1);
+			}
+
+			rk_clrsetreg(&cru->cru_mode_con, CPLL_MODE_MASK,
+				     CPLL_MODE_NORMAL << CPLL_MODE_SHIFT);
+
+			parent = DCLK_VOP1_SELECT_CPLL;
+		} else if (ret == DCLK_VOP1_SELECT_GPLL) {
+			parent = DCLK_VOP1_SELECT_GPLL;
+			lcdc_div = DIV_ROUND_UP(gpll_rate,
+						rate_hz);
+		} else {
+			parent = DCLK_VOP1_SELECT_NPLL;
+			lcdc_div = DIV_ROUND_UP(npll_rate,
+						rate_hz);
+		}
+		rk_clrsetreg(&cru->cru_clksel_con[29],
+			     DCLK_VOP1_DIV_MASK | DCLK_VOP1_PLL_MASK,
+			     ((lcdc_div - 1) << DCLK_VOP1_DIV_SHIFT) |
+			     (parent << DCLK_VOP1_PLL_SHIFT));
+		break;
+	case ACLK_VIO0:
+		lcdc_div = DIV_ROUND_UP(gpll_rate, rate_hz);
+		rk_clrsetreg(&cru->cru_clksel_con[31],
+			     ACLK_VIO0_PLL_MASK | ACLK_VIO0_DIV_MASK,
+			     ACLK_VIO_SELECT_GPLL << ACLK_VIO0_PLL_SHIFT |
+			     (lcdc_div - 1) << ACLK_VIO0_DIV_SHIFT);
+		break;
+	case ACLK_VIO1:
+		lcdc_div = DIV_ROUND_UP(gpll_rate, rate_hz);
+		rk_clrsetreg(&cru->cru_clksel_con[31],
+			     ACLK_VIO1_PLL_MASK | ACLK_VIO1_DIV_MASK,
+			     ACLK_VIO_SELECT_GPLL << ACLK_VIO1_PLL_SHIFT |
+			     (lcdc_div - 1) << ACLK_VIO1_DIV_SHIFT);
+
+		lcdc_div = DIV_ROUND_UP(rate_hz, HCLK_VIO_HZ);
+		rk_clrsetreg(&cru->cru_clksel_con[28],
+			     HCLK_VIO_DIV_MASK,
+			     (lcdc_div - 1) << HCLK_VIO_DIV_SHIFT);
 		break;
 	}
 
@@ -364,14 +611,14 @@ static void rkclk_init(struct rk3288_cru *cru, struct rk3288_grf *grf)
 	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
 	 */
 	aclk_div = GPLL_HZ / PD_BUS_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PD_BUS_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
+	assert((aclk_div + 1) * PD_BUS_ACLK_HZ <= GPLL_HZ && aclk_div <= 0x1f);
 	hclk_div = PD_BUS_ACLK_HZ / PD_BUS_HCLK_HZ - 1;
-	assert((hclk_div + 1) * PD_BUS_HCLK_HZ ==
-		PD_BUS_ACLK_HZ && (hclk_div < 0x4) && (hclk_div != 0x2));
+	assert((hclk_div + 1) * PD_BUS_HCLK_HZ <=
+		PD_BUS_ACLK_HZ && (hclk_div <= 0x3) && (hclk_div != 0x2));
 
 	pclk_div = PD_BUS_ACLK_HZ / PD_BUS_PCLK_HZ - 1;
-	assert((pclk_div + 1) * PD_BUS_PCLK_HZ ==
-		PD_BUS_ACLK_HZ && pclk_div < 0x7);
+	assert((pclk_div + 1) * PD_BUS_PCLK_HZ <=
+		PD_BUS_ACLK_HZ && pclk_div <= 0x7);
 
 	rk_clrsetreg(&cru->cru_clksel_con[1],
 		     PD_BUS_PCLK_DIV_MASK | PD_BUS_HCLK_DIV_MASK |
@@ -386,15 +633,15 @@ static void rkclk_init(struct rk3288_cru *cru, struct rk3288_grf *grf)
 	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
 	 */
 	aclk_div = GPLL_HZ / PERI_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PERI_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
+	assert((aclk_div + 1) * PERI_ACLK_HZ <= GPLL_HZ && aclk_div <= 0x1f);
 
 	hclk_div = ilog2(PERI_ACLK_HZ / PERI_HCLK_HZ);
-	assert((1 << hclk_div) * PERI_HCLK_HZ ==
-		PERI_ACLK_HZ && (hclk_div < 0x4));
+	assert((1 << hclk_div) * PERI_HCLK_HZ <=
+		PERI_ACLK_HZ && (hclk_div <= 0x2));
 
 	pclk_div = ilog2(PERI_ACLK_HZ / PERI_PCLK_HZ);
-	assert((1 << pclk_div) * PERI_PCLK_HZ ==
-		PERI_ACLK_HZ && (pclk_div < 0x4));
+	assert((1 << pclk_div) * PERI_PCLK_HZ <=
+		PERI_ACLK_HZ && (pclk_div <= 0x3));
 
 	rk_clrsetreg(&cru->cru_clksel_con[10],
 		     PERI_PCLK_DIV_MASK | PERI_HCLK_DIV_MASK |
@@ -404,6 +651,18 @@ static void rkclk_init(struct rk3288_cru *cru, struct rk3288_grf *grf)
 		     hclk_div << PERI_HCLK_DIV_SHIFT |
 		     aclk_div << PERI_ACLK_DIV_SHIFT);
 
+	rk_clrsetreg(&cru->cru_clksel_con[39],
+		     ACLK_HEVC_SEL_PLL_MASK | ACLK_HEVC_DIV_CON_MASK,
+		     ACLK_HEVC_SEL_CPLL << ACLK_HEVC_SEL_PLL_SHIFT |
+		     4 << ACLK_HEVC_DIV_CON_SHIFT);
+	rk_clrsetreg(&cru->cru_clksel_con[42],
+		     CLK_HEVC_CORE_SEL_PLL_MASK | CLK_HEVC_CORE_DIV_CON_MASK |
+		     CLK_HEVC_CORE_SEL_PLL_MASK | CLK_HEVC_CORE_DIV_CON_MASK,
+		     CLK_HEVC_CORE_SEL_CPLL << CLK_HEVC_CORE_SEL_PLL_SHIFT |
+		     CLK_HEVC_CABAC_SEL_CPLL << CLK_HEVC_CABAC_DIV_CON_SHIFT |
+		     4 << CLK_HEVC_CORE_DIV_CON_SHIFT |
+		     4 << CLK_HEVC_CABAC_DIV_CON_SHIFT);
+
 	/* PLL enter normal-mode */
 	rk_clrsetreg(&cru->cru_mode_con,
 		     GPLL_MODE_MASK | CPLL_MODE_MASK,
@@ -452,40 +711,6 @@ void rk3288_clk_configure_cpu(struct rk3288_cru *cru, struct rk3288_grf *grf)
 		     APLL_MODE_NORMAL << APLL_MODE_SHIFT);
 }
 
-/* Get pll rate by id */
-static uint32_t rkclk_pll_get_rate(struct rk3288_cru *cru,
-				   enum rk_clk_id clk_id)
-{
-	uint32_t nr, no, nf;
-	uint32_t con;
-	int pll_id = rk_pll_id(clk_id);
-	struct rk3288_pll *pll = &cru->pll[pll_id];
-	static u8 clk_shift[CLK_COUNT] = {
-		0xff, APLL_MODE_SHIFT, DPLL_MODE_SHIFT, CPLL_MODE_SHIFT,
-		GPLL_MODE_SHIFT, NPLL_MODE_SHIFT
-	};
-	uint shift;
-
-	con = readl(&cru->cru_mode_con);
-	shift = clk_shift[clk_id];
-	switch ((con >> shift) & CRU_MODE_MASK) {
-	case APLL_MODE_SLOW:
-		return OSC_HZ;
-	case APLL_MODE_NORMAL:
-		/* normal mode */
-		con = readl(&pll->con0);
-		no = ((con & CLKOD_MASK) >> CLKOD_SHIFT) + 1;
-		nr = ((con & CLKR_MASK) >> CLKR_SHIFT) + 1;
-		con = readl(&pll->con1);
-		nf = ((con & CLKF_MASK) >> CLKF_SHIFT) + 1;
-
-		return (24 * nf / (nr * no)) * 1000000;
-	case APLL_MODE_DEEP:
-	default:
-		return 32768;
-	}
-}
-
 static ulong rockchip_mmc_get_clk(struct rk3288_cru *cru, uint gclk_rate,
 				  int periph)
 {
@@ -496,6 +721,7 @@ static ulong rockchip_mmc_get_clk(struct rk3288_cru *cru, uint gclk_rate,
 	switch (periph) {
 	case HCLK_EMMC:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 		con = readl(&cru->cru_clksel_con[12]);
 		mux = (con & EMMC_PLL_MASK) >> EMMC_PLL_SHIFT;
 		div = (con & EMMC_DIV_MASK) >> EMMC_DIV_SHIFT;
@@ -517,7 +743,7 @@ static ulong rockchip_mmc_get_clk(struct rk3288_cru *cru, uint gclk_rate,
 	}
 
 	src_rate = mux == EMMC_PLL_SELECT_24MHZ ? OSC_HZ : gclk_rate;
-	return DIV_TO_RATE(src_rate, div);
+	return DIV_TO_RATE(src_rate, div) / 2;
 }
 
 static ulong rockchip_mmc_set_clk(struct rk3288_cru *cru, uint gclk_rate,
@@ -634,6 +860,221 @@ static ulong rockchip_spi_set_clk(struct rk3288_cru *cru, uint gclk_rate,
 	return rockchip_spi_get_clk(cru, gclk_rate, periph);
 }
 
+static ulong rockchip_aclk_peri_get_clk(struct rk3288_cru *cru)
+{
+	uint div, mux;
+	u32 con;
+	ulong rate, parent_rate;
+
+	con = readl(&cru->cru_clksel_con[10]);
+	mux = (con & PERI_SEL_PLL_MASK) >> PERI_SEL_PLL_SHIFT;
+	div = (con & PERI_ACLK_DIV_MASK) >> PERI_ACLK_DIV_SHIFT;
+	if (mux)
+		parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+	else
+		parent_rate = rkclk_pll_get_rate(cru, CLK_CODEC);
+	rate = DIV_TO_RATE(parent_rate, div);
+
+	return rate;
+}
+
+static ulong rockchip_aclk_cpu_get_clk(struct rk3288_cru *cru)
+{
+	uint div, mux;
+	u32 con;
+	ulong rate, parent_rate;
+
+	con = readl(&cru->cru_clksel_con[1]);
+	mux = (con & PD_BUS_SEL_PLL_MASK) >> PD_BUS_SEL_PLL_SHIFT;
+	div = (con & PD_BUS_ACLK_DIV0_MASK) >> PD_BUS_ACLK_DIV0_SHIFT;
+	if (mux)
+		parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+	else
+		parent_rate = rkclk_pll_get_rate(cru, CLK_CODEC);
+	parent_rate = DIV_TO_RATE(parent_rate, div);
+
+	div = (con & PD_BUS_ACLK_DIV1_MASK) >> PD_BUS_ACLK_DIV1_SHIFT;
+	rate = DIV_TO_RATE(parent_rate, div);
+
+	return rate;
+}
+
+static ulong rockchip_pclk_peri_get_clk(struct rk3288_cru *cru)
+{
+	uint div;
+	u32 con;
+	ulong rate, parent_rate;
+
+	parent_rate = rockchip_aclk_peri_get_clk(cru);
+	con = readl(&cru->cru_clksel_con[10]);
+	div = (con & PERI_PCLK_DIV_MASK) >> PERI_PCLK_DIV_SHIFT;
+	rate = parent_rate / (1 << div);
+
+	return rate;
+}
+
+static ulong rockchip_pclk_cpu_get_clk(struct rk3288_cru *cru)
+{
+	uint div;
+	u32 con;
+	ulong rate, parent_rate;
+
+	parent_rate = rockchip_aclk_cpu_get_clk(cru);
+	con = readl(&cru->cru_clksel_con[1]);
+	div = (con & PD_BUS_PCLK_DIV_MASK) >> PD_BUS_PCLK_DIV_SHIFT;
+	rate = DIV_TO_RATE(parent_rate, div);
+
+	return rate;
+}
+
+static ulong rockchip_i2c_get_clk(struct rk3288_cru *cru, int periph)
+{
+	switch (periph) {
+	case PCLK_I2C0:
+	case PCLK_I2C2:
+		return rockchip_pclk_cpu_get_clk(cru);
+	case PCLK_I2C1:
+	case PCLK_I2C3:
+	case PCLK_I2C4:
+	case PCLK_I2C5:
+		return rockchip_pclk_peri_get_clk(cru);
+	default:
+		return -EINVAL;
+	}
+}
+
+static ulong rockchip_saradc_get_clk(struct rk3288_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->cru_clksel_con[24]);
+	div = bitfield_extract(val, CLK_SARADC_DIV_CON_SHIFT,
+			       CLK_SARADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rockchip_saradc_set_clk(struct rk3288_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->cru_clksel_con[24],
+		     CLK_SARADC_DIV_CON_MASK,
+		     src_clk_div << CLK_SARADC_DIV_CON_SHIFT);
+
+	return rockchip_saradc_get_clk(cru);
+}
+
+static ulong rockchip_tsadc_get_clk(struct rk3288_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->cru_clksel_con[2]);
+	div = bitfield_extract(val, CLK_TSADC_DIV_CON_SHIFT,
+			       CLK_TSADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(32768, div);
+}
+
+static ulong rockchip_tsadc_set_clk(struct rk3288_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->cru_clksel_con[2],
+		     CLK_TSADC_DIV_CON_MASK,
+		     src_clk_div << CLK_TSADC_DIV_CON_SHIFT);
+
+	return rockchip_tsadc_get_clk(cru);
+}
+
+#ifndef CONFIG_SPL_BUILD
+
+static ulong rockchip_crypto_get_clk(struct rk3288_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->cru_clksel_con[26]);
+	div = (val & CLK_CRYPTO_DIV_CON_MASK) >> CLK_CRYPTO_DIV_CON_SHIFT;
+
+	return DIV_TO_RATE(rockchip_aclk_cpu_get_clk(cru), div);
+}
+
+static ulong rockchip_crypto_set_clk(struct rk3288_cru *cru, uint hz)
+{
+	int src_clk_div;
+	uint p_rate;
+
+	p_rate = rockchip_aclk_cpu_get_clk(cru);
+	src_clk_div = DIV_ROUND_UP(p_rate, hz) - 1;
+	assert(src_clk_div < 3);
+
+	rk_clrsetreg(&cru->cru_clksel_con[26],
+		     CLK_CRYPTO_DIV_CON_MASK,
+		     src_clk_div << CLK_CRYPTO_DIV_CON_SHIFT);
+
+	return rockchip_crypto_get_clk(cru);
+}
+
+static ulong rk3288_alive_get_clk(struct rk3288_cru *cru, uint gclk_rate)
+{
+	u32 div, con, parent;
+
+	con = readl(&cru->cru_clksel_con[33]);
+	div = (con & PCLK_ALIVE_DIV_CON_MASK) >>
+	      PCLK_ALIVE_DIV_CON_SHIFT;
+	parent = gclk_rate;
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rockchip_test_get_clk(struct rk3288_cru *cru, int id)
+{
+	u32 src, val;
+
+	val = readl(&cru->cru_misc_con);
+	src = (val & CLK_TEST_SRC_SEL_MASK) >> CLK_TEST_SRC_SEL_SHIFT;
+	switch (src) {
+	case CLK_TEST_SRC_SEL_24M:
+		return 24000000;
+	case CLK_TEST_SRC_SEL_27M:
+		return 27000000;
+	case CLK_TEST_SRC_SEL_32k:
+		return 32768;
+	default:
+		return -ENOENT;
+	}
+}
+
+static ulong rockchip_test_set_clk(struct rk3288_cru *cru, int id, uint hz)
+{
+	int src = 0;
+
+	switch (hz) {
+	case 24000000:
+		src = 8;
+		break;
+	case 27000000:
+		src = 9;
+		break;
+	case 32768:
+		src = 10;
+		break;
+	default:
+		return -EINVAL;
+	}
+	rk_clrsetreg(&cru->cru_misc_con,
+		     CLK_TEST_SRC_SEL_MASK,
+		     src << CLK_TEST_SRC_SEL_SHIFT);
+
+	return rockchip_test_get_clk(cru, id);
+}
+#endif
+
 static ulong rk3288_clk_get_rate(struct clk *clk)
 {
 	struct rk3288_clk_priv *priv = dev_get_priv(clk->dev);
@@ -648,7 +1089,9 @@ static ulong rk3288_clk_get_rate(struct clk *clk)
 	case HCLK_SDMMC:
 	case HCLK_SDIO0:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 	case SCLK_SDMMC:
+	case SCLK_SDMMC_SAMPLE:
 	case SCLK_SDIO0:
 		new_rate = rockchip_mmc_get_clk(priv->cru, gclk_rate, clk->id);
 		break;
@@ -663,9 +1106,40 @@ static ulong rk3288_clk_get_rate(struct clk *clk)
 	case PCLK_I2C3:
 	case PCLK_I2C4:
 	case PCLK_I2C5:
-		return gclk_rate;
+		new_rate = rockchip_i2c_get_clk(priv->cru, clk->id);
+		break;
 	case PCLK_PWM:
 		return PD_BUS_PCLK_HZ;
+	case SCLK_SARADC:
+		new_rate = rockchip_saradc_get_clk(priv->cru);
+		break;
+	case SCLK_TSADC:
+		new_rate = rockchip_tsadc_get_clk(priv->cru);
+		break;
+	case ACLK_CPU:
+		new_rate = rockchip_aclk_cpu_get_clk(priv->cru);
+		break;
+	case ACLK_PERI:
+		new_rate = rockchip_aclk_peri_get_clk(priv->cru);
+		break;
+	case PCLK_CPU:
+		new_rate = rockchip_pclk_cpu_get_clk(priv->cru);
+		break;
+	case PCLK_PERI:
+		new_rate = rockchip_pclk_peri_get_clk(priv->cru);
+		break;
+#ifndef CONFIG_SPL_BUILD
+	case SCLK_CRYPTO:
+		new_rate = rockchip_crypto_get_clk(priv->cru);
+		break;
+	case PCLK_WDT:
+		new_rate = rk3288_alive_get_clk(priv->cru, gclk_rate);
+		break;
+	case SCLK_TESTOUT_SRC:
+	case SCLK_TESTOUT:
+		new_rate = rockchip_test_get_clk(priv->cru, clk->id);
+		break;
+#endif
 	default:
 		return -ENOENT;
 	}
@@ -706,10 +1180,12 @@ static ulong rk3288_clk_set_rate(struct clk *clk, ulong rate)
 		break;
 #ifndef CONFIG_SPL_BUILD
 	case SCLK_MAC:
-		new_rate = rockchip_mac_set_clk(priv->cru, clk->id, rate);
+		new_rate = rockchip_mac_set_clk(priv->cru, rate);
 		break;
 	case DCLK_VOP0:
 	case DCLK_VOP1:
+	case ACLK_VIO0:
+	case ACLK_VIO1:
 		new_rate = rockchip_vop_set_clk(cru, priv->grf, clk->id, rate);
 		break;
 	case SCLK_EDP_24M:
@@ -722,29 +1198,6 @@ static ulong rk3288_clk_set_rate(struct clk *clk, ulong rate)
 		rk_clrreg(&cru->cru_clksel_con[6], 1 << 15);
 		new_rate = rate;
 		break;
-	case ACLK_VOP0:
-	case ACLK_VOP1: {
-		u32 div;
-
-		/* vop aclk source clk: cpll */
-		div = CPLL_HZ / rate;
-		assert((div - 1 < 64) && (div * rate == CPLL_HZ));
-
-		switch (clk->id) {
-		case ACLK_VOP0:
-			rk_clrsetreg(&cru->cru_clksel_con[31],
-				     3 << 6 | 0x1f << 0,
-				     0 << 6 | (div - 1) << 0);
-			break;
-		case ACLK_VOP1:
-			rk_clrsetreg(&cru->cru_clksel_con[31],
-				     3 << 14 | 0x1f << 8,
-				     0 << 14 | (div - 1) << 8);
-			break;
-		}
-		new_rate = rate;
-		break;
-	}
 	case PCLK_HDMI_CTRL:
 		/* enable pclk hdmi ctrl */
 		rk_clrreg(&cru->cru_clkgate_con[16], 1 << 9);
@@ -755,7 +1208,31 @@ static ulong rk3288_clk_set_rate(struct clk *clk, ulong rate)
 		rk_clrreg(&cru->cru_clkgate_con[7], 1 << 9);
 		new_rate = rate;
 		break;
+	case SCLK_CRYPTO:
+		new_rate = rockchip_crypto_set_clk(priv->cru, rate);
+		break;
+	case SCLK_TESTOUT_SRC:
+	case SCLK_TESTOUT:
+		new_rate = rockchip_test_set_clk(priv->cru, clk->id, rate);
+		break;
 #endif
+	case SCLK_SARADC:
+		new_rate = rockchip_saradc_set_clk(priv->cru, rate);
+		break;
+	case SCLK_TSADC:
+		new_rate = rockchip_tsadc_set_clk(priv->cru, rate);
+		break;
+	case PLL_GPLL:
+	case PLL_CPLL:
+	case PLL_NPLL:
+	case ACLK_CPU:
+	case HCLK_CPU:
+	case PCLK_CPU:
+	case ACLK_PERI:
+	case HCLK_PERI:
+	case PCLK_PERI:
+	case SCLK_UART0:
+		return 0;
 	default:
 		return -ENOENT;
 	}
@@ -763,9 +1240,225 @@ static ulong rk3288_clk_set_rate(struct clk *clk, ulong rate)
 	return new_rate;
 }
 
+#define ROCKCHIP_MMC_DELAY_SEL		BIT(10)
+#define ROCKCHIP_MMC_DEGREE_MASK	0x3
+#define ROCKCHIP_MMC_DELAYNUM_OFFSET	2
+#define ROCKCHIP_MMC_DELAYNUM_MASK	(0xff << ROCKCHIP_MMC_DELAYNUM_OFFSET)
+
+#define PSECS_PER_SEC 1000000000000LL
+/*
+ * Each fine delay is between 44ps-77ps. Assume each fine delay is 60ps to
+ * simplify calculations. So 45degs could be anywhere between 33deg and 57.8deg.
+ */
+#define ROCKCHIP_MMC_DELAY_ELEMENT_PSEC 60
+
+int rockchip_mmc_get_phase(struct clk *clk)
+{
+	struct rk3288_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3288_cru *cru = priv->cru;
+	u32 raw_value, delay_num;
+	u16 degrees = 0;
+	ulong rate;
+
+	rate = rk3288_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		raw_value = readl(&cru->cru_emmc_con[1]);
+	else
+		raw_value = readl(&cru->cru_sdmmc_con[1]);
+
+	degrees = (raw_value & ROCKCHIP_MMC_DEGREE_MASK) * 90;
+
+	if (raw_value & ROCKCHIP_MMC_DELAY_SEL) {
+		/* degrees/delaynum * 10000 */
+		unsigned long factor = (ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10) *
+					36 * (rate / 1000000);
+
+		delay_num = (raw_value & ROCKCHIP_MMC_DELAYNUM_MASK);
+		delay_num >>= ROCKCHIP_MMC_DELAYNUM_OFFSET;
+		degrees += DIV_ROUND_CLOSEST(delay_num * factor, 10000);
+	}
+
+	return degrees % 360;
+}
+
+int rockchip_mmc_set_phase(struct clk *clk, u32 degrees)
+{
+	struct rk3288_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3288_cru *cru = priv->cru;
+	u8 nineties, remainder, delay_num;
+	u32 raw_value, delay;
+	ulong rate;
+
+	rate = rk3288_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	nineties = degrees / 90;
+	remainder = (degrees % 90);
+
+	/*
+	 * Convert to delay; do a little extra work to make sure we
+	 * don't overflow 32-bit / 64-bit numbers.
+	 */
+	delay = 10000000; /* PSECS_PER_SEC / 10000 / 10 */
+	delay *= remainder;
+	delay = DIV_ROUND_CLOSEST(delay, (rate / 1000) * 36 *
+				(ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10));
+
+	delay_num = (u8)min_t(u32, delay, 255);
+
+	raw_value = delay_num ? ROCKCHIP_MMC_DELAY_SEL : 0;
+	raw_value |= delay_num << ROCKCHIP_MMC_DELAYNUM_OFFSET;
+	raw_value |= nineties;
+
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->cru_emmc_con[1]);
+	else
+		writel(raw_value | 0xffff0000, &cru->cru_sdmmc_con[1]);
+
+	debug("mmc set_phase(%d) delay_nums=%u reg=%#x actual_degrees=%d\n",
+	      degrees, delay_num, raw_value, rockchip_mmc_get_phase(clk));
+
+	return 0;
+}
+
+static int rk3288_clk_get_phase(struct clk *clk)
+{
+	int ret;
+
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+		ret = rockchip_mmc_get_phase(clk);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+static int rk3288_clk_set_phase(struct clk *clk, int degrees)
+{
+	int ret;
+
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+		ret = rockchip_mmc_set_phase(clk, degrees);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+static int __maybe_unused rk3288_gmac_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3288_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3288_cru *cru = priv->cru;
+	const char *clock_output_name;
+	int ret;
+
+	/*
+	 * If the requested parent is in the same clock-controller and
+	 * the id is SCLK_MAC_PLL ("mac_pll_src"), switch to the internal
+	 * clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC_PLL)) {
+		debug("%s: switching GAMC to SCLK_MAC_PLL\n", __func__);
+		rk_clrsetreg(&cru->cru_clksel_con[21], RMII_EXTCLK_MASK, 0);
+		return 0;
+	}
+
+	/*
+	 * Otherwise, we need to check the clock-output-names of the
+	 * requested parent to see if the requested id is "ext_gmac".
+	 */
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	/* If this is "ext_gmac", switch to the external clock input */
+	if (!strcmp(clock_output_name, "ext_gmac")) {
+		debug("%s: switching GMAC to external clock\n", __func__);
+		rk_clrsetreg(&cru->cru_clksel_con[21], RMII_EXTCLK_MASK,
+			     RMII_EXTCLK_SELECT_EXT_CLK << RMII_EXTCLK_SHIFT);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int __maybe_unused rk3288_vop_set_parent(struct clk *clk,
+						struct clk *parent)
+{
+	struct rk3288_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3288_cru *cru = priv->cru;
+	int parent_sel;
+
+	switch (parent->id) {
+	case PLL_CPLL:
+		parent_sel = 0;
+		break;
+	case PLL_GPLL:
+		parent_sel = 1;
+		break;
+	case PLL_NPLL:
+		parent_sel = 2;
+		break;
+	default:
+		parent_sel = 0;
+		break;
+	}
+
+	switch (clk->id) {
+	case DCLK_VOP0:
+		rk_clrsetreg(&cru->cru_clksel_con[27],
+			     DCLK_VOP0_PLL_MASK, parent_sel << 0);
+		break;
+	case DCLK_VOP1:
+		rk_clrsetreg(&cru->cru_clksel_con[29],
+			     DCLK_VOP1_PLL_MASK, parent_sel << 6);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __maybe_unused rk3288_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	switch (clk->id) {
+	case SCLK_MAC:
+		return rk3288_gmac_set_parent(clk, parent);
+	case DCLK_VOP0:
+	case DCLK_VOP1:
+		return rk3288_vop_set_parent(clk, parent);
+	case SCLK_USBPHY480M_SRC:
+		return 0;
+	}
+
+	debug("%s: unsupported clk %ld\n", __func__, clk->id);
+	return -ENOENT;
+}
+
 static struct clk_ops rk3288_clk_ops = {
 	.get_rate	= rk3288_clk_get_rate,
 	.set_rate	= rk3288_clk_set_rate,
+	.get_phase	= rk3288_clk_get_phase,
+	.set_phase	= rk3288_clk_set_phase,
+#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
+	.set_parent	= rk3288_clk_set_parent,
+#endif
 };
 
 static int rk3288_clk_ofdata_to_platdata(struct udevice *dev)
@@ -773,7 +1466,7 @@ static int rk3288_clk_ofdata_to_platdata(struct udevice *dev)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3288_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk3288_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
 #endif
 
 	return 0;
@@ -783,6 +1476,7 @@ static int rk3288_clk_probe(struct udevice *dev)
 {
 	struct rk3288_clk_priv *priv = dev_get_priv(dev);
 	bool init_clocks = false;
+	int ret;
 
 	priv->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
 	if (IS_ERR(priv->grf))
@@ -802,15 +1496,35 @@ static int rk3288_clk_probe(struct udevice *dev)
 		 * Init clocks in U-Boot proper if the NPLL is runnning. This
 		 * indicates that a previous boot loader set up the clocks, so
 		 * we need to redo it. U-Boot's SPL does not set this clock.
+		 * Or if the CPLL is not init, we need to redo the clk_init.
 		 */
 		reg = readl(&priv->cru->cru_mode_con);
-		if (((reg & NPLL_MODE_MASK) >> NPLL_MODE_SHIFT) ==
-				NPLL_MODE_NORMAL)
+		if ((((reg & NPLL_MODE_MASK) >> NPLL_MODE_SHIFT) ==
+				NPLL_MODE_NORMAL) ||
+		    !(reg & CPLL_MODE_MASK))
 			init_clocks = true;
 	}
 
-	if (init_clocks)
+	priv->sync_kernel = false;
+	if (!priv->armclk_enter_hz)
+		priv->armclk_enter_hz = rkclk_pll_get_rate(priv->cru,
+							   CLK_ARM);
+
+	if (init_clocks) {
 		rkclk_init(priv->cru, priv->grf);
+		if (!priv->armclk_init_hz)
+			priv->armclk_init_hz = rkclk_pll_get_rate(priv->cru,
+								  CLK_ARM);
+	} else {
+		if (!priv->armclk_init_hz)
+			priv->armclk_init_hz = priv->armclk_enter_hz;
+	}
+
+	ret = clk_set_defaults(dev);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+	else
+		priv->sync_kernel = true;
 
 	return 0;
 }
@@ -818,11 +1532,35 @@ static int rk3288_clk_probe(struct udevice *dev)
 static int rk3288_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk3288_sysreset", "reset", &dev);
-	if (ret)
-		debug("Warning: No RK3288 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3288_cru,
+						    cru_glb_srst_fst_value);
+		priv->glb_srst_snd_value = offsetof(struct rk3288_cru,
+						    cru_glb_srst_snd_value);
+		sys_child->priv = priv;
+	}
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3288_cru,
+						    cru_softrst_con[0]);
+		sf_priv->sf_reset_num = 12;
+		sf_child->priv = sf_priv;
+	}
 
 	return 0;
 }
@@ -843,3 +1581,69 @@ U_BOOT_DRIVER(rockchip_rk3288_cru) = {
 	.ofdata_to_platdata	= rk3288_clk_ofdata_to_platdata,
 	.probe		= rk3288_clk_probe,
 };
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev;
+	struct rk3288_clk_priv *priv;
+	const struct rk3288_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk3288_cru),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arm: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armclk_enter_hz / 1000,
+	       priv->armclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
diff --git a/drivers/clk/rockchip/clk_rk3328.c b/drivers/clk/rockchip/clk_rk3328.c
index c3a6650de0..2391f9db39 100644
--- a/drivers/clk/rockchip/clk_rk3328.c
+++ b/drivers/clk/rockchip/clk_rk3328.c
@@ -5,321 +5,168 @@
  */
 
 #include <common.h>
+#include <bitfield.h>
 #include <clk-uclass.h>
 #include <dm.h>
 #include <errno.h>
 #include <syscon.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3328.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3328.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/grf_rk3328.h>
 #include <asm/io.h>
 #include <dm/lists.h>
 #include <dt-bindings/clock/rk3328-cru.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
-struct pll_div {
-	u32 refdiv;
-	u32 fbdiv;
-	u32 postdiv1;
-	u32 postdiv2;
-	u32 frac;
-};
-
 #define RATE_TO_DIV(input_rate, output_rate) \
 	((input_rate) / (output_rate) - 1);
 #define DIV_TO_RATE(input_rate, div)    ((input_rate) / ((div) + 1))
 
-#define PLL_DIVISORS(hz, _refdiv, _postdiv1, _postdiv2) {\
-	.refdiv = _refdiv,\
-	.fbdiv = (u32)((u64)hz * _refdiv * _postdiv1 * _postdiv2 / OSC_HZ),\
-	.postdiv1 = _postdiv1, .postdiv2 = _postdiv2};
+#ifndef CONFIG_SPL_BUILD
+#define RK3328_CLK_DUMP(_id, _name, _iscru)	\
+{						\
+	.id = _id,				\
+	.name = _name,				\
+	.is_cru = _iscru,			\
+}
+#endif
+
+static struct rockchip_pll_rate_table rk3328_pll_rates[] = {
+	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
+	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
+#ifndef CONFIG_SPL_BUILD
+	RK3036_PLL_RATE(1188000000, 1, 99, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1008000000, 1, 84, 2, 1, 1, 0),
+#endif
+	RK3036_PLL_RATE(816000000, 1, 68, 2, 1, 1, 0),
+	RK3036_PLL_RATE(800000000, 1, 200, 6, 1, 1, 0),
+	RK3036_PLL_RATE(600000000, 1, 75, 3, 1, 1, 0),
+#ifndef CONFIG_SPL_BUILD
+	RK3036_PLL_RATE(594000000, 1, 99, 4, 1, 1, 0),
+	RK3036_PLL_RATE(500000000, 1, 125, 6, 1, 1, 0),
+#endif
+	{ /* sentinel */ },
+};
 
-static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 1, 4, 1);
-static const struct pll_div cpll_init_cfg = PLL_DIVISORS(CPLL_HZ, 2, 2, 1);
+static struct rockchip_pll_rate_table rk3328_pll_frac_rates[] = {
+	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
+#ifndef CONFIG_SPL_BUILD
+	RK3036_PLL_RATE(1016064000, 3, 127, 1, 1, 0, 134217),
+	/* vco = 1016064000 */
+	RK3036_PLL_RATE(983040000, 24, 983, 1, 1, 0, 671088),
+	/* vco = 983040000 */
+#endif
+	RK3036_PLL_RATE(491520000, 24, 983, 2, 1, 0, 671088),
+	/* vco = 983040000 */
+#ifndef CONFIG_SPL_BUILD
+	RK3036_PLL_RATE(61440000, 6, 215, 7, 2, 0, 671088),
+	/* vco = 860156000 */
+	RK3036_PLL_RATE(56448000, 12, 451, 4, 4, 0, 9797894),
+	/* vco = 903168000 */
+	RK3036_PLL_RATE(40960000, 12, 409, 4, 5, 0, 10066329),
+	/* vco = 819200000 */
+#endif
+	{ /* sentinel */ },
+};
 
-static const struct pll_div apll_816_cfg = PLL_DIVISORS(816 * MHz, 1, 2, 1);
-static const struct pll_div apll_600_cfg = PLL_DIVISORS(600 * MHz, 1, 3, 1);
+#define RK3328_CPUCLK_RATE(_rate, _aclk_div, _pclk_div)		\
+{								\
+	.rate	= _rate##U,					\
+	.aclk_div = _aclk_div,					\
+	.pclk_div = _pclk_div,					\
+}
 
-static const struct pll_div *apll_cfgs[] = {
-	[APLL_816_MHZ] = &apll_816_cfg,
-	[APLL_600_MHZ] = &apll_600_cfg,
+static struct rockchip_cpu_rate_table rk3328_cpu_rates[] = {
+	RK3328_CPUCLK_RATE(1200000000, 1, 5),
+	RK3328_CPUCLK_RATE(1008000000, 1, 5),
+	RK3328_CPUCLK_RATE(816000000, 1, 3),
+	RK3328_CPUCLK_RATE(600000000, 1, 3),
 };
 
-enum {
-	/* PLL_CON0 */
-	PLL_POSTDIV1_SHIFT		= 12,
-	PLL_POSTDIV1_MASK		= 0x7 << PLL_POSTDIV1_SHIFT,
-	PLL_FBDIV_SHIFT			= 0,
-	PLL_FBDIV_MASK			= 0xfff,
-
-	/* PLL_CON1 */
-	PLL_DSMPD_SHIFT			= 12,
-	PLL_DSMPD_MASK			= 1 << PLL_DSMPD_SHIFT,
-	PLL_INTEGER_MODE		= 1,
-	PLL_LOCK_STATUS_SHIFT		= 10,
-	PLL_LOCK_STATUS_MASK		= 1 << PLL_LOCK_STATUS_SHIFT,
-	PLL_POSTDIV2_SHIFT		= 6,
-	PLL_POSTDIV2_MASK		= 0x7 << PLL_POSTDIV2_SHIFT,
-	PLL_REFDIV_SHIFT		= 0,
-	PLL_REFDIV_MASK			= 0x3f,
-
-	/* PLL_CON2 */
-	PLL_FRACDIV_SHIFT		= 0,
-	PLL_FRACDIV_MASK		= 0xffffff,
-
-	/* MODE_CON */
-	APLL_MODE_SHIFT			= 0,
-	NPLL_MODE_SHIFT			= 1,
-	DPLL_MODE_SHIFT			= 4,
-	CPLL_MODE_SHIFT			= 8,
-	GPLL_MODE_SHIFT			= 12,
-	PLL_MODE_SLOW			= 0,
-	PLL_MODE_NORM,
-
-	/* CLKSEL_CON0 */
-	CLK_CORE_PLL_SEL_APLL		= 0,
-	CLK_CORE_PLL_SEL_GPLL,
-	CLK_CORE_PLL_SEL_DPLL,
-	CLK_CORE_PLL_SEL_NPLL,
-	CLK_CORE_PLL_SEL_SHIFT		= 6,
-	CLK_CORE_PLL_SEL_MASK		= 3 << CLK_CORE_PLL_SEL_SHIFT,
-	CLK_CORE_DIV_SHIFT		= 0,
-	CLK_CORE_DIV_MASK		= 0x1f,
-
-	/* CLKSEL_CON1 */
-	ACLKM_CORE_DIV_SHIFT		= 4,
-	ACLKM_CORE_DIV_MASK		= 0x7 << ACLKM_CORE_DIV_SHIFT,
-	PCLK_DBG_DIV_SHIFT		= 0,
-	PCLK_DBG_DIV_MASK		= 0xF << PCLK_DBG_DIV_SHIFT,
-
-	/* CLKSEL_CON28 */
-	ACLK_PERIHP_PLL_SEL_CPLL	= 0,
-	ACLK_PERIHP_PLL_SEL_GPLL,
-	ACLK_PERIHP_PLL_SEL_HDMIPHY,
-	ACLK_PERIHP_PLL_SEL_SHIFT	= 6,
-	ACLK_PERIHP_PLL_SEL_MASK	= 3 << ACLK_PERIHP_PLL_SEL_SHIFT,
-	ACLK_PERIHP_DIV_CON_SHIFT	= 0,
-	ACLK_PERIHP_DIV_CON_MASK	= 0x1f,
-
-	/* CLKSEL_CON29 */
-	PCLK_PERIHP_DIV_CON_SHIFT	= 4,
-	PCLK_PERIHP_DIV_CON_MASK	= 0x7 << PCLK_PERIHP_DIV_CON_SHIFT,
-	HCLK_PERIHP_DIV_CON_SHIFT	= 0,
-	HCLK_PERIHP_DIV_CON_MASK	= 3 << HCLK_PERIHP_DIV_CON_SHIFT,
-
-	/* CLKSEL_CON22 */
-	CLK_TSADC_DIV_CON_SHIFT		= 0,
-	CLK_TSADC_DIV_CON_MASK		= 0x3ff,
-
-	/* CLKSEL_CON23 */
-	CLK_SARADC_DIV_CON_SHIFT	= 0,
-	CLK_SARADC_DIV_CON_MASK		= 0x3ff << CLK_SARADC_DIV_CON_SHIFT,
-
-	/* CLKSEL_CON24 */
-	CLK_PWM_PLL_SEL_CPLL		= 0,
-	CLK_PWM_PLL_SEL_GPLL,
-	CLK_PWM_PLL_SEL_SHIFT		= 15,
-	CLK_PWM_PLL_SEL_MASK		= 1 << CLK_PWM_PLL_SEL_SHIFT,
-	CLK_PWM_DIV_CON_SHIFT		= 8,
-	CLK_PWM_DIV_CON_MASK		= 0x7f << CLK_PWM_DIV_CON_SHIFT,
-
-	CLK_SPI_PLL_SEL_CPLL		= 0,
-	CLK_SPI_PLL_SEL_GPLL,
-	CLK_SPI_PLL_SEL_SHIFT		= 7,
-	CLK_SPI_PLL_SEL_MASK		= 1 << CLK_SPI_PLL_SEL_SHIFT,
-	CLK_SPI_DIV_CON_SHIFT		= 0,
-	CLK_SPI_DIV_CON_MASK		= 0x7f << CLK_SPI_DIV_CON_SHIFT,
-
-	/* CLKSEL_CON30 */
-	CLK_SDMMC_PLL_SEL_CPLL		= 0,
-	CLK_SDMMC_PLL_SEL_GPLL,
-	CLK_SDMMC_PLL_SEL_24M,
-	CLK_SDMMC_PLL_SEL_USBPHY,
-	CLK_SDMMC_PLL_SHIFT		= 8,
-	CLK_SDMMC_PLL_MASK		= 0x3 << CLK_SDMMC_PLL_SHIFT,
-	CLK_SDMMC_DIV_CON_SHIFT          = 0,
-	CLK_SDMMC_DIV_CON_MASK           = 0xff << CLK_SDMMC_DIV_CON_SHIFT,
-
-	/* CLKSEL_CON32 */
-	CLK_EMMC_PLL_SEL_CPLL		= 0,
-	CLK_EMMC_PLL_SEL_GPLL,
-	CLK_EMMC_PLL_SEL_24M,
-	CLK_EMMC_PLL_SEL_USBPHY,
-	CLK_EMMC_PLL_SHIFT		= 8,
-	CLK_EMMC_PLL_MASK		= 0x3 << CLK_EMMC_PLL_SHIFT,
-	CLK_EMMC_DIV_CON_SHIFT          = 0,
-	CLK_EMMC_DIV_CON_MASK           = 0xff << CLK_EMMC_DIV_CON_SHIFT,
-
-	/* CLKSEL_CON34 */
-	CLK_I2C_PLL_SEL_CPLL		= 0,
-	CLK_I2C_PLL_SEL_GPLL,
-	CLK_I2C_DIV_CON_MASK		= 0x7f,
-	CLK_I2C_PLL_SEL_MASK		= 1,
-	CLK_I2C1_PLL_SEL_SHIFT		= 15,
-	CLK_I2C1_DIV_CON_SHIFT		= 8,
-	CLK_I2C0_PLL_SEL_SHIFT		= 7,
-	CLK_I2C0_DIV_CON_SHIFT		= 0,
-
-	/* CLKSEL_CON35 */
-	CLK_I2C3_PLL_SEL_SHIFT		= 15,
-	CLK_I2C3_DIV_CON_SHIFT		= 8,
-	CLK_I2C2_PLL_SEL_SHIFT		= 7,
-	CLK_I2C2_DIV_CON_SHIFT		= 0,
+#ifndef CONFIG_SPL_BUILD
+static const struct rk3328_clk_info clks_dump[] = {
+	RK3328_CLK_DUMP(PLL_APLL, "apll", true),
+	RK3328_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK3328_CLK_DUMP(PLL_CPLL, "cpll", true),
+	RK3328_CLK_DUMP(PLL_GPLL, "gpll", true),
+	RK3328_CLK_DUMP(PLL_NPLL, "npll", true),
+	RK3328_CLK_DUMP(ARMCLK, "armclk", true),
+	RK3328_CLK_DUMP(ACLK_BUS_PRE, "aclk_bus", true),
+	RK3328_CLK_DUMP(HCLK_BUS_PRE, "hclk_bus", true),
+	RK3328_CLK_DUMP(PCLK_BUS_PRE, "pclk_bus", true),
+	RK3328_CLK_DUMP(ACLK_PERI_PRE, "aclk_peri", true),
+	RK3328_CLK_DUMP(HCLK_PERI, "hclk_peri", true),
+	RK3328_CLK_DUMP(PCLK_PERI, "pclk_peri", true),
+};
+#endif
+
+static struct rockchip_pll_clock rk3328_pll_clks[] = {
+	[APLL] = PLL(pll_rk3328, PLL_APLL, RK3328_PLL_CON(0),
+		     RK3328_MODE_CON, 0, 10, 0, rk3328_pll_frac_rates),
+	[DPLL] = PLL(pll_rk3328, PLL_DPLL, RK3328_PLL_CON(8),
+		     RK3328_MODE_CON, 4, 10, 0, NULL),
+	[CPLL] = PLL(pll_rk3328, PLL_CPLL, RK3328_PLL_CON(16),
+		    RK3328_MODE_CON, 8, 10, 0, rk3328_pll_rates),
+	[GPLL] = PLL(pll_rk3328, PLL_GPLL, RK3328_PLL_CON(24),
+		     RK3328_MODE_CON, 12, 10, 0, rk3328_pll_frac_rates),
+	[NPLL] = PLL(pll_rk3328, PLL_NPLL, RK3328_PLL_CON(40),
+		     RK3328_MODE_CON, 1, 10, 0, rk3328_pll_rates),
 };
 
-#define VCO_MAX_KHZ	(3200 * (MHz / KHz))
-#define VCO_MIN_KHZ	(800 * (MHz / KHz))
-#define OUTPUT_MAX_KHZ	(3200 * (MHz / KHz))
-#define OUTPUT_MIN_KHZ	(16 * (MHz / KHz))
-
-/*
- *  the div restructions of pll in integer mode, these are defined in
- *  * CRU_*PLL_CON0 or PMUCRU_*PLL_CON0
- */
-#define PLL_DIV_MIN	16
-#define PLL_DIV_MAX	3200
-
-/*
- * How to calculate the PLL(from TRM V0.3 Part 1 Page 63):
- * Formulas also embedded within the Fractional PLL Verilog model:
- * If DSMPD = 1 (DSM is disabled, "integer mode")
- * FOUTVCO = FREF / REFDIV * FBDIV
- * FOUTPOSTDIV = FOUTVCO / POSTDIV1 / POSTDIV2
- * Where:
- * FOUTVCO = Fractional PLL non-divided output frequency
- * FOUTPOSTDIV = Fractional PLL divided output frequency
- *               (output of second post divider)
- * FREF = Fractional PLL input reference frequency, (the OSC_HZ 24MHz input)
- * REFDIV = Fractional PLL input reference clock divider
- * FBDIV = Integer value programmed into feedback divide
- *
- */
-static void rkclk_set_pll(struct rk3328_cru *cru, enum rk_clk_id clk_id,
-			const struct pll_div *div)
+static ulong rk3328_armclk_set_clk(struct rk3328_clk_priv *priv, ulong hz)
 {
-	u32 *pll_con;
-	u32 mode_shift, mode_mask;
+	struct rk3328_cru *cru = priv->cru;
+	const struct rockchip_cpu_rate_table *rate;
+	ulong old_rate;
 
-	pll_con = NULL;
-	mode_shift = 0;
-	switch (clk_id) {
-	case CLK_ARM:
-		pll_con = cru->apll_con;
-		mode_shift = APLL_MODE_SHIFT;
-		break;
-	case CLK_DDR:
-		pll_con = cru->dpll_con;
-		mode_shift = DPLL_MODE_SHIFT;
-		break;
-	case CLK_CODEC:
-		pll_con = cru->cpll_con;
-		mode_shift = CPLL_MODE_SHIFT;
-		break;
-	case CLK_GENERAL:
-		pll_con = cru->gpll_con;
-		mode_shift = GPLL_MODE_SHIFT;
-		break;
-	case CLK_NEW:
-		pll_con = cru->npll_con;
-		mode_shift = NPLL_MODE_SHIFT;
-		break;
-	default:
-		break;
+	rate = rockchip_get_cpu_settings(rk3328_cpu_rates, hz);
+	if (!rate) {
+		printf("%s unsupported rate\n", __func__);
+		return -EINVAL;
 	}
-	mode_mask = 1 << mode_shift;
-
-	/* All 8 PLLs have same VCO and output frequency range restrictions. */
-	u32 vco_khz = OSC_HZ / 1000 * div->fbdiv / div->refdiv;
-	u32 output_khz = vco_khz / div->postdiv1 / div->postdiv2;
-
-	debug("PLL at %p: fbdiv=%d, refdiv=%d, postdiv1=%d, \
-	      postdiv2=%d, vco=%u khz, output=%u khz\n",
-	      pll_con, div->fbdiv, div->refdiv, div->postdiv1,
-	      div->postdiv2, vco_khz, output_khz);
-	assert(vco_khz >= VCO_MIN_KHZ && vco_khz <= VCO_MAX_KHZ &&
-	       output_khz >= OUTPUT_MIN_KHZ && output_khz <= OUTPUT_MAX_KHZ &&
-	       div->fbdiv >= PLL_DIV_MIN && div->fbdiv <= PLL_DIV_MAX);
 
 	/*
-	 * When power on or changing PLL setting,
-	 * we must force PLL into slow mode to ensure output stable clock.
+	 * select apll as cpu/core clock pll source and
+	 * set up dependent divisors for PERI and ACLK clocks.
+	 * core hz : apll = 1:1
 	 */
-	rk_clrsetreg(&cru->mode_con, mode_mask, PLL_MODE_SLOW << mode_shift);
-
-	/* use integer mode */
-	rk_clrsetreg(&pll_con[1], PLL_DSMPD_MASK,
-		     PLL_INTEGER_MODE << PLL_DSMPD_SHIFT);
-
-	rk_clrsetreg(&pll_con[0],
-		     PLL_FBDIV_MASK | PLL_POSTDIV1_MASK,
-		     (div->fbdiv << PLL_FBDIV_SHIFT) |
-		     (div->postdiv1 << PLL_POSTDIV1_SHIFT));
-	rk_clrsetreg(&pll_con[1],
-		     PLL_POSTDIV2_MASK | PLL_REFDIV_MASK,
-		     (div->postdiv2 << PLL_POSTDIV2_SHIFT) |
-		     (div->refdiv << PLL_REFDIV_SHIFT));
-
-	/* waiting for pll lock */
-	while (!(readl(&pll_con[1]) & (1 << PLL_LOCK_STATUS_SHIFT)))
-		udelay(1);
-
-	/* pll enter normal mode */
-	rk_clrsetreg(&cru->mode_con, mode_mask, PLL_MODE_NORM << mode_shift);
-}
-
-static void rkclk_init(struct rk3328_cru *cru)
-{
-	u32 aclk_div;
-	u32 hclk_div;
-	u32 pclk_div;
-
-	/* configure gpll cpll */
-	rkclk_set_pll(cru, CLK_GENERAL, &gpll_init_cfg);
-	rkclk_set_pll(cru, CLK_CODEC, &cpll_init_cfg);
-
-	/* configure perihp aclk, hclk, pclk */
-	aclk_div = GPLL_HZ / PERIHP_ACLK_HZ - 1;
-	hclk_div = PERIHP_ACLK_HZ / PERIHP_HCLK_HZ - 1;
-	pclk_div = PERIHP_ACLK_HZ / PERIHP_PCLK_HZ - 1;
-
-	rk_clrsetreg(&cru->clksel_con[28],
-		     ACLK_PERIHP_PLL_SEL_MASK | ACLK_PERIHP_DIV_CON_MASK,
-		     ACLK_PERIHP_PLL_SEL_GPLL << ACLK_PERIHP_PLL_SEL_SHIFT |
-		     aclk_div << ACLK_PERIHP_DIV_CON_SHIFT);
-	rk_clrsetreg(&cru->clksel_con[29],
-		     PCLK_PERIHP_DIV_CON_MASK | HCLK_PERIHP_DIV_CON_MASK,
-		     pclk_div << PCLK_PERIHP_DIV_CON_SHIFT |
-		     hclk_div << HCLK_PERIHP_DIV_CON_SHIFT);
-}
-
-void rk3328_configure_cpu(struct rk3328_cru *cru,
-			  enum apll_frequencies apll_freq)
-{
-	u32 clk_core_div;
-	u32 aclkm_div;
-	u32 pclk_dbg_div;
-
-	rkclk_set_pll(cru, CLK_ARM, apll_cfgs[apll_freq]);
-
-	clk_core_div = APLL_HZ / CLK_CORE_HZ - 1;
-	aclkm_div = APLL_HZ / ACLKM_CORE_HZ / (clk_core_div + 1) - 1;
-	pclk_dbg_div = APLL_HZ / PCLK_DBG_HZ / (clk_core_div + 1) - 1;
-
-	rk_clrsetreg(&cru->clksel_con[0],
-		     CLK_CORE_PLL_SEL_MASK | CLK_CORE_DIV_MASK,
-		     CLK_CORE_PLL_SEL_APLL << CLK_CORE_PLL_SEL_SHIFT |
-		     clk_core_div << CLK_CORE_DIV_SHIFT);
+	old_rate = rockchip_pll_get_rate(&rk3328_pll_clks[NPLL],
+					 priv->cru, NPLL);
+	if (old_rate > hz) {
+		if (rockchip_pll_set_rate(&rk3328_pll_clks[NPLL],
+					  priv->cru, NPLL, hz))
+			return -EINVAL;
+		rk_clrsetreg(&cru->clksel_con[0],
+			     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
+			     CORE_CLK_PLL_SEL_NPLL << CORE_CLK_PLL_SEL_SHIFT |
+			     0 << CORE_DIV_CON_SHIFT);
+		rk_clrsetreg(&cru->clksel_con[1],
+			     CORE_ACLK_DIV_MASK | CORE_DBG_DIV_MASK,
+			     rate->aclk_div << CORE_ACLK_DIV_SHIFT |
+			     rate->pclk_div << CORE_DBG_DIV_SHIFT);
+	} else if (old_rate < hz) {
+		rk_clrsetreg(&cru->clksel_con[1],
+			     CORE_ACLK_DIV_MASK | CORE_DBG_DIV_MASK,
+			     rate->aclk_div << CORE_ACLK_DIV_SHIFT |
+			     rate->pclk_div << CORE_DBG_DIV_SHIFT);
+		rk_clrsetreg(&cru->clksel_con[0],
+			     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
+			     CORE_CLK_PLL_SEL_NPLL << CORE_CLK_PLL_SEL_SHIFT |
+			     0 << CORE_DIV_CON_SHIFT);
+		if (rockchip_pll_set_rate(&rk3328_pll_clks[NPLL],
+					  priv->cru, NPLL, hz))
+			return -EINVAL;
+	}
 
-	rk_clrsetreg(&cru->clksel_con[1],
-		     PCLK_DBG_DIV_MASK | ACLKM_CORE_DIV_MASK,
-		     pclk_dbg_div << PCLK_DBG_DIV_SHIFT |
-		     aclkm_div << ACLKM_CORE_DIV_SHIFT);
+	return rockchip_pll_get_rate(&rk3328_pll_clks[NPLL], priv->cru, NPLL);
 }
 
-
-static ulong rk3328_i2c_get_clk(struct rk3328_cru *cru, ulong clk_id)
+#ifndef CONFIG_SPL_BUILD
+static ulong rk3328_i2c_get_clk(struct rk3328_clk_priv *priv, ulong clk_id)
 {
+	struct rk3328_cru *cru = priv->cru;
 	u32 div, con;
 
 	switch (clk_id) {
@@ -344,14 +191,16 @@ static ulong rk3328_i2c_get_clk(struct rk3328_cru *cru, ulong clk_id)
 		return -EINVAL;
 	}
 
-	return DIV_TO_RATE(GPLL_HZ, div);
+	return DIV_TO_RATE(priv->gpll_hz, div);
 }
 
-static ulong rk3328_i2c_set_clk(struct rk3328_cru *cru, ulong clk_id, uint hz)
+static ulong rk3328_i2c_set_clk(struct rk3328_clk_priv *priv,
+				ulong clk_id, uint hz)
 {
+	struct rk3328_cru *cru = priv->cru;
 	int src_clk_div;
 
-	src_clk_div = GPLL_HZ / hz;
+	src_clk_div = priv->gpll_hz / hz;
 	assert(src_clk_div - 1 < 127);
 
 	switch (clk_id) {
@@ -388,11 +237,85 @@ static ulong rk3328_i2c_set_clk(struct rk3328_cru *cru, ulong clk_id, uint hz)
 		return -EINVAL;
 	}
 
-	return DIV_TO_RATE(GPLL_HZ, src_clk_div);
+	return DIV_TO_RATE(priv->gpll_hz, src_clk_div);
 }
 
-static ulong rk3328_mmc_get_clk(struct rk3328_cru *cru, uint clk_id)
+static ulong rk3328_gmac2io_set_clk(struct rk3328_clk_priv *priv, ulong rate)
 {
+	struct rk3328_cru *cru = priv->cru;
+	struct rk3328_grf_regs *grf;
+	ulong ret;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	/*
+	 * The RGMII CLK can be derived either from an external "clkin"
+	 * or can be generated from internally by a divider from SCLK_MAC.
+	 */
+	if (readl(&grf->mac_con[1]) & BIT(10) &&
+	    readl(&grf->soc_con[4]) & BIT(14)) {
+		/* An external clock will always generate the right rate... */
+		ret = rate;
+	} else {
+		u32 con = readl(&cru->clksel_con[27]);
+		ulong pll_rate;
+		u8 div;
+
+		if ((con >> GMAC2IO_PLL_SEL_SHIFT) & GMAC2IO_PLL_SEL_GPLL)
+			pll_rate = priv->gpll_hz;
+		else
+			pll_rate = priv->cpll_hz;
+
+		div = DIV_ROUND_UP(pll_rate, rate) - 1;
+		if (div <= 0x1f)
+			rk_clrsetreg(&cru->clksel_con[27], GMAC2IO_CLK_DIV_MASK,
+				     div << GMAC2IO_CLK_DIV_SHIFT);
+		else
+			debug("Unsupported div for gmac:%d\n", div);
+
+		return DIV_TO_RATE(pll_rate, div);
+	}
+
+	return ret;
+}
+
+static ulong rk3328_gmac2phy_src_set_clk(struct rk3328_cru *cru, ulong rate)
+{
+	u32 con = readl(&cru->clksel_con[26]);
+	ulong pll_rate;
+	u8 div;
+
+	if ((con >> GMAC2PHY_PLL_SEL_SHIFT) & GMAC2PHY_PLL_SEL_GPLL)
+		pll_rate = GPLL_HZ;
+	else
+		pll_rate = CPLL_HZ;
+
+	div = DIV_ROUND_UP(pll_rate, rate) - 1;
+	if (div <= 0x1f)
+		rk_clrsetreg(&cru->clksel_con[26], GMAC2PHY_CLK_DIV_MASK,
+			     div << GMAC2PHY_CLK_DIV_SHIFT);
+	else
+		debug("Unsupported div for gmac:%d\n", div);
+
+	return DIV_TO_RATE(pll_rate, div);
+}
+
+static ulong rk3328_gmac2phy_set_clk(struct rk3328_cru *cru, ulong rate)
+{
+	struct rk3328_grf_regs *grf;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (readl(&grf->mac_con[2]) & BIT(10))
+		/* An external clock will always generate the right rate... */
+		return rate;
+	else
+		return rk3328_gmac2phy_src_set_clk(cru, rate);
+}
+#endif
+
+static ulong rk3328_mmc_get_clk(struct rk3328_clk_priv *priv, uint clk_id)
+{
+	struct rk3328_cru *cru = priv->cru;
 	u32 div, con, con_id;
 
 	switch (clk_id) {
@@ -402,6 +325,7 @@ static ulong rk3328_mmc_get_clk(struct rk3328_cru *cru, uint clk_id)
 		break;
 	case HCLK_EMMC:
 	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
 		con_id = 32;
 		break;
 	default:
@@ -414,12 +338,13 @@ static ulong rk3328_mmc_get_clk(struct rk3328_cru *cru, uint clk_id)
 	    == CLK_EMMC_PLL_SEL_24M)
 		return DIV_TO_RATE(OSC_HZ, div) / 2;
 	else
-		return DIV_TO_RATE(GPLL_HZ, div) / 2;
+		return DIV_TO_RATE(priv->gpll_hz, div) / 2;
 }
 
-static ulong rk3328_mmc_set_clk(struct rk3328_cru *cru,
+static ulong rk3328_mmc_set_clk(struct rk3328_clk_priv *priv,
 				ulong clk_id, ulong set_rate)
 {
+	struct rk3328_cru *cru = priv->cru;
 	int src_clk_div;
 	u32 con_id;
 
@@ -437,7 +362,7 @@ static ulong rk3328_mmc_set_clk(struct rk3328_cru *cru,
 	}
 	/* Select clk_sdmmc/emmc source from GPLL by default */
 	/* mmc clock defaulg div 2 internal, need provide double in cru */
-	src_clk_div = DIV_ROUND_UP(GPLL_HZ / 2, set_rate);
+	src_clk_div = DIV_ROUND_UP(priv->gpll_hz / 2, set_rate);
 
 	if (src_clk_div > 127) {
 		/* use 24MHz source for 400KHz clock */
@@ -453,54 +378,485 @@ static ulong rk3328_mmc_set_clk(struct rk3328_cru *cru,
 			     (src_clk_div - 1) << CLK_EMMC_DIV_CON_SHIFT);
 	}
 
-	return rk3328_mmc_get_clk(cru, clk_id);
+	return rk3328_mmc_get_clk(priv, clk_id);
 }
 
-static ulong rk3328_pwm_get_clk(struct rk3328_cru *cru)
+static ulong rk3328_spi_get_clk(struct rk3328_clk_priv *priv)
 {
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, con, mux, p_rate;
+
+	con = readl(&cru->clksel_con[24]);
+	div = (con & CLK_SPI_DIV_CON_MASK) >> CLK_SPI_DIV_CON_SHIFT;
+	mux = (con & CLK_SPI_PLL_SEL_MASK) >> CLK_SPI_PLL_SEL_SHIFT;
+	if (mux)
+		p_rate = priv->gpll_hz;
+	else
+		p_rate = priv->cpll_hz;
+
+	return DIV_TO_RATE(p_rate, div);
+}
+
+static ulong rk3328_spi_set_clk(struct rk3328_clk_priv *priv, uint hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div = priv->gpll_hz / hz;
+
+	rk_clrsetreg(&cru->clksel_con[24],
+		     CLK_SPI_PLL_SEL_MASK | CLK_SPI_DIV_CON_MASK,
+		     CLK_SPI_PLL_SEL_GPLL << CLK_SPI_PLL_SEL_SHIFT |
+		     (div - 1) << CLK_SPI_DIV_CON_SHIFT);
+
+	return DIV_TO_RATE(priv->gpll_hz, div);
+}
+
+#ifndef CONFIG_SPL_BUILD
+static ulong rk3328_pwm_get_clk(struct rk3328_clk_priv *priv)
+{
+	struct rk3328_cru *cru = priv->cru;
 	u32 div, con;
 
 	con = readl(&cru->clksel_con[24]);
 	div = (con & CLK_PWM_DIV_CON_MASK) >> CLK_PWM_DIV_CON_SHIFT;
 
-	return DIV_TO_RATE(GPLL_HZ, div);
+	return DIV_TO_RATE(priv->gpll_hz, div);
 }
 
-static ulong rk3328_pwm_set_clk(struct rk3328_cru *cru, uint hz)
+static ulong rk3328_pwm_set_clk(struct rk3328_clk_priv *priv, uint hz)
 {
-	u32 div = GPLL_HZ / hz;
+	struct rk3328_cru *cru = priv->cru;
+	u32 div = priv->gpll_hz / hz;
 
 	rk_clrsetreg(&cru->clksel_con[24],
 		     CLK_PWM_PLL_SEL_MASK | CLK_PWM_DIV_CON_MASK,
 		     CLK_PWM_PLL_SEL_GPLL << CLK_PWM_PLL_SEL_SHIFT |
 		     (div - 1) << CLK_PWM_DIV_CON_SHIFT);
 
-	return DIV_TO_RATE(GPLL_HZ, div);
+	return DIV_TO_RATE(priv->gpll_hz, div);
+}
+
+static ulong rk3328_saradc_get_clk(struct rk3328_clk_priv *priv)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[23]);
+	div = bitfield_extract(val, CLK_SARADC_DIV_CON_SHIFT,
+			       CLK_SARADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3328_saradc_set_clk(struct rk3328_clk_priv *priv, uint hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->clksel_con[23],
+		     CLK_SARADC_DIV_CON_MASK,
+		     src_clk_div << CLK_SARADC_DIV_CON_SHIFT);
+
+	return rk3328_saradc_get_clk(priv);
+}
+
+static ulong rk3328_tsadc_get_clk(struct rk3328_clk_priv *priv)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[22]);
+	div = bitfield_extract(val, CLK_SARADC_DIV_CON_SHIFT,
+			       CLK_SARADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3328_tsadc_set_clk(struct rk3328_clk_priv *priv, uint hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->clksel_con[22],
+		     CLK_SARADC_DIV_CON_MASK,
+		     src_clk_div << CLK_SARADC_DIV_CON_SHIFT);
+
+	return rk3328_tsadc_get_clk(priv);
+}
+
+static ulong rk3328_vop_get_clk(struct rk3328_clk_priv *priv, ulong clk_id)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_VOP_PRE:
+	case ACLK_VOP:
+		con = readl(&cru->clksel_con[39]);
+		div = (con & ACLK_VOP_DIV_CON_MASK) >> ACLK_VOP_DIV_CON_SHIFT;
+		parent = priv->cpll_hz;
+		break;
+	case ACLK_VIO_PRE:
+	case ACLK_VIO:
+		con = readl(&cru->clksel_con[37]);
+		div = (con & ACLK_VIO_DIV_CON_MASK) >> ACLK_VIO_DIV_CON_SHIFT;
+		parent = priv->cpll_hz;
+		break;
+	case HCLK_VIO_PRE:
+	case HCLK_VIO:
+		parent = rk3328_vop_get_clk(priv, ACLK_VIO_PRE);
+		con = readl(&cru->clksel_con[37]);
+		div = (con & HCLK_VIO_DIV_CON_MASK) >> HCLK_VIO_DIV_CON_SHIFT;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3328_vop_set_clk(struct rk3328_clk_priv *priv,
+				ulong clk_id, uint hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	int src_clk_div;
+	u32 con, parent;
+
+	src_clk_div = DIV_ROUND_UP(priv->cpll_hz, hz);
+	assert(src_clk_div - 1 < 31);
+
+	switch (clk_id) {
+	case ACLK_VOP_PRE:
+	case ACLK_VOP:
+		rk_clrsetreg(&cru->clksel_con[39],
+			     ACLK_VOP_PLL_SEL_MASK | ACLK_VOP_DIV_CON_MASK,
+			     ACLK_VOP_PLL_SEL_CPLL << ACLK_VOP_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_VOP_DIV_CON_SHIFT);
+		break;
+	case ACLK_VIO_PRE:
+	case ACLK_VIO:
+		rk_clrsetreg(&cru->clksel_con[37],
+			     ACLK_VIO_PLL_SEL_MASK | ACLK_VIO_DIV_CON_MASK,
+			     ACLK_VIO_PLL_SEL_CPLL << ACLK_VIO_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_VIO_DIV_CON_SHIFT);
+		break;
+	case HCLK_VIO_PRE:
+	case HCLK_VIO:
+		src_clk_div = DIV_ROUND_UP(rk3328_vop_get_clk(priv,
+							      ACLK_VIO_PRE),
+					   hz);
+		rk_clrsetreg(&cru->clksel_con[37],
+			     HCLK_VIO_DIV_CON_MASK,
+			     (src_clk_div - 1) << HCLK_VIO_DIV_CON_SHIFT);
+		break;
+	case DCLK_LCDC:
+		con = readl(&cru->clksel_con[40]);
+		con = (con & DCLK_LCDC_SEL_MASK) >> DCLK_LCDC_SEL_SHIFT;
+		if (con) {
+			parent = readl(&cru->clksel_con[40]);
+			parent = (parent & DCLK_LCDC_PLL_SEL_MASK) >>
+				 DCLK_LCDC_PLL_SEL_SHIFT;
+			if (parent)
+				src_clk_div = DIV_ROUND_UP(priv->cpll_hz, hz);
+			else
+				src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+
+			rk_clrsetreg(&cru->clksel_con[40],
+				     DCLK_LCDC_DIV_CON_MASK,
+				     (src_clk_div - 1) <<
+				     DCLK_LCDC_DIV_CON_SHIFT);
+		}
+		break;
+	default:
+		printf("do not support this vop freq\n");
+		return -EINVAL;
+	}
+
+	return rk3328_vop_get_clk(priv, clk_id);
+}
+#endif
+
+static ulong rk3328_bus_get_clk(struct rk3328_clk_priv *priv, ulong clk_id)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_BUS_PRE:
+		con = readl(&cru->clksel_con[0]);
+		div = (con & ACLK_BUS_DIV_CON_MASK) >> ACLK_BUS_DIV_CON_SHIFT;
+		parent = priv->cpll_hz;
+		break;
+	case HCLK_BUS_PRE:
+		con = readl(&cru->clksel_con[1]);
+		div = (con & HCLK_BUS_DIV_CON_MASK) >> HCLK_BUS_DIV_CON_SHIFT;
+		parent = rk3328_bus_get_clk(priv, ACLK_BUS_PRE);
+		break;
+	case PCLK_BUS_PRE:
+		con = readl(&cru->clksel_con[1]);
+		div = (con & PCLK_BUS_DIV_CON_MASK) >> PCLK_BUS_DIV_CON_SHIFT;
+		parent = rk3328_bus_get_clk(priv, ACLK_BUS_PRE);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
 }
 
+static ulong rk3328_bus_set_clk(struct rk3328_clk_priv *priv,
+				ulong clk_id, ulong hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	int src_clk_div;
+
+	/*
+	 * select gpll as pd_bus bus clock source and
+	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
+	 */
+	switch (clk_id) {
+	case ACLK_BUS_PRE:
+		src_clk_div = DIV_ROUND_UP(priv->cpll_hz, hz);
+		assert(src_clk_div - 1 < 31);
+		if (src_clk_div > 32)
+			src_clk_div = 32;
+		rk_clrsetreg(&cru->clksel_con[0],
+			     CLK_BUS_PLL_SEL_MASK | ACLK_BUS_DIV_CON_MASK,
+			     CLK_BUS_PLL_SEL_CPLL << CLK_BUS_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_BUS_DIV_CON_SHIFT);
+		break;
+	case HCLK_BUS_PRE:
+		src_clk_div = DIV_ROUND_UP(rk3328_bus_get_clk(priv,
+							      ACLK_BUS_PRE),
+					   hz);
+		assert(src_clk_div - 1 < 3);
+		rk_clrsetreg(&cru->clksel_con[1],
+			     HCLK_BUS_DIV_CON_MASK,
+			     (src_clk_div - 1) << HCLK_BUS_DIV_CON_SHIFT);
+		break;
+	case PCLK_BUS_PRE:
+		src_clk_div = DIV_ROUND_UP(rk3328_bus_get_clk(priv,
+							      ACLK_BUS_PRE),
+					   hz);
+		assert(src_clk_div - 1 < 7);
+		rk_clrsetreg(&cru->clksel_con[1],
+			     PCLK_BUS_DIV_CON_MASK,
+			     (src_clk_div - 1) << PCLK_BUS_DIV_CON_SHIFT);
+		break;
+	default:
+		printf("do not support this bus freq\n");
+		return -EINVAL;
+	}
+	return rk3328_bus_get_clk(priv, clk_id);
+}
+
+static ulong rk3328_peri_get_clk(struct rk3328_clk_priv *priv, ulong clk_id)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_PERI_PRE:
+		con = readl(&cru->clksel_con[28]);
+		div = (con & ACLK_PERI_DIV_CON_MASK) >> ACLK_PERI_DIV_CON_SHIFT;
+		parent = priv->cpll_hz;
+		break;
+	case HCLK_PERI:
+		con = readl(&cru->clksel_con[29]);
+		div = (con & HCLK_PERI_DIV_CON_MASK) >> HCLK_PERI_DIV_CON_SHIFT;
+		parent = rk3328_peri_get_clk(priv, ACLK_PERI_PRE);
+		break;
+	case PCLK_PERI:
+		con = readl(&cru->clksel_con[29]);
+		div = (con & PCLK_PERI_DIV_CON_MASK) >> PCLK_PERI_DIV_CON_SHIFT;
+		parent = rk3328_peri_get_clk(priv, ACLK_PERI_PRE);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3328_peri_set_clk(struct rk3328_clk_priv *priv,
+				 ulong clk_id, ulong hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	int src_clk_div;
+
+	/*
+	 * select gpll as pd_bus bus clock source and
+	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
+	 */
+	switch (clk_id) {
+	case ACLK_PERI_PRE:
+		src_clk_div = DIV_ROUND_UP(priv->cpll_hz, hz);
+		assert(src_clk_div - 1 < 31);
+		if (src_clk_div > 32)
+			src_clk_div = 32;
+		rk_clrsetreg(&cru->clksel_con[28],
+			     CLK_PERI_PLL_SEL_MASK | ACLK_PERI_DIV_CON_MASK,
+			     CLK_PERI_PLL_SEL_CPLL << CLK_PERI_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_PERI_DIV_CON_SHIFT);
+		break;
+	case HCLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rk3328_peri_get_clk(priv,
+							       ACLK_PERI_PRE),
+					   hz);
+		assert(src_clk_div - 1 < 3);
+		rk_clrsetreg(&cru->clksel_con[29],
+			     HCLK_PERI_DIV_CON_MASK,
+			     (src_clk_div - 1) << HCLK_PERI_DIV_CON_SHIFT);
+		break;
+	case PCLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rk3328_peri_get_clk(priv,
+							       ACLK_PERI_PRE),
+					   hz);
+		assert(src_clk_div - 1 < 7);
+		rk_clrsetreg(&cru->clksel_con[29],
+			     PCLK_PERI_DIV_CON_MASK,
+			     (src_clk_div - 1) << PCLK_PERI_DIV_CON_SHIFT);
+		break;
+	default:
+		printf("do not support this bus freq\n");
+		return -EINVAL;
+	}
+
+	return rk3328_peri_get_clk(priv, clk_id);
+}
+
+#ifndef CONFIG_SPL_BUILD
+static ulong rk3328_crypto_get_clk(struct rk3328_clk_priv *priv, ulong clk_id)
+{
+	struct rk3328_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case SCLK_CRYPTO:
+		con = readl(&cru->clksel_con[20]);
+		div = (con & CRYPTO_DIV_MASK) >> CRYPTO_DIV_SHIFT;
+		parent = priv->gpll_hz;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3328_crypto_set_clk(struct rk3328_clk_priv *priv, ulong clk_id,
+				   ulong hz)
+{
+	struct rk3328_cru *cru = priv->cru;
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(priv->gpll_hz, hz);
+	assert(src_clk_div - 1 <= 127);
+
+	/*
+	 * select gpll as crypto clock source and
+	 * set up dependent divisors for crypto clocks.
+	 */
+	switch (clk_id) {
+	case SCLK_CRYPTO:
+		rk_clrsetreg(&cru->clksel_con[20],
+			     CRYPTO_PLL_SEL_MASK | CRYPTO_DIV_MASK,
+			     CRYPTO_PLL_SEL_GPLL << CRYPTO_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << CRYPTO_DIV_SHIFT);
+		break;
+	default:
+		printf("do not support this peri freq\n");
+		return -EINVAL;
+	}
+
+	return rk3328_crypto_get_clk(priv, clk_id);
+}
+#endif
+
 static ulong rk3328_clk_get_rate(struct clk *clk)
 {
 	struct rk3328_clk_priv *priv = dev_get_priv(clk->dev);
 	ulong rate = 0;
 
+#ifndef CONFIG_SPL_BUILD
+	if (!priv->gpll_hz) {
+		priv->gpll_hz = rockchip_pll_get_rate(&rk3328_pll_clks[GPLL],
+						      priv->cru, GPLL);
+		debug("%s gpll=%lu\n", __func__, priv->gpll_hz);
+	}
+	if (!priv->cpll_hz) {
+		priv->cpll_hz = rockchip_pll_get_rate(&rk3328_pll_clks[CPLL],
+						      priv->cru, CPLL);
+		debug("%s cpll=%lu\n", __func__, priv->cpll_hz);
+	}
+#endif
+
 	switch (clk->id) {
-	case 0 ... 29:
-		return 0;
+	case PLL_APLL:
+	case PLL_DPLL:
+	case PLL_CPLL:
+	case PLL_GPLL:
+	case PLL_NPLL:
+		rate = rockchip_pll_get_rate(&rk3328_pll_clks[clk->id - 1],
+					     priv->cru, clk->id - 1);
+		break;
+	case ARMCLK:
+		rate = rockchip_pll_get_rate(&rk3328_pll_clks[NPLL],
+					     priv->cru, NPLL);
+		break;
+	case ACLK_BUS_PRE:
+	case HCLK_BUS_PRE:
+	case PCLK_BUS_PRE:
+		rate = rk3328_bus_get_clk(priv, clk->id);
+		break;
+	case ACLK_PERI_PRE:
+	case HCLK_PERI:
+	case PCLK_PERI:
+		rate = rk3328_peri_get_clk(priv, clk->id);
+		break;
 	case HCLK_SDMMC:
 	case HCLK_EMMC:
 	case SCLK_SDMMC:
 	case SCLK_EMMC:
-		rate = rk3328_mmc_get_clk(priv->cru, clk->id);
+	case SCLK_EMMC_SAMPLE:
+		rate = rk3328_mmc_get_clk(priv, clk->id);
+		break;
+	case SCLK_SPI:
+		rate = rk3328_spi_get_clk(priv);
 		break;
+#ifndef CONFIG_SPL_BUILD
 	case SCLK_I2C0:
 	case SCLK_I2C1:
 	case SCLK_I2C2:
 	case SCLK_I2C3:
-		rate = rk3328_i2c_get_clk(priv->cru, clk->id);
+		rate = rk3328_i2c_get_clk(priv, clk->id);
 		break;
 	case SCLK_PWM:
-		rate = rk3328_pwm_get_clk(priv->cru);
+		rate = rk3328_pwm_get_clk(priv);
+		break;
+	case SCLK_SARADC:
+		rate = rk3328_saradc_get_clk(priv);
+		break;
+	case SCLK_TSADC:
+		rate = rk3328_tsadc_get_clk(priv);
+		break;
+	case ACLK_VOP_PRE:
+	case ACLK_VIO_PRE:
+	case HCLK_VIO_PRE:
+	case ACLK_VOP:
+	case ACLK_VIO:
+	case HCLK_VIO:
+		rate = rk3328_vop_get_clk(priv, clk->id);
 		break;
+	case SCLK_CRYPTO:
+		rate = rk3328_crypto_get_clk(priv, clk->id);
+		break;
+#endif
 	default:
 		return -ENOENT;
 	}
@@ -514,22 +870,397 @@ static ulong rk3328_clk_set_rate(struct clk *clk, ulong rate)
 	ulong ret = 0;
 
 	switch (clk->id) {
-	case 0 ... 29:
-		return 0;
+	case PLL_APLL:
+	case PLL_DPLL:
+	case PLL_NPLL:
+		ret = rockchip_pll_set_rate(&rk3328_pll_clks[clk->id - 1],
+					    priv->cru, clk->id - 1, rate);
+		break;
+	case PLL_CPLL:
+		ret = rockchip_pll_set_rate(&rk3328_pll_clks[CPLL],
+					    priv->cru, CPLL, rate);
+		priv->cpll_hz = rate;
+		break;
+	case PLL_GPLL:
+		ret = rockchip_pll_set_rate(&rk3328_pll_clks[GPLL],
+					    priv->cru, GPLL, rate);
+		priv->gpll_hz = rate;
+		break;
+	case ARMCLK:
+		if (priv->armclk_hz)
+			ret = rk3328_armclk_set_clk(priv, rate);
+		priv->armclk_hz = rate;
+		break;
+	case ACLK_BUS_PRE:
+	case HCLK_BUS_PRE:
+	case PCLK_BUS_PRE:
+		rate = rk3328_bus_set_clk(priv, clk->id, rate);
+		break;
+	case ACLK_PERI_PRE:
+	case HCLK_PERI:
+	case PCLK_PERI:
+		rate = rk3328_peri_set_clk(priv, clk->id, rate);
+		break;
 	case HCLK_SDMMC:
 	case HCLK_EMMC:
 	case SCLK_SDMMC:
 	case SCLK_EMMC:
-		ret = rk3328_mmc_set_clk(priv->cru, clk->id, rate);
+		ret = rk3328_mmc_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_SPI:
+		ret = rk3328_spi_set_clk(priv, rate);
 		break;
+#ifndef CONFIG_SPL_BUILD
 	case SCLK_I2C0:
 	case SCLK_I2C1:
 	case SCLK_I2C2:
 	case SCLK_I2C3:
-		ret = rk3328_i2c_set_clk(priv->cru, clk->id, rate);
+		ret = rk3328_i2c_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_MAC2IO:
+		ret = rk3328_gmac2io_set_clk(priv, rate);
+		break;
+	case SCLK_MAC2PHY:
+		ret = rk3328_gmac2phy_set_clk(priv->cru, rate);
+		break;
+	case SCLK_MAC2PHY_SRC:
+		ret = rk3328_gmac2phy_src_set_clk(priv->cru, rate);
 		break;
 	case SCLK_PWM:
-		ret = rk3328_pwm_set_clk(priv->cru, rate);
+		ret = rk3328_pwm_set_clk(priv, rate);
+		break;
+	case SCLK_SARADC:
+		ret = rk3328_saradc_set_clk(priv, rate);
+		break;
+	case SCLK_TSADC:
+		ret = rk3328_tsadc_set_clk(priv, rate);
+		break;
+	case DCLK_LCDC:
+	case ACLK_VOP_PRE:
+	case ACLK_VIO_PRE:
+	case HCLK_VIO_PRE:
+	case ACLK_VOP:
+	case ACLK_VIO:
+	case HCLK_VIO:
+		rate = rk3328_vop_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_CRYPTO:
+		rate = rk3328_crypto_set_clk(priv, clk->id, rate);
+		break;
+#endif
+	case SCLK_PDM:
+	case SCLK_RTC32K:
+	case SCLK_UART0:
+	case SCLK_UART1:
+	case SCLK_UART2:
+	case SCLK_SDIO:
+	case SCLK_TSP:
+	case SCLK_WIFI:
+	case ACLK_RGA_PRE:
+	case SCLK_RGA:
+	case ACLK_RKVDEC_PRE:
+	case ACLK_RKVENC:
+	case ACLK_VPU_PRE:
+	case SCLK_VDEC_CABAC:
+	case SCLK_VDEC_CORE:
+	case SCLK_VENC_CORE:
+	case SCLK_VENC_DSP:
+	case SCLK_EFUSE:
+	case PCLK_DDR:
+	case ACLK_GMAC:
+	case PCLK_GMAC:
+	case SCLK_USB3OTG_SUSPEND:
+		return 0;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+#ifndef CONFIG_SPL_BUILD
+static int rk3328_gmac2io_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3328_grf_regs *grf;
+	const char *clock_output_name;
+	int ret;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	/*
+	 * If the requested parent is in the same clock-controller and the id
+	 * is SCLK_MAC2IO_SRC ("clk_mac2io_src"), switch to the internal clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC2IO_SRC)) {
+		debug("%s: switching RGMII to SCLK_MAC2IO_SRC\n", __func__);
+		rk_clrreg(&grf->mac_con[1], BIT(10));
+		return 0;
+	}
+
+	/*
+	 * Otherwise, we need to check the clock-output-names of the
+	 * requested parent to see if the requested id is "gmac_clkin".
+	 */
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	/* If this is "gmac_clkin", switch to the external clock input */
+	if (!strcmp(clock_output_name, "gmac_clkin")) {
+		debug("%s: switching RGMII to CLKIN\n", __func__);
+		rk_setreg(&grf->mac_con[1], BIT(10));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int rk3328_gmac2io_ext_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3328_grf_regs *grf;
+	const char *clock_output_name;
+	int ret;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	/*
+	 * If the requested parent is in the same clock-controller and the id
+	 * is SCLK_MAC2IO ("clk_mac2io"), switch to the internal clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC2IO)) {
+		debug("%s: switching RGMII to SCLK_MAC2IO\n", __func__);
+		rk_clrreg(&grf->soc_con[4], BIT(14));
+		return 0;
+	}
+
+	/*
+	 * Otherwise, we need to check the clock-output-names of the
+	 * requested parent to see if the requested id is "gmac_clkin".
+	 */
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	/* If this is "gmac_clkin", switch to the external clock input */
+	if (!strcmp(clock_output_name, "gmac_clkin")) {
+		debug("%s: switching RGMII to CLKIN\n", __func__);
+		rk_setreg(&grf->soc_con[4], BIT(14));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int rk3328_gmac2phy_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3328_grf_regs *grf;
+	const char *clock_output_name;
+	int ret;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	/*
+	 * If the requested parent is in the same clock-controller and the id
+	 * is SCLK_MAC2PHY_SRC ("clk_mac2phy_src"), switch to the internal clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC2PHY_SRC)) {
+		debug("%s: switching MAC CLK to SCLK_MAC2IO_PHY\n", __func__);
+		rk_clrreg(&grf->mac_con[2], BIT(10));
+		return 0;
+	}
+
+	/*
+	 * Otherwise, we need to check the clock-output-names of the
+	 * requested parent to see if the requested id is "phy_50m_out".
+	 */
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	/* If this is "phy_50m_out", switch to the external clock input */
+	if (!strcmp(clock_output_name, "phy_50m_out")) {
+		debug("%s: switching MAC CLK to PHY_50M_OUT\n", __func__);
+		rk_setreg(&grf->mac_con[2], BIT(10));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int rk3328_lcdc_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3328_clk_priv *priv = dev_get_priv(clk->dev);
+
+	if (parent->id == HDMIPHY)
+		rk_clrsetreg(&priv->cru->clksel_con[40],
+			     DCLK_LCDC_SEL_MASK,
+			     DCLK_LCDC_SEL_HDMIPHY << DCLK_LCDC_SEL_SHIFT);
+	else if (parent->id == PLL_CPLL)
+		rk_clrsetreg(&priv->cru->clksel_con[40],
+			     DCLK_LCDC_SEL_MASK | DCLK_LCDC_PLL_SEL_MASK,
+			     (DCLK_LCDC_SEL_PLL << DCLK_LCDC_SEL_SHIFT) |
+			     (DCLK_LCDC_PLL_SEL_CPLL <<
+			     DCLK_LCDC_PLL_SEL_SHIFT));
+	else
+		rk_clrsetreg(&priv->cru->clksel_con[40],
+			     DCLK_LCDC_SEL_MASK | DCLK_LCDC_PLL_SEL_MASK,
+			     (DCLK_LCDC_SEL_PLL << DCLK_LCDC_SEL_SHIFT) |
+			     (DCLK_LCDC_PLL_SEL_GPLL <<
+			     DCLK_LCDC_PLL_SEL_SHIFT));
+
+	return 0;
+}
+#endif
+
+static int rk3328_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	switch (clk->id) {
+#ifndef CONFIG_SPL_BUILD
+	case SCLK_MAC2IO:
+		return rk3328_gmac2io_set_parent(clk, parent);
+	case SCLK_MAC2IO_EXT:
+		return rk3328_gmac2io_ext_set_parent(clk, parent);
+	case SCLK_MAC2PHY:
+		return rk3328_gmac2phy_set_parent(clk, parent);
+	case DCLK_LCDC:
+		return rk3328_lcdc_set_parent(clk, parent);
+#endif
+	case SCLK_PDM:
+	case SCLK_RTC32K:
+	case SCLK_UART0:
+	case SCLK_UART1:
+	case SCLK_UART2:
+		return 0;
+	}
+
+	debug("%s: unsupported clk %ld\n", __func__, clk->id);
+	return -ENOENT;
+}
+
+#define ROCKCHIP_MMC_DELAY_SEL		BIT(10)
+#define ROCKCHIP_MMC_DEGREE_MASK	0x3
+#define ROCKCHIP_MMC_DELAYNUM_OFFSET	2
+#define ROCKCHIP_MMC_DELAYNUM_MASK	(0xff << ROCKCHIP_MMC_DELAYNUM_OFFSET)
+
+#define PSECS_PER_SEC 1000000000000LL
+/*
+ * Each fine delay is between 44ps-77ps. Assume each fine delay is 60ps to
+ * simplify calculations. So 45degs could be anywhere between 33deg and 57.8deg.
+ */
+#define ROCKCHIP_MMC_DELAY_ELEMENT_PSEC 60
+
+int rk3328_mmc_get_phase(struct clk *clk)
+{
+	struct rk3328_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3328_cru *cru = priv->cru;
+	u32 raw_value, delay_num;
+	u16 degrees = 0;
+	ulong rate;
+
+	rate = rk3328_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		raw_value = readl(&cru->emmc_con[1]);
+	else if (clk->id == SCLK_SDMMC_SAMPLE)
+		raw_value = readl(&cru->sdmmc_con[1]);
+	else
+		raw_value = readl(&cru->sdio_con[1]);
+
+	raw_value >>= 1;
+	degrees = (raw_value & ROCKCHIP_MMC_DEGREE_MASK) * 90;
+
+	if (raw_value & ROCKCHIP_MMC_DELAY_SEL) {
+		/* degrees/delaynum * 10000 */
+		unsigned long factor = (ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10) *
+					36 * (rate / 1000000);
+
+		delay_num = (raw_value & ROCKCHIP_MMC_DELAYNUM_MASK);
+		delay_num >>= ROCKCHIP_MMC_DELAYNUM_OFFSET;
+		degrees += DIV_ROUND_CLOSEST(delay_num * factor, 10000);
+	}
+
+	return degrees % 360;
+}
+
+int rk3328_mmc_set_phase(struct clk *clk, u32 degrees)
+{
+	struct rk3328_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3328_cru *cru = priv->cru;
+	u8 nineties, remainder, delay_num;
+	u32 raw_value, delay;
+	ulong rate;
+
+	rate = rk3328_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	nineties = degrees / 90;
+	remainder = (degrees % 90);
+
+	/*
+	 * Convert to delay; do a little extra work to make sure we
+	 * don't overflow 32-bit / 64-bit numbers.
+	 */
+	delay = 10000000; /* PSECS_PER_SEC / 10000 / 10 */
+	delay *= remainder;
+	delay = DIV_ROUND_CLOSEST(delay, (rate / 1000) * 36 *
+				(ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10));
+
+	delay_num = (u8)min_t(u32, delay, 255);
+
+	raw_value = delay_num ? ROCKCHIP_MMC_DELAY_SEL : 0;
+	raw_value |= delay_num << ROCKCHIP_MMC_DELAYNUM_OFFSET;
+	raw_value |= nineties;
+
+	raw_value <<= 1;
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->emmc_con[1]);
+	else if (clk->id == SCLK_SDMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->sdmmc_con[1]);
+	else
+		writel(raw_value | 0xffff0000, &cru->sdio_con[1]);
+
+	debug("mmc set_phase(%d) delay_nums=%u reg=%#x actual_degrees=%d\n",
+	      degrees, delay_num, raw_value, rk3328_mmc_get_phase(clk));
+
+	return 0;
+}
+
+static int rk3328_clk_get_phase(struct clk *clk)
+{
+	int ret;
+
+	debug("%s %ld\n", __func__, clk->id);
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO_SAMPLE:
+		ret = rk3328_mmc_get_phase(clk);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+static int rk3328_clk_set_phase(struct clk *clk, int degrees)
+{
+	int ret;
+
+	debug("%s %ld\n", __func__, clk->id);
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO_SAMPLE:
+		ret = rk3328_mmc_set_phase(clk, degrees);
 		break;
 	default:
 		return -ENOENT;
@@ -541,13 +1272,73 @@ static ulong rk3328_clk_set_rate(struct clk *clk, ulong rate)
 static struct clk_ops rk3328_clk_ops = {
 	.get_rate = rk3328_clk_get_rate,
 	.set_rate = rk3328_clk_set_rate,
+	.set_parent = rk3328_clk_set_parent,
+	.get_phase = rk3328_clk_get_phase,
+	.set_phase = rk3328_clk_set_phase,
 };
 
+static void rkclk_init(struct rk3328_clk_priv *priv)
+{
+	if (rockchip_pll_get_rate(&rk3328_pll_clks[NPLL],
+				  priv->cru, NPLL) != APLL_HZ)
+		rk3328_armclk_set_clk(priv, APLL_HZ);
+
+	priv->gpll_hz = rockchip_pll_get_rate(&rk3328_pll_clks[GPLL],
+					      priv->cru, GPLL);
+	priv->cpll_hz = rockchip_pll_get_rate(&rk3328_pll_clks[CPLL],
+					      priv->cru, CPLL);
+
+	/* before set pll set child div first */
+	rk_clrsetreg(&priv->cru->clksel_con[24], (0x3f << 8) | (0x3f << 0),
+		     (0x17 << 8) | (0x17 << 0));
+	rk_clrsetreg(&priv->cru->clksel_con[27], (0x1f << 8) | (0x1f << 0),
+		     (0x17 << 8) | (0x17 << 0));
+	rk_clrsetreg(&priv->cru->clksel_con[31], 0xff << 0, 0xb << 0);
+	rk_clrsetreg(&priv->cru->clksel_con[43], 0xff << 0, 0xb << 0);
+	rk_clrsetreg(&priv->cru->clksel_con[52], 0x1f << 8, 0x5 << 8);
+
+	rockchip_pll_set_rate(&rk3328_pll_clks[GPLL],
+			      priv->cru, GPLL, GPLL_HZ);
+	priv->gpll_hz = GPLL_HZ;
+
+	rockchip_pll_set_rate(&rk3328_pll_clks[CPLL],
+			      priv->cru, CPLL, CPLL_HZ);
+	priv->cpll_hz = CPLL_HZ;
+
+	rk3328_bus_set_clk(priv, ACLK_BUS_PRE, ACLK_BUS_HZ);
+	rk3328_bus_set_clk(priv, HCLK_BUS_PRE, ACLK_BUS_HZ / 2);
+	rk3328_bus_set_clk(priv, PCLK_BUS_PRE, ACLK_BUS_HZ / 2);
+	rk3328_peri_set_clk(priv, ACLK_PERI_PRE, ACLK_PERI_HZ);
+	rk3328_peri_set_clk(priv, HCLK_PERI, ACLK_PERI_HZ / 2);
+	rk3328_peri_set_clk(priv, PCLK_PERI, ACLK_PERI_HZ / 2);
+	/*rk3328_mmc_set_clk(priv, SCLK_EMMC, rate);*/
+
+	/* set usbphy and hdmiphy from phy */
+	rk_clrsetreg(&priv->cru->misc, (0x1 << 13) |
+		     (0x1 << 15), (0 << 15) | (0 << 13));
+}
+
 static int rk3328_clk_probe(struct udevice *dev)
 {
 	struct rk3328_clk_priv *priv = dev_get_priv(dev);
-
-	rkclk_init(priv->cru);
+	int ret = 0;
+
+	priv->sync_kernel = false;
+	if (!priv->armclk_enter_hz)
+		priv->armclk_enter_hz =
+		rockchip_pll_get_rate(&rk3328_pll_clks[NPLL],
+				      priv->cru, NPLL);
+	rkclk_init(priv);
+	if (!priv->armclk_init_hz)
+		priv->armclk_init_hz =
+		rockchip_pll_get_rate(&rk3328_pll_clks[NPLL],
+				      priv->cru, NPLL);
+
+	ret = clk_set_defaults(dev);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+	else
+		priv->sync_kernel = true;
 
 	return 0;
 }
@@ -556,7 +1347,7 @@ static int rk3328_clk_ofdata_to_platdata(struct udevice *dev)
 {
 	struct rk3328_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk3328_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
 
 	return 0;
 }
@@ -564,13 +1355,37 @@ static int rk3328_clk_ofdata_to_platdata(struct udevice *dev)
 static int rk3328_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk3328_sysreset", "reset", &dev);
-	if (ret)
-		printf("Warning: No RK3328 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3328_cru,
+						    glb_srst_fst_value);
+		priv->glb_srst_snd_value = offsetof(struct rk3328_cru,
+						    glb_srst_snd_value);
+		sys_child->priv = priv;
+	}
 
-	return ret;
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3328_cru,
+						    softrst_con[0]);
+		sf_priv->sf_reset_num = 12;
+		sf_child->priv = sf_priv;
+	}
+
+	return 0;
 }
 
 static const struct udevice_id rk3328_clk_ids[] = {
@@ -588,3 +1403,68 @@ U_BOOT_DRIVER(rockchip_rk3328_cru) = {
 	.bind		= rk3328_clk_bind,
 	.probe		= rk3328_clk_probe,
 };
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev;
+	struct rk3328_clk_priv *priv;
+	const struct rk3328_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk3328_cru),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arm: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armclk_enter_hz / 1000,
+	       priv->armclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
diff --git a/drivers/clk/rockchip/clk_rk3368.c b/drivers/clk/rockchip/clk_rk3368.c
index 2be1f572d7..b007777797 100644
--- a/drivers/clk/rockchip/clk_rk3368.c
+++ b/drivers/clk/rockchip/clk_rk3368.c
@@ -12,9 +12,10 @@
 #include <errno.h>
 #include <mapmem.h>
 #include <syscon.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3368.h>
-#include <asm/arch/hardware.h>
+#include <bitfield.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3368.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <asm/io.h>
 #include <dm/lists.h>
 #include <dt-bindings/clock/rk3368-cru.h>
@@ -28,9 +29,27 @@ struct rk3368_clk_plat {
 #endif
 
 struct pll_div {
+	ulong rate;
 	u32 nr;
 	u32 nf;
 	u32 no;
+	u32 nb;
+};
+
+#define RK3368_PLL_RATE(_rate, _nr, _nf, _no, _nb)	\
+{							\
+	.rate	= _rate##U,				\
+	.nr = _nr,					\
+	.nf = _nf,					\
+	.no = _no,					\
+	.nb = _nb,					\
+}
+
+static struct pll_div rk3368_pll_rates[] = {
+	/* _mhz,  _nr, _nf, _no, _nb */
+	RK3368_PLL_RATE(594000000, 1, 99, 4, 16),
+	RK3368_PLL_RATE(424200000, 5, 707, 8, 0),
+	RK3368_PLL_RATE(410000000, 3, 205, 4, 16),
 };
 
 #define OSC_HZ		(24 * 1000 * 1000)
@@ -38,9 +57,52 @@ struct pll_div {
 #define APLL_B_HZ	(816 * 1000 * 1000)
 #define GPLL_HZ		(576 * 1000 * 1000)
 #define CPLL_HZ		(400 * 1000 * 1000)
+#define NPLL_HZ		(594 * 1000 * 1000)
 
 #define DIV_TO_RATE(input_rate, div)    ((input_rate) / ((div) + 1))
 
+#if !defined(CONFIG_SPL_BUILD)
+#define RK3368_CLK_DUMP(_id, _name, _iscru)	\
+{						\
+	.id = _id,				\
+	.name = _name,				\
+	.is_cru = _iscru,			\
+}
+
+static const struct rk3368_clk_info clks_dump[] = {
+	RK3368_CLK_DUMP(PLL_APLLB, "apllb", true),
+	RK3368_CLK_DUMP(PLL_APLLL, "aplll", true),
+	RK3368_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK3368_CLK_DUMP(PLL_CPLL, "cpll", true),
+	RK3368_CLK_DUMP(PLL_GPLL, "gpll", true),
+	RK3368_CLK_DUMP(PLL_NPLL, "npll", true),
+	RK3368_CLK_DUMP(ARMCLKB, "armclkb", true),
+	RK3368_CLK_DUMP(ARMCLKL, "armclkl", true),
+	RK3368_CLK_DUMP(ACLK_BUS, "aclk_bus", true),
+	RK3368_CLK_DUMP(HCLK_BUS, "hclk_bus", true),
+	RK3368_CLK_DUMP(PCLK_BUS, "pclk_Bus", true),
+	RK3368_CLK_DUMP(ACLK_PERI, "aclk_peri", true),
+	RK3368_CLK_DUMP(HCLK_PERI, "hclk_peri", true),
+	RK3368_CLK_DUMP(PCLK_PERI, "pclk_peri", true),
+};
+#endif
+
+#define RK3368_CPUCLK_RATE(_rate, _aclk_div, _pclk_div)		\
+{								\
+	.rate	= _rate##U,					\
+	.aclk_div = _aclk_div,					\
+	.pclk_div = _pclk_div,					\
+}
+
+static struct rockchip_cpu_rate_table rk3368_cpu_rates[] = {
+#if !defined(CONFIG_SPL_BUILD)
+	RK3368_CPUCLK_RATE(1200000000, 1, 5),
+	RK3368_CPUCLK_RATE(1008000000, 1, 5),
+#endif
+	RK3368_CPUCLK_RATE(816000000, 1, 3),
+	RK3368_CPUCLK_RATE(600000000, 1, 3),
+};
+
 #define PLL_DIVISORS(hz, _nr, _no) { \
 	.nr = _nr, .nf = (u32)((u64)hz * _nr * _no / OSC_HZ), .no = _no}; \
 	_Static_assert(((u64)hz * _nr * _no / OSC_HZ) * OSC_HZ /\
@@ -58,6 +120,105 @@ static const struct pll_div cpll_init_cfg = PLL_DIVISORS(CPLL_HZ, 1, 6);
 
 static ulong rk3368_clk_get_rate(struct clk *clk);
 
+#define VCO_MAX_KHZ	2200000
+#define VCO_MIN_KHZ	440000
+#define FREF_MAX_KHZ	2200000
+#define FREF_MIN_KHZ	269
+#define PLL_LIMIT_FREQ	400000000
+
+struct pll_div *rkclk_get_pll_config(ulong freq_hz)
+{
+	unsigned int rate_count = ARRAY_SIZE(rk3368_pll_rates);
+	int i;
+
+	for (i = 0; i < rate_count; i++) {
+		if (freq_hz == rk3368_pll_rates[i].rate)
+			return &rk3368_pll_rates[i];
+	}
+	return NULL;
+}
+
+static int pll_para_config(ulong freq_hz, struct pll_div *div, uint *ext_div)
+{
+	struct pll_div *best_div = NULL;
+	uint ref_khz = OSC_HZ / 1000, nr, nf = 0;
+	uint fref_khz;
+	uint diff_khz, best_diff_khz;
+	const uint max_nr = 1 << 6, max_nf = 1 << 12, max_no = 1 << 4;
+	uint vco_khz;
+	uint no = 1;
+	uint freq_khz = freq_hz / 1000;
+
+	if (!freq_hz) {
+		printf("%s: the frequency can not be 0 Hz\n", __func__);
+		return -EINVAL;
+	}
+
+	no = DIV_ROUND_UP(VCO_MIN_KHZ, freq_khz);
+	if (ext_div) {
+		*ext_div = DIV_ROUND_UP(PLL_LIMIT_FREQ, freq_hz);
+		no = DIV_ROUND_UP(no, *ext_div);
+	}
+
+	best_div = rkclk_get_pll_config(freq_hz * (*ext_div));
+	if (best_div) {
+		div->nr = best_div->nr;
+		div->nf = best_div->nf;
+		div->no = best_div->no;
+		div->nb = best_div->nb;
+		return 0;
+	}
+
+	/* only even divisors (and 1) are supported */
+	if (no > 1)
+		no = DIV_ROUND_UP(no, 2) * 2;
+
+	vco_khz = freq_khz * no;
+	if (ext_div)
+		vco_khz *= *ext_div;
+
+	if (vco_khz < VCO_MIN_KHZ || vco_khz > VCO_MAX_KHZ || no > max_no) {
+		printf("%s: Cannot find out VCO for Frequency (%luHz).\n",
+		       __func__, freq_hz);
+		return -1;
+	}
+
+	div->no = no;
+
+	best_diff_khz = vco_khz;
+	for (nr = 1; nr < max_nr && best_diff_khz; nr++) {
+		fref_khz = ref_khz / nr;
+		if (fref_khz < FREF_MIN_KHZ)
+			break;
+		if (fref_khz > FREF_MAX_KHZ)
+			continue;
+
+		nf = vco_khz / fref_khz;
+		if (nf >= max_nf)
+			continue;
+		diff_khz = vco_khz - nf * fref_khz;
+		if (nf + 1 < max_nf && diff_khz > fref_khz / 2) {
+			nf++;
+			diff_khz = fref_khz - diff_khz;
+		}
+
+		if (diff_khz >= best_diff_khz)
+			continue;
+
+		best_diff_khz = diff_khz;
+		div->nr = nr;
+		div->nf = nf;
+	}
+
+	if (best_diff_khz > 4 * 1000) {
+		printf("%s:Fail to match output freq %lu,best_is %u Hz\n",
+		       __func__, freq_hz, best_diff_khz * 1000);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 /* Get pll rate by id */
 static uint32_t rkclk_pll_get_rate(struct rk3368_cru *cru,
 				   enum rk3368_pll_id pll_id)
@@ -85,7 +246,6 @@ static uint32_t rkclk_pll_get_rate(struct rk3368_cru *cru,
 	}
 }
 
-#if IS_ENABLED(CONFIG_SPL_BUILD) || IS_ENABLED(CONFIG_TPL_BUILD)
 static int rkclk_set_pll(struct rk3368_cru *cru, enum rk3368_pll_id pll_id,
 			 const struct pll_div *div)
 {
@@ -109,7 +269,10 @@ static int rkclk_set_pll(struct rk3368_cru *cru, enum rk3368_pll_id pll_id,
 	 * BWADJ should be set to NF / 2 to ensure the nominal bandwidth.
 	 * Compare the RK3368 TRM, section "3.6.4 PLL Bandwidth Adjustment".
 	 */
-	clrsetbits_le32(&pll->con2, PLL_BWADJ_MASK, (div->nf >> 1) - 1);
+	if (div->nb)
+		clrsetbits_le32(&pll->con2, PLL_BWADJ_MASK, div->nb - 1);
+	else
+		clrsetbits_le32(&pll->con2, PLL_BWADJ_MASK, (div->nf >> 1) - 1);
 
 	udelay(10);
 
@@ -125,34 +288,6 @@ static int rkclk_set_pll(struct rk3368_cru *cru, enum rk3368_pll_id pll_id,
 
 	return 0;
 }
-#endif
-
-#if IS_ENABLED(CONFIG_SPL_BUILD) || IS_ENABLED(CONFIG_TPL_BUILD)
-static void rkclk_init(struct rk3368_cru *cru)
-{
-	u32 apllb, aplll, dpll, cpll, gpll;
-
-	rkclk_set_pll(cru, APLLB, &apll_b_init_cfg);
-	rkclk_set_pll(cru, APLLL, &apll_l_init_cfg);
-#if !defined(CONFIG_TPL_BUILD)
-	/*
-	 * If we plan to return to the boot ROM, we can't increase the
-	 * GPLL rate from the SPL stage.
-	 */
-	rkclk_set_pll(cru, GPLL, &gpll_init_cfg);
-	rkclk_set_pll(cru, CPLL, &cpll_init_cfg);
-#endif
-
-	apllb = rkclk_pll_get_rate(cru, APLLB);
-	aplll = rkclk_pll_get_rate(cru, APLLL);
-	dpll = rkclk_pll_get_rate(cru, DPLL);
-	cpll = rkclk_pll_get_rate(cru, CPLL);
-	gpll = rkclk_pll_get_rate(cru, GPLL);
-
-	debug("%s apllb(%d) apll(%d) dpll(%d) cpll(%d) gpll(%d)\n",
-	       __func__, apllb, aplll, dpll, cpll, gpll);
-}
-#endif
 
 #if !IS_ENABLED(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(MMC_SUPPORT)
 static ulong rk3368_mmc_get_clk(struct rk3368_cru *cru, uint clk_id)
@@ -301,7 +436,7 @@ static ulong rk3368_ddr_set_clk(struct rk3368_cru *cru, ulong set_rate)
 		dpll_cfg = &dpll_1600;
 		break;
 	default:
-		error("Unsupported SDRAM frequency!,%ld\n", set_rate);
+		pr_err("Unsupported SDRAM frequency!,%ld\n", set_rate);
 	}
 	rkclk_set_pll(cru, DPLL, dpll_cfg);
 
@@ -310,15 +445,43 @@ static ulong rk3368_ddr_set_clk(struct rk3368_cru *cru, ulong set_rate)
 #endif
 
 #if CONFIG_IS_ENABLED(GMAC_ROCKCHIP)
-static ulong rk3368_gmac_set_clk(struct rk3368_cru *cru,
-				 ulong clk_id, ulong set_rate)
+static ulong rk3368_gmac_set_clk(struct rk3368_cru *cru, ulong set_rate)
 {
+	ulong ret;
+
 	/*
-	 * This models the 'assigned-clock-parents = <&ext_gmac>' from
-	 * the DTS and switches to the 'ext_gmac' clock parent.
+	 * The gmac clock can be derived either from an external clock
+	 * or can be generated from internally by a divider from SCLK_MAC.
 	 */
-	rk_setreg(&cru->clksel_con[43], GMAC_MUX_SEL_EXTCLK);
-	return set_rate;
+	if (readl(&cru->clksel_con[43]) & GMAC_MUX_SEL_EXTCLK) {
+		/* An external clock will always generate the right rate... */
+		ret = set_rate;
+	} else {
+		u32 con = readl(&cru->clksel_con[43]);
+		ulong pll_rate;
+		u8 div;
+
+		if (((con >> GMAC_PLL_SHIFT) & GMAC_PLL_MASK) ==
+		    GMAC_PLL_SELECT_GENERAL)
+			pll_rate = GPLL_HZ;
+		else if (((con >> GMAC_PLL_SHIFT) & GMAC_PLL_MASK) ==
+			 GMAC_PLL_SELECT_CODEC)
+			pll_rate = CPLL_HZ;
+		else
+			/* CPLL is not set */
+			return -EPERM;
+
+		div = DIV_ROUND_UP(pll_rate, set_rate) - 1;
+		if (div <= 0x1f)
+			rk_clrsetreg(&cru->clksel_con[43], GMAC_DIV_CON_MASK,
+				     div << GMAC_DIV_CON_SHIFT);
+		else
+			debug("Unsupported div for gmac:%d\n", div);
+
+		return DIV_TO_RATE(pll_rate, div);
+	}
+
+	return ret;
 }
 #endif
 
@@ -359,7 +522,7 @@ static ulong rk3368_spi_get_clk(struct rk3368_cru *cru, ulong clk_id)
 		break;
 
 	default:
-		error("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
+		pr_err("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
 		return -EINVAL;
 	}
 
@@ -384,7 +547,7 @@ static ulong rk3368_spi_set_clk(struct rk3368_cru *cru, ulong clk_id, uint hz)
 		break;
 
 	default:
-		error("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
+		pr_err("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
 		return -EINVAL;
 	}
 
@@ -397,6 +560,371 @@ static ulong rk3368_spi_set_clk(struct rk3368_cru *cru, ulong clk_id, uint hz)
 	return rk3368_spi_get_clk(cru, clk_id);
 }
 
+static ulong rk3368_saradc_get_clk(struct rk3368_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[25]);
+	div = bitfield_extract(val, CLK_SARADC_DIV_CON_SHIFT,
+			       CLK_SARADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3368_saradc_set_clk(struct rk3368_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->clksel_con[25],
+		     CLK_SARADC_DIV_CON_MASK,
+		     src_clk_div << CLK_SARADC_DIV_CON_SHIFT);
+
+	return rk3368_saradc_get_clk(cru);
+}
+
+static ulong rk3368_bus_get_clk(struct rk3368_cru *cru, ulong clk_id)
+{
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_BUS:
+		con = readl(&cru->clksel_con[8]);
+		div = (con & ACLK_BUS_DIV_CON_MASK) >> ACLK_BUS_DIV_CON_SHIFT;
+		parent = rkclk_pll_get_rate(cru, GPLL);
+		break;
+	case HCLK_BUS:
+		con = readl(&cru->clksel_con[8]);
+		div = (con & HCLK_BUS_DIV_CON_MASK) >> HCLK_BUS_DIV_CON_SHIFT;
+		parent = rk3368_bus_get_clk(cru, ACLK_BUS);
+		break;
+	case PCLK_BUS:
+	case PCLK_PWM0:
+	case PCLK_PWM1:
+	case PCLK_I2C0:
+	case PCLK_I2C1:
+		con = readl(&cru->clksel_con[8]);
+		div = (con & PCLK_BUS_DIV_CON_MASK) >> PCLK_BUS_DIV_CON_SHIFT;
+		parent = rk3368_bus_get_clk(cru, ACLK_BUS);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3368_bus_set_clk(struct rk3368_cru *cru,
+				ulong clk_id, ulong hz)
+{
+	int src_clk_div;
+
+	/*
+	 * select gpll as pd_bus bus clock source and
+	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
+	 */
+	switch (clk_id) {
+	case ACLK_BUS:
+		src_clk_div = DIV_ROUND_UP(rkclk_pll_get_rate(cru, GPLL), hz);
+		assert(src_clk_div - 1 < 31);
+		rk_clrsetreg(&cru->clksel_con[8],
+			     CLK_BUS_PLL_SEL_MASK | ACLK_BUS_DIV_CON_MASK,
+			     CLK_BUS_PLL_SEL_GPLL << CLK_BUS_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_BUS_DIV_CON_SHIFT);
+		break;
+	case HCLK_BUS:
+		src_clk_div = DIV_ROUND_UP(rk3368_bus_get_clk(cru,
+							      ACLK_BUS),
+					   hz);
+		assert(src_clk_div - 1 < 3);
+		rk_clrsetreg(&cru->clksel_con[8],
+			     HCLK_BUS_DIV_CON_MASK,
+			     (src_clk_div - 1) << HCLK_BUS_DIV_CON_SHIFT);
+		break;
+	case PCLK_BUS:
+		src_clk_div = DIV_ROUND_UP(rk3368_bus_get_clk(cru,
+							      ACLK_BUS),
+					   hz);
+		assert(src_clk_div - 1 < 3);
+		rk_clrsetreg(&cru->clksel_con[8],
+			     PCLK_BUS_DIV_CON_MASK,
+			     (src_clk_div - 1) << PCLK_BUS_DIV_CON_SHIFT);
+		break;
+	default:
+		printf("do not support this bus freq\n");
+		return -EINVAL;
+	}
+	return rk3368_bus_get_clk(cru, clk_id);
+}
+
+static ulong rk3368_peri_get_clk(struct rk3368_cru *cru, ulong clk_id)
+{
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_PERI:
+		con = readl(&cru->clksel_con[9]);
+		div = (con & ACLK_PERI_DIV_CON_MASK) >> ACLK_PERI_DIV_CON_SHIFT;
+		parent = rkclk_pll_get_rate(cru, GPLL);
+		break;
+	case HCLK_PERI:
+		con = readl(&cru->clksel_con[9]);
+		div = (con & HCLK_PERI_DIV_CON_MASK) >> HCLK_PERI_DIV_CON_SHIFT;
+		parent = rk3368_peri_get_clk(cru, ACLK_PERI);
+		break;
+	case PCLK_PERI:
+	case PCLK_I2C2:
+	case PCLK_I2C3:
+	case PCLK_I2C4:
+	case PCLK_I2C5:
+		con = readl(&cru->clksel_con[9]);
+		div = (con & PCLK_PERI_DIV_CON_MASK) >> PCLK_PERI_DIV_CON_SHIFT;
+		parent = rk3368_peri_get_clk(cru, ACLK_PERI);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3368_peri_set_clk(struct rk3368_cru *cru,
+				 ulong clk_id, ulong hz)
+{
+	int src_clk_div;
+
+	/*
+	 * select gpll as pd_bus bus clock source and
+	 * set up dependent divisors for PCLK/HCLK and ACLK clocks.
+	 */
+	switch (clk_id) {
+	case ACLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rkclk_pll_get_rate(cru, GPLL), hz);
+		assert(src_clk_div - 1 < 31);
+		rk_clrsetreg(&cru->clksel_con[9],
+			     CLK_PERI_PLL_SEL_MASK | ACLK_PERI_DIV_CON_MASK,
+			     CLK_PERI_PLL_SEL_GPLL << CLK_PERI_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << ACLK_PERI_DIV_CON_SHIFT);
+		break;
+	case HCLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rk3368_peri_get_clk(cru,
+							       ACLK_PERI),
+					   hz);
+		assert(src_clk_div - 1 < 3);
+		rk_clrsetreg(&cru->clksel_con[9],
+			     HCLK_PERI_DIV_CON_MASK,
+			     (src_clk_div - 1) << HCLK_PERI_DIV_CON_SHIFT);
+		break;
+	case PCLK_PERI:
+		src_clk_div = DIV_ROUND_UP(rk3368_peri_get_clk(cru,
+							       ACLK_PERI),
+					   hz);
+		assert(src_clk_div - 1 < 3);
+		rk_clrsetreg(&cru->clksel_con[9],
+			     PCLK_PERI_DIV_CON_MASK,
+			     (src_clk_div - 1) << PCLK_PERI_DIV_CON_SHIFT);
+		break;
+	default:
+		printf("do not support this bus freq\n");
+		return -EINVAL;
+	}
+
+	return rk3368_peri_get_clk(cru, clk_id);
+}
+
+#if !defined(CONFIG_SPL_BUILD)
+static ulong rk3368_vop_get_clk(struct rk3368_cru *cru,  int clk_id)
+{
+	u32 div, con, parent, sel;
+
+	switch (clk_id) {
+	case DCLK_VOP:
+		con = readl(&cru->clksel_con[20]);
+		div = con & DCLK_VOP_DIV_MASK;
+		parent = rkclk_pll_get_rate(cru, NPLL);
+		break;
+	case ACLK_VOP:
+		con = readl(&cru->clksel_con[19]);
+		div = con & ACLK_VOP_DIV_MASK;
+		sel =  (con & (ACLK_VOP_PLL_SEL_MASK <<
+			ACLK_VOP_PLL_SEL_SHIFT)) >>
+			ACLK_VOP_PLL_SEL_SHIFT;
+		if (sel == ACLK_VOP_PLL_SEL_CPLL)
+			parent = rkclk_pll_get_rate(cru, CPLL);
+		else if (ACLK_VOP_PLL_SEL_GPLL)
+			parent = rkclk_pll_get_rate(cru, GPLL);
+		else
+			parent = 480000000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3368_vop_set_clk(struct rk3368_cru *cru, int clk_id, uint hz)
+{
+	struct pll_div npll_config = {0};
+	u32 lcdc_div;
+	int ret;
+
+	switch (clk_id) {
+	case DCLK_VOP:
+		if (!(NPLL_HZ % hz)) {
+			rkclk_set_pll(cru, NPLL, rkclk_get_pll_config(NPLL_HZ));
+			lcdc_div = NPLL_HZ / hz;
+		} else {
+			ret = pll_para_config(hz, &npll_config, &lcdc_div);
+			if (ret)
+				return ret;
+
+			rkclk_set_pll(cru, NPLL, &npll_config);
+		}
+		/* vop dclk source clk: npll,dclk_div: 1 */
+		rk_clrsetreg(&cru->clksel_con[20],
+			     (DCLK_VOP_PLL_SEL_MASK << DCLK_VOP_PLL_SEL_SHIFT) |
+			     (DCLK_VOP_DIV_MASK << DCLK_VOP_DIV_SHIFT),
+			     (DCLK_VOP_PLL_SEL_NPLL << DCLK_VOP_PLL_SEL_SHIFT) |
+			     (lcdc_div - 1) << DCLK_VOP_DIV_SHIFT);
+		break;
+	case ACLK_VOP:
+		if ((rkclk_pll_get_rate(cru, CPLL) % hz) == 0) {
+			lcdc_div = rkclk_pll_get_rate(cru, CPLL) / hz;
+			rk_clrsetreg(&cru->clksel_con[19],
+				     (ACLK_VOP_PLL_SEL_MASK <<
+				     ACLK_VOP_PLL_SEL_SHIFT) |
+				     (ACLK_VOP_DIV_MASK <<
+				     ACLK_VOP_DIV_SHIFT),
+				     (ACLK_VOP_PLL_SEL_CPLL <<
+				     ACLK_VOP_PLL_SEL_SHIFT) |
+				     (lcdc_div - 1) <<
+				     ACLK_VOP_DIV_SHIFT);
+		} else {
+			lcdc_div = rkclk_pll_get_rate(cru, GPLL) / hz;
+			rk_clrsetreg(&cru->clksel_con[19],
+				     (ACLK_VOP_PLL_SEL_MASK <<
+				     ACLK_VOP_PLL_SEL_SHIFT) |
+				     (ACLK_VOP_DIV_MASK <<
+				     ACLK_VOP_DIV_SHIFT),
+				     (ACLK_VOP_PLL_SEL_GPLL <<
+				     ACLK_VOP_PLL_SEL_SHIFT) |
+				     (lcdc_div - 1) <<
+				     ACLK_VOP_DIV_SHIFT);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static ulong rk3368_alive_get_clk(struct rk3368_clk_priv *priv)
+{
+	struct rk3368_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	con = readl(&cru->clksel_con[10]);
+	div = (con & PCLK_ALIVE_DIV_CON_MASK) >>
+	      PCLK_ALIVE_DIV_CON_SHIFT;
+	parent = GPLL_HZ;
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3368_crypto_get_rate(struct rk3368_clk_priv *priv)
+{
+	struct rk3368_cru *cru = priv->cru;
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[10]);
+	div = (val & CLK_CRYPTO_DIV_CON_MASK) >> CLK_CRYPTO_DIV_CON_SHIFT;
+
+	return DIV_TO_RATE(rk3368_bus_get_clk(priv->cru, ACLK_BUS), div);
+}
+
+static ulong rk3368_crypto_set_rate(struct rk3368_clk_priv *priv,
+				    uint hz)
+{
+	struct rk3368_cru *cru = priv->cru;
+	int src_clk_div;
+	uint p_rate;
+
+	p_rate = rk3368_bus_get_clk(priv->cru, ACLK_BUS);
+	src_clk_div = DIV_ROUND_UP(p_rate, hz) - 1;
+	assert(src_clk_div < 3);
+
+	rk_clrsetreg(&cru->clksel_con[10],
+		     CLK_CRYPTO_DIV_CON_MASK,
+		     src_clk_div << CLK_CRYPTO_DIV_CON_SHIFT);
+
+	return rk3368_crypto_get_rate(priv);
+}
+#endif
+
+static ulong rk3368_armclk_set_clk(struct rk3368_clk_priv *priv,
+				   int clk_id, ulong hz)
+{
+	struct rk3368_cru *cru = priv->cru;
+	const struct rockchip_cpu_rate_table *rate;
+	struct pll_div pll_config = {0};
+	ulong old_rate;
+	u32 pll_div, pll_id, con_id;
+	int ret;
+
+	rate = rockchip_get_cpu_settings(rk3368_cpu_rates, hz);
+	if (!rate) {
+		printf("%s unsupported rate\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * select apll as cpu/core clock pll source and
+	 * set up dependent divisors for PERI and ACLK clocks.
+	 * core hz : apll = 1:1
+	 */
+
+	ret = pll_para_config(hz, &pll_config, &pll_div);
+	if (ret)
+		return ret;
+
+	if (clk_id == ARMCLKB) {
+		old_rate = rkclk_pll_get_rate(priv->cru, APLLB);
+		pll_id = APLLB;
+		con_id = 0;
+	} else {
+		old_rate = rkclk_pll_get_rate(priv->cru, APLLL);
+		pll_id = APLLL;
+		con_id = 2;
+	}
+
+	if (old_rate > hz) {
+		ret = rkclk_set_pll(priv->cru, pll_id, &pll_config);
+		rk_clrsetreg(&cru->clksel_con[con_id],
+			     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
+			     CORE_CLK_PLL_SEL_APLL << CORE_CLK_PLL_SEL_SHIFT |
+			     0 << CORE_DIV_CON_SHIFT);
+		rk_clrsetreg(&cru->clksel_con[con_id + 1],
+			     CORE_ACLK_DIV_MASK | CORE_DBG_DIV_MASK,
+			     rate->aclk_div << CORE_ACLK_DIV_SHIFT |
+			     rate->pclk_div << CORE_DBG_DIV_SHIFT);
+	} else if (old_rate < hz) {
+		rk_clrsetreg(&cru->clksel_con[con_id],
+			     CORE_CLK_PLL_SEL_MASK | CORE_DIV_CON_MASK,
+			     CORE_CLK_PLL_SEL_APLL << CORE_CLK_PLL_SEL_SHIFT |
+			     0 << CORE_DIV_CON_SHIFT);
+		rk_clrsetreg(&cru->clksel_con[con_id + 1],
+			     CORE_ACLK_DIV_MASK | CORE_DBG_DIV_MASK,
+			     rate->aclk_div << CORE_ACLK_DIV_SHIFT |
+			     rate->pclk_div << CORE_DBG_DIV_SHIFT);
+		ret = rkclk_set_pll(priv->cru, pll_id, &pll_config);
+	}
+
+	return rkclk_pll_get_rate(priv->cru, pll_id);
+}
+
 static ulong rk3368_clk_get_rate(struct clk *clk)
 {
 	struct rk3368_clk_priv *priv = dev_get_priv(clk->dev);
@@ -404,43 +932,115 @@ static ulong rk3368_clk_get_rate(struct clk *clk)
 
 	debug("%s: id %ld\n", __func__, clk->id);
 	switch (clk->id) {
+	case PLL_APLLB:
+	case PLL_APLLL:
+	case PLL_DPLL:
 	case PLL_CPLL:
-		rate = rkclk_pll_get_rate(priv->cru, CPLL);
-		break;
 	case PLL_GPLL:
-		rate = rkclk_pll_get_rate(priv->cru, GPLL);
+	case PLL_NPLL:
+		rate = rkclk_pll_get_rate(priv->cru, clk->id - 1);
+		break;
+	case ARMCLKB:
+		rate = rkclk_pll_get_rate(priv->cru, APLLB);
+		break;
+	case ARMCLKL:
+		rate = rkclk_pll_get_rate(priv->cru, APLLL);
 		break;
 	case SCLK_SPI0 ... SCLK_SPI2:
 		rate = rk3368_spi_get_clk(priv->cru, clk->id);
 		break;
+	case ACLK_BUS:
+	case HCLK_BUS:
+	case PCLK_BUS:
+	case PCLK_PWM0:
+	case PCLK_PWM1:
+	case PCLK_I2C0:
+	case PCLK_I2C1:
+		rate = rk3368_bus_get_clk(priv->cru, clk->id);
+		break;
+	case ACLK_PERI:
+	case HCLK_PERI:
+	case PCLK_PERI:
+	case PCLK_I2C2:
+	case PCLK_I2C3:
+	case PCLK_I2C4:
+	case PCLK_I2C5:
+		rate = rk3368_peri_get_clk(priv->cru, clk->id);
+		break;
 #if !IS_ENABLED(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(MMC_SUPPORT)
 	case HCLK_SDMMC:
 	case HCLK_EMMC:
 		rate = rk3368_mmc_get_clk(priv->cru, clk->id);
 		break;
+#endif
+	case SCLK_SARADC:
+		rate = rk3368_saradc_get_clk(priv->cru);
+		break;
+#if !defined(CONFIG_SPL_BUILD)
+	case ACLK_VOP:
+	case DCLK_VOP:
+		rate =  rk3368_vop_get_clk(priv->cru, clk->id);
+		break;
+	case PCLK_WDT:
+		rate = rk3368_alive_get_clk(priv);
+		break;
+	case SCLK_CRYPTO:
+		rate = rk3368_crypto_get_rate(priv);
+		break;
 #endif
 	default:
 		return -ENOENT;
 	}
-
 	return rate;
 }
 
 static ulong rk3368_clk_set_rate(struct clk *clk, ulong rate)
 {
 	__maybe_unused struct rk3368_clk_priv *priv = dev_get_priv(clk->dev);
+	struct pll_div pll_config = {0};
+	u32 pll_div;
 	ulong ret = 0;
 
-	debug("%s id:%ld rate:%ld\n", __func__, clk->id, rate);
 	switch (clk->id) {
+	case PLL_APLLB:
+	case PLL_APLLL:
+	case PLL_CPLL:
+	case PLL_GPLL:
+	case PLL_NPLL:
+		ret = pll_para_config(rate, &pll_config, &pll_div);
+		if (ret)
+			return ret;
+
+		ret = rkclk_set_pll(priv->cru, clk->id - 1, &pll_config);
+		break;
+	case ARMCLKB:
+		if (priv->armbclk_hz)
+			ret = rk3368_armclk_set_clk(priv, clk->id, rate);
+		priv->armbclk_hz = rate;
+		break;
+	case ARMCLKL:
+		if (priv->armlclk_hz)
+			ret = rk3368_armclk_set_clk(priv, clk->id, rate);
+		priv->armlclk_hz = rate;
+		break;
 	case SCLK_SPI0 ... SCLK_SPI2:
 		ret = rk3368_spi_set_clk(priv->cru, clk->id, rate);
 		break;
 #if IS_ENABLED(CONFIG_TPL_BUILD)
-	case CLK_DDR:
+	case SCLK_DDRCLK:
 		ret = rk3368_ddr_set_clk(priv->cru, rate);
 		break;
 #endif
+	case ACLK_BUS:
+	case HCLK_BUS:
+	case PCLK_BUS:
+		rate = rk3368_bus_set_clk(priv->cru, clk->id, rate);
+		break;
+	case ACLK_PERI:
+	case HCLK_PERI:
+	case PCLK_PERI:
+		rate = rk3368_peri_set_clk(priv->cru, clk->id, rate);
+		break;
 #if !IS_ENABLED(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(MMC_SUPPORT)
 	case HCLK_SDMMC:
 	case HCLK_EMMC:
@@ -450,7 +1050,22 @@ static ulong rk3368_clk_set_rate(struct clk *clk, ulong rate)
 #if CONFIG_IS_ENABLED(GMAC_ROCKCHIP)
 	case SCLK_MAC:
 		/* select the external clock */
-		ret = rk3368_gmac_set_clk(priv->cru, clk->id, rate);
+		ret = rk3368_gmac_set_clk(priv->cru, rate);
+		break;
+#endif
+	case SCLK_SARADC:
+		ret =  rk3368_saradc_set_clk(priv->cru, rate);
+		break;
+#if !defined(CONFIG_SPL_BUILD)
+	case ACLK_VOP:
+	case DCLK_VOP:
+		ret =  rk3368_vop_set_clk(priv->cru, clk->id, rate);
+		break;
+	case ACLK_CCI_PRE:
+		ret =  0;
+		break;
+	case SCLK_CRYPTO:
+		ret = rk3368_crypto_set_rate(priv, rate);
 		break;
 #endif
 	default:
@@ -460,23 +1075,248 @@ static ulong rk3368_clk_set_rate(struct clk *clk, ulong rate)
 	return ret;
 }
 
+static int __maybe_unused rk3368_gmac_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3368_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3368_cru *cru = priv->cru;
+	const char *clock_output_name;
+	int ret;
+
+	/*
+	 * If the requested parent is in the same clock-controller and
+	 * the id is SCLK_MAC ("sclk_mac"), switch to the internal
+	 * clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC)) {
+		debug("%s: switching GAMC to SCLK_MAC\n", __func__);
+		rk_clrreg(&cru->clksel_con[43], GMAC_MUX_SEL_EXTCLK);
+		return 0;
+	}
+
+	/*
+	 * Otherwise, we need to check the clock-output-names of the
+	 * requested parent to see if the requested id is "ext_gmac".
+	 */
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	/* If this is "ext_gmac", switch to the external clock input */
+	if (!strcmp(clock_output_name, "ext_gmac")) {
+		debug("%s: switching GMAC to external clock\n", __func__);
+		rk_setreg(&cru->clksel_con[43], GMAC_MUX_SEL_EXTCLK);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int __maybe_unused rk3368_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	switch (clk->id) {
+	case SCLK_MAC:
+		return rk3368_gmac_set_parent(clk, parent);
+	}
+
+	debug("%s: unsupported clk %ld\n", __func__, clk->id);
+	return -ENOENT;
+}
+
+#define ROCKCHIP_MMC_DELAY_SEL		BIT(10)
+#define ROCKCHIP_MMC_DEGREE_MASK	0x3
+#define ROCKCHIP_MMC_DELAYNUM_OFFSET	2
+#define ROCKCHIP_MMC_DELAYNUM_MASK	(0xff << ROCKCHIP_MMC_DELAYNUM_OFFSET)
+
+#define PSECS_PER_SEC 1000000000000LL
+/*
+ * Each fine delay is between 44ps-77ps. Assume each fine delay is 60ps to
+ * simplify calculations. So 45degs could be anywhere between 33deg and 57.8deg.
+ */
+#define ROCKCHIP_MMC_DELAY_ELEMENT_PSEC 60
+
+int rk3368_mmc_get_phase(struct clk *clk)
+{
+	struct rk3368_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3368_cru *cru = priv->cru;
+	u32 raw_value, delay_num;
+	u16 degrees = 0;
+	ulong rate;
+
+	rate = rk3368_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		raw_value = readl(&cru->emmc_con[1]);
+	else if (clk->id == SCLK_SDMMC_SAMPLE)
+		raw_value = readl(&cru->sdmmc_con[1]);
+	else
+		raw_value = readl(&cru->sdio0_con[1]);
+
+	raw_value >>= 1;
+	degrees = (raw_value & ROCKCHIP_MMC_DEGREE_MASK) * 90;
+
+	if (raw_value & ROCKCHIP_MMC_DELAY_SEL) {
+		/* degrees/delaynum * 10000 */
+		unsigned long factor = (ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10) *
+					36 * (rate / 1000000);
+
+		delay_num = (raw_value & ROCKCHIP_MMC_DELAYNUM_MASK);
+		delay_num >>= ROCKCHIP_MMC_DELAYNUM_OFFSET;
+		degrees += DIV_ROUND_CLOSEST(delay_num * factor, 10000);
+	}
+
+	return degrees % 360;
+}
+
+int rk3368_mmc_set_phase(struct clk *clk, u32 degrees)
+{
+	struct rk3368_clk_priv *priv = dev_get_priv(clk->dev);
+	struct rk3368_cru *cru = priv->cru;
+	u8 nineties, remainder, delay_num;
+	u32 raw_value, delay;
+	ulong rate;
+
+	rate = rk3368_clk_get_rate(clk);
+
+	if (rate < 0)
+		return rate;
+
+	nineties = degrees / 90;
+	remainder = (degrees % 90);
+
+	/*
+	 * Convert to delay; do a little extra work to make sure we
+	 * don't overflow 32-bit / 64-bit numbers.
+	 */
+	delay = 10000000; /* PSECS_PER_SEC / 10000 / 10 */
+	delay *= remainder;
+	delay = DIV_ROUND_CLOSEST(delay, (rate / 1000) * 36 *
+				(ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10));
+
+	delay_num = (u8)min_t(u32, delay, 255);
+
+	raw_value = delay_num ? ROCKCHIP_MMC_DELAY_SEL : 0;
+	raw_value |= delay_num << ROCKCHIP_MMC_DELAYNUM_OFFSET;
+	raw_value |= nineties;
+
+	raw_value <<= 1;
+	if (clk->id == SCLK_EMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->emmc_con[1]);
+	else if (clk->id == SCLK_SDMMC_SAMPLE)
+		writel(raw_value | 0xffff0000, &cru->sdmmc_con[1]);
+	else
+		writel(raw_value | 0xffff0000, &cru->sdio0_con[1]);
+
+	debug("mmc set_phase(%d) delay_nums=%u reg=%#x actual_degrees=%d\n",
+	      degrees, delay_num, raw_value, rk3368_mmc_get_phase(clk));
+
+	return 0;
+}
+
+static int rk3368_clk_get_phase(struct clk *clk)
+{
+	int ret;
+
+	debug("%s %ld\n", __func__, clk->id);
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO0_SAMPLE:
+		ret = rk3368_mmc_get_phase(clk);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
+static int rk3368_clk_set_phase(struct clk *clk, int degrees)
+{
+	int ret;
+
+	debug("%s %ld\n", __func__, clk->id);
+	switch (clk->id) {
+	case SCLK_EMMC_SAMPLE:
+	case SCLK_SDMMC_SAMPLE:
+	case SCLK_SDIO0_SAMPLE:
+		ret = rk3368_mmc_set_phase(clk, degrees);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+}
+
 static struct clk_ops rk3368_clk_ops = {
 	.get_rate = rk3368_clk_get_rate,
 	.set_rate = rk3368_clk_set_rate,
+	.get_phase = rk3368_clk_get_phase,
+	.set_phase = rk3368_clk_set_phase,
+#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
+	.set_parent = rk3368_clk_set_parent,
+#endif
 };
 
+#if IS_ENABLED(CONFIG_SPL_BUILD) || IS_ENABLED(CONFIG_TPL_BUILD)
+static void rkclk_init(struct rk3368_cru *cru)
+{
+	u32 apllb, aplll, dpll, cpll, gpll;
+
+	rkclk_set_pll(cru, APLLB, &apll_b_init_cfg);
+	rkclk_set_pll(cru, APLLL, &apll_l_init_cfg);
+#if !defined(CONFIG_TPL_BUILD)
+	/*
+	 * If we plan to return to the boot ROM, we can't increase the
+	 * GPLL rate from the SPL stage.
+	 */
+	rkclk_set_pll(cru, GPLL, &gpll_init_cfg);
+	rkclk_set_pll(cru, CPLL, &cpll_init_cfg);
+#endif
+rk_clrsetreg(&cru->clksel_con[37],  (1 << 8), 1 << 8);
+	apllb = rkclk_pll_get_rate(cru, APLLB);
+	aplll = rkclk_pll_get_rate(cru, APLLL);
+	dpll = rkclk_pll_get_rate(cru, DPLL);
+	cpll = rkclk_pll_get_rate(cru, CPLL);
+	gpll = rkclk_pll_get_rate(cru, GPLL);
+
+	debug("%s apllb(%d) apll(%d) dpll(%d) cpll(%d) gpll(%d)\n",
+	      __func__, apllb, aplll, dpll, cpll, gpll);
+}
+#endif
+
 static int rk3368_clk_probe(struct udevice *dev)
 {
 	struct rk3368_clk_priv __maybe_unused *priv = dev_get_priv(dev);
+	int ret;
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3368_clk_plat *plat = dev_get_platdata(dev);
 
-	priv->cru = map_sysmem(plat->dtd.reg[1], plat->dtd.reg[3]);
+	priv->cru = map_sysmem(plat->dtd.reg[0], plat->dtd.reg[1]);
 #endif
+	priv->sync_kernel = false;
+	if (!priv->armlclk_enter_hz)
+		priv->armlclk_enter_hz = rkclk_pll_get_rate(priv->cru, APLLL);
+	if (!priv->armbclk_enter_hz)
+		priv->armbclk_enter_hz = rkclk_pll_get_rate(priv->cru, APLLB);
 #if IS_ENABLED(CONFIG_SPL_BUILD) || IS_ENABLED(CONFIG_TPL_BUILD)
 	rkclk_init(priv->cru);
 #endif
-
+	rkclk_set_pll(priv->cru, NPLL, rkclk_get_pll_config(NPLL_HZ));
+	if (!priv->armlclk_init_hz)
+		priv->armlclk_init_hz = rkclk_pll_get_rate(priv->cru, APLLL);
+	if (!priv->armbclk_init_hz)
+		priv->armbclk_init_hz = rkclk_pll_get_rate(priv->cru, APLLB);
+	/* Process 'assigned-{clocks/clock-parents/clock-rates}' properties */
+	ret = clk_set_defaults(dev);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+	else
+		priv->sync_kernel = true;
 	return 0;
 }
 
@@ -485,7 +1325,7 @@ static int rk3368_clk_ofdata_to_platdata(struct udevice *dev)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3368_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk3368_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
 #endif
 
 	return 0;
@@ -494,13 +1334,37 @@ static int rk3368_clk_ofdata_to_platdata(struct udevice *dev)
 static int rk3368_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk3368_sysreset", "reset", &dev);
-	if (ret)
-		error("bind RK3368 reset driver failed: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3368_cru,
+						    glb_srst_fst_val);
+		priv->glb_srst_snd_value = offsetof(struct rk3368_cru,
+						    glb_srst_snd_val);
+		sys_child->priv = priv;
+	}
 
-	return ret;
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3368_cru,
+						    softrst_con[0]);
+		sf_priv->sf_reset_num = 15;
+		sf_child->priv = sf_priv;
+	}
+
+	return 0;
 }
 
 static const struct udevice_id rk3368_clk_ids[] = {
@@ -521,3 +1385,74 @@ U_BOOT_DRIVER(rockchip_rk3368_cru) = {
 	.bind		= rk3368_clk_bind,
 	.probe		= rk3368_clk_probe,
 };
+
+#if !defined(CONFIG_SPL_BUILD)
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev;
+	struct rk3368_clk_priv *priv;
+	const struct rk3368_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk3368_cru),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arml: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armlclk_enter_hz / 1000,
+	       priv->armlclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armlclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	printf("CLK: (%s. armb: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armbclk_enter_hz / 1000,
+	       priv->armbclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armlclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
diff --git a/drivers/clk/rockchip/clk_rk3399.c b/drivers/clk/rockchip/clk_rk3399.c
index 3edafea140..c9852d368c 100644
--- a/drivers/clk/rockchip/clk_rk3399.c
+++ b/drivers/clk/rockchip/clk_rk3399.c
@@ -12,10 +12,11 @@
 #include <errno.h>
 #include <mapmem.h>
 #include <syscon.h>
+#include <bitfield.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3399.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3399.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <dm/lists.h>
 #include <dt-bindings/clock/rk3399-cru.h>
 
@@ -37,6 +38,7 @@ struct pll_div {
 	u32 postdiv1;
 	u32 postdiv2;
 	u32 frac;
+	u32 freq;
 };
 
 #define RATE_TO_DIV(input_rate, output_rate) \
@@ -46,22 +48,49 @@ struct pll_div {
 #define PLL_DIVISORS(hz, _refdiv, _postdiv1, _postdiv2) {\
 	.refdiv = _refdiv,\
 	.fbdiv = (u32)((u64)hz * _refdiv * _postdiv1 * _postdiv2 / OSC_HZ),\
-	.postdiv1 = _postdiv1, .postdiv2 = _postdiv2};
+	.postdiv1 = _postdiv1, .postdiv2 = _postdiv2, .freq = hz};
 
-#if defined(CONFIG_SPL_BUILD)
-static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 2, 2, 1);
-static const struct pll_div cpll_init_cfg = PLL_DIVISORS(CPLL_HZ, 1, 2, 2);
-#else
+#if !defined(CONFIG_SPL_BUILD)
 static const struct pll_div ppll_init_cfg = PLL_DIVISORS(PPLL_HZ, 2, 2, 1);
 #endif
+static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 1, 3, 1);
+static const struct pll_div npll_init_cfg = PLL_DIVISORS(NPLL_HZ, 1, 3, 1);
+static const struct pll_div apll_1600_cfg = PLL_DIVISORS(1600*MHz, 3, 1, 1);
+static const struct pll_div apll_816_cfg = PLL_DIVISORS(816 * MHz, 1, 2, 1);
+static const struct pll_div apll_600_cfg = PLL_DIVISORS(600*MHz, 1, 2, 1);
+
+static const struct pll_div *apll_cfgs[] = {
+	[APLL_1600_MHZ] = &apll_1600_cfg,
+	[APLL_816_MHZ] = &apll_816_cfg,
+	[APLL_600_MHZ] = &apll_600_cfg,
+};
 
-static const struct pll_div apll_l_1600_cfg = PLL_DIVISORS(1600*MHz, 3, 1, 1);
-static const struct pll_div apll_l_600_cfg = PLL_DIVISORS(600*MHz, 1, 2, 1);
+#ifndef CONFIG_SPL_BUILD
+#define RK3399_CLK_DUMP(_id, _name, _iscru)    \
+{                                              \
+	.id = _id,                              \
+	.name = _name,                          \
+	.is_cru = _iscru,                       \
+}
 
-static const struct pll_div *apll_l_cfgs[] = {
-	[APLL_L_1600_MHZ] = &apll_l_1600_cfg,
-	[APLL_L_600_MHZ] = &apll_l_600_cfg,
+static const struct rk3399_clk_info clks_dump[] = {
+	RK3399_CLK_DUMP(PLL_APLLL, "aplll", true),
+	RK3399_CLK_DUMP(PLL_APLLB, "apllb", true),
+	RK3399_CLK_DUMP(PLL_DPLL, "dpll", true),
+	RK3399_CLK_DUMP(PLL_CPLL, "cpll", true),
+	RK3399_CLK_DUMP(PLL_GPLL, "gpll", true),
+	RK3399_CLK_DUMP(PLL_NPLL, "npll", true),
+	RK3399_CLK_DUMP(PLL_VPLL, "vpll", true),
+	RK3399_CLK_DUMP(ACLK_PERIHP, "aclk_perihp", true),
+	RK3399_CLK_DUMP(HCLK_PERIHP, "hclk_perihp", true),
+	RK3399_CLK_DUMP(PCLK_PERIHP, "pclk_perihp", true),
+	RK3399_CLK_DUMP(ACLK_PERILP0, "aclk_perilp0", true),
+	RK3399_CLK_DUMP(HCLK_PERILP0, "hclk_perilp0", true),
+	RK3399_CLK_DUMP(PCLK_PERILP0, "pclk_perilp0", true),
+	RK3399_CLK_DUMP(HCLK_PERILP1, "hclk_perilp1", true),
+	RK3399_CLK_DUMP(PCLK_PERILP1, "pclk_perilp1", true),
 };
+#endif
 
 enum {
 	/* PLL_CON0 */
@@ -112,23 +141,23 @@ enum {
 	/* PMUCRU_CLKSEL_CON3 */
 	CLK_I2C4_DIV_CON_SHIFT		= 0,
 
-	/* CLKSEL_CON0 */
-	ACLKM_CORE_L_DIV_CON_SHIFT	= 8,
-	ACLKM_CORE_L_DIV_CON_MASK	= 0x1f << ACLKM_CORE_L_DIV_CON_SHIFT,
-	CLK_CORE_L_PLL_SEL_SHIFT	= 6,
-	CLK_CORE_L_PLL_SEL_MASK		= 3 << CLK_CORE_L_PLL_SEL_SHIFT,
-	CLK_CORE_L_PLL_SEL_ALPLL	= 0x0,
-	CLK_CORE_L_PLL_SEL_ABPLL	= 0x1,
-	CLK_CORE_L_PLL_SEL_DPLL		= 0x10,
-	CLK_CORE_L_PLL_SEL_GPLL		= 0x11,
-	CLK_CORE_L_DIV_MASK		= 0x1f,
-	CLK_CORE_L_DIV_SHIFT		= 0,
-
-	/* CLKSEL_CON1 */
-	PCLK_DBG_L_DIV_SHIFT		= 0x8,
-	PCLK_DBG_L_DIV_MASK		= 0x1f << PCLK_DBG_L_DIV_SHIFT,
-	ATCLK_CORE_L_DIV_SHIFT		= 0,
-	ATCLK_CORE_L_DIV_MASK		= 0x1f << ATCLK_CORE_L_DIV_SHIFT,
+	/* CLKSEL_CON0 / CLKSEL_CON2 */
+	ACLKM_CORE_DIV_CON_MASK	= 0x1f,
+	ACLKM_CORE_DIV_CON_SHIFT	= 8,
+	CLK_CORE_PLL_SEL_MASK		= 3,
+	CLK_CORE_PLL_SEL_SHIFT		= 6,
+	CLK_CORE_PLL_SEL_ALPLL		= 0x0,
+	CLK_CORE_PLL_SEL_ABPLL		= 0x1,
+	CLK_CORE_PLL_SEL_DPLL		= 0x10,
+	CLK_CORE_PLL_SEL_GPLL		= 0x11,
+	CLK_CORE_DIV_MASK		= 0x1f,
+	CLK_CORE_DIV_SHIFT		= 0,
+
+	/* CLKSEL_CON1 / CLKSEL_CON3 */
+	PCLK_DBG_DIV_MASK		= 0x1f,
+	PCLK_DBG_DIV_SHIFT		= 0x8,
+	ATCLK_CORE_DIV_MASK		= 0x1f,
+	ATCLK_CORE_DIV_SHIFT		= 0,
 
 	/* CLKSEL_CON14 */
 	PCLK_PERIHP_DIV_CON_SHIFT	= 12,
@@ -169,6 +198,15 @@ enum {
 	ACLK_PERILP0_DIV_CON_SHIFT	= 0,
 	ACLK_PERILP0_DIV_CON_MASK	= 0x1f,
 
+	/* CRU_CLK_SEL24_CON */
+	CRYPTO0_PLL_SEL_SHIFT		= 6,
+	CRYPTO0_PLL_SEL_MASK		= 3 << CRYPTO0_PLL_SEL_SHIFT,
+	CRYPTO_PLL_SEL_CPLL		= 0,
+	CRYPTO_PLL_SEL_GPLL,
+	CRYPTO_PLL_SEL_PPLL		= 0,
+	CRYPTO0_DIV_SHIFT		= 0,
+	CRYPTO0_DIV_MASK		= 0x1f << CRYPTO0_DIV_SHIFT,
+
 	/* CLKSEL_CON25 */
 	PCLK_PERILP1_DIV_CON_SHIFT	= 8,
 	PCLK_PERILP1_DIV_CON_MASK	= 0x7 << PCLK_PERILP1_DIV_CON_SHIFT,
@@ -181,7 +219,12 @@ enum {
 
 	/* CLKSEL_CON26 */
 	CLK_SARADC_DIV_CON_SHIFT	= 8,
-	CLK_SARADC_DIV_CON_MASK		= 0xff << CLK_SARADC_DIV_CON_SHIFT,
+	CLK_SARADC_DIV_CON_MASK		= GENMASK(15, 8),
+	CLK_SARADC_DIV_CON_WIDTH	= 8,
+	CRYPTO1_PLL_SEL_SHIFT		= 6,
+	CRYPTO1_PLL_SEL_MASK		= 3 << CRYPTO1_PLL_SEL_SHIFT,
+	CRYPTO1_DIV_SHIFT		= 0,
+	CRYPTO1_DIV_MASK		= 0x1f << CRYPTO1_DIV_SHIFT,
 
 	/* CLKSEL_CON27 */
 	CLK_TSADC_SEL_X24M		= 0x0,
@@ -194,6 +237,7 @@ enum {
 	ACLK_VOP_PLL_SEL_SHIFT		= 6,
 	ACLK_VOP_PLL_SEL_MASK		= 0x3 << ACLK_VOP_PLL_SEL_SHIFT,
 	ACLK_VOP_PLL_SEL_CPLL		= 0x1,
+	ACLK_VOP_PLL_SEL_GPLL		= 0x2,
 	ACLK_VOP_DIV_CON_SHIFT		= 0,
 	ACLK_VOP_DIV_CON_MASK		= 0x1f << ACLK_VOP_DIV_CON_SHIFT,
 
@@ -204,9 +248,14 @@ enum {
 	DCLK_VOP_PLL_SEL_SHIFT          = 8,
 	DCLK_VOP_PLL_SEL_MASK           = 3 << DCLK_VOP_PLL_SEL_SHIFT,
 	DCLK_VOP_PLL_SEL_VPLL           = 0,
+	DCLK_VOP_PLL_SEL_CPLL           = 1,
 	DCLK_VOP_DIV_CON_MASK           = 0xff,
 	DCLK_VOP_DIV_CON_SHIFT          = 0,
 
+	/* CLKSEL_CON57 */
+	PCLK_ALIVE_DIV_CON_SHIFT	= 0,
+	PCLK_ALIVE_DIV_CON_MASK		= 0x1f << PCLK_ALIVE_DIV_CON_SHIFT,
+
 	/* CLKSEL_CON58 */
 	CLK_SPI_PLL_SEL_WIDTH = 1,
 	CLK_SPI_PLL_SEL_MASK = ((1 < CLK_SPI_PLL_SEL_WIDTH) - 1),
@@ -289,6 +338,31 @@ enum {
  * FBDIV = Integer value programmed into feedback divide
  *
  */
+
+static uint32_t rkclk_pll_get_rate(u32 *pll_con)
+{
+	u32 refdiv, fbdiv, postdiv1, postdiv2;
+	u32 con;
+
+	con = readl(&pll_con[3]);
+	switch ((con & PLL_MODE_MASK) >> PLL_MODE_SHIFT) {
+	case PLL_MODE_SLOW:
+		return OSC_HZ;
+	case PLL_MODE_NORM:
+		/* normal mode */
+		con = readl(&pll_con[0]);
+		fbdiv = (con & PLL_FBDIV_MASK) >> PLL_FBDIV_SHIFT;
+		con = readl(&pll_con[1]);
+		postdiv1 = (con & PLL_POSTDIV1_MASK) >> PLL_POSTDIV1_SHIFT;
+		postdiv2 = (con & PLL_POSTDIV2_MASK) >> PLL_POSTDIV2_SHIFT;
+		refdiv = (con & PLL_REFDIV_MASK) >> PLL_REFDIV_SHIFT;
+		return (24 * fbdiv / (refdiv * postdiv1 * postdiv2)) * 1000000;
+	case PLL_MODE_DEEP:
+	default:
+		return 32768;
+	}
+}
+
 static void rkclk_set_pll(u32 *pll_con, const struct pll_div *div)
 {
 	/* All 8 PLLs have same VCO and output frequency range restrictions. */
@@ -332,6 +406,42 @@ static void rkclk_set_pll(u32 *pll_con, const struct pll_div *div)
 		     PLL_MODE_NORM << PLL_MODE_SHIFT);
 }
 
+static ulong rk3399_pll_get_rate(struct rk3399_clk_priv *priv,
+				 enum rk3399_pll_id pll_id)
+{
+	struct rk3399_cru *cru = priv->cru;
+	u32 *pll_con;
+
+	switch (pll_id) {
+	case PLL_APLLL:
+		pll_con = &cru->apll_l_con[0];
+		break;
+	case PLL_APLLB:
+		pll_con = &cru->apll_b_con[0];
+		break;
+	case PLL_DPLL:
+		pll_con = &cru->dpll_con[0];
+		break;
+	case PLL_CPLL:
+		pll_con = &cru->cpll_con[0];
+		break;
+	case PLL_GPLL:
+		pll_con = &cru->gpll_con[0];
+		break;
+	case PLL_NPLL:
+		pll_con = &cru->npll_con[0];
+		break;
+	case PLL_VPLL:
+		pll_con = &cru->vpll_con[0];
+		break;
+	default:
+		pll_con = &cru->vpll_con[0];
+		break;
+	}
+
+	return rkclk_pll_get_rate(pll_con);
+}
+
 static int pll_para_config(u32 freq_hz, struct pll_div *div)
 {
 	u32 ref_khz = OSC_HZ / KHz, refdiv, fbdiv = 0;
@@ -396,116 +506,56 @@ static int pll_para_config(u32 freq_hz, struct pll_div *div)
 	return 0;
 }
 
-#ifdef CONFIG_SPL_BUILD
-static void rkclk_init(struct rk3399_cru *cru)
-{
-	u32 aclk_div;
-	u32 hclk_div;
-	u32 pclk_div;
-
-	/*
-	 * some cru registers changed by bootrom, we'd better reset them to
-	 * reset/default values described in TRM to avoid confusion in kernel.
-	 * Please consider these three lines as a fix of bootrom bug.
-	 */
-	rk_clrsetreg(&cru->clksel_con[12], 0xffff, 0x4101);
-	rk_clrsetreg(&cru->clksel_con[19], 0xffff, 0x033f);
-	rk_clrsetreg(&cru->clksel_con[56], 0x0003, 0x0003);
-
-	/* configure gpll cpll */
-	rkclk_set_pll(&cru->gpll_con[0], &gpll_init_cfg);
-	rkclk_set_pll(&cru->cpll_con[0], &cpll_init_cfg);
-
-	/* configure perihp aclk, hclk, pclk */
-	aclk_div = GPLL_HZ / PERIHP_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PERIHP_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
-
-	hclk_div = PERIHP_ACLK_HZ / PERIHP_HCLK_HZ - 1;
-	assert((hclk_div + 1) * PERIHP_HCLK_HZ ==
-	       PERIHP_ACLK_HZ && (hclk_div < 0x4));
-
-	pclk_div = PERIHP_ACLK_HZ / PERIHP_PCLK_HZ - 1;
-	assert((pclk_div + 1) * PERIHP_PCLK_HZ ==
-	       PERIHP_ACLK_HZ && (pclk_div < 0x7));
-
-	rk_clrsetreg(&cru->clksel_con[14],
-		     PCLK_PERIHP_DIV_CON_MASK | HCLK_PERIHP_DIV_CON_MASK |
-		     ACLK_PERIHP_PLL_SEL_MASK | ACLK_PERIHP_DIV_CON_MASK,
-		     pclk_div << PCLK_PERIHP_DIV_CON_SHIFT |
-		     hclk_div << HCLK_PERIHP_DIV_CON_SHIFT |
-		     ACLK_PERIHP_PLL_SEL_GPLL << ACLK_PERIHP_PLL_SEL_SHIFT |
-		     aclk_div << ACLK_PERIHP_DIV_CON_SHIFT);
-
-	/* configure perilp0 aclk, hclk, pclk */
-	aclk_div = GPLL_HZ / PERILP0_ACLK_HZ - 1;
-	assert((aclk_div + 1) * PERILP0_ACLK_HZ == GPLL_HZ && aclk_div < 0x1f);
-
-	hclk_div = PERILP0_ACLK_HZ / PERILP0_HCLK_HZ - 1;
-	assert((hclk_div + 1) * PERILP0_HCLK_HZ ==
-	       PERILP0_ACLK_HZ && (hclk_div < 0x4));
-
-	pclk_div = PERILP0_ACLK_HZ / PERILP0_PCLK_HZ - 1;
-	assert((pclk_div + 1) * PERILP0_PCLK_HZ ==
-	       PERILP0_ACLK_HZ && (pclk_div < 0x7));
-
-	rk_clrsetreg(&cru->clksel_con[23],
-		     PCLK_PERILP0_DIV_CON_MASK | HCLK_PERILP0_DIV_CON_MASK |
-		     ACLK_PERILP0_PLL_SEL_MASK | ACLK_PERILP0_DIV_CON_MASK,
-		     pclk_div << PCLK_PERILP0_DIV_CON_SHIFT |
-		     hclk_div << HCLK_PERILP0_DIV_CON_SHIFT |
-		     ACLK_PERILP0_PLL_SEL_GPLL << ACLK_PERILP0_PLL_SEL_SHIFT |
-		     aclk_div << ACLK_PERILP0_DIV_CON_SHIFT);
-
-	/* perilp1 hclk select gpll as source */
-	hclk_div = GPLL_HZ / PERILP1_HCLK_HZ - 1;
-	assert((hclk_div + 1) * PERILP1_HCLK_HZ ==
-	       GPLL_HZ && (hclk_div < 0x1f));
-
-	pclk_div = PERILP1_HCLK_HZ / PERILP1_HCLK_HZ - 1;
-	assert((pclk_div + 1) * PERILP1_HCLK_HZ ==
-	       PERILP1_HCLK_HZ && (hclk_div < 0x7));
-
-	rk_clrsetreg(&cru->clksel_con[25],
-		     PCLK_PERILP1_DIV_CON_MASK | HCLK_PERILP1_DIV_CON_MASK |
-		     HCLK_PERILP1_PLL_SEL_MASK,
-		     pclk_div << PCLK_PERILP1_DIV_CON_SHIFT |
-		     hclk_div << HCLK_PERILP1_DIV_CON_SHIFT |
-		     HCLK_PERILP1_PLL_SEL_GPLL << HCLK_PERILP1_PLL_SEL_SHIFT);
-}
-#endif
-
 void rk3399_configure_cpu(struct rk3399_cru *cru,
-			  enum apll_l_frequencies apll_l_freq)
+			  enum apll_frequencies freq,
+			  enum cpu_cluster cluster)
 {
 	u32 aclkm_div;
 	u32 pclk_dbg_div;
-	u32 atclk_div;
+	u32 atclk_div, apll_hz;
+	int con_base, parent;
+	u32 *pll_con;
+
+	switch (cluster) {
+	case CPU_CLUSTER_LITTLE:
+		con_base = 0;
+		parent = CLK_CORE_PLL_SEL_ALPLL;
+		pll_con = &cru->apll_l_con[0];
+		break;
+	case CPU_CLUSTER_BIG:
+	default:
+		con_base = 2;
+		parent = CLK_CORE_PLL_SEL_ABPLL;
+		pll_con = &cru->apll_b_con[0];
+		break;
+	}
 
-	rkclk_set_pll(&cru->apll_l_con[0], apll_l_cfgs[apll_l_freq]);
+	apll_hz = apll_cfgs[freq]->freq;
+	rkclk_set_pll(pll_con, apll_cfgs[freq]);
 
-	aclkm_div = APLL_HZ / ACLKM_CORE_HZ - 1;
-	assert((aclkm_div + 1) * ACLKM_CORE_HZ == APLL_HZ &&
+	aclkm_div = apll_hz / ACLKM_CORE_HZ - 1;
+	assert((aclkm_div + 1) * ACLKM_CORE_HZ <= apll_hz &&
 	       aclkm_div < 0x1f);
 
-	pclk_dbg_div = APLL_HZ / PCLK_DBG_HZ - 1;
-	assert((pclk_dbg_div + 1) * PCLK_DBG_HZ == APLL_HZ &&
+	pclk_dbg_div = apll_hz / PCLK_DBG_HZ - 1;
+	assert((pclk_dbg_div + 1) * PCLK_DBG_HZ <= apll_hz &&
 	       pclk_dbg_div < 0x1f);
 
-	atclk_div = APLL_HZ / ATCLK_CORE_HZ - 1;
-	assert((atclk_div + 1) * ATCLK_CORE_HZ == APLL_HZ &&
+	atclk_div = apll_hz / ATCLK_CORE_HZ - 1;
+	assert((atclk_div + 1) * ATCLK_CORE_HZ <= apll_hz &&
 	       atclk_div < 0x1f);
 
-	rk_clrsetreg(&cru->clksel_con[0],
-		     ACLKM_CORE_L_DIV_CON_MASK | CLK_CORE_L_PLL_SEL_MASK |
-		     CLK_CORE_L_DIV_MASK,
-		     aclkm_div << ACLKM_CORE_L_DIV_CON_SHIFT |
-		     CLK_CORE_L_PLL_SEL_ALPLL << CLK_CORE_L_PLL_SEL_SHIFT |
-		     0 << CLK_CORE_L_DIV_SHIFT);
-
-	rk_clrsetreg(&cru->clksel_con[1],
-		     PCLK_DBG_L_DIV_MASK | ATCLK_CORE_L_DIV_MASK,
-		     pclk_dbg_div << PCLK_DBG_L_DIV_SHIFT |
-		     atclk_div << ATCLK_CORE_L_DIV_SHIFT);
+	rk_clrsetreg(&cru->clksel_con[con_base],
+		     ACLKM_CORE_DIV_CON_MASK | CLK_CORE_PLL_SEL_MASK |
+		     CLK_CORE_DIV_MASK,
+		     aclkm_div << ACLKM_CORE_DIV_CON_SHIFT |
+		     parent << CLK_CORE_PLL_SEL_SHIFT |
+		     0 << CLK_CORE_DIV_SHIFT);
+
+	rk_clrsetreg(&cru->clksel_con[con_base + 1],
+		     PCLK_DBG_DIV_MASK | ATCLK_CORE_DIV_MASK,
+		     pclk_dbg_div << PCLK_DBG_DIV_SHIFT |
+		     atclk_div << ATCLK_CORE_DIV_SHIFT);
 }
 #define I2C_CLK_REG_MASK(bus) \
 			(I2C_DIV_CON_MASK << \
@@ -574,7 +624,7 @@ static ulong rk3399_i2c_set_clk(struct rk3399_cru *cru, ulong clk_id, uint hz)
 
 	/* i2c0,4,8 src clock from ppll, i2c1,2,3,5,6,7 src clock from gpll*/
 	src_clk_div = GPLL_HZ / hz;
-	assert(src_clk_div - 1 < 127);
+	assert(src_clk_div - 1 <= 127);
 
 	switch (clk_id) {
 	case SCLK_I2C1:
@@ -645,11 +695,6 @@ static const struct spi_clkreg spi_clkregs[] = {
 		.sel_shift = CLK_SPI5_PLL_SEL_SHIFT, },
 };
 
-static inline u32 extract_bits(u32 val, unsigned width, unsigned shift)
-{
-	return (val >> shift) & ((1 << width) - 1);
-}
-
 static ulong rk3399_spi_get_clk(struct rk3399_cru *cru, ulong clk_id)
 {
 	const struct spi_clkreg *spiclk = NULL;
@@ -661,12 +706,13 @@ static ulong rk3399_spi_get_clk(struct rk3399_cru *cru, ulong clk_id)
 		break;
 
 	default:
-		error("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
+		pr_err("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
 		return -EINVAL;
 	}
 
 	val = readl(&cru->clksel_con[spiclk->reg]);
-	div = extract_bits(val, CLK_SPI_PLL_DIV_CON_WIDTH, spiclk->div_shift);
+	div = bitfield_extract(val, spiclk->div_shift,
+			       CLK_SPI_PLL_DIV_CON_WIDTH);
 
 	return DIV_TO_RATE(GPLL_HZ, div);
 }
@@ -685,7 +731,7 @@ static ulong rk3399_spi_set_clk(struct rk3399_cru *cru, ulong clk_id, uint hz)
 		break;
 
 	default:
-		error("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
+		pr_err("%s: SPI clk-id %ld not supported\n", __func__, clk_id);
 		return -EINVAL;
 	}
 
@@ -698,12 +744,14 @@ static ulong rk3399_spi_set_clk(struct rk3399_cru *cru, ulong clk_id, uint hz)
 	return rk3399_spi_get_clk(cru, clk_id);
 }
 
+#define RK3399_LIMIT_PLL_ACLK_VOP	(400 * 1000000)
+
 static ulong rk3399_vop_set_clk(struct rk3399_cru *cru, ulong clk_id, u32 hz)
 {
-	struct pll_div vpll_config = {0};
-	int aclk_vop = 198*MHz;
+	struct pll_div vpll_config = {0}, cpll_config = {0};
+	int aclk_vop = RK3399_LIMIT_PLL_ACLK_VOP;
 	void *aclkreg_addr, *dclkreg_addr;
-	u32 div;
+	u32 div = 1;
 
 	switch (clk_id) {
 	case DCLK_VOP0:
@@ -718,25 +766,27 @@ static ulong rk3399_vop_set_clk(struct rk3399_cru *cru, ulong clk_id, u32 hz)
 		return -EINVAL;
 	}
 	/* vop aclk source clk: cpll */
-	div = CPLL_HZ / aclk_vop;
-	assert(div - 1 < 32);
+	div = GPLL_HZ / aclk_vop;
+	assert(div - 1 <= 31);
 
 	rk_clrsetreg(aclkreg_addr,
 		     ACLK_VOP_PLL_SEL_MASK | ACLK_VOP_DIV_CON_MASK,
-		     ACLK_VOP_PLL_SEL_CPLL << ACLK_VOP_PLL_SEL_SHIFT |
+		     ACLK_VOP_PLL_SEL_GPLL << ACLK_VOP_PLL_SEL_SHIFT |
 		     (div - 1) << ACLK_VOP_DIV_CON_SHIFT);
 
-	/* vop dclk source from vpll, and equals to vpll(means div == 1) */
-	if (pll_para_config(hz, &vpll_config))
-		return -1;
-
-	rkclk_set_pll(&cru->vpll_con[0], &vpll_config);
+	if (readl(dclkreg_addr) & DCLK_VOP_PLL_SEL_MASK) {
+		if (pll_para_config(hz, &cpll_config))
+			return -1;
+		rkclk_set_pll(&cru->cpll_con[0], &cpll_config);
+	} else {
+		if (pll_para_config(hz, &vpll_config))
+			return -1;
+		rkclk_set_pll(&cru->vpll_con[0], &vpll_config);
+	}
 
 	rk_clrsetreg(dclkreg_addr,
-		     DCLK_VOP_DCLK_SEL_MASK | DCLK_VOP_PLL_SEL_MASK|
-		     DCLK_VOP_DIV_CON_MASK,
+		     DCLK_VOP_DCLK_SEL_MASK | DCLK_VOP_DIV_CON_MASK,
 		     DCLK_VOP_DCLK_SEL_DIVOUT << DCLK_VOP_DCLK_SEL_SHIFT |
-		     DCLK_VOP_PLL_SEL_VPLL << DCLK_VOP_PLL_SEL_SHIFT |
 		     (1 - 1) << DCLK_VOP_DIV_CON_SHIFT);
 
 	return hz;
@@ -754,7 +804,7 @@ static ulong rk3399_mmc_get_clk(struct rk3399_cru *cru, uint clk_id)
 		div = 2;
 		break;
 	case SCLK_EMMC:
-		con = readl(&cru->clksel_con[21]);
+		con = readl(&cru->clksel_con[22]);
 		div = 1;
 		break;
 	default:
@@ -809,12 +859,20 @@ static ulong rk3399_mmc_set_clk(struct rk3399_cru *cru,
 
 		/* Select clk_emmc source from GPLL too */
 		src_clk_div = DIV_ROUND_UP(GPLL_HZ, set_rate);
-		assert(src_clk_div - 1 < 128);
-
-		rk_clrsetreg(&cru->clksel_con[22],
-			     CLK_EMMC_PLL_MASK | CLK_EMMC_DIV_CON_MASK,
-			     CLK_EMMC_PLL_SEL_GPLL << CLK_EMMC_PLL_SHIFT |
-			     (src_clk_div - 1) << CLK_EMMC_DIV_CON_SHIFT);
+		if (src_clk_div > 128) {
+			/* use 24MHz source for 400KHz clock */
+			src_clk_div = DIV_ROUND_UP(OSC_HZ, set_rate);
+			assert(src_clk_div - 1 < 128);
+			rk_clrsetreg(&cru->clksel_con[22],
+				     CLK_EMMC_PLL_MASK | CLK_EMMC_DIV_CON_MASK,
+				     CLK_EMMC_PLL_SEL_24M << CLK_EMMC_PLL_SHIFT |
+				     (src_clk_div - 1) << CLK_EMMC_DIV_CON_SHIFT);
+		} else {
+			rk_clrsetreg(&cru->clksel_con[22],
+				     CLK_EMMC_PLL_MASK | CLK_EMMC_DIV_CON_MASK,
+				     CLK_EMMC_PLL_SEL_GPLL << CLK_EMMC_PLL_SHIFT |
+				     (src_clk_div - 1) << CLK_EMMC_DIV_CON_SHIFT);
+		}
 		break;
 	default:
 		return -EINVAL;
@@ -822,6 +880,30 @@ static ulong rk3399_mmc_set_clk(struct rk3399_cru *cru,
 	return rk3399_mmc_get_clk(cru, clk_id);
 }
 
+static ulong rk3399_gmac_set_clk(struct rk3399_cru *cru, ulong rate)
+{
+	ulong ret;
+
+	/*
+	 * The RGMII CLK can be derived either from an external "clkin"
+	 * or can be generated from internally by a divider from SCLK_MAC.
+	 */
+	if (readl(&cru->clksel_con[19]) & BIT(4)) {
+		/* An external clock will always generate the right rate... */
+		ret = rate;
+	} else {
+		/*
+		 * No platform uses an internal clock to date.
+		 * Implement this once it becomes necessary and print an error
+		 * if someone tries to use it (while it remains unimplemented).
+		 */
+		pr_err("%s: internal clock is UNIMPLEMENTED\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
 #define PMUSGRF_DDR_RGN_CON16 0xff330040
 static ulong rk3399_ddr_set_clk(struct rk3399_cru *cru,
 				ulong set_rate)
@@ -833,41 +915,240 @@ static ulong rk3399_ddr_set_clk(struct rk3399_cru *cru,
 
 	/*  clk_ddrc == DPLL = 24MHz / refdiv * fbdiv / postdiv1 / postdiv2 */
 	switch (set_rate) {
-	case 200*MHz:
+	case 50 * MHz:
+		dpll_cfg = (struct pll_div)
+		{.refdiv = 1, .fbdiv = 12, .postdiv1 = 3, .postdiv2 = 2};
+		break;
+	case 200 * MHz:
 		dpll_cfg = (struct pll_div)
 		{.refdiv = 1, .fbdiv = 50, .postdiv1 = 6, .postdiv2 = 1};
 		break;
-	case 300*MHz:
+	case 300 * MHz:
 		dpll_cfg = (struct pll_div)
 		{.refdiv = 2, .fbdiv = 100, .postdiv1 = 4, .postdiv2 = 1};
 		break;
-	case 666*MHz:
+	case 400 * MHz:
+		dpll_cfg = (struct pll_div)
+		{.refdiv = 1, .fbdiv = 50, .postdiv1 = 3, .postdiv2 = 1};
+		break;
+	case 666 * MHz:
 		dpll_cfg = (struct pll_div)
 		{.refdiv = 2, .fbdiv = 111, .postdiv1 = 2, .postdiv2 = 1};
 		break;
-	case 800*MHz:
+	case 800 * MHz:
 		dpll_cfg = (struct pll_div)
 		{.refdiv = 1, .fbdiv = 100, .postdiv1 = 3, .postdiv2 = 1};
 		break;
-	case 933*MHz:
+	case 933 * MHz:
 		dpll_cfg = (struct pll_div)
 		{.refdiv = 1, .fbdiv = 116, .postdiv1 = 3, .postdiv2 = 1};
 		break;
 	default:
-		error("Unsupported SDRAM frequency!,%ld\n", set_rate);
+		pr_err("Unsupported SDRAM frequency!,%ld\n", set_rate);
 	}
 	rkclk_set_pll(&cru->dpll_con[0], &dpll_cfg);
 
 	return set_rate;
 }
+
+static ulong rk3399_saradc_get_clk(struct rk3399_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[26]);
+	div = bitfield_extract(val, CLK_SARADC_DIV_CON_SHIFT,
+			       CLK_SARADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3399_saradc_set_clk(struct rk3399_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div <= 255);
+
+	rk_clrsetreg(&cru->clksel_con[26],
+		     CLK_SARADC_DIV_CON_MASK,
+		     src_clk_div << CLK_SARADC_DIV_CON_SHIFT);
+
+	return rk3399_saradc_get_clk(cru);
+}
+
+static ulong rk3399_tsadc_get_clk(struct rk3399_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[27]);
+	div = bitfield_extract(val, CLK_TSADC_SEL_SHIFT,
+			       10);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3399_tsadc_set_clk(struct rk3399_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div <= 255);
+
+	rk_clrsetreg(&cru->clksel_con[27],
+		     CLK_TSADC_DIV_CON_MASK | CLK_TSADC_SEL_MASK,
+		     (CLK_TSADC_SEL_X24M << CLK_TSADC_SEL_SHIFT) |
+		     (src_clk_div << CLK_TSADC_DIV_CON_SHIFT));
+
+	return rk3399_tsadc_get_clk(cru);
+}
+
+static ulong rk3399_crypto_get_clk(struct rk3399_clk_priv *priv, ulong clk_id)
+{
+	struct rk3399_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case SCLK_CRYPTO0:
+		con = readl(&cru->clksel_con[24]);
+		div = (con & CRYPTO0_DIV_MASK) >> CRYPTO0_DIV_SHIFT;
+		parent = GPLL_HZ;
+		break;
+	case SCLK_CRYPTO1:
+		con = readl(&cru->clksel_con[26]);
+		div = (con & CRYPTO1_DIV_MASK) >> CRYPTO1_DIV_SHIFT;
+		parent = GPLL_HZ;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3399_crypto_set_clk(struct rk3399_clk_priv *priv, ulong clk_id,
+				   ulong hz)
+{
+	struct rk3399_cru *cru = priv->cru;
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(GPLL_HZ, hz);
+	assert(src_clk_div - 1 <= 31);
+
+	/*
+	 * select gpll as crypto clock source and
+	 * set up dependent divisors for crypto clocks.
+	 */
+	switch (clk_id) {
+	case SCLK_CRYPTO0:
+		rk_clrsetreg(&cru->clksel_con[24],
+			     CRYPTO0_PLL_SEL_MASK | CRYPTO0_DIV_MASK,
+			     CRYPTO_PLL_SEL_GPLL << CRYPTO0_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << CRYPTO0_DIV_SHIFT);
+		break;
+	case SCLK_CRYPTO1:
+		rk_clrsetreg(&cru->clksel_con[26],
+			     CRYPTO1_PLL_SEL_MASK | CRYPTO1_DIV_MASK,
+			     CRYPTO_PLL_SEL_GPLL << CRYPTO1_PLL_SEL_SHIFT |
+			     (src_clk_div - 1) << CRYPTO1_DIV_SHIFT);
+		break;
+	default:
+		printf("do not support this peri freq\n");
+		return -EINVAL;
+	}
+
+	return rk3399_crypto_get_clk(priv, clk_id);
+}
+
+#ifndef CONFIG_SPL_BUILD
+static ulong rk3399_peri_get_clk(struct rk3399_clk_priv *priv, ulong clk_id)
+{
+	struct rk3399_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	switch (clk_id) {
+	case ACLK_PERIHP:
+		con = readl(&cru->clksel_con[14]);
+		div = (con & ACLK_PERIHP_DIV_CON_MASK) >>
+		      ACLK_PERIHP_DIV_CON_SHIFT;
+		parent = GPLL_HZ;
+		break;
+	case PCLK_PERIHP:
+		con = readl(&cru->clksel_con[14]);
+		div = (con & PCLK_PERIHP_DIV_CON_MASK) >>
+		      PCLK_PERIHP_DIV_CON_SHIFT;
+		parent = rk3399_peri_get_clk(priv, ACLK_PERIHP);
+		break;
+	case HCLK_PERIHP:
+		con = readl(&cru->clksel_con[14]);
+		div = (con & HCLK_PERIHP_DIV_CON_MASK) >>
+		      HCLK_PERIHP_DIV_CON_SHIFT;
+		parent = rk3399_peri_get_clk(priv, ACLK_PERIHP);
+		break;
+	case ACLK_PERILP0:
+		con = readl(&cru->clksel_con[23]);
+		div = (con & ACLK_PERILP0_DIV_CON_MASK) >>
+		      ACLK_PERILP0_DIV_CON_SHIFT;
+		parent = GPLL_HZ;
+		break;
+	case HCLK_PERILP0:
+		con = readl(&cru->clksel_con[23]);
+		div = (con & HCLK_PERILP0_DIV_CON_MASK) >>
+		      HCLK_PERILP0_DIV_CON_SHIFT;
+		parent = rk3399_peri_get_clk(priv, ACLK_PERILP0);
+		break;
+	case PCLK_PERILP0:
+		con = readl(&cru->clksel_con[23]);
+		div = (con & PCLK_PERILP0_DIV_CON_MASK) >>
+		      PCLK_PERILP0_DIV_CON_SHIFT;
+		parent = rk3399_peri_get_clk(priv, ACLK_PERILP0);
+		break;
+	case HCLK_PERILP1:
+		con = readl(&cru->clksel_con[25]);
+		div = (con & HCLK_PERILP1_DIV_CON_MASK) >>
+		      HCLK_PERILP1_DIV_CON_SHIFT;
+		parent = GPLL_HZ;
+		break;
+	case PCLK_PERILP1:
+		con = readl(&cru->clksel_con[25]);
+		div = (con & PCLK_PERILP1_DIV_CON_MASK) >>
+		      PCLK_PERILP1_DIV_CON_SHIFT;
+		parent = rk3399_peri_get_clk(priv, HCLK_PERILP1);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3399_alive_get_clk(struct rk3399_clk_priv *priv)
+{
+	struct rk3399_cru *cru = priv->cru;
+	u32 div, con, parent;
+
+	con = readl(&cru->clksel_con[57]);
+	div = (con & PCLK_ALIVE_DIV_CON_MASK) >>
+	      PCLK_ALIVE_DIV_CON_SHIFT;
+	parent = GPLL_HZ;
+	return DIV_TO_RATE(parent, div);
+}
+#endif
+
 static ulong rk3399_clk_get_rate(struct clk *clk)
 {
 	struct rk3399_clk_priv *priv = dev_get_priv(clk->dev);
 	ulong rate = 0;
 
 	switch (clk->id) {
-	case 0 ... 63:
-		return 0;
+	case PLL_APLLL:
+	case PLL_APLLB:
+	case PLL_DPLL:
+	case PLL_CPLL:
+	case PLL_GPLL:
+	case PLL_NPLL:
+	case PLL_VPLL:
+		rate = rk3399_pll_get_rate(priv, clk->id);
+		break;
 	case HCLK_SDMMC:
 	case SCLK_SDMMC:
 	case SCLK_EMMC:
@@ -885,7 +1166,9 @@ static ulong rk3399_clk_get_rate(struct clk *clk)
 		rate = rk3399_spi_get_clk(priv->cru, clk->id);
 		break;
 	case SCLK_UART0:
+	case SCLK_UART1:
 	case SCLK_UART2:
+	case SCLK_UART3:
 		return 24000000;
 		break;
 	case PCLK_HDMI_CTRL:
@@ -895,6 +1178,32 @@ static ulong rk3399_clk_get_rate(struct clk *clk)
 		break;
 	case PCLK_EFUSE1024NS:
 		break;
+	case SCLK_SARADC:
+		rate = rk3399_saradc_get_clk(priv->cru);
+		break;
+	case SCLK_TSADC:
+		rate = rk3399_tsadc_get_clk(priv->cru);
+		break;
+	case SCLK_CRYPTO0:
+	case SCLK_CRYPTO1:
+		rate = rk3399_crypto_get_clk(priv, clk->id);
+		break;
+#ifndef CONFIG_SPL_BUILD
+	case ACLK_PERIHP:
+	case HCLK_PERIHP:
+	case PCLK_PERIHP:
+	case ACLK_PERILP0:
+	case HCLK_PERILP0:
+	case PCLK_PERILP0:
+	case HCLK_PERILP1:
+	case PCLK_PERILP1:
+		rate = rk3399_peri_get_clk(priv, clk->id);
+		break;
+	case PCLK_ALIVE:
+	case PCLK_WDT:
+		rate = rk3399_alive_get_clk(priv);
+		break;
+#endif
 	default:
 		return -ENOENT;
 	}
@@ -910,14 +1219,31 @@ static ulong rk3399_clk_set_rate(struct clk *clk, ulong rate)
 	switch (clk->id) {
 	case 0 ... 63:
 		return 0;
+
+	case ACLK_PERIHP:
+	case HCLK_PERIHP:
+	case PCLK_PERIHP:
+		return 0;
+
+	case ACLK_PERILP0:
+	case HCLK_PERILP0:
+	case PCLK_PERILP0:
+		return 0;
+
+	case ACLK_CCI:
+		return 0;
+
+	case HCLK_PERILP1:
+	case PCLK_PERILP1:
+		return 0;
+
 	case HCLK_SDMMC:
 	case SCLK_SDMMC:
 	case SCLK_EMMC:
 		ret = rk3399_mmc_set_clk(priv->cru, clk->id, rate);
 		break;
 	case SCLK_MAC:
-		/* nothing to do, as this is an external clock */
-		ret = rate;
+		ret = rk3399_gmac_set_clk(priv->cru, rate);
 		break;
 	case SCLK_I2C1:
 	case SCLK_I2C2:
@@ -943,6 +1269,16 @@ static ulong rk3399_clk_set_rate(struct clk *clk, ulong rate)
 		break;
 	case PCLK_EFUSE1024NS:
 		break;
+	case SCLK_SARADC:
+		ret = rk3399_saradc_set_clk(priv->cru, rate);
+		break;
+	case SCLK_TSADC:
+		ret = rk3399_tsadc_set_clk(priv->cru, rate);
+		break;
+	case SCLK_CRYPTO0:
+	case SCLK_CRYPTO1:
+		ret = rk3399_crypto_set_clk(priv, clk->id, rate);
+		break;
 	default:
 		return -ENOENT;
 	}
@@ -950,23 +1286,244 @@ static ulong rk3399_clk_set_rate(struct clk *clk, ulong rate)
 	return ret;
 }
 
+static int __maybe_unused rk3399_gmac_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct rk3399_clk_priv *priv = dev_get_priv(clk->dev);
+	const char *clock_output_name;
+	int ret;
+
+	/*
+	 * If the requested parent is in the same clock-controller and
+	 * the id is SCLK_MAC ("clk_gmac"), switch to the internal clock.
+	 */
+	if ((parent->dev == clk->dev) && (parent->id == SCLK_MAC)) {
+		debug("%s: switching RGMII to SCLK_MAC\n", __func__);
+		rk_clrreg(&priv->cru->clksel_con[19], BIT(4));
+		return 0;
+	}
+
+	/*
+	 * Otherwise, we need to check the clock-output-names of the
+	 * requested parent to see if the requested id is "clkin_gmac".
+	 */
+	ret = dev_read_string_index(parent->dev, "clock-output-names",
+				    parent->id, &clock_output_name);
+	if (ret < 0)
+		return -ENODATA;
+
+	/* If this is "clkin_gmac", switch to the external clock input */
+	if (!strcmp(clock_output_name, "clkin_gmac")) {
+		debug("%s: switching RGMII to CLKIN\n", __func__);
+		rk_setreg(&priv->cru->clksel_con[19], BIT(4));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int __maybe_unused rk3399_dclk_vop_set_parent(struct clk *clk,
+						     struct clk *parent)
+{
+	struct rk3399_clk_priv *priv = dev_get_priv(clk->dev);
+	void *dclkreg_addr;
+
+	switch (clk->id) {
+	case DCLK_VOP0_DIV:
+		dclkreg_addr = &priv->cru->clksel_con[49];
+		break;
+	case DCLK_VOP1_DIV:
+		dclkreg_addr = &priv->cru->clksel_con[50];
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (parent->id == PLL_CPLL) {
+		rk_clrsetreg(dclkreg_addr, DCLK_VOP_PLL_SEL_MASK,
+			     DCLK_VOP_PLL_SEL_CPLL << DCLK_VOP_PLL_SEL_SHIFT);
+	} else {
+		rk_clrsetreg(dclkreg_addr, DCLK_VOP_PLL_SEL_MASK,
+			     DCLK_VOP_PLL_SEL_VPLL << DCLK_VOP_PLL_SEL_SHIFT);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused rk3399_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	switch (clk->id) {
+	case SCLK_RMII_SRC:
+		return rk3399_gmac_set_parent(clk, parent);
+	case DCLK_VOP0_DIV:
+	case DCLK_VOP1_DIV:
+		return rk3399_dclk_vop_set_parent(clk, parent);
+	}
+
+	debug("%s: unsupported clk %ld\n", __func__, clk->id);
+	return -ENOENT;
+}
+
+static int rk3399_clk_enable(struct clk *clk)
+{
+	switch (clk->id) {
+	case HCLK_HOST0:
+	case HCLK_HOST0_ARB:
+	case SCLK_USBPHY0_480M_SRC:
+	case HCLK_HOST1:
+	case HCLK_HOST1_ARB:
+	case SCLK_USBPHY1_480M_SRC:
+	case ACLK_USB3OTG1:
+	case ACLK_USB3_GRF:
+	case SCLK_USB3OTG1_REF:
+	case SCLK_USB3OTG1_SUSPEND:
+		return 0;
+	}
+
+	debug("%s: unsupported clk %ld\n", __func__, clk->id);
+	return -ENOENT;
+}
+
 static struct clk_ops rk3399_clk_ops = {
 	.get_rate = rk3399_clk_get_rate,
 	.set_rate = rk3399_clk_set_rate,
+#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
+	.set_parent = rk3399_clk_set_parent,
+#endif
+	.enable = rk3399_clk_enable,
 };
 
+static void rkclk_init(struct rk3399_cru *cru)
+{
+	u32 aclk_div;
+	u32 hclk_div;
+	u32 pclk_div;
+
+	rk3399_configure_cpu(cru, APLL_816_MHZ, CPU_CLUSTER_LITTLE);
+	rk3399_configure_cpu(cru, APLL_816_MHZ, CPU_CLUSTER_BIG);
+
+	/*
+	 * some cru registers changed by bootrom, we'd better reset them to
+	 * reset/default values described in TRM to avoid confusion in kernel.
+	 * Please consider these three lines as a fix of bootrom bug.
+	 */
+	if (rkclk_pll_get_rate(&cru->npll_con[0]) != NPLL_HZ)
+		rkclk_set_pll(&cru->npll_con[0], &npll_init_cfg);
+
+	if (rkclk_pll_get_rate(&cru->gpll_con[0]) == GPLL_HZ)
+		return;
+
+	rk_clrsetreg(&cru->clksel_con[12], 0xffff, 0x4101);
+	rk_clrsetreg(&cru->clksel_con[19], 0xffff, 0x033f);
+	rk_clrsetreg(&cru->clksel_con[56], 0x0003, 0x0003);
+
+	/* configure perihp aclk, hclk, pclk */
+	aclk_div = DIV_ROUND_UP(GPLL_HZ, PERIHP_ACLK_HZ) - 1;
+
+	hclk_div = PERIHP_ACLK_HZ / PERIHP_HCLK_HZ - 1;
+	assert((hclk_div + 1) * PERIHP_HCLK_HZ <=
+	       PERIHP_ACLK_HZ && (hclk_div <= 0x3));
+
+	pclk_div = PERIHP_ACLK_HZ / PERIHP_PCLK_HZ - 1;
+	assert((pclk_div + 1) * PERIHP_PCLK_HZ <=
+	       PERIHP_ACLK_HZ && (pclk_div <= 0x7));
+
+	rk_clrsetreg(&cru->clksel_con[14],
+		     PCLK_PERIHP_DIV_CON_MASK | HCLK_PERIHP_DIV_CON_MASK |
+		     ACLK_PERIHP_PLL_SEL_MASK | ACLK_PERIHP_DIV_CON_MASK,
+		     pclk_div << PCLK_PERIHP_DIV_CON_SHIFT |
+		     hclk_div << HCLK_PERIHP_DIV_CON_SHIFT |
+		     ACLK_PERIHP_PLL_SEL_GPLL << ACLK_PERIHP_PLL_SEL_SHIFT |
+		     aclk_div << ACLK_PERIHP_DIV_CON_SHIFT);
+
+	/* configure perilp0 aclk, hclk, pclk */
+	aclk_div = DIV_ROUND_UP(GPLL_HZ, PERILP0_ACLK_HZ) - 1;
+
+	hclk_div = PERILP0_ACLK_HZ / PERILP0_HCLK_HZ - 1;
+	assert((hclk_div + 1) * PERILP0_HCLK_HZ <=
+	       PERILP0_ACLK_HZ && (hclk_div <= 0x3));
+
+	pclk_div = PERILP0_ACLK_HZ / PERILP0_PCLK_HZ - 1;
+	assert((pclk_div + 1) * PERILP0_PCLK_HZ <=
+	       PERILP0_ACLK_HZ && (pclk_div <= 0x7));
+
+	rk_clrsetreg(&cru->clksel_con[23],
+		     PCLK_PERILP0_DIV_CON_MASK | HCLK_PERILP0_DIV_CON_MASK |
+		     ACLK_PERILP0_PLL_SEL_MASK | ACLK_PERILP0_DIV_CON_MASK,
+		     pclk_div << PCLK_PERILP0_DIV_CON_SHIFT |
+		     hclk_div << HCLK_PERILP0_DIV_CON_SHIFT |
+		     ACLK_PERILP0_PLL_SEL_GPLL << ACLK_PERILP0_PLL_SEL_SHIFT |
+		     aclk_div << ACLK_PERILP0_DIV_CON_SHIFT);
+
+	/* perilp1 hclk select gpll as source */
+	hclk_div = DIV_ROUND_UP(GPLL_HZ, PERILP1_HCLK_HZ) - 1;
+	assert((hclk_div + 1) * PERILP1_HCLK_HZ <=
+	       GPLL_HZ && (hclk_div <= 0x1f));
+
+	pclk_div = PERILP1_HCLK_HZ / PERILP1_PCLK_HZ - 1;
+	assert((pclk_div + 1) * PERILP1_PCLK_HZ <=
+	       PERILP1_HCLK_HZ && (pclk_div <= 0x7));
+
+	rk_clrsetreg(&cru->clksel_con[25],
+		     PCLK_PERILP1_DIV_CON_MASK | HCLK_PERILP1_DIV_CON_MASK |
+		     HCLK_PERILP1_PLL_SEL_MASK,
+		     pclk_div << PCLK_PERILP1_DIV_CON_SHIFT |
+		     hclk_div << HCLK_PERILP1_DIV_CON_SHIFT |
+		     HCLK_PERILP1_PLL_SEL_GPLL << HCLK_PERILP1_PLL_SEL_SHIFT);
+
+	rk_clrsetreg(&cru->clksel_con[21],
+		     ACLK_EMMC_PLL_SEL_MASK | ACLK_EMMC_DIV_CON_MASK,
+		     ACLK_EMMC_PLL_SEL_GPLL << ACLK_EMMC_PLL_SEL_SHIFT |
+		     (4 - 1) << ACLK_EMMC_DIV_CON_SHIFT);
+	rk_clrsetreg(&cru->clksel_con[22], 0x3f << 0, 7 << 0);
+
+	/*
+	 * I2c MUx is in cpll by default, but cpll is for dclk_vop exclusive.
+	 * If dclk_vop set rate after i2c init, the CPLL changed,
+	 * but the i2c not perception, it will resulting the wrong
+	 * frequency of the i2c.
+	 * So set the i2c frequency according to the kernel configuration,
+	 * and Hang I2C on the GPLL.
+	 */
+	rk_clrsetreg(&cru->clksel_con[61], I2C_CLK_REG_MASK(1),
+		     I2C_CLK_REG_VALUE(1, 4));
+	rk_clrsetreg(&cru->clksel_con[62], I2C_CLK_REG_MASK(2),
+		     I2C_CLK_REG_VALUE(2, 4));
+	rk_clrsetreg(&cru->clksel_con[63], I2C_CLK_REG_MASK(3),
+		     I2C_CLK_REG_VALUE(3, 4));
+	rk_clrsetreg(&cru->clksel_con[61], I2C_CLK_REG_MASK(5),
+		     I2C_CLK_REG_VALUE(5, 4));
+	rk_clrsetreg(&cru->clksel_con[62], I2C_CLK_REG_MASK(6),
+		     I2C_CLK_REG_VALUE(6, 4));
+	rk_clrsetreg(&cru->clksel_con[63], I2C_CLK_REG_MASK(7),
+		     I2C_CLK_REG_VALUE(7, 4));
+
+	rkclk_set_pll(&cru->gpll_con[0], &gpll_init_cfg);
+}
+
 static int rk3399_clk_probe(struct udevice *dev)
 {
-#ifdef CONFIG_SPL_BUILD
 	struct rk3399_clk_priv *priv = dev_get_priv(dev);
 
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3399_clk_plat *plat = dev_get_platdata(dev);
 
-	priv->cru = map_sysmem(plat->dtd.reg[1], plat->dtd.reg[3]);
+	priv->cru = map_sysmem(plat->dtd.reg[0], plat->dtd.reg[1]);
 #endif
+
+	priv->sync_kernel = false;
+	if (!priv->armlclk_enter_hz)
+		priv->armlclk_enter_hz =
+		rkclk_pll_get_rate(&priv->cru->apll_l_con[0]);
+	if (!priv->armbclk_enter_hz)
+		priv->armbclk_enter_hz =
+		rkclk_pll_get_rate(&priv->cru->apll_b_con[0]);
 	rkclk_init(priv->cru);
-#endif
+	if (!priv->armlclk_init_hz)
+		priv->armlclk_init_hz =
+		rkclk_pll_get_rate(&priv->cru->apll_l_con[0]);
+	if (!priv->armbclk_init_hz)
+		priv->armbclk_init_hz =
+		rkclk_pll_get_rate(&priv->cru->apll_b_con[0]);
+
 	return 0;
 }
 
@@ -975,7 +1532,7 @@ static int rk3399_clk_ofdata_to_platdata(struct udevice *dev)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3399_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rk3399_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
 #endif
 	return 0;
 }
@@ -983,11 +1540,35 @@ static int rk3399_clk_ofdata_to_platdata(struct udevice *dev)
 static int rk3399_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rk3399_sysreset", "reset", &dev);
-	if (ret)
-		printf("Warning: No RK3399 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3399_cru,
+						    glb_srst_fst_value);
+		priv->glb_srst_snd_value = offsetof(struct rk3399_cru,
+						    glb_srst_snd_value);
+		sys_child->priv = priv;
+	}
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3399_cru,
+						    softrst_con[0]);
+		sf_priv->sf_reset_num = 21;
+		sf_child->priv = sf_priv;
+	}
 
 	return 0;
 }
@@ -1083,6 +1664,7 @@ static ulong rk3399_pmuclk_get_rate(struct clk *clk)
 
 	switch (clk->id) {
 	case PCLK_RKPWM_PMU:
+	case PCLK_WDT_M0_PMU:
 		rate = rk3399_pwm_get_clk(priv->pmucru);
 		break;
 	case SCLK_I2C0_PMU:
@@ -1090,6 +1672,9 @@ static ulong rk3399_pmuclk_get_rate(struct clk *clk)
 	case SCLK_I2C8_PMU:
 		rate = rk3399_i2c_get_pmuclk(priv->pmucru, clk->id);
 		break;
+	case SCLK_UART4_PMU:
+		rate = 24000000;
+		break;
 	default:
 		return -ENOENT;
 	}
@@ -1145,7 +1730,7 @@ static int rk3399_pmuclk_probe(struct udevice *dev)
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3399_pmuclk_plat *plat = dev_get_platdata(dev);
 
-	priv->pmucru = map_sysmem(plat->dtd.reg[1], plat->dtd.reg[3]);
+	priv->pmucru = map_sysmem(plat->dtd.reg[0], plat->dtd.reg[1]);
 #endif
 
 #ifndef CONFIG_SPL_BUILD
@@ -1159,11 +1744,33 @@ static int rk3399_pmuclk_ofdata_to_platdata(struct udevice *dev)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rk3399_pmuclk_priv *priv = dev_get_priv(dev);
 
-	priv->pmucru = (struct rk3399_pmucru *)devfdt_get_addr(dev);
+	priv->pmucru = dev_read_addr_ptr(dev);
 #endif
 	return 0;
 }
 
+static int rk3399_pmuclk_bind(struct udevice *dev)
+{
+	int ret = 0;
+	struct udevice *sf_child;
+	struct softreset_reg *sf_priv;
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset",
+					 "reset", dev_ofnode(dev),
+					 &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rk3399_pmucru,
+						    pmucru_softrst_con[0]);
+		sf_priv->sf_reset_num = 2;
+		sf_child->priv = sf_priv;
+	}
+
+	return 0;
+}
+
 static const struct udevice_id rk3399_pmuclk_ids[] = {
 	{ .compatible = "rockchip,rk3399-pmucru" },
 	{ }
@@ -1177,7 +1784,89 @@ U_BOOT_DRIVER(rockchip_rk3399_pmuclk) = {
 	.ofdata_to_platdata = rk3399_pmuclk_ofdata_to_platdata,
 	.ops		= &rk3399_pmuclk_ops,
 	.probe		= rk3399_pmuclk_probe,
+	.bind		= rk3399_pmuclk_bind,
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	.platdata_auto_alloc_size = sizeof(struct rk3399_pmuclk_plat),
 #endif
 };
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * soc_clk_dump() - Print clock frequencies
+ * Returns zero on success
+ *
+ * Implementation for the clk dump command.
+ */
+int soc_clk_dump(void)
+{
+	struct udevice *cru_dev, *pmucru_dev;
+	struct rk3399_clk_priv *priv;
+	const struct rk3399_clk_info *clk_dump;
+	struct clk clk;
+	unsigned long clk_count = ARRAY_SIZE(clks_dump);
+	unsigned long rate;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(clk_rk3399),
+					  &cru_dev);
+	if (ret) {
+		printf("%s failed to get cru device\n", __func__);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_driver(UCLASS_CLK,
+					  DM_GET_DRIVER(rockchip_rk3399_pmuclk),
+					  &pmucru_dev);
+	if (ret) {
+		printf("%s failed to get pmucru device\n", __func__);
+		return ret;
+	}
+
+	priv = dev_get_priv(cru_dev);
+	printf("CLK: (%s. arml: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armlclk_enter_hz / 1000,
+	       priv->armlclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armlclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	printf("CLK: (%s. armb: enter %lu KHz, init %lu KHz, kernel %lu%s)\n",
+	       priv->sync_kernel ? "sync kernel" : "uboot",
+	       priv->armbclk_enter_hz / 1000,
+	       priv->armbclk_init_hz / 1000,
+	       priv->set_armclk_rate ? priv->armbclk_hz / 1000 : 0,
+	       priv->set_armclk_rate ? " KHz" : "N/A");
+	for (i = 0; i < clk_count; i++) {
+		clk_dump = &clks_dump[i];
+		if (clk_dump->name) {
+			clk.id = clk_dump->id;
+			if (clk_dump->is_cru)
+				ret = clk_request(cru_dev, &clk);
+			else
+				ret = clk_request(pmucru_dev, &clk);
+			if (ret < 0)
+				return ret;
+
+			rate = clk_get_rate(&clk);
+			clk_free(&clk);
+			if (i == 0) {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			} else {
+				if (rate < 0)
+					printf("  %s %s\n", clk_dump->name,
+					       "unknown");
+				else
+					printf("  %s %lu KHz\n", clk_dump->name,
+					       rate / 1000);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
diff --git a/drivers/clk/rockchip/clk_rv1108.c b/drivers/clk/rockchip/clk_rv1108.c
index cf966bbdc3..7377486fb7 100644
--- a/drivers/clk/rockchip/clk_rv1108.c
+++ b/drivers/clk/rockchip/clk_rv1108.c
@@ -5,14 +5,15 @@
  */
 
 #include <common.h>
+#include <bitfield.h>
 #include <clk-uclass.h>
 #include <dm.h>
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rv1108.h>
-#include <asm/arch/hardware.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rv1108.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <dm/lists.h>
 #include <dt-bindings/clock/rv1108-cru.h>
 
@@ -36,7 +37,10 @@ enum {
 			 #hz "Hz cannot be hit with PLL "\
 			 "divisors on line " __stringify(__LINE__));
 
-/* use interge mode*/
+static const struct pll_div apll_init_cfg = PLL_DIVISORS(APLL_HZ, 1, 3, 1);
+static const struct pll_div gpll_init_cfg = PLL_DIVISORS(GPLL_HZ, 2, 2, 1);
+
+/* use integer mode */
 static inline int rv1108_pll_id(enum rk_clk_id clk_id)
 {
 	int id = 0;
@@ -58,6 +62,58 @@ static inline int rv1108_pll_id(enum rk_clk_id clk_id)
 	return id;
 }
 
+static int rkclk_set_pll(struct rv1108_cru *cru, enum rk_clk_id clk_id,
+			 const struct pll_div *div)
+{
+	int pll_id = rv1108_pll_id(clk_id);
+	struct rv1108_pll *pll = &cru->pll[pll_id];
+
+	/* All PLLs have same VCO and output frequency range restrictions. */
+	uint vco_hz = OSC_HZ / 1000 * div->fbdiv / div->refdiv * 1000;
+	uint output_hz = vco_hz / div->postdiv1 / div->postdiv2;
+
+	debug("PLL at %p: fb=%d, ref=%d, pst1=%d, pst2=%d, vco=%u Hz, output=%u Hz\n",
+	      pll, div->fbdiv, div->refdiv, div->postdiv1,
+	      div->postdiv2, vco_hz, output_hz);
+	assert(vco_hz >= VCO_MIN_HZ && vco_hz <= VCO_MAX_HZ &&
+	       output_hz >= OUTPUT_MIN_HZ && output_hz <= OUTPUT_MAX_HZ);
+
+	/*
+	 * When power on or changing PLL setting,
+	 * we must force PLL into slow mode to ensure output stable clock.
+	 */
+	rk_clrsetreg(&pll->con3, WORK_MODE_MASK,
+		     WORK_MODE_SLOW << WORK_MODE_SHIFT);
+
+	/* use integer mode */
+	rk_setreg(&pll->con3, 1 << DSMPD_SHIFT);
+	/* Power down */
+	rk_setreg(&pll->con3, 1 << GLOBAL_POWER_DOWN_SHIFT);
+
+	rk_clrsetreg(&pll->con0, FBDIV_MASK, div->fbdiv << FBDIV_SHIFT);
+	rk_clrsetreg(&pll->con1, POSTDIV1_MASK | POSTDIV2_MASK | REFDIV_MASK,
+		     (div->postdiv1 << POSTDIV1_SHIFT |
+		     div->postdiv2 << POSTDIV2_SHIFT |
+		     div->refdiv << REFDIV_SHIFT));
+	rk_clrsetreg(&pll->con2, FRACDIV_MASK,
+		     (div->refdiv << REFDIV_SHIFT));
+
+	/* Power Up */
+	rk_clrreg(&pll->con3, 1 << GLOBAL_POWER_DOWN_SHIFT);
+
+	/* waiting for pll lock */
+	while (readl(&pll->con2) & (1 << LOCK_STA_SHIFT))
+		udelay(1);
+
+	/*
+	 * set PLL into normal mode.
+	 */
+	rk_clrsetreg(&pll->con3, WORK_MODE_MASK,
+		     WORK_MODE_NORMAL << WORK_MODE_SHIFT);
+
+	return 0;
+}
+
 static uint32_t rkclk_pll_get_rate(struct rv1108_cru *cru,
 				   enum rk_clk_id clk_id)
 {
@@ -75,7 +131,7 @@ static uint32_t rkclk_pll_get_rate(struct rv1108_cru *cru,
 		fbdiv = (con0 >> FBDIV_SHIFT) & FBDIV_MASK;
 		postdiv1 = (con1 & POSTDIV1_MASK) >> POSTDIV1_SHIFT;
 		postdiv2 = (con1 & POSTDIV2_MASK) >> POSTDIV2_SHIFT;
-		refdiv = (con1 & REFDIV_MASK) >> REFDIV_SHIFT;
+		refdiv = (con1 >> REFDIV_SHIFT) & REFDIV_MASK;
 		freq = (24 * fbdiv / (refdiv * postdiv1 * postdiv2)) * 1000000;
 	} else {
 		freq = OSC_HZ;
@@ -130,6 +186,374 @@ static int rv1108_sfc_set_clk(struct rv1108_cru *cru, uint rate)
 	return DIV_TO_RATE(pll_rate, div);
 }
 
+static ulong rv1108_saradc_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[22]);
+	div = bitfield_extract(val, CLK_SARADC_DIV_CON_SHIFT,
+			       CLK_SARADC_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rv1108_saradc_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(OSC_HZ, hz) - 1;
+	assert(src_clk_div < 128);
+
+	rk_clrsetreg(&cru->clksel_con[22],
+		     CLK_SARADC_DIV_CON_MASK,
+		     src_clk_div << CLK_SARADC_DIV_CON_SHIFT);
+
+	return rv1108_saradc_get_clk(cru);
+}
+
+static ulong rv1108_aclk_vio1_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[28]);
+	div = bitfield_extract(val, ACLK_VIO1_CLK_DIV_SHIFT,
+			       CLK_VIO_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(GPLL_HZ, div);
+}
+
+static ulong rv1108_aclk_vio1_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(GPLL_HZ, hz) - 1;
+	assert(src_clk_div < 32);
+
+	rk_clrsetreg(&cru->clksel_con[28],
+		     ACLK_VIO1_CLK_DIV_MASK | ACLK_VIO1_PLL_SEL_MASK,
+		     (src_clk_div << ACLK_VIO1_CLK_DIV_SHIFT) |
+		     (VIO_PLL_SEL_GPLL << ACLK_VIO1_PLL_SEL_SHIFT));
+
+	return rv1108_aclk_vio1_get_clk(cru);
+}
+
+static ulong rv1108_aclk_vio0_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[28]);
+	div = bitfield_extract(val, ACLK_VIO0_CLK_DIV_SHIFT,
+			       CLK_VIO_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(GPLL_HZ, div);
+}
+
+static ulong rv1108_aclk_vio0_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(GPLL_HZ, hz) - 1;
+	assert(src_clk_div < 32);
+
+	rk_clrsetreg(&cru->clksel_con[28],
+		     ACLK_VIO0_CLK_DIV_MASK | ACLK_VIO0_PLL_SEL_MASK,
+		     (src_clk_div << ACLK_VIO0_CLK_DIV_SHIFT) |
+		     (VIO_PLL_SEL_GPLL << ACLK_VIO0_PLL_SEL_SHIFT));
+
+	/*HCLK_VIO default div = 4*/
+	rk_clrsetreg(&cru->clksel_con[29],
+		     HCLK_VIO_CLK_DIV_MASK,
+		     3 << HCLK_VIO_CLK_DIV_SHIFT);
+	/*PCLK_VIO default div = 4*/
+	rk_clrsetreg(&cru->clksel_con[29],
+		     PCLK_VIO_CLK_DIV_MASK,
+		     3 << PCLK_VIO_CLK_DIV_SHIFT);
+
+	return rv1108_aclk_vio0_get_clk(cru);
+}
+
+static ulong rv1108_dclk_vop_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+
+	val = readl(&cru->clksel_con[32]);
+	div = bitfield_extract(val, DCLK_VOP_CLK_DIV_SHIFT,
+			       DCLK_VOP_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(GPLL_HZ, div);
+}
+
+static ulong rv1108_dclk_vop_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+
+	src_clk_div = DIV_ROUND_UP(GPLL_HZ, hz) - 1;
+	assert(src_clk_div < 64);
+
+	rk_clrsetreg(&cru->clksel_con[32],
+		     DCLK_VOP_CLK_DIV_MASK | DCLK_VOP_PLL_SEL_MASK |
+		     DCLK_VOP_SEL_SHIFT,
+		     (src_clk_div << DCLK_VOP_CLK_DIV_SHIFT) |
+		     (DCLK_VOP_PLL_SEL_GPLL << DCLK_VOP_PLL_SEL_SHIFT) |
+		     (DCLK_VOP_SEL_PLL << DCLK_VOP_SEL_SHIFT));
+
+	return rv1108_dclk_vop_get_clk(cru);
+}
+
+static ulong rv1108_aclk_bus_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	val = readl(&cru->clksel_con[2]);
+	div = bitfield_extract(val, ACLK_BUS_DIV_CON_SHIFT,
+			       ACLK_BUS_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(parent_rate, div);
+}
+
+static ulong rv1108_aclk_bus_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	src_clk_div = DIV_ROUND_UP(parent_rate, hz) - 1;
+	assert(src_clk_div < 32);
+
+	rk_clrsetreg(&cru->clksel_con[2],
+		     ACLK_BUS_DIV_CON_MASK | ACLK_BUS_PLL_SEL_MASK,
+		     (src_clk_div << ACLK_BUS_DIV_CON_SHIFT) |
+		     (ACLK_BUS_PLL_SEL_GPLL << ACLK_BUS_PLL_SEL_SHIFT));
+
+	return rv1108_aclk_bus_get_clk(cru);
+}
+
+static ulong rv1108_aclk_peri_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	val = readl(&cru->clksel_con[23]);
+	div = bitfield_extract(val, ACLK_PERI_DIV_CON_SHIFT,
+			       PERI_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(parent_rate, div);
+}
+
+static ulong rv1108_hclk_peri_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	val = readl(&cru->clksel_con[23]);
+	div = bitfield_extract(val, HCLK_PERI_DIV_CON_SHIFT,
+			       PERI_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(parent_rate, div);
+}
+
+static ulong rv1108_pclk_peri_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, val;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	val = readl(&cru->clksel_con[23]);
+	div = bitfield_extract(val, PCLK_PERI_DIV_CON_SHIFT,
+			       PERI_DIV_CON_WIDTH);
+
+	return DIV_TO_RATE(parent_rate, div);
+}
+
+static ulong rv1108_aclk_peri_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	src_clk_div = DIV_ROUND_UP(parent_rate, hz) - 1;
+	assert(src_clk_div < 32);
+
+	rk_clrsetreg(&cru->clksel_con[23],
+		     ACLK_PERI_DIV_CON_MASK | ACLK_PERI_PLL_SEL_MASK,
+		     (src_clk_div << ACLK_PERI_DIV_CON_SHIFT) |
+		     (ACLK_PERI_PLL_SEL_GPLL << ACLK_PERI_PLL_SEL_SHIFT));
+
+	return rv1108_aclk_peri_get_clk(cru);
+}
+
+static ulong rv1108_hclk_peri_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	src_clk_div = DIV_ROUND_UP(parent_rate, hz) - 1;
+	assert(src_clk_div < 32);
+
+	rk_clrsetreg(&cru->clksel_con[23],
+		     HCLK_PERI_DIV_CON_MASK,
+		     (src_clk_div << HCLK_PERI_DIV_CON_SHIFT));
+
+	return rv1108_hclk_peri_get_clk(cru);
+}
+
+static ulong rv1108_pclk_peri_set_clk(struct rv1108_cru *cru, uint hz)
+{
+	int src_clk_div;
+	ulong parent_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+
+	src_clk_div = DIV_ROUND_UP(parent_rate, hz) - 1;
+	assert(src_clk_div < 32);
+
+	rk_clrsetreg(&cru->clksel_con[23],
+		     PCLK_PERI_DIV_CON_MASK,
+		     (src_clk_div << PCLK_PERI_DIV_CON_SHIFT));
+
+	return rv1108_pclk_peri_get_clk(cru);
+}
+
+static ulong rv1108_i2c_get_clk(struct rv1108_cru *cru, ulong clk_id)
+{
+	u32 div, con;
+
+	switch (clk_id) {
+	case SCLK_I2C0_PMU:
+		con = readl(&cru->clksel_con[19]);
+		div = bitfield_extract(con, CLK_I2C0_DIV_CON_SHIFT,
+				       I2C_DIV_CON_WIDTH);
+		break;
+	case SCLK_I2C1:
+		con = readl(&cru->clksel_con[19]);
+		div = bitfield_extract(con, CLK_I2C1_DIV_CON_SHIFT,
+				       I2C_DIV_CON_WIDTH);
+		break;
+	case SCLK_I2C2:
+		con = readl(&cru->clksel_con[20]);
+		div = bitfield_extract(con, CLK_I2C2_DIV_CON_SHIFT,
+				       I2C_DIV_CON_WIDTH);
+		break;
+	case SCLK_I2C3:
+		con = readl(&cru->clksel_con[20]);
+		div = bitfield_extract(con, CLK_I2C3_DIV_CON_SHIFT,
+				       I2C_DIV_CON_WIDTH);
+		break;
+	default:
+		printf("do not support this i2c bus\n");
+		return -EINVAL;
+	}
+
+	return DIV_TO_RATE(GPLL_HZ, div);
+}
+
+static ulong rv1108_i2c_set_clk(struct rv1108_cru *cru, ulong clk_id, uint hz)
+{
+	int src_clk_div;
+
+	/* i2c0,4,8 src clock from ppll, i2c1,2,3,5,6,7 src clock from gpll*/
+	src_clk_div = GPLL_HZ / hz;
+	assert(src_clk_div - 1 <= 127);
+
+	switch (clk_id) {
+	case SCLK_I2C0_PMU:
+		rk_clrsetreg(&cru->clksel_con[19],
+			     CLK_I2C0_DIV_CON_MASK | CLK_I2C1_PLL_SEL_MASK,
+			     (src_clk_div << CLK_I2C0_DIV_CON_SHIFT) |
+			     (CLK_I2C1_PLL_SEL_GPLL << CLK_I2C1_PLL_SEL_SHIFT));
+		break;
+	case SCLK_I2C1:
+		rk_clrsetreg(&cru->clksel_con[19],
+			     CLK_I2C1_DIV_CON_MASK | CLK_I2C1_PLL_SEL_MASK,
+			     (src_clk_div << CLK_I2C1_DIV_CON_SHIFT) |
+			     (CLK_I2C1_PLL_SEL_GPLL << CLK_I2C1_PLL_SEL_SHIFT));
+		break;
+	case SCLK_I2C2:
+		rk_clrsetreg(&cru->clksel_con[20],
+			     CLK_I2C2_DIV_CON_MASK | CLK_I2C3_PLL_SEL_MASK,
+			     (src_clk_div << CLK_I2C2_DIV_CON_SHIFT) |
+			     (CLK_I2C3_PLL_SEL_GPLL << CLK_I2C3_PLL_SEL_SHIFT));
+		break;
+	case SCLK_I2C3:
+		rk_clrsetreg(&cru->clksel_con[20],
+			     CLK_I2C3_DIV_CON_MASK | CLK_I2C3_PLL_SEL_MASK,
+			     (src_clk_div << CLK_I2C3_DIV_CON_SHIFT) |
+			     (CLK_I2C3_PLL_SEL_GPLL << CLK_I2C3_PLL_SEL_SHIFT));
+		break;
+	default:
+		printf("do not support this i2c bus\n");
+		return -EINVAL;
+	}
+
+	return rv1108_i2c_get_clk(cru, clk_id);
+}
+
+static ulong rv1108_spi_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, con;
+
+	con = readl(&cru->clksel_con[11]);
+	div = (con & SPI_DIV_MASK) >> SPI_DIV_SHIFT;
+
+	return DIV_TO_RATE(rkclk_pll_get_rate(cru, CLK_GENERAL), div);
+}
+
+static ulong  rv1108_spi_set_clk(struct rv1108_cru *cru, ulong hz)
+{
+	int div;
+
+	div = DIV_ROUND_UP(rkclk_pll_get_rate(cru, CLK_GENERAL), hz);
+	assert(div - 1 < 128);
+	rk_clrsetreg(&cru->clksel_con[11],
+		     SPI_PLL_SEL_MASK | SPI_DIV_MASK,
+		     SPI_PLL_SEL_GPLL << SPI_PLL_SEL_SHIFT |
+		     (div - 1) << SPI_DIV_SHIFT);
+	return  rv1108_spi_get_clk(cru);
+}
+
+static ulong rv1108_mmc_get_clk(struct rv1108_cru *cru)
+{
+	u32 div, con;
+	ulong mmc_clk;
+
+	con = readl(&cru->clksel_con[26]);
+	div = bitfield_extract(con, EMMC_CLK_DIV_SHIFT, 8);
+
+	con = readl(&cru->clksel_con[25]);
+
+	if ((con & EMMC_PLL_SEL_MASK) >> EMMC_PLL_SEL_SHIFT == EMMC_PLL_SEL_OSC)
+		mmc_clk = DIV_TO_RATE(OSC_HZ, div) / 2;
+	else
+		mmc_clk = DIV_TO_RATE(GPLL_HZ, div) / 2;
+
+	debug("%s div %d get_clk %ld\n", __func__, div, mmc_clk);
+	return mmc_clk;
+}
+
+static ulong rv1108_mmc_set_clk(struct rv1108_cru *cru, ulong rate)
+{
+	int div;
+	u32 pll_rate;
+
+	div = DIV_ROUND_UP(rkclk_pll_get_rate(cru, CLK_GENERAL), rate);
+
+	if (div < 127) {
+		debug("%s source gpll\n", __func__);
+		rk_clrsetreg(&cru->clksel_con[25], EMMC_PLL_SEL_MASK,
+			     (EMMC_PLL_SEL_GPLL << EMMC_PLL_SEL_SHIFT));
+		pll_rate = rkclk_pll_get_rate(cru, CLK_GENERAL);
+	} else {
+		debug("%s source 24m\n", __func__);
+		rk_clrsetreg(&cru->clksel_con[25], EMMC_PLL_SEL_MASK,
+			     (EMMC_PLL_SEL_OSC << EMMC_PLL_SEL_SHIFT));
+		pll_rate = OSC_HZ;
+	}
+
+	div = DIV_ROUND_UP(pll_rate / 2, rate);
+	rk_clrsetreg(&cru->clksel_con[26], EMMC_CLK_DIV_MASK,
+		     ((div - 1) << EMMC_CLK_DIV_SHIFT));
+
+	debug("%s set_rate %ld div %d\n", __func__,  rate, div);
+
+	return DIV_TO_RATE(pll_rate, div);
+}
+
 static ulong rv1108_clk_get_rate(struct clk *clk)
 {
 	struct rv1108_clk_priv *priv = dev_get_priv(clk->dev);
@@ -137,6 +561,33 @@ static ulong rv1108_clk_get_rate(struct clk *clk)
 	switch (clk->id) {
 	case 0 ... 63:
 		return rkclk_pll_get_rate(priv->cru, clk->id);
+	case SCLK_SARADC:
+		return rv1108_saradc_get_clk(priv->cru);
+	case ACLK_VIO0:
+		return rv1108_aclk_vio0_get_clk(priv->cru);
+	case ACLK_VIO1:
+		return rv1108_aclk_vio1_get_clk(priv->cru);
+	case DCLK_VOP:
+		return rv1108_dclk_vop_get_clk(priv->cru);
+	case ACLK_PRE:
+		return rv1108_aclk_bus_get_clk(priv->cru);
+	case ACLK_PERI:
+		return rv1108_aclk_peri_get_clk(priv->cru);
+	case HCLK_PERI:
+		return rv1108_hclk_peri_get_clk(priv->cru);
+	case PCLK_PERI:
+		return rv1108_pclk_peri_get_clk(priv->cru);
+	case SCLK_I2C0_PMU:
+	case SCLK_I2C1:
+	case SCLK_I2C2:
+	case SCLK_I2C3:
+		return rv1108_i2c_get_clk(priv->cru, clk->id);
+	case HCLK_EMMC:
+	case SCLK_EMMC:
+	case SCLK_EMMC_SAMPLE:
+		return rv1108_mmc_get_clk(priv->cru);
+	case SCLK_SPI:
+		return rv1108_spi_get_clk(priv->cru);
 	default:
 		return -ENOENT;
 	}
@@ -154,6 +605,43 @@ static ulong rv1108_clk_set_rate(struct clk *clk, ulong rate)
 	case SCLK_SFC:
 		new_rate = rv1108_sfc_set_clk(priv->cru, rate);
 		break;
+	case SCLK_SARADC:
+		new_rate = rv1108_saradc_set_clk(priv->cru, rate);
+		break;
+	case ACLK_VIO0:
+		new_rate = rv1108_aclk_vio0_set_clk(priv->cru, rate);
+		break;
+	case ACLK_VIO1:
+		new_rate = rv1108_aclk_vio1_set_clk(priv->cru, rate);
+		break;
+	case DCLK_VOP:
+		new_rate = rv1108_dclk_vop_set_clk(priv->cru, rate);
+		break;
+	case ACLK_PRE:
+		new_rate = rv1108_aclk_bus_set_clk(priv->cru, rate);
+		break;
+	case ACLK_PERI:
+		new_rate = rv1108_aclk_peri_set_clk(priv->cru, rate);
+		break;
+	case HCLK_PERI:
+		new_rate = rv1108_hclk_peri_set_clk(priv->cru, rate);
+		break;
+	case PCLK_PERI:
+		new_rate = rv1108_pclk_peri_set_clk(priv->cru, rate);
+		break;
+	case SCLK_I2C0_PMU:
+	case SCLK_I2C1:
+	case SCLK_I2C2:
+	case SCLK_I2C3:
+		new_rate = rv1108_i2c_set_clk(priv->cru, clk->id, rate);
+		break;
+	case HCLK_EMMC:
+	case SCLK_EMMC:
+		new_rate = rv1108_mmc_set_clk(priv->cru, rate);
+		break;
+	case SCLK_SPI:
+		new_rate = rv1108_spi_set_clk(priv->cru, rate);
+		break;
 	default:
 		return -ENOENT;
 	}
@@ -168,21 +656,56 @@ static const struct clk_ops rv1108_clk_ops = {
 
 static void rkclk_init(struct rv1108_cru *cru)
 {
-	unsigned int apll = rkclk_pll_get_rate(cru, CLK_ARM);
-	unsigned int dpll = rkclk_pll_get_rate(cru, CLK_DDR);
-	unsigned int gpll = rkclk_pll_get_rate(cru, CLK_GENERAL);
+	unsigned int apll, dpll, gpll;
+	unsigned int aclk_bus, aclk_peri, hclk_peri, pclk_peri;
+
+	aclk_bus = rv1108_aclk_bus_set_clk(cru, ACLK_BUS_HZ / 2);
+	aclk_peri = rv1108_aclk_peri_set_clk(cru, ACLK_PERI_HZ / 2);
+	hclk_peri = rv1108_hclk_peri_set_clk(cru, HCLK_PERI_HZ / 2);
+	pclk_peri = rv1108_pclk_peri_set_clk(cru, PCLK_PERI_HZ / 2);
+	rv1108_aclk_vio0_set_clk(cru, 297000000);
+	rv1108_aclk_vio1_set_clk(cru, 297000000);
+
+	/* configure apll */
+	rkclk_set_pll(cru, CLK_ARM, &apll_init_cfg);
+	rkclk_set_pll(cru, CLK_GENERAL, &gpll_init_cfg);
+	aclk_bus = rv1108_aclk_bus_set_clk(cru, ACLK_BUS_HZ);
+	aclk_peri = rv1108_aclk_peri_set_clk(cru, ACLK_PERI_HZ);
+	hclk_peri = rv1108_hclk_peri_set_clk(cru, HCLK_PERI_HZ);
+	pclk_peri = rv1108_pclk_peri_set_clk(cru, PCLK_PERI_HZ);
+
+	apll = rkclk_pll_get_rate(cru, CLK_ARM);
+	dpll = rkclk_pll_get_rate(cru, CLK_DDR);
+	gpll = rkclk_pll_get_rate(cru, CLK_GENERAL);
 
 	rk_clrsetreg(&cru->clksel_con[0], CORE_CLK_DIV_MASK,
 		     0 << MAC_CLK_DIV_SHIFT);
+	rk_clrsetreg(&cru->clksel_con[27],
+		     NANDC_PLL_SEL_MASK | NANDC_CLK_DIV_MASK,
+		     NANDC_PLL_SEL_GPLL << NANDC_PLL_SEL_SHIFT |
+		     7 << NANDC_CLK_DIV_SHIFT);
+	rk_clrsetreg(&cru->clksel_con[27],
+		     SFC_PLL_SEL_MASK | SFC_CLK_DIV_MASK,
+		     SFC_PLL_SEL_GPLL << SFC_PLL_SEL_SHIFT |
+		     11 << SFC_CLK_DIV_SHIFT);
 
 	printf("APLL: %d DPLL:%d GPLL:%d\n", apll, dpll, gpll);
+	printf("ACLK_BUS: %d ACLK_PERI:%d HCLK_PERI:%d PCLK_PERI:%d\n",
+	       aclk_bus, aclk_peri, hclk_peri, pclk_peri);
 }
 
-static int rv1108_clk_probe(struct udevice *dev)
+static int rv1108_clk_ofdata_to_platdata(struct udevice *dev)
 {
 	struct rv1108_clk_priv *priv = dev_get_priv(dev);
 
-	priv->cru = (struct rv1108_cru *)devfdt_get_addr(dev);
+	priv->cru = dev_read_addr_ptr(dev);
+
+	return 0;
+}
+
+static int rv1108_clk_probe(struct udevice *dev)
+{
+	struct rv1108_clk_priv *priv = dev_get_priv(dev);
 
 	rkclk_init(priv->cru);
 
@@ -192,11 +715,35 @@ static int rv1108_clk_probe(struct udevice *dev)
 static int rv1108_clk_bind(struct udevice *dev)
 {
 	int ret;
+	struct udevice *sys_child, *sf_child;
+	struct sysreset_reg *priv;
+	struct softreset_reg *sf_priv;
 
 	/* The reset driver does not have a device node, so bind it here */
-	ret = device_bind_driver(gd->dm_root, "rv1108_sysreset", "reset", &dev);
-	if (ret)
-		error("No Rv1108 reset driver: ret=%d\n", ret);
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rv1108_cru,
+						    glb_srst_fst_val);
+		priv->glb_srst_snd_value = offsetof(struct rv1108_cru,
+						    glb_srst_snd_val);
+		sys_child->priv = priv;
+	}
+
+	ret = device_bind_driver_to_node(dev, "rockchip_reset", "reset",
+					 dev_ofnode(dev), &sf_child);
+	if (ret) {
+		debug("Warning: No rockchip reset driver: ret=%d\n", ret);
+	} else {
+		sf_priv = malloc(sizeof(struct softreset_reg));
+		sf_priv->sf_reset_offset = offsetof(struct rv1108_cru,
+						    softrst_con[0]);
+		sf_priv->sf_reset_num = 13;
+		sf_child->priv = sf_priv;
+	}
 
 	return 0;
 }
@@ -213,5 +760,6 @@ U_BOOT_DRIVER(clk_rv1108) = {
 	.priv_auto_alloc_size = sizeof(struct rv1108_clk_priv),
 	.ops		= &rv1108_clk_ops,
 	.bind		= rv1108_clk_bind,
+	.ofdata_to_platdata	= rv1108_clk_ofdata_to_platdata,
 	.probe		= rv1108_clk_probe,
 };
diff --git a/drivers/core/Kconfig b/drivers/core/Kconfig
index 7afef1f9a3..e8ba20ca82 100644
--- a/drivers/core/Kconfig
+++ b/drivers/core/Kconfig
@@ -45,6 +45,12 @@ config DM_WARN
 	  This will cause dm_warn() to be compiled out - it will do nothing
 	  when called.
 
+config DM_DEBUG
+	bool "Enable debug messages in driver model core"
+	depends on DM
+	help
+	  Say Y here if you want to compile in debug messages in DM core.
+
 config DM_DEVICE_REMOVE
 	bool "Support device removal"
 	depends on DM
diff --git a/drivers/core/Makefile b/drivers/core/Makefile
index 3d68c70b57..a5039c5bd3 100644
--- a/drivers/core/Makefile
+++ b/drivers/core/Makefile
@@ -16,3 +16,5 @@ ifndef CONFIG_DM_DEV_READ_INLINE
 obj-$(CONFIG_OF_CONTROL) += read.o
 endif
 obj-$(CONFIG_OF_CONTROL) += of_extra.o ofnode.o read_extra.o
+
+ccflags-$(CONFIG_DM_DEBUG) += -DDEBUG
diff --git a/drivers/core/device.c b/drivers/core/device.c
index 5463d1ffa5..6498bc2256 100644
--- a/drivers/core/device.c
+++ b/drivers/core/device.c
@@ -11,12 +11,14 @@
 
 #include <common.h>
 #include <asm/io.h>
+#include <clk.h>
 #include <fdtdec.h>
 #include <fdt_support.h>
 #include <malloc.h>
 #include <dm/device.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
+#include <dm/of_access.h>
 #include <dm/pinctrl.h>
 #include <dm/platdata.h>
 #include <dm/read.h>
@@ -35,6 +37,7 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 {
 	struct udevice *dev;
 	struct uclass *uc;
+	bool after_u_boot_dev = true;
 	int size, ret = 0;
 
 	if (devp)
@@ -48,6 +51,64 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 		return ret;
 	}
 
+#if defined(CONFIG_USING_KERNEL_DTB) && !defined(CONFIG_USING_KERNEL_DTB_V2)
+	if (gd->flags & GD_FLG_RELOC) {
+		/* For mmc/nand/spiflash, just update from kernel dtb instead bind again*/
+		if (drv->id == UCLASS_MMC || drv->id == UCLASS_RKNAND ||
+		    drv->id == UCLASS_SPI_FLASH || drv->id == UCLASS_MTD ||
+		    drv->id == UCLASS_PCI || drv->id == UCLASS_AHCI) {
+			/*
+			 * Reject all mmc device from kernel.
+			 *
+			 * - we always follow the rule: use mmc device from U-Boot
+			 * - avoid alias id on defferent device between U-Boot and kernel
+			 */
+			if ((gd->flags & GD_FLG_KDTB_READY) &&
+			     (drv->id == UCLASS_MMC))
+				return 0;
+
+			list_for_each_entry(dev, &uc->dev_head, uclass_node) {
+				if (!strcmp(name, dev->name)) {
+					debug("%s do not bind dev already in list %s\n",
+					      __func__, dev->name);
+					/*
+					 * There is no clearly reason for this
+					 * legacy code, but remain it here since
+					 * everything seems fine with or without
+					 * this. Maybe removed in the future.
+					 */
+					dev->node = node;
+					return 0;
+				}
+			}
+		}
+
+		/* Use other nodes from kernel dtb */
+		struct udevice *n;
+
+		list_for_each_entry_safe(dev, n, &uc->dev_head, uclass_node) {
+			if (!strcmp(name, dev->name) &&
+			    (dev_read_bool(dev, "u-boot,dm-pre-reloc") ||
+			     dev_read_bool(dev, "u-boot,dm-spl"))) {
+
+				/* Always use these node from U-Boot dtb */
+				if (drv->id == UCLASS_CRYPTO ||
+				    drv->id == UCLASS_WDT) {
+					debug("%s do not delete uboot dev: %s\n",
+					      __func__, dev->name);
+					return 0;
+				} else if (drv->id == UCLASS_REGULATOR || !strcmp(dev->name, "gpio-regulator")) {
+					debug("%s do not delete uboot dev: %s\n",
+					      __func__, dev->name);
+
+					return 0;
+				} else {
+					list_del_init(&dev->uclass_node);
+				}
+			}
+		}
+	}
+#endif
 	dev = calloc(1, sizeof(struct udevice));
 	if (!dev)
 		return -ENOMEM;
@@ -139,7 +200,59 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 	if (parent)
 		list_add_tail(&dev->sibling_node, &parent->child_head);
 
-	ret = uclass_bind_device(dev);
+#ifdef CONFIG_USING_KERNEL_DTB
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+	/*
+	 * Put these U-Boot devices in the head of uclass device list for
+	 * the primary get by uclass_get_device_xxx().
+	 *
+	 * device-list: U0, U1, U2, ... K0, K1, K2, ... (prior u-boot dev)
+	 * device-list: K0, K1, K2, ... U0, U1, U2, ... (normal)
+	 *
+	 * U: u-boot dev
+	 * K: kernel dev
+	 */
+	u32 i, prior_u_boot_uclass_id[] = {
+		UCLASS_AHCI,		/* boot device */
+		UCLASS_BLK,
+		UCLASS_MMC,
+		UCLASS_MTD,
+		UCLASS_PCI,
+		UCLASS_RKNAND,
+		UCLASS_SPI_FLASH,
+
+		UCLASS_CRYPTO,		/* RSA security */
+		UCLASS_FIRMWARE,	/* psci sysreset */
+		UCLASS_RNG,		/* ramdom number */
+		UCLASS_SYSCON,		/* grf, pmugrf */
+		UCLASS_SYSRESET,	/* psci sysreset */
+		UCLASS_WDT,		/* reliable sysreset */
+	};
+
+	if (gd->flags & GD_FLG_KDTB_READY) {
+		after_u_boot_dev = false;
+		dev->flags |= DM_FLAG_KNRL_DTB;
+
+		for (i = 0; i < ARRAY_SIZE(prior_u_boot_uclass_id); i++) {
+			if (drv->id == prior_u_boot_uclass_id[i]) {
+				after_u_boot_dev = true;
+				break;
+			}
+		}
+
+		/* no u-boot dev ? */
+		if (!dev->uclass->u_boot_dev_head)
+			dev->uclass->u_boot_dev_head = &uc->dev_head;
+	} else {
+		if (!dev->uclass->u_boot_dev_head)
+			dev->uclass->u_boot_dev_head = &dev->uclass_node;
+	}
+#else
+	if (gd->flags & GD_FLG_KDTB_READY)
+		dev->flags |= DM_FLAG_KNRL_DTB;
+#endif
+#endif
+	ret = uclass_bind_device(dev, after_u_boot_dev);
 	if (ret)
 		goto fail_uclass_bind;
 
@@ -161,7 +274,7 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 	}
 
 	if (parent)
-		dm_dbg("Bound device %s to %s\n", dev->name, parent->name);
+		pr_debug("Bound device %s to %s\n", dev->name, parent->name);
 	if (devp)
 		*devp = dev;
 
@@ -254,6 +367,7 @@ static void *alloc_priv(int size, uint flags)
 	void *priv;
 
 	if (flags & DM_FLAG_ALLOC_PRIV_DMA) {
+		size = ROUND(size, ARCH_DMA_MINALIGN);
 		priv = memalign(ARCH_DMA_MINALIGN, size);
 		if (priv) {
 			memset(priv, '\0', size);
@@ -702,8 +816,12 @@ int device_set_name(struct udevice *dev, const char *name)
 bool device_is_compatible(struct udevice *dev, const char *compat)
 {
 	const void *fdt = gd->fdt_blob;
+	ofnode node = dev_ofnode(dev);
 
-	return !fdt_node_check_compatible(fdt, dev_of_offset(dev), compat);
+	if (ofnode_is_np(node))
+		return of_device_is_compatible(ofnode_to_np(node), compat, NULL, NULL);
+	else
+		return !fdt_node_check_compatible(fdt, ofnode_to_offset(node), compat);
 }
 
 bool of_machine_is_compatible(const char *compat)
diff --git a/drivers/core/dump.c b/drivers/core/dump.c
index c3e109e7ed..1eb036c789 100644
--- a/drivers/core/dump.c
+++ b/drivers/core/dump.c
@@ -14,12 +14,11 @@ static void show_devices(struct udevice *dev, int depth, int last_flag)
 {
 	int i, is_last;
 	struct udevice *child;
-	char class_name[12];
 
 	/* print the first 11 characters to not break the tree-format. */
-	strlcpy(class_name, dev->uclass->uc_drv->name, sizeof(class_name));
-	printf(" %-11s [ %c ]    ", class_name,
-	       dev->flags & DM_FLAG_ACTIVATED ? '+' : ' ');
+	printf(" %08lx    %-10.10s [ %c ]   %-25.25s  ",
+	       (ulong)dev, dev->uclass->uc_drv->name,
+	       dev->flags & DM_FLAG_ACTIVATED ? '+' : ' ', dev->driver->name);
 
 	for (i = depth; i >= 0; i--) {
 		is_last = (last_flag >> i) & 1;
@@ -36,8 +35,15 @@ static void show_devices(struct udevice *dev, int depth, int last_flag)
 		}
 	}
 
-	printf("%s\n", dev->name);
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+	printf("%s %s\n", dev->name, dev->flags & DM_FLAG_KNRL_DTB ? "" : "*");
+#else
+	int pre_reloc, remained;
 
+	pre_reloc = dev->flags & DM_FLAG_KNRL_DTB ? 0 : 1;
+	remained = pre_reloc ? !list_empty(&dev->uclass_node) : 0;
+	printf("%s %s%s\n", dev->name, pre_reloc ? "*" : "", remained ? "*" : "");
+#endif
 	list_for_each_entry(child, &dev->child_head, sibling_node) {
 		is_last = list_is_last(&child->sibling_node, &dev->child_head);
 		show_devices(child, depth + 1, (last_flag << 1) | is_last);
@@ -50,8 +56,8 @@ void dm_dump_all(void)
 
 	root = dm_root();
 	if (root) {
-		printf(" Class       Probed   Name\n");
-		printf("----------------------------------------\n");
+		printf(" Addr        Class      Probed    Driver                   Name\n");
+		printf("-------------------------------------------------------------------------\n");
 		show_devices(root, -1, 0);
 	}
 }
@@ -65,11 +71,16 @@ void dm_dump_all(void)
  */
 static void dm_display_line(struct udevice *dev)
 {
-	printf("- %c %s @ %08lx",
-	       dev->flags & DM_FLAG_ACTIVATED ? '*' : ' ',
+	printf("  [ %c ] %s @ %08lx",
+	       dev->flags & DM_FLAG_ACTIVATED ? '+' : ' ',
 	       dev->name, (ulong)map_to_sysmem(dev));
 	if (dev->seq != -1 || dev->req_seq != -1)
 		printf(", seq %d, (req %d)", dev->seq, dev->req_seq);
+	if (dev->driver->id == UCLASS_BLK) {
+		struct blk_desc *desc = dev_get_uclass_platdata(dev);
+		printf(" | %s%d", blk_get_if_type_name(desc->if_type), desc->devnum);
+	}
+	printf(" %c", dev->flags & DM_FLAG_KNRL_DTB ? ' ' : '*');
 	puts("\n");
 }
 
diff --git a/drivers/core/lists.c b/drivers/core/lists.c
index 6067914e81..6fa5d1090a 100644
--- a/drivers/core/lists.c
+++ b/drivers/core/lists.c
@@ -139,12 +139,13 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp)
 	if (devp)
 		*devp = NULL;
 	name = ofnode_get_name(node);
-	dm_dbg("bind node %s\n", name);
+	pr_debug("bind node %s\n", name);
 
 	compat_list = ofnode_get_property(node, "compatible", &compat_length);
 	if (!compat_list) {
 		if (compat_length == -FDT_ERR_NOTFOUND) {
-			dm_dbg("Device '%s' has no compatible string\n", name);
+			pr_debug("Device '%s' has no compatible string\n",
+				 name);
 			return 0;
 		}
 
@@ -159,8 +160,8 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp)
 	 */
 	for (i = 0; i < compat_length; i += strlen(compat) + 1) {
 		compat = compat_list + i;
-		dm_dbg("   - attempt to match compatible string '%s'\n",
-		       compat);
+		pr_debug("   - attempt to match compatible string '%s'\n",
+			 compat);
 
 		for (entry = driver; entry != driver + n_ents; entry++) {
 			ret = driver_check_compatible(entry->of_match, &id,
@@ -171,11 +172,11 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp)
 		if (entry == driver + n_ents)
 			continue;
 
-		dm_dbg("   - found match at '%s'\n", entry->name);
+		pr_debug("   - found match at '%s'\n", entry->name);
 		ret = device_bind_with_driver_data(parent, entry, name,
 						   id->data, node, &dev);
 		if (ret == -ENODEV) {
-			dm_dbg("Driver '%s' refuses to bind\n", entry->name);
+			pr_debug("Driver '%s' refuses to bind\n", entry->name);
 			continue;
 		}
 		if (ret) {
@@ -191,7 +192,7 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp)
 	}
 
 	if (!found && !result && ret != -ENODEV)
-		dm_dbg("No match for node '%s'\n", name);
+		pr_debug("No match for node '%s'\n", name);
 
 	return result;
 }
diff --git a/drivers/core/of_access.c b/drivers/core/of_access.c
index c31cba7fd6..a6d216fd70 100644
--- a/drivers/core/of_access.c
+++ b/drivers/core/of_access.c
@@ -21,7 +21,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <dm/of_access.h>
 #include <linux/ctype.h>
 #include <linux/err.h>
@@ -387,6 +387,16 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 	for_each_of_allnodes(np)
 		if (np->phandle == handle)
 			break;
+
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+	/* If not find in kernel fdt, traverse u-boot fdt */
+	if (!np) {
+		for (np = gd->of_root_f; np; np = of_find_all_nodes(np)) {
+			if (np->phandle == handle)
+				break;
+		}
+	}
+#endif
 	(void)of_node_get(np);
 
 	return np;
@@ -439,6 +449,33 @@ int of_read_u32(const struct device_node *np, const char *propname, u32 *outp)
 	return 0;
 }
 
+/**
+ * of_property_read_u64 - Find and read a 64 bit integer from a property
+ * @np:         device node from which the property value is to be read.
+ * @propname:   name of the property to be searched.
+ * @out_value:  pointer to return value, modified only if return value is 0.
+ *
+ * Search for a property in a device node and read a 64-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64(const struct device_node *np, const char *propname,
+                         u64 *out_value)
+{
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+							   sizeof(*out_value));
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	*out_value = of_read_number(val, 2);
+
+	return 0;
+}
+
 int of_read_u32_array(const struct device_node *np, const char *propname,
 		      u32 *out_values, size_t sz)
 {
@@ -458,6 +495,25 @@ int of_read_u32_array(const struct device_node *np, const char *propname,
 	return 0;
 }
 
+int of_write_u32_array(const struct device_node *np, const char *propname,
+		       u32 *values, size_t sz)
+{
+	__be32 *val;
+
+	debug("%s: %s: ", __func__, propname);
+	val = of_find_property_value_of_size(np, propname,
+					     sz * sizeof(*values));
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	debug("size %zd\n", sz);
+	while (sz--)
+		*val++ = cpu_to_be32p(values++);
+
+	return 0;
+}
+
 int of_property_match_string(const struct device_node *np, const char *propname,
 			     const char *string)
 {
@@ -675,10 +731,26 @@ int of_count_phandle_with_args(const struct device_node *np,
 static void of_alias_add(struct alias_prop *ap, struct device_node *np,
 			 int id, const char *stem, int stem_len)
 {
+	struct alias_prop *oldap;
 	ap->np = np;
 	ap->id = id;
 	strncpy(ap->stem, stem, stem_len);
 	ap->stem[stem_len] = 0;
+
+	/* Delete U-Boot alias which is same with kernel */
+	mutex_lock(&of_mutex);
+	list_for_each_entry(oldap, &aliases_lookup, link) {
+		if (stem && !strcmp(stem, oldap->alias) && (id == oldap->id)) {
+			/* Always use from U-Boot aliase */
+			if (strcmp(stem, "mmc"))
+				continue;
+
+			list_del(&oldap->link);
+			break;
+		}
+	}
+	mutex_unlock(&of_mutex);
+
 	list_add_tail(&ap->link, &aliases_lookup);
 	debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
 	      ap->alias, ap->stem, ap->id, of_node_full_name(np));
@@ -766,6 +838,44 @@ int of_alias_get_id(const struct device_node *np, const char *stem)
 	return id;
 }
 
+struct device_node *of_alias_get_dev(const char *stem, int id)
+{
+	struct alias_prop *app;
+	struct device_node *np = NULL;
+
+	mutex_lock(&of_mutex);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		if (strcmp(app->stem, stem) != 0)
+			continue;
+
+		if (id == app->id) {
+			np = app->np;
+			break;
+		}
+	}
+	mutex_unlock(&of_mutex);
+
+	return np;
+}
+
+struct device_node *of_alias_dump(void)
+{
+	struct alias_prop *app;
+	struct device_node *np = NULL;
+
+	mutex_lock(&of_mutex);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		printf("%10s%d: %20s, phandle=%d %4s\n",
+		       app->stem, app->id,
+		       app->np->full_name, app->np->phandle,
+		       of_get_property(app->np, "u-boot,dm-pre-reloc", NULL) ||
+		       of_get_property(app->np, "u-boot,dm-spl", NULL) ? "*" : "");
+	}
+	mutex_unlock(&of_mutex);
+
+	return np;
+}
+
 struct device_node *of_get_stdout(void)
 {
 	return of_stdout;
diff --git a/drivers/core/of_addr.c b/drivers/core/of_addr.c
index 4757066967..7513ea2cf7 100644
--- a/drivers/core/of_addr.c
+++ b/drivers/core/of_addr.c
@@ -8,7 +8,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <dm/of_access.h>
 #include <dm/of_addr.h>
 #include <linux/err.h>
diff --git a/drivers/core/of_extra.c b/drivers/core/of_extra.c
index 0381909848..ca2e92b32b 100644
--- a/drivers/core/of_extra.c
+++ b/drivers/core/of_extra.c
@@ -6,7 +6,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <dm/of_access.h>
 #include <dm/of_extra.h>
 #include <dm/ofnode.h>
diff --git a/drivers/core/ofnode.c b/drivers/core/ofnode.c
index 0685b689d8..fe98b2e472 100644
--- a/drivers/core/ofnode.c
+++ b/drivers/core/ofnode.c
@@ -9,7 +9,7 @@
 #include <dm.h>
 #include <fdtdec.h>
 #include <fdt_support.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <dm/of_access.h>
 #include <dm/of_addr.h>
 #include <dm/ofnode.h>
@@ -56,6 +56,21 @@ int ofnode_read_s32_default(ofnode node, const char *propname, s32 def)
 	return def;
 }
 
+int ofnode_read_u64(ofnode node, const char *propname, u64 *outp)
+{
+	assert(ofnode_valid(node));
+	debug("%s: %s: ", __func__, propname);
+
+	if (ofnode_is_np(node)) {
+		return of_property_read_u64(ofnode_to_np(node), propname, outp);
+	} else {
+		printf("%s: not implement\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 bool ofnode_read_bool(ofnode node, const char *propname)
 {
 	const void *prop;
@@ -145,6 +160,21 @@ int ofnode_read_u32_array(ofnode node, const char *propname,
 	}
 }
 
+int ofnode_write_u32_array(ofnode node, const char *propname,
+			   u32 *values, size_t sz)
+{
+	assert(ofnode_valid(node));
+	debug("%s: %s: ", __func__, propname);
+
+	if (ofnode_is_np(node)) {
+		return of_write_u32_array(ofnode_to_np(node), propname,
+					 values, sz);
+	} else {
+		return fdt_setprop((void *)gd->fdt_blob, ofnode_to_offset(node),
+				   propname, values, sz);
+	}
+}
+
 ofnode ofnode_first_subnode(ofnode node)
 {
 	assert(ofnode_valid(node));
@@ -165,15 +195,45 @@ ofnode ofnode_next_subnode(ofnode node)
 		fdt_next_subnode(gd->fdt_blob, ofnode_to_offset(node)));
 }
 
-const char *ofnode_get_name(ofnode node)
+ofnode ofnode_get_parent(ofnode node)
 {
+	ofnode parent;
+
 	assert(ofnode_valid(node));
+	if (ofnode_is_np(node))
+		parent = np_to_ofnode(of_get_parent(ofnode_to_np(node)));
+	else
+		parent.of_offset = fdt_parent_offset(gd->fdt_blob,
+						     ofnode_to_offset(node));
+
+	return parent;
+}
+
+const char *ofnode_get_name(ofnode node)
+{
+	if(!ofnode_valid(node)){
+		debug("%s node not valid\n", __func__);
+		return NULL;
+	}
 	if (ofnode_is_np(node))
 		return strrchr(node.np->full_name, '/') + 1;
 
 	return fdt_get_name(gd->fdt_blob, ofnode_to_offset(node), NULL);
 }
 
+ofnode ofnode_get_by_phandle(uint phandle)
+{
+	ofnode node;
+
+	if (of_live_active())
+		node = np_to_ofnode(of_find_node_by_phandle(phandle));
+	else
+		node.of_offset = fdt_node_offset_by_phandle(gd->fdt_blob,
+							    phandle);
+
+	return node;
+}
+
 int ofnode_read_size(ofnode node, const char *propname)
 {
 	int len;
@@ -390,10 +450,11 @@ int ofnode_decode_display_timing(ofnode parent, int index,
 	if (!ofnode_valid(timings))
 		return -EINVAL;
 
-	for (i = 0, node = ofnode_first_subnode(timings);
-	     ofnode_valid(node) && i != index;
-	     node = ofnode_first_subnode(node))
-		i++;
+	i = 0;
+	ofnode_for_each_subnode(node, timings) {
+		if (i++ == index)
+			break;
+	}
 
 	if (!ofnode_valid(node))
 		return -EINVAL;
@@ -467,8 +528,10 @@ fdt_addr_t ofnode_get_addr_size(ofnode node, const char *property,
 		int na, ns;
 		int psize;
 		const struct device_node *np = ofnode_to_np(node);
-		const __be32 *prop = of_get_property(np, "reg", &psize);
+		const __be32 *prop = of_get_property(np, property, &psize);
 
+		if (!prop)
+			return FDT_ADDR_T_NONE;
 		na = of_n_addr_cells(np);
 		ns = of_n_addr_cells(np);
 		*sizep = of_read_number(prop + na, ns);
@@ -639,3 +702,11 @@ int ofnode_read_resource_byname(ofnode node, const char *name,
 
 	return ofnode_read_resource(node, index, res);
 }
+
+u64 ofnode_translate_address(ofnode node, const fdt32_t *in_addr)
+{
+	if (ofnode_is_np(node))
+		return of_translate_address(ofnode_to_np(node), in_addr);
+	else
+		return fdt_translate_address(gd->fdt_blob, ofnode_to_offset(node), in_addr);
+}
diff --git a/drivers/core/read.c b/drivers/core/read.c
index 6acb33388f..5b8acf14f6 100644
--- a/drivers/core/read.c
+++ b/drivers/core/read.c
@@ -7,6 +7,7 @@
 
 #include <common.h>
 #include <dm.h>
+#include <mapmem.h>
 #include <dm/of_access.h>
 
 int dev_read_u32_default(struct udevice *dev, const char *propname, int def)
@@ -14,6 +15,11 @@ int dev_read_u32_default(struct udevice *dev, const char *propname, int def)
 	return ofnode_read_u32_default(dev_ofnode(dev), propname, def);
 }
 
+int dev_read_s32_default(struct udevice *dev, const char *propname, int def)
+{
+	return ofnode_read_s32_default(dev_ofnode(dev), propname, def);
+}
+
 const char *dev_read_string(struct udevice *dev, const char *propname)
 {
 	return ofnode_read_string(dev_ofnode(dev), propname);
@@ -57,6 +63,13 @@ fdt_addr_t dev_read_addr(struct udevice *dev)
 	return dev_read_addr_index(dev, 0);
 }
 
+void *dev_read_addr_ptr(struct udevice *dev)
+{
+	fdt_addr_t addr = dev_read_addr(dev);
+
+	return (addr == FDT_ADDR_T_NONE) ? NULL : map_sysmem(addr, 0);
+}
+
 fdt_addr_t dev_read_addr_size(struct udevice *dev, const char *property,
 				fdt_size_t *sizep)
 {
@@ -65,6 +78,9 @@ fdt_addr_t dev_read_addr_size(struct udevice *dev, const char *property,
 
 const char *dev_read_name(struct udevice *dev)
 {
+	if (!dev_of_valid(dev))
+		return NULL;
+
 	return ofnode_get_name(dev_ofnode(dev));
 }
 
@@ -74,6 +90,17 @@ int dev_read_stringlist_search(struct udevice *dev, const char *property,
 	return ofnode_stringlist_search(dev_ofnode(dev), property, string);
 }
 
+int dev_read_string_index(struct udevice *dev, const char *propname, int index,
+			  const char **outp)
+{
+	return ofnode_read_string_index(dev_ofnode(dev), propname, index, outp);
+}
+
+int dev_read_string_count(struct udevice *dev, const char *propname)
+{
+	return ofnode_read_string_count(dev_ofnode(dev), propname);
+}
+
 int dev_read_phandle_with_args(struct udevice *dev, const char *list_name,
 				const char *cells_name, int cell_count,
 				int index,
@@ -84,6 +111,14 @@ int dev_read_phandle_with_args(struct udevice *dev, const char *list_name,
 					      out_args);
 }
 
+int dev_count_phandle_with_args(struct udevice *dev,
+		const char *list_name, const char *cells_name)
+{
+	return ofnode_count_phandle_with_args(dev_ofnode(dev), list_name,
+					      cells_name);
+}
+
+
 int dev_read_addr_cells(struct udevice *dev)
 {
 	return ofnode_read_addr_cells(dev_ofnode(dev));
@@ -140,9 +175,19 @@ int dev_read_alias_seq(struct udevice *dev, int *devnump)
 int dev_read_u32_array(struct udevice *dev, const char *propname,
 		       u32 *out_values, size_t sz)
 {
+	if (!dev_of_valid(dev))
+		return -EINVAL;
 	return ofnode_read_u32_array(dev_ofnode(dev), propname, out_values, sz);
 }
 
+int dev_write_u32_array(struct udevice *dev, const char *propname,
+			u32 *values, size_t sz)
+{
+	if (!dev_of_valid(dev))
+		return -EINVAL;
+	return ofnode_write_u32_array(dev_ofnode(dev), propname, values, sz);
+}
+
 const uint8_t *dev_read_u8_array_ptr(struct udevice *dev, const char *propname,
 				     size_t sz)
 {
@@ -170,3 +215,8 @@ int dev_read_resource_byname(struct udevice *dev, const char *name,
 {
 	return ofnode_read_resource_byname(dev_ofnode(dev), name, res);
 }
+
+u64 dev_translate_address(struct udevice *dev, const fdt32_t *in_addr)
+{
+	return ofnode_translate_address(dev_ofnode(dev), in_addr);
+}
diff --git a/drivers/core/regmap.c b/drivers/core/regmap.c
index d4e16a27ef..ab1f6a4964 100644
--- a/drivers/core/regmap.c
+++ b/drivers/core/regmap.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <mapmem.h>
 #include <regmap.h>
@@ -40,7 +40,7 @@ static struct regmap *regmap_alloc_count(int count)
 }
 
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
-int regmap_init_mem_platdata(struct udevice *dev, u32 *reg, int count,
+int regmap_init_mem_platdata(struct udevice *dev, fdt_val_t *reg, int count,
 			     struct regmap **mapp)
 {
 	struct regmap_range *range;
@@ -96,9 +96,7 @@ int regmap_init_mem(struct udevice *dev, struct regmap **mapp)
 			range->start = r.start;
 			range->size = r.end - r.start + 1;
 		} else {
-			range->start = fdtdec_get_addr_size_fixed(gd->fdt_blob,
-					dev_of_offset(dev), "reg", index,
-					addr_len, size_len, &sz, true);
+			range->start = devfdt_get_addr_size_index(dev, index, &sz);
 			range->size = sz;
 		}
 	}
@@ -147,3 +145,17 @@ int regmap_write(struct regmap *map, uint offset, uint val)
 
 	return 0;
 }
+
+int regmap_update_bits(struct regmap *map, uint offset, uint mask, uint val)
+{
+	uint reg;
+	int ret;
+
+	ret = regmap_read(map, offset, &reg);
+	if (ret)
+		return ret;
+
+	reg &= ~mask;
+
+	return regmap_write(map, offset, reg | val);
+}
diff --git a/drivers/core/root.c b/drivers/core/root.c
index d691d6ff94..c928256d12 100644
--- a/drivers/core/root.c
+++ b/drivers/core/root.c
@@ -11,7 +11,7 @@
 #include <errno.h>
 #include <fdtdec.h>
 #include <malloc.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <dm/device.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
@@ -224,10 +224,15 @@ static int dm_scan_fdt_live(struct udevice *parent,
 
 	for (np = node_parent->child; np; np = np->sibling) {
 		if (pre_reloc_only &&
-		    !of_find_property(np, "u-boot,dm-pre-reloc", NULL))
+#ifdef CONFIG_USING_KERNEL_DTB
+		    (!of_find_property(np, "u-boot,dm-pre-reloc", NULL) &&
+		     !of_find_property(np, "u-boot,dm-spl", NULL)))
+#else
+		     !of_find_property(np, "u-boot,dm-pre-reloc", NULL))
+#endif
 			continue;
 		if (!of_device_is_available(np)) {
-			dm_dbg("   - ignoring disabled device\n");
+			pr_debug("   - ignoring disabled device\n");
 			continue;
 		}
 		err = lists_bind_fdt(parent, np_to_ofnode(np), NULL);
@@ -235,6 +240,11 @@ static int dm_scan_fdt_live(struct udevice *parent,
 			ret = err;
 			debug("%s: ret=%d\n", np->name, ret);
 		}
+
+		/* There is no compatible in "/firmware", bind it by default. */
+		if (!pre_reloc_only && !strcmp(np->name, "firmware"))
+			ret = device_bind_driver_to_node(gd->dm_root,
+				"firmware", np->name, np_to_ofnode(np), NULL);
 	}
 
 	if (ret)
@@ -262,6 +272,7 @@ static int dm_scan_fdt_node(struct udevice *parent, const void *blob,
 			    int offset, bool pre_reloc_only)
 {
 	int ret = 0, err;
+	const char *name;
 
 	for (offset = fdt_first_subnode(blob, offset);
 	     offset > 0;
@@ -270,7 +281,7 @@ static int dm_scan_fdt_node(struct udevice *parent, const void *blob,
 		    !dm_fdt_pre_reloc(blob, offset))
 			continue;
 		if (!fdtdec_get_is_enabled(blob, offset)) {
-			dm_dbg("   - ignoring disabled device\n");
+			pr_debug("   - ignoring disabled device\n");
 			continue;
 		}
 		err = lists_bind_fdt(parent, offset_to_ofnode(offset), NULL);
@@ -279,6 +290,12 @@ static int dm_scan_fdt_node(struct udevice *parent, const void *blob,
 			debug("%s: ret=%d\n", fdt_get_name(blob, offset, NULL),
 			      ret);
 		}
+
+		/* There is no compatible in "/firmware", bind it by default. */
+		name = fdt_get_name(blob, offset, NULL);
+		if (name && !strcmp(name, "firmware"))
+			ret = device_bind_driver_to_node(parent, "firmware",
+					name, offset_to_ofnode(offset), NULL);
 	}
 
 	if (ret)
@@ -312,8 +329,38 @@ int dm_scan_fdt(const void *blob, bool pre_reloc_only)
 #endif
 	return dm_scan_fdt_node(gd->dm_root, blob, 0, pre_reloc_only);
 }
+#else
+static int dm_scan_fdt_node(struct udevice *parent, const void *blob,
+			    int offset, bool pre_reloc_only)
+{
+	return 0;
+}
 #endif
 
+int dm_extended_scan_fdt(const void *blob, bool pre_reloc_only)
+{
+	int node, ret;
+
+	ret = dm_scan_fdt(gd->fdt_blob, pre_reloc_only);
+	if (ret) {
+		debug("dm_scan_fdt() failed: %d\n", ret);
+		return ret;
+	}
+
+	/* bind fixed-clock */
+	node = ofnode_to_offset(ofnode_path("/clocks"));
+	/* if no DT "clocks" node, no need to go further */
+	if (node < 0)
+		return ret;
+
+	ret = dm_scan_fdt_node(gd->dm_root, gd->fdt_blob, node,
+			       pre_reloc_only);
+	if (ret)
+		debug("dm_scan_fdt_node() failed: %d\n", ret);
+
+	return ret;
+}
+
 __weak int dm_scan_other(bool pre_reloc_only)
 {
 	return 0;
@@ -335,9 +382,9 @@ int dm_init_and_scan(bool pre_reloc_only)
 	}
 
 	if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) {
-		ret = dm_scan_fdt(gd->fdt_blob, pre_reloc_only);
+		ret = dm_extended_scan_fdt(gd->fdt_blob, pre_reloc_only);
 		if (ret) {
-			debug("dm_scan_fdt() failed: %d\n", ret);
+			debug("dm_extended_scan_dt() failed: %d\n", ret);
 			return ret;
 		}
 	}
diff --git a/drivers/core/simple-bus.c b/drivers/core/simple-bus.c
index 14803e32b1..5acfa5f0e4 100644
--- a/drivers/core/simple-bus.c
+++ b/drivers/core/simple-bus.c
@@ -7,8 +7,6 @@
 #include <common.h>
 #include <dm.h>
 
-DECLARE_GLOBAL_DATA_PTR;
-
 struct simple_bus_plat {
 	u32 base;
 	u32 size;
diff --git a/drivers/core/syscon-uclass.c b/drivers/core/syscon-uclass.c
index a69937e63c..5f5a9f8f42 100644
--- a/drivers/core/syscon-uclass.c
+++ b/drivers/core/syscon-uclass.c
@@ -45,6 +45,25 @@ static int syscon_pre_probe(struct udevice *dev)
 #endif
 }
 
+struct regmap *syscon_regmap_lookup_by_phandle(struct udevice *dev,
+					       const char *name)
+{
+	struct udevice *syscon;
+	struct regmap *r;
+	int err;
+
+	err = uclass_get_device_by_phandle(UCLASS_SYSCON, dev,
+					   name, &syscon);
+	if (err)
+		return ERR_PTR(err);
+
+	r = syscon_get_regmap(syscon);
+	if (!r)
+		return ERR_PTR(-ENODEV);
+
+	return r;
+}
+
 int syscon_get_by_driver_data(ulong driver_data, struct udevice **devp)
 {
 	struct udevice *dev;
diff --git a/drivers/core/uclass.c b/drivers/core/uclass.c
index f5e4067922..02f1bebd80 100644
--- a/drivers/core/uclass.c
+++ b/drivers/core/uclass.c
@@ -34,6 +34,9 @@ struct uclass *uclass_find(enum uclass_id key)
 	list_for_each_entry(uc, &gd->uclass_root, sibling_node) {
 		if (uc->uc_drv->id == key)
 			return uc;
+
+		if (uc->uc_drv->id == UCLASS_ROOT)
+			break;
 	}
 
 	return NULL;
@@ -77,6 +80,9 @@ static int uclass_add(enum uclass_id id, struct uclass **ucp)
 		}
 	}
 	uc->uc_drv = uc_drv;
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+	uc->u_boot_dev_head = NULL;
+#endif
 	INIT_LIST_HEAD(&uc->sibling_node);
 	INIT_LIST_HEAD(&uc->dev_head);
 	list_add(&uc->sibling_node, &DM_UCLASS_ROOT_NON_CONST);
@@ -158,6 +164,20 @@ const char *uclass_get_name(enum uclass_id id)
 	return uc->uc_drv->name;
 }
 
+enum uclass_id uclass_get_by_name(const char *name)
+{
+	int i;
+
+	for (i = 0; i < UCLASS_COUNT; i++) {
+		struct uclass_driver *uc_drv = lists_uclass_lookup(i);
+
+		if (uc_drv && !strcmp(uc_drv->name, name))
+			return i;
+	}
+
+	return UCLASS_INVALID;
+}
+
 int uclass_find_device(enum uclass_id id, int index, struct udevice **devp)
 {
 	struct uclass *uc;
@@ -243,7 +263,7 @@ int uclass_find_device_by_seq(enum uclass_id id, int seq_or_req_seq,
 	int ret;
 
 	*devp = NULL;
-	debug("%s: %d %d\n", __func__, find_req_seq, seq_or_req_seq);
+	pr_debug("%s: %d %d\n", __func__, find_req_seq, seq_or_req_seq);
 	if (seq_or_req_seq == -1)
 		return -ENODEV;
 	ret = uclass_get(id, &uc);
@@ -251,15 +271,15 @@ int uclass_find_device_by_seq(enum uclass_id id, int seq_or_req_seq,
 		return ret;
 
 	list_for_each_entry(dev, &uc->dev_head, uclass_node) {
-		debug("   - %d %d '%s'\n", dev->req_seq, dev->seq, dev->name);
+		pr_debug("   - %d %d '%s'\n", dev->req_seq, dev->seq, dev->name);
 		if ((find_req_seq ? dev->req_seq : dev->seq) ==
 				seq_or_req_seq) {
 			*devp = dev;
-			debug("   - found\n");
+			pr_debug("   - found\n");
 			return 0;
 		}
 	}
-	debug("   - not found\n");
+	pr_debug("   - not found\n");
 
 	return -ENODEV;
 }
@@ -443,6 +463,34 @@ int uclass_get_device_by_ofnode(enum uclass_id id, ofnode node,
 }
 
 #if CONFIG_IS_ENABLED(OF_CONTROL)
+int uclass_get_device_by_phandle_id(enum uclass_id id, uint phandle_id,
+				    struct udevice **devp)
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret;
+
+	*devp = NULL;
+	ret = uclass_get(id, &uc);
+	if (ret)
+		return ret;
+
+	ret = -ENODEV;
+	list_for_each_entry(dev, &uc->dev_head, uclass_node) {
+		uint phandle;
+
+		phandle = dev_read_phandle(dev);
+
+		if (phandle == phandle_id) {
+			*devp = dev;
+			ret = 0;
+			break;
+		}
+	}
+
+	return uclass_get_device_tail(dev, ret, devp);
+}
+
 int uclass_get_device_by_phandle(enum uclass_id id, struct udevice *parent,
 				 const char *name, struct udevice **devp)
 {
@@ -519,14 +567,20 @@ int uclass_next_device_check(struct udevice **devp)
 	return device_probe(*devp);
 }
 
-int uclass_bind_device(struct udevice *dev)
+int uclass_bind_device(struct udevice *dev, bool after_u_boot_dev)
 {
 	struct uclass *uc;
 	int ret;
 
 	uc = dev->uclass;
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+	if (after_u_boot_dev)
+		list_add_tail(&dev->uclass_node, &uc->dev_head);
+	else
+		list_add_tail(&dev->uclass_node, uc->u_boot_dev_head);
+#else
 	list_add_tail(&dev->uclass_node, &uc->dev_head);
-
+#endif
 	if (dev->parent) {
 		struct uclass_driver *uc_drv = dev->parent->uclass->uc_drv;
 
@@ -641,3 +695,8 @@ int uclass_pre_remove_device(struct udevice *dev)
 	return 0;
 }
 #endif
+
+UCLASS_DRIVER(nop) = {
+	.id		= UCLASS_NOP,
+	.name		= "nop",
+};
diff --git a/drivers/core/util.c b/drivers/core/util.c
index 2e232d57a1..24abe1445b 100644
--- a/drivers/core/util.c
+++ b/drivers/core/util.c
@@ -6,7 +6,7 @@
 
 #include <common.h>
 #include <dm/util.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <vsprintf.h>
 
 #ifdef CONFIG_DM_WARN
@@ -20,17 +20,6 @@ void dm_warn(const char *fmt, ...)
 }
 #endif
 
-#ifdef DEBUG
-void dm_dbg(const char *fmt, ...)
-{
-	va_list args;
-
-	va_start(args, fmt);
-	vprintf(fmt, args);
-	va_end(args);
-}
-#endif
-
 int list_count_items(struct list_head *head)
 {
 	struct list_head *node;
diff --git a/drivers/cpu/Kconfig b/drivers/cpu/Kconfig
index 0d1424d38e..6dfced4f4f 100644
--- a/drivers/cpu/Kconfig
+++ b/drivers/cpu/Kconfig
@@ -6,3 +6,15 @@ config CPU
 	  multiple CPUs, then normally have to be set up in U-Boot so that
 	  they can work correctly in the OS. This provides a framework for
 	  finding out information about available CPUs and making changes.
+
+config AMP
+	bool "Enable AMP drivers using Driver Model"
+	help
+	  This support Asymmetric Multi-Processing, cpus can run on different
+	  firmware.
+
+config ROCKCHIP_AMP
+	bool "Enable Rockchip AMP driver"
+	depends on AMP && ROCKCHIP_SMCCC && RKIMG_BOOTLOADER
+	help
+	  This enable Rockchip AMP driver support.
diff --git a/drivers/cpu/Makefile b/drivers/cpu/Makefile
index db515f6f17..963bf1e341 100644
--- a/drivers/cpu/Makefile
+++ b/drivers/cpu/Makefile
@@ -7,3 +7,4 @@
 obj-$(CONFIG_CPU) += cpu-uclass.o
 
 obj-$(CONFIG_ARCH_BMIPS) += bmips_cpu.o
+obj-$(CONFIG_ROCKCHIP_AMP) += rockchip_amp.o
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 1ea116be75..69f405460e 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -1,5 +1,18 @@
 menu "Hardware crypto devices"
 
+config DM_CRYPTO
+	bool "Enable Driver Model for CRYPTO drivers (UCLASS_CRYPTO)"
+	depends on DM
+	---help---
+	This config enables the dm crypto support.
+
+config SPL_DM_CRYPTO
+	bool "Enable Driver Model for CRYPTO drivers in spl"
+	depends on SPL_DM
+	---help---
+	This config enables the dm crypto support.
+
 source drivers/crypto/fsl/Kconfig
+source drivers/crypto/rockchip/Kconfig
 
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index fb8c10b38c..e54de414ec 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -5,6 +5,8 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-$(CONFIG_EXYNOS_ACE_SHA)	+= ace_sha.o
+obj-$(CONFIG_$(SPL_TPL_)DM_CRYPTO) += crypto-uclass.o
+obj-$(CONFIG_EXYNOS_ACE_SHA) += ace_sha.o
 obj-y += rsa_mod_exp/
 obj-y += fsl/
+obj-y += rockchip/
diff --git a/drivers/crypto/fsl/sec.c b/drivers/crypto/fsl/sec.c
index 0940faf768..470e662d8e 100644
--- a/drivers/crypto/fsl/sec.c
+++ b/drivers/crypto/fsl/sec.c
@@ -5,7 +5,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #if CONFIG_SYS_FSL_SEC_COMPAT == 2 || CONFIG_SYS_FSL_SEC_COMPAT >= 4
 #include <fsl_sec.h>
diff --git a/drivers/ddr/microchip/ddr2.c b/drivers/ddr/microchip/ddr2.c
index 6056418588..a52427c3d6 100644
--- a/drivers/ddr/microchip/ddr2.c
+++ b/drivers/ddr/microchip/ddr2.c
@@ -57,8 +57,8 @@ static int ddr2_phy_calib_start(void)
 	writel(SCL_START | SCL_EN, &ddr2_phy->scl_start);
 
 	/* Wait for SCL for data byte to pass */
-	return wait_for_bit(__func__, &ddr2_phy->scl_start, SCL_LUBPASS,
-			    true, CONFIG_SYS_HZ, false);
+	return wait_for_bit_le32(&ddr2_phy->scl_start, SCL_LUBPASS,
+				 true, CONFIG_SYS_HZ, false);
 }
 
 /* DDR2 Controller initialization */
@@ -256,8 +256,8 @@ void ddr2_ctrl_init(void)
 	writel(INIT_START, &ctrl->memcon);
 
 	/* wait for all host cmds to be transmitted */
-	wait_for_bit(__func__, &ctrl->cmdissue, CMD_VALID, false,
-		     CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(&ctrl->cmdissue, CMD_VALID, false,
+			  CONFIG_SYS_HZ, false);
 
 	/* inform all cmds issued, ready for normal operation */
 	writel(INIT_START | INIT_DONE, &ctrl->memcon);
diff --git a/drivers/dfu/Kconfig b/drivers/dfu/Kconfig
index 56a98f5273..f0ceede2d1 100644
--- a/drivers/dfu/Kconfig
+++ b/drivers/dfu/Kconfig
@@ -23,6 +23,12 @@ config DFU_NAND
 	  This option enables using DFU to read and write to NAND based
 	  storage.
 
+config DFU_MTD
+	bool "MTD back end for DFU"
+	help
+	  This option enables using DFU to read and write to MTD based
+	  storage.
+
 config DFU_RAM
 	bool "RAM back end for DFU"
 	help
diff --git a/drivers/dfu/Makefile b/drivers/dfu/Makefile
index 61f2b71f91..c769d8c52a 100644
--- a/drivers/dfu/Makefile
+++ b/drivers/dfu/Makefile
@@ -7,6 +7,7 @@
 
 obj-$(CONFIG_USB_FUNCTION_DFU) += dfu.o
 obj-$(CONFIG_DFU_MMC) += dfu_mmc.o
+obj-$(CONFIG_DFU_MTD) += dfu_mtd.o
 obj-$(CONFIG_DFU_NAND) += dfu_nand.o
 obj-$(CONFIG_DFU_RAM) += dfu_ram.o
 obj-$(CONFIG_DFU_SF) += dfu_sf.o
diff --git a/drivers/dfu/dfu.c b/drivers/dfu/dfu.c
index ff732ac309..7bd5389b2b 100644
--- a/drivers/dfu/dfu.c
+++ b/drivers/dfu/dfu.c
@@ -64,14 +64,14 @@ int dfu_init_env_entities(char *interface, char *devstr)
 #endif
 	str_env = env_get("dfu_alt_info");
 	if (!str_env) {
-		error("\"dfu_alt_info\" env variable not defined!\n");
+		pr_err("\"dfu_alt_info\" env variable not defined!\n");
 		return -EINVAL;
 	}
 
 	env_bkp = strdup(str_env);
 	ret = dfu_config_entities(env_bkp, interface, devstr);
 	if (ret) {
-		error("DFU entities configuration failed!\n");
+		pr_err("DFU entities configuration failed!\n");
 		return ret;
 	}
 
@@ -132,7 +132,7 @@ static char *dfu_get_hash_algo(void)
 		return s;
 	}
 
-	error("DFU hash method: %s not supported!\n", s);
+	pr_err("DFU hash method: %s not supported!\n", s);
 	return NULL;
 }
 
@@ -273,7 +273,7 @@ int dfu_write(struct dfu_entity *dfu, void *buf, int size, int blk_seq_num)
 
 	/* we should be in buffer now (if not then size too large) */
 	if ((dfu->i_buf + size) > dfu->i_buf_end) {
-		error("Buffer overflow! (0x%p + 0x%x > 0x%p)\n", dfu->i_buf,
+		pr_err("Buffer overflow! (0x%p + 0x%x > 0x%p)\n", dfu->i_buf,
 		      size, dfu->i_buf_end);
 		dfu_transaction_cleanup(dfu);
 		return -1;
@@ -400,6 +400,9 @@ static int dfu_fill_entity(struct dfu_entity *dfu, char *s, int alt,
 	if (strcmp(interface, "mmc") == 0) {
 		if (dfu_fill_entity_mmc(dfu, devstr, s))
 			return -1;
+	} else if (strcmp(interface, "mtd") == 0) {
+		if (dfu_fill_entity_mtd(dfu, devstr, s))
+			return -1;
 	} else if (strcmp(interface, "nand") == 0) {
 		if (dfu_fill_entity_nand(dfu, devstr, s))
 			return -1;
@@ -451,7 +454,7 @@ int dfu_config_entities(char *env, char *interface, char *devstr)
 	if (s) {
 		ret = hash_lookup_algo(s, &dfu_hash_algo);
 		if (ret)
-			error("Hash algorithm %s not supported\n", s);
+			pr_err("Hash algorithm %s not supported\n", s);
 	}
 
 	dfu = calloc(sizeof(*dfu), dfu_alt_num);
@@ -576,7 +579,7 @@ int dfu_write_from_mem_addr(struct dfu_entity *dfu, void *buf, int size)
 		      dp, left, write);
 		ret = dfu_write(dfu, dp, write, i);
 		if (ret) {
-			error("DFU write failed\n");
+			pr_err("DFU write failed\n");
 			return ret;
 		}
 
@@ -586,7 +589,7 @@ int dfu_write_from_mem_addr(struct dfu_entity *dfu, void *buf, int size)
 
 	ret = dfu_flush(dfu, NULL, 0, i);
 	if (ret)
-		error("DFU flush failed!");
+		pr_err("DFU flush failed!");
 
 	return ret;
 }
diff --git a/drivers/dfu/dfu_mmc.c b/drivers/dfu/dfu_mmc.c
index 39e10b1a5a..47948d369d 100644
--- a/drivers/dfu/dfu_mmc.c
+++ b/drivers/dfu/dfu_mmc.c
@@ -29,7 +29,7 @@ static int mmc_block_op(enum dfu_op op, struct dfu_entity *dfu,
 
 	mmc = find_mmc_device(dfu->data.mmc.dev_num);
 	if (!mmc) {
-		error("Device MMC %d - not found!", dfu->data.mmc.dev_num);
+		pr_err("Device MMC %d - not found!", dfu->data.mmc.dev_num);
 		return -ENODEV;
 	}
 
@@ -69,11 +69,11 @@ static int mmc_block_op(enum dfu_op op, struct dfu_entity *dfu,
 			       buf);
 		break;
 	default:
-		error("Operation not supported\n");
+		pr_err("Operation not supported\n");
 	}
 
 	if (n != blk_count) {
-		error("MMC operation failed");
+		pr_err("MMC operation failed");
 		if (dfu->data.mmc.hw_partition >= 0)
 			blk_select_hwpart_devnum(IF_TYPE_MMC,
 						 dfu->data.mmc.dev_num,
@@ -312,7 +312,7 @@ int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr, char *s)
 	for (; parg < argv + sizeof(argv) / sizeof(*argv); ++parg) {
 		*parg = strsep(&s, " ");
 		if (*parg == NULL) {
-			error("Invalid number of arguments.\n");
+			pr_err("Invalid number of arguments.\n");
 			return -ENODEV;
 		}
 	}
@@ -327,13 +327,13 @@ int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr, char *s)
 
 	mmc = find_mmc_device(dfu->data.mmc.dev_num);
 	if (mmc == NULL) {
-		error("Couldn't find MMC device no. %d.\n",
+		pr_err("Couldn't find MMC device no. %d.\n",
 		      dfu->data.mmc.dev_num);
 		return -ENODEV;
 	}
 
 	if (mmc_init(mmc)) {
-		error("Couldn't init MMC device.\n");
+		pr_err("Couldn't init MMC device.\n");
 		return -ENODEV;
 	}
 
@@ -360,7 +360,7 @@ int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr, char *s)
 		int mmcpart = third_arg;
 
 		if (part_get_info(blk_dev, mmcpart, &partinfo) != 0) {
-			error("Couldn't find part #%d on mmc device #%d\n",
+			pr_err("Couldn't find part #%d on mmc device #%d\n",
 			      mmcpart, mmcdev);
 			return -ENODEV;
 		}
@@ -374,7 +374,7 @@ int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr, char *s)
 	} else if (!strcmp(entity_type, "ext4")) {
 		dfu->layout = DFU_FS_EXT4;
 	} else {
-		error("Memory layout (%s) not supported!\n", entity_type);
+		pr_err("Memory layout (%s) not supported!\n", entity_type);
 		return -ENODEV;
 	}
 
@@ -397,7 +397,7 @@ int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr, char *s)
 		dfu_file_buf = memalign(CONFIG_SYS_CACHELINE_SIZE,
 					CONFIG_SYS_DFU_MAX_FILE_SIZE);
 		if (!dfu_file_buf) {
-			error("Could not memalign 0x%x bytes",
+			pr_err("Could not memalign 0x%x bytes",
 			      CONFIG_SYS_DFU_MAX_FILE_SIZE);
 			return -ENOMEM;
 		}
diff --git a/drivers/dfu/dfu_nand.c b/drivers/dfu/dfu_nand.c
index 6dc9ff7aea..23dfc8e519 100644
--- a/drivers/dfu/dfu_nand.c
+++ b/drivers/dfu/dfu_nand.c
@@ -192,8 +192,9 @@ unsigned int dfu_polltimeout_nand(struct dfu_entity *dfu)
 int dfu_fill_entity_nand(struct dfu_entity *dfu, char *devstr, char *s)
 {
 	char *st;
+#ifndef CONFIG_SPL_BUILD
 	int ret, dev, part;
-
+#endif
 	dfu->data.nand.ubi = 0;
 	dfu->dev_type = DFU_DEV_NAND;
 	st = strsep(&s, " ");
@@ -203,6 +204,7 @@ int dfu_fill_entity_nand(struct dfu_entity *dfu, char *devstr, char *s)
 		s++;
 		dfu->data.nand.size = simple_strtoul(s, &s, 16);
 	} else if ((!strcmp(st, "part")) || (!strcmp(st, "partubi"))) {
+#ifndef CONFIG_SPL_BUILD
 		char mtd_id[32];
 		struct mtd_device *mtd_dev;
 		u8 part_num;
@@ -229,6 +231,7 @@ int dfu_fill_entity_nand(struct dfu_entity *dfu, char *devstr, char *s)
 		dfu->data.nand.size = pi->size;
 		if (!strcmp(st, "partubi"))
 			dfu->data.nand.ubi = 1;
+#endif
 	} else {
 		printf("%s: Memory layout (%s) not supported!\n", __func__, st);
 		return -1;
diff --git a/drivers/dfu/dfu_ram.c b/drivers/dfu/dfu_ram.c
index 6e3f5316f5..2b5e05a913 100644
--- a/drivers/dfu/dfu_ram.c
+++ b/drivers/dfu/dfu_ram.c
@@ -18,12 +18,12 @@ static int dfu_transfer_medium_ram(enum dfu_op op, struct dfu_entity *dfu,
 				   u64 offset, void *buf, long *len)
 {
 	if (dfu->layout != DFU_RAM_ADDR) {
-		error("unsupported layout: %s\n", dfu_get_layout(dfu->layout));
+		pr_err("unsupported layout: %s\n", dfu_get_layout(dfu->layout));
 		return  -EINVAL;
 	}
 
 	if (offset > dfu->data.ram.size) {
-		error("request exceeds allowed area\n");
+		pr_err("request exceeds allowed area\n");
 		return -EINVAL;
 	}
 
@@ -62,14 +62,14 @@ int dfu_fill_entity_ram(struct dfu_entity *dfu, char *devstr, char *s)
 	for (; parg < argv + sizeof(argv) / sizeof(*argv); ++parg) {
 		*parg = strsep(&s, " ");
 		if (*parg == NULL) {
-			error("Invalid number of arguments.\n");
+			pr_err("Invalid number of arguments.\n");
 			return -ENODEV;
 		}
 	}
 
 	dfu->dev_type = DFU_DEV_RAM;
 	if (strcmp(argv[0], "ram")) {
-		error("unsupported device: %s\n", argv[0]);
+		pr_err("unsupported device: %s\n", argv[0]);
 		return -ENODEV;
 	}
 
diff --git a/drivers/dfu/dfu_tftp.c b/drivers/dfu/dfu_tftp.c
index cd71708231..62bf797dac 100644
--- a/drivers/dfu/dfu_tftp.c
+++ b/drivers/dfu/dfu_tftp.c
@@ -43,7 +43,7 @@ int dfu_tftp_write(char *dfu_entity_name, unsigned int addr, unsigned int len,
 	alt_setting_num = dfu_get_alt(sb);
 	free(sb);
 	if (alt_setting_num < 0) {
-		error("Alt setting [%d] to write not found!",
+		pr_err("Alt setting [%d] to write not found!",
 		      alt_setting_num);
 		ret = -ENODEV;
 		goto done;
@@ -51,7 +51,7 @@ int dfu_tftp_write(char *dfu_entity_name, unsigned int addr, unsigned int len,
 
 	dfu = dfu_get_entity(alt_setting_num);
 	if (!dfu) {
-		error("DFU entity for alt: %d not found!", alt_setting_num);
+		pr_err("DFU entity for alt: %d not found!", alt_setting_num);
 		ret = -ENODEV;
 		goto done;
 	}
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 1b92c7789d..4ee6afad35 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -19,4 +19,19 @@ config TI_EDMA3
 	  This driver support data transfer between memory
 	  regions.
 
+config APBH_DMA
+	bool "Support APBH DMA"
+	depends on MX23 || MX28 || MX6 || MX7
+	help
+	  Enable APBH DMA driver.
+
+if APBH_DMA
+config APBH_DMA_BURST
+	bool "Enable DMA BURST"
+
+config APBH_DMA_BURST8
+	bool "Enable DMA BURST8"
+
+endif
+
 endmenu # menu "DMA Support"
diff --git a/drivers/dma/dma-uclass.c b/drivers/dma/dma-uclass.c
index ea21fd9c6f..3d0ce22fbc 100644
--- a/drivers/dma/dma-uclass.c
+++ b/drivers/dma/dma-uclass.c
@@ -33,7 +33,7 @@ int dma_get_device(u32 transfer_type, struct udevice **devp)
 	}
 
 	if (!dev) {
-		error("No DMA device found that supports %x type\n",
+		pr_err("No DMA device found that supports %x type\n",
 		      transfer_type);
 		return -EPROTONOSUPPORT;
 	}
diff --git a/drivers/dma/lpc32xx_dma.c b/drivers/dma/lpc32xx_dma.c
index 955adfeccd..63a8a2f340 100644
--- a/drivers/dma/lpc32xx_dma.c
+++ b/drivers/dma/lpc32xx_dma.c
@@ -96,7 +96,7 @@ int lpc32xx_dma_start_xfer(unsigned int channel,
 {
 	if (unlikely(((BIT_MASK(channel) & alloc_ch) == 0) ||
 		     (channel >= DMA_NO_OF_CHANNELS))) {
-		error("Request for xfer on unallocated channel %d", channel);
+		pr_err("Request for xfer on unallocated channel %d", channel);
 		return -1;
 	}
 	writel(BIT_MASK(channel), &dma->int_tc_clear);
@@ -117,7 +117,7 @@ int lpc32xx_dma_wait_status(unsigned int channel)
 
 	/* Check if given channel is valid */
 	if (unlikely(channel >= DMA_NO_OF_CHANNELS)) {
-		error("Request for status on unallocated channel %d", channel);
+		pr_err("Request for status on unallocated channel %d", channel);
 		return -1;
 	}
 
@@ -129,7 +129,7 @@ int lpc32xx_dma_wait_status(unsigned int channel)
 			break;
 
 		if (get_timer(start) > CONFIG_SYS_HZ) {
-			error("DMA status timeout channel %d\n", channel);
+			pr_err("DMA status timeout channel %d\n", channel);
 			return -ETIMEDOUT;
 		}
 		udelay(1);
@@ -138,7 +138,7 @@ int lpc32xx_dma_wait_status(unsigned int channel)
 	if (unlikely(readl(&dma->raw_err_stat) & BIT_MASK(channel))) {
 		setbits_le32(&dma->int_err_clear, BIT_MASK(channel));
 		setbits_le32(&dma->raw_err_stat, BIT_MASK(channel));
-		error("DMA error on channel %d\n", channel);
+		pr_err("DMA error on channel %d\n", channel);
 		return -1;
 	}
 	setbits_le32(&dma->int_tc_clear, BIT_MASK(channel));
diff --git a/drivers/dma/ti-edma3.c b/drivers/dma/ti-edma3.c
index 39e9793013..635eb7876d 100644
--- a/drivers/dma/ti-edma3.c
+++ b/drivers/dma/ti-edma3.c
@@ -491,7 +491,7 @@ static int ti_edma3_transfer(struct udevice *dev, int direction, void *dst,
 		__edma3_transfer(priv->base, 1, dst, src, len);
 		break;
 	default:
-		error("Transfer type not implemented in DMA driver\n");
+		pr_err("Transfer type not implemented in DMA driver\n");
 		break;
 	}
 
diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 4c32426e0e..b034317b55 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -4,3 +4,5 @@ config FIRMWARE
 config ARM_PSCI_FW
 	bool
 	select FIRMWARE
+
+source "drivers/firmware/scmi/Kconfig"
diff --git a/drivers/firmware/Makefile b/drivers/firmware/Makefile
index b208255368..eecae5b1ff 100644
--- a/drivers/firmware/Makefile
+++ b/drivers/firmware/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_FIRMWARE)		+= firmware-uclass.o
 obj-$(CONFIG_ARM_PSCI_FW)	+= psci.o
+obj-$(CONFIG_$(SPL_TPL_)SCMI_FIRMWARE)	+= scmi/
diff --git a/drivers/firmware/firmware-uclass.c b/drivers/firmware/firmware-uclass.c
index af781b5b69..ef1e098257 100644
--- a/drivers/firmware/firmware-uclass.c
+++ b/drivers/firmware/firmware-uclass.c
@@ -10,3 +10,11 @@ UCLASS_DRIVER(firmware) = {
 	.id		= UCLASS_FIRMWARE,
 	.name		= "firmware",
 };
+
+U_BOOT_DRIVER(firmware) = {
+	.name	= "firmware",
+	.id	= UCLASS_FIRMWARE,
+#if !CONFIG_IS_ENABLED(OF_PLATDATA)
+	.bind = dm_scan_fdt_dev,
+#endif
+};
diff --git a/drivers/firmware/psci.c b/drivers/firmware/psci.c
index 451fbdebba..8c72db997c 100644
--- a/drivers/firmware/psci.c
+++ b/drivers/firmware/psci.c
@@ -10,7 +10,7 @@
 #include <common.h>
 #include <dm.h>
 #include <dm/lists.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <linux/arm-smccc.h>
 #include <linux/errno.h>
 #include <linux/psci.h>
@@ -56,11 +56,9 @@ static int psci_bind(struct udevice *dev)
 
 static int psci_probe(struct udevice *dev)
 {
-	DECLARE_GLOBAL_DATA_PTR;
 	const char *method;
 
-	method = fdt_stringlist_get(gd->fdt_blob, dev_of_offset(dev), "method",
-				    0, NULL);
+	method = dev_read_prop(dev, "method", NULL);
 	if (!method) {
 		printf("missing \"method\" property\n");
 		return -ENXIO;
diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
index 6b2c866319..2dc4bd5ad3 100644
--- a/drivers/fpga/Kconfig
+++ b/drivers/fpga/Kconfig
@@ -45,4 +45,19 @@ config FPGA_ZYNQMPPL
 	  Enable FPGA driver for loading bitstream in BIT and BIN format
 	  on Xilinx Zynq UltraScale+ (ZynqMP) device.
 
+config FPGA_ROCKCHIP
+	bool "Enable Rockchip FPGA drivers"
+	depends on ARCH_ROCKCHIP
+	help
+	  Enale Rockchip FPGA specific functions.
+
+config FPGA_MMC
+	bool "FPGA board with MMC"
+	depends on FPGA_ROCKCHIP
+
+config FPGA_RAM
+	bool "FPGA board with RAM"
+	depends on FPGA_ROCKCHIP
+	select DM_RAMDISK
+	select RAMDISK_RO
 endmenu
diff --git a/drivers/fpga/socfpga_arria10.c b/drivers/fpga/socfpga_arria10.c
index 5c1a68a009..d5763965dd 100644
--- a/drivers/fpga/socfpga_arria10.c
+++ b/drivers/fpga/socfpga_arria10.c
@@ -62,8 +62,7 @@ int is_fpgamgr_user_mode(void)
 
 static int wait_for_user_mode(void)
 {
-	return wait_for_bit(__func__,
-		&fpga_manager_base->imgcfg_stat,
+	return wait_for_bit_le32(&fpga_manager_base->imgcfg_stat,
 		ALT_FPGAMGR_IMGCFG_STAT_F2S_USERMODE_SET_MSK,
 		1, FPGA_TIMEOUT_MSEC, false);
 }
@@ -115,19 +114,17 @@ static int wait_for_nconfig_pin_and_nstatus_pin(void)
 	/* Poll until f2s_nconfig_pin and f2s_nstatus_pin; loop until de-asserted,
 	 * timeout at 1000ms
 	 */
-	return wait_for_bit(__func__,
-			    &fpga_manager_base->imgcfg_stat,
-			    mask,
-			    false, FPGA_TIMEOUT_MSEC, false);
+	return wait_for_bit_le32(&fpga_manager_base->imgcfg_stat,
+		mask,
+		false, FPGA_TIMEOUT_MSEC, false);
 }
 
 static int wait_for_f2s_nstatus_pin(unsigned long value)
 {
 	/* Poll until f2s to specific value, timeout at 1000ms */
-	return wait_for_bit(__func__,
-			    &fpga_manager_base->imgcfg_stat,
-			    ALT_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN_SET_MSK,
-			    value, FPGA_TIMEOUT_MSEC, false);
+	return wait_for_bit_le32(&fpga_manager_base->imgcfg_stat,
+		ALT_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN_SET_MSK,
+		value, FPGA_TIMEOUT_MSEC, false);
 }
 
 /* set CD ratio */
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index ffeda9425a..e968e9edd4 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -144,6 +144,19 @@ config ROCKCHIP_GPIO
 	  The GPIOs for a device are defined in the device tree with one node
 	  for each bank.
 
+config ROCKCHIP_GPIO_V2
+	bool "Rockchip GPIO driver version 2.0"
+	depends on ROCKCHIP_GPIO
+	default n
+	help
+	  Support GPIO access on Rockchip SoCs. The GPIOs are arranged into
+	  a number of banks (different for each SoC type) each with 32 GPIOs.
+	  The GPIOs for a device are defined in the device tree with one node
+	  for each bank.
+
+	  Support version 2.0 GPIO controller, which support write enable bits
+	  for some registers, such as dr, ddr.
+
 config SANDBOX_GPIO
 	bool "Enable sandbox GPIO driver"
 	depends on SANDBOX && DM && DM_GPIO
diff --git a/drivers/gpio/adi_gpio2.c b/drivers/gpio/adi_gpio2.c
index 4db08a344a..1012f2d8eb 100644
--- a/drivers/gpio/adi_gpio2.c
+++ b/drivers/gpio/adi_gpio2.c
@@ -138,7 +138,7 @@ int peripheral_request(unsigned short per, const char *label)
 		return 0;
 
 	if (!(per & P_DEFINED))
-		return -ENODEV;
+		return -EINVAL;
 
 	BUG_ON(ident >= MAX_RESOURCES);
 
diff --git a/drivers/gpio/atmel_pio4.c b/drivers/gpio/atmel_pio4.c
index f3689467f0..30bc4296e3 100644
--- a/drivers/gpio/atmel_pio4.c
+++ b/drivers/gpio/atmel_pio4.c
@@ -50,11 +50,11 @@ static int atmel_pio4_config_io_func(u32 port, u32 pin,
 	u32 reg, mask;
 
 	if (pin >= ATMEL_PIO_NPINS_PER_BANK)
-		return -ENODEV;
+		return -EINVAL;
 
 	port_base = atmel_pio4_port_base(port);
 	if (!port_base)
-		return -ENODEV;
+		return -EINVAL;
 
 	mask = 1 << pin;
 	reg = func;
@@ -128,11 +128,11 @@ int atmel_pio4_set_pio_output(u32 port, u32 pin, u32 value)
 	u32 reg, mask;
 
 	if (pin >= ATMEL_PIO_NPINS_PER_BANK)
-		return -ENODEV;
+		return -EINVAL;
 
 	port_base = atmel_pio4_port_base(port);
 	if (!port_base)
-		return -ENODEV;
+		return -EINVAL;
 
 	mask = 0x01 << pin;
 	reg = ATMEL_PIO_CFGR_FUNC_GPIO | ATMEL_PIO_DIR_MASK;
@@ -154,11 +154,11 @@ int atmel_pio4_get_pio_input(u32 port, u32 pin)
 	u32 reg, mask;
 
 	if (pin >= ATMEL_PIO_NPINS_PER_BANK)
-		return -ENODEV;
+		return -EINVAL;
 
 	port_base = atmel_pio4_port_base(port);
 	if (!port_base)
-		return -ENODEV;
+		return -EINVAL;
 
 	mask = 0x01 << pin;
 	reg = ATMEL_PIO_CFGR_FUNC_GPIO;
diff --git a/drivers/gpio/imx_rgpio2p.c b/drivers/gpio/imx_rgpio2p.c
index 5abc88ba54..5a5f646813 100644
--- a/drivers/gpio/imx_rgpio2p.c
+++ b/drivers/gpio/imx_rgpio2p.c
@@ -168,7 +168,7 @@ static int imx_rgpio2p_bind(struct udevice *dev)
 
 	addr = devfdt_get_addr_index(dev, 1);
 	if (addr == FDT_ADDR_T_NONE)
-		return -ENODEV;
+		return -EINVAL;
 
 	/*
 	 * TODO:
diff --git a/drivers/gpio/kw_gpio.c b/drivers/gpio/kw_gpio.c
index 43b27e3fea..cc26cc1658 100644
--- a/drivers/gpio/kw_gpio.c
+++ b/drivers/gpio/kw_gpio.c
@@ -14,7 +14,7 @@
  */
 
 #include <common.h>
-#include <asm/bitops.h>
+#include <linux/bitops.h>
 #include <asm/io.h>
 #include <asm/arch/soc.h>
 #include <asm/arch/gpio.h>
diff --git a/drivers/gpio/mxc_gpio.c b/drivers/gpio/mxc_gpio.c
index 0eb6c600f1..698d9feedf 100644
--- a/drivers/gpio/mxc_gpio.c
+++ b/drivers/gpio/mxc_gpio.c
@@ -304,7 +304,7 @@ static int mxc_gpio_bind(struct udevice *dev)
 
 	addr = devfdt_get_addr(dev);
 	if (addr == FDT_ADDR_T_NONE)
-		return -ENODEV;
+		return -EINVAL;
 
 	/*
 	 * TODO:
diff --git a/drivers/gpio/omap_gpio.c b/drivers/gpio/omap_gpio.c
index b423e34ca4..1f67482340 100644
--- a/drivers/gpio/omap_gpio.c
+++ b/drivers/gpio/omap_gpio.c
@@ -307,7 +307,7 @@ static int omap_gpio_bind(struct udevice *dev)
 
 	base_addr = devfdt_get_addr(dev);
 	if (base_addr == FDT_ADDR_T_NONE)
-		return -ENODEV;
+		return -EINVAL;
 
 	/*
 	* TODO:
diff --git a/drivers/gpio/pca953x_gpio.c b/drivers/gpio/pca953x_gpio.c
index 4962f25230..bf46b39523 100644
--- a/drivers/gpio/pca953x_gpio.c
+++ b/drivers/gpio/pca953x_gpio.c
@@ -265,7 +265,8 @@ static int pca953x_probe(struct udevice *dev)
 		return -ENODEV;
 	}
 
-	addr = fdtdec_get_int(gd->fdt_blob, dev_of_offset(dev), "reg", 0);
+//	addr = fdtdec_get_int(gd->fdt_blob, dev_of_offset(dev), "reg", 0);
+	addr = ofnode_read_s32_default(dev->node, "reg", 0);
 	if (addr == 0)
 		return -ENODEV;
 
diff --git a/drivers/gpio/rk_gpio.c b/drivers/gpio/rk_gpio.c
index 6f7366acba..139b0ed1f6 100644
--- a/drivers/gpio/rk_gpio.c
+++ b/drivers/gpio/rk_gpio.c
@@ -1,28 +1,52 @@
 /*
  * (C) Copyright 2015 Google, Inc
  *
- * (C) Copyright 2008-2014 Rockchip Electronics
+ * (C) Copyright 2008-2020 Rockchip Electronics
  * Peter, Software Engineering, <superpeter.cai@gmail.com>.
+ * Jianqun Xu, Software Engineering, <jay.xu@rock-chips.com>.
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
 
 #include <common.h>
 #include <dm.h>
+#include <dm/of_access.h>
 #include <syscon.h>
 #include <linux/errno.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
+#include <asm/arch-rockchip/clock.h>
 #include <dm/pinctrl.h>
 #include <dt-bindings/clock/rk3288-cru.h>
 
-enum {
-	ROCKCHIP_GPIOS_PER_BANK		= 32,
-};
+#include "../pinctrl/rockchip/pinctrl-rockchip.h"
 
 #define OFFSET_TO_BIT(bit)	(1UL << (bit))
 
+#ifdef CONFIG_ROCKCHIP_GPIO_V2
+#define REG_L(R)	(R##_l)
+#define REG_H(R)	(R##_h)
+#define READ_REG(REG)	((readl(REG_L(REG)) & 0xFFFF) | \
+			((readl(REG_H(REG)) & 0xFFFF) << 16))
+#define WRITE_REG(REG, VAL)	\
+{\
+	writel(((VAL) & 0xFFFF) | 0xFFFF0000, REG_L(REG)); \
+	writel((((VAL) & 0xFFFF0000) >> 16) | 0xFFFF0000, REG_H(REG));\
+}
+#define CLRBITS_LE32(REG, MASK)	WRITE_REG(REG, READ_REG(REG) & ~(MASK))
+#define SETBITS_LE32(REG, MASK)	WRITE_REG(REG, READ_REG(REG) | (MASK))
+#define CLRSETBITS_LE32(REG, MASK, VAL)	WRITE_REG(REG, \
+				(READ_REG(REG) & ~(MASK)) | (VAL))
+
+#else
+#define READ_REG(REG)			readl(REG)
+#define WRITE_REG(REG, VAL)		writel(VAL, REG)
+#define CLRBITS_LE32(REG, MASK)		clrbits_le32(REG, MASK)
+#define SETBITS_LE32(REG, MASK)		setbits_le32(REG, MASK)
+#define CLRSETBITS_LE32(REG, MASK, VAL)	clrsetbits_le32(REG, MASK, VAL)
+#endif
+
+
 struct rockchip_gpio_priv {
 	struct rockchip_gpio_regs *regs;
 	struct udevice *pinctrl;
@@ -35,7 +59,7 @@ static int rockchip_gpio_direction_input(struct udevice *dev, unsigned offset)
 	struct rockchip_gpio_priv *priv = dev_get_priv(dev);
 	struct rockchip_gpio_regs *regs = priv->regs;
 
-	clrbits_le32(&regs->swport_ddr, OFFSET_TO_BIT(offset));
+	CLRBITS_LE32(&regs->swport_ddr, OFFSET_TO_BIT(offset));
 
 	return 0;
 }
@@ -47,8 +71,8 @@ static int rockchip_gpio_direction_output(struct udevice *dev, unsigned offset,
 	struct rockchip_gpio_regs *regs = priv->regs;
 	int mask = OFFSET_TO_BIT(offset);
 
-	clrsetbits_le32(&regs->swport_dr, mask, value ? mask : 0);
-	setbits_le32(&regs->swport_ddr, mask);
+	CLRSETBITS_LE32(&regs->swport_dr, mask, value ? mask : 0);
+	SETBITS_LE32(&regs->swport_ddr, mask);
 
 	return 0;
 }
@@ -68,7 +92,7 @@ static int rockchip_gpio_set_value(struct udevice *dev, unsigned offset,
 	struct rockchip_gpio_regs *regs = priv->regs;
 	int mask = OFFSET_TO_BIT(offset);
 
-	clrsetbits_le32(&regs->swport_dr, mask, value ? mask : 0);
+	CLRSETBITS_LE32(&regs->swport_dr, mask, value ? mask : 0);
 
 	return 0;
 }
@@ -84,13 +108,16 @@ static int rockchip_gpio_get_function(struct udevice *dev, unsigned offset)
 	int ret;
 
 	ret = pinctrl_get_gpio_mux(priv->pinctrl, priv->bank, offset);
-	if (ret)
+	if (ret < 0) {
+		dev_err(dev, "fail to get gpio mux %d\n", ret);
 		return ret;
+	}
 
 	/* If it's not 0, then it is not a GPIO */
-	if (ret)
+	if (ret > 0)
 		return GPIOF_FUNC;
-	is_output = readl(&regs->swport_ddr) & OFFSET_TO_BIT(offset);
+
+	is_output = READ_REG(&regs->swport_ddr) & OFFSET_TO_BIT(offset);
 
 	return is_output ? GPIOF_OUTPUT : GPIOF_INPUT;
 #endif
@@ -100,20 +127,49 @@ static int rockchip_gpio_probe(struct udevice *dev)
 {
 	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
 	struct rockchip_gpio_priv *priv = dev_get_priv(dev);
-	char *end;
-	int ret;
+	struct rockchip_pinctrl_priv *pctrl_priv;
+	struct rockchip_pin_bank *bank;
+	char *end = NULL;
+	static int gpio;
+	int id = -1, ret;
 
-	/* This only supports RK3288 at present */
-	priv->regs = (struct rockchip_gpio_regs *)devfdt_get_addr(dev);
+	priv->regs = dev_read_addr_ptr(dev);
 	ret = uclass_first_device_err(UCLASS_PINCTRL, &priv->pinctrl);
-	if (ret)
+	if (ret) {
+		dev_err(dev, "failed to get pinctrl device %d\n", ret);
 		return ret;
+	}
+
+	pctrl_priv = dev_get_priv(priv->pinctrl);
+	if (!pctrl_priv) {
+		dev_err(dev, "failed to get pinctrl priv\n");
+		return -EINVAL;
+	}
 
-	uc_priv->gpio_count = ROCKCHIP_GPIOS_PER_BANK;
 	end = strrchr(dev->name, '@');
-	priv->bank = trailing_strtoln(dev->name, end);
-	priv->name[0] = 'A' + priv->bank;
-	uc_priv->bank_name = priv->name;
+	if (end)
+		id = trailing_strtoln(dev->name, end);
+	else
+		dev_read_alias_seq(dev, &id);
+
+	if (id < 0)
+		id = gpio++;
+
+	if (id >= pctrl_priv->ctrl->nr_banks) {
+		dev_err(dev, "bank id invalid\n");
+		return -EINVAL;
+	}
+
+	bank = &pctrl_priv->ctrl->pin_banks[id];
+	if (bank->bank_num != id) {
+		dev_err(dev, "bank id mismatch with pinctrl\n");
+		return -EINVAL;
+	}
+
+	priv->bank = bank->bank_num;
+	uc_priv->gpio_count = bank->nr_pins;
+	uc_priv->gpio_base = bank->pin_base;
+	uc_priv->bank_name = bank->name;
 
 	return 0;
 }
diff --git a/drivers/gpio/tegra186_gpio.c b/drivers/gpio/tegra186_gpio.c
index c5a7e13cce..deb59e8b32 100644
--- a/drivers/gpio/tegra186_gpio.c
+++ b/drivers/gpio/tegra186_gpio.c
@@ -181,7 +181,7 @@ static int tegra186_gpio_bind(struct udevice *parent)
 
 	regs = (uint32_t *)devfdt_get_addr_name(parent, "gpio");
 	if (regs == (uint32_t *)FDT_ADDR_T_NONE)
-		return -ENODEV;
+		return -EINVAL;
 
 	for (port = 0; port < ctlr_data->port_count; port++) {
 		struct tegra186_gpio_platdata *plat;
diff --git a/drivers/i2c/i2c-gpio.c b/drivers/i2c/i2c-gpio.c
index aeeb304a87..4e8fa21473 100644
--- a/drivers/i2c/i2c-gpio.c
+++ b/drivers/i2c/i2c-gpio.c
@@ -322,7 +322,7 @@ static int i2c_gpio_ofdata_to_platdata(struct udevice *dev)
 
 	return 0;
 error:
-	error("Can't get %s gpios! Error: %d", dev->name, ret);
+	pr_err("Can't get %s gpios! Error: %d", dev->name, ret);
 	return ret;
 }
 
diff --git a/drivers/i2c/i2c-uclass.c b/drivers/i2c/i2c-uclass.c
index 1397f34dda..47531a8fb4 100644
--- a/drivers/i2c/i2c-uclass.c
+++ b/drivers/i2c/i2c-uclass.c
@@ -489,9 +489,15 @@ static int i2c_post_probe(struct udevice *dev)
 {
 #if CONFIG_IS_ENABLED(OF_CONTROL)
 	struct dm_i2c_bus *i2c = dev_get_uclass_priv(dev);
+	int seq;
 
 	i2c->speed_hz = dev_read_u32_default(dev, "clock-frequency", 100000);
 
+	if (dev_read_alias_seq(dev, &seq) >= 0)
+		printf("I2c%d speed: %dHz\n", seq, i2c->speed_hz);
+	else
+		printf("I2c speed: %dHz\n", i2c->speed_hz);
+
 	return dm_i2c_set_bus_speed(dev, i2c->speed_hz);
 #else
 	return 0;
diff --git a/drivers/i2c/imx_lpi2c.c b/drivers/i2c/imx_lpi2c.c
index aa97196e23..e7ec17fe9e 100644
--- a/drivers/i2c/imx_lpi2c.c
+++ b/drivers/i2c/imx_lpi2c.c
@@ -412,7 +412,7 @@ static int imx_lpi2c_probe(struct udevice *bus)
 
 	addr = devfdt_get_addr(bus);
 	if (addr == FDT_ADDR_T_NONE)
-		return -ENODEV;
+		return -EINVAL;
 
 	i2c_bus->base = addr;
 	i2c_bus->index = bus->seq;
diff --git a/drivers/i2c/mxc_i2c.c b/drivers/i2c/mxc_i2c.c
index b7bb76c0ed..abf1da2ae3 100644
--- a/drivers/i2c/mxc_i2c.c
+++ b/drivers/i2c/mxc_i2c.c
@@ -176,7 +176,7 @@ static int bus_i2c_set_bus_speed(struct mxc_i2c_bus *i2c_bus, int speed)
 	int reg_shift = quirk ? VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
 
 	if (!base)
-		return -ENODEV;
+		return -EINVAL;
 
 	/* Store divider value */
 	writeb(idx, base + (IFDR << reg_shift));
@@ -239,7 +239,7 @@ static int tx_byte(struct mxc_i2c_bus *i2c_bus, u8 byte)
 	if (ret < 0)
 		return ret;
 	if (ret & I2SR_RX_NO_AK)
-		return -ENODEV;
+		return -EREMOTEIO;
 	return 0;
 }
 
@@ -418,14 +418,14 @@ static int i2c_init_transfer(struct mxc_i2c_bus *i2c_bus, u8 chip,
 			VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
 
 	if (!i2c_bus->base)
-		return -ENODEV;
+		return -EINVAL;
 
 	for (retry = 0; retry < 3; retry++) {
 		ret = i2c_init_transfer_(i2c_bus, chip, addr, alen);
 		if (ret >= 0)
 			return 0;
 		i2c_imx_stop(i2c_bus);
-		if (ret == -ENODEV)
+		if (ret == -EREMOTEIO)
 			return ret;
 
 		printf("%s: failed for chip 0x%x retry=%d\n", __func__, chip,
@@ -754,7 +754,7 @@ static int mxc_i2c_probe(struct udevice *bus)
 
 	addr = devfdt_get_addr(bus);
 	if (addr == FDT_ADDR_T_NONE)
-		return -ENODEV;
+		return -EINVAL;
 
 	i2c_bus->base = addr;
 	i2c_bus->index = bus->seq;
@@ -783,7 +783,7 @@ static int mxc_i2c_probe(struct udevice *bus)
 		    !dm_gpio_is_valid(&i2c_bus->scl_gpio) |
 		    ret | ret2) {
 			dev_err(dev, "i2c bus %d at %lu, fail to request scl/sda gpio\n", bus->seq, i2c_bus->base);
-			return -ENODEV;
+			return -EINVAL;
 		}
 	}
 
diff --git a/drivers/i2c/omap24xx_i2c.c b/drivers/i2c/omap24xx_i2c.c
index c98c6276dd..5d33815146 100644
--- a/drivers/i2c/omap24xx_i2c.c
+++ b/drivers/i2c/omap24xx_i2c.c
@@ -755,7 +755,7 @@ static uint omap24_i2c_setspeed(struct i2c_adapter *adap, uint speed)
 
 	ret = __omap24_i2c_setspeed(i2c_base, speed, &adap->waitdelay);
 	if (ret) {
-		error("%s: set i2c speed failed\n", __func__);
+		pr_err("%s: set i2c speed failed\n", __func__);
 		return ret;
 	}
 
diff --git a/drivers/i2c/rk_i2c.c b/drivers/i2c/rk_i2c.c
index 68e66536e4..e310afc647 100644
--- a/drivers/i2c/rk_i2c.c
+++ b/drivers/i2c/rk_i2c.c
@@ -13,9 +13,9 @@
 #include <errno.h>
 #include <i2c.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/i2c.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/i2c.h>
+#include <asm/arch-rockchip/periph.h>
 #include <dm/pinctrl.h>
 #include <linux/sizes.h>
 
@@ -32,8 +32,76 @@ struct rk_i2c {
 	struct clk clk;
 	struct i2c_regs *regs;
 	unsigned int speed;
+	unsigned int cfg;
 };
 
+struct i2c_spec_values {
+	unsigned int min_low_ns;
+	unsigned int min_high_ns;
+	unsigned int max_rise_ns;
+	unsigned int max_fall_ns;
+};
+
+enum {
+	RK_I2C_VERSION0 = 0,
+	RK_I2C_VERSION1,
+	RK_I2C_VERSION5 = 5,
+};
+
+/********************* Private Variable Definition ***************************/
+
+static const struct i2c_spec_values standard_mode_spec = {
+	.min_low_ns = 4700,
+	.min_high_ns = 4000,
+	.max_rise_ns = 1000,
+	.max_fall_ns = 300,
+};
+
+static const struct i2c_spec_values fast_mode_spec = {
+	.min_low_ns = 1300,
+	.min_high_ns = 600,
+	.max_rise_ns = 300,
+	.max_fall_ns = 300,
+};
+
+static const struct i2c_spec_values fast_modeplus_spec = {
+	.min_low_ns = 500,
+	.min_high_ns = 260,
+	.max_rise_ns = 120,
+	.max_fall_ns = 120,
+};
+
+static const struct i2c_spec_values *rk_i2c_get_spec(unsigned int speed)
+{
+	if (speed == 1000)
+		return &fast_modeplus_spec;
+	else if (speed == 400)
+		return &fast_mode_spec;
+	else
+		return &standard_mode_spec;
+}
+
+static void rk_i2c_show_regs(struct i2c_regs *regs)
+{
+#ifdef DEBUG
+	uint i;
+
+	debug("i2c_con: 0x%08x\n", readl(&regs->con));
+	debug("i2c_clkdiv: 0x%08x\n", readl(&regs->clkdiv));
+	debug("i2c_mrxaddr: 0x%08x\n", readl(&regs->mrxaddr));
+	debug("i2c_mrxraddR: 0x%08x\n", readl(&regs->mrxraddr));
+	debug("i2c_mtxcnt: 0x%08x\n", readl(&regs->mtxcnt));
+	debug("i2c_mrxcnt: 0x%08x\n", readl(&regs->mrxcnt));
+	debug("i2c_ien: 0x%08x\n", readl(&regs->ien));
+	debug("i2c_ipd: 0x%08x\n", readl(&regs->ipd));
+	debug("i2c_fcnt: 0x%08x\n", readl(&regs->fcnt));
+	for (i = 0; i < 8; i++)
+		debug("i2c_txdata%d: 0x%08x\n", i, readl(&regs->txdata[i]));
+	for (i = 0; i < 8; i++)
+		debug("i2c_rxdata%d: 0x%08x\n", i, readl(&regs->rxdata[i]));
+#endif
+}
+
 static inline void rk_i2c_get_div(int div, int *divh, int *divl)
 {
 	*divl = div / 2;
@@ -48,9 +116,9 @@ static inline void rk_i2c_get_div(int div, int *divh, int *divl)
  * SCL = PCLK / SCLK Divisor
  * i2c_rate = PCLK
  */
-static void rk_i2c_set_clk(struct rk_i2c *i2c, uint32_t scl_rate)
+static void rk_i2c_set_clk(struct rk_i2c *i2c, unsigned int scl_rate)
 {
-	uint32_t i2c_rate;
+	unsigned int i2c_rate;
 	int div, divl, divh;
 
 	/* First get i2c rate from pclk */
@@ -69,28 +137,78 @@ static void rk_i2c_set_clk(struct rk_i2c *i2c, uint32_t scl_rate)
 	debug("set clk(I2C_CLKDIV: 0x%08x)\n", readl(&i2c->regs->clkdiv));
 }
 
-static void rk_i2c_show_regs(struct i2c_regs *regs)
+static int rk_i2c_adapter_clk(struct rk_i2c *i2c, unsigned int scl_rate)
 {
-#ifdef DEBUG
-	uint i;
+	const struct i2c_spec_values *spec;
+	unsigned int min_total_div, min_low_div, min_high_div, min_hold_div;
+	unsigned int low_div, high_div, extra_div, extra_low_div;
+	unsigned int min_low_ns, min_high_ns;
+	unsigned int start_setup = 0;
+	unsigned int i2c_rate = clk_get_rate(&i2c->clk);
+	unsigned int speed;
 
-	debug("i2c_con: 0x%08x\n", readl(&regs->con));
-	debug("i2c_clkdiv: 0x%08x\n", readl(&regs->clkdiv));
-	debug("i2c_mrxaddr: 0x%08x\n", readl(&regs->mrxaddr));
-	debug("i2c_mrxraddR: 0x%08x\n", readl(&regs->mrxraddr));
-	debug("i2c_mtxcnt: 0x%08x\n", readl(&regs->mtxcnt));
-	debug("i2c_mrxcnt: 0x%08x\n", readl(&regs->mrxcnt));
-	debug("i2c_ien: 0x%08x\n", readl(&regs->ien));
-	debug("i2c_ipd: 0x%08x\n", readl(&regs->ipd));
-	debug("i2c_fcnt: 0x%08x\n", readl(&regs->fcnt));
-	for (i = 0; i < 8; i++)
-		debug("i2c_txdata%d: 0x%08x\n", i, readl(&regs->txdata[i]));
-	for (i = 0; i < 8; i++)
-		debug("i2c_rxdata%d: 0x%08x\n", i, readl(&regs->rxdata[i]));
-#endif
+	debug("rk_i2c_set_clk: i2c rate = %d, scl rate = %d\n", i2c_rate,
+	      scl_rate);
+
+	if (scl_rate <= 100000 && scl_rate >= 1000) {
+		start_setup = 1;
+		speed = 100;
+	} else if (scl_rate <= 400000 && scl_rate >= 100000) {
+		speed = 400;
+	} else if (scl_rate <= 1000000 && scl_rate > 400000) {
+		speed = 1000;
+	} else {
+		debug("invalid i2c speed : %d\n", scl_rate);
+		return -EINVAL;
+	}
+
+	spec = rk_i2c_get_spec(speed);
+	i2c_rate = DIV_ROUND_UP(i2c_rate, 1000);
+	speed = DIV_ROUND_UP(scl_rate, 1000);
+
+	min_total_div = DIV_ROUND_UP(i2c_rate, speed * 8);
+
+	min_high_ns = spec->max_rise_ns + spec->min_high_ns;
+	min_high_div = DIV_ROUND_UP(i2c_rate * min_high_ns, 8 * 1000000);
+
+	min_low_ns = spec->max_fall_ns + spec->min_low_ns;
+	min_low_div = DIV_ROUND_UP(i2c_rate * min_low_ns, 8 * 1000000);
+
+	min_high_div = (min_high_div < 1) ? 2 : min_high_div;
+	min_low_div = (min_low_div < 1) ? 2 : min_low_div;
+
+	min_hold_div = min_high_div + min_low_div;
+
+	if (min_hold_div >= min_total_div) {
+		high_div = min_high_div;
+		low_div = min_low_div;
+	} else {
+		extra_div = min_total_div - min_hold_div;
+		extra_low_div = DIV_ROUND_UP(min_low_div * extra_div,
+					     min_hold_div);
+
+		low_div = min_low_div + extra_low_div;
+		high_div = min_high_div + (extra_div - extra_low_div);
+	}
+
+	high_div--;
+	low_div--;
+
+	if (high_div > 0xffff || low_div > 0xffff)
+		return -EINVAL;
+
+	/* 1 for data hold/setup time is enough */
+	i2c->cfg = I2C_CON_SDA_CFG(1) | I2C_CON_STA_CFG(start_setup);
+	writel((high_div << I2C_CLK_DIV_HIGH_SHIFT) | low_div,
+	       &i2c->regs->clkdiv);
+
+	debug("set clk(I2C_TIMING: 0x%08x)\n", i2c->cfg);
+	debug("set clk(I2C_CLKDIV: 0x%08x)\n", readl(&i2c->regs->clkdiv));
+
+	return 0;
 }
 
-static int rk_i2c_send_start_bit(struct rk_i2c *i2c)
+static int rk_i2c_send_start_bit(struct rk_i2c *i2c, u32 con)
 {
 	struct i2c_regs *regs = i2c->regs;
 	ulong start;
@@ -98,8 +216,8 @@ static int rk_i2c_send_start_bit(struct rk_i2c *i2c)
 	debug("I2c Send Start bit.\n");
 	writel(I2C_IPD_ALL_CLEAN, &regs->ipd);
 
-	writel(I2C_CON_EN | I2C_CON_START, &regs->con);
 	writel(I2C_STARTIEN, &regs->ien);
+	writel(I2C_CON_EN | I2C_CON_START | i2c->cfg | con, &regs->con);
 
 	start = get_timer(0);
 	while (1) {
@@ -115,6 +233,9 @@ static int rk_i2c_send_start_bit(struct rk_i2c *i2c)
 		udelay(1);
 	}
 
+	/* clean start bit */
+	writel(I2C_CON_EN | i2c->cfg | con, &regs->con);
+
 	return 0;
 }
 
@@ -126,7 +247,7 @@ static int rk_i2c_send_stop_bit(struct rk_i2c *i2c)
 	debug("I2c Send Stop bit.\n");
 	writel(I2C_IPD_ALL_CLEAN, &regs->ipd);
 
-	writel(I2C_CON_EN | I2C_CON_STOP, &regs->con);
+	writel(I2C_CON_EN | i2c->cfg | I2C_CON_STOP, &regs->con);
 	writel(I2C_CON_STOP, &regs->ien);
 
 	start = get_timer(0);
@@ -143,16 +264,19 @@ static int rk_i2c_send_stop_bit(struct rk_i2c *i2c)
 		udelay(1);
 	}
 
+	udelay(1);
 	return 0;
 }
 
 static inline void rk_i2c_disable(struct rk_i2c *i2c)
 {
+	writel(0, &i2c->regs->ien);
+	writel(I2C_IPD_ALL_CLEAN, &i2c->regs->ipd);
 	writel(0, &i2c->regs->con);
 }
 
 static int rk_i2c_read(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
-		       uchar *buf, uint b_len)
+		       uchar *buf, uint b_len, bool snd)
 {
 	struct i2c_regs *regs = i2c->regs;
 	uchar *pbuf = buf;
@@ -163,15 +287,15 @@ static int rk_i2c_read(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
 	uint con = 0;
 	uint rxdata;
 	uint i, j;
-	int err;
+	int err = 0;
 	bool snd_chunk = false;
 
 	debug("rk_i2c_read: chip = %d, reg = %d, r_len = %d, b_len = %d\n",
 	      chip, reg, r_len, b_len);
 
-	err = rk_i2c_send_start_bit(i2c);
-	if (err)
-		return err;
+	/* If the second message for TRX read, resetting internal state. */
+	if (snd)
+		writel(0, &regs->con);
 
 	writel(I2C_MRXADDR_SET(1, chip << 1 | 1), &regs->mrxaddr);
 	if (r_len == 0) {
@@ -198,16 +322,21 @@ static int rk_i2c_read(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
 		words_xferred = DIV_ROUND_UP(bytes_xferred, 4);
 
 		/*
-		 * make sure we are in plain RX mode if we read a second chunk
+		 * make sure we are in plain RX mode if we read a second chunk;
+		 * and first rx read need to send start bit.
 		 */
-		if (snd_chunk)
+		if (snd_chunk) {
 			con |= I2C_CON_MOD(I2C_MODE_RX);
-		else
+			writel(con | i2c->cfg, &regs->con);
+		} else {
 			con |= I2C_CON_MOD(I2C_MODE_TRX);
+			err = rk_i2c_send_start_bit(i2c, con);
+			if (err)
+				return err;
+		}
 
-		writel(con, &regs->con);
-		writel(bytes_xferred, &regs->mrxcnt);
 		writel(I2C_MBRFIEN | I2C_NAKRCVIEN, &regs->ien);
+		writel(bytes_xferred, &regs->mrxcnt);
 
 		start = get_timer(0);
 		while (1) {
@@ -244,9 +373,6 @@ static int rk_i2c_read(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
 	}
 
 i2c_exit:
-	rk_i2c_send_stop_bit(i2c);
-	rk_i2c_disable(i2c);
-
 	return err;
 }
 
@@ -254,20 +380,18 @@ static int rk_i2c_write(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
 			uchar *buf, uint b_len)
 {
 	struct i2c_regs *regs = i2c->regs;
-	int err;
+	int err = 0;
 	uchar *pbuf = buf;
 	uint bytes_remain_len = b_len + r_len + 1;
 	uint bytes_xferred = 0;
 	uint words_xferred = 0;
+	bool next = false;
 	ulong start;
 	uint txdata;
 	uint i, j;
 
 	debug("rk_i2c_write: chip = %d, reg = %d, r_len = %d, b_len = %d\n",
 	      chip, reg, r_len, b_len);
-	err = rk_i2c_send_start_bit(i2c);
-	if (err)
-		return err;
 
 	while (bytes_remain_len) {
 		if (bytes_remain_len > RK_I2C_FIFO_SIZE)
@@ -295,9 +419,19 @@ static int rk_i2c_write(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
 			debug("I2c Write TXDATA[%d] = 0x%08x\n", i, txdata);
 		}
 
-		writel(I2C_CON_EN | I2C_CON_MOD(I2C_MODE_TX), &regs->con);
-		writel(bytes_xferred, &regs->mtxcnt);
+		/* If the write is the first, need to send start bit */
+		if (!next) {
+			err = rk_i2c_send_start_bit(i2c, I2C_CON_EN |
+					   I2C_CON_MOD(I2C_MODE_TX));
+			if (err)
+				return err;
+			next = true;
+		} else {
+			writel(I2C_CON_EN | I2C_CON_MOD(I2C_MODE_TX) | i2c->cfg,
+			       &regs->con);
+		}
 		writel(I2C_MBTFIEN | I2C_NAKRCVIEN, &regs->ien);
+		writel(bytes_xferred, &regs->mtxcnt);
 
 		start = get_timer(0);
 		while (1) {
@@ -323,9 +457,6 @@ static int rk_i2c_write(struct rk_i2c *i2c, uchar chip, uint reg, uint r_len,
 	}
 
 i2c_exit:
-	rk_i2c_send_stop_bit(i2c);
-	rk_i2c_disable(i2c);
-
 	return err;
 }
 
@@ -333,32 +464,60 @@ static int rockchip_i2c_xfer(struct udevice *bus, struct i2c_msg *msg,
 			     int nmsgs)
 {
 	struct rk_i2c *i2c = dev_get_priv(bus);
+	bool snd = false; /* second message for TRX read */
 	int ret;
 
 	debug("i2c_xfer: %d messages\n", nmsgs);
+	if (nmsgs > 2 || ((nmsgs == 2) && (msg->flags & I2C_M_RD))) {
+		debug("Not support more messages now, split them\n");
+		return -EINVAL;
+	}
+
 	for (; nmsgs > 0; nmsgs--, msg++) {
 		debug("i2c_xfer: chip=0x%x, len=0x%x\n", msg->addr, msg->len);
+
 		if (msg->flags & I2C_M_RD) {
+			/* If snd is true, it is TRX mode. */
 			ret = rk_i2c_read(i2c, msg->addr, 0, 0, msg->buf,
-					  msg->len);
+					  msg->len, snd);
 		} else {
+			snd = true;
 			ret = rk_i2c_write(i2c, msg->addr, 0, 0, msg->buf,
 					   msg->len);
 		}
+
 		if (ret) {
 			debug("i2c_write: error sending\n");
-			return -EREMOTEIO;
+			ret = -EREMOTEIO;
+			goto exit;
 		}
 	}
 
-	return 0;
+exit:
+	rk_i2c_send_stop_bit(i2c);
+	rk_i2c_disable(i2c);
+
+	return ret;
+}
+
+static unsigned int rk3x_i2c_get_version(struct rk_i2c *i2c)
+{
+	struct i2c_regs *regs = i2c->regs;
+	uint version;
+
+	version = readl(&regs->con) & I2C_CON_VERSION;
+
+	return version >>= I2C_CON_VERSION_SHIFT;
 }
 
 int rockchip_i2c_set_bus_speed(struct udevice *bus, unsigned int speed)
 {
 	struct rk_i2c *i2c = dev_get_priv(bus);
 
-	rk_i2c_set_clk(i2c, speed);
+	if (rk3x_i2c_get_version(i2c) >= RK_I2C_VERSION1)
+		rk_i2c_adapter_clk(i2c, speed);
+	else
+		rk_i2c_set_clk(i2c, speed);
 
 	return 0;
 }
@@ -382,7 +541,7 @@ static int rockchip_i2c_probe(struct udevice *bus)
 {
 	struct rk_i2c *priv = dev_get_priv(bus);
 
-	priv->regs = (void *)devfdt_get_addr(bus);
+	priv->regs = dev_read_addr_ptr(bus);
 
 	return 0;
 }
@@ -396,7 +555,10 @@ static const struct udevice_id rockchip_i2c_ids[] = {
 	{ .compatible = "rockchip,rk3066-i2c" },
 	{ .compatible = "rockchip,rk3188-i2c" },
 	{ .compatible = "rockchip,rk3288-i2c" },
+	{ .compatible = "rockchip,rk3328-i2c" },
 	{ .compatible = "rockchip,rk3399-i2c" },
+	{ .compatible = "rockchip,rk3228-i2c" },
+	{ .compatible = "rockchip,rv1108-i2c" },
 	{ }
 };
 
diff --git a/drivers/i2c/stm32f7_i2c.c b/drivers/i2c/stm32f7_i2c.c
index bf5fefab7b..196f2365ea 100644
--- a/drivers/i2c/stm32f7_i2c.c
+++ b/drivers/i2c/stm32f7_i2c.c
@@ -549,7 +549,7 @@ static int stm32_i2c_compute_solutions(struct stm32_i2c_setup *setup,
 	}
 
 	if (list_empty(solutions)) {
-		error("%s: no Prescaler solution\n", __func__);
+		pr_err("%s: no Prescaler solution\n", __func__);
 		ret = -EPERM;
 	}
 
@@ -627,7 +627,7 @@ static int stm32_i2c_choose_solution(struct stm32_i2c_setup *setup,
 	}
 
 	if (!s) {
-		error("%s: no solution at all\n", __func__);
+		pr_err("%s: no solution at all\n", __func__);
 		ret = -EPERM;
 	}
 
@@ -643,14 +643,14 @@ static int stm32_i2c_compute_timing(struct stm32_i2c_priv *i2c_priv,
 	int ret;
 
 	if (setup->speed >= STM32_I2C_SPEED_END) {
-		error("%s: speed out of bound {%d/%d}\n", __func__,
+		pr_err("%s: speed out of bound {%d/%d}\n", __func__,
 		      setup->speed, STM32_I2C_SPEED_END - 1);
 		return -EINVAL;
 	}
 
 	if ((setup->rise_time > i2c_specs[setup->speed].rise_max) ||
 	    (setup->fall_time > i2c_specs[setup->speed].fall_max)) {
-		error("%s :timings out of bound Rise{%d>%d}/Fall{%d>%d}\n",
+		pr_err("%s :timings out of bound Rise{%d>%d}/Fall{%d>%d}\n",
 		      __func__,
 		      setup->rise_time, i2c_specs[setup->speed].rise_max,
 		      setup->fall_time, i2c_specs[setup->speed].fall_max);
@@ -658,13 +658,13 @@ static int stm32_i2c_compute_timing(struct stm32_i2c_priv *i2c_priv,
 	}
 
 	if (setup->dnf > STM32_I2C_DNF_MAX) {
-		error("%s: DNF out of bound %d/%d\n", __func__,
+		pr_err("%s: DNF out of bound %d/%d\n", __func__,
 		      setup->dnf, STM32_I2C_DNF_MAX);
 		return -EINVAL;
 	}
 
 	if (setup->speed_freq > i2c_specs[setup->speed].rate) {
-		error("%s: Freq {%d/%d}\n", __func__,
+		pr_err("%s: Freq {%d/%d}\n", __func__,
 		      setup->speed_freq, i2c_specs[setup->speed].rate);
 		return -EINVAL;
 	}
@@ -711,7 +711,7 @@ static int stm32_i2c_setup_timing(struct stm32_i2c_priv *i2c_priv,
 	setup->clock_src = clk_get_rate(&i2c_priv->clk);
 
 	if (!setup->clock_src) {
-		error("%s: clock rate is 0\n", __func__);
+		pr_err("%s: clock rate is 0\n", __func__);
 		return -EINVAL;
 	}
 
@@ -734,7 +734,7 @@ static int stm32_i2c_setup_timing(struct stm32_i2c_priv *i2c_priv,
 	} while (ret);
 
 	if (ret) {
-		error("%s: impossible to compute I2C timings.\n", __func__);
+		pr_err("%s: impossible to compute I2C timings.\n", __func__);
 		return ret;
 	}
 
diff --git a/drivers/i2c/tegra186_bpmp_i2c.c b/drivers/i2c/tegra186_bpmp_i2c.c
index 931c6de508..b46a09a4e0 100644
--- a/drivers/i2c/tegra186_bpmp_i2c.c
+++ b/drivers/i2c/tegra186_bpmp_i2c.c
@@ -94,7 +94,7 @@ static int tegra186_bpmp_i2c_probe(struct udevice *dev)
 					    "nvidia,bpmp-bus-id", U32_MAX);
 	if (priv->bpmp_bus_id == U32_MAX) {
 		debug("%s: could not parse nvidia,bpmp-bus-id\n", __func__);
-		return -ENODEV;
+		return -EINVAL;
 	}
 
 	return 0;
diff --git a/drivers/i2c/tegra_i2c.c b/drivers/i2c/tegra_i2c.c
index 3255e8ed37..7d23e51b69 100644
--- a/drivers/i2c/tegra_i2c.c
+++ b/drivers/i2c/tegra_i2c.c
@@ -372,12 +372,12 @@ static int tegra_i2c_probe(struct udevice *dev)
 
 	ret = reset_get_by_name(dev, "i2c", &i2c_bus->reset_ctl);
 	if (ret) {
-		error("reset_get_by_name() failed: %d\n", ret);
+		pr_err("reset_get_by_name() failed: %d\n", ret);
 		return ret;
 	}
 	ret = clk_get_by_name(dev, "div-clk", &i2c_bus->clk);
 	if (ret) {
-		error("clk_get_by_name() failed: %d\n", ret);
+		pr_err("clk_get_by_name() failed: %d\n", ret);
 		return ret;
 	}
 
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index b3873c140d..a32ed55c9f 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -1,3 +1,16 @@
+config INPUT
+	bool "Enable input subsystem"
+	depends on DM
+	default y
+
+config SPL_INPUT
+	bool "Enable input subsystem for SPL"
+	depends on SPL_DM
+
+config TPL_INPUT
+	bool "Enable input subsystem for TPL"
+	depends on TPL_DM
+
 config DM_KEYBOARD
 	bool "Enable driver model keyboard support"
 	depends on DM
@@ -7,8 +20,63 @@ config DM_KEYBOARD
 	  includes methods to start/stop the device, check for available
 	  input and update LEDs if the keyboard has them.
 
+config DM_KEY
+	bool "Enable driver model key support"
+	depends on DM
+	help
+	  This adds a simple uclass for key.
+
+config DM_RC
+	bool "Enable driver model Remote Controller support"
+	depends on DM
+	help
+	  This adds a uclass for Remote Controllers. This is needed
+	  in order to support standalone IR receivers.
+
+config RK_IR
+	bool "Enable rk ir support"
+	depends on DM_RC
+	select BITREVERSE
+	help
+	  This adds a driver for the rockchip IR controller.
+
+config SPL_DM_KEYBOARD
+	bool "Enable driver model keyboard support"
+	depends on SPL_DM
+	help
+	  This adds a uclass for keyboards and implements keyboard support
+	  using driver model. The API is implemented by keyboard.h and
+	  includes methods to start/stop the device, check for available
+	  input and update LEDs if the keyboard has them.
+
+config TPL_DM_KEYBOARD
+	bool "Enable driver model keyboard support"
+	depends on TPL_DM
+	help
+	  This adds a uclass for keyboards and implements keyboard support
+	  using driver model. The API is implemented by keyboard.h and
+	  includes methods to start/stop the device, check for available
+	  input and update LEDs if the keyboard has them.
+
 config CROS_EC_KEYB
 	bool "Enable Chrome OS EC keyboard support"
+	depends on INPUT
+	help
+	  Most ARM Chromebooks use an EC to provide access to the keyboard.
+	  Messages are used to request key scans from the EC and these are
+	  then decoded into keys by this driver.
+
+config SPL_CROS_EC_KEYB
+	bool "Enable Chrome OS EC keyboard support in SPL"
+	depends on SPL_INPUT
+	help
+	  Most ARM Chromebooks use an EC to provide access to the keyboard.
+	  Messages are used to request key scans from the EC and these are
+	  then decoded into keys by this driver.
+
+config TPL_CROS_EC_KEYB
+	bool "Enable Chrome OS EC keyboard support in TPL"
+	depends on TPL_INPUT
 	help
 	  Most ARM Chromebooks use an EC to provide access to the keyboard.
 	  Messages are used to request key scans from the EC and these are
@@ -24,3 +92,41 @@ config I8042_KEYB
 	  driver handles English and German keyboards - set the environment
 	  variable 'keymap' to "de" to select German. Keyboard repeat is
 	  handled by the keyboard itself.
+
+config RK8XX_PWRKEY
+	bool "Enable RK805/rk806/816/817 pwrkey support"
+	depends on DM_KEY && (PMIC_RK8XX || PMIC_SPI_RK8XX) && IRQ
+	help
+	  This adds a driver for the RK805/816/817 pwrkey support.
+
+config ADC_KEY
+	bool "Enable adc keys support"
+	depends on DM_KEY
+	help
+	  This adds a driver for the adc keys support.
+
+config SPL_ADC_KEY
+        bool "Enable SPL adc keys support without DM"
+        depends on SPL_INPUT
+        help
+          This adds a driver for the SPL adc keys support
+
+config GPIO_KEY
+	bool "Enable gpio keys support"
+	depends on DM_KEY
+	help
+	  This adds a driver for the gpio keys support.
+
+config RK_KEY
+	bool "Enable rk keys support"
+	depends on DM_KEY
+	help
+	  This adds a driver for the rk keys support.
+
+config PWRKEY_DNL_TRIGGER_NUM
+	int "Enter download mode by pwrkey trigger count"
+	default 0
+	depends on DM_KEY && IRQ
+	help
+	  This support enter download mode by press and release pwrkey for times
+	  over the trigger count. The default value 0 means disabled.
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 9109ac6dba..d7ce0f3c73 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -5,16 +5,30 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-$(CONFIG_DM_KEYBOARD) += keyboard-uclass.o
+obj-$(CONFIG_$(SPL_)DM_KEY) += key-uclass.o
+obj-$(CONFIG_DM_RC) += rc-uclass.o
+obj-$(CONFIG_RK_IR) += rockchip_ir.o
 
+obj-y += input.o
+obj-$(CONFIG_$(SPL_TPL_)CROS_EC_KEYB) += cros_ec_keyb.o
+obj-$(CONFIG_$(SPL_TPL_)OF_CONTROL) += key_matrix.o
+obj-$(CONFIG_$(SPL_TPL_)DM_KEYBOARD) += keyboard-uclass.o
+
+ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_I8042_KEYB) += i8042.o
 obj-$(CONFIG_TEGRA_KEYBOARD) += tegra-kbc.o
 obj-$(CONFIG_TWL4030_INPUT) += twl4030.o
 obj-$(CONFIG_TWL6030_INPUT) += twl6030.o
-obj-$(CONFIG_CROS_EC_KEYB) += cros_ec_keyb.o
+obj-$(CONFIG_RK8XX_PWRKEY) += rk8xx_pwrkey.o
+obj-$(CONFIG_ADC_KEY) += adc_key.o
+obj-$(CONFIG_GPIO_KEY) += gpio_key.o
+obj-$(CONFIG_RK_KEY) += rk_key.o
+obj-$(CONFIG_RK8XX_PWRKEY) += rk8xx_pwrkey.o
 ifdef CONFIG_PS2KBD
 obj-y += keyboard.o pc_keyb.o
 obj-$(CONFIG_PS2MULT) += ps2mult.o ps2ser.o
 endif
-obj-y += input.o
-obj-$(CONFIG_$(SPL_)OF_CONTROL) += key_matrix.o
+
+else
+obj-$(CONFIG_SPL_ADC_KEY) += spl_adc_key.o
+endif
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 26da3a95ff..4c84dd40ae 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -650,7 +650,7 @@ int input_stdio_register(struct stdio_dev *dev)
 	int error;
 
 	error = stdio_register(dev);
-
+#if !defined(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(ENV_SUPPORT)
 	/* check if this is the standard input device */
 	if (!error && strcmp(env_get("stdin"), dev->name) == 0) {
 		/* reassign the console */
@@ -658,6 +658,9 @@ int input_stdio_register(struct stdio_dev *dev)
 				console_assign(stdin, dev->name))
 			return -1;
 	}
+#else
+	error = error;
+#endif
 
 	return 0;
 }
diff --git a/drivers/led/led_gpio.c b/drivers/led/led_gpio.c
index 9976635887..56702a1417 100644
--- a/drivers/led/led_gpio.c
+++ b/drivers/led/led_gpio.c
@@ -60,11 +60,29 @@ static int led_gpio_probe(struct udevice *dev)
 {
 	struct led_uc_plat *uc_plat = dev_get_uclass_platdata(dev);
 	struct led_gpio_priv *priv = dev_get_priv(dev);
+	const char *state;
+	int ret;
 
 	/* Ignore the top-level LED node */
 	if (!uc_plat->label)
 		return 0;
-	return gpio_request_by_name(dev, "gpios", 0, &priv->gpio, GPIOD_IS_OUT);
+
+	ret = gpio_request_by_name(dev, "gpios", 0, &priv->gpio, GPIOD_IS_OUT);
+	if (ret) {
+		printf("Failed to request gpios of led '%s'\n", uc_plat->label);
+		return ret;
+	}
+
+	/* Apply default state */
+	state = dev_read_prop(dev, "default-state", NULL);
+	if (state) {
+		if (!strcmp(state, "on"))
+			ret = gpio_led_set_state(dev, LEDST_ON);
+		else if (!strcmp(state, "off"))
+			ret = gpio_led_set_state(dev, LEDST_OFF);
+	}
+
+	return ret;
 }
 
 static int led_gpio_remove(struct udevice *dev)
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 3d282d5b14..7e009fc46b 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -13,6 +13,36 @@ config MISC
 	  set of generic read, write and ioctl methods may be used to
 	  access the device.
 
+config SPL_MISC
+	bool "Enable Driver Model for Misc drivers in SPL"
+	depends on SPL_DM
+	help
+	  Enable driver model for miscellaneous devices. This class is
+	  used only for those do not fit other more general classes. A
+	  set of generic read, write and ioctl methods may be used to
+	  access the device.
+
+config TPL_MISC
+	bool "Enable Driver Model for Misc drivers in TPL"
+	depends on TPL_DM
+	help
+	  Enable driver model for miscellaneous devices. This class is
+	  used only for those do not fit other more general classes. A
+	  set of generic read, write and ioctl methods may be used to
+	  access the device.
+
+config MISC_DECOMPRESS
+	bool "Enable misc decompress driver support"
+	depends on MISC
+	help
+	  Enable misc decompress driver support.
+
+config SPL_MISC_DECOMPRESS
+	bool "Enable misc decompress driver support in SPL"
+	depends on SPL_MISC
+	help
+	  Enable misc decompress driver support in spl.
+
 config ALTERA_SYSID
 	bool "Altera Sysid support"
 	depends on MISC
@@ -41,6 +71,33 @@ config ROCKCHIP_EFUSE
 	  extended (by porting the read function from the Linux kernel sources)
 	  to support other recent Rockchip devices.
 
+config ROCKCHIP_OTP
+	bool "Rockchip OTP Support"
+	depends on MISC
+	help
+	  This is a simple drive to dump specified values of Rockchip SoC
+	  from otp, such as cpu-leakage.
+
+config ROCKCHIP_HW_DECOMPRESS
+	bool "Rockchip HardWare Decompress Support"
+	depends on MISC_DECOMPRESS
+	help
+	  This driver support Decompress IP built-in Rockchip SoC, support
+	  LZ4, GZIP, PNG, ZLIB.
+
+config SPL_ROCKCHIP_HW_DECOMPRESS
+	bool "Rockchip HardWare Decompress Support"
+	depends on SPL_MISC_DECOMPRESS
+	help
+	  This driver support Decompress IP built-in Rockchip SoC, support
+	  LZ4, GZIP, PNG, ZLIB.
+
+config SPL_ROCKCHIP_SECURE_OTP
+	bool "Rockchip Secure OTP Support in spl"
+	depends on SPL_MISC
+	help
+	  Support read & write secure otp in spl.
+
 config CMD_CROS_EC
 	bool "Enable crosec command"
 	depends on CROS_EC
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 10265c8fb4..b2626182cc 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -5,7 +5,8 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-$(CONFIG_MISC) += misc-uclass.o
+obj-$(CONFIG_$(SPL_TPL_)MISC) += misc-uclass.o misc_otp.o
+obj-$(CONFIG_$(SPL_TPL_)MISC_DECOMPRESS) += misc_decompress.o
 obj-$(CONFIG_ALI152X) += ali512x.o
 obj-$(CONFIG_ALTERA_SYSID) += altera_sysid.o
 obj-$(CONFIG_ATSHA204A) += atsha204a-i2c.o
@@ -20,7 +21,7 @@ obj-$(CONFIG_CROS_EC_SPI) += cros_ec_spi.o
 endif
 obj-$(CONFIG_FSL_IIM) += fsl_iim.o
 obj-$(CONFIG_LED_STATUS_GPIO) += gpio_led.o
-obj-$(CONFIG_I2C_EEPROM) += i2c_eeprom.o
+obj-$(CONFIG_$(SPL_TPL_)I2C_EEPROM) += i2c_eeprom.o
 obj-$(CONFIG_FSL_MC9SDZ60) += mc9sdz60.o
 obj-$(CONFIG_MXC_OCOTP) += mxc_ocotp.o
 obj-$(CONFIG_MXS_OCOTP) += mxs_ocotp.o
@@ -52,3 +53,34 @@ obj-$(CONFIG_FSL_DEVICE_DISABLE) += fsl_devdis.o
 obj-$(CONFIG_WINBOND_W83627) += winbond_w83627.o
 obj-$(CONFIG_QFW) += qfw.o
 obj-$(CONFIG_ROCKCHIP_EFUSE) += rockchip-efuse.o
+obj-$(CONFIG_ROCKCHIP_OTP) += rockchip-otp.o
+
+ifdef CONFIG_ROCKCHIP_RK3308
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += rk3308-secure-otp.o
+endif
+
+ifdef CONFIG_ROCKCHIP_PX30
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += px30-secure-otp.o
+endif
+
+ifdef CONFIG_ROCKCHIP_RK3328
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += rk3328-secure-otp.o
+endif
+
+ifdef CONFIG_ROCKCHIP_RK3568
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += rk3568-secure-otp.o
+endif
+
+ifdef CONFIG_ROCKCHIP_RV1106
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += rv1106-secure-otp.o
+endif
+
+ifdef CONFIG_ROCKCHIP_RV1126
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += rv1126-secure-otp.o
+endif
+
+ifdef CONFIG_ROCKCHIP_RK3588
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_SECURE_OTP) += rk3588-secure-otp.o
+endif
+
+obj-$(CONFIG_$(SPL_TPL_)ROCKCHIP_HW_DECOMPRESS) += rockchip_decompress.o
diff --git a/drivers/misc/cros_ec.c b/drivers/misc/cros_ec.c
index feaa5d8567..eefaaa53ad 100644
--- a/drivers/misc/cros_ec.c
+++ b/drivers/misc/cros_ec.c
@@ -1038,8 +1038,7 @@ int cros_ec_decode_ec_flash(struct udevice *dev, struct fdt_cros_ec *config)
 
 	config->flash_erase_value = ofnode_read_s32_default(flash_node,
 							    "erase-value", -1);
-	for (node = ofnode_first_subnode(flash_node); ofnode_valid(node);
-	     node = ofnode_next_subnode(node)) {
+	ofnode_for_each_subnode(node, flash_node) {
 		const char *name = ofnode_get_name(node);
 		enum ec_flash_region region;
 
diff --git a/drivers/misc/misc-uclass.c b/drivers/misc/misc-uclass.c
index d9eea3dac5..2163830878 100644
--- a/drivers/misc/misc-uclass.c
+++ b/drivers/misc/misc-uclass.c
@@ -56,6 +56,33 @@ int misc_call(struct udevice *dev, int msgid, void *tx_msg, int tx_size,
 	return ops->call(dev, msgid, tx_msg, tx_size, rx_msg, rx_size);
 }
 
+struct udevice *misc_get_device_by_capability(u32 capability)
+{
+	const struct misc_ops *ops;
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret;
+	u32 cap;
+
+	ret = uclass_get(UCLASS_MISC, &uc);
+	if (ret)
+		return NULL;
+
+	for (uclass_first_device(UCLASS_MISC, &dev);
+	     dev;
+	     uclass_next_device(&dev)) {
+		ops = device_get_ops(dev);
+		if (!ops || !ops->ioctl)
+			continue;
+
+		ret = ops->ioctl(dev, IOCTL_REQ_CAPABILITY, &cap);
+		if (!ret && ((cap & capability) == capability))
+			return dev;
+	}
+
+	return NULL;
+}
+
 UCLASS_DRIVER(misc) = {
 	.id		= UCLASS_MISC,
 	.name		= "misc",
diff --git a/drivers/misc/rockchip-efuse.c b/drivers/misc/rockchip-efuse.c
index 2e3bc9137a..7aba9b8964 100644
--- a/drivers/misc/rockchip-efuse.c
+++ b/drivers/misc/rockchip-efuse.c
@@ -12,9 +12,51 @@
 #include <command.h>
 #include <display_options.h>
 #include <dm.h>
+#include <linux/arm-smccc.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <misc.h>
+#include <asm/arch-rockchip/rockchip_smccc.h>
+
+#define T_CSB_P_S		0
+#define T_PGENB_P_S		0
+#define T_LOAD_P_S		0
+#define T_ADDR_P_S		0
+#define T_STROBE_P_S		(0 + 110) /* 1.1us */
+#define T_CSB_P_L		(0 + 110 + 1000 + 20) /* 200ns */
+#define T_PGENB_P_L		(0 + 110 + 1000 + 20)
+#define T_LOAD_P_L		(0 + 110 + 1000 + 20)
+#define T_ADDR_P_L		(0 + 110 + 1000 + 20)
+#define T_STROBE_P_L		(0 + 110 + 1000) /* 10us */
+#define T_CSB_R_S		0
+#define T_PGENB_R_S		0
+#define T_LOAD_R_S		0
+#define T_ADDR_R_S		2
+#define T_STROBE_R_S		(2 + 3)
+#define T_CSB_R_L		(2 + 3 + 3 + 3)
+#define T_PGENB_R_L		(2 + 3 + 3 + 3)
+#define T_LOAD_R_L		(2 + 3 + 3 + 3)
+#define T_ADDR_R_L		(2 + 3 + 3 + 2)
+#define T_STROBE_R_L		(2 + 3 + 3)
+
+#define T_CSB_P			0x28
+#define T_PGENB_P		0x2c
+#define T_LOAD_P		0x30
+#define T_ADDR_P		0x34
+#define T_STROBE_P		0x38
+#define T_CSB_R			0x3c
+#define T_PGENB_R		0x40
+#define T_LOAD_R		0x44
+#define T_ADDR_R		0x48
+#define T_STROBE_R		0x4c
+
+#define RK1808_USER_MODE	BIT(0)
+#define RK1808_INT_FINISH	BIT(0)
+#define RK1808_AUTO_ENB		BIT(0)
+#define RK1808_AUTO_RD		BIT(1)
+#define RK1808_A_SHIFT		16
+#define RK1808_A_MASK		0x3ff
+#define RK1808_NBYTES		4
 
 #define RK3399_A_SHIFT          16
 #define RK3399_A_MASK           0x3ff
@@ -28,6 +70,24 @@
 #define RK3399_STROBE           BIT(1)
 #define RK3399_CSB              BIT(0)
 
+#define RK3288_A_SHIFT          6
+#define RK3288_A_MASK           0x3ff
+#define RK3288_NFUSES           32
+#define RK3288_BYTES_PER_FUSE   1
+#define RK3288_PGENB            BIT(3)
+#define RK3288_LOAD             BIT(2)
+#define RK3288_STROBE           BIT(1)
+#define RK3288_CSB              BIT(0)
+
+#define RK3328_INT_STATUS	0x0018
+#define RK3328_DOUT		0x0020
+#define RK3328_AUTO_CTRL	0x0024
+#define RK3328_INT_FINISH	BIT(0)
+#define RK3328_AUTO_ENB		BIT(0)
+#define RK3328_AUTO_RD		BIT(1)
+
+typedef int (*EFUSE_READ)(struct udevice *dev, int offset, void *buf, int size);
+
 struct rockchip_efuse_regs {
 	u32 ctrl;      /* 0x00  efuse control register */
 	u32 dout;      /* 0x04  efuse data out register */
@@ -36,6 +96,10 @@ struct rockchip_efuse_regs {
 	u32 jtag_pass; /* 0x10  JTAG password */
 	u32 strobe_finish_ctrl;
 		       /* 0x14	efuse strobe finish control register */
+	u32 int_status;/* 0x18 */
+	u32 reserved;  /* 0x1c */
+	u32 dout2;     /* 0x20 */
+	u32 auto_ctrl; /* 0x24 */
 };
 
 struct rockchip_efuse_platdata {
@@ -43,45 +107,121 @@ struct rockchip_efuse_platdata {
 	struct clk *clk;
 };
 
-#if defined(DEBUG)
-static int dump_efuses(cmd_tbl_t *cmdtp, int flag,
-		       int argc, char * const argv[])
+static void rk1808_efuse_timing_init(void __iomem *base)
+{
+	static bool init;
+
+	if (init)
+		return;
+
+	/* enable auto mode */
+	writel(readl(base) & (~RK1808_USER_MODE), base);
+
+	/* setup efuse timing */
+	writel((T_CSB_P_S << 16) | T_CSB_P_L, base + T_CSB_P);
+	writel((T_PGENB_P_S << 16) | T_PGENB_P_L, base + T_PGENB_P);
+	writel((T_LOAD_P_S << 16) | T_LOAD_P_L, base + T_LOAD_P);
+	writel((T_ADDR_P_S << 16) | T_ADDR_P_L, base + T_ADDR_P);
+	writel((T_STROBE_P_S << 16) | T_STROBE_P_L, base + T_STROBE_P);
+	writel((T_CSB_R_S << 16) | T_CSB_R_L, base + T_CSB_R);
+	writel((T_PGENB_R_S << 16) | T_PGENB_R_L, base + T_PGENB_R);
+	writel((T_LOAD_R_S << 16) | T_LOAD_R_L, base + T_LOAD_R);
+	writel((T_ADDR_R_S << 16) | T_ADDR_R_L, base + T_ADDR_R);
+	writel((T_STROBE_R_S << 16) | T_STROBE_R_L, base + T_STROBE_R);
+
+	init = true;
+}
+
+static int rockchip_rk1808_efuse_read(struct udevice *dev, int offset,
+				      void *buf, int size)
 {
-	/*
-	 * N.B.: This function is tailored towards the RK3399 and assumes that
-	 *       there's always 32 fuses x 32 bits (i.e. 128 bytes of data) to
-	 *       be read.
-	 */
-
-	struct udevice *dev;
-	u8 fuses[128];
-	int ret;
-
-	/* retrieve the device */
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_GET_DRIVER(rockchip_efuse), &dev);
-	if (ret) {
-		printf("%s: no misc-device found\n", __func__);
-		return 0;
+	struct rockchip_efuse_platdata *plat = dev_get_platdata(dev);
+	struct rockchip_efuse_regs *efuse =
+		(struct rockchip_efuse_regs *)plat->base;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	u32 out_value, status;
+	u8 *buffer;
+	int ret = 0, i = 0;
+
+	rk1808_efuse_timing_init(plat->base);
+
+	addr_start = rounddown(offset, RK1808_NBYTES) / RK1808_NBYTES;
+	addr_end = roundup(offset + size, RK1808_NBYTES) / RK1808_NBYTES;
+	addr_offset = offset % RK1808_NBYTES;
+	addr_len = addr_end - addr_start;
+
+	buffer = calloc(1, sizeof(*buffer) * addr_len * RK1808_NBYTES);
+	if (!buffer)
+		return -ENOMEM;
+
+	while (addr_len--) {
+		writel(RK1808_AUTO_RD | RK1808_AUTO_ENB |
+		       ((addr_start++ & RK1808_A_MASK) << RK1808_A_SHIFT),
+		       &efuse->auto_ctrl);
+		udelay(2);
+		status = readl(&efuse->int_status);
+		if (!(status & RK1808_INT_FINISH)) {
+			ret = -EIO;
+			goto err;
+		}
+		out_value = readl(&efuse->dout2);
+		writel(RK1808_INT_FINISH, &efuse->int_status);
+
+		memcpy(&buffer[i], &out_value, RK1808_NBYTES);
+		i += RK1808_NBYTES;
 	}
+	memcpy(buf, buffer + addr_offset, size);
+err:
+	kfree(buffer);
+
+	return ret;
+}
 
-	ret = misc_read(dev, 0, &fuses, sizeof(fuses));
-	if (ret) {
-		printf("%s: misc_read failed\n", __func__);
-		return 0;
+#ifndef CONFIG_SPL_BUILD
+static int rockchip_rk3368_efuse_read(struct udevice *dev, int offset,
+				      void *buf, int size)
+{
+	struct rockchip_efuse_platdata *plat = dev_get_platdata(dev);
+	struct rockchip_efuse_regs *efuse =
+		(struct rockchip_efuse_regs *)plat->base;
+	u8 *buffer = buf;
+	struct arm_smccc_res res;
+
+	/* Switch to read mode */
+	sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+				 RK3288_LOAD | RK3288_PGENB);
+	udelay(1);
+	while (size--) {
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl, res.a1 &
+					 (~(RK3288_A_MASK << RK3288_A_SHIFT)));
+		/* set addr */
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl, res.a1 |
+					 ((offset++ & RK3288_A_MASK) <<
+					  RK3288_A_SHIFT));
+		udelay(1);
+		/* strobe low to high */
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+					 res.a1 | RK3288_STROBE);
+		ndelay(60);
+		/* read data */
+		res = sip_smc_secure_reg_read((ulong)&efuse->dout);
+		*buffer++ = res.a1;
+		/* reset strobe to low */
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+					 res.a1 & (~RK3288_STROBE));
+		udelay(1);
 	}
 
-	printf("efuse-contents:\n");
-	print_buffer(0, fuses, 1, 128, 16);
+	/* Switch to standby mode */
+	sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+				 RK3288_PGENB | RK3288_CSB);
 
 	return 0;
 }
-
-U_BOOT_CMD(
-	rk3399_dump_efuses, 1, 1, dump_efuses,
-	"Dump the content of the efuses",
-	""
-);
 #endif
 
 static int rockchip_rk3399_efuse_read(struct udevice *dev, int offset,
@@ -128,26 +268,235 @@ static int rockchip_rk3399_efuse_read(struct udevice *dev, int offset,
 	return 0;
 }
 
+static int rockchip_rk3288_efuse_read(struct udevice *dev, int offset,
+				      void *buf, int size)
+{
+	struct rockchip_efuse_platdata *plat = dev_get_platdata(dev);
+	struct rockchip_efuse_regs *efuse =
+		(struct rockchip_efuse_regs *)plat->base;
+	u8 *buffer = buf;
+	int max_size = RK3288_NFUSES * RK3288_BYTES_PER_FUSE;
+
+	if (size > (max_size - offset))
+		size = max_size - offset;
+
+	/* Switch to read mode */
+	writel(RK3288_LOAD | RK3288_PGENB, &efuse->ctrl);
+	udelay(1);
+
+	while (size--) {
+		writel(readl(&efuse->ctrl) &
+				(~(RK3288_A_MASK << RK3288_A_SHIFT)),
+				&efuse->ctrl);
+		/* set addr */
+		writel(readl(&efuse->ctrl) |
+				((offset++ & RK3288_A_MASK) << RK3288_A_SHIFT),
+				&efuse->ctrl);
+		udelay(1);
+		/* strobe low to high */
+		writel(readl(&efuse->ctrl) |
+				RK3288_STROBE, &efuse->ctrl);
+		ndelay(60);
+		/* read data */
+		*buffer++ = readl(&efuse->dout);
+		/* reset strobe to low */
+		writel(readl(&efuse->ctrl) &
+				(~RK3288_STROBE), &efuse->ctrl);
+		udelay(1);
+	}
+
+	/* Switch to standby mode */
+	writel(RK3288_PGENB | RK3288_CSB, &efuse->ctrl);
+
+	return 0;
+}
+
+#ifndef CONFIG_SPL_BUILD
+static int rockchip_rk3288_efuse_secure_read(struct udevice *dev, int offset,
+					     void *buf, int size)
+{
+	struct rockchip_efuse_platdata *plat = dev_get_platdata(dev);
+	struct rockchip_efuse_regs *efuse =
+		(struct rockchip_efuse_regs *)plat->base;
+	u8 *buffer = buf;
+	int max_size = RK3288_NFUSES * RK3288_BYTES_PER_FUSE;
+	struct arm_smccc_res res;
+
+	if (size > (max_size - offset))
+		size = max_size - offset;
+
+	/* Switch to read mode */
+	sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+				 RK3288_LOAD | RK3288_PGENB);
+	udelay(1);
+	while (size--) {
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl, res.a1 &
+					 (~(RK3288_A_MASK << RK3288_A_SHIFT)));
+		/* set addr */
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl, res.a1 |
+					 ((offset++ & RK3288_A_MASK) <<
+					  RK3288_A_SHIFT));
+		udelay(1);
+		/* strobe low to high */
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+					 res.a1 | RK3288_STROBE);
+		ndelay(60);
+		/* read data */
+		res = sip_smc_secure_reg_read((ulong)&efuse->dout);
+		*buffer++ = res.a1;
+		/* reset strobe to low */
+		res = sip_smc_secure_reg_read((ulong)&efuse->ctrl);
+		sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+					 res.a1 & (~RK3288_STROBE));
+		udelay(1);
+	}
+
+	/* Switch to standby mode */
+	sip_smc_secure_reg_write((ulong)&efuse->ctrl,
+				 RK3288_PGENB | RK3288_CSB);
+
+	return 0;
+}
+#endif
+
+static int rockchip_rk3328_efuse_read(struct udevice *dev, int offset,
+				      void *buf, int size)
+{
+	struct rockchip_efuse_platdata *plat = dev_get_platdata(dev);
+	struct rockchip_efuse_regs *efuse =
+		(struct rockchip_efuse_regs *)plat->base;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	u32 out_value, status;
+	u8 *buffer;
+	int ret = 0, i = 0, j = 0;
+
+	/* Max non-secure Byte */
+	if (size > 32)
+		size = 32;
+
+	/* 128 Byte efuse, 96 Byte for secure, 32 Byte for non-secure */
+	offset += 96;
+	addr_start = rounddown(offset, RK3399_BYTES_PER_FUSE) /
+						RK3399_BYTES_PER_FUSE;
+	addr_end = roundup(offset + size, RK3399_BYTES_PER_FUSE) /
+						RK3399_BYTES_PER_FUSE;
+	addr_offset = offset % RK3399_BYTES_PER_FUSE;
+	addr_len = addr_end - addr_start;
+
+	buffer = calloc(1, sizeof(*buffer) * addr_len * RK3399_BYTES_PER_FUSE);
+	if (!buffer)
+		return -ENOMEM;
+
+	for (j = 0; j < addr_len; j++) {
+		writel(RK3328_AUTO_RD | RK3328_AUTO_ENB |
+		       ((addr_start++ & RK3399_A_MASK) << RK3399_A_SHIFT),
+		         &efuse->auto_ctrl);
+		udelay(5);
+		status = readl(&efuse->int_status);
+		if (!(status & RK3328_INT_FINISH)) {
+			ret = -EIO;
+			goto err;
+		}
+		out_value = readl(&efuse->dout2);
+		writel(RK3328_INT_FINISH, &efuse->int_status);
+
+		memcpy(&buffer[i], &out_value, RK3399_BYTES_PER_FUSE);
+		i += RK3399_BYTES_PER_FUSE;
+	}
+	memcpy(buf, buffer + addr_offset, size);
+err:
+	free(buffer);
+
+	return ret;
+}
+
 static int rockchip_efuse_read(struct udevice *dev, int offset,
 			       void *buf, int size)
 {
-	return rockchip_rk3399_efuse_read(dev, offset, buf, size);
+	EFUSE_READ efuse_read = NULL;
+
+	efuse_read = (EFUSE_READ)dev_get_driver_data(dev);
+	if (!efuse_read)
+		return -ENOSYS;
+
+	return (*efuse_read)(dev, offset, buf, size);
+}
+
+static int rockchip_efuse_capatiblity(struct udevice *dev, u32 *buf)
+{
+	*buf = device_is_compatible(dev, "rockchip,rk3288-secure-efuse") ?
+	       OTP_S : OTP_NS;
+
+	return 0;
+}
+
+static int rockchip_efuse_ioctl(struct udevice *dev, unsigned long request,
+				void *buf)
+{
+	int ret = -EINVAL;
+
+	switch (request) {
+	case IOCTL_REQ_CAPABILITY:
+		ret = rockchip_efuse_capatiblity(dev, buf);
+		break;
+	}
+
+	return ret;
 }
 
 static const struct misc_ops rockchip_efuse_ops = {
 	.read = rockchip_efuse_read,
+	.ioctl = rockchip_efuse_ioctl,
 };
 
 static int rockchip_efuse_ofdata_to_platdata(struct udevice *dev)
 {
 	struct rockchip_efuse_platdata *plat = dev_get_platdata(dev);
 
-	plat->base = (void *)dev_read_addr(dev);
+	plat->base = dev_read_addr_ptr(dev);
 	return 0;
 }
 
 static const struct udevice_id rockchip_efuse_ids[] = {
-	{ .compatible = "rockchip,rk3399-efuse" },
+	{
+		.compatible = "rockchip,rk1808-efuse",
+		.data = (ulong)&rockchip_rk1808_efuse_read,
+	},
+#ifndef CONFIG_SPL_BUILD
+	{
+		.compatible = "rockchip,rk3288-secure-efuse",
+		.data = (ulong)&rockchip_rk3288_efuse_secure_read,
+	},
+#endif
+	{
+		.compatible = "rockchip,rk3066a-efuse",
+		.data = (ulong)&rockchip_rk3288_efuse_read,
+	},
+	{
+		.compatible = "rockchip,rk3188-efuse",
+		.data = (ulong)&rockchip_rk3288_efuse_read,
+	},
+	{
+		.compatible = "rockchip,rk322x-efuse",
+		.data = (ulong)&rockchip_rk3288_efuse_read,
+	},
+	{
+		.compatible = "rockchip,rk3328-efuse",
+		.data = (ulong)&rockchip_rk3328_efuse_read,
+	},
+#ifndef CONFIG_SPL_BUILD
+	{
+		.compatible = "rockchip,rk3368-efuse",
+		.data = (ulong)&rockchip_rk3368_efuse_read,
+	},
+#endif
+	{
+		.compatible = "rockchip,rk3399-efuse",
+		.data = (ulong)&rockchip_rk3399_efuse_read,
+	},
 	{}
 };
 
diff --git a/drivers/misc/tegra186_bpmp.c b/drivers/misc/tegra186_bpmp.c
index d61bacfc44..1fdf8efff3 100644
--- a/drivers/misc/tegra186_bpmp.c
+++ b/drivers/misc/tegra186_bpmp.c
@@ -44,7 +44,7 @@ static int tegra186_bpmp_call(struct udevice *dev, int mrq, void *tx_msg,
 
 	ret = tegra_ivc_write_get_next_frame(&priv->ivc, &ivc_frame);
 	if (ret) {
-		error("tegra_ivc_write_get_next_frame() failed: %d\n", ret);
+		pr_err("tegra_ivc_write_get_next_frame() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -55,7 +55,7 @@ static int tegra186_bpmp_call(struct udevice *dev, int mrq, void *tx_msg,
 
 	ret = tegra_ivc_write_advance(&priv->ivc);
 	if (ret) {
-		error("tegra_ivc_write_advance() failed: %d\n", ret);
+		pr_err("tegra_ivc_write_advance() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -63,7 +63,7 @@ static int tegra186_bpmp_call(struct udevice *dev, int mrq, void *tx_msg,
 	for (;;) {
 		ret = tegra_ivc_channel_notified(&priv->ivc);
 		if (ret) {
-			error("tegra_ivc_channel_notified() failed: %d\n", ret);
+			pr_err("tegra_ivc_channel_notified() failed: %d\n", ret);
 			return ret;
 		}
 
@@ -73,7 +73,7 @@ static int tegra186_bpmp_call(struct udevice *dev, int mrq, void *tx_msg,
 
 		/* Timeout 20ms; roughly 10x current max observed duration */
 		if ((timer_get_us() - start_time) > 20 * 1000) {
-			error("tegra_ivc_read_get_next_frame() timed out (%d)\n",
+			pr_err("tegra_ivc_read_get_next_frame() timed out (%d)\n",
 			      ret);
 			return -ETIMEDOUT;
 		}
@@ -86,12 +86,12 @@ static int tegra186_bpmp_call(struct udevice *dev, int mrq, void *tx_msg,
 
 	ret = tegra_ivc_read_advance(&priv->ivc);
 	if (ret) {
-		error("tegra_ivc_write_advance() failed: %d\n", ret);
+		pr_err("tegra_ivc_write_advance() failed: %d\n", ret);
 		return ret;
 	}
 
 	if (err) {
-		error("BPMP responded with error %d\n", err);
+		pr_err("BPMP responded with error %d\n", err);
 		/* err isn't a U-Boot error code, so don't that */
 		return -EIO;
 	}
@@ -144,14 +144,14 @@ static ulong tegra186_bpmp_get_shmem(struct udevice *dev, int index)
 	ret = fdtdec_parse_phandle_with_args(gd->fdt_blob, dev_of_offset(dev),
 					      "shmem", NULL, 0, index, &args);
 	if (ret < 0) {
-		error("fdtdec_parse_phandle_with_args() failed: %d\n", ret);
+		pr_err("fdtdec_parse_phandle_with_args() failed: %d\n", ret);
 		return ret;
 	}
 
 	reg = fdtdec_get_addr_size_auto_noparent(gd->fdt_blob, args.node,
 						 "reg", 0, NULL, true);
 	if (reg == FDT_ADDR_T_NONE) {
-		error("fdtdec_get_addr_size_auto_noparent() failed\n");
+		pr_err("fdtdec_get_addr_size_auto_noparent() failed\n");
 		return -ENODEV;
 	}
 
@@ -166,7 +166,7 @@ static void tegra186_bpmp_ivc_notify(struct tegra_ivc *ivc)
 
 	ret = mbox_send(&priv->mbox, NULL);
 	if (ret)
-		error("mbox_send() failed: %d\n", ret);
+		pr_err("mbox_send() failed: %d\n", ret);
 }
 
 static int tegra186_bpmp_probe(struct udevice *dev)
@@ -179,18 +179,18 @@ static int tegra186_bpmp_probe(struct udevice *dev)
 
 	ret = mbox_get_by_index(dev, 0, &priv->mbox);
 	if (ret) {
-		error("mbox_get_by_index() failed: %d\n", ret);
+		pr_err("mbox_get_by_index() failed: %d\n", ret);
 		return ret;
 	}
 
 	tx_base = tegra186_bpmp_get_shmem(dev, 0);
 	if (IS_ERR_VALUE(tx_base)) {
-		error("tegra186_bpmp_get_shmem failed for tx_base\n");
+		pr_err("tegra186_bpmp_get_shmem failed for tx_base\n");
 		return tx_base;
 	}
 	rx_base = tegra186_bpmp_get_shmem(dev, 1);
 	if (IS_ERR_VALUE(rx_base)) {
-		error("tegra186_bpmp_get_shmem failed for rx_base\n");
+		pr_err("tegra186_bpmp_get_shmem failed for rx_base\n");
 		return rx_base;
 	}
 	debug("shmem: rx=%lx, tx=%lx\n", rx_base, tx_base);
@@ -198,7 +198,7 @@ static int tegra186_bpmp_probe(struct udevice *dev)
 	ret = tegra_ivc_init(&priv->ivc, rx_base, tx_base, BPMP_IVC_FRAME_COUNT,
 			     BPMP_IVC_FRAME_SIZE, tegra186_bpmp_ivc_notify);
 	if (ret) {
-		error("tegra_ivc_init() failed: %d\n", ret);
+		pr_err("tegra_ivc_init() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -211,7 +211,7 @@ static int tegra186_bpmp_probe(struct udevice *dev)
 
 		/* Timeout 100ms */
 		if ((timer_get_us() - start_time) > 100 * 1000) {
-			error("Initial IVC reset timed out (%d)\n", ret);
+			pr_err("Initial IVC reset timed out (%d)\n", ret);
 			ret = -ETIMEDOUT;
 			goto err_free_mbox;
 		}
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 6de927b8c6..8e365e45f5 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -10,6 +10,13 @@ config MMC
 	  If you want MMC/SD/SDIO support, you should say Y here and
 	  also to your specific host controller driver.
 
+config MMC_WRITE
+	bool "support for MMC/SD write operations"
+	depends on MMC
+	default y
+	help
+	  Enable write access to MMC and SD Cards
+
 config DM_MMC
 	bool "Enable MMC controllers using Driver Model"
 	depends on DM
@@ -48,6 +55,19 @@ config SPL_MMC_TINY
 	  operations too, which can remove the need for malloc support in SPL
 	  and thus further reduce footprint.
 
+config MMC_SIMPLE
+	bool "Reduce mmc code size"
+	help
+	  Reduce mmc code size.
+
+config SUPPORT_EMMC_RPMB
+	bool "Support eMMC replay protected memory block (RPMB)"
+	depends on MMC && CMD_MMC
+	default y
+	help
+	  Enable support for reading, writing and programming the
+	  key for the Replay Protection Memory Block partition in eMMC.
+
 config MMC_DAVINCI
 	bool "TI DAVINCI Multimedia Card Interface support"
 	depends on ARCH_DAVINCI
@@ -119,6 +139,10 @@ config MMC_MXC
 
 config MMC_MXS
 	bool "Freescale MXS Multimedia Card Interface support"
+	depends on MX23 || MX28 || MX6 || MX7
+	select APBH_DMA
+	select APBH_DMA_BURST if ARCH_MX6 || ARCH_MX7
+	select APBH_DMA_BURST8 if ARCH_MX6 || ARCH_MX7
 	help
 	  This selects the Freescale SSP MMC controller found on MXS based
 	  platforms like mx23/28.
@@ -229,6 +253,17 @@ config MMC_SDHCI_BCM2835
 
 	  If unsure, say N.
 
+config MMC_SDHCI_BCMSTB
+	tristate "SDHCI support for the BCMSTB SD/MMC Controller"
+	depends on MMC_SDHCI
+	help
+	  This selects the Broadcom set-top box SD/MMC controller.
+
+	  If you have a BCMSTB platform with SD or MMC devices,
+	  say Y here.
+
+	  If unsure, say N.
+
 config MMC_SDHCI_CADENCE
 	bool "SDHCI support for the Cadence SD/SDIO/eMMC controller"
 	depends on BLK && DM_MMC
@@ -382,6 +417,13 @@ config GENERIC_ATMEL_MCI
 	  the SD Memory Card Specification V2.0, the SDIO V2.0 specification
 	  and CE-ATA V1.1.
 
+config MMC_USE_PRE_CONFIG
+	bool "Enable to use pre-configure set by pre-loader or bootrom"
+	help
+	  The MMC is initialized by pre-loader or bootrom, so it is no need to
+	  initialize it again. Open this config to skip some unused initialized
+	  process.
+
 endif
 
 config TEGRA124_MMC_DISABLE_EXT_LOOPBACK
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index a6becb2309..4e0e6330d0 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -7,6 +7,7 @@
 
 obj-y += mmc.o
 obj-$(CONFIG_$(SPL_)DM_MMC) += mmc-uclass.o
+obj-$(CONFIG_$(SPL_)MMC_WRITE) += mmc_write.o
 
 ifndef CONFIG_$(SPL_)BLK
 obj-y += mmc_legacy.o
@@ -16,9 +17,6 @@ obj-$(CONFIG_SUPPORT_EMMC_BOOT) += mmc_boot.o
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_MMC_BOOT) += fsl_esdhc_spl.o
-obj-$(CONFIG_SPL_SAVEENV) += mmc_write.o
-else
-obj-y += mmc_write.o
 endif
 
 obj-$(CONFIG_ARM_PL180_MMCI) += arm_pl180_mmci.o
@@ -48,6 +46,7 @@ obj-$(CONFIG_SH_SDHI) += sh_sdhi.o
 obj-$(CONFIG_MMC_SDHCI)			+= sdhci.o
 obj-$(CONFIG_MMC_SDHCI_ATMEL)		+= atmel_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_BCM2835)		+= bcm2835_sdhci.o
+obj-$(CONFIG_MMC_SDHCI_BCMSTB)		+= bcmstb_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_CADENCE)		+= sdhci-cadence.o
 obj-$(CONFIG_MMC_SDHCI_KONA)		+= kona_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_MSM)		+= msm_sdhci.o
diff --git a/drivers/mmc/bcm2835_sdhci.c b/drivers/mmc/bcm2835_sdhci.c
index 3157354d2a..819bd88960 100644
--- a/drivers/mmc/bcm2835_sdhci.c
+++ b/drivers/mmc/bcm2835_sdhci.c
@@ -50,11 +50,6 @@
 #define MIN_FREQ 400000
 #define SDHCI_BUFFER 0x20
 
-struct bcm2835_sdhci_plat {
-	struct mmc_config cfg;
-	struct mmc mmc;
-};
-
 struct bcm2835_sdhci_host {
 	struct sdhci_host host;
 	uint twoticks_delay;
@@ -80,8 +75,7 @@ static inline void bcm2835_sdhci_raw_writel(struct sdhci_host *host, u32 val,
 	 * too)
 	 */
 	if (reg != SDHCI_BUFFER) {
-		while (timer_get_us() - bcm_host->last_write <
-		       bcm_host->twoticks_delay)
+		while (timer_get_us() - bcm_host->last_write < bcm_host->twoticks_delay)
 			;
 	}
 
diff --git a/drivers/mmc/dw_mmc.c b/drivers/mmc/dw_mmc.c
index 23f642980b..ae4a04dafd 100644
--- a/drivers/mmc/dw_mmc.c
+++ b/drivers/mmc/dw_mmc.c
@@ -6,16 +6,82 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
-#include <bouncebuf.h>
 #include <common.h>
+#include <bouncebuf.h>
 #include <errno.h>
 #include <malloc.h>
 #include <memalign.h>
 #include <mmc.h>
 #include <dwmmc.h>
+#ifdef CONFIG_DM_GPIO
+#include <asm/gpio.h>
+#include <asm-generic/gpio.h>
+#endif
 
 #define PAGE_SIZE 4096
 
+/*
+ * Currently it supports read/write up to 8*8*4 Bytes per
+ * stride as a burst mode. Please note that if you change
+ * MAX_STRIDE, you should also update dwmci_memcpy_fromio
+ * to augment the groups of {ldm, stm}.
+ */
+#define MAX_STRIDE 64
+#if (CONFIG_ARM && CONFIG_CPU_V7 && !defined(CONFIG_MMC_SIMPLE))
+void noinline dwmci_memcpy_fromio(void *buffer, void *fifo_addr)
+{
+	__asm__ __volatile__ (
+		"push {r2, r3, r4, r5, r6, r7, r8, r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"pop {r2, r3, r4, r5, r6,r7,r8,r9}\n"
+		:::"memory"
+	);
+}
+
+void noinline dwmci_memcpy_toio(void *buffer, void *fifo_addr)
+{
+	__asm__ __volatile__ (
+		"push {r2, r3, r4, r5, r6, r7, r8, r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"ldm r0!, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"stm r1, {r2,r3,r4,r5,r6,r7,r8,r9}\n"
+		"pop {r2, r3, r4, r5, r6,r7,r8,r9}\n"
+		:::"memory"
+	);
+}
+#else
+void dwmci_memcpy_fromio(void *buffer, void *fifo_addr) {};
+void dwmci_memcpy_toio(void *buffer, void *fifo_addr) {};
+#endif
+
 static int dwmci_wait_reset(struct dwmci_host *host, u32 value)
 {
 	unsigned long timeout = 1000;
@@ -93,27 +159,64 @@ static void dwmci_prepare_data(struct dwmci_host *host,
 	dwmci_writel(host, DWMCI_BYTCNT, data->blocksize * data->blocks);
 }
 
+static unsigned int dwmci_get_timeout(struct mmc *mmc, const unsigned int size)
+{
+	unsigned int timeout;
+
+	timeout = size * 8;	/* counting in bits */
+	timeout *= 10;		/* wait 10 times as long */
+	timeout /= mmc->clock;
+	timeout /= mmc->bus_width;
+	timeout *= 1000;	/* counting in msec */
+	timeout = (timeout < 10000) ? 10000 : timeout;
+
+	return timeout;
+}
+
 static int dwmci_data_transfer(struct dwmci_host *host, struct mmc_data *data)
 {
 	int ret = 0;
-	u32 timeout = 240000;
-	u32 mask, size, i, len = 0;
+	int reset_timeout = 100;
+	u32 timeout, status, ctrl, mask, size, i, len = 0;
 	u32 *buf = NULL;
 	ulong start = get_timer(0);
 	u32 fifo_depth = (((host->fifoth_val & RX_WMARK_MASK) >>
 			    RX_WMARK_SHIFT) + 1) * 2;
+	bool stride;
 
-	size = data->blocksize * data->blocks / 4;
+	size = data->blocksize * data->blocks;
+	/* Still use legacy PIO mode if size < 512(128 * 4) Bytes */
+	stride = host->stride_pio && size > 128;
 	if (data->flags == MMC_DATA_READ)
 		buf = (unsigned int *)data->dest;
 	else
 		buf = (unsigned int *)data->src;
 
+	timeout = dwmci_get_timeout(host->mmc, size);
+	size /= 4;
+
 	for (;;) {
 		mask = dwmci_readl(host, DWMCI_RINTSTS);
 		/* Error during data transfer. */
 		if (mask & (DWMCI_DATA_ERR | DWMCI_DATA_TOUT)) {
 			debug("%s: DATA ERROR!\n", __func__);
+			dwmci_wait_reset(host, DWMCI_RESET_ALL);
+			dwmci_writel(host, DWMCI_CMD, DWMCI_CMD_PRV_DAT_WAIT |
+				     DWMCI_CMD_UPD_CLK | DWMCI_CMD_START);
+
+			do {
+				status = dwmci_readl(host, DWMCI_CMD);
+				if (reset_timeout-- < 0)
+					break;
+				udelay(100);
+			} while (status & DWMCI_CMD_START);
+
+			if (!host->fifo_mode) {
+				ctrl = dwmci_readl(host, DWMCI_BMOD);
+				ctrl |= DWMCI_BMOD_IDMAC_RESET;
+				dwmci_writel(host, DWMCI_BMOD, ctrl);
+			}
+
 			ret = -EINVAL;
 			break;
 		}
@@ -127,9 +230,24 @@ static int dwmci_data_transfer(struct dwmci_host *host, struct mmc_data *data)
 					len = (len >> DWMCI_FIFO_SHIFT) &
 						    DWMCI_FIFO_MASK;
 					len = min(size, len);
-					for (i = 0; i < len; i++)
-						*buf++ =
-						dwmci_readl(host, DWMCI_DATA);
+					if (!stride) {
+						/* Legacy pio mode */
+						for (i = 0; i < len; i++)
+							*buf++ = dwmci_readl(host, DWMCI_DATA);
+						goto read_again;
+					}
+
+					/* dwmci_memcpy_fromio now bursts 256 Bytes once */
+					if (len < MAX_STRIDE)
+						continue;
+
+					for (i = 0; i < len / MAX_STRIDE; i++) {
+						dwmci_memcpy_fromio(buf, host->ioaddr + DWMCI_DATA);
+						buf += MAX_STRIDE;
+					}
+
+					len = i * MAX_STRIDE;
+read_again:
 					size = size > len ? (size - len) : 0;
 				}
 				dwmci_writel(host, DWMCI_RINTSTS,
@@ -142,9 +260,23 @@ static int dwmci_data_transfer(struct dwmci_host *host, struct mmc_data *data)
 						   DWMCI_FIFO_SHIFT) &
 						   DWMCI_FIFO_MASK);
 					len = min(size, len);
-					for (i = 0; i < len; i++)
-						dwmci_writel(host, DWMCI_DATA,
-							     *buf++);
+					if (!stride) {
+						for (i = 0; i < len; i++)
+							dwmci_writel(host, DWMCI_DATA,
+								     *buf++);
+						goto write_again;
+					}
+					/* dwmci_memcpy_toio now bursts 256 Bytes once */
+					if (len < MAX_STRIDE)
+						continue;
+
+					for (i = 0; i < len / MAX_STRIDE; i++) {
+						dwmci_memcpy_toio(buf, host->ioaddr + DWMCI_DATA);
+						buf += MAX_STRIDE;
+					}
+
+					len = i * MAX_STRIDE;
+write_again:
 					size = size > len ? (size - len) : 0;
 				}
 				dwmci_writel(host, DWMCI_RINTSTS,
@@ -221,14 +353,20 @@ static int dwmci_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 			dwmci_wait_reset(host, DWMCI_CTRL_FIFO_RESET);
 		} else {
 			if (data->flags == MMC_DATA_READ) {
-				bounce_buffer_start(&bbstate, (void*)data->dest,
+				ret = bounce_buffer_start(&bbstate,
+						(void*)data->dest,
 						data->blocksize *
 						data->blocks, GEN_BB_WRITE);
 			} else {
-				bounce_buffer_start(&bbstate, (void*)data->src,
+				ret = bounce_buffer_start(&bbstate,
+						(void*)data->src,
 						data->blocksize *
 						data->blocks, GEN_BB_READ);
 			}
+
+			if (ret)
+				return ret;
+
 			dwmci_prepare_data(host, data, cur_idmac,
 					   bbstate.bounce_buffer);
 		}
@@ -316,10 +454,137 @@ static int dwmci_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		}
 	}
 
-	udelay(100);
+	return ret;
+}
+
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+#ifdef CONFIG_DM_MMC
+static int dwmci_send_cmd_prepare(struct udevice *dev, struct mmc_cmd *cmd,
+				  struct mmc_data *data)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+#else
+static int dwmci_send_cmd_prepare(struct mmc *mmc, struct mmc_cmd *cmd,
+				  struct mmc_data *data)
+{
+#endif
+	struct dwmci_host *host = mmc->priv;
+	struct dwmci_idmac *cur_idmac;
+	int ret = 0, flags = 0, i;
+	unsigned int timeout = 500;
+	u32 retry = 100000;
+	u32 mask;
+	ulong start = get_timer(0);
+	struct bounce_buffer bbstate;
+
+	cur_idmac = malloc(ROUND(DIV_ROUND_UP(data->blocks, 8) *
+			   sizeof(struct dwmci_idmac),
+			   ARCH_DMA_MINALIGN) + ARCH_DMA_MINALIGN - 1);
+	if (!cur_idmac)
+		return -ENODATA;
+
+	while (dwmci_readl(host, DWMCI_STATUS) & DWMCI_BUSY) {
+		if (get_timer(start) > timeout) {
+			debug("%s: Timeout on data busy\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	dwmci_writel(host, DWMCI_RINTSTS, DWMCI_INTMSK_ALL);
+
+	if (data) {
+		if (host->fifo_mode) {
+			dwmci_writel(host, DWMCI_BLKSIZ, data->blocksize);
+			dwmci_writel(host, DWMCI_BYTCNT,
+				     data->blocksize * data->blocks);
+			dwmci_wait_reset(host, DWMCI_CTRL_FIFO_RESET);
+		} else {
+			if (data->flags == MMC_DATA_READ) {
+				bounce_buffer_start(&bbstate, (void *)data->dest,
+						    data->blocksize *
+						    data->blocks, GEN_BB_WRITE);
+			} else {
+				bounce_buffer_start(&bbstate, (void *)data->src,
+						    data->blocksize *
+						    data->blocks, GEN_BB_READ);
+			}
+			dwmci_prepare_data(host, data, cur_idmac,
+					   bbstate.bounce_buffer);
+		}
+	}
+
+	dwmci_writel(host, DWMCI_CMDARG, cmd->cmdarg);
+
+	if (data)
+		flags = dwmci_set_transfer_mode(host, data);
+
+	if ((cmd->resp_type & MMC_RSP_136) && (cmd->resp_type & MMC_RSP_BUSY))
+		return -1;
+
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		flags |= DWMCI_CMD_ABORT_STOP;
+	else
+		flags |= DWMCI_CMD_PRV_DAT_WAIT;
+
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		flags |= DWMCI_CMD_RESP_EXP;
+		if (cmd->resp_type & MMC_RSP_136)
+			flags |= DWMCI_CMD_RESP_LENGTH;
+	}
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= DWMCI_CMD_CHECK_CRC;
+
+	flags |= (cmd->cmdidx | DWMCI_CMD_START | DWMCI_CMD_USE_HOLD_REG);
+
+	debug("Sending CMD%d\n", cmd->cmdidx);
+
+	dwmci_writel(host, DWMCI_CMD, flags);
+
+	for (i = 0; i < retry; i++) {
+		mask = dwmci_readl(host, DWMCI_RINTSTS);
+		if (mask & DWMCI_INTMSK_CDONE) {
+			if (!data)
+				dwmci_writel(host, DWMCI_RINTSTS, mask);
+			break;
+		}
+	}
+
+	if (i == retry) {
+		debug("%s: Timeout.\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	if (mask & DWMCI_INTMSK_RTO) {
+		/*
+		 * Timeout here is not necessarily fatal. (e)MMC cards
+		 * will splat here when they receive CMD55 as they do
+		 * not support this command and that is exactly the way
+		 * to tell them apart from SD cards. Thus, this output
+		 * below shall be debug(). eMMC cards also do not favor
+		 * CMD8, please keep that in mind.
+		 */
+		debug("%s: Response Timeout.\n", __func__);
+		return -ETIMEDOUT;
+	} else if (mask & DWMCI_INTMSK_RE) {
+		debug("%s: Response Error.\n", __func__);
+		return -EIO;
+	}
+
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		if (cmd->resp_type & MMC_RSP_136) {
+			cmd->response[0] = dwmci_readl(host, DWMCI_RESP3);
+			cmd->response[1] = dwmci_readl(host, DWMCI_RESP2);
+			cmd->response[2] = dwmci_readl(host, DWMCI_RESP1);
+			cmd->response[3] = dwmci_readl(host, DWMCI_RESP0);
+		} else {
+			cmd->response[0] = dwmci_readl(host, DWMCI_RESP0);
+		}
+	}
 
 	return ret;
 }
+#endif
 
 static int dwmci_setup_bus(struct dwmci_host *host, u32 freq)
 {
@@ -327,7 +592,7 @@ static int dwmci_setup_bus(struct dwmci_host *host, u32 freq)
 	int timeout = 10000;
 	unsigned long sclk;
 
-	if ((freq == host->clock) || (freq == 0))
+	if (freq == 0)
 		return 0;
 	/*
 	 * If host->get_mmc_clk isn't defined,
@@ -343,6 +608,9 @@ static int dwmci_setup_bus(struct dwmci_host *host, u32 freq)
 		return -EINVAL;
 	}
 
+	if (sclk == 0)
+		return -EINVAL;
+
 	if (sclk == freq)
 		div = 0;	/* bypass mode */
 	else
@@ -383,6 +651,42 @@ static int dwmci_setup_bus(struct dwmci_host *host, u32 freq)
 	return 0;
 }
 
+#ifdef CONFIG_DM_MMC
+static bool dwmci_card_busy(struct udevice *dev)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+#else
+static bool dwmci_card_busy(struct mmc *mmc)
+{
+#endif
+	u32 status;
+	struct dwmci_host *host = (struct dwmci_host *)mmc->priv;
+
+	/*
+	 * Check the busy bit which is low when DAT[3:0]
+	 * (the data lines) are 0000
+	 */
+	status = dwmci_readl(host, DWMCI_STATUS);
+
+	return !!(status & DWMCI_BUSY);
+}
+
+#ifdef CONFIG_DM_MMC
+static int dwmci_execute_tuning(struct udevice *dev, u32 opcode)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+#else
+static int dwmci_execute_tuning(struct mmc *mmc, u32 opcode)
+{
+#endif
+	struct dwmci_host *host = (struct dwmci_host *)mmc->priv;
+
+	if (!host->execute_tuning)
+		return -EIO;
+
+	return host->execute_tuning(host, opcode);
+}
+
 #ifdef CONFIG_DM_MMC
 static int dwmci_set_ios(struct udevice *dev)
 {
@@ -412,7 +716,7 @@ static int dwmci_set_ios(struct mmc *mmc)
 	dwmci_writel(host, DWMCI_CTYPE, ctype);
 
 	regs = dwmci_readl(host, DWMCI_UHS_REG);
-	if (mmc->ddr_mode)
+	if (mmc_card_ddr(mmc))
 		regs |= DWMCI_DDR_MODE;
 	else
 		regs &= ~DWMCI_DDR_MODE;
@@ -428,17 +732,38 @@ static int dwmci_set_ios(struct mmc *mmc)
 static int dwmci_init(struct mmc *mmc)
 {
 	struct dwmci_host *host = mmc->priv;
+	uint32_t use_dma;
+	uint32_t verid;
 
 	if (host->board_init)
 		host->board_init(host);
-
+#ifdef CONFIG_ARCH_ROCKCHIP
+	if (host->dev_index == 0)
+		dwmci_writel(host, DWMCI_PWREN, 1);
+	else if (host->dev_index == 1)
+		dwmci_writel(host, DWMCI_PWREN, 0);
+	else
+		dwmci_writel(host, DWMCI_PWREN, 1);
+#else
 	dwmci_writel(host, DWMCI_PWREN, 1);
+#endif
+
+	verid = dwmci_readl(host, DWMCI_VERID) & 0x0000ffff;
+	if (verid >= DW_MMC_240A)
+		dwmci_writel(host, DWMCI_CARDTHRCTL, DWMCI_CDTHRCTRL_CONFIG);
 
 	if (!dwmci_wait_reset(host, DWMCI_RESET_ALL)) {
 		debug("%s[%d] Fail-reset!!\n", __func__, __LINE__);
 		return -EIO;
 	}
 
+	use_dma = SDMMC_GET_TRANS_MODE(dwmci_readl(host, DWMCI_HCON));
+	if (use_dma == DMA_INTERFACE_IDMA) {
+		host->fifo_mode = 0;
+	} else {
+		host->fifo_mode = 1;
+	}
+
 	/* Enumerate at 400KHz */
 	dwmci_setup_bus(host, mmc->cfg->f_min);
 
@@ -455,7 +780,8 @@ static int dwmci_init(struct mmc *mmc)
 
 		fifo_size = dwmci_readl(host, DWMCI_FIFOTH);
 		fifo_size = ((fifo_size & RX_WMARK_MASK) >> RX_WMARK_SHIFT) + 1;
-		host->fifoth_val = MSIZE(0x2) | RX_WMARK(fifo_size / 2 - 1) |
+		host->fifoth_val = MSIZE(DWMCI_MSIZE) |
+				RX_WMARK(fifo_size / 2 - 1) |
 				TX_WMARK(fifo_size / 2);
 	}
 	dwmci_writel(host, DWMCI_FIFOTH, host->fifoth_val);
@@ -466,6 +792,24 @@ static int dwmci_init(struct mmc *mmc)
 	return 0;
 }
 
+static int dwmci_get_cd(struct udevice *dev)
+{
+	int ret = -1;
+
+#if defined(CONFIG_DM_GPIO) && (defined(CONFIG_SPL_GPIO_SUPPORT) || !defined(CONFIG_SPL_BUILD))
+	struct gpio_desc detect;
+
+	ret = gpio_request_by_name(dev, "cd-gpios", 0, &detect, GPIOD_IS_IN);
+	if (ret) {
+		return ret;
+	}
+
+	ret = !dm_gpio_get_value(&detect);
+	dm_gpio_free(dev, &detect);
+#endif
+	return ret;
+}
+
 #ifdef CONFIG_DM_MMC
 int dwmci_probe(struct udevice *dev)
 {
@@ -475,15 +819,24 @@ int dwmci_probe(struct udevice *dev)
 }
 
 const struct dm_mmc_ops dm_dwmci_ops = {
+	.card_busy	= dwmci_card_busy,
 	.send_cmd	= dwmci_send_cmd,
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+	.send_cmd_prepare = dwmci_send_cmd_prepare,
+#endif
 	.set_ios	= dwmci_set_ios,
+	.get_cd         = dwmci_get_cd,
+	.execute_tuning	= dwmci_execute_tuning,
 };
 
 #else
 static const struct mmc_ops dwmci_ops = {
+	.card_busy	= dwmci_card_busy,
 	.send_cmd	= dwmci_send_cmd,
 	.set_ios	= dwmci_set_ios,
+	.get_cd         = dwmci_get_cd,
 	.init		= dwmci_init,
+	.execute_tuning	= dwmci_execute_tuning,
 };
 #endif
 
@@ -501,12 +854,21 @@ void dwmci_setup_cfg(struct mmc_config *cfg, struct dwmci_host *host,
 
 	cfg->host_caps = host->caps;
 
-	if (host->buswidth == 8) {
-		cfg->host_caps |= MMC_MODE_8BIT;
-		cfg->host_caps &= ~MMC_MODE_4BIT;
-	} else {
+	switch (host->buswidth) {
+	case 8:
+		cfg->host_caps |= MMC_MODE_8BIT | MMC_MODE_4BIT;
+		break;
+	case 4:
 		cfg->host_caps |= MMC_MODE_4BIT;
 		cfg->host_caps &= ~MMC_MODE_8BIT;
+		break;
+	case 1:
+		cfg->host_caps &= ~MMC_MODE_4BIT;
+		cfg->host_caps &= ~MMC_MODE_8BIT;
+		break;
+	default:
+		printf("Unsupported bus width: %d\n", host->buswidth);
+		break;
 	}
 	cfg->host_caps |= MMC_MODE_HS | MMC_MODE_HS_52MHz;
 
diff --git a/drivers/mmc/exynos_dw_mmc.c b/drivers/mmc/exynos_dw_mmc.c
index 40f7892ac8..7d823814ad 100644
--- a/drivers/mmc/exynos_dw_mmc.c
+++ b/drivers/mmc/exynos_dw_mmc.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <dwmmc.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <errno.h>
 #include <asm/arch/dwmmc.h>
@@ -155,7 +155,7 @@ static int exynos_dwmci_get_config(const void *blob, int node,
 
 	priv = malloc(sizeof(struct dwmci_exynos_priv_data));
 	if (!priv) {
-		error("dwmci_exynos_priv_data malloc fail!\n");
+		pr_err("dwmci_exynos_priv_data malloc fail!\n");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/mmc/fsl_esdhc.c b/drivers/mmc/fsl_esdhc.c
index cc188c4260..e3d1f91c94 100644
--- a/drivers/mmc/fsl_esdhc.c
+++ b/drivers/mmc/fsl_esdhc.c
@@ -407,7 +407,7 @@ static int esdhc_send_cmd_common(struct fsl_esdhc_priv *priv, struct mmc *mmc,
 #if defined(CONFIG_FSL_USDHC)
 	esdhc_write32(&regs->mixctrl,
 	(esdhc_read32(&regs->mixctrl) & 0xFFFFFF80) | (xfertyp & 0x7F)
-			| (mmc->ddr_mode ? XFERTYP_DDREN : 0));
+			| (mmc_card_ddr(mmc) ? XFERTYP_DDREN : 0));
 	esdhc_write32(&regs->xfertyp, xfertyp & 0xFFFF0000);
 #else
 	esdhc_write32(&regs->xfertyp, xfertyp);
@@ -548,7 +548,7 @@ static void set_sysctl(struct fsl_esdhc_priv *priv, struct mmc *mmc, uint clock)
 	while (sdhc_clk / (div * pre_div * ddr_pre_div) > clock && div < 16)
 		div++;
 
-	pre_div >>= 1;
+	pre_div >>= mmc_card_ddr(mmc) ? 2 : 1;
 	div -= 1;
 
 	clk = (pre_div << 8) | (div << 4);
diff --git a/drivers/mmc/hi6220_dw_mmc.c b/drivers/mmc/hi6220_dw_mmc.c
index d795198534..44a8ef825f 100644
--- a/drivers/mmc/hi6220_dw_mmc.c
+++ b/drivers/mmc/hi6220_dw_mmc.c
@@ -44,7 +44,7 @@ int hi6220_dwmci_add_port(int index, u32 regbase, int bus_width)
 
 	host = calloc(1, sizeof(struct dwmci_host));
 	if (!host) {
-		error("dwmci_host calloc failed!\n");
+		pr_err("dwmci_host calloc failed!\n");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/mmc/mmc-uclass.c b/drivers/mmc/mmc-uclass.c
index 5dda20cda5..0b49d3d8d1 100644
--- a/drivers/mmc/mmc-uclass.c
+++ b/drivers/mmc/mmc-uclass.c
@@ -20,8 +20,9 @@ int dm_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
 {
 	struct mmc *mmc = mmc_get_mmc_dev(dev);
 	struct dm_mmc_ops *ops = mmc_get_ops(dev);
-	int ret;
+	int ret, retry_time = 3;
 
+retry:
 	mmmc_trace_before_send(mmc, cmd);
 	if (ops->send_cmd)
 		ret = ops->send_cmd(dev, cmd, data);
@@ -29,14 +30,77 @@ int dm_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
 		ret = -ENOSYS;
 	mmmc_trace_after_send(mmc, cmd, ret);
 
+	if (ret && cmd->cmdidx != SD_CMD_SEND_IF_COND &&
+	    cmd->cmdidx != MMC_CMD_APP_CMD &&
+	    cmd->cmdidx != MMC_CMD_SEND_OP_COND &&
+	    cmd->cmdidx != MMC_SEND_TUNING_BLOCK_HS200 &&
+	    cmd->cmdidx != MMC_CMD_READ_MULTIPLE_BLOCK &&
+	    cmd->cmdidx != MMC_CMD_WRITE_MULTIPLE_BLOCK) {
+		/* execute tuning at last retry. */
+		if (retry_time == 1 &&
+		    mmc->timing == MMC_TIMING_MMC_HS200 &&
+		    ops->execute_tuning) {
+			u32 opcode = MMC_SEND_TUNING_BLOCK_HS200;
+			ops->execute_tuning(mmc->dev, opcode);
+	    	}
+		if (retry_time-- > 0)
+			goto retry;
+		printf("MMC error: The cmd index is %d, ret is %d\n", cmd->cmdidx, ret);
+	}
+
 	return ret;
 }
 
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+int dm_mmc_send_cmd_prepare(struct udevice *dev, struct mmc_cmd *cmd,
+			    struct mmc_data *data)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+	struct dm_mmc_ops *ops = mmc_get_ops(dev);
+	int ret;
+
+	mmmc_trace_before_send(mmc, cmd);
+	if (ops->send_cmd_prepare)
+		ret = ops->send_cmd_prepare(dev, cmd, data);
+	else
+		ret = -ENOSYS;
+	mmmc_trace_after_send(mmc, cmd, ret);
+	if (ret && cmd->cmdidx != SD_CMD_SEND_IF_COND
+	    && cmd->cmdidx != MMC_CMD_APP_CMD)
+		printf("MMC error: The cmd index is %d, ret is %d\n", cmd->cmdidx, ret);
+
+	return ret;
+}
+#endif
+
 int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 {
 	return dm_mmc_send_cmd(mmc->dev, cmd, data);
 }
 
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+int mmc_send_cmd_prepare(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	return dm_mmc_send_cmd_prepare(mmc->dev, cmd, data);
+}
+#endif
+
+bool mmc_card_busy(struct mmc *mmc)
+{
+	struct dm_mmc_ops *ops = mmc_get_ops(mmc->dev);
+
+	if (!ops->card_busy)
+		return -ENOSYS;
+	return ops->card_busy(mmc->dev);
+}
+
+bool mmc_can_card_busy(struct mmc *mmc)
+{
+	struct dm_mmc_ops *ops = mmc_get_ops(mmc->dev);
+
+	return !!ops->card_busy;
+}
+
 int dm_mmc_set_ios(struct udevice *dev)
 {
 	struct dm_mmc_ops *ops = mmc_get_ops(dev);
@@ -198,11 +262,9 @@ int mmc_bind(struct udevice *dev, struct mmc *mmc, const struct mmc_config *cfg)
 
 	if (!mmc_get_ops(dev))
 		return -ENOSYS;
-#ifndef CONFIG_SPL_BUILD
 	/* Use the fixed index with aliase node's index */
 	ret = dev_read_alias_seq(dev, &devnum);
 	debug("%s: alias ret=%d, devnum=%d\n", __func__, ret, devnum);
-#endif
 
 	ret = blk_create_devicef(dev, "mmc_blk", "blk", IF_TYPE_MMC,
 			devnum, 512, 0, &bdev);
@@ -275,7 +337,7 @@ static int mmc_blk_probe(struct udevice *dev)
 
 static const struct blk_ops mmc_blk_ops = {
 	.read	= mmc_bread,
-#ifndef CONFIG_SPL_BUILD
+#if CONFIG_IS_ENABLED(MMC_WRITE)
 	.write	= mmc_bwrite,
 	.erase	= mmc_berase,
 #endif
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 38d2e07dd5..3738ae515e 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -30,6 +30,8 @@ static const unsigned int sd_au_size[] = {
 	SZ_16M / 512,	(SZ_16M + SZ_8M) / 512,	SZ_32M / 512,	SZ_64M / 512,
 };
 
+static char mmc_ext_csd[512];
+
 #if CONFIG_IS_ENABLED(MMC_TINY)
 static struct mmc mmc_static;
 struct mmc *find_mmc_device(int dev_num)
@@ -210,7 +212,7 @@ int mmc_set_blocklen(struct mmc *mmc, int len)
 {
 	struct mmc_cmd cmd;
 
-	if (mmc->ddr_mode)
+	if (mmc_card_ddr(mmc))
 		return 0;
 
 	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
@@ -261,6 +263,108 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 	return blkcnt;
 }
 
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+static int mmc_read_blocks_prepare(struct mmc *mmc, void *dst, lbaint_t start,
+				   lbaint_t blkcnt)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+
+	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * mmc->read_bl_len;
+
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = dst;
+	data.blocks = blkcnt;
+	data.blocksize = mmc->read_bl_len;
+	data.flags = MMC_DATA_READ;
+
+	if (mmc_send_cmd_prepare(mmc, &cmd, &data))
+		return 0;
+
+	return blkcnt;
+}
+#endif
+
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+#if CONFIG_IS_ENABLED(BLK)
+ulong mmc_bread_prepare(struct udevice *dev, lbaint_t start, lbaint_t blkcnt, void *dst)
+#else
+ulong mmc_bread_prepare(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
+			void *dst)
+#endif
+{
+#if CONFIG_IS_ENABLED(BLK)
+	struct blk_desc *block_dev = dev_get_uclass_platdata(dev);
+#endif
+	int dev_num = block_dev->devnum;
+	int timeout = 0;
+	int err;
+
+	if (blkcnt == 0)
+		return 0;
+
+	struct mmc *mmc = find_mmc_device(dev_num);
+
+	if (!mmc)
+		return 0;
+
+	if (CONFIG_IS_ENABLED(MMC_TINY))
+		err = mmc_switch_part(mmc, block_dev->hwpart);
+	else
+		err = blk_dselect_hwpart(block_dev, block_dev->hwpart);
+
+	if (err < 0)
+		return 0;
+
+	if ((start + blkcnt) > block_dev->lba) {
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+		printf("MMC: block number 0x" LBAF " exceeds max(0x" LBAF ")\n",
+		       start + blkcnt, block_dev->lba);
+#endif
+		return 0;
+	}
+
+	if (mmc_set_blocklen(mmc, mmc->read_bl_len)) {
+		debug("%s: Failed to set blocklen\n", __func__);
+		return 0;
+	}
+
+	if (mmc_read_blocks_prepare(mmc, dst, start, blkcnt) != blkcnt) {
+		debug("%s: Failed to read blocks\n", __func__);
+re_init_retry:
+		timeout++;
+		/*
+		 * Try re-init seven times.
+		 */
+		if (timeout > 7) {
+			printf("Re-init retry timeout\n");
+			return 0;
+		}
+
+		mmc->has_init = 0;
+		if (mmc_init(mmc))
+			return 0;
+
+		if (mmc_read_blocks_prepare(mmc, dst, start, blkcnt) != blkcnt) {
+			printf("%s: Re-init mmc_read_blocks_prepare error\n",
+			       __func__);
+			goto re_init_retry;
+		}
+	}
+
+	return blkcnt;
+}
+#endif
+
 #if CONFIG_IS_ENABLED(BLK)
 ulong mmc_bread(struct udevice *dev, lbaint_t start, lbaint_t blkcnt, void *dst)
 #else
@@ -275,6 +379,14 @@ ulong mmc_bread(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
 	int err;
 	lbaint_t cur, blocks_todo = blkcnt;
 
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+	if (block_dev->op_flag == BLK_PRE_RW)
+#if CONFIG_IS_ENABLED(BLK)
+		return mmc_bread_prepare(dev, start, blkcnt, dst);
+#else
+		return mmc_bread_prepare(block_dev, start, blkcnt, dst);
+#endif
+#endif
 	if (blkcnt == 0)
 		return 0;
 
@@ -308,7 +420,26 @@ ulong mmc_bread(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
 			mmc->cfg->b_max : blocks_todo;
 		if (mmc_read_blocks(mmc, dst, start, cur) != cur) {
 			debug("%s: Failed to read blocks\n", __func__);
-			return 0;
+			int timeout = 0;
+re_init_retry:
+			timeout++;
+			/*
+			 * Try re-init seven times.
+			 */
+			if (timeout > 7) {
+				printf("Re-init retry timeout\n");
+				return 0;
+			}
+
+			mmc->has_init = 0;
+			if (mmc_init(mmc))
+				return 0;
+
+			if (mmc_read_blocks(mmc, dst, start, cur) != cur) {
+				printf("%s: Re-init mmc_read_blocks error\n",
+				       __func__);
+				goto re_init_retry;
+			}
 		}
 		blocks_todo -= cur;
 		start += cur;
@@ -318,6 +449,32 @@ ulong mmc_bread(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
 	return blkcnt;
 }
 
+void mmc_set_clock(struct mmc *mmc, uint clock)
+{
+	if (clock > mmc->cfg->f_max)
+		clock = mmc->cfg->f_max;
+
+	if (clock < mmc->cfg->f_min)
+		clock = mmc->cfg->f_min;
+
+	mmc->clock = clock;
+
+	mmc_set_ios(mmc);
+}
+
+static void mmc_set_bus_width(struct mmc *mmc, uint width)
+{
+	mmc->bus_width = width;
+
+	mmc_set_ios(mmc);
+}
+
+static void mmc_set_timing(struct mmc *mmc, uint timing)
+{
+	mmc->timing = timing;
+	mmc_set_ios(mmc);
+}
+
 static int mmc_go_idle(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
@@ -339,6 +496,7 @@ static int mmc_go_idle(struct mmc *mmc)
 	return 0;
 }
 
+#ifndef CONFIG_MMC_USE_PRE_CONFIG
 static int sd_send_op_cond(struct mmc *mmc)
 {
 	int timeout = 1000;
@@ -406,6 +564,7 @@ static int sd_send_op_cond(struct mmc *mmc)
 
 	return 0;
 }
+#endif
 
 static int mmc_send_op_cond_iter(struct mmc *mmc, int use_arg)
 {
@@ -428,6 +587,7 @@ static int mmc_send_op_cond_iter(struct mmc *mmc, int use_arg)
 	return 0;
 }
 
+#ifndef CONFIG_MMC_USE_PRE_CONFIG
 static int mmc_send_op_cond(struct mmc *mmc)
 {
 	int err, i;
@@ -448,7 +608,7 @@ static int mmc_send_op_cond(struct mmc *mmc)
 	mmc->op_cond_pending = 1;
 	return 0;
 }
-
+#endif
 static int mmc_complete_op_cond(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
@@ -498,10 +658,18 @@ static int mmc_complete_op_cond(struct mmc *mmc)
 
 static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 {
+	static int initialized;
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 	int err;
 
+	if (initialized) {
+		memcpy(ext_csd, mmc_ext_csd, 512);
+		return 0;
+	}
+
+	initialized = 1;
+
 	/* Get the Card Status Register */
 	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
 	cmd.resp_type = MMC_RSP_R1;
@@ -513,14 +681,66 @@ static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 	data.flags = MMC_DATA_READ;
 
 	err = mmc_send_cmd(mmc, &cmd, &data);
-
+	memcpy(mmc_ext_csd, ext_csd, 512);
+#if defined(CONFIG_MMC_USE_PRE_CONFIG) && defined(CONFIG_SPL_BUILD)
+	char *mmc_ecsd_base = NULL;
+	ulong mmc_ecsd;
+
+	mmc_ecsd = dev_read_u32_default(mmc->dev, "mmc-ecsd", 0);
+	mmc_ecsd_base = (char *)mmc_ecsd;
+	if (mmc_ecsd_base) {
+		memcpy(mmc_ecsd_base, ext_csd, 512);
+		*(unsigned int *)(mmc_ecsd_base + 512) = 0x55aa55aa;
+	}
+#endif
 	return err;
 }
 
-int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+static int mmc_poll_for_busy(struct mmc *mmc, u8 send_status)
 {
 	struct mmc_cmd cmd;
+	u8 busy = true;
+	uint start;
+	int ret;
 	int timeout = 1000;
+
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	start = get_timer(0);
+
+	if (!send_status && !mmc_can_card_busy(mmc)) {
+		mdelay(timeout);
+		return 0;
+	}
+
+	do {
+		if (!send_status) {
+			busy = mmc_card_busy(mmc);
+		} else {
+			ret = mmc_send_cmd(mmc, &cmd, NULL);
+
+			if (ret)
+				return ret;
+
+			if (cmd.response[0] & MMC_STATUS_SWITCH_ERROR)
+				return -EBADMSG;
+			busy = (cmd.response[0] & MMC_STATUS_CURR_STATE) ==
+				MMC_STATE_PRG;
+		}
+
+		if (get_timer(start) > timeout && busy)
+			return -ETIMEDOUT;
+	} while (busy);
+
+	return 0;
+}
+
+static int __mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value,
+			u8 send_status)
+{
+	struct mmc_cmd cmd;
 	int retries = 3;
 	int ret;
 
@@ -530,26 +750,375 @@ int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 				 (index << 16) |
 				 (value << 8);
 
-	while (retries > 0) {
+	do {
 		ret = mmc_send_cmd(mmc, &cmd, NULL);
 
-		/* Waiting for the ready status */
-		if (!ret) {
-			ret = mmc_send_status(mmc, timeout);
-			return ret;
+		if (!ret)
+			return mmc_poll_for_busy(mmc, send_status);
+	} while (--retries > 0 && ret);
+
+	return ret;
+}
+
+int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+{
+	return __mmc_switch(mmc, set, index, value, true);
+}
+
+static int mmc_select_bus_width(struct mmc *mmc)
+{
+	u32 ext_csd_bits[] = {
+		EXT_CSD_BUS_WIDTH_8,
+		EXT_CSD_BUS_WIDTH_4,
+	};
+	u32 bus_widths[] = {
+		MMC_BUS_WIDTH_8BIT,
+		MMC_BUS_WIDTH_4BIT,
+	};
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
+	u32 idx, bus_width = 0;
+	int err = 0;
+
+	if (mmc->version < MMC_VERSION_4 ||
+	    !(mmc->cfg->host_caps & (MMC_MODE_4BIT | MMC_MODE_8BIT)))
+		return 0;
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+
+	if (err)
+		return err;
+
+	idx = (mmc->cfg->host_caps & MMC_MODE_8BIT) ? 0 : 1;
+
+	/*
+	 * Unlike SD, MMC cards dont have a configuration register to notify
+	 * supported bus width. So bus test command should be run to identify
+	 * the supported bus width or compare the ext csd values of current
+	 * bus width and ext csd values of 1 bit mode read earlier.
+	 */
+	for (; idx < ARRAY_SIZE(bus_widths); idx++) {
+		/*
+		 * Host is capable of 8bit transfer, then switch
+		 * the device to work in 8bit transfer mode. If the
+		 * mmc switch command returns error then switch to
+		 * 4bit transfer mode. On success set the corresponding
+		 * bus width on the host.
+		 */
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_BUS_WIDTH, ext_csd_bits[idx]);
+		if (err)
+			continue;
+
+		bus_width = bus_widths[idx];
+		mmc_set_bus_width(mmc, bus_width);
+
+		err = mmc_send_ext_csd(mmc, test_csd);
+
+		if (err)
+			continue;
+
+		/* Only compare read only fields */
+		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] ==
+			test_csd[EXT_CSD_PARTITIONING_SUPPORT]) &&
+		    (ext_csd[EXT_CSD_HC_WP_GRP_SIZE] ==
+			test_csd[EXT_CSD_HC_WP_GRP_SIZE]) &&
+		    (ext_csd[EXT_CSD_REV] == test_csd[EXT_CSD_REV]) &&
+			(ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] ==
+			test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]) &&
+		    !memcmp(&ext_csd[EXT_CSD_SEC_CNT],
+			&test_csd[EXT_CSD_SEC_CNT], 4)) {
+			err = bus_width;
+			break;
+		} else {
+			err = -EBADMSG;
 		}
+	}
+
+	return err;
+}
+
+#ifndef CONFIG_MMC_SIMPLE
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
 
-		retries--;
+int mmc_send_tuning(struct mmc *mmc, u32 opcode)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	const u8 *tuning_block_pattern;
+	int size, err = 0;
+	u8 *data_buf;
+
+	if (mmc->bus_width == MMC_BUS_WIDTH_8BIT) {
+		tuning_block_pattern = tuning_blk_pattern_8bit;
+		size = sizeof(tuning_blk_pattern_8bit);
+	} else if (mmc->bus_width == MMC_BUS_WIDTH_4BIT) {
+		tuning_block_pattern = tuning_blk_pattern_4bit;
+		size = sizeof(tuning_blk_pattern_4bit);
+	} else {
+		return -EINVAL;
+	}
+
+	data_buf = calloc(1, size);
+	if (!data_buf)
+		return -ENOMEM;
+
+	cmd.cmdidx = opcode;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	data.dest = (char *)data_buf;
+	data.blocksize = size;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err)
+		goto out;
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		err = -EIO;
+out:
+	free(data_buf);
+	return err;
+}
+
+static int mmc_execute_tuning(struct mmc *mmc)
+{
+#ifdef CONFIG_DM_MMC
+	struct dm_mmc_ops *ops = mmc_get_ops(mmc->dev);
+#endif
+	u32 opcode;
+
+	if (IS_SD(mmc))
+		opcode = MMC_SEND_TUNING_BLOCK;
+	else
+		opcode = MMC_SEND_TUNING_BLOCK_HS200;
+
+#ifndef CONFIG_DM_MMC
+	if (mmc->cfg->ops->execute_tuning) {
+		return mmc->cfg->ops->execute_tuning(mmc, opcode);
+#else
+	if (ops->execute_tuning) {
+		return ops->execute_tuning(mmc->dev, opcode);
+#endif
+	} else {
+		debug("Tuning feature required for HS200 mode.\n");
+		return -EIO;
 	}
+}
+
+static int mmc_hs200_tuning(struct mmc *mmc)
+{
+	return mmc_execute_tuning(mmc);
+}
+
+#else
+int mmc_send_tuning(struct mmc *mmc, u32 opcode) { return 0; }
+int mmc_execute_tuning(struct mmc *mmc) { return 0; }
+static int mmc_hs200_tuning(struct mmc *mmc) { return 0; }
+#endif
+
+static int mmc_select_hs(struct mmc *mmc)
+{
+	int ret;
+
+	ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS);
+
+	if (!ret)
+		mmc_set_timing(mmc, MMC_TIMING_MMC_HS);
 
 	return ret;
+}
+
+static int mmc_select_hs_ddr(struct mmc *mmc)
+{
+	u32 ext_csd_bits;
+	int err = 0;
+
+	if (mmc->bus_width == MMC_BUS_WIDTH_1BIT)
+		return 0;
+
+	ext_csd_bits = (mmc->bus_width == MMC_BUS_WIDTH_8BIT) ?
+			EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_BUS_WIDTH, ext_csd_bits);
+	if (err)
+		return err;
+
+	mmc_set_timing(mmc, MMC_TIMING_MMC_DDR52);
 
+	return 0;
+}
+
+#ifndef CONFIG_MMC_SIMPLE
+static int mmc_select_hs200(struct mmc *mmc)
+{
+	int ret;
+
+	/*
+	 * Set the bus width(4 or 8) with host's support and
+	 * switch to HS200 mode if bus width is set successfully.
+	 */
+	ret = mmc_select_bus_width(mmc);
+
+	if (ret > 0) {
+		ret = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				   EXT_CSD_HS_TIMING,
+				   EXT_CSD_TIMING_HS200, false);
+
+		if (ret)
+			return ret;
+
+		mmc_set_timing(mmc, MMC_TIMING_MMC_HS200);
+	}
+
+	return ret;
+}
+
+static int mmc_select_hs400(struct mmc *mmc)
+{
+	int ret;
+
+	/* Reduce frequency to HS frequency */
+	mmc_set_clock(mmc, MMC_HIGH_52_MAX_DTR);
+
+	/* Switch card to HS mode */
+	ret = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS, false);
+	if (ret)
+		return ret;
+
+	/* Set host controller to HS timing */
+	mmc_set_timing(mmc, MMC_TIMING_MMC_HS);
+
+	ret = mmc_send_status(mmc, 1000);
+	if (ret)
+		return ret;
+
+	/* Switch card to DDR */
+	ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_BUS_WIDTH,
+			 EXT_CSD_DDR_BUS_WIDTH_8);
+	if (ret)
+		return ret;
+
+	/* Switch card to HS400 */
+	ret = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400, false);
+	if (ret)
+		return ret;
+
+	/* Set host controller to HS400 timing and frequency */
+	mmc_set_timing(mmc, MMC_TIMING_MMC_HS400);
+
+	return ret;
+}
+#else
+static int mmc_select_hs200(struct mmc *mmc) { return 0; }
+static int mmc_select_hs400(struct mmc *mmc) { return 0; }
+#endif
+
+static u32 mmc_select_card_type(struct mmc *mmc, u8 *ext_csd)
+{
+	u8 card_type;
+	u32 host_caps, avail_type = 0;
+
+	card_type = ext_csd[EXT_CSD_CARD_TYPE];
+	host_caps = mmc->cfg->host_caps;
+
+	if ((host_caps & MMC_MODE_HS) &&
+	    (card_type & EXT_CSD_CARD_TYPE_26))
+		avail_type |= EXT_CSD_CARD_TYPE_26;
+
+	if ((host_caps & MMC_MODE_HS) &&
+	    (card_type & EXT_CSD_CARD_TYPE_52))
+		avail_type |= EXT_CSD_CARD_TYPE_52;
+
+	/*
+	 * For the moment, u-boot doesn't support signal voltage
+	 * switch, therefor we assume that host support ddr52
+	 * at 1.8v or 3.3v I/O(1.2v I/O not supported, hs200 and
+	 * hs400 are the same).
+	 */
+	if ((host_caps & MMC_MODE_DDR_52MHz) &&
+	    (card_type & EXT_CSD_CARD_TYPE_DDR_1_8V))
+		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_8V;
+
+	if ((host_caps & MMC_MODE_HS200) &&
+	    (card_type & EXT_CSD_CARD_TYPE_HS200_1_8V))
+		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V;
+
+	/*
+	 * If host can support HS400, it means that host can also
+	 * support HS200.
+	 */
+	if ((host_caps & MMC_MODE_HS400) &&
+	    (host_caps & MMC_MODE_8BIT) &&
+	    (card_type & EXT_CSD_CARD_TYPE_HS400_1_8V))
+		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V |
+				EXT_CSD_CARD_TYPE_HS400_1_8V;
+
+	if ((host_caps & MMC_MODE_HS400ES) &&
+	    (host_caps & MMC_MODE_8BIT) &&
+	    ext_csd[EXT_CSD_STROBE_SUPPORT] &&
+	    (avail_type & EXT_CSD_CARD_TYPE_HS400_1_8V))
+		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V |
+				EXT_CSD_CARD_TYPE_HS400_1_8V |
+				EXT_CSD_CARD_TYPE_HS400ES;
+
+	return avail_type;
+}
+
+static void mmc_set_bus_speed(struct mmc *mmc, u8 avail_type)
+{
+	int clock = 0;
+
+	if (mmc_card_hs(mmc))
+		clock = (avail_type & EXT_CSD_CARD_TYPE_52) ?
+			MMC_HIGH_52_MAX_DTR : MMC_HIGH_26_MAX_DTR;
+	else if (mmc_card_hs200(mmc) ||
+		 mmc_card_hs400(mmc) ||
+		 mmc_card_hs400es(mmc))
+		clock = MMC_HS200_MAX_DTR;
+
+	mmc_set_clock(mmc, clock);
 }
 
 static int mmc_change_freq(struct mmc *mmc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
-	char cardtype;
+	u32 avail_type;
 	int err;
 
 	mmc->card_caps = 0;
@@ -568,33 +1137,34 @@ static int mmc_change_freq(struct mmc *mmc)
 	if (err)
 		return err;
 
-	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
-
-	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
-
-	if (err)
-		return err;
+	avail_type = mmc_select_card_type(mmc, ext_csd);
 
-	/* Now check to see that it worked */
-	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (avail_type & EXT_CSD_CARD_TYPE_HS200)
+		err = mmc_select_hs200(mmc);
+	else if (avail_type & EXT_CSD_CARD_TYPE_HS)
+		err = mmc_select_hs(mmc);
+	else
+		err = -EINVAL;
 
 	if (err)
 		return err;
 
-	/* No high-speed support */
-	if (!ext_csd[EXT_CSD_HS_TIMING])
-		return 0;
+	mmc_set_bus_speed(mmc, avail_type);
 
-	/* High Speed is set, there are two types: 52MHz and 26MHz */
-	if (cardtype & EXT_CSD_CARD_TYPE_52) {
-		if (cardtype & EXT_CSD_CARD_TYPE_DDR_1_8V)
-			mmc->card_caps |= MMC_MODE_DDR_52MHz;
-		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
-	} else {
-		mmc->card_caps |= MMC_MODE_HS;
+	if (mmc_card_hs200(mmc)) {
+		err = mmc_hs200_tuning(mmc);
+		if (avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+		    mmc->bus_width == MMC_BUS_WIDTH_8BIT) {
+			err = mmc_select_hs400(mmc);
+			mmc_set_bus_speed(mmc, avail_type);
+		}
+	} else if (!mmc_card_hs400es(mmc)) {
+		err = mmc_select_bus_width(mmc) > 0 ? 0 : err;
+		if (!err && avail_type & EXT_CSD_CARD_TYPE_DDR_52)
+			err = mmc_select_hs_ddr(mmc);
 	}
 
-	return 0;
+	return err;
 }
 
 static int mmc_set_capacity(struct mmc *mmc, int part_num)
@@ -1081,36 +1651,28 @@ static void mmc_set_ios(struct mmc *mmc)
 	if (mmc->cfg->ops->set_ios)
 		mmc->cfg->ops->set_ios(mmc);
 }
-#endif
 
-void mmc_set_clock(struct mmc *mmc, uint clock)
+static bool mmc_card_busy(struct mmc *mmc)
 {
-	if (clock > mmc->cfg->f_max)
-		clock = mmc->cfg->f_max;
+	if (!mmc->cfg->ops->card_busy)
+		return -ENOSYS;
 
-	if (clock < mmc->cfg->f_min)
-		clock = mmc->cfg->f_min;
-
-	mmc->clock = clock;
-
-	mmc_set_ios(mmc);
+	return mmc->cfg->ops->card_busy(mmc);
 }
 
-static void mmc_set_bus_width(struct mmc *mmc, uint width)
+static bool mmc_can_card_busy(struct mmc *)
 {
-	mmc->bus_width = width;
-
-	mmc_set_ios(mmc);
+	return !!mmc->cfg->ops->card_busy;
 }
+#endif
 
 static int mmc_startup(struct mmc *mmc)
 {
 	int err, i;
-	uint mult, freq;
+	uint mult, freq, tran_speed;
 	u64 cmult, csize, capacity;
 	struct mmc_cmd cmd;
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
-	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
 	bool has_parts = false;
 	bool part_completed;
 	struct blk_desc *bdesc;
@@ -1126,7 +1688,7 @@ static int mmc_startup(struct mmc *mmc)
 			return err;
 	}
 #endif
-
+#ifndef CONFIG_MMC_USE_PRE_CONFIG
 	/* Put the Card in Identify Mode */
 	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
 		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
@@ -1158,7 +1720,7 @@ static int mmc_startup(struct mmc *mmc)
 		if (IS_SD(mmc))
 			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
 	}
-
+#endif
 	/* Get the Card-Specific Data */
 	cmd.cmdidx = MMC_CMD_SEND_CSD;
 	cmd.resp_type = MMC_RSP_R2;
@@ -1203,7 +1765,7 @@ static int mmc_startup(struct mmc *mmc)
 	freq = fbase[(cmd.response[0] & 0x7)];
 	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
 
-	mmc->tran_speed = freq * mult;
+	tran_speed = freq * mult;
 
 	mmc->dsr_imp = ((cmd.response[1] >> 12) & 0x1);
 	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
@@ -1320,6 +1882,8 @@ static int mmc_startup(struct mmc *mmc)
 		if (part_completed &&
 		    (ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & ENHNCD_SUPPORT))
 			mmc->part_attr = ext_csd[EXT_CSD_PARTITIONS_ATTRIBUTE];
+		if (ext_csd[EXT_CSD_SEC_FEATURE_SUPPORT] & EXT_CSD_SEC_GB_CL_EN)
+			mmc->esr.mmc_can_trim = 1;
 
 		mmc->capacity_boot = ext_csd[EXT_CSD_BOOT_MULT] << 17;
 
@@ -1450,105 +2014,15 @@ static int mmc_startup(struct mmc *mmc)
 			return err;
 
 		if (mmc->card_caps & MMC_MODE_HS)
-			mmc->tran_speed = 50000000;
+			tran_speed = MMC_HIGH_52_MAX_DTR;
 		else
-			mmc->tran_speed = 25000000;
-	} else if (mmc->version >= MMC_VERSION_4) {
-		/* Only version 4 of MMC supports wider bus widths */
-		int idx;
-
-		/* An array of possible bus widths in order of preference */
-		static unsigned ext_csd_bits[] = {
-			EXT_CSD_DDR_BUS_WIDTH_8,
-			EXT_CSD_DDR_BUS_WIDTH_4,
-			EXT_CSD_BUS_WIDTH_8,
-			EXT_CSD_BUS_WIDTH_4,
-			EXT_CSD_BUS_WIDTH_1,
-		};
-
-		/* An array to map CSD bus widths to host cap bits */
-		static unsigned ext_to_hostcaps[] = {
-			[EXT_CSD_DDR_BUS_WIDTH_4] =
-				MMC_MODE_DDR_52MHz | MMC_MODE_4BIT,
-			[EXT_CSD_DDR_BUS_WIDTH_8] =
-				MMC_MODE_DDR_52MHz | MMC_MODE_8BIT,
-			[EXT_CSD_BUS_WIDTH_4] = MMC_MODE_4BIT,
-			[EXT_CSD_BUS_WIDTH_8] = MMC_MODE_8BIT,
-		};
-
-		/* An array to map chosen bus width to an integer */
-		static unsigned widths[] = {
-			8, 4, 8, 4, 1,
-		};
-
-		for (idx=0; idx < ARRAY_SIZE(ext_csd_bits); idx++) {
-			unsigned int extw = ext_csd_bits[idx];
-			unsigned int caps = ext_to_hostcaps[extw];
-
-			/*
-			 * If the bus width is still not changed,
-			 * don't try to set the default again.
-			 * Otherwise, recover from switch attempts
-			 * by switching to 1-bit bus width.
-			 */
-			if (extw == EXT_CSD_BUS_WIDTH_1 &&
-					mmc->bus_width == 1) {
-				err = 0;
-				break;
-			}
-
-			/*
-			 * Check to make sure the card and controller support
-			 * these capabilities
-			 */
-			if ((mmc->card_caps & caps) != caps)
-				continue;
-
-			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_BUS_WIDTH, extw);
-
-			if (err)
-				continue;
-
-			mmc->ddr_mode = (caps & MMC_MODE_DDR_52MHz) ? 1 : 0;
-			mmc_set_bus_width(mmc, widths[idx]);
-
-			err = mmc_send_ext_csd(mmc, test_csd);
-
-			if (err)
-				continue;
-
-			/* Only compare read only fields */
-			if (ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
-				== test_csd[EXT_CSD_PARTITIONING_SUPPORT] &&
-			    ext_csd[EXT_CSD_HC_WP_GRP_SIZE]
-				== test_csd[EXT_CSD_HC_WP_GRP_SIZE] &&
-			    ext_csd[EXT_CSD_REV]
-				== test_csd[EXT_CSD_REV] &&
-			    ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
-				== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE] &&
-			    memcmp(&ext_csd[EXT_CSD_SEC_CNT],
-				   &test_csd[EXT_CSD_SEC_CNT], 4) == 0)
-				break;
-			else
-				err = -EBADMSG;
-		}
+			tran_speed = MMC_HIGH_26_MAX_DTR;
 
-		if (err)
-			return err;
-
-		if (mmc->card_caps & MMC_MODE_HS) {
-			if (mmc->card_caps & MMC_MODE_HS_52MHz)
-				mmc->tran_speed = 52000000;
-			else
-				mmc->tran_speed = 26000000;
-		}
+		mmc_set_clock(mmc, tran_speed);
 	}
 
-	mmc_set_clock(mmc, mmc->tran_speed);
-
 	/* Fix the block length for DDR mode */
-	if (mmc->ddr_mode) {
+	if (mmc_card_ddr(mmc)) {
 		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
 		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
 	}
@@ -1585,6 +2059,7 @@ static int mmc_startup(struct mmc *mmc)
 	return 0;
 }
 
+#ifndef CONFIG_MMC_USE_PRE_CONFIG
 static int mmc_send_if_cond(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
@@ -1607,6 +2082,7 @@ static int mmc_send_if_cond(struct mmc *mmc)
 
 	return 0;
 }
+#endif
 
 #if !CONFIG_IS_ENABLED(DM_MMC)
 /* board-specific MMC power initializations. */
@@ -1615,6 +2091,7 @@ __weak void board_mmc_power_init(void)
 }
 #endif
 
+#ifndef CONFIG_MMC_USE_PRE_CONFIG
 static int mmc_power_init(struct mmc *mmc)
 {
 #if CONFIG_IS_ENABLED(DM_MMC)
@@ -1644,7 +2121,50 @@ static int mmc_power_init(struct mmc *mmc)
 #endif
 	return 0;
 }
+#endif
+#ifdef CONFIG_MMC_USE_PRE_CONFIG
+static int mmc_select_card(struct mmc *mmc, int n)
+{
+	struct mmc_cmd cmd;
+	int err = 0;
 
+	memset(&cmd, 0, sizeof(struct mmc_cmd));
+	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
+		mmc->rca = n;
+		cmd.cmdidx = MMC_CMD_SELECT_CARD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = mmc->rca << 16;
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+	}
+
+	return err;
+}
+
+int mmc_start_init(struct mmc *mmc)
+{
+	/*
+	 * We use the MMC config set by the bootrom.
+	 * So it is no need to reset the eMMC device.
+	 */
+	mmc_set_bus_width(mmc, 8);
+	mmc_set_clock(mmc, 1);
+	mmc_set_timing(mmc, MMC_TIMING_LEGACY);
+	/* Send cmd7 to return stand-by state*/
+	mmc_select_card(mmc, 0);
+	mmc->version = MMC_VERSION_UNKNOWN;
+	mmc->high_capacity = 1;
+	/*
+	 * The RCA is set to 2 by rockchip bootrom, use the default
+	 * value here.
+	 */
+#ifdef CONFIG_ARCH_ROCKCHIP
+	mmc->rca = 2;
+#else
+	mmc->rca = 1;
+#endif
+	return 0;
+}
+#else
 int mmc_start_init(struct mmc *mmc)
 {
 	bool no_card;
@@ -1681,9 +2201,9 @@ int mmc_start_init(struct mmc *mmc)
 	if (err)
 		return err;
 #endif
-	mmc->ddr_mode = 0;
 	mmc_set_bus_width(mmc, 1);
 	mmc_set_clock(mmc, 1);
+	mmc_set_timing(mmc, MMC_TIMING_LEGACY);
 
 	/* Reset the Card */
 	err = mmc_go_idle(mmc);
@@ -1717,6 +2237,7 @@ int mmc_start_init(struct mmc *mmc)
 
 	return err;
 }
+#endif
 
 static int mmc_complete_init(struct mmc *mmc)
 {
diff --git a/drivers/mmc/mmc_private.h b/drivers/mmc/mmc_private.h
index 1290eed590..0a377d15cc 100644
--- a/drivers/mmc/mmc_private.h
+++ b/drivers/mmc/mmc_private.h
@@ -14,6 +14,10 @@
 
 extern int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 			struct mmc_data *data);
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+int mmc_send_cmd_prepare(struct mmc *mmc, struct mmc_cmd *cmd,
+			 struct mmc_data *data);
+#endif
 extern int mmc_send_status(struct mmc *mmc, int timeout);
 extern int mmc_set_blocklen(struct mmc *mmc, int len);
 #ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
@@ -23,12 +27,20 @@ void mmc_adapter_card_type_ident(void);
 #if CONFIG_IS_ENABLED(BLK)
 ulong mmc_bread(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
 		void *dst);
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+ulong mmc_bread_prepare(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
+			void *dst);
+#endif
 #else
 ulong mmc_bread(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
 		void *dst);
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+ulong mmc_bread_prepare(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
+			void *dst);
+#endif
 #endif
 
-#if !(defined(CONFIG_SPL_BUILD) && !defined(CONFIG_SPL_SAVEENV))
+#if CONFIG_IS_ENABLED(MMC_WRITE)
 
 #if CONFIG_IS_ENABLED(BLK)
 ulong mmc_bwrite(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
@@ -40,7 +52,7 @@ ulong mmc_bwrite(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
 ulong mmc_berase(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt);
 #endif
 
-#else /* CONFIG_SPL_BUILD and CONFIG_SPL_SAVEENV is not defined */
+#else /* CONFIG_SPL_MMC_WRITE is not defined */
 
 /* declare dummies to reduce code size. */
 
diff --git a/drivers/mmc/mmc_write.c b/drivers/mmc/mmc_write.c
index 54acbf7336..061d3f002e 100644
--- a/drivers/mmc/mmc_write.c
+++ b/drivers/mmc/mmc_write.c
@@ -20,6 +20,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 	struct mmc_cmd cmd;
 	ulong end;
 	int err, start_cmd, end_cmd;
+	uint erase_mode;
 
 	if (mmc->high_capacity) {
 		end = start + blkcnt - 1;
@@ -28,12 +29,24 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 		start *= mmc->write_bl_len;
 	}
 
+	/*
+	 * The SD card have just one erase mode, the erase command
+	 * perform an erase on the sector(s).
+	 * The Emmc have four erase mode. We use the trim mode with
+	 * cmd.cmdarg equal to MMC_TRIM_ARG which command performs an
+	 * erase on the sector(s).
+	 */
 	if (IS_SD(mmc)) {
 		start_cmd = SD_CMD_ERASE_WR_BLK_START;
 		end_cmd = SD_CMD_ERASE_WR_BLK_END;
+		erase_mode = MMC_ERASE_ARG;
 	} else {
 		start_cmd = MMC_CMD_ERASE_GROUP_START;
 		end_cmd = MMC_CMD_ERASE_GROUP_END;
+		if (mmc->esr.mmc_can_trim)
+			erase_mode = MMC_TRIM_ARG;
+		else
+			erase_mode = MMC_ERASE_ARG;
 	}
 
 	cmd.cmdidx = start_cmd;
@@ -52,7 +65,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 		goto err_out;
 
 	cmd.cmdidx = MMC_CMD_ERASE;
-	cmd.cmdarg = MMC_ERASE_ARG;
+	cmd.cmdarg = erase_mode;
 	cmd.resp_type = MMC_RSP_R1b;
 
 	err = mmc_send_cmd(mmc, &cmd, NULL);
@@ -81,50 +94,69 @@ ulong mmc_berase(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt)
 	struct mmc *mmc = find_mmc_device(dev_num);
 	lbaint_t blk = 0, blk_r = 0;
 	int timeout = 1000;
+	int mode = 0;
 
 	if (!mmc)
 		return -1;
 
+	if (!blkcnt)
+		return 0;
+
 	err = blk_select_hwpart_devnum(IF_TYPE_MMC, dev_num,
 				       block_dev->hwpart);
+
 	if (err < 0)
 		return -1;
 
-	/*
-	 * We want to see if the requested start or total block count are
-	 * unaligned.  We discard the whole numbers and only care about the
-	 * remainder.
-	 */
-	err = div_u64_rem(start, mmc->erase_grp_size, &start_rem);
-	err = div_u64_rem(blkcnt, mmc->erase_grp_size, &blkcnt_rem);
-	if (start_rem || blkcnt_rem)
-		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
-		       "The erase range would be change to "
-		       "0x" LBAF "~0x" LBAF "\n\n",
-		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
-		       ((start + blkcnt + mmc->erase_grp_size)
-		       & ~(mmc->erase_grp_size - 1)) - 1);
-
-	while (blk < blkcnt) {
-		if (IS_SD(mmc) && mmc->ssr.au) {
-			blk_r = ((blkcnt - blk) > mmc->ssr.au) ?
-				mmc->ssr.au : (blkcnt - blk);
-		} else {
-			blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
-				mmc->erase_grp_size : (blkcnt - blk);
-		}
-		err = mmc_erase_t(mmc, start + blk, blk_r);
-		if (err)
-			break;
-
-		blk += blk_r;
+	if (!IS_SD(mmc)) {
+		if (mmc->esr.mmc_can_trim)
+			mode = 1;
+	}
 
-		/* Waiting for the ready status */
+	if (mode) {
+		err = mmc_erase_t(mmc, start, blkcnt);
+		if (err)
+			return err;
 		if (mmc_send_status(mmc, timeout))
 			return 0;
-	}
 
-	return blk;
+		return blkcnt;
+	} else {
+		/*
+		 * We want to see if the requested start or total block
+		 * count are unaligned.  We discard the whole numbers and
+		 * only care about the remainder.
+		 */
+		err = div_u64_rem(start, mmc->erase_grp_size, &start_rem);
+		err = div_u64_rem(blkcnt, mmc->erase_grp_size, &blkcnt_rem);
+		if (start_rem || blkcnt_rem)
+			printf("\n\nCaution! Your devices Erase group is 0x%x\n"
+			       "The erase range would be change to "
+			       "0x" LBAF "~0x" LBAF "\n\n",
+			       mmc->erase_grp_size,
+			       start & ~(mmc->erase_grp_size - 1),
+			       ((start + blkcnt + mmc->erase_grp_size)
+			       & ~(mmc->erase_grp_size - 1)) - 1);
+		while (blk < blkcnt) {
+			if (IS_SD(mmc) && mmc->ssr.au) {
+				blk_r = ((blkcnt - blk) > mmc->ssr.au) ?
+				mmc->ssr.au : (blkcnt - blk);
+			} else {
+				blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
+					mmc->erase_grp_size : (blkcnt - blk);
+			}
+			err = mmc_erase_t(mmc, start + blk, blk_r);
+			if (err)
+				break;
+
+			blk += blk_r;
+
+			/* Waiting for the ready status */
+			if (mmc_send_status(mmc, timeout))
+				return 0;
+		}
+		return blk;
+	}
 }
 
 static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
@@ -133,6 +165,7 @@ static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 	int timeout = 1000;
+	ulong writen_cnt = blkcnt;
 
 	if ((start + blkcnt) > mmc_get_blk_desc(mmc)->lba) {
 		printf("MMC: block number 0x" LBAF " exceeds max(0x" LBAF ")\n",
@@ -161,7 +194,7 @@ static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
 
 	if (mmc_send_cmd(mmc, &cmd, &data)) {
 		printf("mmc write failed\n");
-		return 0;
+		writen_cnt = 0;
 	}
 
 	/* SPI multiblock writes terminate using a special
@@ -181,7 +214,7 @@ static ulong mmc_write_blocks(struct mmc *mmc, lbaint_t start,
 	if (mmc_send_status(mmc, timeout))
 		return 0;
 
-	return blkcnt;
+	return writen_cnt;
 }
 
 #ifdef CONFIG_BLK
@@ -213,8 +246,11 @@ ulong mmc_bwrite(struct blk_desc *block_dev, lbaint_t start, lbaint_t blkcnt,
 	do {
 		cur = (blocks_todo > mmc->cfg->b_max) ?
 			mmc->cfg->b_max : blocks_todo;
-		if (mmc_write_blocks(mmc, start, cur, src) != cur)
-			return 0;
+		if (mmc_write_blocks(mmc, start, cur, src) != cur) {
+			/* retry again with Open-ended Multiple block write */
+			if (mmc_write_blocks(mmc, start, cur, src) != cur)
+				return 0;
+		}
 		blocks_todo -= cur;
 		start += cur;
 		src += cur * mmc->write_bl_len;
diff --git a/drivers/mmc/msm_sdhci.c b/drivers/mmc/msm_sdhci.c
index 9117ab6bf9..f0661bd96c 100644
--- a/drivers/mmc/msm_sdhci.c
+++ b/drivers/mmc/msm_sdhci.c
@@ -109,15 +109,15 @@ static int msm_sdc_probe(struct udevice *dev)
 
 
 	/* Wait for reset to be written to register */
-	if (wait_for_bit(__func__, prv->base + SDCC_MCI_STATUS2,
-			 SDCC_MCI_STATUS2_MCI_ACT, false, 10, false)) {
+	if (wait_for_bit_le32(prv->base + SDCC_MCI_STATUS2,
+			      SDCC_MCI_STATUS2_MCI_ACT, false, 10, false)) {
 		printf("msm_sdhci: reset request failed\n");
 		return -EIO;
 	}
 
 	/* SW reset can take upto 10HCLK + 15MCLK cycles. (min 40us) */
-	if (wait_for_bit(__func__, prv->base + SDCC_MCI_POWER,
-			 SDCC_MCI_POWER_SW_RST, false, 2, false)) {
+	if (wait_for_bit_le32(prv->base + SDCC_MCI_POWER,
+			      SDCC_MCI_POWER_SW_RST, false, 2, false)) {
 		printf("msm_sdhci: stuck in reset\n");
 		return -ETIMEDOUT;
 	}
diff --git a/drivers/mmc/rockchip_dw_mmc.c b/drivers/mmc/rockchip_dw_mmc.c
index e7fcf89f73..053282fc44 100644
--- a/drivers/mmc/rockchip_dw_mmc.c
+++ b/drivers/mmc/rockchip_dw_mmc.c
@@ -14,8 +14,8 @@
 #include <pwrseq.h>
 #include <syscon.h>
 #include <asm/gpio.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/periph.h>
 #include <linux/err.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -30,22 +30,49 @@ struct rockchip_mmc_plat {
 
 struct rockchip_dwmmc_priv {
 	struct clk clk;
+	struct clk sample_clk;
 	struct dwmci_host host;
 	int fifo_depth;
 	bool fifo_mode;
 	u32 minmax[2];
 };
 
+#ifdef CONFIG_USING_KERNEL_DTB
+int board_mmc_dm_reinit(struct udevice *dev)
+{
+	struct rockchip_dwmmc_priv *priv = dev_get_priv(dev);
+
+	if (!priv || !&priv->clk)
+		return 0;
+
+	if (!memcmp(dev->name, "dwmmc", strlen("dwmmc")))
+		return clk_get_by_index(dev, 0, &priv->clk);
+	else
+		return 0;
+}
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+__weak void mmc_gpio_init_direct(void) {}
+#endif
+
 static uint rockchip_dwmmc_get_mmc_clk(struct dwmci_host *host, uint freq)
 {
 	struct udevice *dev = host->priv;
 	struct rockchip_dwmmc_priv *priv = dev_get_priv(dev);
 	int ret;
 
+	/*
+	 * If DDR52 8bit mode(only emmc work in 8bit mode),
+	 * divider must be set 1
+	 */
+	if (mmc_card_ddr52(host->mmc) && host->mmc->bus_width == 8)
+		freq *= 2;
+
 	ret = clk_set_rate(&priv->clk, freq);
 	if (ret < 0) {
 		debug("%s: err=%d\n", __func__, ret);
-		return ret;
+		return 0;
 	}
 
 	return freq;
@@ -58,7 +85,7 @@ static int rockchip_dwmmc_ofdata_to_platdata(struct udevice *dev)
 	struct dwmci_host *host = &priv->host;
 
 	host->name = dev->name;
-	host->ioaddr = (void *)devfdt_get_addr(dev);
+	host->ioaddr = dev_read_addr_ptr(dev);
 	host->buswidth = dev_read_u32_default(dev, "bus-width", 4);
 	host->get_mmc_clk = rockchip_dwmmc_get_mmc_clk;
 	host->priv = dev;
@@ -95,6 +122,56 @@ static int rockchip_dwmmc_ofdata_to_platdata(struct udevice *dev)
 	return 0;
 }
 
+#ifndef CONFIG_MMC_SIMPLE
+static int rockchip_dwmmc_execute_tuning(struct dwmci_host *host, u32 opcode)
+{
+	int i = 0;
+	int ret = -1;
+	struct mmc *mmc = host->mmc;
+	struct udevice *dev = host->priv;
+	struct rockchip_dwmmc_priv *priv = dev_get_priv(dev);
+
+	if (IS_ERR(&priv->sample_clk))
+		return -EIO;
+
+	if (mmc->default_phase > 0 && mmc->default_phase < 360) {
+		ret = clk_set_phase(&priv->sample_clk, mmc->default_phase);
+		if (ret)
+			printf("set clk phase fail\n");
+		else
+			ret = mmc_send_tuning(mmc, opcode);
+		mmc->default_phase = 0;
+	}
+	/*
+	 * If use default_phase to tune successfully, return.
+	 * Otherwise, use the othe phase to tune.
+	 */
+	if (!ret)
+		return ret;
+
+	for (i = 0; i < 5; i++) {
+		/* mmc->init_retry must be 0, 1, 2, 3 */
+		if (mmc->init_retry == 4)
+			mmc->init_retry = 0;
+
+		ret = clk_set_phase(&priv->sample_clk, 90 * mmc->init_retry);
+		if (ret) {
+			printf("set clk phase fail\n");
+			break;
+		}
+		ret = mmc_send_tuning(mmc, opcode);
+		debug("Tuning phase is %d, ret is %d\n", mmc->init_retry * 90, ret);
+		mmc->init_retry++;
+		if (!ret)
+			break;
+	}
+
+	return ret;
+}
+#else
+static int rockchip_dwmmc_execute_tuning(struct dwmci_host *host, u32 opcode) { return 0; }
+#endif
+
 static int rockchip_dwmmc_probe(struct udevice *dev)
 {
 	struct rockchip_mmc_plat *plat = dev_get_platdata(dev);
@@ -104,6 +181,9 @@ static int rockchip_dwmmc_probe(struct udevice *dev)
 	struct udevice *pwr_dev __maybe_unused;
 	int ret;
 
+#ifdef CONFIG_SPL_BUILD
+	mmc_gpio_init_direct();
+#endif
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct dtd_rockchip_rk3288_dw_mshc *dtplat = &plat->dtplat;
 
@@ -111,6 +191,7 @@ static int rockchip_dwmmc_probe(struct udevice *dev)
 	host->ioaddr = map_sysmem(dtplat->reg[0], dtplat->reg[1]);
 	host->buswidth = dtplat->bus_width;
 	host->get_mmc_clk = rockchip_dwmmc_get_mmc_clk;
+	host->execute_tuning = rockchip_dwmmc_execute_tuning;
 	host->priv = dev;
 	host->dev_index = 0;
 	priv->fifo_depth = dtplat->fifo_depth;
@@ -125,13 +206,24 @@ static int rockchip_dwmmc_probe(struct udevice *dev)
 	ret = clk_get_by_index(dev, 0, &priv->clk);
 	if (ret < 0)
 		return ret;
+
+	ret = clk_get_by_name(dev, "ciu-sample", &priv->sample_clk);
+	if (ret < 0)
+		debug("MMC: sample clock not found, not support hs200!\n");
+	host->execute_tuning = rockchip_dwmmc_execute_tuning;
 #endif
-	host->fifoth_val = MSIZE(0x2) |
+	host->fifoth_val = MSIZE(DWMCI_MSIZE) |
 		RX_WMARK(priv->fifo_depth / 2 - 1) |
 		TX_WMARK(priv->fifo_depth / 2);
 
 	host->fifo_mode = priv->fifo_mode;
 
+#ifdef CONFIG_ROCKCHIP_RK3128
+	host->stride_pio = true;
+#else
+	host->stride_pio = false;
+#endif
+
 #ifdef CONFIG_PWRSEQ
 	/* Enable power if needed */
 	ret = uclass_get_device_by_phandle(UCLASS_PWRSEQ, dev, "mmc-pwrseq",
@@ -143,6 +235,11 @@ static int rockchip_dwmmc_probe(struct udevice *dev)
 	}
 #endif
 	dwmci_setup_cfg(&plat->cfg, host, priv->minmax[1], priv->minmax[0]);
+	if (dev_read_bool(dev, "mmc-hs200-1_8v"))
+		plat->cfg.host_caps |= MMC_MODE_HS200;
+	plat->mmc.default_phase =
+		dev_read_u32_default(dev, "default-sample-phase", 0);
+	plat->mmc.init_retry = 0;
 	host->mmc = &plat->mmc;
 	host->mmc->priv = &priv->host;
 	host->mmc->dev = dev;
@@ -160,6 +257,7 @@ static int rockchip_dwmmc_bind(struct udevice *dev)
 
 static const struct udevice_id rockchip_dwmmc_ids[] = {
 	{ .compatible = "rockchip,rk3288-dw-mshc" },
+	{ .compatible = "rockchip,rk2928-dw-mshc" },
 	{ }
 };
 
diff --git a/drivers/mmc/rockchip_sdhci.c b/drivers/mmc/rockchip_sdhci.c
index f31d329c81..e701fb80dc 100644
--- a/drivers/mmc/rockchip_sdhci.c
+++ b/drivers/mmc/rockchip_sdhci.c
@@ -6,19 +6,80 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
+#include <asm/arch-rockchip/hardware.h>
 #include <common.h>
 #include <dm.h>
 #include <dt-structs.h>
-#include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <mapmem.h>
 #include <sdhci.h>
 #include <clk.h>
+#include <syscon.h>
+#include <dm/ofnode.h>
+#include <asm/arch-rockchip/clock.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 /* 400KHz is max freq for card ID etc. Use that as min */
 #define EMMC_MIN_FREQ	400000
+#define KHz	(1000)
+#define MHz	(1000 * KHz)
+
+#define PHYCTRL_CALDONE_MASK		0x1
+#define PHYCTRL_CALDONE_SHIFT		0x6
+#define PHYCTRL_CALDONE_DONE		0x1
+#define PHYCTRL_DLLRDY_MASK		0x1
+#define PHYCTRL_DLLRDY_SHIFT		0x5
+#define PHYCTRL_DLLRDY_DONE		0x1
+#define PHYCTRL_FREQSEL_200M		0x0
+#define PHYCTRL_FREQSEL_50M		0x1
+#define PHYCTRL_FREQSEL_100M		0x2
+#define PHYCTRL_FREQSEL_150M		0x3
+#define PHYCTRL_DLL_LOCK_WO_TMOUT(x)	\
+	((((x) >> PHYCTRL_DLLRDY_SHIFT) & PHYCTRL_DLLRDY_MASK) ==\
+	PHYCTRL_DLLRDY_DONE)
+
+/* Rockchip specific Registers */
+#define DWCMSHC_CTRL_HS400		0x7
+#define DWCMSHC_CARD_IS_EMMC		BIT(0)
+#define DWCMSHC_ENHANCED_STROBE		BIT(8)
+
+#define DWCMSHC_HOST_CTRL3		0x508
+#define DWCMSHC_EMMC_CONTROL		0x52c
+#define DWCMSHC_EMMC_DLL_CTRL		0x800
+#define DWCMSHC_EMMC_DLL_CTRL_RESET	BIT(1)
+#define DWCMSHC_EMMC_DLL_RXCLK		0x804
+#define DWCMSHC_EMMC_DLL_TXCLK		0x808
+#define DWCMSHC_EMMC_DLL_STRBIN		0x80c
+#define DECMSHC_EMMC_DLL_CMDOUT		0x810
+#define DWCMSHC_EMMC_DLL_STATUS0	0x840
+#define DWCMSHC_EMMC_DLL_STATUS1	0x844
+#define DWCMSHC_EMMC_DLL_START		BIT(0)
+#define DWCMSHC_EMMC_DLL_RXCLK_SRCSEL	29
+#define DWCMSHC_EMMC_DLL_START_POINT	16
+#define DWCMSHC_EMMC_DLL_START_DEFAULT	5
+#define DWCMSHC_EMMC_DLL_INC_VALUE	2
+#define DWCMSHC_EMMC_DLL_INC		8
+#define DWCMSHC_EMMC_DLL_DLYENA		BIT(27)
+#define DLL_TXCLK_TAPNUM_DEFAULT	0x10
+#define DLL_TXCLK_TAPNUM_90_DEGREES	0x8
+#define DLL_STRBIN_TAPNUM_DEFAULT	0x3
+#define DLL_TXCLK_TAPNUM_FROM_SW	BIT(24)
+#define DLL_TXCLK_NO_INVERTER		BIT(29)
+#define DWCMSHC_EMMC_DLL_LOCKED		BIT(8)
+#define DWCMSHC_EMMC_DLL_TIMEOUT	BIT(9)
+#define DLL_RXCLK_NO_INVERTER		1
+#define DLL_RXCLK_INVERTER		0
+#define DLL_CMDOUT_TAPNUM_90_DEGREES	0x8
+#define DLL_CMDOUT_TAPNUM_FROM_SW	BIT(24)
+#define DLL_CMDOUT_SRC_CLK_NEG		BIT(28)
+#define DLL_CMDOUT_EN_SRC_CLK_NEG	BIT(29)
+
+#define DWCMSHC_ENHANCED_STROBE		BIT(8)
+#define DLL_LOCK_WO_TMOUT(x) \
+	((((x) & DWCMSHC_EMMC_DLL_LOCKED) == DWCMSHC_EMMC_DLL_LOCKED) && \
+	(((x) & DWCMSHC_EMMC_DLL_TIMEOUT) == 0))
+#define ROCKCHIP_MAX_CLKS		3
 
 struct rockchip_sdhc_plat {
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
@@ -28,13 +89,359 @@ struct rockchip_sdhc_plat {
 	struct mmc mmc;
 };
 
+struct rockchip_emmc_phy {
+	u32 emmcphy_con[7];
+	u32 reserved;
+	u32 emmcphy_status;
+};
+
 struct rockchip_sdhc {
 	struct sdhci_host host;
+	struct udevice *dev;
 	void *base;
+	struct rockchip_emmc_phy *phy;
+	struct clk emmc_clk;
+};
+
+struct sdhci_data {
+	int (*emmc_set_clock)(struct sdhci_host *host, unsigned int clock);
+	void (*set_ios_post)(struct sdhci_host *host);
+	int (*get_phy)(struct udevice *dev);
+	u32 flags;
+#define RK_DLL_CMD_OUT		BIT(1)
+#define RK_RXCLK_NO_INVERTER	BIT(2)
 };
 
-static int arasan_sdhci_probe(struct udevice *dev)
+static void rk3399_emmc_phy_power_on(struct rockchip_emmc_phy *phy, u32 clock)
+{
+	u32 caldone, dllrdy, freqsel;
+	uint start;
+
+	writel(RK_CLRSETBITS(7 << 4, 0), &phy->emmcphy_con[6]);
+	writel(RK_CLRSETBITS(1 << 11, 1 << 11), &phy->emmcphy_con[0]);
+	writel(RK_CLRSETBITS(0xf << 7, 6 << 7), &phy->emmcphy_con[0]);
+
+	/*
+	 * According to the user manual, calpad calibration
+	 * cycle takes more than 2us without the minimal recommended
+	 * value, so we may need a little margin here
+	 */
+	udelay(3);
+	writel(RK_CLRSETBITS(1, 1), &phy->emmcphy_con[6]);
+
+	/*
+	 * According to the user manual, it asks driver to
+	 * wait 5us for calpad busy trimming. But it seems that
+	 * 5us of caldone isn't enough for all cases.
+	 */
+	udelay(500);
+	caldone = readl(&phy->emmcphy_status);
+	caldone = (caldone >> PHYCTRL_CALDONE_SHIFT) & PHYCTRL_CALDONE_MASK;
+	if (caldone != PHYCTRL_CALDONE_DONE) {
+		printf("%s: caldone timeout.\n", __func__);
+		return;
+	}
+
+	/* Set the frequency of the DLL operation */
+	if (clock < 75 * MHz)
+		freqsel = PHYCTRL_FREQSEL_50M;
+	else if (clock < 125 * MHz)
+		freqsel = PHYCTRL_FREQSEL_100M;
+	else if (clock < 175 * MHz)
+		freqsel = PHYCTRL_FREQSEL_150M;
+	else
+		freqsel = PHYCTRL_FREQSEL_200M;
+
+	/* Set the frequency of the DLL operation */
+	writel(RK_CLRSETBITS(3 << 12, freqsel << 12), &phy->emmcphy_con[0]);
+	writel(RK_CLRSETBITS(1 << 1, 1 << 1), &phy->emmcphy_con[6]);
+
+	/* REN Enable on STRB Line for HS400 */
+	writel(RK_CLRSETBITS(0, 1 << 9), &phy->emmcphy_con[2]);
+
+	start = get_timer(0);
+
+	do {
+		udelay(1);
+		dllrdy = readl(&phy->emmcphy_status);
+		dllrdy = (dllrdy >> PHYCTRL_DLLRDY_SHIFT) & PHYCTRL_DLLRDY_MASK;
+		if (dllrdy == PHYCTRL_DLLRDY_DONE)
+			break;
+	} while (get_timer(start) < 50000);
+
+	if (dllrdy != PHYCTRL_DLLRDY_DONE)
+		printf("%s: dllrdy timeout.\n", __func__);
+}
+
+static void rk3399_emmc_phy_power_off(struct rockchip_emmc_phy *phy)
+{
+	writel(RK_CLRSETBITS(1, 0), &phy->emmcphy_con[6]);
+	writel(RK_CLRSETBITS(1 << 1, 0), &phy->emmcphy_con[6]);
+}
+
+static int rockchip_emmc_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	unsigned int div, clk = 0, timeout;
+	unsigned int input_clk;
+	struct rockchip_sdhc *priv =
+			container_of(host, struct rockchip_sdhc, host);
+
+	/* Wait max 20 ms */
+	timeout = 200;
+	while (sdhci_readl(host, SDHCI_PRESENT_STATE) &
+			   (SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT)) {
+		if (timeout == 0) {
+			printf("%s: Timeout to wait cmd & data inhibit\n",
+			       __func__);
+			return -EBUSY;
+		}
+
+		timeout--;
+		udelay(100);
+	}
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
+
+	if (clock == 0)
+		return 0;
+
+	input_clk = clk_set_rate(&priv->emmc_clk, clock);
+	if (IS_ERR_VALUE(input_clk))
+		input_clk = host->max_clk;
+
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
+		/*
+		 * Check if the Host Controller supports Programmable Clock
+		 * Mode.
+		 */
+		if (host->clk_mul) {
+			for (div = 1; div <= 1024; div++) {
+				if ((input_clk / div) <= clock)
+					break;
+			}
+
+			/*
+			 * Set Programmable Clock Mode in the Clock
+			 * Control register.
+			 */
+			clk = SDHCI_PROG_CLOCK_MODE;
+			div--;
+		} else {
+			/* Version 3.00 divisors must be a multiple of 2. */
+			if (input_clk <= clock) {
+				div = 1;
+			} else {
+				for (div = 2;
+				     div < SDHCI_MAX_DIV_SPEC_300;
+				     div += 2) {
+					if ((input_clk / div) <= clock)
+						break;
+				}
+			}
+			div >>= 1;
+		}
+	} else {
+		/* Version 2.00 divisors must be a power of 2. */
+		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
+			if ((input_clk / div) <= clock)
+				break;
+		}
+		div >>= 1;
+	}
+
+	clk |= (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
+	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
+		<< SDHCI_DIVIDER_HI_SHIFT;
+	clk |= SDHCI_CLOCK_INT_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printf("%s: Internal clock never stabilised.\n",
+			       __func__);
+			return -EBUSY;
+		}
+		timeout--;
+		udelay(1000);
+	}
+	clk |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	host->clock = clock;
+
+	return 0;
+}
+
+static int rk3399_emmc_get_phy(struct udevice *dev)
 {
+	struct rockchip_sdhc *priv = dev_get_priv(dev);
+
+#if CONFIG_IS_ENABLED(OF_PLATDATA)
+	priv->phy = (struct rockchip_emmc_phy *)0xff77f780;
+#else
+	ofnode phy_node;
+	void *grf_base;
+	u32 grf_phy_offset, phandle;
+
+	phandle = dev_read_u32_default(dev, "phys", 0);
+	phy_node = ofnode_get_by_phandle(phandle);
+	if (!ofnode_valid(phy_node)) {
+		debug("Not found emmc phy device\n");
+		return -ENODEV;
+	}
+
+	grf_base = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (grf_base < 0)
+		printf("%s Get syscon grf failed", __func__);
+	grf_phy_offset = ofnode_read_u32_default(phy_node, "reg", 0);
+
+	priv->phy = (struct rockchip_emmc_phy *)(grf_base + grf_phy_offset);
+#endif
+	return 0;
+}
+
+static int rk3399_sdhci_emmc_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct rockchip_sdhc *priv =
+			container_of(host, struct rockchip_sdhc, host);
+	int cycle_phy = host->clock != clock &&
+			clock > EMMC_MIN_FREQ;
+
+	if (cycle_phy)
+		rk3399_emmc_phy_power_off(priv->phy);
+
+	rockchip_emmc_set_clock(host, clock);
+
+	if (cycle_phy)
+		rk3399_emmc_phy_power_on(priv->phy, clock);
+
+	return 0;
+}
+
+static int dwcmshc_sdhci_emmc_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct rockchip_sdhc *priv = container_of(host, struct rockchip_sdhc, host);
+	struct sdhci_data *data = (struct sdhci_data *)dev_get_driver_data(priv->dev);
+	u32 extra;
+	int timeout = 500, ret;
+
+	ret = rockchip_emmc_set_clock(host, clock);
+
+	if (clock >= 100 * MHz) {
+		/* reset DLL */
+		sdhci_writel(host, DWCMSHC_EMMC_DLL_CTRL_RESET, DWCMSHC_EMMC_DLL_CTRL);
+		udelay(1);
+		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_CTRL);
+
+		/* Init DLL settings */
+		extra = DWCMSHC_EMMC_DLL_START_DEFAULT << DWCMSHC_EMMC_DLL_START_POINT |
+			DWCMSHC_EMMC_DLL_INC_VALUE << DWCMSHC_EMMC_DLL_INC |
+			DWCMSHC_EMMC_DLL_START;
+		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_CTRL);
+
+		while (1) {
+			if (timeout < 0)
+				return -ETIMEDOUT;
+			if (DLL_LOCK_WO_TMOUT((sdhci_readl(host, DWCMSHC_EMMC_DLL_STATUS0))))
+				break;
+			udelay(1);
+			timeout--;
+		}
+		extra = DWCMSHC_EMMC_DLL_DLYENA;
+		if (data->flags & RK_RXCLK_NO_INVERTER)
+			extra |= DLL_RXCLK_NO_INVERTER << DWCMSHC_EMMC_DLL_RXCLK_SRCSEL;
+		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_RXCLK);
+
+		extra = DWCMSHC_EMMC_DLL_DLYENA |
+			DLL_TXCLK_TAPNUM_FROM_SW |
+			DLL_TXCLK_NO_INVERTER|
+			DLL_TXCLK_TAPNUM_DEFAULT;
+
+		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_TXCLK);
+
+		extra = DWCMSHC_EMMC_DLL_DLYENA |
+			DLL_STRBIN_TAPNUM_DEFAULT;
+		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_STRBIN);
+	} else {
+		/* Disable cmd conflict check */
+		extra = sdhci_readl(host, DWCMSHC_HOST_CTRL3);
+		extra &= ~BIT(0);
+		sdhci_writel(host, extra, DWCMSHC_HOST_CTRL3);
+
+		/* reset the clock phase when the frequency is lower than 100MHz */
+		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_CTRL);
+		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_RXCLK);
+		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_TXCLK);
+		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_STRBIN);
+		sdhci_writel(host, 0, DECMSHC_EMMC_DLL_CMDOUT);
+	}
+	return ret;
+}
+
+static void dwcmshc_sdhci_set_ios_post(struct sdhci_host *host)
+{
+	u16 ctrl;
+	u32 extra;
+	u32 timing = host->mmc->timing;
+
+	if (timing == MMC_TIMING_MMC_HS400 || timing == MMC_TIMING_MMC_HS400ES) {
+		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+		ctrl &= ~SDHCI_CTRL_UHS_MASK;
+		ctrl |= DWCMSHC_CTRL_HS400;
+		sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+
+		/* set CARD_IS_EMMC bit to enable Data Strobe for HS400 */
+		ctrl = sdhci_readw(host, DWCMSHC_EMMC_CONTROL);
+		ctrl |= DWCMSHC_CARD_IS_EMMC;
+		sdhci_writew(host, ctrl, DWCMSHC_EMMC_CONTROL);
+
+		extra = DLL_CMDOUT_SRC_CLK_NEG |
+			DLL_CMDOUT_EN_SRC_CLK_NEG;
+		sdhci_writel(host, extra, DECMSHC_EMMC_DLL_CMDOUT);
+
+		extra = DWCMSHC_EMMC_DLL_DLYENA |
+			DLL_TXCLK_TAPNUM_FROM_SW |
+			DLL_TXCLK_NO_INVERTER|
+			DLL_TXCLK_TAPNUM_90_DEGREES;
+		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_TXCLK);
+	}
+}
+
+static int dwcmshc_emmc_get_phy(struct udevice *dev)
+{
+	return 0;
+}
+
+static int rockchip_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct rockchip_sdhc *priv =
+			container_of(host, struct rockchip_sdhc, host);
+	struct sdhci_data *data = (struct sdhci_data *)dev_get_driver_data(priv->dev);
+	if (!data)
+		return -EINVAL;
+
+	return data->emmc_set_clock(host, clock);
+}
+
+static void rockchip_sdhci_set_ios_post(struct sdhci_host *host)
+{
+	struct rockchip_sdhc *priv =
+			container_of(host, struct rockchip_sdhc, host);
+	struct sdhci_data *data = (struct sdhci_data *)dev_get_driver_data(priv->dev);
+
+	if (data && data->set_ios_post)
+		data->set_ios_post(host);
+}
+
+static struct sdhci_ops rockchip_sdhci_ops = {
+	.set_clock	= rockchip_sdhci_set_clock,
+	.set_ios_post	= rockchip_sdhci_set_ios_post,
+};
+
+static int rockchip_sdhci_probe(struct udevice *dev)
+{
+	struct sdhci_data *data = (struct sdhci_data *)dev_get_driver_data(dev);
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
 	struct rockchip_sdhc_plat *plat = dev_get_platdata(dev);
 	struct rockchip_sdhc *prv = dev_get_priv(dev);
@@ -46,11 +453,25 @@ static int arasan_sdhci_probe(struct udevice *dev)
 	struct dtd_rockchip_rk3399_sdhci_5_1 *dtplat = &plat->dtplat;
 
 	host->name = dev->name;
-	host->ioaddr = map_sysmem(dtplat->reg[1], dtplat->reg[3]);
+	host->ioaddr = map_sysmem(dtplat->reg[0], dtplat->reg[1]);
+	host->host_caps |= MMC_MODE_8BIT;
 	max_frequency = dtplat->max_frequency;
 	ret = clk_get_by_index_platdata(dev, 0, dtplat->clocks, &clk);
 #else
 	max_frequency = dev_read_u32_default(dev, "max-frequency", 0);
+	switch (dev_read_u32_default(dev, "bus-width", 4)) {
+	case 8:
+		host->host_caps |= MMC_MODE_8BIT;
+		break;
+	case 4:
+		host->host_caps |= MMC_MODE_4BIT;
+		break;
+	case 1:
+		break;
+	default:
+		printf("Invalid \"bus-width\" value\n");
+		return -EINVAL;
+	}
 	ret = clk_get_by_index(dev, 0, &clk);
 #endif
 	if (!ret) {
@@ -61,9 +482,20 @@ static int arasan_sdhci_probe(struct udevice *dev)
 		printf("%s fail to get clk\n", __func__);
 	}
 
-	host->quirks = SDHCI_QUIRK_WAIT_SEND_CMD;
+	prv->emmc_clk = clk;
+	prv->dev = dev;
+	ret = data->get_phy(dev);
+	if (ret)
+		return ret;
+
+	host->ops = &rockchip_sdhci_ops;
+
 	host->max_clk = max_frequency;
 
+	if (dev_read_bool(dev, "mmc-hs200-1_8v"))
+		host->host_caps |= MMC_MODE_HS200;
+	else if (dev_read_bool(dev, "mmc-hs400-1_8v"))
+		host->host_caps |= MMC_MODE_HS400;
 	ret = sdhci_setup_cfg(&plat->cfg, host, 0, EMMC_MIN_FREQ);
 
 	host->mmc = &plat->mmc;
@@ -76,13 +508,13 @@ static int arasan_sdhci_probe(struct udevice *dev)
 	return sdhci_probe(dev);
 }
 
-static int arasan_sdhci_ofdata_to_platdata(struct udevice *dev)
+static int rockchip_sdhci_of_to_plat(struct udevice *dev)
 {
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct sdhci_host *host = dev_get_priv(dev);
 
 	host->name = dev->name;
-	host->ioaddr = devfdt_get_addr_ptr(dev);
+	host->ioaddr = dev_read_addr_ptr(dev);
 #endif
 
 	return 0;
@@ -95,19 +527,48 @@ static int rockchip_sdhci_bind(struct udevice *dev)
 	return sdhci_bind(dev, &plat->mmc, &plat->cfg);
 }
 
-static const struct udevice_id arasan_sdhci_ids[] = {
-	{ .compatible = "arasan,sdhci-5.1" },
+static const struct sdhci_data arasan_data = {
+	.emmc_set_clock = rk3399_sdhci_emmc_set_clock,
+	.get_phy = rk3399_emmc_get_phy,
+};
+
+static const struct sdhci_data rk3568_data = {
+	.emmc_set_clock = dwcmshc_sdhci_emmc_set_clock,
+	.get_phy = dwcmshc_emmc_get_phy,
+	.flags = RK_RXCLK_NO_INVERTER,
+};
+
+static const struct sdhci_data rk3588_data = {
+	.emmc_set_clock = dwcmshc_sdhci_emmc_set_clock,
+	.get_phy = dwcmshc_emmc_get_phy,
+	.set_ios_post = dwcmshc_sdhci_set_ios_post,
+	.flags = RK_DLL_CMD_OUT | RK_RXCLK_NO_INVERTER,
+};
+
+static const struct udevice_id sdhci_ids[] = {
+	{
+		.compatible = "arasan,sdhci-5.1",
+		.data = (ulong)&arasan_data,
+	},
+	{
+		.compatible = "snps,dwcmshc-sdhci",
+		.data = (ulong)&rk3568_data,
+	},
+	{
+		.compatible = "rockchip,rk3588-dwcmshc",
+		.data = (ulong)&rk3588_data,
+	},
 	{ }
 };
 
 U_BOOT_DRIVER(arasan_sdhci_drv) = {
-	.name		= "rockchip_rk3399_sdhci_5_1",
+	.name		= "rockchip_sdhci_5_1",
 	.id		= UCLASS_MMC,
-	.of_match	= arasan_sdhci_ids,
-	.ofdata_to_platdata = arasan_sdhci_ofdata_to_platdata,
+	.of_match	= sdhci_ids,
+	.ofdata_to_platdata = rockchip_sdhci_of_to_plat,
 	.ops		= &sdhci_ops,
 	.bind		= rockchip_sdhci_bind,
-	.probe		= arasan_sdhci_probe,
+	.probe		= rockchip_sdhci_probe,
 	.priv_auto_alloc_size = sizeof(struct rockchip_sdhc),
 	.platdata_auto_alloc_size = sizeof(struct rockchip_sdhc_plat),
 };
diff --git a/drivers/mmc/rpmb.c b/drivers/mmc/rpmb.c
index 0b6b6222bd..88136f0644 100644
--- a/drivers/mmc/rpmb.c
+++ b/drivers/mmc/rpmb.c
@@ -40,12 +40,6 @@
 #define RPMB_ERR_CNT_EXPIRED	0x80
 #define RPMB_ERR_MSK		0x7
 
-/* Sizes of RPMB data frame */
-#define RPMB_SZ_STUFF		196
-#define RPMB_SZ_MAC		32
-#define RPMB_SZ_DATA		256
-#define RPMB_SZ_NONCE		16
-
 #define SHA256_BLOCK_SIZE	64
 
 /* Error messages */
@@ -60,20 +54,6 @@ static const char * const rpmb_err_msg[] = {
 	"Authentication key not yet programmed",
 };
 
-
-/* Structure of RPMB data frame. */
-struct s_rpmb {
-	unsigned char stuff[RPMB_SZ_STUFF];
-	unsigned char mac[RPMB_SZ_MAC];
-	unsigned char data[RPMB_SZ_DATA];
-	unsigned char nonce[RPMB_SZ_NONCE];
-	unsigned int write_counter;
-	unsigned short address;
-	unsigned short block_count;
-	unsigned short result;
-	unsigned short request;
-};
-
 static int mmc_set_blockcount(struct mmc *mmc, unsigned int blockcount,
 			      bool is_rel_write)
 {
@@ -87,7 +67,7 @@ static int mmc_set_blockcount(struct mmc *mmc, unsigned int blockcount,
 
 	return mmc_send_cmd(mmc, &cmd, NULL);
 }
-static int mmc_rpmb_request(struct mmc *mmc, const struct s_rpmb *s,
+static int mmc_rpmb_request(struct mmc *mmc, const void *s,
 			    unsigned int count, bool is_rel_write)
 {
 	struct mmc_cmd cmd = {0};
@@ -104,10 +84,10 @@ static int mmc_rpmb_request(struct mmc *mmc, const struct s_rpmb *s,
 
 	cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
 	cmd.cmdarg = 0;
-	cmd.resp_type = MMC_RSP_R1b;
+	cmd.resp_type = MMC_RSP_R1;
 
 	data.src = (const char *)s;
-	data.blocks = 1;
+	data.blocks = count;
 	data.blocksize = MMC_MAX_BLOCK_LEN;
 	data.flags = MMC_DATA_WRITE;
 
@@ -121,13 +101,13 @@ static int mmc_rpmb_request(struct mmc *mmc, const struct s_rpmb *s,
 	return 0;
 }
 static int mmc_rpmb_response(struct mmc *mmc, struct s_rpmb *s,
-			     unsigned short expected)
+			     unsigned short expected, unsigned short cnt)
 {
 	struct mmc_cmd cmd = {0};
 	struct mmc_data data;
 	int ret;
 
-	ret = mmc_set_blockcount(mmc, 1, false);
+	ret = mmc_set_blockcount(mmc, cnt, false);
 	if (ret) {
 #ifdef CONFIG_MMC_RPMB_TRACE
 		printf("%s:mmc_set_blockcount-> %d\n", __func__, ret);
@@ -139,7 +119,7 @@ static int mmc_rpmb_response(struct mmc *mmc, struct s_rpmb *s,
 	cmd.resp_type = MMC_RSP_R1;
 
 	data.dest = (char *)s;
-	data.blocks = 1;
+	data.blocks = cnt;
 	data.blocksize = MMC_MAX_BLOCK_LEN;
 	data.flags = MMC_DATA_READ;
 
@@ -178,7 +158,7 @@ static int mmc_rpmb_status(struct mmc *mmc, unsigned short expected)
 		return -1;
 
 	/* Read the result */
-	return mmc_rpmb_response(mmc, rpmb_frame, expected);
+	return mmc_rpmb_response(mmc, rpmb_frame, expected, 1);
 }
 static void rpmb_hmac(unsigned char *key, unsigned char *buff, int len,
 		      unsigned char *output)
@@ -236,7 +216,7 @@ int mmc_rpmb_get_counter(struct mmc *mmc, unsigned long *pcounter)
 		return -1;
 
 	/* Read the result */
-	ret = mmc_rpmb_response(mmc, rpmb_frame, RPMB_RESP_WCOUNTER);
+	ret = mmc_rpmb_response(mmc, rpmb_frame, RPMB_RESP_WCOUNTER, 1);
 	if (ret)
 		return ret;
 
@@ -260,65 +240,168 @@ int mmc_rpmb_set_key(struct mmc *mmc, void *key)
 int mmc_rpmb_read(struct mmc *mmc, void *addr, unsigned short blk,
 		  unsigned short cnt, unsigned char *key)
 {
-	ALLOC_CACHE_ALIGN_BUFFER(struct s_rpmb, rpmb_frame, 1);
+	ALLOC_CACHE_ALIGN_BUFFER
+		(char, rpmb_frame_data,
+		sizeof(struct s_rpmb) * cnt);
+	ALLOC_CACHE_ALIGN_BUFFER
+		(char, rpmb_frame_data_verify,
+		sizeof(struct s_rpmb_verify) * cnt);
+	struct s_rpmb *rpmb_frame;
+	struct s_rpmb_verify *rpmb_frame_vrify;
 	int i;
 
+	memset(rpmb_frame_data, 0, sizeof(struct s_rpmb) * cnt);
+	memset(rpmb_frame_data_verify, 0, sizeof(struct s_rpmb_verify) * cnt);
+	rpmb_frame = (struct s_rpmb *)rpmb_frame_data;
+	rpmb_frame->address = cpu_to_be16(blk);
+	rpmb_frame->request = cpu_to_be16(RPMB_REQ_READ_DATA);
+	if (mmc_rpmb_request(mmc, rpmb_frame, 1, false)) {
+		printf("mmc_rpmb_read request error\n");
+		return -1;
+	}
+
+	if (mmc_rpmb_response
+			(mmc,
+			(struct s_rpmb *)rpmb_frame_data,
+			RPMB_RESP_READ_DATA, cnt)) {
+		printf("mmc_rpmb_read response error\n");
+		return -1;
+	}
+
 	for (i = 0; i < cnt; i++) {
-		/* Fill the request */
-		memset(rpmb_frame, 0, sizeof(struct s_rpmb));
-		rpmb_frame->address = cpu_to_be16(blk + i);
-		rpmb_frame->request = cpu_to_be16(RPMB_REQ_READ_DATA);
-		if (mmc_rpmb_request(mmc, rpmb_frame, 1, false))
-			break;
-
-		/* Read the result */
-		if (mmc_rpmb_response(mmc, rpmb_frame, RPMB_RESP_READ_DATA))
-			break;
-
-		/* Check the HMAC if key is provided */
-		if (key) {
-			unsigned char ret_hmac[RPMB_SZ_MAC];
-
-			rpmb_hmac(key, rpmb_frame->data, 284, ret_hmac);
-			if (memcmp(ret_hmac, rpmb_frame->mac, RPMB_SZ_MAC)) {
-				printf("MAC error on block #%d\n", i);
-				break;
-			}
-		}
-		/* Copy data */
+		rpmb_frame = (struct s_rpmb *)
+					(rpmb_frame_data +
+					i * sizeof(struct s_rpmb));
+
+		rpmb_frame_vrify = (struct s_rpmb_verify *)
+					(rpmb_frame_data_verify +
+					i * sizeof(struct s_rpmb_verify));
 		memcpy(addr + i * RPMB_SZ_DATA, rpmb_frame->data, RPMB_SZ_DATA);
+		memcpy(rpmb_frame_vrify->data, rpmb_frame->data, 284);
 	}
-	return i;
+
+	if (key) {
+		unsigned char ret_hmac[RPMB_SZ_MAC];
+		rpmb_hmac
+			(key, (unsigned char *)rpmb_frame_data_verify,
+			284 * cnt, ret_hmac);
+		if (memcmp(ret_hmac, rpmb_frame->mac, RPMB_SZ_MAC)) {
+			printf("MAC error on block #%d\n", i);
+			return -1;
+		}
+	}
+
+	return cnt;
 }
 int mmc_rpmb_write(struct mmc *mmc, void *addr, unsigned short blk,
 		  unsigned short cnt, unsigned char *key)
 {
-	ALLOC_CACHE_ALIGN_BUFFER(struct s_rpmb, rpmb_frame, 1);
+	struct s_rpmb *rpmb_frame;
+	struct s_rpmb_verify *rpmb_frame_vrify;
+	ALLOC_CACHE_ALIGN_BUFFER
+		(char, rpmb_frame_data,
+		sizeof(struct s_rpmb) * cnt);
+	ALLOC_CACHE_ALIGN_BUFFER
+		(char, rpmb_frame_data_verify,
+		sizeof(struct s_rpmb_verify) * cnt);
+
 	unsigned long wcount;
-	int i;
+	unsigned short i;
+	unsigned short temp;
 
+	temp = cnt - 1;
+	memset(rpmb_frame_data, 0, sizeof(struct s_rpmb) * cnt);
+	memset(rpmb_frame_data_verify, 0, sizeof(struct s_rpmb_verify) * cnt);
 	for (i = 0; i < cnt; i++) {
-		if (mmc_rpmb_get_counter(mmc, &wcount)) {
-			printf("Cannot read RPMB write counter\n");
-			break;
+		if (i == 0) {
+			if (mmc_rpmb_get_counter(mmc, &wcount)) {
+				printf("Cannot read RPMB write counter\n");
+				break;
+			}
 		}
 
-		/* Fill the request */
-		memset(rpmb_frame, 0, sizeof(struct s_rpmb));
+		rpmb_frame = (struct s_rpmb *)
+			(rpmb_frame_data +
+			i * sizeof(struct s_rpmb));
+		rpmb_frame_vrify = (struct s_rpmb_verify *)
+			(rpmb_frame_data_verify +
+			i * sizeof(struct s_rpmb_verify));
 		memcpy(rpmb_frame->data, addr + i * RPMB_SZ_DATA, RPMB_SZ_DATA);
-		rpmb_frame->address = cpu_to_be16(blk + i);
-		rpmb_frame->block_count = cpu_to_be16(1);
+		memcpy(rpmb_frame_vrify->data, addr +
+			i * RPMB_SZ_DATA, RPMB_SZ_DATA);
+		rpmb_frame->address = cpu_to_be16(blk);
+		rpmb_frame_vrify->address = cpu_to_be16(blk);
+		rpmb_frame->block_count = cpu_to_be16(cnt);
+		rpmb_frame_vrify->block_count = cpu_to_be16(cnt);
 		rpmb_frame->write_counter = cpu_to_be32(wcount);
+		rpmb_frame_vrify->write_counter = cpu_to_be32(wcount);
 		rpmb_frame->request = cpu_to_be16(RPMB_REQ_WRITE_DATA);
-		/* Computes HMAC */
-		rpmb_hmac(key, rpmb_frame->data, 284, rpmb_frame->mac);
+		rpmb_frame_vrify->request = cpu_to_be16(RPMB_REQ_WRITE_DATA);
+		if (i == temp) {
+			rpmb_hmac
+				(key, (unsigned char *)rpmb_frame_data_verify,
+				284 * cnt, rpmb_frame->mac);
+		}
+	}
+	if (mmc_rpmb_request(mmc, rpmb_frame_data, cnt, true))
+		return -1;
 
-		if (mmc_rpmb_request(mmc, rpmb_frame, 1, true))
-			break;
+	if (mmc_rpmb_status(mmc, RPMB_RESP_WRITE_DATA))
+		return -1;
+	return cnt;
+}
 
-		/* Get status */
-		if (mmc_rpmb_status(mmc, RPMB_RESP_WRITE_DATA))
-			break;
-	}
-	return i;
+int read_counter(struct mmc *mmc, struct s_rpmb *requestpackets)
+{
+	if (mmc_rpmb_request(mmc, requestpackets, 1, false))
+		return -1;
+
+	if (mmc_rpmb_response(mmc, requestpackets, RPMB_RESP_WCOUNTER, 1))
+		return -1;
+
+	return 0;
+}
+
+int program_key(struct mmc *mmc, struct s_rpmb *requestpackets)
+{
+	if (mmc_rpmb_request(mmc, requestpackets, 1, true))
+		return -1;
+
+	memset(requestpackets, 0, sizeof(struct s_rpmb));
+
+	requestpackets->request = cpu_to_be16(RPMB_REQ_STATUS);
+
+	if (mmc_rpmb_request(mmc, requestpackets, 1, false))
+		return -1;
+
+	return mmc_rpmb_response(mmc, requestpackets, RPMB_RESP_KEY, 1);
+}
+
+int authenticated_read(struct mmc *mmc,
+	struct s_rpmb *requestpackets, uint16_t block_count)
+{
+	if (mmc_rpmb_request(mmc, requestpackets, 1, false))
+		return -1;
+
+	if (mmc_rpmb_response
+		(mmc, requestpackets, RPMB_RESP_READ_DATA, block_count))
+		return -1;
+
+	return 0;
+}
+
+int authenticated_write(struct mmc *mmc, struct s_rpmb *requestpackets)
+{
+	if (mmc_rpmb_request(mmc, requestpackets, 1, true))
+		return -1;
+
+	memset(requestpackets, 0, sizeof(struct s_rpmb));
+
+	requestpackets->request = cpu_to_be16(RPMB_REQ_STATUS);
+
+	if (mmc_rpmb_request(mmc, requestpackets, 1, false))
+		return -1;
+
+	return mmc_rpmb_response(mmc, requestpackets, RPMB_RESP_WRITE_DATA, 1);
 }
+
diff --git a/drivers/mmc/s5p_sdhci.c b/drivers/mmc/s5p_sdhci.c
index 62817a0d07..6007a8ab64 100644
--- a/drivers/mmc/s5p_sdhci.c
+++ b/drivers/mmc/s5p_sdhci.c
@@ -10,7 +10,7 @@
 #include <malloc.h>
 #include <sdhci.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <asm/gpio.h>
 #include <asm/arch/mmc.h>
 #include <asm/arch/clk.h>
@@ -73,14 +73,14 @@ static void s5p_sdhci_set_control_reg(struct sdhci_host *host)
 	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
 }
 
-static void s5p_set_clock(struct sdhci_host *host, u32 div)
+static void s5p_set_clock_ext(struct sdhci_host *host, u32 div)
 {
 	/* ToDo : Use the Clock Framework */
 	set_mmc_clk(host->index, div);
 }
 
 static const struct sdhci_ops s5p_sdhci_ops = {
-	.set_clock	= &s5p_set_clock,
+	.set_clock_ext	= &s5p_set_clock_ext,
 	.set_control_reg = &s5p_sdhci_set_control_reg,
 };
 
diff --git a/drivers/mmc/sdhci-cadence.c b/drivers/mmc/sdhci-cadence.c
index f83c1d7241..e027642008 100644
--- a/drivers/mmc/sdhci-cadence.c
+++ b/drivers/mmc/sdhci-cadence.c
@@ -10,7 +10,7 @@
 #include <linux/io.h>
 #include <linux/iopoll.h>
 #include <linux/sizes.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <mmc.h>
 #include <sdhci.h>
 
diff --git a/drivers/mmc/sdhci.c b/drivers/mmc/sdhci.c
index 11d1f0c24c..4d472b78b3 100644
--- a/drivers/mmc/sdhci.c
+++ b/drivers/mmc/sdhci.c
@@ -158,7 +158,10 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 	static unsigned int cmd_timeout = SDHCI_CMD_DEFAULT_TIMEOUT;
 
 	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
-	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
+	mask = SDHCI_CMD_INHIBIT;
+
+	if (data)
+		mask |= SDHCI_DATA_INHIBIT;
 
 	/* We shouldn't wait for data inihibit for stop commands, even
 	   though they might use busy signaling */
@@ -200,6 +203,13 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 	if (data)
 		flags |= SDHCI_CMD_DATA;
 
+	if (cmd->cmdidx == MMC_SEND_TUNING_BLOCK ||
+	    cmd->cmdidx == MMC_SEND_TUNING_BLOCK_HS200) {
+		mask &= ~SDHCI_INT_RESPONSE;
+		mask |= SDHCI_INT_DATA_AVAIL;
+		flags |= SDHCI_CMD_DATA;
+	}
+
 	/* Set Transfer mode regarding to data flag */
 	if (data != 0) {
 		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
@@ -301,9 +311,8 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 		return -ECOMM;
 }
 
-static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
+int sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 {
-	struct sdhci_host *host = mmc->priv;
 	unsigned int div, clk = 0, timeout;
 
 	/* Wait max 20 ms */
@@ -319,12 +328,10 @@ static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
 		timeout--;
 		udelay(100);
 	}
-
 	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
 
 	if (clock == 0)
 		return 0;
-
 	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
 		/*
 		 * Check if the Host Controller supports Programmable Clock
@@ -364,9 +371,8 @@ static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
 		}
 		div >>= 1;
 	}
-
-	if (host->ops && host->ops->set_clock)
-		host->ops->set_clock(host, div);
+	if (host->ops && host->ops->set_clock_ext)
+		host->ops->set_clock_ext(host, div);
 
 	clk |= (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
 	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
@@ -386,9 +392,10 @@ static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
 		timeout--;
 		udelay(1000);
 	}
-
 	clk |= SDHCI_CLOCK_CARD_EN;
 	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	host->clock = clock;
 	return 0;
 }
 
@@ -422,6 +429,57 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
 }
 
+static void sdhci_set_uhs_signaling(struct sdhci_host *host)
+{
+	u16 ctrl_2;
+	u32 timing = host->mmc->timing;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+
+	if ((timing != MMC_TIMING_LEGACY) &&
+	    (timing != MMC_TIMING_MMC_HS) &&
+	    (timing != MMC_TIMING_SD_HS))
+		ctrl_2 |= SDHCI_CTRL_VDD_180;
+
+	if ((timing == MMC_TIMING_MMC_HS200) ||
+	    (timing == MMC_TIMING_UHS_SDR104))
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104 | SDHCI_CTRL_DRV_TYPE_A;
+	else if (timing == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (timing == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if ((timing == MMC_TIMING_UHS_SDR50) ||
+		(timing == MMC_TIMING_MMC_HS))
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+		 (timing == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (timing == MMC_TIMING_MMC_HS400 ||
+		 timing == MMC_TIMING_MMC_HS400ES)
+		ctrl_2 |= SDHCI_CTRL_HS400 | SDHCI_CTRL_DRV_TYPE_A;
+
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+#ifdef CONFIG_DM_MMC
+static bool sdhci_card_busy(struct udevice *dev)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+#else
+static bool sdhci_card_busy(struct mmc *mmc)
+{
+#endif
+	struct sdhci_host *host = mmc->priv;
+	u32 present_state;
+
+	/* Check whether DAT[0] is 0 */
+	present_state = sdhci_readl(host, SDHCI_PRESENT_STATE);
+
+	return !(present_state & SDHCI_DATA_0_LVL);
+}
+
 #ifdef CONFIG_DM_MMC
 static int sdhci_set_ios(struct udevice *dev)
 {
@@ -436,8 +494,12 @@ static int sdhci_set_ios(struct mmc *mmc)
 	if (host->ops && host->ops->set_control_reg)
 		host->ops->set_control_reg(host);
 
-	if (mmc->clock != host->clock)
-		sdhci_set_clock(mmc, mmc->clock);
+	if (mmc->clock != host->clock) {
+		if (host->ops && host->ops->set_clock)
+			host->ops->set_clock(host, mmc->clock);
+		else
+			sdhci_set_clock(host, mmc->clock);
+	}
 
 	/* Set bus width */
 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
@@ -456,16 +518,21 @@ static int sdhci_set_ios(struct mmc *mmc)
 			ctrl &= ~SDHCI_CTRL_4BITBUS;
 	}
 
-	if (mmc->clock > 26000000)
+	if (!(mmc->timing == MMC_TIMING_LEGACY) &&
+	    !(host->quirks & SDHCI_QUIRK_NO_HISPD_BIT))
 		ctrl |= SDHCI_CTRL_HISPD;
 	else
 		ctrl &= ~SDHCI_CTRL_HISPD;
 
-	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
-		ctrl &= ~SDHCI_CTRL_HISPD;
-
 	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
 
+	if ((mmc->timing != MMC_TIMING_LEGACY) &&
+	    (mmc->timing != MMC_TIMING_MMC_HS) &&
+	    (mmc->timing != MMC_TIMING_SD_HS))
+		sdhci_set_power(host, MMC_VDD_165_195_SHIFT);
+
+	sdhci_set_uhs_signaling(host);
+
 	/* If available, call the driver specific "post" set_ios() function */
 	if (host->ops && host->ops->set_ios_post)
 		host->ops->set_ios_post(host);
@@ -502,6 +569,108 @@ static int sdhci_init(struct mmc *mmc)
 	return 0;
 }
 
+static int sdhci_send_tuning(struct sdhci_host *host, u32 opcode)
+{
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = opcode;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+	/*
+	 * In response to CMD19, the card sends 64 bytes of tuning
+	 * block to the Host Controller. So we set the block size
+	 * to 64 here.
+	 */
+	if (opcode == MMC_SEND_TUNING_BLOCK_HS200 &&
+	    host->mmc->bus_width == MMC_BUS_WIDTH_8BIT)
+		sdhci_writew(host, SDHCI_MAKE_BLKSZ(7, 128), SDHCI_BLOCK_SIZE);
+	else
+		sdhci_writew(host, SDHCI_MAKE_BLKSZ(7, 64), SDHCI_BLOCK_SIZE);
+
+	/*
+	 * The tuning block is sent by the card to the host controller.
+	 * So we set the TRNS_READ bit in the Transfer Mode register.
+	 * This also takes care of setting DMA Enable and Multi Block
+	 * Select in the same register to 0.
+	 */
+	sdhci_writew(host, SDHCI_TRNS_READ, SDHCI_TRANSFER_MODE);
+
+#ifdef CONFIG_DM_MMC
+	return sdhci_send_command(host->mmc->dev, &cmd, NULL);
+#else
+	return sdhci_send_command(host->mmc, &cmd, NULL);
+#endif
+}
+
+#define MAX_TUNING_LOOP 40
+static int __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int i;
+	int ret;
+
+	/*
+	 * Issue opcode repeatedly till Execute Tuning is set to 0 or the number
+	 * of loops reaches 40 times.
+	 */
+	for (i = 0; i < MAX_TUNING_LOOP; i++) {
+		u16 ctrl;
+
+		ret = sdhci_send_tuning(host, opcode);
+
+		if (ret)
+			return ret;
+
+		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+		if (!(ctrl & SDHCI_CTRL_EXEC_TUNING)) {
+			if (ctrl & SDHCI_CTRL_TUNED_CLK)
+				/* Tuning successfully */
+				return 0;
+			break;
+		}
+	}
+
+	return -ETIMEDOUT;
+}
+
+#ifdef CONFIG_DM_MMC
+static int sdhci_execute_tuning(struct udevice *dev, u32 opcode)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+#else
+static int sdhci_execute_tuning(struct mmc *mmc, u32 opcode)
+{
+#endif
+	struct sdhci_host *host = mmc->priv;
+	u16 ctrl;
+
+	/*
+	 * The Host Controller needs tuning in case of SDR104 and DDR50
+	 * mode, and for SDR50 mode when Use Tuning for SDR50 is set in
+	 * the Capabilities register.
+	 * If the Host Controller supports the HS200 mode then the
+	 * tuning function has to be executed.
+	 */
+	switch (mmc->timing) {
+	/* HS400 tuning is done in HS200 mode */
+	case MMC_TIMING_MMC_HS400:
+		return -EINVAL;
+	case MMC_TIMING_MMC_HS200:
+		/*
+		 * Periodic re-tuning for HS400 is not expected to be needed, so
+		 * disable it here.
+		 */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl |= SDHCI_CTRL_EXEC_TUNING;
+	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+
+	return __sdhci_execute_tuning(host, opcode);
+}
+
 #ifdef CONFIG_DM_MMC
 int sdhci_probe(struct udevice *dev)
 {
@@ -511,14 +680,18 @@ int sdhci_probe(struct udevice *dev)
 }
 
 const struct dm_mmc_ops sdhci_ops = {
+	.card_busy	= sdhci_card_busy,
 	.send_cmd	= sdhci_send_command,
 	.set_ios	= sdhci_set_ios,
+	.execute_tuning = sdhci_execute_tuning,
 };
 #else
 static const struct mmc_ops sdhci_ops = {
+	.card_busy	= sdhci_card_busy,
 	.send_cmd	= sdhci_send_command,
 	.set_ios	= sdhci_set_ios,
 	.init		= sdhci_init,
+	.execute_tuning = sdhci_execute_tuning,
 };
 #endif
 
diff --git a/drivers/mmc/socfpga_dw_mmc.c b/drivers/mmc/socfpga_dw_mmc.c
index 759686ccd6..9ace505fe4 100644
--- a/drivers/mmc/socfpga_dw_mmc.c
+++ b/drivers/mmc/socfpga_dw_mmc.c
@@ -11,7 +11,7 @@
 #include <dwmmc.h>
 #include <errno.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <linux/err.h>
 #include <malloc.h>
 
diff --git a/drivers/mmc/uniphier-sd.c b/drivers/mmc/uniphier-sd.c
index e272b14153..7d582c2bf9 100644
--- a/drivers/mmc/uniphier-sd.c
+++ b/drivers/mmc/uniphier-sd.c
@@ -11,10 +11,10 @@
 #include <mmc.h>
 #include <dm.h>
 #include <linux/compat.h>
+#include <linux/dma-direction.h>
 #include <linux/io.h>
 #include <linux/sizes.h>
 #include <asm/unaligned.h>
-#include <asm/dma-mapping.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -532,7 +532,7 @@ static void uniphier_sd_set_ddr_mode(struct uniphier_sd_priv *priv,
 	u32 tmp;
 
 	tmp = readl(priv->regbase + UNIPHIER_SD_IF_MODE);
-	if (mmc->ddr_mode)
+	if (mmc_card_ddr(mmc))
 		tmp |= UNIPHIER_SD_IF_MODE_DDR;
 	else
 		tmp &= ~UNIPHIER_SD_IF_MODE_DDR;
@@ -599,7 +599,7 @@ static int uniphier_sd_set_ios(struct udevice *dev)
 	int ret;
 
 	dev_dbg(dev, "clock %uHz, DDRmode %d, width %u\n",
-		mmc->clock, mmc->ddr_mode, mmc->bus_width);
+		mmc->clock, mmc_card_ddr(mmc), mmc->bus_width);
 
 	ret = uniphier_sd_set_bus_width(priv, mmc);
 	if (ret)
diff --git a/drivers/mmc/xenon_sdhci.c b/drivers/mmc/xenon_sdhci.c
index 2b7cb7f6b6..f41e628222 100644
--- a/drivers/mmc/xenon_sdhci.c
+++ b/drivers/mmc/xenon_sdhci.c
@@ -18,7 +18,7 @@
 #include <common.h>
 #include <dm.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <sdhci.h>
 
@@ -94,18 +94,6 @@ DECLARE_GLOBAL_DATA_PTR;
 /* Hyperion only have one slot 0 */
 #define XENON_MMC_SLOT_ID_HYPERION		0
 
-#define MMC_TIMING_LEGACY	0
-#define MMC_TIMING_MMC_HS	1
-#define MMC_TIMING_SD_HS	2
-#define MMC_TIMING_UHS_SDR12	3
-#define MMC_TIMING_UHS_SDR25	4
-#define MMC_TIMING_UHS_SDR50	5
-#define MMC_TIMING_UHS_SDR104	6
-#define MMC_TIMING_UHS_DDR50	7
-#define MMC_TIMING_MMC_DDR52	8
-#define MMC_TIMING_MMC_HS200	9
-#define MMC_TIMING_MMC_HS400	10
-
 #define XENON_MMC_MAX_CLK	400000000
 
 enum soc_pad_ctrl_type {
@@ -159,7 +147,7 @@ static int xenon_mmc_phy_init(struct sdhci_host *host)
 	}
 
 	if (time <= 0) {
-		error("Failed to enable MMC internal clock in time\n");
+		pr_err("Failed to enable MMC internal clock in time\n");
 		return -ETIMEDOUT;
 	}
 
@@ -187,7 +175,7 @@ static int xenon_mmc_phy_init(struct sdhci_host *host)
 	}
 
 	if (time <= 0) {
-		error("Failed to init MMC PHY in time\n");
+		pr_err("Failed to init MMC PHY in time\n");
 		return -ETIMEDOUT;
 	}
 
@@ -249,7 +237,7 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 	sdhci_writew(host, var, SDHCI_CLOCK_CONTROL);
 
 	var = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
-	if (host->mmc->ddr_mode) {
+	if (mmc_card_ddr(host->mmc)) {
 		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) | CMD_DDR_MODE;
 	} else {
 		var &= ~((DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
@@ -330,7 +318,7 @@ static void xenon_mask_cmd_conflict_err(struct sdhci_host *host)
 static void xenon_sdhci_set_ios_post(struct sdhci_host *host)
 {
 	struct xenon_sdhci_priv *priv = host->mmc->priv;
-	uint speed = host->mmc->tran_speed;
+	uint speed = host->mmc->clock;
 	int pwr_18v = 0;
 
 	if ((sdhci_readb(host, SDHCI_POWER_CONTROL) & ~SDHCI_POWER_ON) ==
@@ -341,7 +329,7 @@ static void xenon_sdhci_set_ios_post(struct sdhci_host *host)
 	if (IS_SD(host->mmc)) {
 		/* SD/SDIO */
 		if (pwr_18v) {
-			if (host->mmc->ddr_mode)
+			if (mmc_card_ddr(host->mmc))
 				priv->timing = MMC_TIMING_UHS_DDR50;
 			else if (speed <= 25000000)
 				priv->timing = MMC_TIMING_UHS_SDR25;
@@ -355,7 +343,7 @@ static void xenon_sdhci_set_ios_post(struct sdhci_host *host)
 		}
 	} else {
 		/* eMMC */
-		if (host->mmc->ddr_mode)
+		if (mmc_card_ddr(host->mmc))
 			priv->timing = MMC_TIMING_MMC_DDR52;
 		else if (speed <= 26000000)
 			priv->timing = MMC_TIMING_LEGACY;
diff --git a/drivers/mmc/zynq_sdhci.c b/drivers/mmc/zynq_sdhci.c
index 0fddb420dc..4a5600f31f 100644
--- a/drivers/mmc/zynq_sdhci.c
+++ b/drivers/mmc/zynq_sdhci.c
@@ -10,7 +10,7 @@
 #include <common.h>
 #include <dm.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <sdhci.h>
 
diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index 19579801d2..321f8b2bd5 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -1,5 +1,8 @@
 menu "MTD Support"
 
+config MTD_PARTITIONS
+	bool
+
 config MTD
 	bool "Enable Driver Model for MTD drivers"
 	depends on DM
@@ -8,11 +11,40 @@ config MTD
 	  flash, RAM and similar chips, often used for solid state file
 	  systems on embedded devices.
 
+config MTD_BLK
+	bool "Enable mtd block model for MTD drivers"
+	depends on MTD
+	help
+	  Enable mtd block model for Memory Technology Devices (MTD).
+
+config MTD_WRITE
+	bool "support for nand & spi nand & spi nor write operations"
+	depends on MTD_BLK
+	default y
+	help
+	  Enable write access to nand & spi nand & spi nor
+
 config MTD_NOR_FLASH
 	bool "Enable parallel NOR flash support"
 	help
 	  Enable support for parallel NOR flash.
 
+config MTD_DEVICE
+	bool "Enable MTD Device for NAND and ONENAND devices"
+	help
+	  Adds the MTD device infrastructure from the Linux kernel.
+	  Needed for mtdparts command support.
+
+config FLASH_CFI_DRIVER
+	bool "Enable CFI Flash driver"
+	help
+	  The Common Flash Interface specification was developed by Intel,
+	  AMD and other flash manufactures. It provides a universal method
+	  for probing the capabilities of flash devices. If you wish to
+	  support any device that is CFI-compliant, you need to enable this
+	  option. Visit <http://www.amd.com/products/nvd/overview/cfi.html>
+	  for more information on CFI.
+
 config CFI_FLASH
 	bool "Enable Driver Model for CFI Flash driver"
 	depends on MTD
@@ -40,10 +72,17 @@ config FLASH_PIC32
 	  This enables access to Microchip PIC32 internal non-CFI flash
 	  chips through PIC32 Non-Volatile-Memory Controller.
 
-endmenu
+config RENESAS_RPC_HF
+	bool "Renesas RCar Gen3 RPC Hyperflash driver"
+	depends on RCAR_GEN3 && MTD
+	help
+	  This enables access to Hyperflash memory through the Renesas
+	  RCar Gen3 RPC controller.
 
 source "drivers/mtd/nand/Kconfig"
 
 source "drivers/mtd/spi/Kconfig"
 
 source "drivers/mtd/ubi/Kconfig"
+
+endmenu
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index bd680a784f..8fa594c3f0 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -5,20 +5,21 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-ifneq (,$(findstring y,$(CONFIG_MTD_DEVICE)$(CONFIG_CMD_NAND)$(CONFIG_CMD_ONENAND)$(CONFIG_CMD_SF)))
+ifneq (,$(findstring y,$(CONFIG_MTD_DEVICE)$(CONFIG_CMD_NAND)$(CONFIG_CMD_ONENAND)$(CONFIG_CMD_SF)$(CONFIG_CMD_MTD)))
 obj-y += mtdcore.o mtd_uboot.o
 endif
 obj-$(CONFIG_MTD) += mtd-uclass.o
+obj-$(CONFIG_MTD_BLK) += mtd_blk.o
 obj-$(CONFIG_MTD_PARTITIONS) += mtdpart.o
 obj-$(CONFIG_MTD_CONCAT) += mtdconcat.o
 obj-$(CONFIG_ALTERA_QSPI) += altera_qspi.o
-obj-$(CONFIG_HAS_DATAFLASH) += at45.o
 obj-$(CONFIG_FLASH_CFI_DRIVER) += cfi_flash.o
 obj-$(CONFIG_FLASH_CFI_MTD) += cfi_mtd.o
-obj-$(CONFIG_HAS_DATAFLASH) += dataflash.o
-obj-$(CONFIG_FTSMC020) += ftsmc020.o
 obj-$(CONFIG_FLASH_CFI_LEGACY) += jedec_flash.o
 obj-$(CONFIG_MW_EEPROM) += mw_eeprom.o
 obj-$(CONFIG_FLASH_PIC32) += pic32_flash.o
 obj-$(CONFIG_ST_SMI) += st_smi.o
 obj-$(CONFIG_STM32_FLASH) += stm32_flash.o
+obj-$(CONFIG_RENESAS_RPC_HF) += renesas_rpc_hf.o
+
+obj-y += nand/
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index f3bb72788a..e5509fe353 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -91,6 +91,8 @@ static u16 cfi_flash_config_reg(int i)
 
 #if defined(CONFIG_SYS_MAX_FLASH_BANKS_DETECT)
 int cfi_flash_num_flash_banks = CONFIG_SYS_MAX_FLASH_BANKS_DETECT;
+#else
+int cfi_flash_num_flash_banks;
 #endif
 
 #ifdef CONFIG_CFI_FLASH /* for driver model */
@@ -111,11 +113,9 @@ static void cfi_flash_init_dm(void)
 	}
 }
 
-static phys_addr_t cfi_flash_base[CFI_MAX_FLASH_BANKS];
-
 phys_addr_t cfi_flash_bank_addr(int i)
 {
-	return cfi_flash_base[i];
+	return flash_info[i].base;
 }
 #else
 __weak phys_addr_t cfi_flash_bank_addr(int i)
@@ -177,7 +177,8 @@ __maybe_weak u64 flash_read64(void *addr)
 
 /*-----------------------------------------------------------------------
  */
-#if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+#if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || \
+	(CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
 static flash_info_t *flash_get_info(ulong base)
 {
 	int i;
@@ -206,7 +207,7 @@ unsigned long flash_sector_size(flash_info_t *info, flash_sect_t sect)
  * create an address based on the offset and the port width
  */
 static inline void *
-flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
+flash_map(flash_info_t *info, flash_sect_t sect, uint offset)
 {
 	unsigned int byte_offset = offset * info->portwidth;
 
@@ -214,7 +215,7 @@ flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
 }
 
 static inline void flash_unmap(flash_info_t *info, flash_sect_t sect,
-		unsigned int offset, void *addr)
+			       unsigned int offset, void *addr)
 {
 }
 
@@ -232,14 +233,14 @@ static void flash_make_cmd(flash_info_t *info, u32 cmd, void *cmdbuf)
 	uchar val;
 	uchar *cp = (uchar *) cmdbuf;
 
-	for (i = info->portwidth; i > 0; i--){
-		cword_offset = (info->portwidth-i)%info->chipwidth;
+	for (i = info->portwidth; i > 0; i--) {
+		cword_offset = (info->portwidth - i) % info->chipwidth;
 #if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
 		cp_offset = info->portwidth - i;
-		val = *((uchar*)&cmd_le + cword_offset);
+		val = *((uchar *)&cmd_le + cword_offset);
 #else
 		cp_offset = i - 1;
-		val = *((uchar*)&cmd + sizeof(u32) - cword_offset - 1);
+		val = *((uchar *)&cmd + sizeof(u32) - cword_offset - 1);
 #endif
 		cp[cp_offset] = (cword_offset >= sizeof(u32)) ? 0x00 : val;
 	}
@@ -249,17 +250,17 @@ static void flash_make_cmd(flash_info_t *info, u32 cmd, void *cmdbuf)
 /*-----------------------------------------------------------------------
  * Debug support
  */
-static void print_longlong (char *str, unsigned long long data)
+static void print_longlong(char *str, unsigned long long data)
 {
 	int i;
 	char *cp;
 
-	cp = (char *) &data;
+	cp = (char *)&data;
 	for (i = 0; i < 8; i++)
-		sprintf (&str[i * 2], "%2.2x", *cp++);
+		sprintf(&str[i * 2], "%2.2x", *cp++);
 }
 
-static void flash_printqry (struct cfi_qry *qry)
+static void flash_printqry(struct cfi_qry *qry)
 {
 	u8 *p = (u8 *)qry;
 	int x, y;
@@ -271,6 +272,7 @@ static void flash_printqry (struct cfi_qry *qry)
 		debug(" ");
 		for (y = 0; y < 16; y++) {
 			unsigned char c = p[x + y];
+
 			if (c >= 0x20 && c <= 0x7e)
 				debug("%c", c);
 			else
@@ -281,44 +283,42 @@ static void flash_printqry (struct cfi_qry *qry)
 }
 #endif
 
-
 /*-----------------------------------------------------------------------
  * read a character at a port width address
  */
-static inline uchar flash_read_uchar (flash_info_t * info, uint offset)
+static inline uchar flash_read_uchar(flash_info_t *info, uint offset)
 {
 	uchar *cp;
 	uchar retval;
 
-	cp = flash_map (info, 0, offset);
+	cp = flash_map(info, 0, offset);
 #if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
 	retval = flash_read8(cp);
 #else
 	retval = flash_read8(cp + info->portwidth - 1);
 #endif
-	flash_unmap (info, 0, offset, cp);
+	flash_unmap(info, 0, offset, cp);
 	return retval;
 }
 
 /*-----------------------------------------------------------------------
  * read a word at a port width address, assume 16bit bus
  */
-static inline ushort flash_read_word (flash_info_t * info, uint offset)
+static inline ushort flash_read_word(flash_info_t *info, uint offset)
 {
 	ushort *addr, retval;
 
-	addr = flash_map (info, 0, offset);
-	retval = flash_read16 (addr);
-	flash_unmap (info, 0, offset, addr);
+	addr = flash_map(info, 0, offset);
+	retval = flash_read16(addr);
+	flash_unmap(info, 0, offset, addr);
 	return retval;
 }
 
-
 /*-----------------------------------------------------------------------
  * read a long word by picking the least significant byte of each maximum
  * port size word. Swap for ppc format.
  */
-static ulong flash_read_long (flash_info_t * info, flash_sect_t sect,
+static ulong flash_read_long (flash_info_t *info, flash_sect_t sect,
 			      uint offset)
 {
 	uchar *addr;
@@ -327,14 +327,13 @@ static ulong flash_read_long (flash_info_t * info, flash_sect_t sect,
 #ifdef DEBUG
 	int x;
 #endif
-	addr = flash_map (info, sect, offset);
+	addr = flash_map(info, sect, offset);
 
 #ifdef DEBUG
-	debug ("long addr is at %p info->portwidth = %d\n", addr,
-	       info->portwidth);
-	for (x = 0; x < 4 * info->portwidth; x++) {
-		debug ("addr[%x] = 0x%x\n", x, flash_read8(addr + x));
-	}
+	debug("long addr is at %p info->portwidth = %d\n", addr,
+	      info->portwidth);
+	for (x = 0; x < 4 * info->portwidth; x++)
+		debug("addr[%x] = 0x%x\n", x, flash_read8(addr + x));
 #endif
 #if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
 	retval = ((flash_read8(addr) << 16) |
@@ -358,28 +357,27 @@ static ulong flash_read_long (flash_info_t * info, flash_sect_t sect,
 static void flash_write_cmd(flash_info_t *info, flash_sect_t sect,
 			    uint offset, u32 cmd)
 {
-
 	void *addr;
 	cfiword_t cword;
 
-	addr = flash_map (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
+	addr = flash_map(info, sect, offset);
+	flash_make_cmd(info, cmd, &cword);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
-		debug ("fwc addr %p cmd %x %x 8bit x %d bit\n", addr, cmd,
-		       cword.w8, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		debug("fwc addr %p cmd %x %x 8bit x %d bit\n", addr, cmd,
+		      cword.w8, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 		flash_write8(cword.w8, addr);
 		break;
 	case FLASH_CFI_16BIT:
-		debug ("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr,
-		       cmd, cword.w16,
-		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		debug("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr,
+		      cmd, cword.w16,
+		      info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 		flash_write16(cword.w16, addr);
 		break;
 	case FLASH_CFI_32BIT:
-		debug ("fwc addr %p cmd %x %8.8x 32bit x %d bit\n", addr,
-		       cmd, cword.w32,
-		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		debug("fwc addr %p cmd %x %8.8x 32bit x %d bit\n", addr,
+		      cmd, cword.w32,
+		      info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 		flash_write32(cword.w32, addr);
 		break;
 	case FLASH_CFI_64BIT:
@@ -387,11 +385,11 @@ static void flash_write_cmd(flash_info_t *info, flash_sect_t sect,
 		{
 			char str[20];
 
-			print_longlong (str, cword.w64);
+			print_longlong(str, cword.w64);
 
-			debug ("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
-			       addr, cmd, str,
-			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+			debug("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
+			      addr, cmd, str,
+			      info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 		}
 #endif
 		flash_write64(cword.w64, addr);
@@ -404,36 +402,36 @@ static void flash_write_cmd(flash_info_t *info, flash_sect_t sect,
 	flash_unmap(info, sect, offset, addr);
 }
 
-static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
+static void flash_unlock_seq(flash_info_t *info, flash_sect_t sect)
 {
-	flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_UNLOCK_START);
-	flash_write_cmd (info, sect, info->addr_unlock2, AMD_CMD_UNLOCK_ACK);
+	flash_write_cmd(info, sect, info->addr_unlock1, AMD_CMD_UNLOCK_START);
+	flash_write_cmd(info, sect, info->addr_unlock2, AMD_CMD_UNLOCK_ACK);
 }
 
 /*-----------------------------------------------------------------------
  */
-static int flash_isequal (flash_info_t * info, flash_sect_t sect,
-			  uint offset, uchar cmd)
+static int flash_isequal(flash_info_t *info, flash_sect_t sect, uint offset,
+			 uchar cmd)
 {
 	void *addr;
 	cfiword_t cword;
 	int retval;
 
-	addr = flash_map (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
+	addr = flash_map(info, sect, offset);
+	flash_make_cmd(info, cmd, &cword);
 
-	debug ("is= cmd %x(%c) addr %p ", cmd, cmd, addr);
+	debug("is= cmd %x(%c) addr %p ", cmd, cmd, addr);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
-		debug ("is= %x %x\n", flash_read8(addr), cword.w8);
+		debug("is= %x %x\n", flash_read8(addr), cword.w8);
 		retval = (flash_read8(addr) == cword.w8);
 		break;
 	case FLASH_CFI_16BIT:
-		debug ("is= %4.4x %4.4x\n", flash_read16(addr), cword.w16);
+		debug("is= %4.4x %4.4x\n", flash_read16(addr), cword.w16);
 		retval = (flash_read16(addr) == cword.w16);
 		break;
 	case FLASH_CFI_32BIT:
-		debug ("is= %8.8x %8.8x\n", flash_read32(addr), cword.w32);
+		debug("is= %8.8x %8.8x\n", flash_read32(addr), cword.w32);
 		retval = (flash_read32(addr) == cword.w32);
 		break;
 	case FLASH_CFI_64BIT:
@@ -442,9 +440,9 @@ static int flash_isequal (flash_info_t * info, flash_sect_t sect,
 			char str1[20];
 			char str2[20];
 
-			print_longlong (str1, flash_read64(addr));
-			print_longlong (str2, cword.w64);
-			debug ("is= %s %s\n", str1, str2);
+			print_longlong(str1, flash_read64(addr));
+			print_longlong(str2, cword.w64);
+			debug("is= %s %s\n", str1, str2);
 		}
 #endif
 		retval = (flash_read64(addr) == cword.w64);
@@ -460,15 +458,15 @@ static int flash_isequal (flash_info_t * info, flash_sect_t sect,
 
 /*-----------------------------------------------------------------------
  */
-static int flash_isset (flash_info_t * info, flash_sect_t sect,
-			uint offset, uchar cmd)
+static int flash_isset(flash_info_t *info, flash_sect_t sect, uint offset,
+		       uchar cmd)
 {
 	void *addr;
 	cfiword_t cword;
 	int retval;
 
-	addr = flash_map (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
+	addr = flash_map(info, sect, offset);
+	flash_make_cmd(info, cmd, &cword);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
 		retval = ((flash_read8(addr) & cword.w8) == cword.w8);
@@ -493,15 +491,15 @@ static int flash_isset (flash_info_t * info, flash_sect_t sect,
 
 /*-----------------------------------------------------------------------
  */
-static int flash_toggle (flash_info_t * info, flash_sect_t sect,
-			 uint offset, uchar cmd)
+static int flash_toggle(flash_info_t *info, flash_sect_t sect, uint offset,
+			uchar cmd)
 {
-	void *addr;
+	u8 *addr;
 	cfiword_t cword;
 	int retval;
 
-	addr = flash_map (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
+	addr = flash_map(info, sect, offset);
+	flash_make_cmd(info, cmd, &cword);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
 		retval = flash_read8(addr) != flash_read8(addr);
@@ -513,8 +511,8 @@ static int flash_toggle (flash_info_t * info, flash_sect_t sect,
 		retval = flash_read32(addr) != flash_read32(addr);
 		break;
 	case FLASH_CFI_64BIT:
-		retval = ( (flash_read32( addr ) != flash_read32( addr )) ||
-			   (flash_read32(addr+4) != flash_read32(addr+4)) );
+		retval = ((flash_read32(addr) != flash_read32(addr)) ||
+			   (flash_read32(addr + 4) != flash_read32(addr + 4)));
 		break;
 	default:
 		retval = 0;
@@ -531,7 +529,7 @@ static int flash_toggle (flash_info_t * info, flash_sect_t sect,
  * This routine checks the status of the chip and returns true if the
  * chip is busy.
  */
-static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
+static int flash_is_busy(flash_info_t *info, flash_sect_t sect)
 {
 	int retval;
 
@@ -539,19 +537,28 @@ static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
 	case CFI_CMDSET_INTEL_PROG_REGIONS:
 	case CFI_CMDSET_INTEL_STANDARD:
 	case CFI_CMDSET_INTEL_EXTENDED:
-		retval = !flash_isset (info, sect, 0, FLASH_STATUS_DONE);
+		retval = !flash_isset(info, sect, 0, FLASH_STATUS_DONE);
 		break;
 	case CFI_CMDSET_AMD_STANDARD:
 	case CFI_CMDSET_AMD_EXTENDED:
 #ifdef CONFIG_FLASH_CFI_LEGACY
 	case CFI_CMDSET_AMD_LEGACY:
 #endif
-		retval = flash_toggle (info, sect, 0, AMD_STATUS_TOGGLE);
+		if (info->sr_supported) {
+			flash_write_cmd(info, sect, info->addr_unlock1,
+					FLASH_CMD_READ_STATUS);
+			retval = !flash_isset(info, sect, 0,
+					      FLASH_STATUS_DONE);
+		} else {
+			retval = flash_toggle(info, sect, 0,
+					      AMD_STATUS_TOGGLE);
+		}
+
 		break;
 	default:
 		retval = 0;
 	}
-	debug ("flash_is_busy: %d\n", retval);
+	debug("%s: %d\n", __func__, retval);
 	return retval;
 }
 
@@ -559,14 +566,15 @@ static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
  *  wait for XSR.7 to be set. Time out with an error if it does not.
  *  This routine does not set the flash to read-array mode.
  */
-static int flash_status_check (flash_info_t * info, flash_sect_t sector,
-			       ulong tout, char *prompt)
+static int flash_status_check(flash_info_t *info, flash_sect_t sector,
+			      ulong tout, char *prompt)
 {
 	ulong start;
 
 #if CONFIG_SYS_HZ != 1000
+	/* Avoid overflow for large HZ */
 	if ((ulong)CONFIG_SYS_HZ > 100000)
-		tout *= (ulong)CONFIG_SYS_HZ / 1000;  /* for a big HZ, avoid overflow */
+		tout *= (ulong)CONFIG_SYS_HZ / 1000;
 	else
 		tout = DIV_ROUND_UP(tout * (ulong)CONFIG_SYS_HZ, 1000);
 #endif
@@ -575,18 +583,18 @@ static int flash_status_check (flash_info_t * info, flash_sect_t sector,
 #ifdef CONFIG_SYS_LOW_RES_TIMER
 	reset_timer();
 #endif
-	start = get_timer (0);
+	start = get_timer(0);
 	WATCHDOG_RESET();
-	while (flash_is_busy (info, sector)) {
-		if (get_timer (start) > tout) {
-			printf ("Flash %s timeout at address %lx data %lx\n",
-				prompt, info->start[sector],
-				flash_read_long (info, sector, 0));
-			flash_write_cmd (info, sector, 0, info->cmd_reset);
+	while (flash_is_busy(info, sector)) {
+		if (get_timer(start) > tout) {
+			printf("Flash %s timeout at address %lx data %lx\n",
+			       prompt, info->start[sector],
+			       flash_read_long(info, sector, 0));
+			flash_write_cmd(info, sector, 0, info->cmd_reset);
 			udelay(1);
-			return ERR_TIMOUT;
+			return ERR_TIMEOUT;
 		}
-		udelay (1);		/* also triggers watchdog */
+		udelay(1);		/* also triggers watchdog */
 	}
 	return ERR_OK;
 }
@@ -597,40 +605,40 @@ static int flash_status_check (flash_info_t * info, flash_sect_t sector,
  *
  * This routine sets the flash to read-array mode.
  */
-static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
-				    ulong tout, char *prompt)
+static int flash_full_status_check(flash_info_t *info, flash_sect_t sector,
+				   ulong tout, char *prompt)
 {
 	int retcode;
 
-	retcode = flash_status_check (info, sector, tout, prompt);
+	retcode = flash_status_check(info, sector, tout, prompt);
 	switch (info->vendor) {
 	case CFI_CMDSET_INTEL_PROG_REGIONS:
 	case CFI_CMDSET_INTEL_EXTENDED:
 	case CFI_CMDSET_INTEL_STANDARD:
-		if ((retcode == ERR_OK)
-		    && !flash_isset(info, sector, 0, FLASH_STATUS_DONE)) {
+		if (retcode == ERR_OK &&
+		    !flash_isset(info, sector, 0, FLASH_STATUS_DONE)) {
 			retcode = ERR_INVAL;
-			printf ("Flash %s error at address %lx\n", prompt,
-				info->start[sector]);
-			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS |
+			printf("Flash %s error at address %lx\n", prompt,
+			       info->start[sector]);
+			if (flash_isset(info, sector, 0, FLASH_STATUS_ECLBS |
 					 FLASH_STATUS_PSLBS)) {
-				puts ("Command Sequence Error.\n");
-			} else if (flash_isset (info, sector, 0,
+				puts("Command Sequence Error.\n");
+			} else if (flash_isset(info, sector, 0,
 						FLASH_STATUS_ECLBS)) {
-				puts ("Block Erase Error.\n");
+				puts("Block Erase Error.\n");
 				retcode = ERR_NOT_ERASED;
-			} else if (flash_isset (info, sector, 0,
+			} else if (flash_isset(info, sector, 0,
 						FLASH_STATUS_PSLBS)) {
-				puts ("Locking Error\n");
+				puts("Locking Error\n");
 			}
-			if (flash_isset (info, sector, 0, FLASH_STATUS_DPS)) {
-				puts ("Block locked.\n");
+			if (flash_isset(info, sector, 0, FLASH_STATUS_DPS)) {
+				puts("Block locked.\n");
 				retcode = ERR_PROTECTED;
 			}
-			if (flash_isset (info, sector, 0, FLASH_STATUS_VPENS))
-				puts ("Vpp Low Error.\n");
+			if (flash_isset(info, sector, 0, FLASH_STATUS_VPENS))
+				puts("Vpp Low Error.\n");
 		}
-		flash_write_cmd (info, sector, 0, info->cmd_reset);
+		flash_write_cmd(info, sector, 0, info->cmd_reset);
 		udelay(1);
 		break;
 	default:
@@ -657,8 +665,9 @@ static int flash_status_poll(flash_info_t *info, void *src, void *dst,
 	int ready;
 
 #if CONFIG_SYS_HZ != 1000
+	/* Avoid overflow for large HZ */
 	if ((ulong)CONFIG_SYS_HZ > 100000)
-		tout *= (ulong)CONFIG_SYS_HZ / 1000;  /* for a big HZ, avoid overflow */
+		tout *= (ulong)CONFIG_SYS_HZ / 1000;
 	else
 		tout = DIV_ROUND_UP(tout * (ulong)CONFIG_SYS_HZ, 1000);
 #endif
@@ -692,7 +701,7 @@ static int flash_status_poll(flash_info_t *info, void *src, void *dst,
 		if (get_timer(start) > tout) {
 			printf("Flash %s timeout at address %lx data %lx\n",
 			       prompt, (ulong)dst, (ulong)flash_read8(dst));
-			return ERR_TIMOUT;
+			return ERR_TIMEOUT;
 		}
 		udelay(1);		/* also triggers watchdog */
 	}
@@ -702,7 +711,7 @@ static int flash_status_poll(flash_info_t *info, void *src, void *dst,
 
 /*-----------------------------------------------------------------------
  */
-static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
+static void flash_add_byte(flash_info_t *info, cfiword_t *cword, uchar c)
 {
 #if defined(__LITTLE_ENDIAN) && !defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
 	unsigned short	w;
@@ -748,17 +757,17 @@ static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
  * Loop through the sector table starting from the previously found sector.
  * Searches forwards or backwards, dependent on the passed address.
  */
-static flash_sect_t find_sector (flash_info_t * info, ulong addr)
+static flash_sect_t find_sector(flash_info_t *info, ulong addr)
 {
 	static flash_sect_t saved_sector; /* previously found sector */
 	static flash_info_t *saved_info; /* previously used flash bank */
 	flash_sect_t sector = saved_sector;
 
-	if ((info != saved_info) || (sector >= info->sector_count))
+	if (info != saved_info || sector >= info->sector_count)
 		sector = 0;
 
-	while ((info->start[sector] < addr)
-			&& (sector < info->sector_count - 1))
+	while ((sector < info->sector_count - 1) &&
+	       (info->start[sector] < addr))
 		sector++;
 	while ((info->start[sector] > addr) && (sector > 0))
 		/*
@@ -774,8 +783,7 @@ static flash_sect_t find_sector (flash_info_t * info, ulong addr)
 
 /*-----------------------------------------------------------------------
  */
-static int flash_write_cfiword (flash_info_t * info, ulong dest,
-				cfiword_t cword)
+static int flash_write_cfiword(flash_info_t *info, ulong dest, cfiword_t cword)
 {
 	void *dstaddr = (void *)dest;
 	int flag;
@@ -804,27 +812,27 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 		return ERR_NOT_ERASED;
 
 	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
+	flag = disable_interrupts();
 
 	switch (info->vendor) {
 	case CFI_CMDSET_INTEL_PROG_REGIONS:
 	case CFI_CMDSET_INTEL_EXTENDED:
 	case CFI_CMDSET_INTEL_STANDARD:
-		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
+		flash_write_cmd(info, 0, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd(info, 0, 0, FLASH_CMD_WRITE);
 		break;
 	case CFI_CMDSET_AMD_EXTENDED:
 	case CFI_CMDSET_AMD_STANDARD:
 		sect = find_sector(info, dest);
-		flash_unlock_seq (info, sect);
-		flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_WRITE);
+		flash_unlock_seq(info, sect);
+		flash_write_cmd(info, sect, info->addr_unlock1, AMD_CMD_WRITE);
 		sect_found = 1;
 		break;
 #ifdef CONFIG_FLASH_CFI_LEGACY
 	case CFI_CMDSET_AMD_LEGACY:
 		sect = find_sector(info, dest);
-		flash_unlock_seq (info, 0);
-		flash_write_cmd (info, 0, info->addr_unlock1, AMD_CMD_WRITE);
+		flash_unlock_seq(info, 0);
+		flash_write_cmd(info, 0, info->addr_unlock1, AMD_CMD_WRITE);
 		sect_found = 1;
 		break;
 #endif
@@ -847,10 +855,10 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 
 	/* re-enable interrupts if necessary */
 	if (flag)
-		enable_interrupts ();
+		enable_interrupts();
 
 	if (!sect_found)
-		sect = find_sector (info, dest);
+		sect = find_sector(info, dest);
 
 	if (use_flash_status_poll(info))
 		return flash_status_poll(info, &cword, dstaddr,
@@ -862,15 +870,15 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 
 #ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
 
-static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
-				  int len)
+static int flash_write_cfibuffer(flash_info_t *info, ulong dest, uchar *cp,
+				 int len)
 {
 	flash_sect_t sector;
 	int cnt;
 	int retcode;
-	void *src = cp;
-	void *dst = (void *)dest;
-	void *dst2 = dst;
+	u8 *src = cp;
+	u8 *dst = (u8 *)dest;
+	u8 *dst2 = dst;
 	int flag = 1;
 	uint offset = 0;
 	unsigned int shift;
@@ -926,25 +934,27 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 	}
 
 	src = cp;
-	sector = find_sector (info, dest);
+	sector = find_sector(info, dest);
 
 	switch (info->vendor) {
 	case CFI_CMDSET_INTEL_PROG_REGIONS:
 	case CFI_CMDSET_INTEL_STANDARD:
 	case CFI_CMDSET_INTEL_EXTENDED:
 		write_cmd = (info->vendor == CFI_CMDSET_INTEL_PROG_REGIONS) ?
-					FLASH_CMD_WRITE_BUFFER_PROG : FLASH_CMD_WRITE_TO_BUFFER;
-		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, sector, 0, FLASH_CMD_READ_STATUS);
-		flash_write_cmd (info, sector, 0, write_cmd);
-		retcode = flash_status_check (info, sector,
-					      info->buffer_write_tout,
-					      "write to buffer");
+			    FLASH_CMD_WRITE_BUFFER_PROG :
+			    FLASH_CMD_WRITE_TO_BUFFER;
+		flash_write_cmd(info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd(info, sector, 0, FLASH_CMD_READ_STATUS);
+		flash_write_cmd(info, sector, 0, write_cmd);
+		retcode = flash_status_check(info, sector,
+					     info->buffer_write_tout,
+					     "write to buffer");
 		if (retcode == ERR_OK) {
 			/* reduce the number of loops by the width of
-			 * the port */
+			 * the port
+			 */
 			cnt = len >> shift;
-			flash_write_cmd (info, sector, 0, cnt - 1);
+			flash_write_cmd(info, sector, 0, cnt - 1);
 			while (cnt-- > 0) {
 				switch (info->portwidth) {
 				case FLASH_CFI_8BIT:
@@ -968,9 +978,9 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 					goto out_unmap;
 				}
 			}
-			flash_write_cmd (info, sector, 0,
-					 FLASH_CMD_WRITE_BUFFER_CONFIRM);
-			retcode = flash_full_status_check (
+			flash_write_cmd(info, sector, 0,
+					FLASH_CMD_WRITE_BUFFER_CONFIRM);
+			retcode = flash_full_status_check(
 				info, sector, info->buffer_write_tout,
 				"buffer write");
 		}
@@ -1018,7 +1028,7 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 			goto out_unmap;
 		}
 
-		flash_write_cmd (info, sector, 0, AMD_CMD_WRITE_BUFFER_CONFIRM);
+		flash_write_cmd(info, sector, 0, AMD_CMD_WRITE_BUFFER_CONFIRM);
 		if (use_flash_status_poll(info))
 			retcode = flash_status_poll(info, src - (1 << shift),
 						    dst - (1 << shift),
@@ -1031,7 +1041,7 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 		break;
 
 	default:
-		debug ("Unknown Command Set\n");
+		debug("Unknown Command Set\n");
 		retcode = ERR_INVAL;
 		break;
 	}
@@ -1041,10 +1051,9 @@ out_unmap:
 }
 #endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
 
-
 /*-----------------------------------------------------------------------
  */
-int flash_erase (flash_info_t * info, int s_first, int s_last)
+int flash_erase(flash_info_t *info, int s_first, int s_last)
 {
 	int rcode = 0;
 	int prot;
@@ -1052,28 +1061,25 @@ int flash_erase (flash_info_t * info, int s_first, int s_last)
 	int st;
 
 	if (info->flash_id != FLASH_MAN_CFI) {
-		puts ("Can't erase unknown flash type - aborted\n");
+		puts("Can't erase unknown flash type - aborted\n");
 		return 1;
 	}
-	if ((s_first < 0) || (s_first > s_last)) {
-		puts ("- no sectors to erase\n");
+	if (s_first < 0 || s_first > s_last) {
+		puts("- no sectors to erase\n");
 		return 1;
 	}
 
 	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
+	for (sect = s_first; sect <= s_last; ++sect)
+		if (info->protect[sect])
 			prot++;
-		}
-	}
 	if (prot) {
-		printf ("- Warning: %d protected sectors will not be erased!\n",
-			prot);
+		printf("- Warning: %d protected sectors will not be erased!\n",
+		       prot);
 	} else if (flash_verbose) {
-		putc ('\n');
+		putc('\n');
 	}
 
-
 	for (sect = s_first; sect <= s_last; sect++) {
 		if (ctrlc()) {
 			printf("\n");
@@ -1111,60 +1117,64 @@ int flash_erase (flash_info_t * info, int s_first, int s_last)
 			case CFI_CMDSET_INTEL_PROG_REGIONS:
 			case CFI_CMDSET_INTEL_STANDARD:
 			case CFI_CMDSET_INTEL_EXTENDED:
-				flash_write_cmd (info, sect, 0,
-						 FLASH_CMD_CLEAR_STATUS);
-				flash_write_cmd (info, sect, 0,
-						 FLASH_CMD_BLOCK_ERASE);
-				flash_write_cmd (info, sect, 0,
-						 FLASH_CMD_ERASE_CONFIRM);
+				flash_write_cmd(info, sect, 0,
+						FLASH_CMD_CLEAR_STATUS);
+				flash_write_cmd(info, sect, 0,
+						FLASH_CMD_BLOCK_ERASE);
+				flash_write_cmd(info, sect, 0,
+						FLASH_CMD_ERASE_CONFIRM);
 				break;
 			case CFI_CMDSET_AMD_STANDARD:
 			case CFI_CMDSET_AMD_EXTENDED:
-				flash_unlock_seq (info, sect);
-				flash_write_cmd (info, sect,
+				flash_unlock_seq(info, sect);
+				flash_write_cmd(info, sect,
 						info->addr_unlock1,
 						AMD_CMD_ERASE_START);
-				flash_unlock_seq (info, sect);
-				flash_write_cmd (info, sect, 0,
-						 info->cmd_erase_sector);
+				flash_unlock_seq(info, sect);
+				flash_write_cmd(info, sect, 0,
+						info->cmd_erase_sector);
 				break;
 #ifdef CONFIG_FLASH_CFI_LEGACY
 			case CFI_CMDSET_AMD_LEGACY:
-				flash_unlock_seq (info, 0);
-				flash_write_cmd (info, 0, info->addr_unlock1,
+				flash_unlock_seq(info, 0);
+				flash_write_cmd(info, 0, info->addr_unlock1,
 						AMD_CMD_ERASE_START);
-				flash_unlock_seq (info, 0);
-				flash_write_cmd (info, sect, 0,
+				flash_unlock_seq(info, 0);
+				flash_write_cmd(info, sect, 0,
 						AMD_CMD_ERASE_SECTOR);
 				break;
 #endif
 			default:
-				debug ("Unkown flash vendor %d\n",
-				       info->vendor);
+				debug("Unknown flash vendor %d\n",
+				      info->vendor);
 				break;
 			}
 
 			if (use_flash_status_poll(info)) {
 				cfiword_t cword;
 				void *dest;
+
 				cword.w64 = 0xffffffffffffffffULL;
 				dest = flash_map(info, sect, 0);
 				st = flash_status_poll(info, &cword, dest,
-						       info->erase_blk_tout, "erase");
+						       info->erase_blk_tout,
+						       "erase");
 				flash_unmap(info, sect, 0, dest);
-			} else
+			} else {
 				st = flash_full_status_check(info, sect,
 							     info->erase_blk_tout,
 							     "erase");
+			}
+
 			if (st)
 				rcode = 1;
 			else if (flash_verbose)
-				putc ('.');
+				putc('.');
 		}
 	}
 
 	if (flash_verbose)
-		puts (" done\n");
+		puts(" done\n");
 
 	return rcode;
 }
@@ -1193,71 +1203,69 @@ static int sector_erased(flash_info_t *info, int i)
 }
 #endif /* CONFIG_SYS_FLASH_EMPTY_INFO */
 
-void flash_print_info (flash_info_t * info)
+void flash_print_info(flash_info_t *info)
 {
 	int i;
 
 	if (info->flash_id != FLASH_MAN_CFI) {
-		puts ("missing or unknown FLASH type\n");
+		puts("missing or unknown FLASH type\n");
 		return;
 	}
 
-	printf ("%s flash (%d x %d)",
-		info->name,
-		(info->portwidth << 3), (info->chipwidth << 3));
-	if (info->size < 1024*1024)
-		printf ("  Size: %ld kB in %d Sectors\n",
-			info->size >> 10, info->sector_count);
+	printf("%s flash (%d x %d)",
+	       info->name,
+	       (info->portwidth << 3), (info->chipwidth << 3));
+	if (info->size < 1024 * 1024)
+		printf("  Size: %ld kB in %d Sectors\n",
+		       info->size >> 10, info->sector_count);
 	else
-		printf ("  Size: %ld MB in %d Sectors\n",
-			info->size >> 20, info->sector_count);
-	printf ("  ");
+		printf("  Size: %ld MB in %d Sectors\n",
+		       info->size >> 20, info->sector_count);
+	printf("  ");
 	switch (info->vendor) {
-		case CFI_CMDSET_INTEL_PROG_REGIONS:
-			printf ("Intel Prog Regions");
-			break;
-		case CFI_CMDSET_INTEL_STANDARD:
-			printf ("Intel Standard");
-			break;
-		case CFI_CMDSET_INTEL_EXTENDED:
-			printf ("Intel Extended");
-			break;
-		case CFI_CMDSET_AMD_STANDARD:
-			printf ("AMD Standard");
-			break;
-		case CFI_CMDSET_AMD_EXTENDED:
-			printf ("AMD Extended");
-			break;
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
+		printf("Intel Prog Regions");
+		break;
+	case CFI_CMDSET_INTEL_STANDARD:
+		printf("Intel Standard");
+		break;
+	case CFI_CMDSET_INTEL_EXTENDED:
+		printf("Intel Extended");
+		break;
+	case CFI_CMDSET_AMD_STANDARD:
+		printf("AMD Standard");
+		break;
+	case CFI_CMDSET_AMD_EXTENDED:
+		printf("AMD Extended");
+		break;
 #ifdef CONFIG_FLASH_CFI_LEGACY
-		case CFI_CMDSET_AMD_LEGACY:
-			printf ("AMD Legacy");
-			break;
+	case CFI_CMDSET_AMD_LEGACY:
+		printf("AMD Legacy");
+		break;
 #endif
-		default:
-			printf ("Unknown (%d)", info->vendor);
-			break;
+	default:
+		printf("Unknown (%d)", info->vendor);
+		break;
 	}
-	printf (" command set, Manufacturer ID: 0x%02X, Device ID: 0x",
-		info->manufacturer_id);
-	printf (info->chipwidth == FLASH_CFI_16BIT ? "%04X" : "%02X",
-		info->device_id);
+	printf(" command set, Manufacturer ID: 0x%02X, Device ID: 0x",
+	       info->manufacturer_id);
+	printf(info->chipwidth == FLASH_CFI_16BIT ? "%04X" : "%02X",
+	       info->device_id);
 	if ((info->device_id & 0xff) == 0x7E) {
 		printf(info->chipwidth == FLASH_CFI_16BIT ? "%04X" : "%02X",
-		info->device_id2);
+		       info->device_id2);
 	}
-	if ((info->vendor == CFI_CMDSET_AMD_STANDARD) && (info->legacy_unlock))
+	if (info->vendor == CFI_CMDSET_AMD_STANDARD && info->legacy_unlock)
 		printf("\n  Advanced Sector Protection (PPB) enabled");
-	printf ("\n  Erase timeout: %ld ms, write timeout: %ld ms\n",
-		info->erase_blk_tout,
-		info->write_tout);
+	printf("\n  Erase timeout: %ld ms, write timeout: %ld ms\n",
+	       info->erase_blk_tout, info->write_tout);
 	if (info->buffer_size > 1) {
-		printf ("  Buffer write timeout: %ld ms, "
-			"buffer size: %d bytes\n",
-		info->buffer_write_tout,
-		info->buffer_size);
+		printf("  Buffer write timeout: %ld ms, ",
+		       info->buffer_write_tout);
+		printf("buffer size: %d bytes\n", info->buffer_size);
 	}
 
-	puts ("\n  Sector Start Addresses:");
+	puts("\n  Sector Start Addresses:");
 	for (i = 0; i < info->sector_count; ++i) {
 		if (ctrlc())
 			break;
@@ -1265,18 +1273,17 @@ void flash_print_info (flash_info_t * info)
 			putc('\n');
 #ifdef CONFIG_SYS_FLASH_EMPTY_INFO
 		/* print empty and read-only info */
-		printf ("  %08lX %c %s ",
-			info->start[i],
-			sector_erased(info, i) ? 'E' : ' ',
-			info->protect[i] ? "RO" : "  ");
+		printf("  %08lX %c %s ",
+		       info->start[i],
+		       sector_erased(info, i) ? 'E' : ' ',
+		       info->protect[i] ? "RO" : "  ");
 #else	/* ! CONFIG_SYS_FLASH_EMPTY_INFO */
-		printf ("  %08lX   %s ",
-			info->start[i],
-			info->protect[i] ? "RO" : "  ");
+		printf("  %08lX   %s ",
+		       info->start[i],
+		       info->protect[i] ? "RO" : "  ");
 #endif
 	}
-	putc ('\n');
-	return;
+	putc('\n');
 }
 
 /*-----------------------------------------------------------------------
@@ -1289,11 +1296,11 @@ void flash_print_info (flash_info_t * info)
 #define FLASH_SHOW_PROGRESS(scale, dots, digit, dots_sub) \
 	if (flash_verbose) { \
 		dots -= dots_sub; \
-		if ((scale > 0) && (dots <= 0)) { \
+		if (scale > 0 && dots <= 0) { \
 			if ((digit % 5) == 0) \
-				printf ("%d", digit / 5); \
+				printf("%d", digit / 5); \
 			else \
-				putc ('.'); \
+				putc('.'); \
 			digit--; \
 			dots += scale; \
 		} \
@@ -1308,7 +1315,7 @@ void flash_print_info (flash_info_t * info)
  * 1 - write timeout
  * 2 - Flash not erased
  */
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt)
 {
 	ulong wp;
 	uchar *p;
@@ -1336,20 +1343,21 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 	wp = (addr & ~(info->portwidth - 1));
 
 	/* handle unaligned start */
-	if ((aln = addr - wp) != 0) {
+	aln = addr - wp;
+	if (aln != 0) {
 		cword.w32 = 0;
 		p = (uchar *)wp;
 		for (i = 0; i < aln; ++i)
-			flash_add_byte (info, &cword, flash_read8(p + i));
+			flash_add_byte(info, &cword, flash_read8(p + i));
 
 		for (; (i < info->portwidth) && (cnt > 0); i++) {
-			flash_add_byte (info, &cword, *src++);
+			flash_add_byte(info, &cword, *src++);
 			cnt--;
 		}
 		for (; (cnt == 0) && (i < info->portwidth); ++i)
-			flash_add_byte (info, &cword, flash_read8(p + i));
+			flash_add_byte(info, &cword, flash_read8(p + i));
 
-		rc = flash_write_cfiword (info, wp, cword);
+		rc = flash_write_cfiword(info, wp, cword);
 		if (rc != 0)
 			return rc;
 
@@ -1366,8 +1374,9 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 		if (info->buffer_size == 1) {
 			cword.w32 = 0;
 			for (i = 0; i < info->portwidth; i++)
-				flash_add_byte (info, &cword, *src++);
-			if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+				flash_add_byte(info, &cword, *src++);
+			rc = flash_write_cfiword(info, wp, cword);
+			if (rc != 0)
 				return rc;
 			wp += info->portwidth;
 			cnt -= info->portwidth;
@@ -1378,7 +1387,8 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 		i = buffered_size - (wp % buffered_size);
 		if (i > cnt)
 			i = cnt;
-		if ((rc = flash_write_cfibuffer (info, wp, src, i)) != ERR_OK)
+		rc = flash_write_cfibuffer(info, wp, src, i);
+		if (rc != ERR_OK)
 			return rc;
 		i -= i & (info->portwidth - 1);
 		wp += i;
@@ -1392,10 +1402,10 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 #else
 	while (cnt >= info->portwidth) {
 		cword.w32 = 0;
-		for (i = 0; i < info->portwidth; i++) {
-			flash_add_byte (info, &cword, *src++);
-		}
-		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+		for (i = 0; i < info->portwidth; i++)
+			flash_add_byte(info, &cword, *src++);
+		rc = flash_write_cfiword(info, wp, cword);
+		if (rc != 0)
 			return rc;
 		wp += info->portwidth;
 		cnt -= info->portwidth;
@@ -1406,9 +1416,8 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 	}
 #endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
 
-	if (cnt == 0) {
+	if (cnt == 0)
 		return (0);
-	}
 
 	/*
 	 * handle unaligned tail bytes
@@ -1416,13 +1425,13 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 	cword.w32 = 0;
 	p = (uchar *)wp;
 	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
-		flash_add_byte (info, &cword, *src++);
+		flash_add_byte(info, &cword, *src++);
 		--cnt;
 	}
 	for (; i < info->portwidth; ++i)
-		flash_add_byte (info, &cword, flash_read8(p + i));
+		flash_add_byte(info, &cword, flash_read8(p + i));
 
-	return flash_write_cfiword (info, wp, cword);
+	return flash_write_cfiword(info, wp, cword);
 }
 
 static inline int manufact_match(flash_info_t *info, u32 manu)
@@ -1436,8 +1445,8 @@ static inline int manufact_match(flash_info_t *info, u32 manu)
 
 static int cfi_protect_bugfix(flash_info_t *info, long sector, int prot)
 {
-	if (manufact_match(info, INTEL_MANUFACT)
-	    && info->device_id == NUMONYX_256MBIT) {
+	if (manufact_match(info, INTEL_MANUFACT) &&
+	    info->device_id == NUMONYX_256MBIT) {
 		/*
 		 * see errata called
 		 * "Numonyx Axcell P33/P30 Specification Update" :)
@@ -1468,99 +1477,100 @@ static int cfi_protect_bugfix(flash_info_t *info, long sector, int prot)
 	return 0;
 }
 
-int flash_real_protect (flash_info_t * info, long sector, int prot)
+int flash_real_protect(flash_info_t *info, long sector, int prot)
 {
 	int retcode = 0;
 
 	switch (info->vendor) {
-		case CFI_CMDSET_INTEL_PROG_REGIONS:
-		case CFI_CMDSET_INTEL_STANDARD:
-		case CFI_CMDSET_INTEL_EXTENDED:
-			if (!cfi_protect_bugfix(info, sector, prot)) {
-				flash_write_cmd(info, sector, 0,
-					 FLASH_CMD_CLEAR_STATUS);
-				flash_write_cmd(info, sector, 0,
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
+	case CFI_CMDSET_INTEL_STANDARD:
+	case CFI_CMDSET_INTEL_EXTENDED:
+		if (!cfi_protect_bugfix(info, sector, prot)) {
+			flash_write_cmd(info, sector, 0,
+					FLASH_CMD_CLEAR_STATUS);
+			flash_write_cmd(info, sector, 0,
 					FLASH_CMD_PROTECT);
-				if (prot)
-					flash_write_cmd(info, sector, 0,
+			if (prot)
+				flash_write_cmd(info, sector, 0,
 						FLASH_CMD_PROTECT_SET);
-				else
-					flash_write_cmd(info, sector, 0,
+			else
+				flash_write_cmd(info, sector, 0,
 						FLASH_CMD_PROTECT_CLEAR);
-
-			}
-			break;
-		case CFI_CMDSET_AMD_EXTENDED:
-		case CFI_CMDSET_AMD_STANDARD:
-			/* U-Boot only checks the first byte */
-			if (manufact_match(info, ATM_MANUFACT)) {
-				if (prot) {
-					flash_unlock_seq (info, 0);
-					flash_write_cmd (info, 0,
-							info->addr_unlock1,
-							ATM_CMD_SOFTLOCK_START);
-					flash_unlock_seq (info, 0);
-					flash_write_cmd (info, sector, 0,
-							ATM_CMD_LOCK_SECT);
-				} else {
-					flash_write_cmd (info, 0,
-							info->addr_unlock1,
-							AMD_CMD_UNLOCK_START);
-					if (info->device_id == ATM_ID_BV6416)
-						flash_write_cmd (info, sector,
+		}
+		break;
+	case CFI_CMDSET_AMD_EXTENDED:
+	case CFI_CMDSET_AMD_STANDARD:
+		/* U-Boot only checks the first byte */
+		if (manufact_match(info, ATM_MANUFACT)) {
+			if (prot) {
+				flash_unlock_seq(info, 0);
+				flash_write_cmd(info, 0,
+						info->addr_unlock1,
+						ATM_CMD_SOFTLOCK_START);
+				flash_unlock_seq(info, 0);
+				flash_write_cmd(info, sector, 0,
+						ATM_CMD_LOCK_SECT);
+			} else {
+				flash_write_cmd(info, 0,
+						info->addr_unlock1,
+						AMD_CMD_UNLOCK_START);
+				if (info->device_id == ATM_ID_BV6416)
+					flash_write_cmd(info, sector,
 							0, ATM_CMD_UNLOCK_SECT);
-				}
 			}
-			if (info->legacy_unlock) {
-				int flag = disable_interrupts();
-				int lock_flag;
-
-				flash_unlock_seq(info, 0);
-				flash_write_cmd(info, 0, info->addr_unlock1,
-						AMD_CMD_SET_PPB_ENTRY);
-				lock_flag = flash_isset(info, sector, 0, 0x01);
-				if (prot) {
-					if (lock_flag) {
-						flash_write_cmd(info, sector, 0,
+		}
+		if (info->legacy_unlock) {
+			int flag = disable_interrupts();
+			int lock_flag;
+
+			flash_unlock_seq(info, 0);
+			flash_write_cmd(info, 0, info->addr_unlock1,
+					AMD_CMD_SET_PPB_ENTRY);
+			lock_flag = flash_isset(info, sector, 0, 0x01);
+			if (prot) {
+				if (lock_flag) {
+					flash_write_cmd(info, sector, 0,
 							AMD_CMD_PPB_LOCK_BC1);
-						flash_write_cmd(info, sector, 0,
+					flash_write_cmd(info, sector, 0,
 							AMD_CMD_PPB_LOCK_BC2);
-					}
-					debug("sector %ld %slocked\n", sector,
-						lock_flag ? "" : "already ");
-				} else {
-					if (!lock_flag) {
-						debug("unlock %ld\n", sector);
-						flash_write_cmd(info, 0, 0,
+				}
+				debug("sector %ld %slocked\n", sector,
+				      lock_flag ? "" : "already ");
+			} else {
+				if (!lock_flag) {
+					debug("unlock %ld\n", sector);
+					flash_write_cmd(info, 0, 0,
 							AMD_CMD_PPB_UNLOCK_BC1);
-						flash_write_cmd(info, 0, 0,
+					flash_write_cmd(info, 0, 0,
 							AMD_CMD_PPB_UNLOCK_BC2);
-					}
-					debug("sector %ld %sunlocked\n", sector,
-						!lock_flag ? "" : "already ");
 				}
-				if (flag)
-					enable_interrupts();
-
-				if (flash_status_check(info, sector,
-						info->erase_blk_tout,
-						prot ? "protect" : "unprotect"))
-					printf("status check error\n");
-
-				flash_write_cmd(info, 0, 0,
-						AMD_CMD_SET_PPB_EXIT_BC1);
-				flash_write_cmd(info, 0, 0,
-						AMD_CMD_SET_PPB_EXIT_BC2);
+				debug("sector %ld %sunlocked\n", sector,
+				      !lock_flag ? "" : "already ");
 			}
-			break;
+			if (flag)
+				enable_interrupts();
+
+			if (flash_status_check(info, sector,
+					       info->erase_blk_tout,
+					       prot ? "protect" : "unprotect"))
+				printf("status check error\n");
+
+			flash_write_cmd(info, 0, 0,
+					AMD_CMD_SET_PPB_EXIT_BC1);
+			flash_write_cmd(info, 0, 0,
+					AMD_CMD_SET_PPB_EXIT_BC2);
+		}
+		break;
 #ifdef CONFIG_FLASH_CFI_LEGACY
-		case CFI_CMDSET_AMD_LEGACY:
-			flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
-			flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT);
-			if (prot)
-				flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_SET);
-			else
-				flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_CLEAR);
+	case CFI_CMDSET_AMD_LEGACY:
+		flash_write_cmd(info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd(info, sector, 0, FLASH_CMD_PROTECT);
+		if (prot)
+			flash_write_cmd(info, sector, 0,
+					FLASH_CMD_PROTECT_SET);
+		else
+			flash_write_cmd(info, sector, 0,
+					FLASH_CMD_PROTECT_CLEAR);
 #endif
 	};
 
@@ -1569,22 +1579,21 @@ int flash_real_protect (flash_info_t * info, long sector, int prot)
 	 * flash_full_status_check() to work correctly
 	 */
 	flash_write_cmd(info, sector, 0, FLASH_CMD_READ_STATUS);
-	if ((retcode =
-	     flash_full_status_check (info, sector, info->erase_blk_tout,
-				      prot ? "protect" : "unprotect")) == 0) {
-
+	retcode = flash_full_status_check(info, sector, info->erase_blk_tout,
+					  prot ? "protect" : "unprotect");
+	if (retcode == 0) {
 		info->protect[sector] = prot;
 
 		/*
 		 * On some of Intel's flash chips (marked via legacy_unlock)
 		 * unprotect unprotects all locking.
 		 */
-		if ((prot == 0) && (info->legacy_unlock)) {
+		if (prot == 0 && info->legacy_unlock) {
 			flash_sect_t i;
 
 			for (i = 0; i < info->sector_count; i++) {
 				if (info->protect[i])
-					flash_real_protect (info, i, 1);
+					flash_real_protect(info, i, 1);
 			}
 		}
 	}
@@ -1594,17 +1603,17 @@ int flash_real_protect (flash_info_t * info, long sector, int prot)
 /*-----------------------------------------------------------------------
  * flash_read_user_serial - read the OneTimeProgramming cells
  */
-void flash_read_user_serial (flash_info_t * info, void *buffer, int offset,
-			     int len)
+void flash_read_user_serial(flash_info_t *info, void *buffer, int offset,
+			    int len)
 {
 	uchar *src;
 	uchar *dst;
 
 	dst = buffer;
-	src = flash_map (info, 0, FLASH_OFFSET_USER_PROTECTION);
-	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
-	memcpy (dst, src + offset, len);
-	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	src = flash_map(info, 0, FLASH_OFFSET_USER_PROTECTION);
+	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy(dst, src + offset, len);
+	flash_write_cmd(info, 0, 0, info->cmd_reset);
 	udelay(1);
 	flash_unmap(info, 0, FLASH_OFFSET_USER_PROTECTION, src);
 }
@@ -1612,15 +1621,15 @@ void flash_read_user_serial (flash_info_t * info, void *buffer, int offset,
 /*
  * flash_read_factory_serial - read the device Id from the protection area
  */
-void flash_read_factory_serial (flash_info_t * info, void *buffer, int offset,
-				int len)
+void flash_read_factory_serial(flash_info_t *info, void *buffer, int offset,
+			       int len)
 {
 	uchar *src;
 
-	src = flash_map (info, 0, FLASH_OFFSET_INTEL_PROTECTION);
-	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
-	memcpy (buffer, src + offset, len);
-	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	src = flash_map(info, 0, FLASH_OFFSET_INTEL_PROTECTION);
+	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy(buffer, src + offset, len);
+	flash_write_cmd(info, 0, 0, info->cmd_reset);
 	udelay(1);
 	flash_unmap(info, 0, FLASH_OFFSET_INTEL_PROTECTION, src);
 }
@@ -1638,10 +1647,10 @@ static void cfi_reverse_geometry(struct cfi_qry *qry)
 	u32 tmp;
 
 	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
-		tmp = get_unaligned(&(qry->erase_region_info[i]));
-		put_unaligned(get_unaligned(&(qry->erase_region_info[j])),
-			      &(qry->erase_region_info[i]));
-		put_unaligned(tmp, &(qry->erase_region_info[j]));
+		tmp = get_unaligned(&qry->erase_region_info[i]);
+		put_unaligned(get_unaligned(&qry->erase_region_info[j]),
+			      &qry->erase_region_info[i]);
+		put_unaligned(tmp, &qry->erase_region_info[j]);
 	}
 }
 
@@ -1657,11 +1666,11 @@ static void cmdset_intel_read_jedec_ids(flash_info_t *info)
 	udelay(1);
 	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
 	udelay(1000); /* some flash are slow to respond */
-	info->manufacturer_id = flash_read_uchar (info,
-					FLASH_OFFSET_MANUFACTURER_ID);
+	info->manufacturer_id = flash_read_uchar(info,
+						 FLASH_OFFSET_MANUFACTURER_ID);
 	info->device_id = (info->chipwidth == FLASH_CFI_16BIT) ?
-			flash_read_word (info, FLASH_OFFSET_DEVICE_ID) :
-			flash_read_uchar (info, FLASH_OFFSET_DEVICE_ID);
+			flash_read_word(info, FLASH_OFFSET_DEVICE_ID) :
+			flash_read_uchar(info, FLASH_OFFSET_DEVICE_ID);
 	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
 }
 
@@ -1675,8 +1684,8 @@ static int cmdset_intel_init(flash_info_t *info, struct cfi_qry *qry)
 #ifdef CONFIG_SYS_FLASH_PROTECTION
 	/* read legacy lock/unlock bit from intel flash */
 	if (info->ext_addr) {
-		info->legacy_unlock = flash_read_uchar (info,
-				info->ext_addr + 5) & 0x08;
+		info->legacy_unlock =
+			flash_read_uchar(info, info->ext_addr + 5) & 0x08;
 	}
 #endif
 
@@ -1685,45 +1694,55 @@ static int cmdset_intel_init(flash_info_t *info, struct cfi_qry *qry)
 
 static void cmdset_amd_read_jedec_ids(flash_info_t *info)
 {
-	ushort bankId = 0;
-	uchar  manuId;
+	ushort bank_id = 0;
+	uchar  manu_id;
+	uchar  feature;
 
 	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
 	flash_unlock_seq(info, 0);
 	flash_write_cmd(info, 0, info->addr_unlock1, FLASH_CMD_READ_ID);
 	udelay(1000); /* some flash are slow to respond */
 
-	manuId = flash_read_uchar (info, FLASH_OFFSET_MANUFACTURER_ID);
+	manu_id = flash_read_uchar(info, FLASH_OFFSET_MANUFACTURER_ID);
 	/* JEDEC JEP106Z specifies ID codes up to bank 7 */
-	while (manuId == FLASH_CONTINUATION_CODE && bankId < 0x800) {
-		bankId += 0x100;
-		manuId = flash_read_uchar (info,
-			bankId | FLASH_OFFSET_MANUFACTURER_ID);
+	while (manu_id == FLASH_CONTINUATION_CODE && bank_id < 0x800) {
+		bank_id += 0x100;
+		manu_id = flash_read_uchar(info,
+					   bank_id | FLASH_OFFSET_MANUFACTURER_ID);
+	}
+	info->manufacturer_id = manu_id;
+
+	debug("info->ext_addr = 0x%x, cfi_version = 0x%x\n",
+	      info->ext_addr, info->cfi_version);
+	if (info->ext_addr && info->cfi_version >= 0x3134) {
+		/* read software feature (at 0x53) */
+		feature = flash_read_uchar(info, info->ext_addr + 0x13);
+		debug("feature = 0x%x\n", feature);
+		info->sr_supported = feature & 0x1;
 	}
-	info->manufacturer_id = manuId;
 
-	switch (info->chipwidth){
+	switch (info->chipwidth) {
 	case FLASH_CFI_8BIT:
-		info->device_id = flash_read_uchar (info,
-						FLASH_OFFSET_DEVICE_ID);
+		info->device_id = flash_read_uchar(info,
+						   FLASH_OFFSET_DEVICE_ID);
 		if (info->device_id == 0x7E) {
 			/* AMD 3-byte (expanded) device ids */
-			info->device_id2 = flash_read_uchar (info,
-						FLASH_OFFSET_DEVICE_ID2);
+			info->device_id2 = flash_read_uchar(info,
+							    FLASH_OFFSET_DEVICE_ID2);
 			info->device_id2 <<= 8;
-			info->device_id2 |= flash_read_uchar (info,
+			info->device_id2 |= flash_read_uchar(info,
 						FLASH_OFFSET_DEVICE_ID3);
 		}
 		break;
 	case FLASH_CFI_16BIT:
-		info->device_id = flash_read_word (info,
-						FLASH_OFFSET_DEVICE_ID);
+		info->device_id = flash_read_word(info,
+						  FLASH_OFFSET_DEVICE_ID);
 		if ((info->device_id & 0xff) == 0x7E) {
 			/* AMD 3-byte (expanded) device ids */
-			info->device_id2 = flash_read_uchar (info,
-						FLASH_OFFSET_DEVICE_ID2);
+			info->device_id2 = flash_read_uchar(info,
+							    FLASH_OFFSET_DEVICE_ID2);
 			info->device_id2 <<= 8;
-			info->device_id2 |= flash_read_uchar (info,
+			info->device_id2 |= flash_read_uchar(info,
 						FLASH_OFFSET_DEVICE_ID3);
 		}
 		break;
@@ -1754,7 +1773,7 @@ static int cmdset_amd_init(flash_info_t *info, struct cfi_qry *qry)
 }
 
 #ifdef CONFIG_FLASH_CFI_LEGACY
-static void flash_read_jedec_ids (flash_info_t * info)
+static void flash_read_jedec_ids(flash_info_t *info)
 {
 	info->manufacturer_id = 0;
 	info->device_id       = 0;
@@ -1786,7 +1805,8 @@ static int flash_detect_legacy(phys_addr_t base, int banknum)
 
 	if (board_flash_get_legacy(base, banknum, info)) {
 		/* board code may have filled info completely. If not, we
-		   use JEDEC ID probing. */
+		 * use JEDEC ID probing.
+		 */
 		if (!info->vendor) {
 			int modes[] = {
 				CFI_CMDSET_AMD_STANDARD,
@@ -1800,8 +1820,8 @@ static int flash_detect_legacy(phys_addr_t base, int banknum)
 					(ulong)map_physmem(base,
 							   info->portwidth,
 							   MAP_NOCACHE);
-				if (info->portwidth == FLASH_CFI_8BIT
-					&& info->interface == FLASH_CFI_X8X16) {
+				if (info->portwidth == FLASH_CFI_8BIT &&
+				    info->interface == FLASH_CFI_X8X16) {
 					info->addr_unlock1 = 0x2AAA;
 					info->addr_unlock2 = 0x5555;
 				} else {
@@ -1810,18 +1830,18 @@ static int flash_detect_legacy(phys_addr_t base, int banknum)
 				}
 				flash_read_jedec_ids(info);
 				debug("JEDEC PROBE: ID %x %x %x\n",
-						info->manufacturer_id,
-						info->device_id,
-						info->device_id2);
+				      info->manufacturer_id,
+				      info->device_id,
+				      info->device_id2);
 				if (jedec_flash_match(info, info->start[0]))
 					break;
-				else
-					unmap_physmem((void *)info->start[0],
-						      info->portwidth);
+
+				unmap_physmem((void *)info->start[0],
+					      info->portwidth);
 			}
 		}
 
-		switch(info->vendor) {
+		switch (info->vendor) {
 		case CFI_CMDSET_INTEL_PROG_REGIONS:
 		case CFI_CMDSET_INTEL_STANDARD:
 		case CFI_CMDSET_INTEL_EXTENDED:
@@ -1849,8 +1869,8 @@ static inline int flash_detect_legacy(phys_addr_t base, int banknum)
  * detect if flash is compatible with the Common Flash Interface (CFI)
  * http://www.jedec.org/download/search/jesd68.pdf
  */
-static void flash_read_cfi (flash_info_t *info, void *buf,
-		unsigned int start, size_t len)
+static void flash_read_cfi(flash_info_t *info, void *buf, unsigned int start,
+			   size_t len)
 {
 	u8 *p = buf;
 	unsigned int i;
@@ -1870,10 +1890,11 @@ static void __flash_cmd_reset(flash_info_t *info)
 	udelay(1);
 	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
 }
+
 void flash_cmd_reset(flash_info_t *info)
-	__attribute__((weak,alias("__flash_cmd_reset")));
+	__attribute__((weak, alias("__flash_cmd_reset")));
 
-static int __flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
+static int __flash_detect_cfi(flash_info_t *info, struct cfi_qry *qry)
 {
 	int cfi_offset;
 
@@ -1882,23 +1903,23 @@ static int __flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
 
 	for (cfi_offset = 0; cfi_offset < ARRAY_SIZE(flash_offset_cfi);
 	     cfi_offset++) {
-		flash_write_cmd (info, 0, flash_offset_cfi[cfi_offset],
-				 FLASH_CMD_CFI);
-		if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
-		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
-		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
+		flash_write_cmd(info, 0, flash_offset_cfi[cfi_offset],
+				FLASH_CMD_CFI);
+		if (flash_isequal(info, 0, FLASH_OFFSET_CFI_RESP, 'Q') &&
+		    flash_isequal(info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R') &&
+		    flash_isequal(info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
 			flash_read_cfi(info, qry, FLASH_OFFSET_CFI_RESP,
-					sizeof(struct cfi_qry));
+				       sizeof(struct cfi_qry));
 			info->interface	= le16_to_cpu(qry->interface_desc);
 
 			info->cfi_offset = flash_offset_cfi[cfi_offset];
-			debug ("device interface is %d\n",
-			       info->interface);
-			debug ("found port %d chip %d ",
-			       info->portwidth, info->chipwidth);
-			debug ("port %d bits chip %d bits\n",
-			       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
-			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+			debug("device interface is %d\n",
+			      info->interface);
+			debug("found port %d chip %d ",
+			      info->portwidth, info->chipwidth);
+			debug("port %d bits chip %d bits\n",
+			      info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+			      info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 
 			/* calculate command offsets as in the Linux driver */
 			info->addr_unlock1 = 0x555;
@@ -1908,13 +1929,12 @@ static int __flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
 			 * modify the unlock address if we are
 			 * in compatibility mode
 			 */
-			if (	/* x8/x16 in x8 mode */
-				((info->chipwidth == FLASH_CFI_BY8) &&
-					(info->interface == FLASH_CFI_X8X16)) ||
-				/* x16/x32 in x16 mode */
-				((info->chipwidth == FLASH_CFI_BY16) &&
-					(info->interface == FLASH_CFI_X16X32)))
-			{
+			if (/* x8/x16 in x8 mode */
+			    (info->chipwidth == FLASH_CFI_BY8 &&
+				info->interface == FLASH_CFI_X8X16) ||
+			    /* x16/x32 in x16 mode */
+			    (info->chipwidth == FLASH_CFI_BY16 &&
+				info->interface == FLASH_CFI_X16X32)) {
 				info->addr_unlock1 = 0xaaa;
 				info->addr_unlock2 = 0x555;
 			}
@@ -1927,9 +1947,9 @@ static int __flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
 	return 0;
 }
 
-static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
+static int flash_detect_cfi(flash_info_t *info, struct cfi_qry *qry)
 {
-	debug ("flash detect cfi\n");
+	debug("flash detect cfi\n");
 
 	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
 	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
@@ -1939,7 +1959,7 @@ static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
 			if (__flash_detect_cfi(info, qry))
 				return 1;
 	}
-	debug ("not found\n");
+	debug("not found\n");
 	return 0;
 }
 
@@ -2018,7 +2038,7 @@ static void flash_fixup_sst(flash_info_t *info, struct cfi_qry *qry)
 	if (info->device_id == 0x5D23 || /* SST39VF3201B */
 	    info->device_id == 0x5C23) { /* SST39VF3202B */
 		/* set sector granularity to 4KB */
-		info->cmd_erase_sector=0x50;
+		info->cmd_erase_sector = 0x50;
 	}
 }
 
@@ -2030,14 +2050,14 @@ static void flash_fixup_num(flash_info_t *info, struct cfi_qry *qry)
 	 * There's an app note from Numonyx on this issue.
 	 * So adjust the buffer size for M29EW while operating in 8-bit mode
 	 */
-	if (((qry->max_buf_write_size) > 0x8) &&
-			(info->device_id == 0x7E) &&
-			(info->device_id2 == 0x2201 ||
-			info->device_id2 == 0x2301 ||
-			info->device_id2 == 0x2801 ||
-			info->device_id2 == 0x4801)) {
-		debug("Adjusted buffer size on Numonyx flash"
-			" M29EW family in 8 bit mode\n");
+	if (qry->max_buf_write_size > 0x8 &&
+	    info->device_id == 0x7E &&
+	    (info->device_id2 == 0x2201 ||
+	     info->device_id2 == 0x2301 ||
+	     info->device_id2 == 0x2801 ||
+	     info->device_id2 == 0x4801)) {
+		debug("Adjusted buffer size on Numonyx flash");
+		debug(" M29EW family in 8 bit mode\n");
 		qry->max_buf_write_size = 0x8;
 	}
 }
@@ -2046,7 +2066,7 @@ static void flash_fixup_num(flash_info_t *info, struct cfi_qry *qry)
  * The following code cannot be run from FLASH!
  *
  */
-ulong flash_get_size (phys_addr_t base, int banknum)
+ulong flash_get_size(phys_addr_t base, int banknum)
 {
 	flash_info_t *info = &flash_info[banknum];
 	int i, j;
@@ -2070,20 +2090,20 @@ ulong flash_get_size (phys_addr_t base, int banknum)
 
 	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);
 
-	if (flash_detect_cfi (info, &qry)) {
-		info->vendor = le16_to_cpu(get_unaligned(&(qry.p_id)));
-		info->ext_addr = le16_to_cpu(get_unaligned(&(qry.p_adr)));
+	if (flash_detect_cfi(info, &qry)) {
+		info->vendor = le16_to_cpu(get_unaligned(&qry.p_id));
+		info->ext_addr = le16_to_cpu(get_unaligned(&qry.p_adr));
 		num_erase_regions = qry.num_erase_regions;
 
 		if (info->ext_addr) {
-			info->cfi_version = (ushort) flash_read_uchar (info,
+			info->cfi_version = (ushort)flash_read_uchar(info,
 						info->ext_addr + 3) << 8;
-			info->cfi_version |= (ushort) flash_read_uchar (info,
+			info->cfi_version |= (ushort)flash_read_uchar(info,
 						info->ext_addr + 4);
 		}
 
 #ifdef DEBUG
-		flash_printqry (&qry);
+		flash_printqry(&qry);
 #endif
 
 		switch (info->vendor) {
@@ -2098,7 +2118,7 @@ ulong flash_get_size (phys_addr_t base, int banknum)
 			break;
 		default:
 			printf("CFI: Unknown command set 0x%x\n",
-					info->vendor);
+			       info->vendor);
 			/*
 			 * Unfortunately, this means we don't know how
 			 * to get the chip back to Read mode. Might
@@ -2128,49 +2148,49 @@ ulong flash_get_size (phys_addr_t base, int banknum)
 			break;
 		}
 
-		debug ("manufacturer is %d\n", info->vendor);
-		debug ("manufacturer id is 0x%x\n", info->manufacturer_id);
-		debug ("device id is 0x%x\n", info->device_id);
-		debug ("device id2 is 0x%x\n", info->device_id2);
-		debug ("cfi version is 0x%04x\n", info->cfi_version);
+		debug("manufacturer is %d\n", info->vendor);
+		debug("manufacturer id is 0x%x\n", info->manufacturer_id);
+		debug("device id is 0x%x\n", info->device_id);
+		debug("device id2 is 0x%x\n", info->device_id2);
+		debug("cfi version is 0x%04x\n", info->cfi_version);
 
 		size_ratio = info->portwidth / info->chipwidth;
 		/* if the chip is x8/x16 reduce the ratio by half */
-		if ((info->interface == FLASH_CFI_X8X16)
-		    && (info->chipwidth == FLASH_CFI_BY8)) {
+		if (info->interface == FLASH_CFI_X8X16 &&
+		    info->chipwidth == FLASH_CFI_BY8) {
 			size_ratio >>= 1;
 		}
-		debug ("size_ratio %d port %d bits chip %d bits\n",
-		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
-		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		debug("size_ratio %d port %d bits chip %d bits\n",
+		      size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+		      info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 		info->size = 1 << qry.dev_size;
 		/* multiply the size by the number of chips */
 		info->size *= size_ratio;
 		max_size = cfi_flash_bank_size(banknum);
-		if (max_size && (info->size > max_size)) {
+		if (max_size && info->size > max_size) {
 			debug("[truncated from %ldMiB]", info->size >> 20);
 			info->size = max_size;
 		}
-		debug ("found %d erase regions\n", num_erase_regions);
+		debug("found %d erase regions\n", num_erase_regions);
 		sect_cnt = 0;
 		sector = base;
 		for (i = 0; i < num_erase_regions; i++) {
 			if (i > NUM_ERASE_REGIONS) {
-				printf ("%d erase regions found, only %d used\n",
-					num_erase_regions, NUM_ERASE_REGIONS);
+				printf("%d erase regions found, only %d used\n",
+				       num_erase_regions, NUM_ERASE_REGIONS);
 				break;
 			}
 
 			tmp = le32_to_cpu(get_unaligned(
-						&(qry.erase_region_info[i])));
+						&qry.erase_region_info[i]));
 			debug("erase region %u: 0x%08lx\n", i, tmp);
 
 			erase_region_count = (tmp & 0xffff) + 1;
 			tmp >>= 16;
 			erase_region_size =
 				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
-			debug ("erase_region_count = %d erase_region_size = %d\n",
-				erase_region_count, erase_region_size);
+			debug("erase_region_count = %d ", erase_region_count);
+			debug("erase_region_size = %d\n", erase_region_size);
 			for (j = 0; j < erase_region_count; j++) {
 				if (sector - base >= info->size)
 					break;
@@ -2200,9 +2220,9 @@ ulong flash_get_size (phys_addr_t base, int banknum)
 					flash_write_cmd(info, sect_cnt, 0,
 							FLASH_CMD_READ_ID);
 					info->protect[sect_cnt] =
-						flash_isset (info, sect_cnt,
-							     FLASH_OFFSET_PROTECT,
-							     FLASH_STATUS_PROTECT);
+						flash_isset(info, sect_cnt,
+							    FLASH_OFFSET_PROTECT,
+							    FLASH_STATUS_PROTECT);
 					flash_write_cmd(info, sect_cnt, 0,
 							FLASH_CMD_RESET);
 					break;
@@ -2251,13 +2271,13 @@ ulong flash_get_size (phys_addr_t base, int banknum)
 		/* round up when converting to ms */
 		info->write_tout = (tmp + 999) / 1000;
 		info->flash_id = FLASH_MAN_CFI;
-		if ((info->interface == FLASH_CFI_X8X16) &&
-		    (info->chipwidth == FLASH_CFI_BY8)) {
+		if (info->interface == FLASH_CFI_X8X16 &&
+		    info->chipwidth == FLASH_CFI_BY8) {
 			/* XXX - Need to test on x8/x16 in parallel. */
 			info->portwidth >>= 1;
 		}
 
-		flash_write_cmd (info, 0, 0, info->cmd_reset);
+		flash_write_cmd(info, 0, 0, info->cmd_reset);
 	}
 
 	return (info->size);
@@ -2312,25 +2332,25 @@ static void flash_protect_default(void)
 #if (CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE) && \
 	(!defined(CONFIG_MONITOR_IS_IN_RAM))
 	flash_protect(FLAG_PROTECT_SET,
-		       CONFIG_SYS_MONITOR_BASE,
-		       CONFIG_SYS_MONITOR_BASE + monitor_flash_len  - 1,
-		       flash_get_info(CONFIG_SYS_MONITOR_BASE));
+		      CONFIG_SYS_MONITOR_BASE,
+		      CONFIG_SYS_MONITOR_BASE + monitor_flash_len  - 1,
+		      flash_get_info(CONFIG_SYS_MONITOR_BASE));
 #endif
 
 	/* Environment protection ON by default */
 #ifdef CONFIG_ENV_IS_IN_FLASH
 	flash_protect(FLAG_PROTECT_SET,
-		       CONFIG_ENV_ADDR,
-		       CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
-		       flash_get_info(CONFIG_ENV_ADDR));
+		      CONFIG_ENV_ADDR,
+		      CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
+		      flash_get_info(CONFIG_ENV_ADDR));
 #endif
 
 	/* Redundant environment protection ON by default */
 #ifdef CONFIG_ENV_ADDR_REDUND
 	flash_protect(FLAG_PROTECT_SET,
-		       CONFIG_ENV_ADDR_REDUND,
-		       CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SECT_SIZE - 1,
-		       flash_get_info(CONFIG_ENV_ADDR_REDUND));
+		      CONFIG_ENV_ADDR_REDUND,
+		      CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SECT_SIZE - 1,
+		      flash_get_info(CONFIG_ENV_ADDR_REDUND));
 #endif
 
 #if defined(CONFIG_SYS_FLASH_AUTOPROTECT_LIST)
@@ -2338,14 +2358,14 @@ static void flash_protect_default(void)
 		debug("autoprotecting from %08lx to %08lx\n",
 		      apl[i].start, apl[i].start + apl[i].size - 1);
 		flash_protect(FLAG_PROTECT_SET,
-			       apl[i].start,
-			       apl[i].start + apl[i].size - 1,
-			       flash_get_info(apl[i].start));
+			      apl[i].start,
+			      apl[i].start + apl[i].size - 1,
+			      flash_get_info(apl[i].start));
 	}
 #endif
 }
 
-unsigned long flash_init (void)
+unsigned long flash_init(void)
 {
 	unsigned long size = 0;
 	int i;
@@ -2353,6 +2373,7 @@ unsigned long flash_init (void)
 #ifdef CONFIG_SYS_FLASH_PROTECTION
 	/* read environment from EEPROM */
 	char s[64];
+
 	env_get_f("unlock", s, sizeof(s));
 #endif
 
@@ -2373,10 +2394,10 @@ unsigned long flash_init (void)
 		size += flash_info[i].size;
 		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
 #ifndef CONFIG_SYS_FLASH_QUIET_TEST
-			printf ("## Unknown flash on Bank %d "
-				"- Size = 0x%08lx = %ld MB\n",
-				i+1, flash_info[i].size,
-				flash_info[i].size >> 20);
+			printf("## Unknown flash on Bank %d ", i + 1);
+			printf("- Size = 0x%08lx = %ld MB\n",
+			       flash_info[i].size,
+			       flash_info[i].size >> 20);
 #endif /* CONFIG_SYS_FLASH_QUIET_TEST */
 		}
 #ifdef CONFIG_SYS_FLASH_PROTECTION
@@ -2405,7 +2426,7 @@ unsigned long flash_init (void)
 				 * unlock only one sector. This will
 				 * unlock all sectors.
 				 */
-				flash_real_protect (&flash_info[i], 0, 0);
+				flash_real_protect(&flash_info[i], 0, 0);
 
 				flash_info[i].legacy_unlock = 1;
 
@@ -2419,11 +2440,11 @@ unsigned long flash_init (void)
 				/*
 				 * No legancy unlocking -> unlock all sectors
 				 */
-				flash_protect (FLAG_PROTECT_CLEAR,
-					       flash_info[i].start[0],
-					       flash_info[i].start[0]
-					       + flash_info[i].size - 1,
-					       &flash_info[i]);
+				flash_protect(FLAG_PROTECT_CLEAR,
+					      flash_info[i].start[0],
+					      flash_info[i].start[0]
+					      + flash_info[i].size - 1,
+					      &flash_info[i]);
 			}
 		}
 #endif /* CONFIG_SYS_FLASH_PROTECTION */
@@ -2440,28 +2461,31 @@ unsigned long flash_init (void)
 #ifdef CONFIG_CFI_FLASH /* for driver model */
 static int cfi_flash_probe(struct udevice *dev)
 {
-	void *blob = (void *)gd->fdt_blob;
-	int node = dev_of_offset(dev);
 	const fdt32_t *cell;
-	phys_addr_t addr;
-	int parent, addrc, sizec;
+	int addrc, sizec;
 	int len, idx;
 
-	parent = fdt_parent_offset(blob, node);
-	fdt_support_default_count_cells(blob, parent, &addrc, &sizec);
-	/* decode regs, there may be multiple reg tuples. */
-	cell = fdt_getprop(blob, node, "reg", &len);
+	addrc = dev_read_addr_cells(dev);
+	sizec = dev_read_size_cells(dev);
+
+	/* decode regs; there may be multiple reg tuples. */
+	cell = dev_read_prop(dev, "reg", &len);
 	if (!cell)
 		return -ENOENT;
 	idx = 0;
 	len /= sizeof(fdt32_t);
 	while (idx < len) {
-		addr = fdt_translate_address((void *)blob,
-					     node, cell + idx);
-		cfi_flash_base[cfi_flash_num_flash_banks++] = addr;
+		phys_addr_t addr;
+
+		addr = dev_translate_address(dev, cell + idx);
+
+		flash_info[cfi_flash_num_flash_banks].dev = dev;
+		flash_info[cfi_flash_num_flash_banks].base = addr;
+		cfi_flash_num_flash_banks++;
+
 		idx += addrc + sizec;
 	}
-	gd->bd->bi_flashstart = cfi_flash_base[0];
+	gd->bd->bi_flashstart = flash_info[0].base;
 
 	return 0;
 }
diff --git a/drivers/mtd/mtd-uclass.c b/drivers/mtd/mtd-uclass.c
index 7b7c48ec5a..bf3d48bd96 100644
--- a/drivers/mtd/mtd-uclass.c
+++ b/drivers/mtd/mtd-uclass.c
@@ -6,9 +6,25 @@
 
 #include <common.h>
 #include <dm.h>
+#include <dm/device-internal.h>
 #include <errno.h>
 #include <mtd.h>
 
+/**
+ * mtd_probe - Probe the device @dev if not already done
+ *
+ * @dev: U-Boot device to probe
+ *
+ * @return 0 on success, an error otherwise.
+ */
+int mtd_probe(struct udevice *dev)
+{
+	if (device_active(dev))
+		return 0;
+
+	return device_probe(dev);
+}
+
 /*
  * Implement a MTD uclass which should include most flash drivers.
  * The uclass private is pointed to mtd_info.
diff --git a/drivers/mtd/mtd_uboot.c b/drivers/mtd/mtd_uboot.c
index 21386951ef..774461a2eb 100644
--- a/drivers/mtd/mtd_uboot.c
+++ b/drivers/mtd/mtd_uboot.c
@@ -5,8 +5,359 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
+#include <dm/device.h>
+#include <dm/uclass-internal.h>
+#include <jffs2/jffs2.h> /* LEGACY */
 #include <linux/mtd/mtd.h>
-#include <jffs2/jffs2.h>
+#include <linux/mtd/partitions.h>
+#include <mtd.h>
+
+#define MTD_NAME_MAX_LEN 20
+
+void board_mtdparts_default(const char **mtdids, const char **mtdparts);
+
+static const char *get_mtdids(void)
+{
+	__maybe_unused const char *mtdparts = NULL;
+	const char *mtdids = env_get("mtdids");
+
+	if (mtdids)
+		return mtdids;
+
+#if defined(CONFIG_SYS_MTDPARTS_RUNTIME)
+	board_mtdparts_default(&mtdids, &mtdparts);
+#elif defined(MTDIDS_DEFAULT)
+	mtdids = MTDIDS_DEFAULT;
+#elif defined(CONFIG_MTDIDS_DEFAULT)
+	mtdids = CONFIG_MTDIDS_DEFAULT;
+#endif
+
+	if (mtdids)
+		env_set("mtdids", mtdids);
+
+	return mtdids;
+}
+
+/**
+ * mtd_search_alternate_name - Search an alternate name for @mtdname thanks to
+ *                             the mtdids legacy environment variable.
+ *
+ * The mtdids string is a list of comma-separated 'dev_id=mtd_id' tupples.
+ * Check if one of the mtd_id matches mtdname, in this case save dev_id in
+ * altname.
+ *
+ * @mtdname: Current MTD device name
+ * @altname: Alternate name to return
+ * @max_len: Length of the alternate name buffer
+ *
+ * @return 0 on success, an error otherwise.
+ */
+int mtd_search_alternate_name(const char *mtdname, char *altname,
+			      unsigned int max_len)
+{
+	const char *mtdids, *equal, *comma, *dev_id, *mtd_id;
+	int dev_id_len, mtd_id_len;
+
+	mtdids = get_mtdids();
+	if (!mtdids)
+		return -EINVAL;
+
+	do {
+		/* Find the '=' sign */
+		dev_id = mtdids;
+		equal = strchr(dev_id, '=');
+		if (!equal)
+			break;
+		dev_id_len = equal - mtdids;
+		mtd_id = equal + 1;
+
+		/* Find the end of the tupple */
+		comma = strchr(mtdids, ',');
+		if (comma)
+			mtd_id_len = comma - mtd_id;
+		else
+			mtd_id_len = &mtdids[strlen(mtdids)] - mtd_id + 1;
+
+		if (!dev_id_len || !mtd_id_len)
+			return -EINVAL;
+
+		if (dev_id_len + 1 > max_len)
+			continue;
+
+		/* Compare the name we search with the current mtd_id */
+		if (!strncmp(mtdname, mtd_id, mtd_id_len)) {
+			strncpy(altname, dev_id, dev_id_len);
+			altname[dev_id_len] = 0;
+
+			return 0;
+		}
+
+		/* Go to the next tupple */
+		mtdids = comma + 1;
+	} while (comma);
+
+	return -EINVAL;
+}
+
+#if IS_ENABLED(CONFIG_MTD)
+static void mtd_probe_uclass_mtd_devs(void)
+{
+	struct udevice *dev;
+	int idx = 0;
+
+	/* Probe devices with DM compliant drivers */
+	while (!uclass_find_device(UCLASS_MTD, idx, &dev) && dev) {
+		mtd_probe(dev);
+		idx++;
+	}
+}
+#else
+static void mtd_probe_uclass_mtd_devs(void) { }
+#endif
+
+#if defined(CONFIG_MTD_PARTITIONS)
+
+#define MTDPARTS_MAXLEN         512
+
+static const char *get_mtdparts(void)
+{
+	__maybe_unused const char *mtdids = NULL;
+	static char tmp_parts[MTDPARTS_MAXLEN];
+	const char *mtdparts = NULL;
+
+	if (gd->flags & GD_FLG_ENV_READY)
+		mtdparts = env_get("mtdparts");
+	else if (env_get_f("mtdparts", tmp_parts, sizeof(tmp_parts)) != -1)
+		mtdparts = tmp_parts;
+
+	if (mtdparts)
+		return mtdparts;
+
+#if defined(CONFIG_SYS_MTDPARTS_RUNTIME)
+	board_mtdparts_default(&mtdids, &mtdparts);
+#elif defined(MTDPARTS_DEFAULT)
+	mtdparts = MTDPARTS_DEFAULT;
+#elif defined(CONFIG_MTDPARTS_DEFAULT)
+	mtdparts = CONFIG_MTDPARTS_DEFAULT;
+#endif
+
+	if (mtdparts)
+		env_set("mtdparts", mtdparts);
+
+	return mtdparts;
+}
+
+static int mtd_del_parts(struct mtd_info *mtd, bool quiet)
+{
+	int ret;
+
+	if (!mtd_has_partitions(mtd))
+		return 0;
+
+	/* do not delete partitions if they are in use. */
+	if (mtd_partitions_used(mtd)) {
+		if (!quiet)
+			printf("\"%s\" partitions still in use, can't delete them\n",
+			       mtd->name);
+		return -EACCES;
+	}
+
+	ret = del_mtd_partitions(mtd);
+	if (ret)
+		return ret;
+
+	return 1;
+}
+
+static bool mtd_del_all_parts_failed;
+
+static void mtd_del_all_parts(void)
+{
+	struct mtd_info *mtd;
+	int ret = 0;
+
+	mtd_del_all_parts_failed = false;
+
+	/*
+	 * It is not safe to remove entries from the mtd_for_each_device loop
+	 * as it uses idr indexes and the partitions removal is done in bulk
+	 * (all partitions of one device at the same time), so break and
+	 * iterate from start each time a new partition is found and deleted.
+	 */
+	do {
+		mtd_for_each_device(mtd) {
+			ret = mtd_del_parts(mtd, false);
+			if (ret > 0)
+				break;
+			else if (ret < 0)
+				mtd_del_all_parts_failed = true;
+		}
+	} while (ret > 0);
+}
+
+int mtd_probe_devices(void)
+{
+	static char *old_mtdparts;
+	static char *old_mtdids;
+	const char *mtdparts = get_mtdparts();
+	const char *mtdids = get_mtdids();
+	const char *mtdparts_next = mtdparts;
+	struct mtd_info *mtd;
+
+	mtd_probe_uclass_mtd_devs();
+
+	/*
+	 * Check if mtdparts/mtdids changed, if the MTD dev list was updated
+	 * or if our previous attempt to delete existing partititions failed.
+	 * In any of these cases we want to update the partitions, otherwise,
+	 * everything is up-to-date and we can return 0 directly.
+	 */
+	if ((!mtdparts && !old_mtdparts && !mtdids && !old_mtdids) ||
+	    (mtdparts && old_mtdparts && mtdids && old_mtdids &&
+	     !mtd_dev_list_updated() && !mtd_del_all_parts_failed &&
+	     !strcmp(mtdparts, old_mtdparts) &&
+	     !strcmp(mtdids, old_mtdids)))
+		return 0;
+
+	/* Update the local copy of mtdparts */
+	free(old_mtdparts);
+	free(old_mtdids);
+	old_mtdparts = strdup(mtdparts);
+	old_mtdids = strdup(mtdids);
+
+	/*
+	 * Remove all old parts. Note that partition removal can fail in case
+	 * one of the partition is still being used by an MTD user, so this
+	 * does not guarantee that all old partitions are gone.
+	 */
+	mtd_del_all_parts();
+
+	/*
+	 * Call mtd_dev_list_updated() to clear updates generated by our own
+	 * parts removal loop.
+	 */
+	mtd_dev_list_updated();
+
+	/* If either mtdparts or mtdids is empty, then exit */
+	if (!mtdparts || !mtdids)
+		return 0;
+
+	/* Start the parsing by ignoring the extra 'mtdparts=' prefix, if any */
+	if (!strncmp(mtdparts, "mtdparts=", sizeof("mtdparts=") - 1))
+		mtdparts += 9;
+
+	/* For each MTD device in mtdparts */
+	for (; mtdparts[0] != '\0'; mtdparts = mtdparts_next) {
+		char mtd_name[MTD_NAME_MAX_LEN], *colon;
+		struct mtd_partition *parts;
+		unsigned int mtd_name_len;
+		int nparts, ret;
+
+		mtdparts_next = strchr(mtdparts, ';');
+		if (!mtdparts_next)
+			mtdparts_next = mtdparts + strlen(mtdparts);
+		else
+			mtdparts_next++;
+
+		colon = strchr(mtdparts, ':');
+		if (colon > mtdparts_next)
+			colon = NULL;
+
+		if (!colon) {
+			printf("Wrong mtdparts: %s\n", mtdparts);
+			return -EINVAL;
+		}
+
+		mtd_name_len = (unsigned int)(colon - mtdparts);
+		if (mtd_name_len + 1 > sizeof(mtd_name)) {
+			printf("MTD name too long: %s\n", mtdparts);
+			return -EINVAL;
+		}
+
+		strncpy(mtd_name, mtdparts, mtd_name_len);
+		mtd_name[mtd_name_len] = '\0';
+		/* Move the pointer forward (including the ':') */
+		mtdparts += mtd_name_len + 1;
+		mtd = get_mtd_device_nm(mtd_name);
+		if (IS_ERR_OR_NULL(mtd)) {
+			char linux_name[MTD_NAME_MAX_LEN];
+
+			/*
+			 * The MTD device named "mtd_name" does not exist. Try
+			 * to find a correspondance with an MTD device having
+			 * the same type and number as defined in the mtdids.
+			 */
+			debug("No device named %s\n", mtd_name);
+			ret = mtd_search_alternate_name(mtd_name, linux_name,
+							MTD_NAME_MAX_LEN);
+			if (!ret)
+				mtd = get_mtd_device_nm(linux_name);
+
+			/*
+			 * If no device could be found, move the mtdparts
+			 * pointer forward until the next set of partitions.
+			 */
+			if (ret || IS_ERR_OR_NULL(mtd)) {
+				printf("Could not find a valid device for %s\n",
+				       mtd_name);
+				mtdparts = mtdparts_next;
+				continue;
+			}
+		}
+
+		/*
+		 * Call mtd_del_parts() again, even if it's already been called
+		 * in mtd_del_all_parts(). We need to know if old partitions are
+		 * still around (because they are still being used by someone),
+		 * and if they are, we shouldn't create new partitions, so just
+		 * skip this MTD device and try the next one.
+		 */
+		ret = mtd_del_parts(mtd, true);
+		if (ret < 0)
+			continue;
+
+		/*
+		 * Parse the MTD device partitions. It will update the mtdparts
+		 * pointer, create an array of parts (that must be freed), and
+		 * return the number of partition structures in the array.
+		 */
+		ret = mtd_parse_partitions(mtd, &mtdparts, &parts, &nparts);
+		if (ret) {
+			printf("Could not parse device %s\n", mtd->name);
+			put_mtd_device(mtd);
+			return -EINVAL;
+		}
+
+		if (!nparts)
+			continue;
+
+		/* Create the new MTD partitions */
+		add_mtd_partitions(mtd, parts, nparts);
+
+		/* Free the structures allocated during the parsing */
+		mtd_free_parsed_partitions(parts, nparts);
+
+		put_mtd_device(mtd);
+	}
+
+	/*
+	 * Call mtd_dev_list_updated() to clear updates generated by our own
+	 * parts registration loop.
+	 */
+	mtd_dev_list_updated();
+
+	return 0;
+}
+#else
+int mtd_probe_devices(void)
+{
+	mtd_probe_uclass_mtd_devs();
+
+	return 0;
+}
+#endif /* defined(CONFIG_MTD_PARTITIONS) */
+
+/* Legacy */
 
 static int get_part(const char *partname, int *idx, loff_t *off, loff_t *size,
 		loff_t *maxsize, int devtype)
diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e3f56e5424..3dff0596fa 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -88,14 +88,17 @@ struct idr_layer {
 
 struct idr {
 	struct idr_layer id[MAX_IDR_ID];
+	bool updated;
 };
 
 #define DEFINE_IDR(name)	struct idr name;
 
 void idr_remove(struct idr *idp, int id)
 {
-	if (idp->id[id].used)
+	if (idp->id[id].used) {
 		idp->id[id].used = 0;
+		idp->updated = true;
+	}
 
 	return;
 }
@@ -135,6 +138,7 @@ int idr_alloc(struct idr *idp, void *ptr, int start, int end, gfp_t gfp_mask)
 		if (idl->used == 0) {
 			idl->used = 1;
 			idl->ptr = ptr;
+			idp->updated = true;
 			return i;
 		}
 		i++;
@@ -156,6 +160,16 @@ struct mtd_info *__mtd_next_device(int i)
 }
 EXPORT_SYMBOL_GPL(__mtd_next_device);
 
+bool mtd_dev_list_updated(void)
+{
+	if (mtd_idr.updated) {
+		mtd_idr.updated = false;
+		return true;
+	}
+
+	return false;
+}
+
 #ifndef __UBOOT__
 static LIST_HEAD(mtd_notifiers);
 
@@ -427,6 +441,8 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->index = i;
 	mtd->usecount = 0;
 
+	INIT_LIST_HEAD(&mtd->partitions);
+
 	/* default value if not set by driver */
 	if (mtd->bitflip_threshold == 0)
 		mtd->bitflip_threshold = mtd->ecc_strength;
@@ -513,6 +529,13 @@ int del_mtd_device(struct mtd_info *mtd)
 	struct mtd_notifier *not;
 #endif
 
+	ret = del_mtd_partitions(mtd);
+	if (ret) {
+		debug("Failed to delete MTD partitions attached to %s (err %d)\n",
+		      mtd->name, ret);
+		return ret;
+	}
+
 	mutex_lock(&mtd_table_mutex);
 
 	if (idr_find(&mtd_idr, mtd->index) != mtd) {
@@ -938,7 +961,20 @@ int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	 * representing the maximum number of bitflips that were corrected on
 	 * any one ecc region (if applicable; zero otherwise).
 	 */
-	ret_code = mtd->_read(mtd, from, len, retlen, buf);
+	if (mtd->_read) {
+		ret_code = mtd->_read(mtd, from, len, retlen, buf);
+	} else if (mtd->_read_oob) {
+		struct mtd_oob_ops ops = {
+			.len = len,
+			.datbuf = buf,
+		};
+
+		ret_code = mtd->_read_oob(mtd, from, &ops);
+		*retlen = ops.retlen;
+	} else {
+		return -ENOTSUPP;
+	}
+
 	if (unlikely(ret_code < 0))
 		return ret_code;
 	if (mtd->ecc_strength == 0)
@@ -953,10 +989,24 @@ int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	*retlen = 0;
 	if (to < 0 || to > mtd->size || len > mtd->size - to)
 		return -EINVAL;
-	if (!mtd->_write || !(mtd->flags & MTD_WRITEABLE))
+	if ((!mtd->_write && !mtd->_write_oob) ||
+	    !(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
 	if (!len)
 		return 0;
+
+	if (!mtd->_write) {
+		struct mtd_oob_ops ops = {
+			.len = len,
+			.datbuf = (u8 *)buf,
+		};
+		int ret;
+
+		ret = mtd->_write_oob(mtd, to, &ops);
+		*retlen = ops.retlen;
+		return ret;
+	}
+
 	return mtd->_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_write);
@@ -984,19 +1034,64 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
 
+static int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,
+			     struct mtd_oob_ops *ops)
+{
+	/*
+	 * Some users are setting ->datbuf or ->oobbuf to NULL, but are leaving
+	 * ->len or ->ooblen uninitialized. Force ->len and ->ooblen to 0 in
+	 *  this case.
+	 */
+	if (!ops->datbuf)
+		ops->len = 0;
+
+	if (!ops->oobbuf)
+		ops->ooblen = 0;
+
+	if (offs < 0 || offs + ops->len > mtd->size)
+		return -EINVAL;
+
+	if (ops->ooblen) {
+		size_t maxooblen;
+
+		if (ops->ooboffs >= mtd_oobavail(mtd, ops))
+			return -EINVAL;
+
+		maxooblen = ((size_t)(mtd_div_by_ws(mtd->size, mtd) -
+				      mtd_div_by_ws(offs, mtd)) *
+			     mtd_oobavail(mtd, ops)) - ops->ooboffs;
+		if (ops->ooblen > maxooblen)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	int ret_code;
 	ops->retlen = ops->oobretlen = 0;
-	if (!mtd->_read_oob)
+
+	ret_code = mtd_check_oob_ops(mtd, from, ops);
+	if (ret_code)
+		return ret_code;
+
+	/* Check the validity of a potential fallback on mtd->_read */
+	if (!mtd->_read_oob && (!mtd->_read || ops->oobbuf))
 		return -EOPNOTSUPP;
+
+	if (mtd->_read_oob)
+		ret_code = mtd->_read_oob(mtd, from, ops);
+	else
+		ret_code = mtd->_read(mtd, from, ops->len, &ops->retlen,
+				      ops->datbuf);
+
 	/*
 	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
 	 * similar to mtd->_read(), returning a non-negative integer
 	 * representing max bitflips. In other cases, mtd->_read_oob() may
 	 * return -EUCLEAN. In all cases, perform similar logic to mtd_read().
 	 */
-	ret_code = mtd->_read_oob(mtd, from, ops);
 	if (unlikely(ret_code < 0))
 		return ret_code;
 	if (mtd->ecc_strength == 0)
@@ -1005,6 +1100,392 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 }
 EXPORT_SYMBOL_GPL(mtd_read_oob);
 
+int mtd_write_oob(struct mtd_info *mtd, loff_t to,
+				struct mtd_oob_ops *ops)
+{
+	int ret;
+
+	ops->retlen = ops->oobretlen = 0;
+
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
+
+	ret = mtd_check_oob_ops(mtd, to, ops);
+	if (ret)
+		return ret;
+
+	/* Check the validity of a potential fallback on mtd->_write */
+	if (!mtd->_write_oob && (!mtd->_write || ops->oobbuf))
+		return -EOPNOTSUPP;
+
+	if (mtd->_write_oob)
+		return mtd->_write_oob(mtd, to, ops);
+	else
+		return mtd->_write(mtd, to, ops->len, &ops->retlen,
+				   ops->datbuf);
+}
+EXPORT_SYMBOL_GPL(mtd_write_oob);
+
+/**
+ * mtd_ooblayout_ecc - Get the OOB region definition of a specific ECC section
+ * @mtd: MTD device structure
+ * @section: ECC section. Depending on the layout you may have all the ECC
+ *	     bytes stored in a single contiguous section, or one section
+ *	     per ECC chunk (and sometime several sections for a single ECC
+ *	     ECC chunk)
+ * @oobecc: OOB region struct filled with the appropriate ECC position
+ *	    information
+ *
+ * This function returns ECC section information in the OOB area. If you want
+ * to get all the ECC bytes information, then you should call
+ * mtd_ooblayout_ecc(mtd, section++, oobecc) until it returns -ERANGE.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_ecc(struct mtd_info *mtd, int section,
+		      struct mtd_oob_region *oobecc)
+{
+	memset(oobecc, 0, sizeof(*oobecc));
+
+	if (!mtd || section < 0)
+		return -EINVAL;
+
+	if (!mtd->ooblayout || !mtd->ooblayout->ecc)
+		return -ENOTSUPP;
+
+	return mtd->ooblayout->ecc(mtd, section, oobecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);
+
+/**
+ * mtd_ooblayout_free - Get the OOB region definition of a specific free
+ *			section
+ * @mtd: MTD device structure
+ * @section: Free section you are interested in. Depending on the layout
+ *	     you may have all the free bytes stored in a single contiguous
+ *	     section, or one section per ECC chunk plus an extra section
+ *	     for the remaining bytes (or other funky layout).
+ * @oobfree: OOB region struct filled with the appropriate free position
+ *	     information
+ *
+ * This function returns free bytes position in the OOB area. If you want
+ * to get all the free bytes information, then you should call
+ * mtd_ooblayout_free(mtd, section++, oobfree) until it returns -ERANGE.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_free(struct mtd_info *mtd, int section,
+		       struct mtd_oob_region *oobfree)
+{
+	memset(oobfree, 0, sizeof(*oobfree));
+
+	if (!mtd || section < 0)
+		return -EINVAL;
+
+	if (!mtd->ooblayout || !mtd->ooblayout->rfree)
+		return -ENOTSUPP;
+
+	return mtd->ooblayout->rfree(mtd, section, oobfree);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_free);
+
+/**
+ * mtd_ooblayout_find_region - Find the region attached to a specific byte
+ * @mtd: mtd info structure
+ * @byte: the byte we are searching for
+ * @sectionp: pointer where the section id will be stored
+ * @oobregion: used to retrieve the ECC position
+ * @iter: iterator function. Should be either mtd_ooblayout_free or
+ *	  mtd_ooblayout_ecc depending on the region type you're searching for
+ *
+ * This function returns the section id and oobregion information of a
+ * specific byte. For example, say you want to know where the 4th ECC byte is
+ * stored, you'll use:
+ *
+ * mtd_ooblayout_find_region(mtd, 3, &section, &oobregion, mtd_ooblayout_ecc);
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_find_region(struct mtd_info *mtd, int byte,
+				int *sectionp, struct mtd_oob_region *oobregion,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	int pos = 0, ret, section = 0;
+
+	memset(oobregion, 0, sizeof(*oobregion));
+
+	while (1) {
+		ret = iter(mtd, section, oobregion);
+		if (ret)
+			return ret;
+
+		if (pos + oobregion->length > byte)
+			break;
+
+		pos += oobregion->length;
+		section++;
+	}
+
+	/*
+	 * Adjust region info to make it start at the beginning at the
+	 * 'start' ECC byte.
+	 */
+	oobregion->offset += byte - pos;
+	oobregion->length -= byte - pos;
+	*sectionp = section;
+
+	return 0;
+}
+
+/**
+ * mtd_ooblayout_find_eccregion - Find the ECC region attached to a specific
+ *				  ECC byte
+ * @mtd: mtd info structure
+ * @eccbyte: the byte we are searching for
+ * @sectionp: pointer where the section id will be stored
+ * @oobregion: OOB region information
+ *
+ * Works like mtd_ooblayout_find_region() except it searches for a specific ECC
+ * byte.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_find_eccregion(struct mtd_info *mtd, int eccbyte,
+				 int *section,
+				 struct mtd_oob_region *oobregion)
+{
+	return mtd_ooblayout_find_region(mtd, eccbyte, section, oobregion,
+					 mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_find_eccregion);
+
+/**
+ * mtd_ooblayout_get_bytes - Extract OOB bytes from the oob buffer
+ * @mtd: mtd info structure
+ * @buf: destination buffer to store OOB bytes
+ * @oobbuf: OOB buffer
+ * @start: first byte to retrieve
+ * @nbytes: number of bytes to retrieve
+ * @iter: section iterator
+ *
+ * Extract bytes attached to a specific category (ECC or free)
+ * from the OOB buffer and copy them into buf.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_get_bytes(struct mtd_info *mtd, u8 *buf,
+				const u8 *oobbuf, int start, int nbytes,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	struct mtd_oob_region oobregion;
+	int section, ret;
+
+	ret = mtd_ooblayout_find_region(mtd, start, &section,
+					&oobregion, iter);
+
+	while (!ret) {
+		int cnt;
+
+		cnt = min_t(int, nbytes, oobregion.length);
+		memcpy(buf, oobbuf + oobregion.offset, cnt);
+		buf += cnt;
+		nbytes -= cnt;
+
+		if (!nbytes)
+			break;
+
+		ret = iter(mtd, ++section, &oobregion);
+	}
+
+	return ret;
+}
+
+/**
+ * mtd_ooblayout_set_bytes - put OOB bytes into the oob buffer
+ * @mtd: mtd info structure
+ * @buf: source buffer to get OOB bytes from
+ * @oobbuf: OOB buffer
+ * @start: first OOB byte to set
+ * @nbytes: number of OOB bytes to set
+ * @iter: section iterator
+ *
+ * Fill the OOB buffer with data provided in buf. The category (ECC or free)
+ * is selected by passing the appropriate iterator.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_set_bytes(struct mtd_info *mtd, const u8 *buf,
+				u8 *oobbuf, int start, int nbytes,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	struct mtd_oob_region oobregion;
+	int section, ret;
+
+	ret = mtd_ooblayout_find_region(mtd, start, &section,
+					&oobregion, iter);
+
+	while (!ret) {
+		int cnt;
+
+		cnt = min_t(int, nbytes, oobregion.length);
+		memcpy(oobbuf + oobregion.offset, buf, cnt);
+		buf += cnt;
+		nbytes -= cnt;
+
+		if (!nbytes)
+			break;
+
+		ret = iter(mtd, ++section, &oobregion);
+	}
+
+	return ret;
+}
+
+/**
+ * mtd_ooblayout_count_bytes - count the number of bytes in a OOB category
+ * @mtd: mtd info structure
+ * @iter: category iterator
+ *
+ * Count the number of bytes in a given category.
+ *
+ * Returns a positive value on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_count_bytes(struct mtd_info *mtd,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	struct mtd_oob_region oobregion;
+	int section = 0, ret, nbytes = 0;
+
+	while (1) {
+		ret = iter(mtd, section++, &oobregion);
+		if (ret) {
+			if (ret == -ERANGE)
+				ret = nbytes;
+			break;
+		}
+
+		nbytes += oobregion.length;
+	}
+
+	return ret;
+}
+
+/**
+ * mtd_ooblayout_get_eccbytes - extract ECC bytes from the oob buffer
+ * @mtd: mtd info structure
+ * @eccbuf: destination buffer to store ECC bytes
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to retrieve
+ * @nbytes: number of ECC bytes to retrieve
+ *
+ * Works like mtd_ooblayout_get_bytes(), except it acts on ECC bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_get_eccbytes(struct mtd_info *mtd, u8 *eccbuf,
+			       const u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_get_bytes(mtd, eccbuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_get_eccbytes);
+
+/**
+ * mtd_ooblayout_set_eccbytes - set ECC bytes into the oob buffer
+ * @mtd: mtd info structure
+ * @eccbuf: source buffer to get ECC bytes from
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to set
+ * @nbytes: number of ECC bytes to set
+ *
+ * Works like mtd_ooblayout_set_bytes(), except it acts on ECC bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_set_eccbytes(struct mtd_info *mtd, const u8 *eccbuf,
+			       u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_set_bytes(mtd, eccbuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_set_eccbytes);
+
+/**
+ * mtd_ooblayout_get_databytes - extract data bytes from the oob buffer
+ * @mtd: mtd info structure
+ * @databuf: destination buffer to store ECC bytes
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to retrieve
+ * @nbytes: number of ECC bytes to retrieve
+ *
+ * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_get_databytes(struct mtd_info *mtd, u8 *databuf,
+				const u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_get_bytes(mtd, databuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_free);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_get_databytes);
+
+/**
+ * mtd_ooblayout_get_eccbytes - set data bytes into the oob buffer
+ * @mtd: mtd info structure
+ * @eccbuf: source buffer to get data bytes from
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to set
+ * @nbytes: number of ECC bytes to set
+ *
+ * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_set_databytes(struct mtd_info *mtd, const u8 *databuf,
+				u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_set_bytes(mtd, databuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_free);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_set_databytes);
+
+/**
+ * mtd_ooblayout_count_freebytes - count the number of free bytes in OOB
+ * @mtd: mtd info structure
+ *
+ * Works like mtd_ooblayout_count_bytes(), except it count free bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_count_freebytes(struct mtd_info *mtd)
+{
+	return mtd_ooblayout_count_bytes(mtd, mtd_ooblayout_free);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_count_freebytes);
+
+/**
+ * mtd_ooblayout_count_freebytes - count the number of ECC bytes in OOB
+ * @mtd: mtd info structure
+ *
+ * Works like mtd_ooblayout_count_bytes(), except it count ECC bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_count_eccbytes(struct mtd_info *mtd)
+{
+	return mtd_ooblayout_count_bytes(mtd, mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_count_eccbytes);
+
 /*
  * Method to access the protection register area, present in some flash
  * devices. The user data is one time programmable but the factory data is read
diff --git a/drivers/mtd/mtdcore.h b/drivers/mtd/mtdcore.h
index 7b0353399a..1d181a1045 100644
--- a/drivers/mtd/mtdcore.h
+++ b/drivers/mtd/mtdcore.h
@@ -5,7 +5,6 @@
 
 extern struct mutex mtd_table_mutex;
 
-struct mtd_info *__mtd_next_device(int i);
 int add_mtd_device(struct mtd_info *mtd);
 int del_mtd_device(struct mtd_info *mtd);
 int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
@@ -16,8 +15,3 @@ int parse_mtd_partitions(struct mtd_info *master, const char * const *types,
 
 int __init init_mtdchar(void);
 void __exit cleanup_mtdchar(void);
-
-#define mtd_for_each_device(mtd)			\
-	for ((mtd) = __mtd_next_device(0);		\
-	     (mtd) != NULL;				\
-	     (mtd) = __mtd_next_device(mtd->index + 1))
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
index 5e42c4b833..b330d22633 100644
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -27,32 +27,16 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/err.h>
+#include <linux/sizes.h>
 
 #include "mtdcore.h"
 
-/* Our partition linked list */
-static LIST_HEAD(mtd_partitions);
 #ifndef __UBOOT__
 static DEFINE_MUTEX(mtd_partitions_mutex);
 #else
 DEFINE_MUTEX(mtd_partitions_mutex);
 #endif
 
-/* Our partition node structure */
-struct mtd_part {
-	struct mtd_info mtd;
-	struct mtd_info *master;
-	uint64_t offset;
-	struct list_head list;
-};
-
-/*
- * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
- * the pointer to that structure with this macro.
- */
-#define PART(x)  ((struct mtd_part *)(x))
-
-
 #ifdef __UBOOT__
 /* from mm/util.c */
 
@@ -77,6 +61,227 @@ char *kstrdup(const char *s, gfp_t gfp)
 }
 #endif
 
+#define MTD_SIZE_REMAINING		(~0LLU)
+#define MTD_OFFSET_NOT_SPECIFIED	(~0LLU)
+
+bool mtd_partitions_used(struct mtd_info *master)
+{
+	struct mtd_info *slave;
+
+	list_for_each_entry(slave, &master->partitions, node) {
+		if (slave->usecount)
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * mtd_parse_partition - Parse @mtdparts partition definition, fill @partition
+ *                       with it and update the @mtdparts string pointer.
+ *
+ * The partition name is allocated and must be freed by the caller.
+ *
+ * This function is widely inspired from part_parse (mtdparts.c).
+ *
+ * @mtdparts: String describing the partition with mtdparts command syntax
+ * @partition: MTD partition structure to fill
+ *
+ * @return 0 on success, an error otherwise.
+ */
+static int mtd_parse_partition(const char **_mtdparts,
+			       struct mtd_partition *partition)
+{
+	const char *mtdparts = *_mtdparts;
+	const char *name = NULL;
+	int name_len;
+	char *buf;
+
+	/* Ensure the partition structure is empty */
+	memset(partition, 0, sizeof(struct mtd_partition));
+
+	/* Fetch the partition size */
+	if (*mtdparts == '-') {
+		/* Assign all remaining space to this partition */
+		partition->size = MTD_SIZE_REMAINING;
+		mtdparts++;
+	} else {
+		partition->size = ustrtoull(mtdparts, (char **)&mtdparts, 0);
+		if (partition->size < SZ_4K) {
+			printf("Minimum partition size 4kiB, %lldB requested\n",
+			       partition->size);
+			return -EINVAL;
+		}
+	}
+
+	/* Check for the offset */
+	partition->offset = MTD_OFFSET_NOT_SPECIFIED;
+	if (*mtdparts == '@') {
+		mtdparts++;
+		partition->offset = ustrtoull(mtdparts, (char **)&mtdparts, 0);
+	}
+
+	/* Now look for the name */
+	if (*mtdparts == '(') {
+		name = ++mtdparts;
+		mtdparts = strchr(name, ')');
+		if (!mtdparts) {
+			printf("No closing ')' found in partition name\n");
+			return -EINVAL;
+		}
+		name_len = mtdparts - name + 1;
+		if ((name_len - 1) == 0) {
+			printf("Empty partition name\n");
+			return -EINVAL;
+		}
+		mtdparts++;
+	} else {
+		/* Name will be of the form size@offset */
+		name_len = 22;
+	}
+
+	/* Check if the partition is read-only */
+	if (strncmp(mtdparts, "ro", 2) == 0) {
+		partition->mask_flags |= MTD_WRITEABLE;
+		mtdparts += 2;
+	}
+
+	/* Check for a potential next partition definition */
+	if (*mtdparts == ',') {
+		if (partition->size == MTD_SIZE_REMAINING) {
+			printf("No partitions allowed after a fill-up\n");
+			return -EINVAL;
+		}
+		++mtdparts;
+	} else if ((*mtdparts == ';') || (*mtdparts == '\0')) {
+		/* NOP */
+	} else {
+		printf("Unexpected character '%c' in mtdparts\n", *mtdparts);
+		return -EINVAL;
+	}
+
+	/*
+	 * Allocate a buffer for the name and either copy the provided name or
+	 * auto-generate it with the form 'size@offset'.
+	 */
+	buf = malloc(name_len);
+	if (!buf)
+		return -ENOMEM;
+
+	if (name)
+		strncpy(buf, name, name_len - 1);
+	else
+		snprintf(buf, name_len, "0x%08llx@0x%08llx",
+			 partition->size, partition->offset);
+
+	buf[name_len - 1] = '\0';
+	partition->name = buf;
+
+	*_mtdparts = mtdparts;
+
+	return 0;
+}
+
+/**
+ * mtd_parse_partitions - Create a partition array from an mtdparts definition
+ *
+ * Stateless function that takes a @parent MTD device, a string @_mtdparts
+ * describing the partitions (with the "mtdparts" command syntax) and creates
+ * the corresponding MTD partition structure array @_parts. Both the name and
+ * the structure partition itself must be freed freed, the caller may use
+ * @mtd_free_parsed_partitions() for this purpose.
+ *
+ * @parent: MTD device which contains the partitions
+ * @_mtdparts: Pointer to a string describing the partitions with "mtdparts"
+ *             command syntax.
+ * @_parts: Allocated array containing the partitions, must be freed by the
+ *          caller.
+ * @_nparts: Size of @_parts array.
+ *
+ * @return 0 on success, an error otherwise.
+ */
+int mtd_parse_partitions(struct mtd_info *parent, const char **_mtdparts,
+			 struct mtd_partition **_parts, int *_nparts)
+{
+	struct mtd_partition partition = {}, *parts;
+	const char *mtdparts = *_mtdparts;
+	int cur_off = 0, cur_sz = 0;
+	int nparts = 0;
+	int ret, idx;
+	u64 sz;
+
+	/* First, iterate over the partitions until we know their number */
+	while (mtdparts[0] != '\0' && mtdparts[0] != ';') {
+		ret = mtd_parse_partition(&mtdparts, &partition);
+		if (ret)
+			return ret;
+
+		free((char *)partition.name);
+		nparts++;
+	}
+
+	/* Allocate an array of partitions to give back to the caller */
+	parts = malloc(sizeof(*parts) * nparts);
+	if (!parts) {
+		printf("Not enough space to save partitions meta-data\n");
+		return -ENOMEM;
+	}
+
+	/* Iterate again over each partition to save the data in our array */
+	for (idx = 0; idx < nparts; idx++) {
+		ret = mtd_parse_partition(_mtdparts, &parts[idx]);
+		if (ret)
+			return ret;
+
+		if (parts[idx].size == MTD_SIZE_REMAINING)
+			parts[idx].size = parent->size - cur_sz;
+		cur_sz += parts[idx].size;
+
+		sz = parts[idx].size;
+		if (sz < parent->writesize || do_div(sz, parent->writesize)) {
+			printf("Partition size must be a multiple of %d\n",
+			       parent->writesize);
+			return -EINVAL;
+		}
+
+		if (parts[idx].offset == MTD_OFFSET_NOT_SPECIFIED)
+			parts[idx].offset = cur_off;
+		cur_off += parts[idx].size;
+
+		parts[idx].ecclayout = parent->ecclayout;
+	}
+
+	/* Offset by one mtdparts to point to the next device if any */
+	if (*_mtdparts[0] == ';')
+		(*_mtdparts)++;
+
+	*_parts = parts;
+	*_nparts = nparts;
+
+	return 0;
+}
+
+/**
+ * mtd_free_parsed_partitions - Free dynamically allocated partitions
+ *
+ * Each successful call to @mtd_parse_partitions must be followed by a call to
+ * @mtd_free_parsed_partitions to free any allocated array during the parsing
+ * process.
+ *
+ * @parts: Array containing the partitions that will be freed.
+ * @nparts: Size of @parts array.
+ */
+void mtd_free_parsed_partitions(struct mtd_partition *parts,
+				unsigned int nparts)
+{
+	int i;
+
+	for (i = 0; i < nparts; i++)
+		free((char *)parts[i].name);
+
+	free(parts);
+}
+
 /*
  * MTD methods which simply translate the effective address and pass through
  * to the _real_ device.
@@ -85,19 +290,18 @@ char *kstrdup(const char *s, gfp_t gfp)
 static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char *buf)
 {
-	struct mtd_part *part = PART(mtd);
 	struct mtd_ecc_stats stats;
 	int res;
 
-	stats = part->master->ecc_stats;
-	res = part->master->_read(part->master, from + part->offset, len,
-				  retlen, buf);
+	stats = mtd->parent->ecc_stats;
+	res = mtd->parent->_read(mtd->parent, from + mtd->offset, len,
+				 retlen, buf);
 	if (unlikely(mtd_is_eccerr(res)))
 		mtd->ecc_stats.failed +=
-			part->master->ecc_stats.failed - stats.failed;
+			mtd->parent->ecc_stats.failed - stats.failed;
 	else
 		mtd->ecc_stats.corrected +=
-			part->master->ecc_stats.corrected - stats.corrected;
+			mtd->parent->ecc_stats.corrected - stats.corrected;
 	return res;
 }
 
@@ -105,17 +309,13 @@ static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
 static int part_point(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, void **virt, resource_size_t *phys)
 {
-	struct mtd_part *part = PART(mtd);
-
-	return part->master->_point(part->master, from + part->offset, len,
-				    retlen, virt, phys);
+	return mtd->parent->_point(mtd->parent, from + mtd->offset, len,
+				   retlen, virt, phys);
 }
 
 static int part_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
 {
-	struct mtd_part *part = PART(mtd);
-
-	return part->master->_unpoint(part->master, from + part->offset, len);
+	return mtd->parent->_unpoint(mtd->parent, from + mtd->offset, len);
 }
 #endif
 
@@ -124,17 +324,13 @@ static unsigned long part_get_unmapped_area(struct mtd_info *mtd,
 					    unsigned long offset,
 					    unsigned long flags)
 {
-	struct mtd_part *part = PART(mtd);
-
-	offset += part->offset;
-	return part->master->_get_unmapped_area(part->master, len, offset,
-						flags);
+	offset += mtd->offset;
+	return mtd->parent->_get_unmapped_area(mtd->parent, len, offset, flags);
 }
 
 static int part_read_oob(struct mtd_info *mtd, loff_t from,
 		struct mtd_oob_ops *ops)
 {
-	struct mtd_part *part = PART(mtd);
 	int res;
 
 	if (from >= mtd->size)
@@ -159,7 +355,7 @@ static int part_read_oob(struct mtd_info *mtd, loff_t from,
 			return -EINVAL;
 	}
 
-	res = part->master->_read_oob(part->master, from + part->offset, ops);
+	res = mtd->parent->_read_oob(mtd->parent, from + mtd->offset, ops);
 	if (unlikely(res)) {
 		if (mtd_is_bitflip(res))
 			mtd->ecc_stats.corrected++;
@@ -172,99 +368,87 @@ static int part_read_oob(struct mtd_info *mtd, loff_t from,
 static int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
 		size_t len, size_t *retlen, u_char *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_read_user_prot_reg(part->master, from, len,
-						 retlen, buf);
+	return mtd->parent->_read_user_prot_reg(mtd->parent, from, len,
+						retlen, buf);
 }
 
 static int part_get_user_prot_info(struct mtd_info *mtd, size_t len,
 				   size_t *retlen, struct otp_info *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_get_user_prot_info(part->master, len, retlen,
-						 buf);
+	return mtd->parent->_get_user_prot_info(mtd->parent, len, retlen,
+						buf);
 }
 
 static int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
 		size_t len, size_t *retlen, u_char *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_read_fact_prot_reg(part->master, from, len,
-						 retlen, buf);
+	return mtd->parent->_read_fact_prot_reg(mtd->parent, from, len,
+						retlen, buf);
 }
 
 static int part_get_fact_prot_info(struct mtd_info *mtd, size_t len,
 				   size_t *retlen, struct otp_info *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_get_fact_prot_info(part->master, len, retlen,
-						 buf);
+	return mtd->parent->_get_fact_prot_info(mtd->parent, len, retlen,
+						buf);
 }
 
 static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_write(part->master, to + part->offset, len,
-				    retlen, buf);
+	return mtd->parent->_write(mtd->parent, to + mtd->offset, len,
+				   retlen, buf);
 }
 
 static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_panic_write(part->master, to + part->offset, len,
-					  retlen, buf);
+	return mtd->parent->_panic_write(mtd->parent, to + mtd->offset, len,
+					 retlen, buf);
 }
 
 static int part_write_oob(struct mtd_info *mtd, loff_t to,
 		struct mtd_oob_ops *ops)
 {
-	struct mtd_part *part = PART(mtd);
-
 	if (to >= mtd->size)
 		return -EINVAL;
 	if (ops->datbuf && to + ops->len > mtd->size)
 		return -EINVAL;
-	return part->master->_write_oob(part->master, to + part->offset, ops);
+	return mtd->parent->_write_oob(mtd->parent, to + mtd->offset, ops);
 }
 
 static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
 		size_t len, size_t *retlen, u_char *buf)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_write_user_prot_reg(part->master, from, len,
-						  retlen, buf);
+	return mtd->parent->_write_user_prot_reg(mtd->parent, from, len,
+						 retlen, buf);
 }
 
 static int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
 		size_t len)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_lock_user_prot_reg(part->master, from, len);
+	return mtd->parent->_lock_user_prot_reg(mtd->parent, from, len);
 }
 
 #ifndef __UBOOT__
 static int part_writev(struct mtd_info *mtd, const struct kvec *vecs,
 		unsigned long count, loff_t to, size_t *retlen)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_writev(part->master, vecs, count,
-				     to + part->offset, retlen);
+	return mtd->parent->_writev(mtd->parent, vecs, count,
+				    to + mtd->offset, retlen);
 }
 #endif
 
 static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	struct mtd_part *part = PART(mtd);
 	int ret;
 
-	instr->addr += part->offset;
-	ret = part->master->_erase(part->master, instr);
+	instr->addr += mtd->offset;
+	ret = mtd->parent->_erase(mtd->parent, instr);
 	if (ret) {
 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
-			instr->fail_addr -= part->offset;
-		instr->addr -= part->offset;
+			instr->fail_addr -= mtd->offset;
+		instr->addr -= mtd->offset;
 	}
 	return ret;
 }
@@ -272,11 +456,9 @@ static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
 void mtd_erase_callback(struct erase_info *instr)
 {
 	if (instr->mtd->_erase == part_erase) {
-		struct mtd_part *part = PART(instr->mtd);
-
 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
-			instr->fail_addr -= part->offset;
-		instr->addr -= part->offset;
+			instr->fail_addr -= instr->mtd->offset;
+		instr->addr -= instr->mtd->offset;
 	}
 	if (instr->callback)
 		instr->callback(instr);
@@ -285,105 +467,112 @@ EXPORT_SYMBOL_GPL(mtd_erase_callback);
 
 static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_lock(part->master, ofs + part->offset, len);
+	return mtd->parent->_lock(mtd->parent, ofs + mtd->offset, len);
 }
 
 static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_unlock(part->master, ofs + part->offset, len);
+	return mtd->parent->_unlock(mtd->parent, ofs + mtd->offset, len);
 }
 
 static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_is_locked(part->master, ofs + part->offset, len);
+	return mtd->parent->_is_locked(mtd->parent, ofs + mtd->offset, len);
 }
 
 static void part_sync(struct mtd_info *mtd)
 {
-	struct mtd_part *part = PART(mtd);
-	part->master->_sync(part->master);
+	mtd->parent->_sync(mtd->parent);
 }
 
 #ifndef __UBOOT__
 static int part_suspend(struct mtd_info *mtd)
 {
-	struct mtd_part *part = PART(mtd);
-	return part->master->_suspend(part->master);
+	return mtd->parent->_suspend(mtd->parent);
 }
 
 static void part_resume(struct mtd_info *mtd)
 {
-	struct mtd_part *part = PART(mtd);
-	part->master->_resume(part->master);
+	mtd->parent->_resume(mtd->parent);
 }
 #endif
 
 static int part_block_isreserved(struct mtd_info *mtd, loff_t ofs)
 {
-	struct mtd_part *part = PART(mtd);
-	ofs += part->offset;
-	return part->master->_block_isreserved(part->master, ofs);
+	ofs += mtd->offset;
+	return mtd->parent->_block_isreserved(mtd->parent, ofs);
 }
 
 static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
 {
-	struct mtd_part *part = PART(mtd);
-	ofs += part->offset;
-	return part->master->_block_isbad(part->master, ofs);
+	ofs += mtd->offset;
+	return mtd->parent->_block_isbad(mtd->parent, ofs);
 }
 
 static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
-	struct mtd_part *part = PART(mtd);
 	int res;
 
-	ofs += part->offset;
-	res = part->master->_block_markbad(part->master, ofs);
+	ofs += mtd->offset;
+	res = mtd->parent->_block_markbad(mtd->parent, ofs);
 	if (!res)
 		mtd->ecc_stats.badblocks++;
 	return res;
 }
 
-static inline void free_partition(struct mtd_part *p)
+static inline void free_partition(struct mtd_info *p)
 {
-	kfree(p->mtd.name);
+	kfree(p->name);
 	kfree(p);
 }
 
 /*
  * This function unregisters and destroy all slave MTD objects which are
- * attached to the given master MTD object.
+ * attached to the given master MTD object, recursively.
  */
+static int do_del_mtd_partitions(struct mtd_info *master)
+{
+	struct mtd_info *slave, *next;
+	int ret, err = 0;
+
+	list_for_each_entry_safe(slave, next, &master->partitions, node) {
+		if (mtd_has_partitions(slave))
+			del_mtd_partitions(slave);
+
+		debug("Deleting %s MTD partition\n", slave->name);
+		ret = del_mtd_device(slave);
+		if (ret < 0) {
+			printf("Error when deleting partition \"%s\" (%d)\n",
+			       slave->name, ret);
+			err = ret;
+			continue;
+		}
+
+		list_del(&slave->node);
+		free_partition(slave);
+	}
+
+	return err;
+}
 
 int del_mtd_partitions(struct mtd_info *master)
 {
-	struct mtd_part *slave, *next;
-	int ret, err = 0;
+	int ret;
+
+	debug("Deleting MTD partitions on \"%s\":\n", master->name);
 
 	mutex_lock(&mtd_partitions_mutex);
-	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
-		if (slave->master == master) {
-			ret = del_mtd_device(&slave->mtd);
-			if (ret < 0) {
-				err = ret;
-				continue;
-			}
-			list_del(&slave->list);
-			free_partition(slave);
-		}
+	ret = do_del_mtd_partitions(master);
 	mutex_unlock(&mtd_partitions_mutex);
 
-	return err;
+	return ret;
 }
 
-static struct mtd_part *allocate_partition(struct mtd_info *master,
-			const struct mtd_partition *part, int partno,
-			uint64_t cur_offset)
+static struct mtd_info *allocate_partition(struct mtd_info *master,
+					   const struct mtd_partition *part,
+					   int partno, uint64_t cur_offset)
 {
-	struct mtd_part *slave;
+	struct mtd_info *slave;
 	char *name;
 
 	/* allocate the partition structure */
@@ -398,83 +587,87 @@ static struct mtd_part *allocate_partition(struct mtd_info *master,
 	}
 
 	/* set up the MTD object for this partition */
-	slave->mtd.type = master->type;
-	slave->mtd.flags = master->flags & ~part->mask_flags;
-	slave->mtd.size = part->size;
-	slave->mtd.writesize = master->writesize;
-	slave->mtd.writebufsize = master->writebufsize;
-	slave->mtd.oobsize = master->oobsize;
-	slave->mtd.oobavail = master->oobavail;
-	slave->mtd.subpage_sft = master->subpage_sft;
-
-	slave->mtd.name = name;
-	slave->mtd.owner = master->owner;
+	slave->type = master->type;
+	slave->flags = master->flags & ~part->mask_flags;
+	slave->size = part->size;
+	slave->writesize = master->writesize;
+	slave->writebufsize = master->writebufsize;
+	slave->oobsize = master->oobsize;
+	slave->oobavail = master->oobavail;
+	slave->subpage_sft = master->subpage_sft;
+
+	slave->name = name;
+	slave->owner = master->owner;
 #ifndef __UBOOT__
-	slave->mtd.backing_dev_info = master->backing_dev_info;
+	slave->backing_dev_info = master->backing_dev_info;
 
 	/* NOTE:  we don't arrange MTDs as a tree; it'd be error-prone
 	 * to have the same data be in two different partitions.
 	 */
-	slave->mtd.dev.parent = master->dev.parent;
+	slave->dev.parent = master->dev.parent;
 #endif
 
-	slave->mtd._read = part_read;
-	slave->mtd._write = part_write;
+	if (master->_read)
+		slave->_read = part_read;
+	if (master->_write)
+		slave->_write = part_write;
 
 	if (master->_panic_write)
-		slave->mtd._panic_write = part_panic_write;
+		slave->_panic_write = part_panic_write;
 
 #ifndef __UBOOT__
 	if (master->_point && master->_unpoint) {
-		slave->mtd._point = part_point;
-		slave->mtd._unpoint = part_unpoint;
+		slave->_point = part_point;
+		slave->_unpoint = part_unpoint;
 	}
 #endif
 
 	if (master->_get_unmapped_area)
-		slave->mtd._get_unmapped_area = part_get_unmapped_area;
+		slave->_get_unmapped_area = part_get_unmapped_area;
 	if (master->_read_oob)
-		slave->mtd._read_oob = part_read_oob;
+		slave->_read_oob = part_read_oob;
 	if (master->_write_oob)
-		slave->mtd._write_oob = part_write_oob;
+		slave->_write_oob = part_write_oob;
 	if (master->_read_user_prot_reg)
-		slave->mtd._read_user_prot_reg = part_read_user_prot_reg;
+		slave->_read_user_prot_reg = part_read_user_prot_reg;
 	if (master->_read_fact_prot_reg)
-		slave->mtd._read_fact_prot_reg = part_read_fact_prot_reg;
+		slave->_read_fact_prot_reg = part_read_fact_prot_reg;
 	if (master->_write_user_prot_reg)
-		slave->mtd._write_user_prot_reg = part_write_user_prot_reg;
+		slave->_write_user_prot_reg = part_write_user_prot_reg;
 	if (master->_lock_user_prot_reg)
-		slave->mtd._lock_user_prot_reg = part_lock_user_prot_reg;
+		slave->_lock_user_prot_reg = part_lock_user_prot_reg;
 	if (master->_get_user_prot_info)
-		slave->mtd._get_user_prot_info = part_get_user_prot_info;
+		slave->_get_user_prot_info = part_get_user_prot_info;
 	if (master->_get_fact_prot_info)
-		slave->mtd._get_fact_prot_info = part_get_fact_prot_info;
+		slave->_get_fact_prot_info = part_get_fact_prot_info;
 	if (master->_sync)
-		slave->mtd._sync = part_sync;
+		slave->_sync = part_sync;
 #ifndef __UBOOT__
 	if (!partno && !master->dev.class && master->_suspend &&
 	    master->_resume) {
-			slave->mtd._suspend = part_suspend;
-			slave->mtd._resume = part_resume;
+		slave->_suspend = part_suspend;
+		slave->_resume = part_resume;
 	}
 	if (master->_writev)
-		slave->mtd._writev = part_writev;
+		slave->_writev = part_writev;
 #endif
 	if (master->_lock)
-		slave->mtd._lock = part_lock;
+		slave->_lock = part_lock;
 	if (master->_unlock)
-		slave->mtd._unlock = part_unlock;
+		slave->_unlock = part_unlock;
 	if (master->_is_locked)
-		slave->mtd._is_locked = part_is_locked;
+		slave->_is_locked = part_is_locked;
 	if (master->_block_isreserved)
-		slave->mtd._block_isreserved = part_block_isreserved;
+		slave->_block_isreserved = part_block_isreserved;
 	if (master->_block_isbad)
-		slave->mtd._block_isbad = part_block_isbad;
+		slave->_block_isbad = part_block_isbad;
 	if (master->_block_markbad)
-		slave->mtd._block_markbad = part_block_markbad;
-	slave->mtd._erase = part_erase;
-	slave->master = master;
+		slave->_block_markbad = part_block_markbad;
+	slave->_erase = part_erase;
+	slave->parent = master;
 	slave->offset = part->offset;
+	INIT_LIST_HEAD(&slave->partitions);
+	INIT_LIST_HEAD(&slave->node);
 
 	if (slave->offset == MTDPART_OFS_APPEND)
 		slave->offset = cur_offset;
@@ -490,41 +683,41 @@ static struct mtd_part *allocate_partition(struct mtd_info *master,
 	}
 	if (slave->offset == MTDPART_OFS_RETAIN) {
 		slave->offset = cur_offset;
-		if (master->size - slave->offset >= slave->mtd.size) {
-			slave->mtd.size = master->size - slave->offset
-							- slave->mtd.size;
+		if (master->size - slave->offset >= slave->size) {
+			slave->size = master->size - slave->offset
+							- slave->size;
 		} else {
 			debug("mtd partition \"%s\" doesn't have enough space: %#llx < %#llx, disabled\n",
 				part->name, master->size - slave->offset,
-				slave->mtd.size);
+				slave->size);
 			/* register to preserve ordering */
 			goto out_register;
 		}
 	}
-	if (slave->mtd.size == MTDPART_SIZ_FULL)
-		slave->mtd.size = master->size - slave->offset;
+	if (slave->size == MTDPART_SIZ_FULL)
+		slave->size = master->size - slave->offset;
 
 	debug("0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
-		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
+		(unsigned long long)(slave->offset + slave->size), slave->name);
 
 	/* let's do some sanity checks */
 	if (slave->offset >= master->size) {
 		/* let's register it anyway to preserve ordering */
 		slave->offset = 0;
-		slave->mtd.size = 0;
+		slave->size = 0;
 		printk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",
 			part->name);
 		goto out_register;
 	}
-	if (slave->offset + slave->mtd.size > master->size) {
-		slave->mtd.size = master->size - slave->offset;
+	if (slave->offset + slave->size > master->size) {
+		slave->size = master->size - slave->offset;
 		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
-			part->name, master->name, (unsigned long long)slave->mtd.size);
+		       part->name, master->name, slave->size);
 	}
 	if (master->numeraseregions > 1) {
 		/* Deal with variable erase size stuff */
 		int i, max = master->numeraseregions;
-		u64 end = slave->offset + slave->mtd.size;
+		u64 end = slave->offset + slave->size;
 		struct mtd_erase_region_info *regions = master->eraseregions;
 
 		/* Find the first erase regions which is part of this
@@ -537,44 +730,43 @@ static struct mtd_part *allocate_partition(struct mtd_info *master,
 
 		/* Pick biggest erasesize */
 		for (; i < max && regions[i].offset < end; i++) {
-			if (slave->mtd.erasesize < regions[i].erasesize) {
-				slave->mtd.erasesize = regions[i].erasesize;
-			}
+			if (slave->erasesize < regions[i].erasesize)
+				slave->erasesize = regions[i].erasesize;
 		}
-		BUG_ON(slave->mtd.erasesize == 0);
+		WARN_ON(slave->erasesize == 0);
 	} else {
 		/* Single erase size */
-		slave->mtd.erasesize = master->erasesize;
+		slave->erasesize = master->erasesize;
 	}
 
-	if ((slave->mtd.flags & MTD_WRITEABLE) &&
-	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
+	if ((slave->flags & MTD_WRITEABLE) &&
+	    mtd_mod_by_eb(slave->offset, slave)) {
 		/* Doesn't start on a boundary of major erase size */
 		/* FIXME: Let it be writable if it is on a boundary of
 		 * _minor_ erase size though */
-		slave->mtd.flags &= ~MTD_WRITEABLE;
+		slave->flags &= ~MTD_WRITEABLE;
 		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
 			part->name);
 	}
-	if ((slave->mtd.flags & MTD_WRITEABLE) &&
-	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
-		slave->mtd.flags &= ~MTD_WRITEABLE;
+	if ((slave->flags & MTD_WRITEABLE) &&
+	    mtd_mod_by_eb(slave->size, slave)) {
+		slave->flags &= ~MTD_WRITEABLE;
 		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
 			part->name);
 	}
 
-	slave->mtd.ecclayout = master->ecclayout;
-	slave->mtd.ecc_step_size = master->ecc_step_size;
-	slave->mtd.ecc_strength = master->ecc_strength;
-	slave->mtd.bitflip_threshold = master->bitflip_threshold;
+	slave->ecclayout = master->ecclayout;
+	slave->ecc_step_size = master->ecc_step_size;
+	slave->ecc_strength = master->ecc_strength;
+	slave->bitflip_threshold = master->bitflip_threshold;
 
 	if (master->_block_isbad) {
 		uint64_t offs = 0;
 
-		while (offs < slave->mtd.size) {
+		while (offs < slave->size) {
 			if (mtd_block_isbad(master, offs + slave->offset))
-				slave->mtd.ecc_stats.badblocks++;
-			offs += slave->mtd.erasesize;
+				slave->ecc_stats.badblocks++;
+			offs += slave->erasesize;
 		}
 	}
 
@@ -587,7 +779,7 @@ int mtd_add_partition(struct mtd_info *master, const char *name,
 		      long long offset, long long length)
 {
 	struct mtd_partition part;
-	struct mtd_part *p, *new;
+	struct mtd_info *p, *new;
 	uint64_t start, end;
 	int ret = 0;
 
@@ -616,21 +808,20 @@ int mtd_add_partition(struct mtd_info *master, const char *name,
 	end = offset + length;
 
 	mutex_lock(&mtd_partitions_mutex);
-	list_for_each_entry(p, &mtd_partitions, list)
-		if (p->master == master) {
-			if ((start >= p->offset) &&
-			    (start < (p->offset + p->mtd.size)))
-				goto err_inv;
-
-			if ((end >= p->offset) &&
-			    (end < (p->offset + p->mtd.size)))
-				goto err_inv;
-		}
+	list_for_each_entry(p, &master->partitions, node) {
+		if (start >= p->offset &&
+		    (start < (p->offset + p->size)))
+			goto err_inv;
+
+		if (end >= p->offset &&
+		    (end < (p->offset + p->size)))
+			goto err_inv;
+	}
 
-	list_add(&new->list, &mtd_partitions);
+	list_add_tail(&new->node, &master->partitions);
 	mutex_unlock(&mtd_partitions_mutex);
 
-	add_mtd_device(&new->mtd);
+	add_mtd_device(new);
 
 	return ret;
 err_inv:
@@ -642,18 +833,17 @@ EXPORT_SYMBOL_GPL(mtd_add_partition);
 
 int mtd_del_partition(struct mtd_info *master, int partno)
 {
-	struct mtd_part *slave, *next;
+	struct mtd_info *slave, *next;
 	int ret = -EINVAL;
 
 	mutex_lock(&mtd_partitions_mutex);
-	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
-		if ((slave->master == master) &&
-		    (slave->mtd.index == partno)) {
-			ret = del_mtd_device(&slave->mtd);
+	list_for_each_entry_safe(slave, next, &master->partitions, node)
+		if (slave->index == partno) {
+			ret = del_mtd_device(slave);
 			if (ret < 0)
 				break;
 
-			list_del(&slave->list);
+			list_del(&slave->node);
 			free_partition(slave);
 			break;
 		}
@@ -677,20 +867,10 @@ int add_mtd_partitions(struct mtd_info *master,
 		       const struct mtd_partition *parts,
 		       int nbparts)
 {
-	struct mtd_part *slave;
+	struct mtd_info *slave;
 	uint64_t cur_offset = 0;
 	int i;
 
-#ifdef __UBOOT__
-	/*
-	 * Need to init the list here, since LIST_INIT() does not
-	 * work on platforms where relocation has problems (like MIPS
-	 * & PPC).
-	 */
-	if (mtd_partitions.next == NULL)
-		INIT_LIST_HEAD(&mtd_partitions);
-#endif
-
 	debug("Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
 
 	for (i = 0; i < nbparts; i++) {
@@ -699,12 +879,12 @@ int add_mtd_partitions(struct mtd_info *master,
 			return PTR_ERR(slave);
 
 		mutex_lock(&mtd_partitions_mutex);
-		list_add(&slave->list, &mtd_partitions);
+		list_add_tail(&slave->node, &master->partitions);
 		mutex_unlock(&mtd_partitions_mutex);
 
-		add_mtd_device(&slave->mtd);
+		add_mtd_device(slave);
 
-		cur_offset = slave->offset + slave->mtd.size;
+		cur_offset = slave->offset + slave->size;
 	}
 
 	return 0;
@@ -807,29 +987,12 @@ int parse_mtd_partitions(struct mtd_info *master, const char *const *types,
 }
 #endif
 
-int mtd_is_partition(const struct mtd_info *mtd)
-{
-	struct mtd_part *part;
-	int ispart = 0;
-
-	mutex_lock(&mtd_partitions_mutex);
-	list_for_each_entry(part, &mtd_partitions, list)
-		if (&part->mtd == mtd) {
-			ispart = 1;
-			break;
-		}
-	mutex_unlock(&mtd_partitions_mutex);
-
-	return ispart;
-}
-EXPORT_SYMBOL_GPL(mtd_is_partition);
-
 /* Returns the size of the entire flash chip */
 uint64_t mtd_get_device_size(const struct mtd_info *mtd)
 {
-	if (!mtd_is_partition(mtd))
-		return mtd->size;
+	if (mtd_is_partition(mtd))
+		return mtd->parent->size;
 
-	return PART(mtd)->master->size;
+	return mtd->size;
 }
 EXPORT_SYMBOL_GPL(mtd_get_device_size);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 85b26d6088..b104b85a52 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -1,186 +1,14 @@
+config MTD_NAND_CORE
+	tristate
 
-menuconfig NAND
-	bool "NAND Device Support"
-if NAND
-
-config SYS_NAND_SELF_INIT
-	bool
-	help
-	  This option, if enabled, provides more flexible and linux-like
-	  NAND initialization process.
-
-config NAND_DENALI
-	bool "Support Denali NAND controller"
-	select SYS_NAND_SELF_INIT
-	imply CMD_NAND
-	help
-	  Enable support for the Denali NAND controller.
-
-config NAND_DENALI_DT
-	bool "Support Denali NAND controller as a DT device"
-	depends on NAND_DENALI && OF_CONTROL && DM
-	help
-	  Enable the driver for NAND flash on platforms using a Denali NAND
-	  controller as a DT device.
-
-config SYS_NAND_DENALI_64BIT
-	bool "Use 64-bit variant of Denali NAND controller"
-	depends on NAND_DENALI
-	help
-	  The Denali NAND controller IP has some variations in terms of
-	  the bus interface.  The DMA setup sequence is completely differenct
-	  between 32bit / 64bit AXI bus variants.
-
-	  If your Denali NAND controller is the 64-bit variant, say Y.
-	  Otherwise (32 bit), say N.
-
-config NAND_DENALI_SPARE_AREA_SKIP_BYTES
-	int "Number of bytes skipped in OOB area"
-	depends on NAND_DENALI
-	range 0 63
-	help
-	  This option specifies the number of bytes to skip from the beginning
-	  of OOB area before last ECC sector data starts.  This is potentially
-	  used to preserve the bad block marker in the OOB area.
-
-config NAND_VF610_NFC
-	bool "Support for Freescale NFC for VF610"
-	select SYS_NAND_SELF_INIT
-	imply CMD_NAND
-	help
-	  Enables support for NAND Flash Controller on some Freescale
-	  processors like the VF610, MCF54418 or Kinetis K70.
-	  The driver supports a maximum 2k page size. The driver
-	  currently does not support hardware ECC.
-
-choice
-	prompt "Hardware ECC strength"
-	depends on NAND_VF610_NFC
-	default SYS_NAND_VF610_NFC_45_ECC_BYTES
-	help
-	  Select the ECC strength used in the hardware BCH ECC block.
-
-config SYS_NAND_VF610_NFC_45_ECC_BYTES
-	bool "24-error correction (45 ECC bytes)"
-
-config SYS_NAND_VF610_NFC_60_ECC_BYTES
-	bool "32-error correction (60 ECC bytes)"
-
-endchoice
-
-config NAND_PXA3XX
-	bool "Support for NAND on PXA3xx and Armada 370/XP/38x"
-	select SYS_NAND_SELF_INIT
-	imply CMD_NAND
-	help
-	  This enables the driver for the NAND flash device found on
-	  PXA3xx processors (NFCv1) and also on Armada 370/XP (NFCv2).
-
-config NAND_SUNXI
-	bool "Support for NAND on Allwinner SoCs"
-	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I
-	select SYS_NAND_SELF_INIT
-	select SYS_NAND_U_BOOT_LOCATIONS
-	imply CMD_NAND
-	---help---
-	Enable support for NAND. This option enables the standard and
-	SPL drivers.
-	The SPL driver only supports reading from the NAND using DMA
-	transfers.
-
-if NAND_SUNXI
-
-config NAND_SUNXI_SPL_ECC_STRENGTH
-	int "Allwinner NAND SPL ECC Strength"
-	default 64
-
-config NAND_SUNXI_SPL_ECC_SIZE
-	int "Allwinner NAND SPL ECC Step Size"
-	default 1024
-
-config NAND_SUNXI_SPL_USABLE_PAGE_SIZE
-	int "Allwinner NAND SPL Usable Page Size"
-	default 1024
-
-endif
-
-config NAND_ARASAN
-	bool "Configure Arasan Nand"
-	imply CMD_NAND
+config MTD_NAND_BBT_USING_FLASH
+	bool "Mtd Nand BBT using flash management strategy"
+	default n
 	help
-	  This enables Nand driver support for Arasan nand flash
-	  controller. This uses the hardware ECC for read and
-	  write operations.
-
-config NAND_MXS
-	bool "MXS NAND support"
-	depends on MX6 || MX7
-	imply CMD_NAND
-	help
-	  This enables NAND driver for the NAND flash controller on the
-	  MXS processors.
-
-config NAND_ZYNQ
-	bool "Support for Zynq Nand controller"
-	select SYS_NAND_SELF_INIT
-	imply CMD_NAND
-	help
-	  This enables Nand driver support for Nand flash controller
-	  found on Zynq SoC.
-
-comment "Generic NAND options"
+	  This is a simple flash BBT management strategy for Nand devices.
 
-# Enhance depends when converting drivers to Kconfig which use this config
-# option (mxc_nand, ndfc, omap_gpmc).
-config SYS_NAND_BUSWIDTH_16BIT
-	bool "Use 16-bit NAND interface"
-	depends on NAND_VF610_NFC
-	help
-	  Indicates that NAND device has 16-bit wide data-bus. In absence of this
-	  config, bus-width of NAND device is assumed to be either 8-bit and later
-	  determined by reading ONFI params.
-	  Above config is useful when NAND device's bus-width information cannot
-	  be determined from on-chip ONFI params, like in following scenarios:
-	  - SPL boot does not support reading of ONFI parameters. This is done to
-	    keep SPL code foot-print small.
-	  - In current U-Boot flow using nand_init(), driver initialization
-	    happens in board_nand_init() which is called before any device probe
-	    (nand_scan_ident + nand_scan_tail), thus device's ONFI parameters are
-	    not available while configuring controller. So a static CONFIG_NAND_xx
-	    is needed to know the device's bus-width in advance.
-
-if SPL
-
-config SYS_NAND_U_BOOT_LOCATIONS
-	bool "Define U-boot binaries locations in NAND"
-	help
-	Enable CONFIG_SYS_NAND_U_BOOT_OFFS though Kconfig.
-	This option should not be enabled when compiling U-boot for boards
-	defining CONFIG_SYS_NAND_U_BOOT_OFFS in their include/configs/<board>.h
-	file.
-
-config SYS_NAND_U_BOOT_OFFS
-	hex "Location in NAND to read U-Boot from"
-	default 0x800000 if NAND_SUNXI
-	depends on SYS_NAND_U_BOOT_LOCATIONS
-	help
-	Set the offset from the start of the nand where u-boot should be
-	loaded from.
-
-config SYS_NAND_U_BOOT_OFFS_REDUND
-	hex "Location in NAND to read U-Boot from"
-	default SYS_NAND_U_BOOT_OFFS
-	depends on SYS_NAND_U_BOOT_LOCATIONS
-	help
-	Set the offset from the start of the nand where the redundant u-boot
-	should be loaded from.
-
-config SPL_NAND_DENALI
-	bool "Support Denali NAND controller for SPL"
-	help
-	  This is a small implementation of the Denali NAND controller
-	  for use on SPL.
+	  Say Y when you want to use BBT in flash.
 
-endif
+source "drivers/mtd/nand/raw/Kconfig"
 
-endif   # if NAND
+source "drivers/mtd/nand/spi/Kconfig"
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 9f7d9d6ff7..a358bc680e 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -1,78 +1,5 @@
-#
-# (C) Copyright 2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
+# SPDX-License-Identifier: GPL-2.0+
 
-ifdef CONFIG_SPL_BUILD
-
-ifdef CONFIG_SPL_NAND_DRIVERS
-NORMAL_DRIVERS=y
-endif
-
-obj-$(CONFIG_SPL_NAND_AM33XX_BCH) += am335x_spl_bch.o
-obj-$(CONFIG_SPL_NAND_DENALI) += denali_spl.o
-obj-$(CONFIG_SPL_NAND_SIMPLE) += nand_spl_simple.o
-obj-$(CONFIG_SPL_NAND_LOAD) += nand_spl_load.o
-obj-$(CONFIG_SPL_NAND_ECC) += nand_ecc.o
-obj-$(CONFIG_SPL_NAND_BASE) += nand_base.o
-obj-$(CONFIG_SPL_NAND_INIT) += nand.o
-ifeq ($(CONFIG_SPL_ENV_SUPPORT),y)
-obj-$(CONFIG_ENV_IS_IN_NAND) += nand_util.o
-endif
-
-else # not spl
-
-NORMAL_DRIVERS=y
-
-obj-y += nand.o
-obj-y += nand_bbt.o
-obj-y += nand_ids.o
-obj-y += nand_util.o
-obj-y += nand_ecc.o
-obj-y += nand_base.o
-obj-y += nand_timings.o
-
-endif # not spl
-
-ifdef NORMAL_DRIVERS
-
-obj-$(CONFIG_NAND_ECC_BCH) += nand_bch.o
-
-obj-$(CONFIG_NAND_ATMEL) += atmel_nand.o
-obj-$(CONFIG_NAND_ARASAN) += arasan_nfc.o
-obj-$(CONFIG_NAND_DAVINCI) += davinci_nand.o
-obj-$(CONFIG_NAND_DENALI) += denali.o
-obj-$(CONFIG_NAND_DENALI_DT) += denali_dt.o
-obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_nand.o
-obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_nand.o
-obj-$(CONFIG_NAND_FSL_UPM) += fsl_upm.o
-obj-$(CONFIG_NAND_FSMC) += fsmc_nand.o
-obj-$(CONFIG_NAND_KB9202) += kb9202_nand.o
-obj-$(CONFIG_NAND_KIRKWOOD) += kirkwood_nand.o
-obj-$(CONFIG_NAND_KMETER1) += kmeter1_nand.o
-obj-$(CONFIG_NAND_LPC32XX_MLC) += lpc32xx_nand_mlc.o
-obj-$(CONFIG_NAND_LPC32XX_SLC) += lpc32xx_nand_slc.o
-obj-$(CONFIG_NAND_VF610_NFC) += vf610_nfc.o
-obj-$(CONFIG_NAND_MXC) += mxc_nand.o
-obj-$(CONFIG_NAND_MXS) += mxs_nand.o
-obj-$(CONFIG_NAND_NDFC) += ndfc.o
-obj-$(CONFIG_NAND_PXA3XX) += pxa3xx_nand.o
-obj-$(CONFIG_NAND_SPEAR) += spr_nand.o
-obj-$(CONFIG_TEGRA_NAND) += tegra_nand.o
-obj-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
-obj-$(CONFIG_NAND_OMAP_ELM) += omap_elm.o
-obj-$(CONFIG_NAND_PLAT) += nand_plat.o
-obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
-obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
-
-else  # minimal SPL drivers
-
-obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_spl.o
-obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_spl.o
-obj-$(CONFIG_NAND_MXC) += mxc_nand_spl.o
-obj-$(CONFIG_NAND_MXS) += mxs_nand_spl.o mxs_nand.o
-obj-$(CONFIG_NAND_SUNXI) += sunxi_nand_spl.o
-
-endif # drivers
+nandcore-objs := core.o bbt.o
+obj-$(CONFIG_MTD_NAND_CORE) += nandcore.o
+obj-$(CONFIG_MTD_SPI_NAND) += spi/
diff --git a/drivers/mtd/onenand/onenand_base.c b/drivers/mtd/onenand/onenand_base.c
index 8282f683a5..371e2ecaa7 100644
--- a/drivers/mtd/onenand/onenand_base.c
+++ b/drivers/mtd/onenand/onenand_base.c
@@ -858,7 +858,8 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 	int ret = 0, boundary = 0;
 	int writesize = this->writesize;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+	pr_debug("onenand_read_ops_nolock: from = 0x%08x, len = %i\n",
+		 (unsigned int) from, (int) len);
 
 	if (ops->mode == MTD_OPS_AUTO_OOB)
 		oobsize = this->ecclayout->oobavail;
@@ -1007,7 +1008,8 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 
 	from += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+	pr_debug("onenand_read_oob_nolock: from = 0x%08x, len = %i\n",
+		 (unsigned int) from, (int) len);
 
 	/* Initialize return length value */
 	ops->oobretlen = 0;
@@ -1214,7 +1216,8 @@ int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 	size_t len = ops->ooblen;
 	u_char *buf = ops->oobbuf;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);
+	pr_debug("onenand_bbt_read_oob: from = 0x%08x, len = %zi\n",
+		 (unsigned int) from, len);
 
 	readcmd = ONENAND_IS_4KB_PAGE(this) ?
 		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
@@ -1417,7 +1420,8 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 	u_char *oobbuf;
 	int ret = 0;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	pr_debug("onenand_write_ops_nolock: to = 0x%08x, len = %i\n",
+		 (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->retlen = 0;
@@ -1538,7 +1542,8 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 
 	to += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	pr_debug("onenand_write_oob_nolock: to = 0x%08x, len = %i\n",
+		 (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->oobretlen = 0;
@@ -1730,7 +1735,7 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 	struct mtd_erase_region_info *region = NULL;
 	unsigned int region_end = 0;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
+	pr_debug("onenand_erase: start = 0x%08x, len = %i\n",
 			(unsigned int) addr, len);
 
 	if (FLEXONENAND(this)) {
@@ -1746,8 +1751,7 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 		 * Erase region's start offset is always block start address.
 		 */
 		if (unlikely((addr - region->offset) & (block_size - 1))) {
-			MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
-				" Unaligned address\n");
+			pr_debug("onenand_erase:" " Unaligned address\n");
 			return -EINVAL;
 		}
 	} else {
@@ -1755,16 +1759,14 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 
 		/* Start address must align on block boundary */
 		if (unlikely(addr & (block_size - 1))) {
-			MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
-						"Unaligned address\n");
+			pr_debug("onenand_erase:" "Unaligned address\n");
 			return -EINVAL;
 		}
 	}
 
 	/* Length must align on block boundary */
 	if (unlikely(len & (block_size - 1))) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			 "onenand_erase: Length not block aligned\n");
+		pr_debug("onenand_erase: Length not block aligned\n");
 		return -EINVAL;
 	}
 
@@ -1793,12 +1795,12 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 		/* Check, if it is write protected */
 		if (ret) {
 			if (ret == -EPERM)
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
-					  "Device is write protected!!!\n");
+				pr_debug("onenand_erase: "
+					 "Device is write protected!!!\n");
 			else
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
-					  "Failed erase, block %d\n",
-					onenand_block(this, addr));
+				pr_debug("onenand_erase: "
+					 "Failed erase, block %d\n",
+					 onenand_block(this, addr));
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = addr;
 
@@ -1849,7 +1851,7 @@ erase_exit:
  */
 void onenand_sync(struct mtd_info *mtd)
 {
-	MTDDEBUG (MTD_DEBUG_LEVEL3, "onenand_sync: called\n");
+	pr_debug("onenand_sync: called\n");
 
 	/* Grab the lock and see if the device is available */
 	onenand_get_device(mtd, FL_SYNCING);
@@ -2654,8 +2656,6 @@ int onenand_probe(struct mtd_info *mtd)
 
 	mtd->flags = MTD_CAP_NANDFLASH;
 	mtd->_erase = onenand_erase;
-	mtd->_read = onenand_read;
-	mtd->_write = onenand_write;
 	mtd->_read_oob = onenand_read_oob;
 	mtd->_write_oob = onenand_write_oob;
 	mtd->_sync = onenand_sync;
diff --git a/drivers/mtd/onenand/onenand_bbt.c b/drivers/mtd/onenand/onenand_bbt.c
index 20507004ed..cde342aaec 100644
--- a/drivers/mtd/onenand/onenand_bbt.c
+++ b/drivers/mtd/onenand/onenand_bbt.c
@@ -160,9 +160,8 @@ static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
 	block = (int) (onenand_block(this, offs) << 1);
 	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
 
-	MTDDEBUG (MTD_DEBUG_LEVEL2,
-		"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
-		(unsigned int)offs, block >> 1, res);
+	pr_debug("onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
+		 (unsigned int)offs, block >> 1, res);
 
 	switch ((int)res) {
 	case 0x00:
diff --git a/drivers/mtd/pic32_flash.c b/drivers/mtd/pic32_flash.c
index e1a8d3bc4b..d908387866 100644
--- a/drivers/mtd/pic32_flash.c
+++ b/drivers/mtd/pic32_flash.c
@@ -66,10 +66,10 @@ static inline void flash_initiate_operation(u32 nvmop)
 
 static int flash_wait_till_busy(const char *func, ulong timeout)
 {
-	int ret = wait_for_bit(__func__, &nvm_regs_p->ctrl.raw,
-			       NVM_WR, false, timeout, false);
+	int ret = wait_for_bit_le32(&nvm_regs_p->ctrl.raw,
+				    NVM_WR, false, timeout, false);
 
-	return ret ? ERR_TIMOUT : ERR_OK;
+	return ret ? ERR_TIMEOUT : ERR_OK;
 }
 
 static inline int flash_complete_operation(void)
@@ -99,7 +99,7 @@ static inline int flash_complete_operation(void)
  * Erase flash sectors, returns:
  * ERR_OK - OK
  * ERR_INVAL - invalid sector arguments
- * ERR_TIMOUT - write timeout
+ * ERR_TIMEOUT - write timeout
  * ERR_NOT_ERASED - Flash not erased
  * ERR_UNKNOWN_FLASH_VENDOR - incorrect flash
  */
@@ -217,7 +217,7 @@ static int write_word(flash_info_t *info, ulong dest, ulong word)
 /*
  * Copy memory to flash, returns:
  * ERR_OK - OK
- * ERR_TIMOUT - write timeout
+ * ERR_TIMEOUT - write timeout
  * ERR_NOT_ERASED - Flash not erased
  */
 int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt)
diff --git a/drivers/mtd/spi/Kconfig b/drivers/mtd/spi/Kconfig
index 5700859ff2..ea256188c0 100644
--- a/drivers/mtd/spi/Kconfig
+++ b/drivers/mtd/spi/Kconfig
@@ -26,17 +26,69 @@ config SPI_FLASH_SANDBOX
 	  stored in a file on the host filesystem.
 
 config SPI_FLASH
-	bool "Legacy SPI Flash Interface support"
+	bool "SPI Flash Core Interface support"
+	select SPI_MEM
 	help
-	  Enable the legacy SPI flash support. This will include basic
+	  Enable the SPI flash Core support. This will include basic
 	  standard support for things like probing, read / write, and
 	  erasing through cmd_sf interface.
 
 	  If unsure, say N
 
+config SF_DEFAULT_BUS
+	int "SPI Flash default bus identifier"
+	depends on SPI_FLASH || DM_SPI_FLASH
+	default 0
+	help
+	  The default bus may be provided by the platform
+	  to handle the common case when only a single serial
+	  flash is present on the system.
+
+config SF_DEFAULT_CS
+	int "SPI Flash default Chip-select"
+	depends on SPI_FLASH || DM_SPI_FLASH
+	default 0
+	help
+	  The default chip select may be provided by the platform
+	  to handle the common case when only a single serial
+	  flash is present on the system.
+
+config SF_DEFAULT_MODE
+	hex "SPI Flash default mode (see include/spi.h)"
+	depends on SPI_FLASH || DM_SPI_FLASH
+	default 3
+	help
+	  The default mode may be provided by the platform
+	  to handle the common case when only a single serial
+	  flash is present on the system.
+	  Not used for boot with device tree; the SPI driver reads
+	  speed and mode from platdata values computed from
+	  available node.
+
+config SF_DEFAULT_SPEED
+	int "SPI Flash default speed in Hz"
+	depends on SPI_FLASH || DM_SPI_FLASH
+	default 1000000
+	help
+	  The default speed may be provided by the platform
+	  to handle the common case when only a single serial
+	  flash is present on the system.
+	  Not used for boot with device tree; the SPI driver reads
+	  speed and mode from platdata values computed from
+	  available node.
+
+if SPI_FLASH
+
+config SPI_FLASH_SFDP_SUPPORT
+	bool "SFDP table parsing support for SPI NOR flashes"
+	depends on !SPI_FLASH_BAR
+	help
+	 Enable support for parsing and auto discovery of parameters for
+	 SPI NOR flashes using Serial Flash Discoverable Parameters (SFDP)
+	 tables as per JESD216 standard.
+
 config SPI_FLASH_BAR
 	bool "SPI flash Bank/Extended address register support"
-	depends on SPI_FLASH
 	help
 	  Enable the SPI flash Bank/Extended address register support.
 	  Bank/Extended address registers are used to access the flash
@@ -44,13 +96,10 @@ config SPI_FLASH_BAR
 
 config SF_DUAL_FLASH
 	bool "SPI DUAL flash memory support"
-	depends on SPI_FLASH
 	help
 	  Enable this option to support two flash memories connected to a single
 	  controller. Currently Xilinx Zynq qspi supports this.
 
-if SPI_FLASH
-
 config SPI_FLASH_ATMEL
 	bool "Atmel SPI flash support"
 	help
@@ -66,6 +115,11 @@ config SPI_FLASH_GIGADEVICE
 	help
 	  Add support for various GigaDevice SPI flash chips (GD25xxx)
 
+config SPI_FLASH_ISSI
+	bool "ISSI SPI flash support"
+	help
+	  Add support for various ISSI SPI flash chips (ISxxx)
+
 config SPI_FLASH_MACRONIX
 	bool "Macronix SPI flash support"
 	help
@@ -91,6 +145,30 @@ config SPI_FLASH_WINBOND
 	help
 	  Add support for various Winbond SPI flash chips (W25xxx)
 
+config SPI_FLASH_XMC
+	bool "XMC SPI flash support"
+	help
+	  Add support for various XMC (Wuhan Xinxin Semiconductor
+	  Manufacturing Corp.) SPI flash chips (XM25xxx)
+
+config SPI_FLASH_XTX
+	bool "XTX SPI flash support"
+	help
+	  Add support for various XTX (XTX Technology Limited)
+	  SPI flash chips (XT25xxx).
+
+config SPI_FLASH_PUYA
+	bool "PUYA SPI flash support"
+	help
+	  Add support for various PUYA (PUYA Semiconductor (Shangehai) Co., Ltd)
+	  SPI flash chips (P25Qxxx and PS25Qxxxx).
+
+config SPI_FLASH_FMSH
+	bool "FMSH SPI flash support"
+	help
+	  Add support for various FMSH (FUDAN MICRO (Shangehai) Co., Ltd)
+	  SPI flash chips (FM25Qxxx).
+
 endif
 
 config SPI_FLASH_USE_4K_SECTORS
@@ -135,16 +213,12 @@ config SPI_FLASH_MTD
 
 	  If unsure, say N
 
-if SPL
-
-config SPL_SPI_SUNXI
-	bool "Support for SPI Flash on Allwinner SoCs in SPL"
-	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNXI_H3_H5 || MACH_SUN50I
-	---help---
-	Enable support for SPI Flash. This option allows SPL to read from
-	sunxi SPI Flash. It uses the same method as the boot ROM, so does
-	not need any extra configuration.
+config SPL_SPI_FLASH_MTD
+	bool "SPI flash MTD support for SPL"
+	depends on SPI_FLASH
+	help
+          Enable the MTD support for the SPI flash layer in SPL.
 
-endif
+	  If unsure, say N
 
 endmenu # menu "SPI Flash Support"
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index fcda023412..232231e114 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -6,13 +6,20 @@
 #
 
 obj-$(CONFIG_DM_SPI_FLASH) += sf-uclass.o
+spi-nor-y := sf_probe.o spi-nor-ids.o
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_SPI_BOOT)	+= fsl_espi_spl.o
-obj-$(CONFIG_SPL_SPI_SUNXI)	+= sunxi_spi_spl.o
+ifeq ($(CONFIG_SPL_SPI_FLASH_TINY),y)
+spi-nor-y += spi-nor-tiny.o
+else
+spi-nor-y += spi-nor-core.o
+endif
+else
+spi-nor-y += spi-nor-core.o
 endif
 
-obj-$(CONFIG_SPI_FLASH) += sf_probe.o spi_flash.o spi_flash_ids.o sf.o
+obj-$(CONFIG_SPI_FLASH) += spi-nor.o
 obj-$(CONFIG_SPI_FLASH_DATAFLASH) += sf_dataflash.o
 obj-$(CONFIG_SPI_FLASH_MTD) += sf_mtd.o
 obj-$(CONFIG_SPI_FLASH_SANDBOX) += sandbox.o
diff --git a/drivers/mtd/spi/sandbox.c b/drivers/mtd/spi/sandbox.c
index 1ba6815232..31714d24cd 100644
--- a/drivers/mtd/spi/sandbox.c
+++ b/drivers/mtd/spi/sandbox.c
@@ -8,6 +8,8 @@
  * Licensed under the GPL-2 or later.
  */
 
+#define LOG_CATEGORY UCLASS_SPI_FLASH
+
 #include <common.h>
 #include <dm.h>
 #include <malloc.h>
@@ -43,6 +45,7 @@ enum sandbox_sf_state {
 	SF_WRITE_STATUS, /* write the flash's status register */
 };
 
+#if CONFIG_IS_ENABLED(LOG)
 static const char *sandbox_sf_state_name(enum sandbox_sf_state state)
 {
 	static const char * const states[] = {
@@ -51,10 +54,13 @@ static const char *sandbox_sf_state_name(enum sandbox_sf_state state)
 	};
 	return states[state];
 }
+#endif /* LOG */
 
 /* Bits for the status register */
 #define STAT_WIP	(1 << 0)
 #define STAT_WEL	(1 << 1)
+#define STAT_BP_SHIFT	2
+#define STAT_BP_MASK	(7 << STAT_BP_SHIFT)
 
 /* Assume all SPI flashes have 3 byte addresses since they do atm */
 #define SF_ADDR_LEN	3
@@ -88,7 +94,7 @@ struct sandbox_spi_flash {
 	/* The current flash status (see STAT_XXX defines above) */
 	u16 status;
 	/* Data describing the flash we're emulating */
-	const struct spi_flash_info *data;
+	const struct flash_info *data;
 	/* The file on disk to serv up data from */
 	int fd;
 };
@@ -100,75 +106,58 @@ struct sandbox_spi_flash_plat_data {
 	int cs;
 };
 
+void sandbox_sf_set_block_protect(struct udevice *dev, int bp_mask)
+{
+	struct sandbox_spi_flash *sbsf = dev_get_priv(dev);
+
+	sbsf->status &= ~STAT_BP_MASK;
+	sbsf->status |= bp_mask << STAT_BP_SHIFT;
+}
+
 /**
  * This is a very strange probe function. If it has platform data (which may
  * have come from the device tree) then this function gets the filename and
- * device type from there. Failing that it looks at the command line
- * parameter.
+ * device type from there.
  */
 static int sandbox_sf_probe(struct udevice *dev)
 {
 	/* spec = idcode:file */
 	struct sandbox_spi_flash *sbsf = dev_get_priv(dev);
-	const char *file;
 	size_t len, idname_len;
-	const struct spi_flash_info *data;
+	const struct flash_info *data;
 	struct sandbox_spi_flash_plat_data *pdata = dev_get_platdata(dev);
 	struct sandbox_state *state = state_get_current();
+	struct dm_spi_slave_platdata *slave_plat;
 	struct udevice *bus = dev->parent;
 	const char *spec = NULL;
+	struct udevice *emul;
 	int ret = 0;
 	int cs = -1;
-	int i;
 
 	debug("%s: bus %d, looking for emul=%p: ", __func__, bus->seq, dev);
-	if (bus->seq >= 0 && bus->seq < CONFIG_SANDBOX_SPI_MAX_BUS) {
-		for (i = 0; i < CONFIG_SANDBOX_SPI_MAX_CS; i++) {
-			if (state->spi[bus->seq][i].emul == dev)
-				cs = i;
-		}
-	}
-	if (cs == -1) {
+	ret = sandbox_spi_get_emul(state, bus, dev, &emul);
+	if (ret) {
 		printf("Error: Unknown chip select for device '%s'\n",
-		       dev->name);
-		return -EINVAL;
+			dev->name);
+		return ret;
 	}
+	slave_plat = dev_get_parent_platdata(dev);
+	cs = slave_plat->cs;
 	debug("found at cs %d\n", cs);
 
 	if (!pdata->filename) {
-		struct sandbox_state *state = state_get_current();
-
-		assert(bus->seq != -1);
-		if (bus->seq < CONFIG_SANDBOX_SPI_MAX_BUS)
-			spec = state->spi[bus->seq][cs].spec;
-		if (!spec) {
-			debug("%s:  No spec found for bus %d, cs %d\n",
-			      __func__, bus->seq, cs);
-			ret = -ENOENT;
-			goto error;
-		}
-
-		file = strchr(spec, ':');
-		if (!file) {
-			printf("%s: unable to parse file\n", __func__);
-			ret = -EINVAL;
-			goto error;
-		}
-		idname_len = file - spec;
-		pdata->filename = file + 1;
-		pdata->device_name = spec;
-		++file;
-	} else {
-		spec = strchr(pdata->device_name, ',');
-		if (spec)
-			spec++;
-		else
-			spec = pdata->device_name;
-		idname_len = strlen(spec);
+		printf("Error: No filename available\n");
+		return -EINVAL;
 	}
+	spec = strchr(pdata->device_name, ',');
+	if (spec)
+		spec++;
+	else
+		spec = pdata->device_name;
+	idname_len = strlen(spec);
 	debug("%s: device='%s'\n", __func__, spec);
 
-	for (data = spi_flash_ids; data->name; data++) {
+	for (data = spi_nor_ids; data->name; data++) {
 		len = strlen(data->name);
 		if (idname_len != len)
 			continue;
@@ -216,7 +205,7 @@ static void sandbox_sf_cs_activate(struct udevice *dev)
 {
 	struct sandbox_spi_flash *sbsf = dev_get_priv(dev);
 
-	debug("sandbox_sf: CS activated; state is fresh!\n");
+	log_content("sandbox_sf: CS activated; state is fresh!\n");
 
 	/* CS is asserted, so reset state */
 	sbsf->off = 0;
@@ -228,7 +217,7 @@ static void sandbox_sf_cs_activate(struct udevice *dev)
 
 static void sandbox_sf_cs_deactivate(struct udevice *dev)
 {
-	debug("sandbox_sf: CS deactivated; cmd done processing!\n");
+	log_content("sandbox_sf: CS deactivated; cmd done processing!\n");
 }
 
 /*
@@ -256,43 +245,43 @@ static int sandbox_sf_process_cmd(struct sandbox_spi_flash *sbsf, const u8 *rx,
 
 	sbsf->cmd = rx[0];
 	switch (sbsf->cmd) {
-	case CMD_READ_ID:
+	case SPINOR_OP_RDID:
 		sbsf->state = SF_ID;
 		sbsf->cmd = SF_ID;
 		break;
-	case CMD_READ_ARRAY_FAST:
+	case SPINOR_OP_READ_FAST:
 		sbsf->pad_addr_bytes = 1;
-	case CMD_READ_ARRAY_SLOW:
-	case CMD_PAGE_PROGRAM:
+	case SPINOR_OP_READ:
+	case SPINOR_OP_PP:
 		sbsf->state = SF_ADDR;
 		break;
-	case CMD_WRITE_DISABLE:
+	case SPINOR_OP_WRDI:
 		debug(" write disabled\n");
 		sbsf->status &= ~STAT_WEL;
 		break;
-	case CMD_READ_STATUS:
+	case SPINOR_OP_RDSR:
 		sbsf->state = SF_READ_STATUS;
 		break;
-	case CMD_READ_STATUS1:
+	case SPINOR_OP_RDSR2:
 		sbsf->state = SF_READ_STATUS1;
 		break;
-	case CMD_WRITE_ENABLE:
+	case SPINOR_OP_WREN:
 		debug(" write enabled\n");
 		sbsf->status |= STAT_WEL;
 		break;
-	case CMD_WRITE_STATUS:
+	case SPINOR_OP_WRSR:
 		sbsf->state = SF_WRITE_STATUS;
 		break;
 	default: {
 		int flags = sbsf->data->flags;
 
 		/* we only support erase here */
-		if (sbsf->cmd == CMD_ERASE_CHIP) {
+		if (sbsf->cmd == SPINOR_OP_CHIP_ERASE) {
 			sbsf->erase_size = sbsf->data->sector_size *
 				sbsf->data->n_sectors;
-		} else if (sbsf->cmd == CMD_ERASE_4K && (flags & SECT_4K)) {
+		} else if (sbsf->cmd == SPINOR_OP_BE_4K && (flags & SECT_4K)) {
 			sbsf->erase_size = 4 << 10;
-		} else if (sbsf->cmd == CMD_ERASE_64K && !(flags & SECT_4K)) {
+		} else if (sbsf->cmd == SPINOR_OP_SE && !(flags & SECT_4K)) {
 			sbsf->erase_size = 64 << 10;
 		} else {
 			debug(" cmd unknown: %#x\n", sbsf->cmd);
@@ -304,8 +293,8 @@ static int sandbox_sf_process_cmd(struct sandbox_spi_flash *sbsf, const u8 *rx,
 	}
 
 	if (oldstate != sbsf->state)
-		debug(" cmd: transition to %s state\n",
-		      sandbox_sf_state_name(sbsf->state));
+		log_content(" cmd: transition to %s state\n",
+			    sandbox_sf_state_name(sbsf->state));
 
 	return 0;
 }
@@ -336,8 +325,8 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 	int bytes = bitlen / 8;
 	int ret;
 
-	debug("sandbox_sf: state:%x(%s) bytes:%u\n", sbsf->state,
-	      sandbox_sf_state_name(sbsf->state), bytes);
+	log_content("sandbox_sf: state:%x(%s) bytes:%u\n", sbsf->state,
+		    sandbox_sf_state_name(sbsf->state), bytes);
 
 	if ((flags & SPI_XFER_BEGIN))
 		sandbox_sf_cs_activate(dev);
@@ -356,7 +345,7 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 		case SF_ID: {
 			u8 id;
 
-			debug(" id: off:%u tx:", sbsf->off);
+			log_content(" id: off:%u tx:", sbsf->off);
 			if (sbsf->off < IDCODE_LEN) {
 				/* Extract correct byte from ID 0x00aabbcc */
 				id = ((JEDEC_MFR(sbsf->data) << 16) |
@@ -365,18 +354,18 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 			} else {
 				id = 0;
 			}
-			debug("%d %02x\n", sbsf->off, id);
+			log_content("%d %02x\n", sbsf->off, id);
 			tx[pos++] = id;
 			++sbsf->off;
 			break;
 		}
 		case SF_ADDR:
-			debug(" addr: bytes:%u rx:%02x ", sbsf->addr_bytes,
-			      rx[pos]);
+			log_content(" addr: bytes:%u rx:%02x ",
+				    sbsf->addr_bytes, rx[pos]);
 
 			if (sbsf->addr_bytes++ < SF_ADDR_LEN)
 				sbsf->off = (sbsf->off << 8) | rx[pos];
-			debug("addr:%06x\n", sbsf->off);
+			log_content("addr:%06x\n", sbsf->off);
 
 			if (tx)
 				sandbox_spi_tristate(&tx[pos], 1);
@@ -393,11 +382,11 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 				return -EIO;
 			}
 			switch (sbsf->cmd) {
-			case CMD_READ_ARRAY_FAST:
-			case CMD_READ_ARRAY_SLOW:
+			case SPINOR_OP_READ_FAST:
+			case SPINOR_OP_READ:
 				sbsf->state = SF_READ;
 				break;
-			case CMD_PAGE_PROGRAM:
+			case SPINOR_OP_PP:
 				sbsf->state = SF_WRITE;
 				break;
 			default:
@@ -405,8 +394,8 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 				sbsf->state = SF_ERASE;
 				goto case_sf_erase;
 			}
-			debug(" cmd: transition to %s state\n",
-			      sandbox_sf_state_name(sbsf->state));
+			log_content(" cmd: transition to %s state\n",
+				    sandbox_sf_state_name(sbsf->state));
 			break;
 		case SF_READ:
 			/*
@@ -415,7 +404,7 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 			 */
 
 			cnt = bytes - pos;
-			debug(" tx: read(%u)\n", cnt);
+			log_content(" tx: read(%u)\n", cnt);
 			assert(tx);
 			ret = os_read(sbsf->fd, tx + pos, cnt);
 			if (ret < 0) {
@@ -425,19 +414,19 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 			pos += ret;
 			break;
 		case SF_READ_STATUS:
-			debug(" read status: %#x\n", sbsf->status);
+			log_content(" read status: %#x\n", sbsf->status);
 			cnt = bytes - pos;
 			memset(tx + pos, sbsf->status, cnt);
 			pos += cnt;
 			break;
 		case SF_READ_STATUS1:
-			debug(" read status: %#x\n", sbsf->status);
+			log_content(" read status: %#x\n", sbsf->status);
 			cnt = bytes - pos;
 			memset(tx + pos, sbsf->status >> 8, cnt);
 			pos += cnt;
 			break;
 		case SF_WRITE_STATUS:
-			debug(" write status: %#x (ignored)\n", rx[pos]);
+			log_content(" write status: %#x (ignored)\n", rx[pos]);
 			pos = bytes;
 			break;
 		case SF_WRITE:
@@ -453,7 +442,7 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 			}
 
 			cnt = bytes - pos;
-			debug(" rx: write(%u)\n", cnt);
+			log_content(" rx: write(%u)\n", cnt);
 			if (tx)
 				sandbox_spi_tristate(&tx[pos], cnt);
 			ret = os_write(sbsf->fd, rx + pos, cnt);
@@ -473,15 +462,15 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 
 			/* verify address is aligned */
 			if (sbsf->off & (sbsf->erase_size - 1)) {
-				debug(" sector erase: cmd:%#x needs align:%#x, but we got %#x\n",
-				      sbsf->cmd, sbsf->erase_size,
-				      sbsf->off);
+				log_content(" sector erase: cmd:%#x needs align:%#x, but we got %#x\n",
+					    sbsf->cmd, sbsf->erase_size,
+					    sbsf->off);
 				sbsf->status &= ~STAT_WEL;
 				goto done;
 			}
 
-			debug(" sector erase addr: %u, size: %u\n", sbsf->off,
-			      sbsf->erase_size);
+			log_content(" sector erase addr: %u, size: %u\n",
+				    sbsf->off, sbsf->erase_size);
 
 			cnt = bytes - pos;
 			if (tx)
@@ -495,13 +484,13 @@ static int sandbox_sf_xfer(struct udevice *dev, unsigned int bitlen,
 			ret = sandbox_erase_part(sbsf, sbsf->erase_size);
 			sbsf->status &= ~STAT_WEL;
 			if (ret) {
-				debug("sandbox_sf: Erase failed\n");
+				log_content("sandbox_sf: Erase failed\n");
 				goto done;
 			}
 			goto done;
 		}
 		default:
-			debug(" ??? no idea what to do ???\n");
+			log_content(" ??? no idea what to do ???\n");
 			goto done;
 		}
 	}
@@ -532,33 +521,8 @@ static const struct dm_spi_emul_ops sandbox_sf_emul_ops = {
 };
 
 #ifdef CONFIG_SPI_FLASH
-static int sandbox_cmdline_cb_spi_sf(struct sandbox_state *state,
-				     const char *arg)
-{
-	unsigned long bus, cs;
-	const char *spec = sandbox_spi_parse_spec(arg, &bus, &cs);
-
-	if (!spec)
-		return 1;
-
-	/*
-	 * It is safe to not make a copy of 'spec' because it comes from the
-	 * command line.
-	 *
-	 * TODO(sjg@chromium.org): It would be nice if we could parse the
-	 * spec here, but the problem is that no U-Boot init has been done
-	 * yet. Perhaps we can figure something out.
-	 */
-	state->spi[bus][cs].spec = spec;
-	debug("%s:  Setting up spec '%s' for bus %ld, cs %ld\n", __func__,
-	      spec, bus, cs);
-
-	return 0;
-}
-SANDBOX_CMDLINE_OPT(spi_sf, 1, "connect a SPI flash: <bus>:<cs>:<id>:<file>");
-
 int sandbox_sf_bind_emul(struct sandbox_state *state, int busnum, int cs,
-			 struct udevice *bus, int of_offset, const char *spec)
+			 struct udevice *bus, ofnode node, const char *spec)
 {
 	struct udevice *emul;
 	char name[20], *str;
@@ -569,16 +533,17 @@ int sandbox_sf_bind_emul(struct sandbox_state *state, int busnum, int cs,
 	strncpy(name, spec, sizeof(name) - 6);
 	name[sizeof(name) - 6] = '\0';
 	strcat(name, "-emul");
-	str = strdup(name);
-	if (!str)
-		return -ENOMEM;
 	drv = lists_driver_lookup_name("sandbox_sf_emul");
 	if (!drv) {
 		puts("Cannot find sandbox_sf_emul driver\n");
 		return -ENOENT;
 	}
-	ret = device_bind(bus, drv, str, NULL, of_offset, &emul);
+	str = strdup(name);
+	if (!str)
+		return -ENOMEM;
+	ret = device_bind_ofnode(bus, drv, str, NULL, node, &emul);
 	if (ret) {
+		free(str);
 		printf("Cannot create emul device for spec '%s' (err=%d)\n",
 		       spec, ret);
 		return ret;
@@ -598,32 +563,6 @@ void sandbox_sf_unbind_emul(struct sandbox_state *state, int busnum, int cs)
 	state->spi[busnum][cs].emul = NULL;
 }
 
-static int sandbox_sf_bind_bus_cs(struct sandbox_state *state, int busnum,
-				  int cs, const char *spec)
-{
-	struct udevice *bus, *slave;
-	int ret;
-
-	ret = uclass_find_device_by_seq(UCLASS_SPI, busnum, true, &bus);
-	if (ret) {
-		printf("Invalid bus %d for spec '%s' (err=%d)\n", busnum,
-		       spec, ret);
-		return ret;
-	}
-	ret = spi_find_chip_select(bus, cs, &slave);
-	if (!ret) {
-		printf("Chip select %d already exists for spec '%s'\n", cs,
-		       spec);
-		return -EEXIST;
-	}
-
-	ret = device_bind_driver(bus, "spi_flash_std", spec, &slave);
-	if (ret)
-		return ret;
-
-	return sandbox_sf_bind_emul(state, busnum, cs, bus, -1, spec);
-}
-
 int sandbox_spi_get_emul(struct sandbox_state *state,
 			 struct udevice *bus, struct udevice *slave,
 			 struct udevice **emulp)
@@ -639,7 +578,7 @@ int sandbox_spi_get_emul(struct sandbox_state *state,
 		debug("%s: busnum=%u, cs=%u: binding SPI flash emulation: ",
 		      __func__, busnum, cs);
 		ret = sandbox_sf_bind_emul(state, busnum, cs, bus,
-					   dev_of_offset(slave), slave->name);
+					   dev_ofnode(slave), slave->name);
 		if (ret) {
 			debug("failed (err=%d)\n", ret);
 			return ret;
@@ -650,35 +589,6 @@ int sandbox_spi_get_emul(struct sandbox_state *state,
 
 	return 0;
 }
-
-int dm_scan_other(bool pre_reloc_only)
-{
-	struct sandbox_state *state = state_get_current();
-	int busnum, cs;
-
-	if (pre_reloc_only)
-		return 0;
-	for (busnum = 0; busnum < CONFIG_SANDBOX_SPI_MAX_BUS; busnum++) {
-		for (cs = 0; cs < CONFIG_SANDBOX_SPI_MAX_CS; cs++) {
-			const char *spec = state->spi[busnum][cs].spec;
-			int ret;
-
-			if (spec) {
-				ret = sandbox_sf_bind_bus_cs(state, busnum,
-							     cs, spec);
-				if (ret) {
-					debug("%s: Bind failed for bus %d, cs %d\n",
-					      __func__, busnum, cs);
-					return ret;
-				}
-				debug("%s:  Setting up spec '%s' for bus %d, cs %d\n",
-				      __func__, spec, busnum, cs);
-			}
-		}
-	}
-
-	return 0;
-}
 #endif
 
 static const struct udevice_id sandbox_sf_ids[] = {
diff --git a/drivers/mtd/spi/sf-uclass.c b/drivers/mtd/spi/sf-uclass.c
index 83876485fe..0843473247 100644
--- a/drivers/mtd/spi/sf-uclass.c
+++ b/drivers/mtd/spi/sf-uclass.c
@@ -15,18 +15,27 @@ DECLARE_GLOBAL_DATA_PTR;
 
 int spi_flash_read_dm(struct udevice *dev, u32 offset, size_t len, void *buf)
 {
-	return sf_get_ops(dev)->read(dev, offset, len, buf);
+	return log_ret(sf_get_ops(dev)->read(dev, offset, len, buf));
 }
 
 int spi_flash_write_dm(struct udevice *dev, u32 offset, size_t len,
 		       const void *buf)
 {
-	return sf_get_ops(dev)->write(dev, offset, len, buf);
+	return log_ret(sf_get_ops(dev)->write(dev, offset, len, buf));
 }
 
 int spi_flash_erase_dm(struct udevice *dev, u32 offset, size_t len)
 {
-	return sf_get_ops(dev)->erase(dev, offset, len);
+	return log_ret(sf_get_ops(dev)->erase(dev, offset, len));
+}
+
+int spl_flash_get_sw_write_prot(struct udevice *dev)
+{
+	struct dm_spi_flash_ops *ops = sf_get_ops(dev);
+
+	if (!ops->get_sw_write_prot)
+		return -ENOSYS;
+	return log_ret(ops->get_sw_write_prot(dev));
 }
 
 /*
diff --git a/drivers/mtd/spi/sf_dataflash.c b/drivers/mtd/spi/sf_dataflash.c
index e5c0e12faa..96247ea371 100644
--- a/drivers/mtd/spi/sf_dataflash.c
+++ b/drivers/mtd/spi/sf_dataflash.c
@@ -19,6 +19,7 @@
 
 #include "sf_internal.h"
 
+#define CMD_READ_ID		0x9f
 /* reads can bypass the buffers */
 #define OP_READ_CONTINUOUS	0xE8
 #define OP_READ_PAGE		0xD2
@@ -76,12 +77,14 @@ struct dataflash {
 static inline int dataflash_status(struct spi_slave *spi)
 {
 	int ret;
+	u8 opcode = OP_READ_STATUS;
 	u8 status;
+
 	/*
 	 * NOTE:  at45db321c over 25 MHz wants to write
 	 * a dummy byte after the opcode...
 	 */
-	ret = spi_flash_cmd(spi, OP_READ_STATUS, &status, 1);
+	ret =  spi_write_then_read(spi, &opcode, 1, NULL, &status, 1);
 	return ret ? -EIO : status;
 }
 
@@ -173,7 +176,7 @@ static int spi_dataflash_erase(struct udevice *dev, u32 offset, size_t len)
 		      command[0], command[1], command[2], command[3],
 		      pageaddr);
 
-		status = spi_flash_cmd_write(spi, command, 4, NULL, 0);
+		status = spi_write_then_read(spi, command, 4, NULL, NULL, 0);
 		if (status < 0) {
 			debug("%s: erase send command error!\n", dev->name);
 			return -EIO;
@@ -248,7 +251,7 @@ static int spi_dataflash_read(struct udevice *dev, u32 offset, size_t len,
 	command[3] = (uint8_t)(addr >> 0);
 
 	/* plus 4 "don't care" bytes, command len: 4 + 4 "don't care" bytes */
-	status = spi_flash_cmd_read(spi, command, 8, buf, len);
+	status = spi_write_then_read(spi, command, 8, NULL, buf, len);
 
 	spi_release_bus(spi);
 
@@ -327,7 +330,8 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 			debug("TRANSFER: (%x) %x %x %x\n",
 			      command[0], command[1], command[2], command[3]);
 
-			status = spi_flash_cmd_write(spi, command, 4, NULL, 0);
+			status = spi_write_then_read(spi, command, 4,
+						     NULL, NULL, 0);
 			if (status < 0) {
 				debug("%s: write(<pagesize) command error!\n",
 				      dev->name);
@@ -352,8 +356,8 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 		debug("PROGRAM: (%x) %x %x %x\n",
 		      command[0], command[1], command[2], command[3]);
 
-		status = spi_flash_cmd_write(spi, command,
-					     4, writebuf, writelen);
+		status = spi_write_then_read(spi, command, 4,
+					     writebuf, NULL, writelen);
 		if (status < 0) {
 			debug("%s: write send command error!\n", dev->name);
 			return -EIO;
@@ -376,8 +380,8 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 		debug("COMPARE: (%x) %x %x %x\n",
 		      command[0], command[1], command[2], command[3]);
 
-		status = spi_flash_cmd_write(spi, command,
-					     4, writebuf, writelen);
+		status = spi_write_then_read(spi, command, 4,
+					     writebuf, NULL, writelen);
 		if (status < 0) {
 			debug("%s: write(compare) send command error!\n",
 			      dev->name);
@@ -442,7 +446,7 @@ static int add_dataflash(struct udevice *dev, char *name, int nr_pages,
 	return 0;
 }
 
-struct flash_info {
+struct data_flash_info {
 	char		*name;
 
 	/*
@@ -461,7 +465,7 @@ struct flash_info {
 #define IS_POW2PS	0x0001		/* uses 2^N byte pages */
 };
 
-static struct flash_info dataflash_data[] = {
+static struct data_flash_info dataflash_data[] = {
 	/*
 	 * NOTE:  chips with SUP_POW2PS (rev D and up) need two entries,
 	 * one with IS_POW2PS and the other without.  The entry with the
@@ -502,12 +506,13 @@ static struct flash_info dataflash_data[] = {
 	{ "at45db642d",  0x1f2800, 8192, 1024, 10, SUP_POW2PS | IS_POW2PS},
 };
 
-static struct flash_info *jedec_probe(struct spi_slave *spi)
+static struct data_flash_info *jedec_probe(struct spi_slave *spi)
 {
 	int			tmp;
 	uint8_t			id[5];
 	uint32_t		jedec;
-	struct flash_info	*info;
+	struct data_flash_info	*info;
+	u8 opcode		= CMD_READ_ID;
 	int status;
 
 	/*
@@ -519,7 +524,7 @@ static struct flash_info *jedec_probe(struct spi_slave *spi)
 	 * That's not an error; only rev C and newer chips handle it, and
 	 * only Atmel sells these chips.
 	 */
-	tmp = spi_flash_cmd(spi, CMD_READ_ID, id, sizeof(id));
+	tmp = spi_write_then_read(spi, &opcode, 1, NULL, id, sizeof(id));
 	if (tmp < 0) {
 		printf("dataflash: error %d reading JEDEC ID\n", tmp);
 		return ERR_PTR(tmp);
@@ -584,7 +589,7 @@ static int spi_dataflash_probe(struct udevice *dev)
 {
 	struct spi_slave *spi = dev_get_parent_priv(dev);
 	struct spi_flash *spi_flash;
-	struct flash_info *info;
+	struct data_flash_info *info;
 	int status;
 
 	spi_flash = dev_get_uclass_priv(dev);
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
index 839cdbe1b0..19b5c7d220 100644
--- a/drivers/mtd/spi/sf_internal.h
+++ b/drivers/mtd/spi/sf_internal.h
@@ -13,216 +13,74 @@
 #include <linux/types.h>
 #include <linux/compiler.h>
 
-/* Dual SPI flash memories - see SPI_COMM_DUAL_... */
-enum spi_dual_flash {
-	SF_SINGLE_FLASH	= 0,
-	SF_DUAL_STACKED_FLASH	= BIT(0),
-	SF_DUAL_PARALLEL_FLASH	= BIT(1),
-};
-
-enum spi_nor_option_flags {
-	SNOR_F_SST_WR		= BIT(0),
-	SNOR_F_USE_FSR		= BIT(1),
-	SNOR_F_USE_UPAGE	= BIT(3),
-};
-
-#define SPI_FLASH_3B_ADDR_LEN		3
-#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
-#define SPI_FLASH_16MB_BOUN		0x1000000
-
-/* CFI Manufacture ID's */
-#define SPI_FLASH_CFI_MFR_SPANSION	0x01
-#define SPI_FLASH_CFI_MFR_STMICRO	0x20
-#define SPI_FLASH_CFI_MFR_MACRONIX	0xc2
-#define SPI_FLASH_CFI_MFR_SST		0xbf
-#define SPI_FLASH_CFI_MFR_WINBOND	0xef
-#define SPI_FLASH_CFI_MFR_ATMEL		0x1f
-
-/* Erase commands */
-#define CMD_ERASE_4K			0x20
-#define CMD_ERASE_CHIP			0xc7
-#define CMD_ERASE_64K			0xd8
+#define SPI_NOR_MAX_ID_LEN	6
+#define SPI_NOR_MAX_ADDR_WIDTH	4
 
-/* Write commands */
-#define CMD_WRITE_STATUS		0x01
-#define CMD_PAGE_PROGRAM		0x02
-#define CMD_WRITE_DISABLE		0x04
-#define CMD_WRITE_ENABLE		0x06
-#define CMD_QUAD_PAGE_PROGRAM		0x32
-
-/* Read commands */
-#define CMD_READ_ARRAY_SLOW		0x03
-#define CMD_READ_ARRAY_FAST		0x0b
-#define CMD_READ_DUAL_OUTPUT_FAST	0x3b
-#define CMD_READ_DUAL_IO_FAST		0xbb
-#define CMD_READ_QUAD_OUTPUT_FAST	0x6b
-#define CMD_READ_QUAD_IO_FAST		0xeb
-#define CMD_READ_ID			0x9f
-#define CMD_READ_STATUS			0x05
-#define CMD_READ_STATUS1		0x35
-#define CMD_READ_CONFIG			0x35
-#define CMD_FLAG_STATUS			0x70
-
-/* Bank addr access commands */
-#ifdef CONFIG_SPI_FLASH_BAR
-# define CMD_BANKADDR_BRWR		0x17
-# define CMD_BANKADDR_BRRD		0x16
-# define CMD_EXTNADDR_WREAR		0xC5
-# define CMD_EXTNADDR_RDEAR		0xC8
+struct flash_info {
+#if !CONFIG_IS_ENABLED(SPI_FLASH_TINY)
+	char		*name;
 #endif
 
-/* Common status */
-#define STATUS_WIP			BIT(0)
-#define STATUS_QEB_WINSPAN		BIT(1)
-#define STATUS_QEB_MXIC			BIT(6)
-#define STATUS_PEC			BIT(7)
-#define SR_BP0				BIT(2)  /* Block protect 0 */
-#define SR_BP1				BIT(3)  /* Block protect 1 */
-#define SR_BP2				BIT(4)  /* Block protect 2 */
-
-/* Flash timeout values */
-#define SPI_FLASH_PROG_TIMEOUT		(2 * CONFIG_SYS_HZ)
-#define SPI_FLASH_PAGE_ERASE_TIMEOUT	(5 * CONFIG_SYS_HZ)
-#define SPI_FLASH_SECTOR_ERASE_TIMEOUT	(10 * CONFIG_SYS_HZ)
-
-/* SST specific */
-#ifdef CONFIG_SPI_FLASH_SST
-# define CMD_SST_BP		0x02    /* Byte Program */
-# define CMD_SST_AAI_WP		0xAD	/* Auto Address Incr Word Program */
-
-int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
-		const void *buf);
-int sst_write_bp(struct spi_flash *flash, u32 offset, size_t len,
-		const void *buf);
-#endif
-
-#define JEDEC_MFR(info)		((info)->id[0])
-#define JEDEC_ID(info)		(((info)->id[1]) << 8 | ((info)->id[2]))
-#define JEDEC_EXT(info)		(((info)->id[3]) << 8 | ((info)->id[4]))
-#define SPI_FLASH_MAX_ID_LEN	6
-
-struct spi_flash_info {
-	/* Device name ([MANUFLETTER][DEVTYPE][DENSITY][EXTRAINFO]) */
-	const char	*name;
-
 	/*
 	 * This array stores the ID bytes.
 	 * The first three bytes are the JEDIC ID.
 	 * JEDEC ID zero means "no ID" (mostly older chips).
 	 */
-	u8		id[SPI_FLASH_MAX_ID_LEN];
+	u8		id[SPI_NOR_MAX_ID_LEN];
 	u8		id_len;
 
-	/*
-	 * The size listed here is what works with SPINOR_OP_SE, which isn't
+	/* The size listed here is what works with SPINOR_OP_SE, which isn't
 	 * necessarily called a "sector" by the vendor.
 	 */
-	u32		sector_size;
-	u32		n_sectors;
+	unsigned int	sector_size;
+	u16		n_sectors;
 
 	u16		page_size;
-
-	u16		flags;
-#define SECT_4K			BIT(0)	/* CMD_ERASE_4K works uniformly */
-#define E_FSR			BIT(1)	/* use flag status register for */
-#define SST_WR			BIT(2)	/* use SST byte/word programming */
-#define WR_QPP			BIT(3)	/* use Quad Page Program */
-#define RD_QUAD			BIT(4)	/* use Quad Read */
-#define RD_DUAL			BIT(5)	/* use Dual Read */
-#define RD_QUADIO		BIT(6)	/* use Quad IO Read */
-#define RD_DUALIO		BIT(7)	/* use Dual IO Read */
-#define RD_FULL			(RD_QUAD | RD_DUAL | RD_QUADIO | RD_DUALIO)
+	u16		addr_width;
+
+	u32		flags;
+#define SECT_4K			BIT(0)	/* SPINOR_OP_BE_4K works uniformly */
+#define SPI_NOR_NO_ERASE	BIT(1)	/* No erase command needed */
+#define SST_WRITE		BIT(2)	/* use SST byte programming */
+#define SPI_NOR_NO_FR		BIT(3)	/* Can't do fastread */
+#define SECT_4K_PMC		BIT(4)	/* SPINOR_OP_BE_4K_PMC works uniformly */
+#define SPI_NOR_DUAL_READ	BIT(5)	/* Flash supports Dual Read */
+#define SPI_NOR_QUAD_READ	BIT(6)	/* Flash supports Quad Read */
+#define USE_FSR			BIT(7)	/* use flag status register */
+#define SPI_NOR_HAS_LOCK	BIT(8)	/* Flash supports lock/unlock via SR */
+#define SPI_NOR_HAS_TB		BIT(9)	/*
+					 * Flash SR has Top/Bottom (TB) protect
+					 * bit. Must be used with
+					 * SPI_NOR_HAS_LOCK.
+					 */
+#define	SPI_S3AN		BIT(10)	/*
+					 * Xilinx Spartan 3AN In-System Flash
+					 * (MFR cannot be used for probing
+					 * because it has the same value as
+					 * ATMEL flashes)
+					 */
+#define SPI_NOR_4B_OPCODES	BIT(11)	/*
+					 * Use dedicated 4byte address op codes
+					 * to support memory size above 128Mib.
+					 */
+#define NO_CHIP_ERASE		BIT(12) /* Chip does not support chip erase */
+#define SPI_NOR_SKIP_SFDP	BIT(13)	/* Skip parsing of SFDP tables */
+#define USE_CLSR		BIT(14)	/* use CLSR command */
+#define SPI_NOR_HAS_SST26LOCK	BIT(15)	/* Flash supports lock/unlock via BPR */
+#define SPI_NOR_OCTAL_READ      BIT(16) /* Flash supports Octal Read */
 };
 
-extern const struct spi_flash_info spi_flash_ids[];
+extern const struct flash_info spi_nor_ids[];
 
-/* Send a single-byte command to the device and read the response */
-int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
-
-/*
- * Send a multi-byte command to the device and read the response. Used
- * for flash array reads, etc.
- */
-int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len);
-
-/*
- * Send a multi-byte command to the device followed by (optional)
- * data. Used for programming the flash array, etc.
- */
-int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
-		const void *data, size_t data_len);
-
-
-/* Flash erase(sectors) operation, support all possible erase commands */
-int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len);
-
-/* Lock stmicro spi flash region */
-int stm_lock(struct spi_flash *flash, u32 ofs, size_t len);
-
-/* Unlock stmicro spi flash region */
-int stm_unlock(struct spi_flash *flash, u32 ofs, size_t len);
-
-/* Check if a stmicro spi flash region is completely locked */
-int stm_is_locked(struct spi_flash *flash, u32 ofs, size_t len);
-
-/* Enable writing on the SPI flash */
-static inline int spi_flash_cmd_write_enable(struct spi_flash *flash)
-{
-	return spi_flash_cmd(flash->spi, CMD_WRITE_ENABLE, NULL, 0);
-}
-
-/* Disable writing on the SPI flash */
-static inline int spi_flash_cmd_write_disable(struct spi_flash *flash)
-{
-	return spi_flash_cmd(flash->spi, CMD_WRITE_DISABLE, NULL, 0);
-}
-
-/*
- * Used for spi_flash write operation
- * - SPI claim
- * - spi_flash_cmd_write_enable
- * - spi_flash_cmd_write
- * - spi_flash_wait_till_ready
- * - SPI release
- */
-int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, const void *buf, size_t buf_len);
-
-/*
- * Flash write operation, support all possible write commands.
- * Write the requested data out breaking it up into multiple write
- * commands as needed per the write size.
- */
-int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
-		size_t len, const void *buf);
+#define JEDEC_MFR(info)	((info)->id[0])
+#define JEDEC_ID(info)		(((info)->id[1]) << 8 | ((info)->id[2]))
 
-/*
- * Same as spi_flash_cmd_read() except it also claims/releases the SPI
- * bus. Used as common part of the ->read() operation.
- */
-int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len);
+/* Get software write-protect value (BP bits) */
+int spi_flash_cmd_get_sw_write_prot(struct spi_flash *flash);
 
-/* Flash read operation, support all possible read commands */
-int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
-		size_t len, void *data);
 
 #ifdef CONFIG_SPI_FLASH_MTD
 int spi_flash_mtd_register(struct spi_flash *flash);
 void spi_flash_mtd_unregister(void);
 #endif
-
-/**
- * spi_flash_scan - scan the SPI FLASH
- * @flash:	the spi flash structure
- *
- * The drivers can use this fuction to scan the SPI FLASH.
- * In the scanning, it will try to get all the necessary information to
- * fill the spi_flash{}.
- *
- * Return: 0 for success, others for failure.
- */
-int spi_flash_scan(struct spi_flash *flash);
-
 #endif /* _SF_INTERNAL_H_ */
diff --git a/drivers/mtd/spi/sf_mtd.c b/drivers/mtd/spi/sf_mtd.c
index 935ae4d2b9..1c2a8c2799 100644
--- a/drivers/mtd/spi/sf_mtd.c
+++ b/drivers/mtd/spi/sf_mtd.c
@@ -11,6 +11,7 @@
 #include <spi_flash.h>
 
 static struct mtd_info sf_mtd_info;
+static bool sf_mtd_registered;
 static char sf_mtd_name[8];
 
 static int spi_flash_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
@@ -18,6 +19,9 @@ static int spi_flash_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 	struct spi_flash *flash = mtd->priv;
 	int err;
 
+	if (!flash)
+		return -ENODEV;
+
 	instr->state = MTD_ERASING;
 
 	err = spi_flash_erase(flash, instr->addr, instr->len);
@@ -39,6 +43,9 @@ static int spi_flash_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
 	struct spi_flash *flash = mtd->priv;
 	int err;
 
+	if (!flash)
+		return -ENODEV;
+
 	err = spi_flash_read(flash, from, len, buf);
 	if (!err)
 		*retlen = len;
@@ -52,6 +59,9 @@ static int spi_flash_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
 	struct spi_flash *flash = mtd->priv;
 	int err;
 
+	if (!flash)
+		return -ENODEV;
+
 	err = spi_flash_write(flash, to, len, buf);
 	if (!err)
 		*retlen = len;
@@ -74,6 +84,17 @@ static int spi_flash_mtd_number(void)
 
 int spi_flash_mtd_register(struct spi_flash *flash)
 {
+	int ret;
+
+	if (sf_mtd_registered) {
+		ret = del_mtd_device(&sf_mtd_info);
+		if (ret)
+			return ret;
+
+		sf_mtd_registered = false;
+	}
+
+	sf_mtd_registered = false;
 	memset(&sf_mtd_info, 0, sizeof(sf_mtd_info));
 	sprintf(sf_mtd_name, "nor%d", spi_flash_mtd_number());
 
@@ -95,10 +116,33 @@ int spi_flash_mtd_register(struct spi_flash *flash)
 	sf_mtd_info.numeraseregions = 0;
 	sf_mtd_info.erasesize = flash->sector_size;
 
-	return add_mtd_device(&sf_mtd_info);
+	ret = add_mtd_device(&sf_mtd_info);
+	if (!ret)
+		sf_mtd_registered = true;
+
+	return ret;
 }
 
 void spi_flash_mtd_unregister(void)
 {
-	del_mtd_device(&sf_mtd_info);
+	int ret;
+
+	if (!sf_mtd_registered)
+		return;
+
+	ret = del_mtd_device(&sf_mtd_info);
+	if (!ret) {
+		sf_mtd_registered = false;
+		return;
+	}
+
+	/*
+	 * Setting mtd->priv to NULL is the best we can do. Thanks to that,
+	 * the MTD layer can still call mtd hooks without risking a
+	 * use-after-free bug. Still, things should be fixed to prevent the
+	 * spi_flash object from being destroyed when del_mtd_device() fails.
+	 */
+	sf_mtd_info.priv = NULL;
+	printf("Failed to unregister MTD %s and the spi_flash object is going away: you're in deep trouble!",
+	       sf_mtd_info.name);
 }
diff --git a/drivers/mtd/spi/sf_probe.c b/drivers/mtd/spi/sf_probe.c
index 7b296378d2..30a87819c1 100644
--- a/drivers/mtd/spi/sf_probe.c
+++ b/drivers/mtd/spi/sf_probe.c
@@ -9,6 +9,7 @@
  */
 
 #include <common.h>
+#include <blk.h>
 #include <dm.h>
 #include <errno.h>
 #include <malloc.h>
@@ -41,7 +42,11 @@ static int spi_flash_probe_slave(struct spi_flash *flash)
 		return ret;
 	}
 
-	ret = spi_flash_scan(flash);
+#if !CONFIG_IS_ENABLED(SPI_FLASH_TINY)
+	flash->mtd.name = (char *)ofnode_read_string(spi->dev->node, "label");
+#endif
+
+	ret = spi_nor_scan(flash);
 	if (ret)
 		goto err_read_id;
 
@@ -55,10 +60,16 @@ err_read_id:
 }
 
 #ifndef CONFIG_DM_SPI_FLASH
-static struct spi_flash *spi_flash_probe_tail(struct spi_slave *bus)
+struct spi_flash *spi_flash_probe(unsigned int busnum, unsigned int cs,
+				  unsigned int max_hz, unsigned int spi_mode)
 {
+	struct spi_slave *bus;
 	struct spi_flash *flash;
 
+	bus = spi_setup_slave(busnum, cs, max_hz, spi_mode);
+	if (!bus)
+		return NULL;
+
 	/* Allocate space if needed (not used by sf-uclass */
 	flash = calloc(1, sizeof(*flash));
 	if (!flash) {
@@ -76,30 +87,6 @@ static struct spi_flash *spi_flash_probe_tail(struct spi_slave *bus)
 	return flash;
 }
 
-struct spi_flash *spi_flash_probe(unsigned int busnum, unsigned int cs,
-		unsigned int max_hz, unsigned int spi_mode)
-{
-	struct spi_slave *bus;
-
-	bus = spi_setup_slave(busnum, cs, max_hz, spi_mode);
-	if (!bus)
-		return NULL;
-	return spi_flash_probe_tail(bus);
-}
-
-#ifdef CONFIG_OF_SPI_FLASH
-struct spi_flash *spi_flash_probe_fdt(const void *blob, int slave_node,
-				      int spi_node)
-{
-	struct spi_slave *bus;
-
-	bus = spi_setup_slave_fdt(blob, slave_node, spi_node);
-	if (!bus)
-		return NULL;
-	return spi_flash_probe_tail(bus);
-}
-#endif
-
 void spi_flash_free(struct spi_flash *flash)
 {
 #ifdef CONFIG_SPI_FLASH_MTD
@@ -115,32 +102,60 @@ static int spi_flash_std_read(struct udevice *dev, u32 offset, size_t len,
 			      void *buf)
 {
 	struct spi_flash *flash = dev_get_uclass_priv(dev);
+	struct mtd_info *mtd = &flash->mtd;
+	size_t retlen;
 
-	return spi_flash_cmd_read_ops(flash, offset, len, buf);
+	return log_ret(mtd->_read(mtd, offset, len, &retlen, buf));
 }
 
 static int spi_flash_std_write(struct udevice *dev, u32 offset, size_t len,
-			const void *buf)
+			       const void *buf)
+{
+	struct spi_flash *flash = dev_get_uclass_priv(dev);
+	struct mtd_info *mtd = &flash->mtd;
+	size_t retlen;
+
+	return mtd->_write(mtd, offset, len, &retlen, buf);
+}
+
+static int spi_flash_std_erase(struct udevice *dev, u32 offset, size_t len)
 {
 	struct spi_flash *flash = dev_get_uclass_priv(dev);
+	struct mtd_info *mtd = &flash->mtd;
+	struct erase_info instr;
 
-#if defined(CONFIG_SPI_FLASH_SST)
-	if (flash->flags & SNOR_F_SST_WR) {
-		if (flash->spi->mode & SPI_TX_BYTE)
-			return sst_write_bp(flash, offset, len, buf);
-		else
-			return sst_write_wp(flash, offset, len, buf);
+	if (offset % mtd->erasesize || len % mtd->erasesize) {
+		printf("SF: Erase offset/length not multiple of erase size\n");
+		return -EINVAL;
 	}
-#endif
 
-	return spi_flash_cmd_write_ops(flash, offset, len, buf);
+	memset(&instr, 0, sizeof(instr));
+	instr.addr = offset;
+	instr.len = len;
+
+	return mtd->_erase(mtd, &instr);
 }
 
-static int spi_flash_std_erase(struct udevice *dev, u32 offset, size_t len)
+static int spi_flash_std_get_sw_write_prot(struct udevice *dev)
 {
 	struct spi_flash *flash = dev_get_uclass_priv(dev);
 
-	return spi_flash_cmd_erase_ops(flash, offset, len);
+	return spi_flash_cmd_get_sw_write_prot(flash);
+}
+
+static int spi_flash_std_bind(struct udevice *udev)
+{
+	int ret = 0;
+
+#ifdef CONFIG_MTD_BLK
+	struct udevice *bdev;
+
+	ret = blk_create_devicef(udev, "mtd_blk", "blk", IF_TYPE_MTD,
+				 BLK_MTD_SPI_NOR, 512, 0, &bdev);
+	if (ret)
+		printf("Cannot create block device\n");
+#endif
+	return ret;
 }
 
 static int spi_flash_std_probe(struct udevice *dev)
@@ -156,14 +171,23 @@ static int spi_flash_std_probe(struct udevice *dev)
 	return spi_flash_probe_slave(flash);
 }
 
+static int spi_flash_std_remove(struct udevice *dev)
+{
+#ifdef CONFIG_SPI_FLASH_MTD
+	spi_flash_mtd_unregister();
+#endif
+	return 0;
+}
+
 static const struct dm_spi_flash_ops spi_flash_std_ops = {
 	.read = spi_flash_std_read,
 	.write = spi_flash_std_write,
 	.erase = spi_flash_std_erase,
+	.get_sw_write_prot = spi_flash_std_get_sw_write_prot,
 };
 
 static const struct udevice_id spi_flash_std_ids[] = {
-	{ .compatible = "spi-flash" },
+	{ .compatible = "jedec,spi-nor" },
 	{ }
 };
 
@@ -171,7 +195,9 @@ U_BOOT_DRIVER(spi_flash_std) = {
 	.name		= "spi_flash_std",
 	.id		= UCLASS_SPI_FLASH,
 	.of_match	= spi_flash_std_ids,
+	.bind		= spi_flash_std_bind,
 	.probe		= spi_flash_std_probe,
+	.remove		= spi_flash_std_remove,
 	.priv_auto_alloc_size = sizeof(struct spi_flash),
 	.ops		= &spi_flash_std_ops,
 };
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 34f68881ed..71afa65ecc 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -16,6 +16,7 @@
 #include <spi.h>
 #include <spi_flash.h>
 #include <linux/log2.h>
+#include <linux/sizes.h>
 #include <dma.h>
 
 #include "sf_internal.h"
@@ -112,7 +113,41 @@ static int write_cr(struct spi_flash *flash, u8 wc)
 }
 #endif
 
+int spi_flash_cmd_get_sw_write_prot(struct spi_flash *flash)
+{
+	u8 status;
+	int ret;
+
+	ret = read_sr(flash, &status);
+	if (ret)
+		return ret;
+
+	return (status >> 2) & 7;
+}
+
 #ifdef CONFIG_SPI_FLASH_BAR
+/*
+ * This "clean_bar" is necessary in a situation when one was accessing
+ * spi flash memory > 16 MiB by using Bank Address Register's BA24 bit.
+ *
+ * After it the BA24 bit shall be cleared to allow access to correct
+ * memory region after SW reset (by calling "reset" command).
+ *
+ * Otherwise, the BA24 bit may be left set and then after reset, the
+ * ROM would read/write/erase SPL from 16 MiB * bank_sel address.
+ */
+static int clean_bar(struct spi_flash *flash)
+{
+	u8 cmd, bank_sel = 0;
+
+	if (flash->bank_curr == 0)
+		return 0;
+	cmd = flash->bank_write_cmd;
+	flash->bank_curr = 0;
+
+	return spi_flash_write_common(flash, &cmd, 1, &bank_sel, 1);
+}
+
 static int write_bar(struct spi_flash *flash, u32 offset)
 {
 	u8 cmd, bank_sel;
@@ -299,7 +334,7 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 
 	erase_size = flash->erase_size;
 	if (offset % erase_size || len % erase_size) {
-		debug("SF: Erase offset/length not multiple of erase size\n");
+		printf("SF: Erase offset/length not multiple of erase size\n");
 		return -1;
 	}
 
@@ -339,6 +374,10 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 		len -= erase_size;
 	}
 
+#ifdef CONFIG_SPI_FLASH_BAR
+	ret = clean_bar(flash);
+#endif
+
 	return ret;
 }
 
@@ -380,7 +419,7 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 
 		if (spi->max_write_size)
 			chunk_len = min(chunk_len,
-					(size_t)spi->max_write_size);
+					spi->max_write_size - sizeof(cmd));
 
 		spi_flash_addr(write_addr, cmd);
 
@@ -397,6 +436,10 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 		offset += chunk_len;
 	}
 
+#ifdef CONFIG_SPI_FLASH_BAR
+	ret = clean_bar(flash);
+#endif
+
 	return ret;
 }
 
@@ -440,17 +483,17 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		size_t len, void *data)
 {
 	struct spi_slave *spi = flash->spi;
-	u8 *cmd, cmdsz;
+	u8 cmdsz;
 	u32 remain_len, read_len, read_addr;
 	int bank_sel = 0;
-	int ret = -1;
+	int ret = 0;
 
 	/* Handle memory-mapped SPI */
 	if (flash->memory_map) {
 		ret = spi_claim_bus(spi);
 		if (ret) {
 			debug("SF: unable to claim SPI bus\n");
-			return ret;
+			return log_ret(ret);
 		}
 		spi_xfer(spi, 0, NULL, NULL, SPI_XFER_MMAP);
 		spi_flash_copy_mmap(data, flash->memory_map + offset, len);
@@ -460,11 +503,7 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 	}
 
 	cmdsz = SPI_FLASH_CMD_LEN + flash->dummy_byte;
-	cmd = calloc(1, cmdsz);
-	if (!cmd) {
-		debug("SF: Failed to allocate cmd\n");
-		return -ENOMEM;
-	}
+	u8 cmd[cmdsz];
 
 	cmd[0] = flash->read_cmd;
 	while (len) {
@@ -477,7 +516,7 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 #ifdef CONFIG_SPI_FLASH_BAR
 		ret = write_bar(flash, read_addr);
 		if (ret < 0)
-			return ret;
+			return log_ret(ret);
 		bank_sel = flash->bank_curr;
 #endif
 		remain_len = ((SPI_FLASH_16MB_BOUN << flash->shift) *
@@ -487,6 +526,9 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		else
 			read_len = remain_len;
 
+		if (spi->max_read_size)
+			read_len = min(read_len, spi->max_read_size);
+
 		spi_flash_addr(read_addr, cmd);
 
 		ret = spi_flash_read_common(flash, cmd, cmdsz, data, read_len);
@@ -500,11 +542,172 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		data += read_len;
 	}
 
-	free(cmd);
-	return ret;
+#ifdef CONFIG_SPI_FLASH_BAR
+	ret = clean_bar(flash);
+#endif
+
+	return log_ret(ret);
 }
 
 #ifdef CONFIG_SPI_FLASH_SST
+static bool sst26_process_bpr(u32 bpr_size, u8 *cmd, u32 bit, enum lock_ctl ctl)
+{
+	switch (ctl) {
+		case SST26_CTL_LOCK:
+			cmd[bpr_size - (bit / 8) - 1] |= BIT(bit % 8);
+			break;
+		case SST26_CTL_UNLOCK:
+			cmd[bpr_size - (bit / 8) - 1] &= ~BIT(bit % 8);
+			break;
+		case SST26_CTL_CHECK:
+			return !!(cmd[bpr_size - (bit / 8) - 1] & BIT(bit % 8));
+	}
+
+	return false;
+}
+
+/*
+ * sst26wf016/sst26wf032/sst26wf064 have next block protection:
+ * 4x   - 8  KByte blocks - read & write protection bits - upper addresses
+ * 1x   - 32 KByte blocks - write protection bits
+ * rest - 64 KByte blocks - write protection bits
+ * 1x   - 32 KByte blocks - write protection bits
+ * 4x   - 8  KByte blocks - read & write protection bits - lower addresses
+ *
+ * We'll support only per 64k lock/unlock so lower and upper 64 KByte region
+ * will be treated as single block.
+ */
+
+/*
+ * Lock, unlock or check lock status of the flash region of the flash (depending
+ * on the lock_ctl value)
+ */
+static int sst26_lock_ctl(struct spi_flash *flash, u32 ofs, size_t len, enum lock_ctl ctl)
+{
+	u32 i, bpr_ptr, rptr_64k, lptr_64k, bpr_size;
+	bool lower_64k = false, upper_64k = false;
+	u8 cmd, bpr_buff[SST26_MAX_BPR_REG_LEN] = {};
+	int ret;
+
+	/* Check length and offset for 64k alignment */
+	if ((ofs & (SZ_64K - 1)) || (len & (SZ_64K - 1)))
+		return -EINVAL;
+
+	if (ofs + len > flash->size)
+		return -EINVAL;
+
+	/* SST26 family has only 16 Mbit, 32 Mbit and 64 Mbit IC */
+	if (flash->size != SZ_2M &&
+	    flash->size != SZ_4M &&
+	    flash->size != SZ_8M)
+		return -EINVAL;
+
+	bpr_size = 2 + (flash->size / SZ_64K / 8);
+
+	cmd = SST26_CMD_READ_BPR;
+	ret = spi_flash_read_common(flash, &cmd, 1, bpr_buff, bpr_size);
+	if (ret < 0) {
+		printf("SF: fail to read block-protection register\n");
+		return ret;
+	}
+
+	rptr_64k = min_t(u32, ofs + len , flash->size - SST26_BOUND_REG_SIZE);
+	lptr_64k = max_t(u32, ofs, SST26_BOUND_REG_SIZE);
+
+	upper_64k = ((ofs + len) > (flash->size - SST26_BOUND_REG_SIZE));
+	lower_64k = (ofs < SST26_BOUND_REG_SIZE);
+
+	/* Lower bits in block-protection register are about 64k region */
+	bpr_ptr = lptr_64k / SZ_64K - 1;
+
+	/* Process 64K blocks region */
+	while (lptr_64k < rptr_64k) {
+		if (sst26_process_bpr(bpr_size, bpr_buff, bpr_ptr, ctl))
+			return EACCES;
+
+		bpr_ptr++;
+		lptr_64k += SZ_64K;
+	}
+
+	/* 32K and 8K region bits in BPR are after 64k region bits */
+	bpr_ptr = (flash->size - 2 * SST26_BOUND_REG_SIZE) / SZ_64K;
+
+	/* Process lower 32K block region */
+	if (lower_64k)
+		if (sst26_process_bpr(bpr_size, bpr_buff, bpr_ptr, ctl))
+			return EACCES;
+
+	bpr_ptr++;
+
+	/* Process upper 32K block region */
+	if (upper_64k)
+		if (sst26_process_bpr(bpr_size, bpr_buff, bpr_ptr, ctl))
+			return EACCES;
+
+	bpr_ptr++;
+
+	/* Process lower 8K block regions */
+	for (i = 0; i < SST26_BPR_8K_NUM; i++) {
+		if (lower_64k)
+			if (sst26_process_bpr(bpr_size, bpr_buff, bpr_ptr, ctl))
+				return EACCES;
+
+		/* In 8K area BPR has both read and write protection bits */
+		bpr_ptr += 2;
+	}
+
+	/* Process upper 8K block regions */
+	for (i = 0; i < SST26_BPR_8K_NUM; i++) {
+		if (upper_64k)
+			if (sst26_process_bpr(bpr_size, bpr_buff, bpr_ptr, ctl))
+				return EACCES;
+
+		/* In 8K area BPR has both read and write protection bits */
+		bpr_ptr += 2;
+	}
+
+	/* If we check region status we don't need to write BPR back */
+	if (ctl == SST26_CTL_CHECK)
+		return 0;
+
+	cmd = SST26_CMD_WRITE_BPR;
+	ret = spi_flash_write_common(flash, &cmd, 1, bpr_buff, bpr_size);
+	if (ret < 0) {
+		printf("SF: fail to write block-protection register\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sst26_unlock(struct spi_flash *flash, u32 ofs, size_t len)
+{
+	return sst26_lock_ctl(flash, ofs, len, SST26_CTL_UNLOCK);
+}
+
+static int sst26_lock(struct spi_flash *flash, u32 ofs, size_t len)
+{
+	return sst26_lock_ctl(flash, ofs, len, SST26_CTL_LOCK);
+}
+
+/*
+ * Returns EACCES (positive value) if region is locked, 0 if region is unlocked,
+ * and negative on errors.
+ */
+static int sst26_is_locked(struct spi_flash *flash, u32 ofs, size_t len)
+{
+	/*
+	 * is_locked function is used for check before reading or erasing flash
+	 * region, so offset and length might be not 64k allighned, so adjust
+	 * them to be 64k allighned as sst26_lock_ctl works only with 64k
+	 * allighned regions.
+	 */
+	ofs -= ofs & (SZ_64K - 1);
+	len = len & (SZ_64K - 1) ? (len & ~(SZ_64K - 1)) + SZ_64K : len;
+
+	return sst26_lock_ctl(flash, ofs, len, SST26_CTL_CHECK);
+}
+
 static int sst_byte_write(struct spi_flash *flash, u32 offset, const void *buf)
 {
 	struct spi_slave *spi = flash->spi;
@@ -807,7 +1010,7 @@ int stm_unlock(struct spi_flash *flash, u32 ofs, size_t len)
 #endif
 
 
-#ifdef CONFIG_SPI_FLASH_MACRONIX
+#if defined(CONFIG_SPI_FLASH_MACRONIX) || defined(CONFIG_SPI_FLASH_GIGADEVICE)
 static int macronix_quad_enable(struct spi_flash *flash)
 {
 	u8 qeb_status;
@@ -892,8 +1095,9 @@ static int set_quad_mode(struct spi_flash *flash,
 			 const struct spi_flash_info *info)
 {
 	switch (JEDEC_MFR(info)) {
-#ifdef CONFIG_SPI_FLASH_MACRONIX
+#if defined(CONFIG_SPI_FLASH_MACRONIX) || defined(CONFIG_SPI_FLASH_GIGADEVICE)
 	case SPI_FLASH_CFI_MFR_MACRONIX:
+	case SPI_FLASH_CIF_MFR_GIGADEVICE:
 		return macronix_quad_enable(flash);
 #endif
 #if defined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)
@@ -903,6 +1107,7 @@ static int set_quad_mode(struct spi_flash *flash,
 #endif
 #ifdef CONFIG_SPI_FLASH_STMICRO
 	case SPI_FLASH_CFI_MFR_STMICRO:
+	case SPI_FLASH_CFI_MFR_MICRON:
 		debug("SF: QEB is volatile for %02x flash\n", JEDEC_MFR(info));
 		return 0;
 #endif
@@ -990,6 +1195,7 @@ int spi_flash_scan(struct spi_flash *flash)
 #if defined(CONFIG_SPI_FLASH_STMICRO) || defined(CONFIG_SPI_FLASH_SST)
 	/* NOR protection support for STmicro/Micron chips and similar */
 	if (JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_STMICRO ||
+	    JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_MICRON ||
 	    JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_SST) {
 		flash->flash_lock = stm_lock;
 		flash->flash_unlock = stm_unlock;
@@ -997,18 +1203,28 @@ int spi_flash_scan(struct spi_flash *flash)
 	}
 #endif
 
+/* sst26wf series block protection implementation differs from other series */
+#if defined(CONFIG_SPI_FLASH_SST)
+	if (JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_SST && info->id[1] == 0x26) {
+		flash->flash_lock = sst26_lock;
+		flash->flash_unlock = sst26_unlock;
+		flash->flash_is_locked = sst26_is_locked;
+	}
+#endif
+
 	/* Compute the flash size */
 	flash->shift = (flash->dual_flash & SF_DUAL_PARALLEL_FLASH) ? 1 : 0;
 	flash->page_size = info->page_size;
 	/*
-	 * The Spansion S25FL032P and S25FL064P have 256b pages, yet use the
-	 * 0x4d00 Extended JEDEC code. The rest of the Spansion flashes with
-	 * the 0x4d00 Extended JEDEC code have 512b pages. All of the others
-	 * have 256b pages.
+	 * The Spansion S25FS512S, S25FL032P and S25FL064P have 256b pages,
+	 * yet use the 0x4d00 Extended JEDEC code. The rest of the Spansion
+	 * flashes with the 0x4d00 Extended JEDEC code have 512b pages.
+	 * All of the others have 256b pages.
 	 */
 	if (JEDEC_EXT(info) == 0x4d00) {
 		if ((JEDEC_ID(info) != 0x0215) &&
-		    (JEDEC_ID(info) != 0x0216))
+		    (JEDEC_ID(info) != 0x0216) &&
+		    (JEDEC_ID(info) != 0x0220))
 			flash->page_size = 512;
 	}
 	flash->page_size <<= flash->shift;
diff --git a/drivers/mtd/spi/spi_flash_ids.c b/drivers/mtd/spi/spi_flash_ids.c
index c4ccf48af4..44e33c7c8b 100644
--- a/drivers/mtd/spi/spi_flash_ids.c
+++ b/drivers/mtd/spi/spi_flash_ids.c
@@ -63,13 +63,21 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"en25s64",	   INFO(0x1c3817, 0x0, 64 * 1024,   128, 0) },
 #endif
 #ifdef CONFIG_SPI_FLASH_GIGADEVICE	/* GIGADEVICE */
+	{"gd25q16c",	   INFO(0xc84015, 0x0, 64 * 1024,    32, RD_FULL | WR_QPP | SECT_4K) },
 	{"gd25q64b",	   INFO(0xc84017, 0x0, 64 * 1024,   128, SECT_4K) },
+	{"gd25q32b",       INFO(0xc84016, 0x0, 64 * 1024,    64, SECT_4K) },
 	{"gd25lq32",	   INFO(0xc86016, 0x0, 64 * 1024,    64, SECT_4K) },
+	{"GD25Q256",       INFO(0xc84019, 0x0, 64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K)},
 #endif
 #ifdef CONFIG_SPI_FLASH_ISSI		/* ISSI */
+	{"is25lq040b",	   INFO(0x9d4013, 0x0, 64 * 1024,    8, 0)  },
 	{"is25lp032",	   INFO(0x9d6016, 0x0, 64 * 1024,    64, 0) },
 	{"is25lp064",	   INFO(0x9d6017, 0x0, 64 * 1024,   128, 0) },
 	{"is25lp128",	   INFO(0x9d6018, 0x0, 64 * 1024,   256, 0) },
+	{"is25lp256",	   INFO(0x9d6019, 0x0, 64 * 1024,   512, 0) },
+	{"is25wp032",	   INFO(0x9d7016, 0x0, 64 * 1024,    64, RD_FULL | SECT_4K) },
+	{"is25wp064",	   INFO(0x9d7017, 0x0, 64 * 1024,   128, RD_FULL | SECT_4K) },
+	{"is25wp128",	   INFO(0x9d7018, 0x0, 64 * 1024,   256, RD_FULL | SECT_4K) },
 #endif
 #ifdef CONFIG_SPI_FLASH_MACRONIX	/* MACRONIX */
 	{"mx25l2006e",	   INFO(0xc22012, 0x0, 64 * 1024,     4, 0) },
@@ -81,8 +89,11 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"mx25l12805",	   INFO(0xc22018, 0x0, 64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"mx25l25635f",	   INFO(0xc22019, 0x0, 64 * 1024,   512, RD_FULL | WR_QPP) },
 	{"mx25l51235f",	   INFO(0xc2201a, 0x0, 64 * 1024,  1024, RD_FULL | WR_QPP) },
+	{"mx25l1633e",	   INFO(0xc22415, 0x0, 64 * 1024,    32, RD_FULL | WR_QPP | SECT_4K) },
 	{"mx25u6435f",	   INFO(0xc22537, 0x0, 64 * 1024,   128, RD_FULL | WR_QPP) },
 	{"mx25l12855e",	   INFO(0xc22618, 0x0, 64 * 1024,   256, RD_FULL | WR_QPP) },
+	{"mx25u1635e",     INFO(0xc22535, 0x0, 64 * 1024,  32, SECT_4K) },
+	{"mx25u25635f",    INFO(0xc22539, 0x0, 64 * 1024,   512, RD_FULL | WR_QPP) },
 	{"mx66u51235f",    INFO(0xc2253a, 0x0, 64 * 1024,  1024, RD_FULL | WR_QPP) },
 	{"mx66l1g45g",     INFO(0xc2201b, 0x0, 64 * 1024,  2048, RD_FULL | WR_QPP) },
 #endif
@@ -91,7 +102,8 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"s25fl016a",	   INFO(0x010214, 0x0, 64 * 1024,    32, 0) },
 	{"s25fl032a",	   INFO(0x010215, 0x0, 64 * 1024,    64, 0) },
 	{"s25fl064a",	   INFO(0x010216, 0x0, 64 * 1024,   128, 0) },
-	{"s25fl116k",	   INFO(0x014015, 0x0, 64 * 1024,   128, 0) },
+	{"s25fl208k",	   INFO(0x014014, 0x0, 64 * 1024,    16, 0) },
+	{"s25fl116k",	   INFO(0x014015, 0x0, 64 * 1024,    32, 0) },
 	{"s25fl164k",	   INFO(0x014017, 0x0140,  64 * 1024,   128, 0) },
 	{"s25fl128p_256k", INFO(0x012018, 0x0300, 256 * 1024,    64, RD_FULL | WR_QPP) },
 	{"s25fl128p_64k",  INFO(0x012018, 0x0301,  64 * 1024,   256, RD_FULL | WR_QPP) },
@@ -99,10 +111,11 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"s25fl064p",	   INFO(0x010216, 0x4d00,  64 * 1024,   128, RD_FULL | WR_QPP) },
 	{"s25fl128s_256k", INFO(0x012018, 0x4d00, 256 * 1024,    64, RD_FULL | WR_QPP) },
 	{"s25fl128s_64k",  INFO(0x012018, 0x4d01,  64 * 1024,   256, RD_FULL | WR_QPP) },
+	{"s25fl128l",      INFO(0x016018, 0, 64 * 1024,    256, RD_FULL | WR_QPP) },
 	{"s25fl256s_256k", INFO(0x010219, 0x4d00, 256 * 1024,   128, RD_FULL | WR_QPP) },
-	{"s25fl256s_64k",  INFO(0x010219, 0x4d01,  64 * 1024,   512, RD_FULL | WR_QPP) },
 	{"s25fs256s_64k",  INFO6(0x010219, 0x4d0181, 64 * 1024, 512, RD_FULL | WR_QPP | SECT_4K) },
-	{"s25fs512s",      INFO6(0x010220, 0x4d0081, 128 * 1024, 512, RD_FULL | WR_QPP | SECT_4K) },
+	{"s25fl256s_64k",  INFO(0x010219, 0x4d01,  64 * 1024,   512, RD_FULL | WR_QPP) },
+	{"s25fs512s",      INFO6(0x010220, 0x4d0081, 256 * 1024, 256, RD_FULL | WR_QPP | SECT_4K) },
 	{"s25fl512s_256k", INFO(0x010220, 0x4d00, 256 * 1024,   256, RD_FULL | WR_QPP) },
 	{"s25fl512s_64k",  INFO(0x010220, 0x4d01,  64 * 1024,  1024, RD_FULL | WR_QPP) },
 	{"s25fl512s_512k", INFO(0x010220, 0x4f00, 256 * 1024,   256, RD_FULL | WR_QPP) },
@@ -126,14 +139,15 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"n25q64a",	   INFO(0x20bb17, 0x0,  64 * 1024,   128, RD_FULL | WR_QPP | SECT_4K) },
 	{"n25q128",	   INFO(0x20ba18, 0x0,  64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"n25q128a",	   INFO(0x20bb18, 0x0,  64 * 1024,   256, RD_FULL | WR_QPP) },
-	{"n25q256",	   INFO(0x20ba19, 0x0,  64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
-	{"n25q256a",	   INFO(0x20bb19, 0x0,  64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
+	{"n25q256",	   INFO(0x20ba19, 0x0,  64 * 1024,   512, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
+	{"n25q256a",	   INFO(0x20bb19, 0x0,  64 * 1024,   512, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
 	{"n25q512",	   INFO(0x20ba20, 0x0,  64 * 1024,  1024, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
 	{"n25q512a",	   INFO(0x20bb20, 0x0,  64 * 1024,  1024, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
 	{"n25q1024",	   INFO(0x20ba21, 0x0,  64 * 1024,  2048, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
 	{"n25q1024a",	   INFO(0x20bb21, 0x0,  64 * 1024,  2048, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
 	{"mt25qu02g",	   INFO(0x20bb22, 0x0,  64 * 1024,  4096, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
 	{"mt25ql02g",	   INFO(0x20ba22, 0x0,  64 * 1024,  4096, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
+	{"mt35xu512g",	   INFO6(0x2c5b1a, 0x104100,  128 * 1024,  512, E_FSR | SECT_4K) },
 #endif
 #ifdef CONFIG_SPI_FLASH_SST		/* SST */
 	{"sst25vf040b",	   INFO(0xbf258d, 0x0,	64 * 1024,     8, SECT_4K | SST_WR) },
@@ -147,6 +161,9 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"sst25wf040",	   INFO(0xbf2504, 0x0,	64 * 1024,     8, SECT_4K | SST_WR) },
 	{"sst25wf040b",	   INFO(0x621613, 0x0,	64 * 1024,     8, SECT_4K) },
 	{"sst25wf080",	   INFO(0xbf2505, 0x0,	64 * 1024,    16, SECT_4K | SST_WR) },
+	{"sst26wf016",	   INFO(0xbf2651, 0x0,	64 * 1024,    32, SECT_4K) },
+	{"sst26wf032",	   INFO(0xbf2622, 0x0,	64 * 1024,    64, SECT_4K) },
+	{"sst26wf064",	   INFO(0xbf2643, 0x0,	64 * 1024,   128, SECT_4K) },
 #endif
 #ifdef CONFIG_SPI_FLASH_WINBOND		/* WINBOND */
 	{"w25p80",	   INFO(0xef2014, 0x0,	64 * 1024,    16, 0) },
@@ -164,9 +181,19 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"w25q256",	   INFO(0xef4019, 0x0,	64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
 	{"w25q80bw",	   INFO(0xef5014, 0x0,	64 * 1024,    16, RD_FULL | WR_QPP | SECT_4K) },
 	{"w25q16dw",	   INFO(0xef6015, 0x0,	64 * 1024,    32, RD_FULL | WR_QPP | SECT_4K) },
+	{"w25q16jv",	   INFO(0xef7015, 0x0,	64 * 1024,    32, RD_FULL | WR_QPP | SECT_4K) },
 	{"w25q32dw",	   INFO(0xef6016, 0x0,	64 * 1024,    64, RD_FULL | WR_QPP | SECT_4K) },
+	{"w25q32jv",	   INFO(0xef7016, 0x0,	64 * 1024,    64, RD_FULL | WR_QPP | SECT_4K) },
 	{"w25q64dw",	   INFO(0xef6017, 0x0,	64 * 1024,   128, RD_FULL | WR_QPP | SECT_4K) },
+	{"w25q64jv",	   INFO(0xef7017, 0x0,	64 * 1024,   128, RD_FULL | WR_QPP | SECT_4K) },
 	{"w25q128fw",	   INFO(0xef6018, 0x0,	64 * 1024,   256, RD_FULL | WR_QPP | SECT_4K) },
+	{"w25q128jv",	   INFO(0xef7018, 0x0,	64 * 1024,   256, RD_FULL | WR_QPP | SECT_4K) },
+	{"w25q256fw",	   INFO(0xef6019, 0x0,	64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
+	{"w25q256jw",	   INFO(0xef7019, 0x0,	64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
+#endif
+#ifdef CONFIG_SPI_FLASH_XMC /* Wuhan Xinxin Semiconductor Manufacturing Corp */
+	{ "xm25qh64a",	   INFO(0x207017, 0x0, 64 * 1024,    128, SECT_4K | RD_DUAL | RD_QUAD) },
+	{ "xm25qh128a",	   INFO(0x207018, 0x0, 64 * 1024,    256, SECT_4K | RD_DUAL | RD_QUAD) },
 #endif
 	{},	/* Empty entry to terminate the list */
 	/*
@@ -174,12 +201,13 @@ const struct spi_flash_info spi_flash_ids[] = {
 	 * Below paired flash devices has similar spi_flash params.
 	 * (s25fl129p_64k, s25fl128s_64k)
 	 * (w25q80bl, w25q80bv)
-	 * (w25q16cl, w25q16dv)
+	 * (w25q16cl, w25q16dv, w25q16jv)
 	 * (w25q32bv, w25q32fv_spi)
 	 * (w25q64cv, w25q64fv_spi)
 	 * (w25q128bv, w25q128fv_spi)
 	 * (w25q32dw, w25q32fv_qpi)
 	 * (w25q64dw, w25q64fv_qpi)
 	 * (w25q128fw, w25q128fv_qpi)
+	 * (w25q256fw, w25q256fv_qpi)
 	 */
 };
diff --git a/drivers/mtd/stm32_flash.c b/drivers/mtd/stm32_flash.c
index 472499d83c..a82814272e 100644
--- a/drivers/mtd/stm32_flash.c
+++ b/drivers/mtd/stm32_flash.c
@@ -12,7 +12,7 @@
 
 flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
 
-#define STM32_FLASH		((struct stm32_flash_regs *)FLASH_CNTL_BASE)
+#define STM32_FLASH	((struct stm32_flash_regs *)STM32_FLASH_CNTL_BASE)
 
 void stm32_flash_latency_cfg(int latency)
 {
diff --git a/drivers/mtd/ubi/Kconfig b/drivers/mtd/ubi/Kconfig
index caa5197df5..2b17eae947 100644
--- a/drivers/mtd/ubi/Kconfig
+++ b/drivers/mtd/ubi/Kconfig
@@ -1,8 +1,14 @@
 menu "UBI support"
 
+config CONFIG_UBI_SILENCE_MSG
+	bool "UBI silence verbose messages"
+	default ENV_IS_IN_UBI
+	help
+	  Make the verbose messages from UBI stop printing. This leaves
+	  warnings and errors enabled.
+
 config MTD_UBI
 	bool "Enable UBI - Unsorted block images"
-	select CRC32
 	select RBTREE
 	select MTD_PARTITIONS
 	help
diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c
index 90fb74a5c9..1ab3ff7312 100644
--- a/drivers/mtd/ubi/attach.c
+++ b/drivers/mtd/ubi/attach.c
@@ -790,7 +790,7 @@ static int check_corruption(struct ubi_device *ubi, struct ubi_vid_hdr *vid_hdr,
 	ubi_dump_vid_hdr(vid_hdr);
 	pr_err("hexdump of PEB %d offset %d, length %d",
 	       pnum, ubi->leb_start, ubi->leb_size);
-	ubi_dbg_print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+	ubi_dbg_print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1,
 			       ubi->peb_buf, ubi->leb_size, 1);
 	err = 1;
 
@@ -1205,8 +1205,7 @@ static void destroy_ai(struct ubi_attach_info *ai)
 		}
 	}
 
-	if (ai->aeb_slab_cache)
-		kmem_cache_destroy(ai->aeb_slab_cache);
+	kmem_cache_destroy(ai->aeb_slab_cache);
 
 	kfree(ai);
 }
diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c
index baf4e2d25b..a6dcd035a6 100644
--- a/drivers/mtd/ubi/build.c
+++ b/drivers/mtd/ubi/build.c
@@ -1060,15 +1060,7 @@ int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,
 #ifndef __UBOOT__
 	wake_up_process(ubi->bgt_thread);
 #else
-	/*
-	 * U-Boot special: We have no bgt_thread in U-Boot!
-	 * So just call do_work() here directly.
-	 */
-	err = do_work(ubi);
-	if (err) {
-		ubi_err(ubi, "%s: work failed with error code %d",
-			ubi->bgt_name, err);
-	}
+	ubi_do_worker(ubi);
 #endif
 
 	spin_unlock(&ubi->wl_lock);
@@ -1259,7 +1251,7 @@ int ubi_init(void)
 	BUILD_BUG_ON(sizeof(struct ubi_vid_hdr) != 64);
 
 	if (mtd_devs > UBI_MAX_DEVICES) {
-		pr_err("UBI error: too many MTD devices, maximum is %d",
+		pr_err("UBI error: too many MTD devices, maximum is %d\n",
 		       UBI_MAX_DEVICES);
 		return -EINVAL;
 	}
@@ -1271,7 +1263,7 @@ int ubi_init(void)
 
 	err = misc_register(&ubi_ctrl_cdev);
 	if (err) {
-		pr_err("UBI error: cannot register device");
+		pr_err("UBI error: cannot register device\n");
 		goto out;
 	}
 
@@ -1298,7 +1290,7 @@ int ubi_init(void)
 		mtd = open_mtd_device(p->name);
 		if (IS_ERR(mtd)) {
 			err = PTR_ERR(mtd);
-			pr_err("UBI error: cannot open mtd %s, error %d",
+			pr_err("UBI error: cannot open mtd %s, error %d\n",
 			       p->name, err);
 			/* See comment below re-ubi_is_module(). */
 			if (ubi_is_module())
@@ -1311,7 +1303,7 @@ int ubi_init(void)
 					 p->vid_hdr_offs, p->max_beb_per1024);
 		mutex_unlock(&ubi_devices_mutex);
 		if (err < 0) {
-			pr_err("UBI error: cannot attach mtd%d",
+			pr_err("UBI error: cannot attach mtd%d\n",
 			       mtd->index);
 			put_mtd_device(mtd);
 
@@ -1335,7 +1327,7 @@ int ubi_init(void)
 
 	err = ubiblock_init();
 	if (err) {
-		pr_err("UBI error: block: cannot initialize, error %d", err);
+		pr_err("UBI error: block: cannot initialize, error %d\n", err);
 
 		/* See comment above re-ubi_is_module(). */
 		if (ubi_is_module())
@@ -1362,7 +1354,7 @@ out:
 	mtd_devs = 0;
 #endif
 	class_unregister(&ubi_class);
-	pr_err("UBI error: cannot initialize UBI, error %d", err);
+	pr_err("UBI error: cannot initialize UBI, error %d\n", err);
 	return err;
 }
 late_initcall(ubi_init);
diff --git a/drivers/mtd/ubi/debug.c b/drivers/mtd/ubi/debug.c
index c35c85b18c..0beaa254f6 100644
--- a/drivers/mtd/ubi/debug.c
+++ b/drivers/mtd/ubi/debug.c
@@ -6,6 +6,7 @@
  * Author: Artem Bityutskiy (Битюцкий Артём)
  */
 
+#include <hexdump.h>
 #include <ubi_uboot.h>
 #include "ubi.h"
 #ifndef __UBOOT__
@@ -40,7 +41,7 @@ void ubi_dump_flash(struct ubi_device *ubi, int pnum, int offset, int len)
 
 	ubi_msg(ubi, "dumping %d bytes of data from PEB %d, offset %d",
 		len, pnum, offset);
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);
+	print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);
 out:
 	vfree(buf);
 	return;
@@ -61,7 +62,7 @@ void ubi_dump_ec_hdr(const struct ubi_ec_hdr *ec_hdr)
 	pr_err("\timage_seq      %d\n", be32_to_cpu(ec_hdr->image_seq));
 	pr_err("\thdr_crc        %#08x\n", be32_to_cpu(ec_hdr->hdr_crc));
 	pr_err("erase counter header hexdump:\n");
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+	print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1,
 		       ec_hdr, UBI_EC_HDR_SIZE, 1);
 }
 
@@ -86,7 +87,7 @@ void ubi_dump_vid_hdr(const struct ubi_vid_hdr *vid_hdr)
 		(unsigned long long)be64_to_cpu(vid_hdr->sqnum));
 	pr_err("\thdr_crc   %08x\n", be32_to_cpu(vid_hdr->hdr_crc));
 	pr_err("Volume identifier header hexdump:\n");
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+	print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1,
 		       vid_hdr, UBI_VID_HDR_SIZE, 1);
 }
 
diff --git a/drivers/mtd/ubi/debug.h b/drivers/mtd/ubi/debug.h
index d8d824e487..215fca7693 100644
--- a/drivers/mtd/ubi/debug.h
+++ b/drivers/mtd/ubi/debug.h
@@ -17,6 +17,9 @@ void ubi_dump_vid_hdr(const struct ubi_vid_hdr *vid_hdr);
 #include <linux/random.h>
 #endif
 
+#include <hexdump.h>
+
+#ifndef __UBOOT__
 #define ubi_assert(expr)  do {                                               \
 	if (unlikely(!(expr))) {                                             \
 		pr_crit("UBI assert failed in %s at %u (pid %d)\n",          \
@@ -24,9 +27,18 @@ void ubi_dump_vid_hdr(const struct ubi_vid_hdr *vid_hdr);
 		dump_stack();                                                \
 	}                                                                    \
 } while (0)
+#else
+#define ubi_assert(expr)  do {                                               \
+	if (unlikely(!(expr))) {                                             \
+		pr_debug("UBI assert failed in %s at %u\n",                  \
+		       __func__, __LINE__);                                  \
+		dump_stack();                                                \
+	}                                                                    \
+} while (0)
+#endif
 
-#define ubi_dbg_print_hex_dump(l, ps, pt, r, g, b, len, a)                   \
-		print_hex_dump(l, ps, pt, r, g, b, len, a)
+#define ubi_dbg_print_hex_dump(ps, pt, r, g, b, len, a)                      \
+		print_hex_dump(ps, pt, r, g, b, len, a)
 
 #define ubi_dbg_msg(type, fmt, ...) \
 	pr_debug("UBI DBG " type " (pid %d): " fmt "\n", current->pid,       \
diff --git a/drivers/mtd/ubi/fastmap-wl.c b/drivers/mtd/ubi/fastmap-wl.c
index a33d4063e0..e36fb39943 100644
--- a/drivers/mtd/ubi/fastmap-wl.c
+++ b/drivers/mtd/ubi/fastmap-wl.c
@@ -170,6 +170,30 @@ void ubi_refill_pools(struct ubi_device *ubi)
 	spin_unlock(&ubi->wl_lock);
 }
 
+/**
+ * produce_free_peb - produce a free physical eraseblock.
+ * @ubi: UBI device description object
+ *
+ * This function tries to make a free PEB by means of synchronous execution of
+ * pending works. This may be needed if, for example the background thread is
+ * disabled. Returns zero in case of success and a negative error code in case
+ * of failure.
+ */
+static int produce_free_peb(struct ubi_device *ubi)
+{
+	int err;
+
+	while (!ubi->free.rb_node && ubi->works_count) {
+		dbg_wl("do one work synchronously");
+		err = do_work(ubi);
+
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
 /**
  * ubi_wl_get_peb - get a physical eraseblock.
  * @ubi: UBI device description object
@@ -212,6 +236,11 @@ again:
 		}
 		retried = 1;
 		up_read(&ubi->fm_eba_sem);
+		ret = produce_free_peb(ubi);
+		if (ret < 0) {
+			down_read(&ubi->fm_eba_sem);
+			goto out;
+		}
 		goto again;
 	}
 
@@ -337,11 +366,6 @@ static void ubi_fastmap_close(struct ubi_device *ubi)
 {
 	int i;
 
-#ifndef __UBOOT__
-	flush_work(&ubi->fm_work);
-#else
-	update_fastmap_work_fn(ubi);
-#endif
 	return_unused_pool_pebs(ubi, &ubi->fm_pool);
 	return_unused_pool_pebs(ubi, &ubi->fm_wl_pool);
 
diff --git a/drivers/mtd/ubi/io.c b/drivers/mtd/ubi/io.c
index 0be9c5a9d5..6d16c2e7e0 100644
--- a/drivers/mtd/ubi/io.c
+++ b/drivers/mtd/ubi/io.c
@@ -78,6 +78,7 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #else
+#include <hexdump.h>
 #include <ubi_uboot.h>
 #endif
 
@@ -1353,11 +1354,11 @@ static int self_check_write(struct ubi_device *ubi, const void *buf, int pnum,
 		ubi_msg(ubi, "data differ at position %d", i);
 		ubi_msg(ubi, "hex dump of the original buffer from %d to %d",
 			i, i + dump_len);
-		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+		print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1,
 			       buf + i, dump_len, 1);
 		ubi_msg(ubi, "hex dump of the read buffer from %d to %d",
 			i, i + dump_len);
-		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+		print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1,
 			       buf1 + i, dump_len, 1);
 		dump_stack();
 		err = -EINVAL;
@@ -1419,7 +1420,7 @@ int ubi_self_check_all_ff(struct ubi_device *ubi, int pnum, int offset, int len)
 fail:
 	ubi_err(ubi, "self-check failed for PEB %d", pnum);
 	ubi_msg(ubi, "hex dump of the %d-%d region", offset, offset + len);
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);
+	print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);
 	err = -EINVAL;
 error:
 	dump_stack();
diff --git a/drivers/mtd/ubi/ubi.h b/drivers/mtd/ubi/ubi.h
index 540f721e1b..3337201fb0 100644
--- a/drivers/mtd/ubi/ubi.h
+++ b/drivers/mtd/ubi/ubi.h
@@ -1119,6 +1119,6 @@ static inline int idx2vol_id(const struct ubi_device *ubi, int idx)
 }
 
 #ifdef __UBOOT__
-int do_work(struct ubi_device *ubi);
+void ubi_do_worker(struct ubi_device *ubi);
 #endif
 #endif /* !__UBI_UBI_H__ */
diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c
index e823ca56f2..0de2a4a5f8 100644
--- a/drivers/mtd/ubi/wl.c
+++ b/drivers/mtd/ubi/wl.c
@@ -191,11 +191,7 @@ static void wl_entry_destroy(struct ubi_device *ubi, struct ubi_wl_entry *e)
  * This function returns zero in case of success and a negative error code in
  * case of failure.
  */
-#ifndef __UBOOT__
 static int do_work(struct ubi_device *ubi)
-#else
-int do_work(struct ubi_device *ubi)
-#endif
 {
 	int err;
 	struct ubi_work *wrk;
@@ -528,6 +524,33 @@ repeat:
 	spin_unlock(&ubi->wl_lock);
 }
 
+#ifdef __UBOOT__
+void ubi_do_worker(struct ubi_device *ubi)
+{
+	int err;
+
+	if (list_empty(&ubi->works) || ubi->ro_mode ||
+	    !ubi->thread_enabled || ubi_dbg_is_bgt_disabled(ubi))
+		return;
+
+	spin_lock(&ubi->wl_lock);
+	while (!list_empty(&ubi->works)) {
+		/*
+		 * call do_work, which executes exactly one work form the queue,
+		 * including removeing it from the work queue.
+		 */
+		spin_unlock(&ubi->wl_lock);
+		err = do_work(ubi);
+		spin_lock(&ubi->wl_lock);
+		if (err) {
+			ubi_err(ubi, "%s: work failed with error code %d",
+				ubi->bgt_name, err);
+		}
+	}
+	spin_unlock(&ubi->wl_lock);
+}
+#endif
+
 /**
  * __schedule_ubi_work - schedule a work.
  * @ubi: UBI device description object
@@ -545,17 +568,6 @@ static void __schedule_ubi_work(struct ubi_device *ubi, struct ubi_work *wrk)
 #ifndef __UBOOT__
 	if (ubi->thread_enabled && !ubi_dbg_is_bgt_disabled(ubi))
 		wake_up_process(ubi->bgt_thread);
-#else
-	int err;
-	/*
-	 * U-Boot special: We have no bgt_thread in U-Boot!
-	 * So just call do_work() here directly.
-	 */
-	err = do_work(ubi);
-	if (err) {
-		ubi_err(ubi, "%s: work failed with error code %d",
-			ubi->bgt_name, err);
-	}
 #endif
 	spin_unlock(&ubi->wl_lock);
 }
@@ -610,6 +622,10 @@ static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,
 	wl_wrk->torture = torture;
 
 	schedule_ubi_work(ubi, wl_wrk);
+
+#ifdef __UBOOT__
+	ubi_do_worker(ubi);
+#endif
 	return 0;
 }
 
@@ -1011,8 +1027,15 @@ static int ensure_wear_leveling(struct ubi_device *ubi, int nested)
 	wrk->func = &wear_leveling_worker;
 	if (nested)
 		__schedule_ubi_work(ubi, wrk);
+#ifndef __UBOOT__
 	else
 		schedule_ubi_work(ubi, wrk);
+#else
+	else {
+		schedule_ubi_work(ubi, wrk);
+		ubi_do_worker(ubi);
+	}
+#endif
 	return err;
 
 out_cancel:
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 5ceea44c60..baeb09a1f0 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -10,6 +10,25 @@ config DM_ETH
 	  This is currently implemented in net/eth.c
 	  Look in include/net.h for details.
 
+config DM_MDIO
+	bool "Enable Driver Model for MDIO devices"
+	depends on DM_ETH && PHYLIB
+	help
+	  Enable driver model for MDIO devices
+
+	  Adds UCLASS_MDIO DM class supporting MDIO buses that are probed as
+	  stand-alone devices.  Useful in particular for systems that support
+	  DM_ETH and have a stand-alone MDIO hardware block shared by multiple
+	  Ethernet interfaces.
+	  This is currently implemented in net/mdio-uclass.c
+	  Look in include/miiphy.h for details.
+
+config DM_ETH_PHY
+	bool "Enable Driver Model for Ethernet Generic PHY drivers"
+	depends on DM
+	help
+	  Enable driver model for Ethernet Generic PHY .
+
 menuconfig NETDEVICES
 	bool "Network device support"
 	depends on NET
@@ -82,6 +101,15 @@ config DWC_ETH_QOS
 	  supports the specific configuration used in NVIDIA's Tegra186 chip,
 	  but should be extensible to other combinations quite easily.
 
+config DWC_ETH_QOS_FULL
+	bool "Synopsys DWC Ethernet QOS full vendor support"
+	depends on DWC_ETH_QOS
+	default y
+	help
+	  Select this to supports the Synopsys Designware Ethernet QOS (Quality
+	  Of Service) IP block for all chips, default is Y, if select it N, only
+	  support rockchip's chips.
+
 config E1000
 	bool "Intel PRO/1000 Gigabit Ethernet support"
 	help
@@ -257,7 +285,7 @@ config PIC32_ETH
 
 config GMAC_ROCKCHIP
 	bool "Rockchip Synopsys Designware Ethernet MAC"
-	depends on DM_ETH && ETH_DESIGNWARE
+	depends on DM_ETH && (ETH_DESIGNWARE || DWC_ETH_QOS)
 	help
 	  This driver provides Rockchip SoCs network support based on the
 	  Synopsys Designware driver.
@@ -272,7 +300,7 @@ config RENESAS_RAVB
 
 config MPC8XX_FEC
 	bool "Fast Ethernet Controller on MPC8XX"
-	depends on 8xx
+	depends on MPC8xx
 	select MII
 	help
 	  This driver implements support for the Fast Ethernet Controller
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 94a4fd8701..4a5110b107 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_TULIP) += dc2114x.o
 obj-$(CONFIG_ETH_DESIGNWARE) += designware.o
 obj-$(CONFIG_DRIVER_DM9000) += dm9000x.o
 obj-$(CONFIG_DNET) += dnet.o
+obj-$(CONFIG_DM_ETH_PHY) += eth-phy-uclass.o
 obj-$(CONFIG_E1000) += e1000.o
 obj-$(CONFIG_E1000_SPI) += e1000_spi.o
 obj-$(CONFIG_EEPRO100) += eepro100.o
diff --git a/drivers/net/ag7xxx.c b/drivers/net/ag7xxx.c
index 00e6806892..f28187058e 100644
--- a/drivers/net/ag7xxx.c
+++ b/drivers/net/ag7xxx.c
@@ -164,8 +164,8 @@ static int ag7xxx_switch_read(struct mii_dev *bus, int addr, int reg, u16 *val)
 	writel(AG7XXX_ETH_MII_MGMT_CMD_READ,
 	       regs + AG7XXX_ETH_MII_MGMT_CMD);
 
-	ret = wait_for_bit("ag7xxx", regs + AG7XXX_ETH_MII_MGMT_IND,
-			   AG7XXX_ETH_MII_MGMT_IND_BUSY, 0, 1000, 0);
+	ret = wait_for_bit_le32(regs + AG7XXX_ETH_MII_MGMT_IND,
+				AG7XXX_ETH_MII_MGMT_IND_BUSY, 0, 1000, 0);
 	if (ret)
 		return ret;
 
@@ -185,8 +185,8 @@ static int ag7xxx_switch_write(struct mii_dev *bus, int addr, int reg, u16 val)
 	       regs + AG7XXX_ETH_MII_MGMT_ADDRESS);
 	writel(val, regs + AG7XXX_ETH_MII_MGMT_CTRL);
 
-	ret = wait_for_bit("ag7xxx", regs + AG7XXX_ETH_MII_MGMT_IND,
-			   AG7XXX_ETH_MII_MGMT_IND_BUSY, 0, 1000, 0);
+	ret = wait_for_bit_le32(regs + AG7XXX_ETH_MII_MGMT_IND,
+				AG7XXX_ETH_MII_MGMT_IND_BUSY, 0, 1000, 0);
 
 	return ret;
 }
@@ -510,13 +510,13 @@ static void ag7xxx_eth_stop(struct udevice *dev)
 
 	/* Stop the TX DMA. */
 	writel(0, priv->regs + AG7XXX_ETH_DMA_TX_CTRL);
-	wait_for_bit("ag7xxx", priv->regs + AG7XXX_ETH_DMA_TX_CTRL, ~0, 0,
-		     1000, 0);
+	wait_for_bit_le32(priv->regs + AG7XXX_ETH_DMA_TX_CTRL, ~0, 0,
+			  1000, 0);
 
 	/* Stop the RX DMA. */
 	writel(0, priv->regs + AG7XXX_ETH_DMA_RX_CTRL);
-	wait_for_bit("ag7xxx", priv->regs + AG7XXX_ETH_DMA_RX_CTRL, ~0, 0,
-		     1000, 0);
+	wait_for_bit_le32(priv->regs + AG7XXX_ETH_DMA_RX_CTRL, ~0, 0,
+			  1000, 0);
 }
 
 /*
diff --git a/drivers/net/bcm-sf2-eth-gmac.c b/drivers/net/bcm-sf2-eth-gmac.c
index 9ff72fa1ed..a2b594ed73 100644
--- a/drivers/net/bcm-sf2-eth-gmac.c
+++ b/drivers/net/bcm-sf2-eth-gmac.c
@@ -610,7 +610,7 @@ int gmac_miiphy_read(struct mii_dev *bus, int phyaddr, int devad, int reg)
 
 	/* Busy wait timeout is 1ms */
 	if (gmac_mii_busywait(1000)) {
-		error("%s: Prepare MII read: MII/MDIO busy\n", __func__);
+		pr_err("%s: Prepare MII read: MII/MDIO busy\n", __func__);
 		return -1;
 	}
 
@@ -622,7 +622,7 @@ int gmac_miiphy_read(struct mii_dev *bus, int phyaddr, int devad, int reg)
 	writel(tmp, GMAC_MII_DATA_ADDR);
 
 	if (gmac_mii_busywait(1000)) {
-		error("%s: MII read failure: MII/MDIO busy\n", __func__);
+		pr_err("%s: MII read failure: MII/MDIO busy\n", __func__);
 		return -1;
 	}
 
@@ -638,7 +638,7 @@ int gmac_miiphy_write(struct mii_dev *bus, int phyaddr, int devad, int reg,
 
 	/* Busy wait timeout is 1ms */
 	if (gmac_mii_busywait(1000)) {
-		error("%s: Prepare MII write: MII/MDIO busy\n", __func__);
+		pr_err("%s: Prepare MII write: MII/MDIO busy\n", __func__);
 		return -1;
 	}
 
@@ -651,7 +651,7 @@ int gmac_miiphy_write(struct mii_dev *bus, int phyaddr, int devad, int reg,
 	writel(tmp, GMAC_MII_DATA_ADDR);
 
 	if (gmac_mii_busywait(1000)) {
-		error("%s: MII write failure: MII/MDIO busy\n", __func__);
+		pr_err("%s: MII write failure: MII/MDIO busy\n", __func__);
 		return -1;
 	}
 
@@ -742,7 +742,7 @@ int gmac_set_speed(int speed, int duplex)
 	} else if (speed == 10) {
 		speed_cfg = 0;
 	} else {
-		error("%s: Invalid GMAC speed(%d)!\n", __func__, speed);
+		pr_err("%s: Invalid GMAC speed(%d)!\n", __func__, speed);
 		return -1;
 	}
 
@@ -820,7 +820,7 @@ int gmac_mac_init(struct eth_device *dev)
 	writel(0, GMAC0_INT_STATUS_ADDR);
 
 	if (dma_init(dma) < 0) {
-		error("%s: GMAC dma_init failed\n", __func__);
+		pr_err("%s: GMAC dma_init failed\n", __func__);
 		goto err_exit;
 	}
 
@@ -855,7 +855,7 @@ int gmac_mac_init(struct eth_device *dev)
 	writel(tmp, GMAC_MII_CTRL_ADDR);
 
 	if (gmac_mii_busywait(1000)) {
-		error("%s: Configure MDIO: MII/MDIO busy\n", __func__);
+		pr_err("%s: Configure MDIO: MII/MDIO busy\n", __func__);
 		goto err_exit;
 	}
 
diff --git a/drivers/net/bcm-sf2-eth.c b/drivers/net/bcm-sf2-eth.c
index e2747365a2..9056f71b9a 100644
--- a/drivers/net/bcm-sf2-eth.c
+++ b/drivers/net/bcm-sf2-eth.c
@@ -40,7 +40,7 @@ static int bcm_sf2_eth_init(struct eth_device *dev)
 
 	rc = eth->mac_init(dev);
 	if (rc) {
-		error("%s: Couldn't cofigure MAC!\n", __func__);
+		pr_err("%s: Couldn't cofigure MAC!\n", __func__);
 		return rc;
 	}
 
@@ -90,7 +90,7 @@ static int bcm_sf2_eth_send(struct eth_device *dev, void *packet, int length)
 		debug(".");
 		i++;
 		if (i > 20) {
-			error("%s: Tx timeout: retried 20 times\n", __func__);
+			pr_err("%s: Tx timeout: retried 20 times\n", __func__);
 			rc = -1;
 			break;
 		}
@@ -117,7 +117,7 @@ static int bcm_sf2_eth_receive(struct eth_device *dev)
 			debug("\nNO More Rx\n");
 			break;
 		} else if ((rcvlen == 0) || (rcvlen > RX_BUF_SIZE)) {
-			error("%s: Wrong Ethernet packet size (%d B), skip!\n",
+			pr_err("%s: Wrong Ethernet packet size (%d B), skip!\n",
 			      __func__, rcvlen);
 			break;
 		} else {
@@ -166,9 +166,9 @@ static int bcm_sf2_eth_open(struct eth_device *dev, bd_t *bt)
 	 */
 	for (i = 0; i < eth->port_num; i++) {
 		if (phy_startup(eth->port[i])) {
-			error("%s: PHY %d startup failed!\n", __func__, i);
+			pr_err("%s: PHY %d startup failed!\n", __func__, i);
 			if (i == CONFIG_BCM_SF2_ETH_DEFAULT_PORT) {
-				error("%s: No default port %d!\n", __func__, i);
+				pr_err("%s: No default port %d!\n", __func__, i);
 				return -1;
 			}
 		}
@@ -205,13 +205,13 @@ int bcm_sf2_eth_register(bd_t *bis, u8 dev_num)
 
 	dev = (struct eth_device *)malloc(sizeof(struct eth_device));
 	if (dev == NULL) {
-		error("%s: Not enough memory!\n", __func__);
+		pr_err("%s: Not enough memory!\n", __func__);
 		return -1;
 	}
 
 	eth = (struct eth_info *)malloc(sizeof(struct eth_info));
 	if (eth == NULL) {
-		error("%s: Not enough memory!\n", __func__);
+		pr_err("%s: Not enough memory!\n", __func__);
 		return -1;
 	}
 
@@ -234,7 +234,7 @@ int bcm_sf2_eth_register(bd_t *bis, u8 dev_num)
 	if (gmac_add(dev)) {
 		free(eth);
 		free(dev);
-		error("%s: Adding GMAC failed!\n", __func__);
+		pr_err("%s: Adding GMAC failed!\n", __func__);
 		return -1;
 	}
 #else
@@ -263,7 +263,7 @@ int bcm_sf2_eth_register(bd_t *bis, u8 dev_num)
 
 	rc = bcm_sf2_eth_init(dev);
 	if (rc != 0) {
-		error("%s: configuration failed!\n", __func__);
+		pr_err("%s: configuration failed!\n", __func__);
 		return -1;
 	}
 
diff --git a/drivers/net/cpsw-common.c b/drivers/net/cpsw-common.c
index 8970ee00af..0dc83ab820 100644
--- a/drivers/net/cpsw-common.c
+++ b/drivers/net/cpsw-common.c
@@ -29,14 +29,14 @@ static int davinci_emac_3517_get_macid(struct udevice *dev, u16 offset,
 
 	syscon = fdtdec_lookup_phandle(fdt, node, "syscon");
 	if (syscon < 0) {
-		error("Syscon offset not found\n");
+		pr_err("Syscon offset not found\n");
 		return -ENOENT;
 	}
 
 	addr = (u32)map_physmem(fdt_translate_address(fdt, syscon, &gmii),
 				sizeof(u32), MAP_NOCACHE);
 	if (addr == FDT_ADDR_T_NONE) {
-		error("Not able to get syscon address to get mac efuse address\n");
+		pr_err("Not able to get syscon address to get mac efuse address\n");
 		return -ENOENT;
 	}
 
@@ -69,14 +69,14 @@ static int cpsw_am33xx_cm_get_macid(struct udevice *dev, u16 offset, int slave,
 
 	syscon = fdtdec_lookup_phandle(fdt, node, "syscon");
 	if (syscon < 0) {
-		error("Syscon offset not found\n");
+		pr_err("Syscon offset not found\n");
 		return -ENOENT;
 	}
 
 	addr = (u32)map_physmem(fdt_translate_address(fdt, syscon, &gmii),
 				sizeof(u32), MAP_NOCACHE);
 	if (addr == FDT_ADDR_T_NONE) {
-		error("Not able to get syscon address to get mac efuse address\n");
+		pr_err("Not able to get syscon address to get mac efuse address\n");
 		return -ENOENT;
 	}
 
diff --git a/drivers/net/cpsw.c b/drivers/net/cpsw.c
index d7db0fc432..b72258f83b 100644
--- a/drivers/net/cpsw.c
+++ b/drivers/net/cpsw.c
@@ -1368,7 +1368,7 @@ static int cpsw_eth_ofdata_to_platdata(struct udevice *dev)
 
 			mdio_base = cpsw_get_addr_by_node(fdt, subnode);
 			if (mdio_base == FDT_ADDR_T_NONE) {
-				error("Not able to get MDIO address space\n");
+				pr_err("Not able to get MDIO address space\n");
 				return -ENOENT;
 			}
 			priv->data.mdio_base = mdio_base;
@@ -1407,7 +1407,7 @@ static int cpsw_eth_ofdata_to_platdata(struct udevice *dev)
 								    subnode);
 
 			if (priv->data.gmii_sel == FDT_ADDR_T_NONE) {
-				error("Not able to get gmii_sel reg address\n");
+				pr_err("Not able to get gmii_sel reg address\n");
 				return -ENOENT;
 			}
 
@@ -1418,7 +1418,7 @@ static int cpsw_eth_ofdata_to_platdata(struct udevice *dev)
 			phy_sel_compat = fdt_getprop(fdt, subnode, "compatible",
 						     NULL);
 			if (!phy_sel_compat) {
-				error("Not able to get gmii_sel compatible\n");
+				pr_err("Not able to get gmii_sel compatible\n");
 				return -ENOENT;
 			}
 		}
@@ -1434,7 +1434,7 @@ static int cpsw_eth_ofdata_to_platdata(struct udevice *dev)
 
 	ret = ti_cm_get_macid(dev, active_slave, pdata->enetaddr);
 	if (ret < 0) {
-		error("cpsw read efuse mac failed\n");
+		pr_err("cpsw read efuse mac failed\n");
 		return ret;
 	}
 
diff --git a/drivers/net/designware.c b/drivers/net/designware.c
index 521e4dde41..036d231071 100644
--- a/drivers/net/designware.c
+++ b/drivers/net/designware.c
@@ -737,16 +737,14 @@ int designware_eth_ofdata_to_platdata(struct udevice *dev)
 #endif
 	struct eth_pdata *pdata = &dw_pdata->eth_pdata;
 	const char *phy_mode;
-	const fdt32_t *cell;
 #ifdef CONFIG_DM_GPIO
 	int reset_flags = GPIOD_IS_OUT;
 #endif
 	int ret = 0;
 
-	pdata->iobase = devfdt_get_addr(dev);
+	pdata->iobase = dev_read_addr(dev);
 	pdata->phy_interface = -1;
-	phy_mode = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "phy-mode",
-			       NULL);
+	phy_mode = dev_read_string(dev, "phy-mode");
 	if (phy_mode)
 		pdata->phy_interface = phy_get_interface_by_name(phy_mode);
 	if (pdata->phy_interface == -1) {
@@ -754,10 +752,7 @@ int designware_eth_ofdata_to_platdata(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	pdata->max_speed = 0;
-	cell = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "max-speed", NULL);
-	if (cell)
-		pdata->max_speed = fdt32_to_cpu(*cell);
+	pdata->max_speed = dev_read_u32_default(dev, "max-speed", 0);
 
 #ifdef CONFIG_DM_GPIO
 	if (dev_read_bool(dev, "snps,reset-active-low"))
diff --git a/drivers/net/dwc_eth_qos.c b/drivers/net/dwc_eth_qos.c
index 5c4315ffea..524093a57e 100644
--- a/drivers/net/dwc_eth_qos.c
+++ b/drivers/net/dwc_eth_qos.c
@@ -27,7 +27,6 @@
  *    supports a single RGMII PHY. This configuration also has SW control over
  *    all clock and reset signals to the HW block.
  */
-
 #include <common.h>
 #include <clk.h>
 #include <dm.h>
@@ -39,8 +38,13 @@
 #include <phy.h>
 #include <reset.h>
 #include <wait_bit.h>
-#include <asm/gpio.h>
 #include <asm/io.h>
+#include <eth_phy.h>
+#ifdef CONFIG_ARCH_IMX8M
+#include <asm/arch/clock.h>
+#include <asm/mach-imx/sys_proto.h>
+#endif
+#include "dwc_eth_qos.h"
 
 /* Core registers */
 
@@ -80,6 +84,7 @@ struct eqos_mac_regs {
 #define EQOS_MAC_CONFIGURATION_PS			BIT(15)
 #define EQOS_MAC_CONFIGURATION_FES			BIT(14)
 #define EQOS_MAC_CONFIGURATION_DM			BIT(13)
+#define EQOS_MAC_CONFIGURATION_LM			BIT(12)
 #define EQOS_MAC_CONFIGURATION_TE			BIT(1)
 #define EQOS_MAC_CONFIGURATION_RE			BIT(0)
 
@@ -94,21 +99,26 @@ struct eqos_mac_regs {
 
 #define EQOS_MAC_RXQ_CTRL0_RXQ0EN_SHIFT			0
 #define EQOS_MAC_RXQ_CTRL0_RXQ0EN_MASK			3
-#define EQOS_MAC_RXQ_CTRL0_RXQ0EN_NOT_ENABLED		0
-#define EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB		2
 
 #define EQOS_MAC_RXQ_CTRL2_PSRQ0_SHIFT			0
 #define EQOS_MAC_RXQ_CTRL2_PSRQ0_MASK			0xff
 
+#define EQOS_MAC_HW_FEATURE0_MMCSEL_SHIFT		8
+#define EQOS_MAC_HW_FEATURE0_HDSEL_SHIFT		2
+#define EQOS_MAC_HW_FEATURE0_GMIISEL_SHIFT		1
+#define EQOS_MAC_HW_FEATURE0_MIISEL_SHIFT		0
+
 #define EQOS_MAC_HW_FEATURE1_TXFIFOSIZE_SHIFT		6
 #define EQOS_MAC_HW_FEATURE1_TXFIFOSIZE_MASK		0x1f
 #define EQOS_MAC_HW_FEATURE1_RXFIFOSIZE_SHIFT		0
 #define EQOS_MAC_HW_FEATURE1_RXFIFOSIZE_MASK		0x1f
 
+#define EQOS_MAC_HW_FEATURE3_ASP_SHIFT			28
+#define EQOS_MAC_HW_FEATURE3_ASP_MASK			0x3
+
 #define EQOS_MAC_MDIO_ADDRESS_PA_SHIFT			21
 #define EQOS_MAC_MDIO_ADDRESS_RDA_SHIFT			16
 #define EQOS_MAC_MDIO_ADDRESS_CR_SHIFT			8
-#define EQOS_MAC_MDIO_ADDRESS_CR_20_35			2
 #define EQOS_MAC_MDIO_ADDRESS_SKAP			BIT(4)
 #define EQOS_MAC_MDIO_ADDRESS_GOC_SHIFT			2
 #define EQOS_MAC_MDIO_ADDRESS_GOC_READ			3
@@ -151,6 +161,8 @@ struct eqos_mtl_regs {
 #define EQOS_MTL_RXQ0_OPERATION_MODE_RFA_MASK		0x3f
 #define EQOS_MTL_RXQ0_OPERATION_MODE_EHFC		BIT(7)
 #define EQOS_MTL_RXQ0_OPERATION_MODE_RSF		BIT(5)
+#define EQOS_MTL_RXQ0_OPERATION_MODE_FEP		BIT(4)
+#define EQOS_MTL_RXQ0_OPERATION_MODE_FUP		BIT(3)
 
 #define EQOS_MTL_RXQ0_DEBUG_PRXQ_SHIFT			16
 #define EQOS_MTL_RXQ0_DEBUG_PRXQ_MASK			0x7fff
@@ -259,38 +271,6 @@ struct eqos_desc {
 #define EQOS_DESC3_LD		BIT(28)
 #define EQOS_DESC3_BUF1V	BIT(24)
 
-struct eqos_config {
-	bool reg_access_always_ok;
-};
-
-struct eqos_priv {
-	struct udevice *dev;
-	const struct eqos_config *config;
-	fdt_addr_t regs;
-	struct eqos_mac_regs *mac_regs;
-	struct eqos_mtl_regs *mtl_regs;
-	struct eqos_dma_regs *dma_regs;
-	struct eqos_tegra186_regs *tegra186_regs;
-	struct reset_ctl reset_ctl;
-	struct gpio_desc phy_reset_gpio;
-	struct clk clk_master_bus;
-	struct clk clk_rx;
-	struct clk clk_ptp_ref;
-	struct clk clk_tx;
-	struct clk clk_slave_bus;
-	struct mii_dev *mii;
-	struct phy_device *phy;
-	void *descs;
-	struct eqos_desc *tx_descs;
-	struct eqos_desc *rx_descs;
-	int tx_desc_idx, rx_desc_idx;
-	void *tx_dma_buf;
-	void *rx_dma_buf;
-	void *rx_pkt;
-	bool started;
-	bool reg_access_ok;
-};
-
 /*
  * TX and RX descriptors are 16 bytes. This causes problems with the cache
  * maintenance on CPUs where the cache-line size exceeds the size of these
@@ -328,7 +308,8 @@ static void eqos_free_descs(void *descs)
 #endif
 }
 
-static void eqos_inval_desc(void *desc)
+#ifdef CONFIG_QOS_FULL
+static void eqos_inval_desc_tegra186(void *desc)
 {
 #ifndef CONFIG_SYS_NONCACHED_MEMORY
 	unsigned long start = (unsigned long)desc & ~(ARCH_DMA_MINALIGN - 1);
@@ -338,31 +319,79 @@ static void eqos_inval_desc(void *desc)
 	invalidate_dcache_range(start, end);
 #endif
 }
+#endif
 
-static void eqos_flush_desc(void *desc)
+static void eqos_inval_desc_generic(void *desc)
+{
+#ifndef CONFIG_SYS_NONCACHED_MEMORY
+	unsigned long start = rounddown((unsigned long)desc, ARCH_DMA_MINALIGN);
+	unsigned long end = roundup((unsigned long)desc + EQOS_DESCRIPTOR_SIZE,
+				    ARCH_DMA_MINALIGN);
+
+	invalidate_dcache_range(start, end);
+#endif
+}
+
+#ifdef CONFIG_QOS_FULL
+static void eqos_flush_desc_tegra186(void *desc)
 {
 #ifndef CONFIG_SYS_NONCACHED_MEMORY
 	flush_cache((unsigned long)desc, EQOS_DESCRIPTOR_SIZE);
 #endif
 }
+#endif
 
-static void eqos_inval_buffer(void *buf, size_t size)
+static void eqos_flush_desc_generic(void *desc)
+{
+#ifndef CONFIG_SYS_NONCACHED_MEMORY
+	unsigned long start = rounddown((unsigned long)desc, ARCH_DMA_MINALIGN);
+	unsigned long end = roundup((unsigned long)desc + EQOS_DESCRIPTOR_SIZE,
+				    ARCH_DMA_MINALIGN);
+
+	flush_dcache_range(start, end);
+#endif
+}
+
+#ifdef CONFIG_QOS_FULL
+static void eqos_inval_buffer_tegra186(void *buf, size_t size)
 {
 	unsigned long start = (unsigned long)buf & ~(ARCH_DMA_MINALIGN - 1);
 	unsigned long end = ALIGN(start + size, ARCH_DMA_MINALIGN);
 
 	invalidate_dcache_range(start, end);
 }
+#endif
 
-static void eqos_flush_buffer(void *buf, size_t size)
+static void eqos_inval_buffer_generic(void *buf, size_t size)
+{
+	unsigned long start = rounddown((unsigned long)buf, ARCH_DMA_MINALIGN);
+	unsigned long end = roundup((unsigned long)buf + size,
+				    ARCH_DMA_MINALIGN);
+
+	invalidate_dcache_range(start, end);
+}
+
+#ifdef CONFIG_QOS_FULL
+static void eqos_flush_buffer_tegra186(void *buf, size_t size)
 {
 	flush_cache((unsigned long)buf, size);
 }
+#endif
+
+static void eqos_flush_buffer_generic(void *buf, size_t size)
+{
+	unsigned long start = rounddown((unsigned long)buf, ARCH_DMA_MINALIGN);
+	unsigned long end = roundup((unsigned long)buf + size,
+				    ARCH_DMA_MINALIGN);
+
+	flush_dcache_range(start, end);
+}
 
 static int eqos_mdio_wait_idle(struct eqos_priv *eqos)
 {
-	return wait_for_bit(__func__, &eqos->mac_regs->mdio_address,
-			    EQOS_MAC_MDIO_ADDRESS_GB, false, 1000000, true);
+	return wait_for_bit_le32(&eqos->mac_regs->mdio_address,
+				 EQOS_MAC_MDIO_ADDRESS_GB, false,
+				 1000000, true);
 }
 
 static int eqos_mdio_read(struct mii_dev *bus, int mdio_addr, int mdio_devad,
@@ -377,7 +406,7 @@ static int eqos_mdio_read(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		error("MDIO not idle at entry");
+		pr_err("MDIO not idle at entry");
 		return ret;
 	}
 
@@ -386,18 +415,18 @@ static int eqos_mdio_read(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 		EQOS_MAC_MDIO_ADDRESS_C45E;
 	val |= (mdio_addr << EQOS_MAC_MDIO_ADDRESS_PA_SHIFT) |
 		(mdio_reg << EQOS_MAC_MDIO_ADDRESS_RDA_SHIFT) |
-		(EQOS_MAC_MDIO_ADDRESS_CR_20_35 <<
+		(eqos->config->config_mac_mdio <<
 		 EQOS_MAC_MDIO_ADDRESS_CR_SHIFT) |
 		(EQOS_MAC_MDIO_ADDRESS_GOC_READ <<
 		 EQOS_MAC_MDIO_ADDRESS_GOC_SHIFT) |
 		EQOS_MAC_MDIO_ADDRESS_GB;
 	writel(val, &eqos->mac_regs->mdio_address);
 
-	udelay(10);
+	udelay(eqos->config->mdio_wait);
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		error("MDIO read didn't complete");
+		pr_err("MDIO read didn't complete");
 		return ret;
 	}
 
@@ -421,7 +450,7 @@ static int eqos_mdio_write(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		error("MDIO not idle at entry");
+		pr_err("MDIO not idle at entry");
 		return ret;
 	}
 
@@ -432,26 +461,28 @@ static int eqos_mdio_write(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 		EQOS_MAC_MDIO_ADDRESS_C45E;
 	val |= (mdio_addr << EQOS_MAC_MDIO_ADDRESS_PA_SHIFT) |
 		(mdio_reg << EQOS_MAC_MDIO_ADDRESS_RDA_SHIFT) |
-		(EQOS_MAC_MDIO_ADDRESS_CR_20_35 <<
+		(eqos->config->config_mac_mdio <<
 		 EQOS_MAC_MDIO_ADDRESS_CR_SHIFT) |
 		(EQOS_MAC_MDIO_ADDRESS_GOC_WRITE <<
 		 EQOS_MAC_MDIO_ADDRESS_GOC_SHIFT) |
 		EQOS_MAC_MDIO_ADDRESS_GB;
 	writel(val, &eqos->mac_regs->mdio_address);
 
-	udelay(10);
+	udelay(eqos->config->mdio_wait);
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		error("MDIO read didn't complete");
+		pr_err("MDIO read didn't complete");
 		return ret;
 	}
 
 	return 0;
 }
 
+#ifdef CONFIG_QOS_FULL
 static int eqos_start_clks_tegra186(struct udevice *dev)
 {
+#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
 
@@ -459,43 +490,45 @@ static int eqos_start_clks_tegra186(struct udevice *dev)
 
 	ret = clk_enable(&eqos->clk_slave_bus);
 	if (ret < 0) {
-		error("clk_enable(clk_slave_bus) failed: %d", ret);
+		pr_err("clk_enable(clk_slave_bus) failed: %d", ret);
 		goto err;
 	}
 
 	ret = clk_enable(&eqos->clk_master_bus);
 	if (ret < 0) {
-		error("clk_enable(clk_master_bus) failed: %d", ret);
+		pr_err("clk_enable(clk_master_bus) failed: %d", ret);
 		goto err_disable_clk_slave_bus;
 	}
 
 	ret = clk_enable(&eqos->clk_rx);
 	if (ret < 0) {
-		error("clk_enable(clk_rx) failed: %d", ret);
+		pr_err("clk_enable(clk_rx) failed: %d", ret);
 		goto err_disable_clk_master_bus;
 	}
 
 	ret = clk_enable(&eqos->clk_ptp_ref);
 	if (ret < 0) {
-		error("clk_enable(clk_ptp_ref) failed: %d", ret);
+		pr_err("clk_enable(clk_ptp_ref) failed: %d", ret);
 		goto err_disable_clk_rx;
 	}
 
 	ret = clk_set_rate(&eqos->clk_ptp_ref, 125 * 1000 * 1000);
 	if (ret < 0) {
-		error("clk_set_rate(clk_ptp_ref) failed: %d", ret);
+		pr_err("clk_set_rate(clk_ptp_ref) failed: %d", ret);
 		goto err_disable_clk_ptp_ref;
 	}
 
 	ret = clk_enable(&eqos->clk_tx);
 	if (ret < 0) {
-		error("clk_enable(clk_tx) failed: %d", ret);
+		pr_err("clk_enable(clk_tx) failed: %d", ret);
 		goto err_disable_clk_ptp_ref;
 	}
+#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
 
+#ifdef CONFIG_CLK
 err_disable_clk_ptp_ref:
 	clk_disable(&eqos->clk_ptp_ref);
 err_disable_clk_rx:
@@ -507,10 +540,74 @@ err_disable_clk_slave_bus:
 err:
 	debug("%s: FAILED: %d\n", __func__, ret);
 	return ret;
+#endif
+}
+
+static int eqos_start_clks_stm32(struct udevice *dev)
+{
+#ifdef CONFIG_CLK
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	ret = clk_enable(&eqos->clk_master_bus);
+	if (ret < 0) {
+		pr_err("clk_enable(clk_master_bus) failed: %d", ret);
+		goto err;
+	}
+
+	if (clk_valid(&eqos->clk_rx)) {
+		ret = clk_enable(&eqos->clk_rx);
+		if (ret < 0) {
+			pr_err("clk_enable(clk_rx) failed: %d", ret);
+			goto err_disable_clk_master_bus;
+		}
+	}
+
+	if (clk_valid(&eqos->clk_tx)) {
+		ret = clk_enable(&eqos->clk_tx);
+		if (ret < 0) {
+			pr_err("clk_enable(clk_tx) failed: %d", ret);
+			goto err_disable_clk_rx;
+		}
+	}
+
+	if (clk_valid(&eqos->clk_ck)) {
+		ret = clk_enable(&eqos->clk_ck);
+		if (ret < 0) {
+			pr_err("clk_enable(clk_ck) failed: %d", ret);
+			goto err_disable_clk_tx;
+		}
+	}
+#endif
+
+	debug("%s: OK\n", __func__);
+	return 0;
+
+#ifdef CONFIG_CLK
+err_disable_clk_tx:
+	if (clk_valid(&eqos->clk_tx))
+		clk_disable(&eqos->clk_tx);
+err_disable_clk_rx:
+	if (clk_valid(&eqos->clk_rx))
+		clk_disable(&eqos->clk_rx);
+err_disable_clk_master_bus:
+	clk_disable(&eqos->clk_master_bus);
+err:
+	debug("%s: FAILED: %d\n", __func__, ret);
+	return ret;
+#endif
 }
 
-void eqos_stop_clks_tegra186(struct udevice *dev)
+static int eqos_start_clks_imx(struct udevice *dev)
 {
+	return 0;
+}
+
+static void eqos_stop_clks_tegra186(struct udevice *dev)
+{
+#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
 	debug("%s(dev=%p):\n", __func__, dev);
@@ -520,10 +617,35 @@ void eqos_stop_clks_tegra186(struct udevice *dev)
 	clk_disable(&eqos->clk_rx);
 	clk_disable(&eqos->clk_master_bus);
 	clk_disable(&eqos->clk_slave_bus);
+#endif
 
 	debug("%s: OK\n", __func__);
 }
 
+static void eqos_stop_clks_stm32(struct udevice *dev)
+{
+#ifdef CONFIG_CLK
+	struct eqos_priv *eqos = dev_get_priv(dev);
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	if (clk_valid(&eqos->clk_tx))
+		clk_disable(&eqos->clk_tx);
+	if (clk_valid(&eqos->clk_rx))
+		clk_disable(&eqos->clk_rx);
+	clk_disable(&eqos->clk_master_bus);
+	if (clk_valid(&eqos->clk_ck))
+		clk_disable(&eqos->clk_ck);
+#endif
+
+	debug("%s: OK\n", __func__);
+}
+
+static void eqos_stop_clks_imx(struct udevice *dev)
+{
+	/* empty */
+}
+
 static int eqos_start_resets_tegra186(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -533,7 +655,7 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 
 	ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 1);
 	if (ret < 0) {
-		error("dm_gpio_set_value(phy_reset, assert) failed: %d", ret);
+		pr_err("dm_gpio_set_value(phy_reset, assert) failed: %d", ret);
 		return ret;
 	}
 
@@ -541,13 +663,13 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 
 	ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 0);
 	if (ret < 0) {
-		error("dm_gpio_set_value(phy_reset, deassert) failed: %d", ret);
+		pr_err("dm_gpio_set_value(phy_reset, deassert) failed: %d", ret);
 		return ret;
 	}
 
 	ret = reset_assert(&eqos->reset_ctl);
 	if (ret < 0) {
-		error("reset_assert() failed: %d", ret);
+		pr_err("reset_assert() failed: %d", ret);
 		return ret;
 	}
 
@@ -555,13 +677,59 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 
 	ret = reset_deassert(&eqos->reset_ctl);
 	if (ret < 0) {
-		error("reset_deassert() failed: %d", ret);
+		pr_err("reset_deassert() failed: %d", ret);
 		return ret;
 	}
 
 	debug("%s: OK\n", __func__);
 	return 0;
 }
+#endif
+
+static int eqos_start_resets_stm32(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+	if (dm_gpio_is_valid(&eqos->phy_reset_gpio)) {
+		ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 0);
+		if (ret < 0) {
+			pr_err("dm_gpio_set_value(phy_reset, deassert) failed: %d",
+			       ret);
+			return ret;
+		}
+
+		udelay(eqos->reset_delays[0]);
+
+		ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 1);
+		if (ret < 0) {
+			pr_err("dm_gpio_set_value(phy_reset, assert) failed: %d",
+			       ret);
+			return ret;
+		}
+
+		udelay(eqos->reset_delays[1]);
+
+		ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 0);
+		if (ret < 0) {
+			pr_err("dm_gpio_set_value(phy_reset, deassert) failed: %d",
+			       ret);
+			return ret;
+		}
+
+		udelay(eqos->reset_delays[2]);
+	}
+	debug("%s: OK\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_QOS_FULL
+static int eqos_start_resets_imx(struct udevice *dev)
+{
+	return 0;
+}
 
 static int eqos_stop_resets_tegra186(struct udevice *dev)
 {
@@ -572,6 +740,30 @@ static int eqos_stop_resets_tegra186(struct udevice *dev)
 
 	return 0;
 }
+#endif
+
+static int eqos_stop_resets_stm32(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+
+	if (dm_gpio_is_valid(&eqos->phy_reset_gpio)) {
+		ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 1);
+		if (ret < 0) {
+			pr_err("dm_gpio_set_value(phy_reset, assert) failed: %d",
+			       ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_QOS_FULL
+static int eqos_stop_resets_imx(struct udevice *dev)
+{
+	return 0;
+}
 
 static int eqos_calibrate_pads_tegra186(struct udevice *dev)
 {
@@ -588,17 +780,17 @@ static int eqos_calibrate_pads_tegra186(struct udevice *dev)
 	setbits_le32(&eqos->tegra186_regs->auto_cal_config,
 		     EQOS_AUTO_CAL_CONFIG_START | EQOS_AUTO_CAL_CONFIG_ENABLE);
 
-	ret = wait_for_bit(__func__, &eqos->tegra186_regs->auto_cal_status,
-			   EQOS_AUTO_CAL_STATUS_ACTIVE, true, 10, false);
+	ret = wait_for_bit_le32(&eqos->tegra186_regs->auto_cal_status,
+				EQOS_AUTO_CAL_STATUS_ACTIVE, true, 10, false);
 	if (ret) {
-		error("calibrate didn't start");
+		pr_err("calibrate didn't start");
 		goto failed;
 	}
 
-	ret = wait_for_bit(__func__, &eqos->tegra186_regs->auto_cal_status,
-			   EQOS_AUTO_CAL_STATUS_ACTIVE, false, 10, false);
+	ret = wait_for_bit_le32(&eqos->tegra186_regs->auto_cal_status,
+				EQOS_AUTO_CAL_STATUS_ACTIVE, false, 10, false);
 	if (ret) {
-		error("calibrate didn't finish");
+		pr_err("calibrate didn't finish");
 		goto failed;
 	}
 
@@ -627,11 +819,67 @@ static int eqos_disable_calibration_tegra186(struct udevice *dev)
 
 static ulong eqos_get_tick_clk_rate_tegra186(struct udevice *dev)
 {
+#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
 	return clk_get_rate(&eqos->clk_slave_bus);
+#else
+	return 0;
+#endif
+}
+#endif
+
+static ulong eqos_get_tick_clk_rate_stm32(struct udevice *dev)
+{
+#ifdef CONFIG_CLK
+	struct eqos_priv *eqos = dev_get_priv(dev);
+
+	return clk_get_rate(&eqos->clk_master_bus);
+#else
+	return 0;
+#endif
 }
 
+#ifdef CONFIG_QOS_FULL
+__weak u32 imx_get_eqos_csr_clk(void)
+{
+	return 100 * 1000000;
+}
+__weak int imx_eqos_txclk_set_rate(unsigned long rate)
+{
+	return 0;
+}
+
+static ulong eqos_get_tick_clk_rate_imx(struct udevice *dev)
+{
+	return imx_get_eqos_csr_clk();
+}
+#endif
+
+static int eqos_calibrate_pads_stm32(struct udevice *dev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_QOS_FULL
+static int eqos_calibrate_pads_imx(struct udevice *dev)
+{
+	return 0;
+}
+#endif
+
+static int eqos_disable_calibration_stm32(struct udevice *dev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_QOS_FULL
+static int eqos_disable_calibration_imx(struct udevice *dev)
+{
+	return 0;
+}
+#endif
+
 static int eqos_set_full_duplex(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -694,8 +942,10 @@ static int eqos_set_mii_speed_10(struct udevice *dev)
 	return 0;
 }
 
+#ifdef CONFIG_QOS_FULL
 static int eqos_set_tx_clk_speed_tegra186(struct udevice *dev)
 {
+#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	ulong rate;
 	int ret;
@@ -713,18 +963,59 @@ static int eqos_set_tx_clk_speed_tegra186(struct udevice *dev)
 		rate = 2.5 * 1000 * 1000;
 		break;
 	default:
-		error("invalid speed %d", eqos->phy->speed);
+		pr_err("invalid speed %d", eqos->phy->speed);
 		return -EINVAL;
 	}
 
 	ret = clk_set_rate(&eqos->clk_tx, rate);
 	if (ret < 0) {
-		error("clk_set_rate(tx_clk, %lu) failed: %d", rate, ret);
+		pr_err("clk_set_rate(tx_clk, %lu) failed: %d", rate, ret);
 		return ret;
 	}
+#endif
 
 	return 0;
 }
+#endif
+
+static int eqos_set_tx_clk_speed_stm32(struct udevice *dev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_QOS_FULL
+static int eqos_set_tx_clk_speed_imx(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	ulong rate;
+	int ret;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	switch (eqos->phy->speed) {
+	case SPEED_1000:
+		rate = 125 * 1000 * 1000;
+		break;
+	case SPEED_100:
+		rate = 25 * 1000 * 1000;
+		break;
+	case SPEED_10:
+		rate = 2.5 * 1000 * 1000;
+		break;
+	default:
+		pr_err("invalid speed %d", eqos->phy->speed);
+		return -EINVAL;
+	}
+
+	ret = imx_eqos_txclk_set_rate(rate);
+	if (ret < 0) {
+		pr_err("imx (tx_clk, %lu) failed: %d", rate, ret);
+		return ret;
+	}
+
+	return 0;
+}
+#endif
 
 static int eqos_adjust_link(struct udevice *dev)
 {
@@ -739,7 +1030,7 @@ static int eqos_adjust_link(struct udevice *dev)
 	else
 		ret = eqos_set_half_duplex(dev);
 	if (ret < 0) {
-		error("eqos_set_*_duplex() failed: %d", ret);
+		pr_err("eqos_set_*_duplex() failed: %d", ret);
 		return ret;
 	}
 
@@ -757,39 +1048,39 @@ static int eqos_adjust_link(struct udevice *dev)
 		ret = eqos_set_mii_speed_10(dev);
 		break;
 	default:
-		error("invalid speed %d", eqos->phy->speed);
+		pr_err("invalid speed %d", eqos->phy->speed);
 		return -EINVAL;
 	}
 	if (ret < 0) {
-		error("eqos_set_*mii_speed*() failed: %d", ret);
+		pr_err("eqos_set_*mii_speed*() failed: %d", ret);
 		return ret;
 	}
 
 	if (en_calibration) {
-		ret = eqos_calibrate_pads_tegra186(dev);
+		ret = eqos->config->ops->eqos_calibrate_pads(dev);
 		if (ret < 0) {
-			error("eqos_calibrate_pads_tegra186() failed: %d", ret);
+			pr_err("eqos_calibrate_pads() failed: %d",
+			       ret);
 			return ret;
 		}
 	} else {
-		ret = eqos_disable_calibration_tegra186(dev);
+		ret = eqos->config->ops->eqos_disable_calibration(dev);
 		if (ret < 0) {
-			error("eqos_disable_calibration_tegra186() failed: %d",
-			      ret);
+			pr_err("eqos_disable_calibration() failed: %d",
+			       ret);
 			return ret;
 		}
 	}
-
-	ret = eqos_set_tx_clk_speed_tegra186(dev);
+	ret = eqos->config->ops->eqos_set_tx_clk_speed(dev);
 	if (ret < 0) {
-		error("eqos_set_tx_clk_speed_tegra186() failed: %d", ret);
+		pr_err("eqos_set_tx_clk_speed() failed: %d", ret);
 		return ret;
 	}
 
 	return 0;
 }
 
-static int eqos_write_hwaddr(struct udevice *dev)
+int eqos_write_hwaddr(struct udevice *dev)
 {
 	struct eth_pdata *plat = dev_get_platdata(dev);
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -833,80 +1124,152 @@ static int eqos_write_hwaddr(struct udevice *dev)
 	return 0;
 }
 
-static int eqos_start(struct udevice *dev)
+#ifdef CONFIG_QOS_FULL
+static int eqos_read_rom_hwaddr(struct udevice *dev)
+{
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+
+#ifdef CONFIG_ARCH_IMX8M
+	imx_get_mac_from_fuse(dev->req_seq, pdata->enetaddr);
+#endif
+	return !is_valid_ethaddr(pdata->enetaddr);
+}
+#endif
+
+int eqos_init(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
-	int ret, i;
+	int ret = 0, limit = 10;
 	ulong rate;
-	u32 val, tx_fifo_sz, rx_fifo_sz, tqs, rqs, pbl;
-	ulong last_rx_desc;
+	u32 val;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
-	eqos->tx_desc_idx = 0;
-	eqos->rx_desc_idx = 0;
-
-	ret = eqos_start_clks_tegra186(dev);
-	if (ret < 0) {
-		error("eqos_start_clks_tegra186() failed: %d", ret);
-		goto err;
+	if (eqos->config->ops->eqos_start_clks) {
+		ret = eqos->config->ops->eqos_start_clks(dev);
+		if (ret < 0) {
+			pr_err("eqos_start_clks() failed: %d", ret);
+			goto err;
+		}
 	}
 
-	ret = eqos_start_resets_tegra186(dev);
-	if (ret < 0) {
-		error("eqos_start_resets_tegra186() failed: %d", ret);
-		goto err_stop_clks;
-	}
+	if (!eqos->mii_reseted) {
+		ret = eqos->config->ops->eqos_start_resets(dev);
+		if (ret < 0) {
+			pr_err("eqos_start_resets() failed: %d", ret);
+			goto err_stop_clks;
+		}
 
-	udelay(10);
+		eqos->mii_reseted = true;
+		udelay(10);
+	}
 
 	eqos->reg_access_ok = true;
 
-	ret = wait_for_bit(__func__, &eqos->dma_regs->mode,
-			   EQOS_DMA_MODE_SWR, false, 10, false);
-	if (ret) {
-		error("EQOS_DMA_MODE_SWR stuck");
+	/* DMA SW reset */
+	val = readl(&eqos->dma_regs->mode);
+	val |= EQOS_DMA_MODE_SWR;
+	writel(val, &eqos->dma_regs->mode);
+	while (limit--) {
+		if (!(readl(&eqos->dma_regs->mode) & EQOS_DMA_MODE_SWR))
+			break;
+		mdelay(10);
+	}
+
+	if (limit < 0) {
+		pr_err("EQOS_DMA_MODE_SWR stuck");
 		goto err_stop_resets;
 	}
 
-	ret = eqos_calibrate_pads_tegra186(dev);
+	ret = eqos->config->ops->eqos_calibrate_pads(dev);
 	if (ret < 0) {
-		error("eqos_calibrate_pads_tegra186() failed: %d", ret);
+		pr_err("eqos_calibrate_pads() failed: %d", ret);
 		goto err_stop_resets;
 	}
+	rate = eqos->config->ops->eqos_get_tick_clk_rate(dev);
 
-	rate = eqos_get_tick_clk_rate_tegra186(dev);
 	val = (rate / 1000000) - 1;
 	writel(val, &eqos->mac_regs->us_tic_counter);
 
-	eqos->phy = phy_connect(eqos->mii, 0, dev, 0);
+	/*
+	 * if PHY was already connected and configured,
+	 * don't need to reconnect/reconfigure again
+	 */
 	if (!eqos->phy) {
-		error("phy_connect() failed");
-		goto err_stop_resets;
-	}
-	ret = phy_config(eqos->phy);
-	if (ret < 0) {
-		error("phy_config() failed: %d", ret);
-		goto err_shutdown_phy;
+		int addr = -1;
+#ifdef CONFIG_DM_ETH_PHY
+		addr = eth_phy_get_addr(dev);
+#endif
+#ifdef DWC_NET_PHYADDR
+		addr = DWC_NET_PHYADDR;
+#endif
+		eqos->phy = phy_connect(eqos->mii, addr, dev,
+		 eqos->config->ops->eqos_get_interface(dev));
+		if (!eqos->phy) {
+			pr_err("phy_connect() failed");
+			goto err_stop_resets;
+		}
+
+		if (eqos->max_speed) {
+			ret = phy_set_supported(eqos->phy, eqos->max_speed);
+			if (ret) {
+				pr_err("phy_set_supported() failed: %d", ret);
+				goto err_shutdown_phy;
+			}
+		}
+
+		ret = phy_config(eqos->phy);
+		if (ret < 0) {
+			pr_err("phy_config() failed: %d", ret);
+			goto err_shutdown_phy;
+		}
 	}
+
 	ret = phy_startup(eqos->phy);
 	if (ret < 0) {
-		error("phy_startup() failed: %d", ret);
+		pr_err("phy_startup() failed: %d", ret);
 		goto err_shutdown_phy;
 	}
 
 	if (!eqos->phy->link) {
-		error("No link");
+		pr_err("No link");
 		goto err_shutdown_phy;
 	}
 
 	ret = eqos_adjust_link(dev);
 	if (ret < 0) {
-		error("eqos_adjust_link() failed: %d", ret);
+		pr_err("eqos_adjust_link() failed: %d", ret);
 		goto err_shutdown_phy;
 	}
 
+	debug("%s: OK\n", __func__);
+	return 0;
+
+err_shutdown_phy:
+	phy_shutdown(eqos->phy);
+err_stop_resets:
+	eqos->config->ops->eqos_stop_resets(dev);
+	eqos->mii_reseted = false;
+err_stop_clks:
+	if (eqos->config->ops->eqos_stop_clks)
+		eqos->config->ops->eqos_stop_clks(dev);
+err:
+	pr_err("FAILED: %d", ret);
+	return ret;
+}
+
+void eqos_enable(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	u32 val, tx_fifo_sz, rx_fifo_sz, tqs, rqs, pbl;
+	ulong last_rx_desc;
+	int i;
+
+	eqos->tx_desc_idx = 0;
+	eqos->rx_desc_idx = 0;
+
 	/* Configure MTL */
+	writel(0x60, &eqos->mtl_regs->txq0_quantum_weight - 0x100);
 
 	/* Enable Store and Forward mode for TX */
 	/* Program Tx operating mode */
@@ -920,7 +1283,9 @@ static int eqos_start(struct udevice *dev)
 
 	/* Enable Store and Forward mode for RX, since no jumbo frame */
 	setbits_le32(&eqos->mtl_regs->rxq0_operation_mode,
-		     EQOS_MTL_RXQ0_OPERATION_MODE_RSF);
+		     EQOS_MTL_RXQ0_OPERATION_MODE_RSF |
+		     EQOS_MTL_RXQ0_OPERATION_MODE_FEP |
+		     EQOS_MTL_RXQ0_OPERATION_MODE_FUP);
 
 	/* Transmit/Receive queue fifo size; use all RAM for 1 queue */
 	val = readl(&eqos->mac_regs->hw_feature1);
@@ -993,9 +1358,22 @@ static int eqos_start(struct udevice *dev)
 	clrsetbits_le32(&eqos->mac_regs->rxq_ctrl0,
 			EQOS_MAC_RXQ_CTRL0_RXQ0EN_MASK <<
 			EQOS_MAC_RXQ_CTRL0_RXQ0EN_SHIFT,
-			EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB <<
+			eqos->config->config_mac <<
+			EQOS_MAC_RXQ_CTRL0_RXQ0EN_SHIFT);
+
+	clrsetbits_le32(&eqos->mac_regs->rxq_ctrl0,
+			EQOS_MAC_RXQ_CTRL0_RXQ0EN_MASK <<
+			EQOS_MAC_RXQ_CTRL0_RXQ0EN_SHIFT,
+			0x2 <<
 			EQOS_MAC_RXQ_CTRL0_RXQ0EN_SHIFT);
 
+	/* Multicast and Broadcast Queue Enable */
+	setbits_le32(&eqos->mac_regs->unused_0a4,
+		     0x00100000);
+	/* enable promise mode */
+	setbits_le32(&eqos->mac_regs->unused_004[1],
+		     0x1);
+
 	/* Set TX flow control parameters */
 	/* Set Pause Time */
 	setbits_le32(&eqos->mac_regs->q0_tx_flow_ctrl,
@@ -1072,9 +1450,13 @@ static int eqos_start(struct udevice *dev)
 		struct eqos_desc *rx_desc = &(eqos->rx_descs[i]);
 		rx_desc->des0 = (u32)(ulong)(eqos->rx_dma_buf +
 					     (i * EQOS_MAX_PACKET_SIZE));
-		rx_desc->des3 |= EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
+		rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
+		mb();
+		eqos->config->ops->eqos_flush_desc(rx_desc);
+		eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf +
+						(i * EQOS_MAX_PACKET_SIZE),
+						EQOS_MAX_PACKET_SIZE);
 	}
-	flush_cache((unsigned long)eqos->descs, EQOS_DESCRIPTORS_SIZE);
 
 	writel(0, &eqos->dma_regs->ch0_txdesc_list_haddress);
 	writel((ulong)eqos->tx_descs, &eqos->dma_regs->ch0_txdesc_list_address);
@@ -1087,14 +1469,12 @@ static int eqos_start(struct udevice *dev)
 	       &eqos->dma_regs->ch0_rxdesc_ring_length);
 
 	/* Enable everything */
-
-	setbits_le32(&eqos->mac_regs->configuration,
-		     EQOS_MAC_CONFIGURATION_TE | EQOS_MAC_CONFIGURATION_RE);
-
 	setbits_le32(&eqos->dma_regs->ch0_tx_control,
 		     EQOS_DMA_CH0_TX_CONTROL_ST);
 	setbits_le32(&eqos->dma_regs->ch0_rx_control,
 		     EQOS_DMA_CH0_RX_CONTROL_SR);
+	setbits_le32(&eqos->mac_regs->configuration,
+		     EQOS_MAC_CONFIGURATION_TE | EQOS_MAC_CONFIGURATION_RE);
 
 	/* TX tail pointer not written until we need to TX a packet */
 	/*
@@ -1107,20 +1487,19 @@ static int eqos_start(struct udevice *dev)
 	writel(last_rx_desc, &eqos->dma_regs->ch0_rxdesc_tail_pointer);
 
 	eqos->started = true;
+}
 
-	debug("%s: OK\n", __func__);
-	return 0;
+static int __maybe_unused eqos_start(struct udevice *dev)
+{
+	int ret;
 
-err_shutdown_phy:
-	phy_shutdown(eqos->phy);
-	eqos->phy = NULL;
-err_stop_resets:
-	eqos_stop_resets_tegra186(dev);
-err_stop_clks:
-	eqos_stop_clks_tegra186(dev);
-err:
-	error("FAILED: %d", ret);
-	return ret;
+	ret = eqos_init(dev);
+	if (ret)
+		return ret;
+
+	eqos_enable(dev);
+
+	return 0;
 }
 
 void eqos_stop(struct udevice *dev)
@@ -1170,10 +1549,9 @@ void eqos_stop(struct udevice *dev)
 
 	if (eqos->phy) {
 		phy_shutdown(eqos->phy);
-		eqos->phy = NULL;
 	}
-	eqos_stop_resets_tegra186(dev);
-	eqos_stop_clks_tegra186(dev);
+	if (eqos->config->ops->eqos_stop_clks)
+		eqos->config->ops->eqos_stop_clks(dev);
 
 	debug("%s: OK\n", __func__);
 }
@@ -1188,7 +1566,7 @@ int eqos_send(struct udevice *dev, void *packet, int length)
 	      length);
 
 	memcpy(eqos->tx_dma_buf, packet, length);
-	eqos_flush_buffer(eqos->tx_dma_buf, length);
+	eqos->config->ops->eqos_flush_buffer(eqos->tx_dma_buf, length);
 
 	tx_desc = &(eqos->tx_descs[eqos->tx_desc_idx]);
 	eqos->tx_desc_idx++;
@@ -1203,12 +1581,13 @@ int eqos_send(struct udevice *dev, void *packet, int length)
 	 */
 	mb();
 	tx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_FD | EQOS_DESC3_LD | length;
-	eqos_flush_desc(tx_desc);
+	eqos->config->ops->eqos_flush_desc(tx_desc);
 
-	writel((ulong)(tx_desc + 1), &eqos->dma_regs->ch0_txdesc_tail_pointer);
+	writel((ulong)(&(eqos->tx_descs[eqos->tx_desc_idx])),
+		&eqos->dma_regs->ch0_txdesc_tail_pointer);
 
 	for (i = 0; i < 1000000; i++) {
-		eqos_inval_desc(tx_desc);
+		eqos->config->ops->eqos_inval_desc(tx_desc);
 		if (!(readl(&tx_desc->des3) & EQOS_DESC3_OWN))
 			return 0;
 		udelay(1);
@@ -1228,6 +1607,7 @@ int eqos_recv(struct udevice *dev, int flags, uchar **packetp)
 	debug("%s(dev=%p, flags=%x):\n", __func__, dev, flags);
 
 	rx_desc = &(eqos->rx_descs[eqos->rx_desc_idx]);
+	eqos->config->ops->eqos_inval_desc(rx_desc);
 	if (rx_desc->des3 & EQOS_DESC3_OWN) {
 		debug("%s: RX packet not available\n", __func__);
 		return -EAGAIN;
@@ -1238,7 +1618,7 @@ int eqos_recv(struct udevice *dev, int flags, uchar **packetp)
 	length = rx_desc->des3 & 0x7fff;
 	debug("%s: *packetp=%p, length=%d\n", __func__, *packetp, length);
 
-	eqos_inval_buffer(*packetp, length);
+	eqos->config->ops->eqos_inval_buffer(*packetp, length);
 
 	return length;
 }
@@ -1259,7 +1639,14 @@ int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 		return -EINVAL;
 	}
 
+	eqos->config->ops->eqos_inval_buffer(packet, length);
+
 	rx_desc = &(eqos->rx_descs[eqos->rx_desc_idx]);
+
+	rx_desc->des0 = 0;
+	mb();
+	eqos->config->ops->eqos_flush_desc(rx_desc);
+	eqos->config->ops->eqos_inval_buffer(packet, length);
 	rx_desc->des0 = (u32)(ulong)packet;
 	rx_desc->des1 = 0;
 	rx_desc->des2 = 0;
@@ -1268,8 +1655,8 @@ int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 	 * writes to the rest of the descriptor too.
 	 */
 	mb();
-	rx_desc->des3 |= EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
-	eqos_flush_desc(rx_desc);
+	rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
+	eqos->config->ops->eqos_flush_desc(rx_desc);
 
 	writel((ulong)rx_desc, &eqos->dma_regs->ch0_rxdesc_tail_pointer);
 
@@ -1304,7 +1691,7 @@ static int eqos_probe_resources_core(struct udevice *dev)
 		ret = -ENOMEM;
 		goto err_free_descs;
 	}
-	debug("%s: rx_dma_buf=%p\n", __func__, eqos->rx_dma_buf);
+	debug("%s: tx_dma_buf=%p\n", __func__, eqos->tx_dma_buf);
 
 	eqos->rx_dma_buf = memalign(EQOS_BUFFER_ALIGN, EQOS_RX_BUFFER_SIZE);
 	if (!eqos->rx_dma_buf) {
@@ -1312,7 +1699,7 @@ static int eqos_probe_resources_core(struct udevice *dev)
 		ret = -ENOMEM;
 		goto err_free_tx_dma_buf;
 	}
-	debug("%s: tx_dma_buf=%p\n", __func__, eqos->tx_dma_buf);
+	debug("%s: rx_dma_buf=%p\n", __func__, eqos->rx_dma_buf);
 
 	eqos->rx_pkt = malloc(EQOS_MAX_PACKET_SIZE);
 	if (!eqos->rx_pkt) {
@@ -1322,6 +1709,9 @@ static int eqos_probe_resources_core(struct udevice *dev)
 	}
 	debug("%s: rx_pkt=%p\n", __func__, eqos->rx_pkt);
 
+	eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf,
+			EQOS_MAX_PACKET_SIZE * EQOS_DESCRIPTORS_RX);
+
 	debug("%s: OK\n", __func__);
 	return 0;
 
@@ -1352,6 +1742,7 @@ static int eqos_remove_resources_core(struct udevice *dev)
 	return 0;
 }
 
+#ifdef CONFIG_QOS_FULL
 static int eqos_probe_resources_tegra186(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -1361,7 +1752,7 @@ static int eqos_probe_resources_tegra186(struct udevice *dev)
 
 	ret = reset_get_by_name(dev, "eqos", &eqos->reset_ctl);
 	if (ret) {
-		error("reset_get_by_name(rst) failed: %d", ret);
+		pr_err("reset_get_by_name(rst) failed: %d", ret);
 		return ret;
 	}
 
@@ -1369,38 +1760,38 @@ static int eqos_probe_resources_tegra186(struct udevice *dev)
 				   &eqos->phy_reset_gpio,
 				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	if (ret) {
-		error("gpio_request_by_name(phy reset) failed: %d", ret);
+		pr_err("gpio_request_by_name(phy reset) failed: %d", ret);
 		goto err_free_reset_eqos;
 	}
 
 	ret = clk_get_by_name(dev, "slave_bus", &eqos->clk_slave_bus);
 	if (ret) {
-		error("clk_get_by_name(slave_bus) failed: %d", ret);
+		pr_err("clk_get_by_name(slave_bus) failed: %d", ret);
 		goto err_free_gpio_phy_reset;
 	}
 
 	ret = clk_get_by_name(dev, "master_bus", &eqos->clk_master_bus);
 	if (ret) {
-		error("clk_get_by_name(master_bus) failed: %d", ret);
+		pr_err("clk_get_by_name(master_bus) failed: %d", ret);
 		goto err_free_clk_slave_bus;
 	}
 
 	ret = clk_get_by_name(dev, "rx", &eqos->clk_rx);
 	if (ret) {
-		error("clk_get_by_name(rx) failed: %d", ret);
+		pr_err("clk_get_by_name(rx) failed: %d", ret);
 		goto err_free_clk_master_bus;
 	}
 
 	ret = clk_get_by_name(dev, "ptp_ref", &eqos->clk_ptp_ref);
 	if (ret) {
-		error("clk_get_by_name(ptp_ref) failed: %d", ret);
+		pr_err("clk_get_by_name(ptp_ref) failed: %d", ret);
 		goto err_free_clk_rx;
 		return ret;
 	}
 
 	ret = clk_get_by_name(dev, "tx", &eqos->clk_tx);
 	if (ret) {
-		error("clk_get_by_name(tx) failed: %d", ret);
+		pr_err("clk_get_by_name(tx) failed: %d", ret);
 		goto err_free_clk_ptp_ref;
 	}
 
@@ -1423,6 +1814,148 @@ err_free_reset_eqos:
 	debug("%s: returns %d\n", __func__, ret);
 	return ret;
 }
+#endif
+
+/* board-specific Ethernet Interface initializations. */
+__weak int board_interface_eth_init(struct udevice *dev,
+				    phy_interface_t interface_type)
+{
+	return 0;
+}
+
+static int eqos_probe_resources_stm32(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+	phy_interface_t interface;
+	struct ofnode_phandle_args phandle_args;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	interface = eqos->config->ops->eqos_get_interface(dev);
+
+	if (interface == PHY_INTERFACE_MODE_NONE) {
+		pr_err("Invalid PHY interface\n");
+		return -EINVAL;
+	}
+
+	ret = board_interface_eth_init(dev, interface);
+	if (ret)
+		return -EINVAL;
+
+	eqos->max_speed = dev_read_u32_default(dev, "max-speed", 0);
+
+	ret = clk_get_by_name(dev, "stmmaceth", &eqos->clk_master_bus);
+	if (ret) {
+		pr_err("clk_get_by_name(master_bus) failed: %d", ret);
+		return ret;
+	}
+
+	ret = clk_get_by_name(dev, "mac-clk-rx", &eqos->clk_rx);
+	if (ret)
+		pr_warn("clk_get_by_name(rx) failed: %d", ret);
+
+	ret = clk_get_by_name(dev, "mac-clk-tx", &eqos->clk_tx);
+	if (ret)
+		pr_warn("clk_get_by_name(tx) failed: %d", ret);
+
+	/*  Get ETH_CLK clocks (optional) */
+	ret = clk_get_by_name(dev, "eth-ck", &eqos->clk_ck);
+	if (ret)
+		pr_warn("No phy clock provided %d", ret);
+
+	eqos->phyaddr = -1;
+	ret = dev_read_phandle_with_args(dev, "phy-handle", NULL, 0, 0,
+					 &phandle_args);
+	if (!ret) {
+		/* search "reset-gpios" in phy node */
+		ret = gpio_request_by_name_nodev(phandle_args.node,
+						 "reset-gpios", 0,
+						 &eqos->phy_reset_gpio,
+						 GPIOD_IS_OUT |
+						 GPIOD_IS_OUT_ACTIVE);
+		if (ret)
+			pr_warn("gpio_request_by_name(phy reset) not provided %d",
+				ret);
+		else
+			eqos->reset_delays[1] = 2;
+
+		eqos->phyaddr = ofnode_read_u32_default(phandle_args.node,
+							"reg", -1);
+	}
+
+	if (!dm_gpio_is_valid(&eqos->phy_reset_gpio)) {
+		int reset_flags = GPIOD_IS_OUT;
+
+		if (dev_read_bool(dev, "snps,reset-active-low"))
+			reset_flags |= GPIOD_ACTIVE_LOW;
+
+		ret = gpio_request_by_name(dev, "snps,reset-gpio", 0,
+					   &eqos->phy_reset_gpio, reset_flags);
+		if (ret == 0)
+			ret = dev_read_u32_array(dev, "snps,reset-delays-us",
+						 eqos->reset_delays, 3);
+		else
+			pr_warn("gpio_request_by_name(snps,reset-gpio) failed: %d",
+				ret);
+	}
+
+	debug("%s: OK\n", __func__);
+	return 0;
+}
+
+static phy_interface_t eqos_get_interface_stm32(struct udevice *dev)
+{
+	const char *phy_mode;
+	phy_interface_t interface = PHY_INTERFACE_MODE_NONE;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	phy_mode = dev_read_string(dev, "phy-mode");
+	if (phy_mode)
+		interface = phy_get_interface_by_name(phy_mode);
+
+	return interface;
+}
+
+#ifdef CONFIG_QOS_FULL
+static phy_interface_t eqos_get_interface_tegra186(struct udevice *dev)
+{
+	return PHY_INTERFACE_MODE_MII;
+}
+
+static int eqos_probe_resources_imx(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	phy_interface_t interface;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	interface = eqos->config->ops->eqos_get_interface(dev);
+
+	if (interface == PHY_INTERFACE_MODE_NONE) {
+		pr_err("Invalid PHY interface\n");
+		return -EINVAL;
+	}
+
+	debug("%s: OK\n", __func__);
+	return 0;
+}
+
+static phy_interface_t eqos_get_interface_imx(struct udevice *dev)
+{
+	const char *phy_mode;
+	phy_interface_t interface = PHY_INTERFACE_MODE_NONE;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	phy_mode = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "phy-mode",
+			       NULL);
+	if (phy_mode)
+		interface = phy_get_interface_by_name(phy_mode);
+
+	return interface;
+}
 
 static int eqos_remove_resources_tegra186(struct udevice *dev)
 {
@@ -1430,19 +1963,52 @@ static int eqos_remove_resources_tegra186(struct udevice *dev)
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
+#ifdef CONFIG_CLK
 	clk_free(&eqos->clk_tx);
 	clk_free(&eqos->clk_ptp_ref);
 	clk_free(&eqos->clk_rx);
 	clk_free(&eqos->clk_slave_bus);
 	clk_free(&eqos->clk_master_bus);
+#endif
 	dm_gpio_free(dev, &eqos->phy_reset_gpio);
 	reset_free(&eqos->reset_ctl);
 
 	debug("%s: OK\n", __func__);
 	return 0;
 }
+#endif
+
+static int eqos_remove_resources_stm32(struct udevice *dev)
+{
+#ifdef CONFIG_CLK
+	struct eqos_priv *eqos = dev_get_priv(dev);
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	if (clk_valid(&eqos->clk_tx))
+		clk_free(&eqos->clk_tx);
+	if (clk_valid(&eqos->clk_rx))
+		clk_free(&eqos->clk_rx);
+	clk_free(&eqos->clk_master_bus);
+	if (clk_valid(&eqos->clk_ck))
+		clk_free(&eqos->clk_ck);
+#endif
+
+	if (dm_gpio_is_valid(&eqos->phy_reset_gpio))
+		dm_gpio_free(dev, &eqos->phy_reset_gpio);
+
+	debug("%s: OK\n", __func__);
+	return 0;
+}
 
-static int eqos_probe(struct udevice *dev)
+#ifdef CONFIG_QOS_FULL
+static int eqos_remove_resources_imx(struct udevice *dev)
+{
+	return 0;
+}
+#endif
+
+int eqos_probe(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
@@ -1452,9 +2018,9 @@ static int eqos_probe(struct udevice *dev)
 	eqos->dev = dev;
 	eqos->config = (void *)dev_get_driver_data(dev);
 
-	eqos->regs = devfdt_get_addr(dev);
+	eqos->regs = dev_read_addr(dev);
 	if (eqos->regs == FDT_ADDR_T_NONE) {
-		error("devfdt_get_addr() failed");
+		pr_err("dev_read_addr() failed");
 		return -ENODEV;
 	}
 	eqos->mac_regs = (void *)(eqos->regs + EQOS_MAC_REGS_BASE);
@@ -1464,39 +2030,49 @@ static int eqos_probe(struct udevice *dev)
 
 	ret = eqos_probe_resources_core(dev);
 	if (ret < 0) {
-		error("eqos_probe_resources_core() failed: %d", ret);
+		pr_err("eqos_probe_resources_core() failed: %d", ret);
 		return ret;
 	}
 
-	ret = eqos_probe_resources_tegra186(dev);
+	ret = eqos->config->ops->eqos_probe_resources(dev);
 	if (ret < 0) {
-		error("eqos_probe_resources_tegra186() failed: %d", ret);
+		pr_err("eqos_probe_resources() failed: %d", ret);
 		goto err_remove_resources_core;
 	}
 
-	eqos->mii = mdio_alloc();
+#ifdef CONFIG_DM_ETH_PHY
+	eqos->mii = eth_phy_get_mdio_bus(dev);
+#endif
 	if (!eqos->mii) {
-		error("mdio_alloc() failed");
-		goto err_remove_resources_tegra;
-	}
-	eqos->mii->read = eqos_mdio_read;
-	eqos->mii->write = eqos_mdio_write;
-	eqos->mii->priv = eqos;
-	strcpy(eqos->mii->name, dev->name);
+		eqos->mii = mdio_alloc();
+		if (!eqos->mii) {
+			pr_err("mdio_alloc() failed");
+			ret = -ENOMEM;
+			goto err_remove_resources_tegra;
+		}
+		eqos->mii->read = eqos_mdio_read;
+		eqos->mii->write = eqos_mdio_write;
+		eqos->mii->priv = eqos;
+		strcpy(eqos->mii->name, dev->name);
 
-	ret = mdio_register(eqos->mii);
-	if (ret < 0) {
-		error("mdio_register() failed: %d", ret);
-		goto err_free_mdio;
+		ret = mdio_register(eqos->mii);
+		if (ret < 0) {
+			pr_err("mdio_register() failed: %d", ret);
+			goto err_free_mdio;
+		}
 	}
 
+#ifdef CONFIG_DM_ETH_PHY
+	eth_phy_set_mdio_bus(dev, eqos->mii);
+#endif
+
 	debug("%s: OK\n", __func__);
 	return 0;
 
 err_free_mdio:
 	mdio_free(eqos->mii);
 err_remove_resources_tegra:
-	eqos_remove_resources_tegra186(dev);
+	eqos->config->ops->eqos_remove_resources(dev);
 err_remove_resources_core:
 	eqos_remove_resources_core(dev);
 
@@ -1504,7 +2080,7 @@ err_remove_resources_core:
 	return ret;
 }
 
-static int eqos_remove(struct udevice *dev)
+static int __maybe_unused eqos_remove(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
@@ -1512,13 +2088,15 @@ static int eqos_remove(struct udevice *dev)
 
 	mdio_unregister(eqos->mii);
 	mdio_free(eqos->mii);
-	eqos_remove_resources_tegra186(dev);
+	eqos->config->ops->eqos_remove_resources(dev);
+
 	eqos_probe_resources_core(dev);
 
 	debug("%s: OK\n", __func__);
 	return 0;
 }
 
+#ifdef CONFIG_QOS_FULL
 static const struct eth_ops eqos_ops = {
 	.start = eqos_start,
 	.stop = eqos_stop,
@@ -1526,27 +2104,133 @@ static const struct eth_ops eqos_ops = {
 	.recv = eqos_recv,
 	.free_pkt = eqos_free_pkt,
 	.write_hwaddr = eqos_write_hwaddr,
+	.read_rom_hwaddr	= eqos_read_rom_hwaddr,
+};
+
+static struct eqos_ops eqos_tegra186_ops = {
+	.eqos_inval_desc = eqos_inval_desc_tegra186,
+	.eqos_flush_desc = eqos_flush_desc_tegra186,
+	.eqos_inval_buffer = eqos_inval_buffer_tegra186,
+	.eqos_flush_buffer = eqos_flush_buffer_tegra186,
+	.eqos_probe_resources = eqos_probe_resources_tegra186,
+	.eqos_remove_resources = eqos_remove_resources_tegra186,
+	.eqos_stop_resets = eqos_stop_resets_tegra186,
+	.eqos_start_resets = eqos_start_resets_tegra186,
+	.eqos_stop_clks = eqos_stop_clks_tegra186,
+	.eqos_start_clks = eqos_start_clks_tegra186,
+	.eqos_calibrate_pads = eqos_calibrate_pads_tegra186,
+	.eqos_disable_calibration = eqos_disable_calibration_tegra186,
+	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_tegra186,
+	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_tegra186,
+	.eqos_get_interface = eqos_get_interface_tegra186
 };
 
 static const struct eqos_config eqos_tegra186_config = {
 	.reg_access_always_ok = false,
+	.mdio_wait = 10,
+	.swr_wait = 10,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_20_35,
+	.ops = &eqos_tegra186_ops
+};
+
+static struct eqos_ops eqos_stm32_ops = {
+	.eqos_inval_desc = eqos_inval_desc_generic,
+	.eqos_flush_desc = eqos_flush_desc_generic,
+	.eqos_inval_buffer = eqos_inval_buffer_generic,
+	.eqos_flush_buffer = eqos_flush_buffer_generic,
+	.eqos_probe_resources = eqos_probe_resources_stm32,
+	.eqos_remove_resources = eqos_remove_resources_stm32,
+	.eqos_stop_resets = eqos_stop_resets_stm32,
+	.eqos_start_resets = eqos_start_resets_stm32,
+	.eqos_stop_clks = eqos_stop_clks_stm32,
+	.eqos_start_clks = eqos_start_clks_stm32,
+	.eqos_calibrate_pads = eqos_calibrate_pads_stm32,
+	.eqos_disable_calibration = eqos_disable_calibration_stm32,
+	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_stm32,
+	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_stm32,
+	.eqos_get_interface = eqos_get_interface_stm32
+};
+
+static const struct eqos_config eqos_stm32_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 50,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_AV,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
+	.ops = &eqos_stm32_ops
+};
+
+static struct eqos_ops eqos_imx_ops = {
+	.eqos_inval_desc = eqos_inval_desc_generic,
+	.eqos_flush_desc = eqos_flush_desc_generic,
+	.eqos_inval_buffer = eqos_inval_buffer_generic,
+	.eqos_flush_buffer = eqos_flush_buffer_generic,
+	.eqos_probe_resources = eqos_probe_resources_imx,
+	.eqos_remove_resources = eqos_remove_resources_imx,
+	.eqos_stop_resets = eqos_stop_resets_imx,
+	.eqos_start_resets = eqos_start_resets_imx,
+	.eqos_stop_clks = eqos_stop_clks_imx,
+	.eqos_start_clks = eqos_start_clks_imx,
+	.eqos_calibrate_pads = eqos_calibrate_pads_imx,
+	.eqos_disable_calibration = eqos_disable_calibration_imx,
+	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_imx,
+	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_imx,
+	.eqos_get_interface = eqos_get_interface_imx
+};
+
+struct eqos_config eqos_imx_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 50,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
+	.ops = &eqos_imx_ops
+};
+#endif
+
+struct eqos_ops eqos_rockchip_ops = {
+	.eqos_inval_desc = eqos_inval_desc_generic,
+	.eqos_flush_desc = eqos_flush_desc_generic,
+	.eqos_inval_buffer = eqos_inval_buffer_generic,
+	.eqos_flush_buffer = eqos_flush_buffer_generic,
+	.eqos_probe_resources = eqos_probe_resources_stm32,
+	.eqos_remove_resources = eqos_remove_resources_stm32,
+	.eqos_stop_resets = eqos_stop_resets_stm32,
+	.eqos_start_resets = eqos_start_resets_stm32,
+	.eqos_calibrate_pads = eqos_calibrate_pads_stm32,
+	.eqos_disable_calibration = eqos_disable_calibration_stm32,
+	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_stm32,
+	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_stm32,
+	.eqos_get_interface = eqos_get_interface_stm32
 };
 
+#ifdef CONFIG_QOS_FULL
 static const struct udevice_id eqos_ids[] = {
 	{
 		.compatible = "nvidia,tegra186-eqos",
 		.data = (ulong)&eqos_tegra186_config
 	},
+	{
+		.compatible = "snps,dwmac-4.20a",
+		.data = (ulong)&eqos_stm32_config
+	},
+	{
+		.compatible = "fsl,imx-eqos",
+		.data = (ulong)&eqos_imx_config
+	},
+
 	{ }
 };
 
 U_BOOT_DRIVER(eth_eqos) = {
 	.name = "eth_eqos",
 	.id = UCLASS_ETH,
-	.of_match = eqos_ids,
+	.of_match = of_match_ptr(eqos_ids),
 	.probe = eqos_probe,
 	.remove = eqos_remove,
 	.ops = &eqos_ops,
 	.priv_auto_alloc_size = sizeof(struct eqos_priv),
 	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
 };
+#endif
diff --git a/drivers/net/e1000_spi.c b/drivers/net/e1000_spi.c
index cb5f93d652..b38f4df9f3 100644
--- a/drivers/net/e1000_spi.c
+++ b/drivers/net/e1000_spi.c
@@ -78,8 +78,6 @@ static inline struct e1000_hw *e1000_hw_from_spi(struct spi_slave *spi)
 }
 
 /* Not sure why all of these are necessary */
-void spi_init_r(void) { /* Nothing to do */ }
-void spi_init_f(void) { /* Nothing to do */ }
 void spi_init(void)   { /* Nothing to do */ }
 
 struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
diff --git a/drivers/net/ep93xx_eth.c b/drivers/net/ep93xx_eth.c
index a94191b9e6..bc45706243 100644
--- a/drivers/net/ep93xx_eth.c
+++ b/drivers/net/ep93xx_eth.c
@@ -324,7 +324,7 @@ static int ep93xx_eth_rcv_packet(struct eth_device *dev)
 			debug("reporting %d bytes...\n", len);
 		} else {
 			/* Do we have an erroneous packet? */
-			error("packet rx error, status %08X %08X",
+			pr_err("packet rx error, status %08X %08X",
 				priv->rx_sq.current->word1,
 				priv->rx_sq.current->word2);
 			dump_rx_descriptor_queue(dev);
@@ -401,7 +401,7 @@ static int ep93xx_eth_send_packet(struct eth_device *dev,
 		; /* noop */
 
 	if (!TX_STATUS_TXWE(priv->tx_sq.current)) {
-		error("packet tx error, status %08X",
+		pr_err("packet tx error, status %08X",
 			priv->tx_sq.current->word1);
 		dump_tx_descriptor_queue(dev);
 		dump_tx_status_queue(dev);
@@ -452,7 +452,7 @@ int ep93xx_eth_initialize(u8 dev_num, int base_addr)
 
 	priv = malloc(sizeof(*priv));
 	if (!priv) {
-		error("malloc() failed");
+		pr_err("malloc() failed");
 		goto eth_init_failed_0;
 	}
 	memset(priv, 0, sizeof(*priv));
@@ -462,34 +462,34 @@ int ep93xx_eth_initialize(u8 dev_num, int base_addr)
 	priv->tx_dq.base = calloc(NUMTXDESC,
 				sizeof(struct tx_descriptor));
 	if (priv->tx_dq.base == NULL) {
-		error("calloc() failed");
+		pr_err("calloc() failed");
 		goto eth_init_failed_1;
 	}
 
 	priv->tx_sq.base = calloc(NUMTXDESC,
 				sizeof(struct tx_status));
 	if (priv->tx_sq.base == NULL) {
-		error("calloc() failed");
+		pr_err("calloc() failed");
 		goto eth_init_failed_2;
 	}
 
 	priv->rx_dq.base = calloc(NUMRXDESC,
 				sizeof(struct rx_descriptor));
 	if (priv->rx_dq.base == NULL) {
-		error("calloc() failed");
+		pr_err("calloc() failed");
 		goto eth_init_failed_3;
 	}
 
 	priv->rx_sq.base = calloc(NUMRXDESC,
 				sizeof(struct rx_status));
 	if (priv->rx_sq.base == NULL) {
-		error("calloc() failed");
+		pr_err("calloc() failed");
 		goto eth_init_failed_4;
 	}
 
 	dev = malloc(sizeof *dev);
 	if (dev == NULL) {
-		error("malloc() failed");
+		pr_err("malloc() failed");
 		goto eth_init_failed_5;
 	}
 	memset(dev, 0, sizeof *dev);
diff --git a/drivers/net/ethoc.c b/drivers/net/ethoc.c
index a6df950081..51a6c97550 100644
--- a/drivers/net/ethoc.c
+++ b/drivers/net/ethoc.c
@@ -548,8 +548,8 @@ static int ethoc_mdio_read(struct mii_dev *bus, int addr, int devad, int reg)
 	ethoc_write(priv, MIIADDRESS, MIIADDRESS_ADDR(addr, reg));
 	ethoc_write(priv, MIICOMMAND, MIICOMMAND_READ);
 
-	rc = wait_for_bit(__func__, ethoc_reg(priv, MIISTATUS),
-			  MIISTATUS_BUSY, false, CONFIG_SYS_HZ, false);
+	rc = wait_for_bit_le32(ethoc_reg(priv, MIISTATUS),
+			       MIISTATUS_BUSY, false, CONFIG_SYS_HZ, false);
 
 	if (rc == 0) {
 		u32 data = ethoc_read(priv, MIIRX_DATA);
@@ -571,8 +571,8 @@ static int ethoc_mdio_write(struct mii_dev *bus, int addr, int devad, int reg,
 	ethoc_write(priv, MIITX_DATA, val);
 	ethoc_write(priv, MIICOMMAND, MIICOMMAND_WRITE);
 
-	rc = wait_for_bit(__func__, ethoc_reg(priv, MIISTATUS),
-			  MIISTATUS_BUSY, false, CONFIG_SYS_HZ, false);
+	rc = wait_for_bit_le32(ethoc_reg(priv, MIISTATUS),
+			       MIISTATUS_BUSY, false, CONFIG_SYS_HZ, false);
 
 	if (rc == 0) {
 		/* reset MII command register */
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index f16b2990d7..133359089c 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -24,6 +24,10 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/mach-imx/sys_proto.h>
+#include <asm-generic/gpio.h>
+
+#include "fec_mxc.h"
+#include <eth_phy.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -1245,14 +1249,29 @@ static int fecmxc_probe(struct udevice *dev)
 	}
 
 	fec_reg_setup(priv);
-	priv->dev_id = (dev_id == -1) ? 0 : dev_id;
 
-	bus = fec_get_miibus(dev, dev_id);
+	priv->dev_id = dev->seq;
+
+#ifdef CONFIG_DM_ETH_PHY
+	bus = eth_phy_get_mdio_bus(dev);
+#endif
+
+	if (!bus) {
+#ifdef CONFIG_FEC_MXC_MDIO_BASE
+		bus = fec_get_miibus((ulong)CONFIG_FEC_MXC_MDIO_BASE, dev->seq);
+#else
+		bus = fec_get_miibus((ulong)priv->eth, dev->seq);
+#endif
+	}
 	if (!bus) {
 		ret = -ENOMEM;
 		goto err_mii;
 	}
 
+#ifdef CONFIG_DM_ETH_PHY
+	eth_phy_set_mdio_bus(dev, bus);
+#endif
+
 	priv->bus = bus;
 	priv->xcv_type = CONFIG_FEC_XCV_TYPE;
 	priv->interface = pdata->phy_interface;
diff --git a/drivers/net/fm/fm.c b/drivers/net/fm/fm.c
index 451dfded77..261f1b911b 100644
--- a/drivers/net/fm/fm.c
+++ b/drivers/net/fm/fm.c
@@ -405,8 +405,6 @@ int fm_init_common(int index, struct ccsr_fman *reg)
 		mmc_init(mmc);
 		(void)mmc->block_dev.block_read(&mmc->block_dev, blk, cnt,
 						addr);
-		/* flush cache after read */
-		flush_cache((ulong)addr, cnt * 512);
 	}
 #elif defined(CONFIG_SYS_QE_FMAN_FW_IN_REMOTE)
 	void *addr = (void *)CONFIG_SYS_FMAN_FW_ADDR;
diff --git a/drivers/net/fsl-mc/dpio/qbman_private.h b/drivers/net/fsl-mc/dpio/qbman_private.h
index 73bbae373e..873323be0f 100644
--- a/drivers/net/fsl-mc/dpio/qbman_private.h
+++ b/drivers/net/fsl-mc/dpio/qbman_private.h
@@ -175,8 +175,8 @@ void qbman_version(u32 *major, u32 *minor)
 	 * LS2080A SoC and its personalities has qbman cotroller version 4.0
 	 * New SoCs like LS2088A, LS1088A has qbman conroller version 4.1
 	 */
-	svr_dev_id = get_svr() >> 16;
-	if (svr_dev_id == SVR_DEV_LS2080A) {
+	svr_dev_id = get_svr();
+	if (IS_SVR_DEV(svr_dev_id, SVR_DEV(SVR_LS2080A))) {
 		*major = 4;
 		*minor = 0;
 	} else {
diff --git a/drivers/net/fsl-mc/mc.c b/drivers/net/fsl-mc/mc.c
index bdb6792c72..d90d150b29 100644
--- a/drivers/net/fsl-mc/mc.c
+++ b/drivers/net/fsl-mc/mc.c
@@ -8,7 +8,7 @@
 #include <errno.h>
 #include <linux/bug.h>
 #include <asm/io.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <net.h>
 #include <fdt_support.h>
 #include <fsl-mc/fsl_mc.h>
diff --git a/drivers/net/gmac_rockchip.c b/drivers/net/gmac_rockchip.c
index 586ccbff0a..61a32ce459 100644
--- a/drivers/net/gmac_rockchip.c
+++ b/drivers/net/gmac_rockchip.c
@@ -10,40 +10,141 @@
 #include <dm.h>
 #include <clk.h>
 #include <phy.h>
+#include <reset.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/periph.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/grf_rk3288.h>
-#include <asm/arch/grf_rk3368.h>
-#include <asm/arch/grf_rk3399.h>
-#include <dm/pinctrl.h>
-#include <dt-bindings/clock/rk3288-cru.h>
+#include <asm/arch-rockchip/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/hardware.h>
+#ifdef CONFIG_DWC_ETH_QOS
+#include <asm/arch-rockchip/grf_rk3568.h>
+#include <asm/arch-rockchip/grf_rk3588.h>
+#include <asm/arch-rockchip/grf_rv1106.h>
+#include <asm/arch-rockchip/grf_rv1126.h>
+#include "dwc_eth_qos.h"
+#else
+#include <asm/arch-rockchip/grf_px30.h>
+#include <asm/arch-rockchip/grf_rk1808.h>
+#include <asm/arch-rockchip/grf_rk322x.h>
+#include <asm/arch-rockchip/grf_rk3288.h>
+#include <asm/arch-rockchip/grf_rk3308.h>
+#include <asm/arch-rockchip/grf_rk3328.h>
+#include <asm/arch-rockchip/grf_rk3368.h>
+#include <asm/arch-rockchip/grf_rk3399.h>
+#include <asm/arch-rockchip/grf_rv1108.h>
 #include "designware.h"
+#include <dt-bindings/clock/rk3288-cru.h>
+#endif
+#include <dm/pinctrl.h>
+#include <dm/of_access.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+struct rockchip_eth_dev {
+#ifdef CONFIG_DWC_ETH_QOS
+	struct eqos_priv eqos;
+#else
+	struct dw_eth_dev dw;
+#endif
+	int phy_interface;
+};
+
 /*
  * Platform data for the gmac
  *
  * dw_eth_pdata: Required platform data for designware driver (must be first)
  */
 struct gmac_rockchip_platdata {
+#ifndef CONFIG_DWC_ETH_QOS
 	struct dw_eth_pdata dw_eth_pdata;
+#else
+	struct eth_pdata eth_pdata;
+#endif
+	struct reset_ctl phy_reset;
+	bool integrated_phy;
+	bool clock_input;
+	int phy_interface;
 	int tx_delay;
 	int rx_delay;
+	int bus_id;
 };
 
 struct rk_gmac_ops {
-	int (*fix_mac_speed)(struct dw_eth_dev *priv);
+#ifdef CONFIG_DWC_ETH_QOS
+	const struct eqos_config config;
+#endif
+	int (*fix_mac_speed)(struct gmac_rockchip_platdata *pdata,
+			     struct rockchip_eth_dev *dev);
+	void (*set_to_rmii)(struct gmac_rockchip_platdata *pdata);
 	void (*set_to_rgmii)(struct gmac_rockchip_platdata *pdata);
+	void (*set_clock_selection)(struct gmac_rockchip_platdata *pdata);
+	void (*integrated_phy_powerup)(struct gmac_rockchip_platdata *pdata);
+};
+
+#ifdef CONFIG_DWC_ETH_QOS
+static const struct eqos_config eqos_rockchip_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 200,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_NOT_ENABLED,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_100_150,
+	.ops = &eqos_rockchip_ops,
 };
+#endif
 
+void gmac_set_rgmii(struct udevice *dev, u32 tx_delay, u32 rx_delay)
+{
+	struct gmac_rockchip_platdata *pdata = dev_get_platdata(dev);
+	struct rk_gmac_ops *ops =
+		(struct rk_gmac_ops *)dev_get_driver_data(dev);
+
+	pdata->tx_delay = tx_delay;
+	pdata->rx_delay = rx_delay;
+
+	ops->set_to_rgmii(pdata);
+}
 
 static int gmac_rockchip_ofdata_to_platdata(struct udevice *dev)
 {
 	struct gmac_rockchip_platdata *pdata = dev_get_platdata(dev);
+	struct ofnode_phandle_args args;
+	struct udevice *phydev;
+	const char *string;
+	int ret;
+
+	string = dev_read_string(dev, "clock_in_out");
+	if (!strcmp(string, "input"))
+		pdata->clock_input = true;
+	else
+		pdata->clock_input = false;
+
+	/* If phy-handle property is passed from DT, use it as the PHY */
+	ret = dev_read_phandle_with_args(dev, "phy-handle", NULL, 0, 0, &args);
+	if (ret) {
+		debug("Cannot get phy phandle: ret=%d\n", ret);
+		pdata->integrated_phy = dev_read_bool(dev, "phy-is-integrated");
+	} else {
+		debug("Found phy-handle subnode\n");
+		pdata->integrated_phy = ofnode_read_bool(args.node,
+							 "phy-is-integrated");
+	}
+
+	if (pdata->integrated_phy) {
+		ret = reset_get_by_name(dev, "mac-phy", &pdata->phy_reset);
+		if (ret) {
+			ret = uclass_get_device_by_ofnode(UCLASS_ETH_PHY, args.node, &phydev);
+			if (ret) {
+				debug("Get phydev by ofnode failed: err=%d\n", ret);
+				return ret;
+			}
+
+			ret = reset_get_by_index(phydev, 0, &pdata->phy_reset);
+			if (ret) {
+				debug("No PHY reset control found: ret=%d\n", ret);
+				return ret;
+			}
+		}
+	}
 
 	/* Check the new naming-style first... */
 	pdata->tx_delay = dev_read_u32_default(dev, "tx_delay", -ENOENT);
@@ -55,11 +156,148 @@ static int gmac_rockchip_ofdata_to_platdata(struct udevice *dev)
 	if (pdata->rx_delay == -ENOENT)
 		pdata->rx_delay = dev_read_u32_default(dev, "rx-delay", 0x10);
 
+#ifdef CONFIG_DWC_ETH_QOS
+	return 0;
+#else
 	return designware_eth_ofdata_to_platdata(dev);
+#endif
+}
+
+#ifndef CONFIG_DWC_ETH_QOS
+static int px30_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				   struct rockchip_eth_dev *dev)
+{
+	struct dw_eth_dev *priv = &dev->dw;
+	struct px30_grf *grf;
+	struct clk clk_speed;
+	int speed, ret;
+	enum {
+		PX30_GMAC_SPEED_SHIFT = 0x2,
+		PX30_GMAC_SPEED_MASK  = BIT(2),
+		PX30_GMAC_SPEED_10M   = 0,
+		PX30_GMAC_SPEED_100M  = BIT(2),
+	};
+
+	ret = clk_get_by_name(priv->phydev->dev, "clk_mac_speed",
+			      &clk_speed);
+	if (ret)
+		return ret;
+
+	switch (priv->phydev->speed) {
+	case 10:
+		speed = PX30_GMAC_SPEED_10M;
+		ret = clk_set_rate(&clk_speed, 2500000);
+		if (ret)
+			return ret;
+		break;
+	case 100:
+		speed = PX30_GMAC_SPEED_100M;
+		ret = clk_set_rate(&clk_speed, 25000000);
+		if (ret)
+			return ret;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phydev->speed);
+		return -EINVAL;
+	}
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con1, PX30_GMAC_SPEED_MASK, speed);
+
+	return 0;
+}
+
+static int rk1808_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
+{
+	struct dw_eth_dev *priv = &dev->dw;
+	struct clk clk_speed;
+	int ret;
+
+	ret = clk_get_by_name(priv->phydev->dev, "clk_mac_speed",
+			      &clk_speed);
+	if (ret)
+		return ret;
+
+	switch (priv->phydev->speed) {
+	case 10:
+		ret = clk_set_rate(&clk_speed, 2500000);
+		if (ret)
+			return ret;
+		break;
+	case 100:
+		ret = clk_set_rate(&clk_speed, 25000000);
+		if (ret)
+			return ret;
+		break;
+	case 1000:
+		ret = clk_set_rate(&clk_speed, 125000000);
+		if (ret)
+			return ret;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phydev->speed);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk3228_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
+{
+	struct dw_eth_dev *priv = &dev->dw;
+	struct rk322x_grf *grf;
+	int clk;
+	enum {
+		RK3228_GMAC_CLK_SEL_SHIFT = 8,
+		RK3228_GMAC_CLK_SEL_MASK  = GENMASK(9, 8),
+		RK3228_GMAC_CLK_SEL_125M  = 0 << 8,
+		RK3228_GMAC_CLK_SEL_25M   = 3 << 8,
+		RK3228_GMAC_CLK_SEL_2_5M  = 2 << 8,
+
+		RK3228_GMAC_RMII_CLK_MASK   = BIT(7),
+		RK3228_GMAC_RMII_CLK_2_5M   = 0,
+		RK3228_GMAC_RMII_CLK_25M    = BIT(7),
+
+		RK3228_GMAC_RMII_SPEED_MASK = BIT(2),
+		RK3228_GMAC_RMII_SPEED_10   = 0,
+		RK3228_GMAC_RMII_SPEED_100  = BIT(2),
+	};
+
+	switch (priv->phydev->speed) {
+	case 10:
+		clk = (pdata->phy_interface == PHY_INTERFACE_MODE_RMII) ?
+		       (RK3228_GMAC_RMII_CLK_2_5M | RK3228_GMAC_RMII_SPEED_10) :
+		       RK3228_GMAC_CLK_SEL_2_5M;
+		break;
+	case 100:
+		clk = (pdata->phy_interface == PHY_INTERFACE_MODE_RMII) ?
+		       (RK3228_GMAC_RMII_CLK_25M | RK3228_GMAC_RMII_SPEED_100) :
+		       RK3228_GMAC_CLK_SEL_25M;
+		break;
+	case 1000:
+		clk = RK3228_GMAC_CLK_SEL_125M;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phydev->speed);
+		return -EINVAL;
+	}
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con[1],
+		     RK3228_GMAC_CLK_SEL_MASK |
+		     RK3228_GMAC_RMII_CLK_MASK |
+		     RK3228_GMAC_RMII_SPEED_MASK,
+		     clk);
+
+	return 0;
 }
 
-static int rk3288_gmac_fix_mac_speed(struct dw_eth_dev *priv)
+static int rk3288_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
 {
+	struct dw_eth_dev *priv = &dev->dw;
 	struct rk3288_grf *grf;
 	int clk;
 
@@ -84,8 +322,104 @@ static int rk3288_gmac_fix_mac_speed(struct dw_eth_dev *priv)
 	return 0;
 }
 
-static int rk3368_gmac_fix_mac_speed(struct dw_eth_dev *priv)
+static int rk3308_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
+{
+	struct dw_eth_dev *priv = &dev->dw;
+	struct rk3308_grf *grf;
+	struct clk clk_speed;
+	int speed, ret;
+	enum {
+		RK3308_GMAC_SPEED_SHIFT = 0x0,
+		RK3308_GMAC_SPEED_MASK  = BIT(0),
+		RK3308_GMAC_SPEED_10M   = 0,
+		RK3308_GMAC_SPEED_100M  = BIT(0),
+	};
+
+	ret = clk_get_by_name(priv->phydev->dev, "clk_mac_speed",
+			      &clk_speed);
+	if (ret)
+		return ret;
+
+	switch (priv->phydev->speed) {
+	case 10:
+		speed = RK3308_GMAC_SPEED_10M;
+		ret = clk_set_rate(&clk_speed, 2500000);
+		if (ret)
+			return ret;
+		break;
+	case 100:
+		speed = RK3308_GMAC_SPEED_100M;
+		ret = clk_set_rate(&clk_speed, 25000000);
+		if (ret)
+			return ret;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phydev->speed);
+		return -EINVAL;
+	}
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con0, RK3308_GMAC_SPEED_MASK, speed);
+
+	return 0;
+}
+
+static int rk3328_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
+{
+	struct dw_eth_dev *priv = &dev->dw;
+	struct rk3328_grf_regs *grf;
+	int clk;
+	enum {
+		RK3328_GMAC_CLK_SEL_SHIFT = 11,
+		RK3328_GMAC_CLK_SEL_MASK  = GENMASK(12, 11),
+		RK3328_GMAC_CLK_SEL_125M  = 0 << 11,
+		RK3328_GMAC_CLK_SEL_25M   = 3 << 11,
+		RK3328_GMAC_CLK_SEL_2_5M  = 2 << 11,
+
+		RK3328_GMAC_RMII_CLK_MASK   = BIT(7),
+		RK3328_GMAC_RMII_CLK_2_5M   = 0,
+		RK3328_GMAC_RMII_CLK_25M    = BIT(7),
+
+		RK3328_GMAC_RMII_SPEED_MASK = BIT(2),
+		RK3328_GMAC_RMII_SPEED_10   = 0,
+		RK3328_GMAC_RMII_SPEED_100  = BIT(2),
+	};
+
+	switch (priv->phydev->speed) {
+	case 10:
+		clk = (pdata->phy_interface == PHY_INTERFACE_MODE_RMII) ?
+		       (RK3328_GMAC_RMII_CLK_2_5M | RK3328_GMAC_RMII_SPEED_10) :
+		       RK3328_GMAC_CLK_SEL_2_5M;
+		break;
+	case 100:
+		clk = (pdata->phy_interface == PHY_INTERFACE_MODE_RMII) ?
+		       (RK3328_GMAC_RMII_CLK_25M | RK3328_GMAC_RMII_SPEED_100) :
+		       RK3328_GMAC_CLK_SEL_25M;
+		break;
+	case 1000:
+		clk = RK3328_GMAC_CLK_SEL_125M;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phydev->speed);
+		return -EINVAL;
+	}
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(pdata->integrated_phy ? &grf->mac_con[2] : &grf->mac_con[1],
+		     RK3328_GMAC_CLK_SEL_MASK |
+		     RK3328_GMAC_RMII_CLK_MASK |
+		     RK3328_GMAC_RMII_SPEED_MASK,
+		     clk);
+
+	return 0;
+}
+
+static int rk3368_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
 {
+	struct dw_eth_dev *priv = &dev->dw;
 	struct rk3368_grf *grf;
 	int clk;
 	enum {
@@ -116,8 +450,10 @@ static int rk3368_gmac_fix_mac_speed(struct dw_eth_dev *priv)
 	return 0;
 }
 
-static int rk3399_gmac_fix_mac_speed(struct dw_eth_dev *priv)
+static int rk3399_gmac_fix_mac_speed(struct gmac_rockchip_platdata *pdata,
+				     struct rockchip_eth_dev *dev)
 {
+	struct dw_eth_dev *priv = &dev->dw;
 	struct rk3399_grf_regs *grf;
 	int clk;
 
@@ -142,136 +478,1148 @@ static int rk3399_gmac_fix_mac_speed(struct dw_eth_dev *priv)
 	return 0;
 }
 
-static void rk3288_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+static int rv1108_set_rmii_speed(struct gmac_rockchip_platdata *pdata,
+				 struct rockchip_eth_dev *dev)
 {
-	struct rk3288_grf *grf;
+	struct dw_eth_dev *priv = &dev->dw;
+	struct rv1108_grf *grf;
+	int clk, speed;
+	enum {
+		RV1108_GMAC_SPEED_MASK		= BIT(2),
+		RV1108_GMAC_SPEED_10M		= 0 << 2,
+		RV1108_GMAC_SPEED_100M		= 1 << 2,
+		RV1108_GMAC_CLK_SEL_MASK	= BIT(7),
+		RV1108_GMAC_CLK_SEL_2_5M	= 0 << 7,
+		RV1108_GMAC_CLK_SEL_25M		= 1 << 7,
+	};
+
+	switch (priv->phydev->speed) {
+	case 10:
+		clk = RV1108_GMAC_CLK_SEL_2_5M;
+		speed = RV1108_GMAC_SPEED_10M;
+		break;
+	case 100:
+		clk = RV1108_GMAC_CLK_SEL_25M;
+		speed = RV1108_GMAC_SPEED_100M;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phydev->speed);
+		return -EINVAL;
+	}
 
 	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
-	rk_clrsetreg(&grf->soc_con1,
-		     RK3288_RMII_MODE_MASK | RK3288_GMAC_PHY_INTF_SEL_MASK,
-		     RK3288_GMAC_PHY_INTF_SEL_RGMII);
+	rk_clrsetreg(&grf->gmac_con0,
+		     RV1108_GMAC_CLK_SEL_MASK | RV1108_GMAC_SPEED_MASK,
+		     clk | speed);
 
-	rk_clrsetreg(&grf->soc_con3,
-		     RK3288_RXCLK_DLY_ENA_GMAC_MASK |
-		     RK3288_TXCLK_DLY_ENA_GMAC_MASK |
-		     RK3288_CLK_RX_DL_CFG_GMAC_MASK |
-		     RK3288_CLK_TX_DL_CFG_GMAC_MASK,
-		     RK3288_RXCLK_DLY_ENA_GMAC_ENABLE |
-		     RK3288_TXCLK_DLY_ENA_GMAC_ENABLE |
-		     pdata->rx_delay << RK3288_CLK_RX_DL_CFG_GMAC_SHIFT |
-		     pdata->tx_delay << RK3288_CLK_TX_DL_CFG_GMAC_SHIFT);
+	return 0;
 }
-
-static void rk3368_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+#else
+static int rk3588_set_rgmii_speed(struct gmac_rockchip_platdata *pdata,
+				  struct rockchip_eth_dev *dev)
 {
-	struct rk3368_grf *grf;
-	enum {
-		RK3368_GMAC_PHY_INTF_SEL_RGMII = 1 << 9,
-		RK3368_GMAC_PHY_INTF_SEL_MASK = GENMASK(11, 9),
-		RK3368_RMII_MODE_MASK  = BIT(6),
-		RK3368_RMII_MODE       = BIT(6),
-	};
+	struct eqos_priv *priv = &dev->eqos;
+	struct rk3588_php_grf *php_grf;
+	unsigned int div, div_mask;
+
 	enum {
-		RK3368_RXCLK_DLY_ENA_GMAC_MASK = BIT(15),
-		RK3368_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
-		RK3368_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(15),
-		RK3368_TXCLK_DLY_ENA_GMAC_MASK = BIT(7),
-		RK3368_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
-		RK3368_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(7),
-		RK3368_CLK_RX_DL_CFG_GMAC_SHIFT = 8,
-		RK3368_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(14, 8),
-		RK3368_CLK_TX_DL_CFG_GMAC_SHIFT = 0,
-		RK3368_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(6, 0),
+		RK3588_GMAC_CLK_RGMII_DIV_SHIFT = 2,
+		RK3588_GMAC_CLK_RGMII_DIV_MASK = GENMASK(3, 2),
+		RK3588_GMAC_CLK_RGMII_DIV1 = 0,
+		RK3588_GMAC_CLK_RGMII_DIV5 = GENMASK(3, 2),
+		RK3588_GMAC_CLK_RGMII_DIV50 = BIT(3),
+		RK3588_GMA_CLK_RMII_DIV2 = BIT(2),
+		RK3588_GMAC_CLK_RMII_DIV20 = 0,
 	};
 
-	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
-	rk_clrsetreg(&grf->soc_con15,
-		     RK3368_RMII_MODE_MASK | RK3368_GMAC_PHY_INTF_SEL_MASK,
-		     RK3368_GMAC_PHY_INTF_SEL_RGMII);
-
-	rk_clrsetreg(&grf->soc_con16,
-		     RK3368_RXCLK_DLY_ENA_GMAC_MASK |
-		     RK3368_TXCLK_DLY_ENA_GMAC_MASK |
-		     RK3368_CLK_RX_DL_CFG_GMAC_MASK |
-		     RK3368_CLK_TX_DL_CFG_GMAC_MASK,
-		     RK3368_RXCLK_DLY_ENA_GMAC_ENABLE |
-		     RK3368_TXCLK_DLY_ENA_GMAC_ENABLE |
-		     pdata->rx_delay << RK3368_CLK_RX_DL_CFG_GMAC_SHIFT |
-		     pdata->tx_delay << RK3368_CLK_TX_DL_CFG_GMAC_SHIFT);
-}
+	php_grf = syscon_get_first_range(ROCKCHIP_SYSCON_PHP_GRF);
 
-static void rk3399_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
-{
-	struct rk3399_grf_regs *grf;
+	switch (priv->phy->speed) {
+	case 10:
+		if (pdata->phy_interface == PHY_INTERFACE_MODE_RMII)
+			div = RK3588_GMAC_CLK_RMII_DIV20;
+		else
+			div = RK3588_GMAC_CLK_RGMII_DIV50;
+		break;
+	case 100:
+		if (pdata->phy_interface == PHY_INTERFACE_MODE_RMII)
+			div = RK3588_GMA_CLK_RMII_DIV2;
+		else
+			div = RK3588_GMAC_CLK_RGMII_DIV5;
+		break;
+	case 1000:
+		if (pdata->phy_interface != PHY_INTERFACE_MODE_RMII)
+			div = RK3588_GMAC_CLK_RGMII_DIV1;
+		else
+			return -EINVAL;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phy->speed);
+		return -EINVAL;
+	}
 
-	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (pdata->bus_id == 1) {
+		div <<= 5;
+		div_mask = RK3588_GMAC_CLK_RGMII_DIV_MASK << 5;
+	}
 
-	rk_clrsetreg(&grf->soc_con5,
-		     RK3399_GMAC_PHY_INTF_SEL_MASK,
-		     RK3399_GMAC_PHY_INTF_SEL_RGMII);
+	rk_clrsetreg(&php_grf->clk_con1, div_mask, div);
 
-	rk_clrsetreg(&grf->soc_con6,
-		     RK3399_RXCLK_DLY_ENA_GMAC_MASK |
-		     RK3399_TXCLK_DLY_ENA_GMAC_MASK |
-		     RK3399_CLK_RX_DL_CFG_GMAC_MASK |
-		     RK3399_CLK_TX_DL_CFG_GMAC_MASK,
-		     RK3399_RXCLK_DLY_ENA_GMAC_ENABLE |
-		     RK3399_TXCLK_DLY_ENA_GMAC_ENABLE |
-		     pdata->rx_delay << RK3399_CLK_RX_DL_CFG_GMAC_SHIFT |
-		     pdata->tx_delay << RK3399_CLK_TX_DL_CFG_GMAC_SHIFT);
+	return 0;
 }
 
-static int gmac_rockchip_probe(struct udevice *dev)
+static int rv1106_set_rmii_speed(struct gmac_rockchip_platdata *pdata,
+				 struct rockchip_eth_dev *dev)
 {
-	struct gmac_rockchip_platdata *pdata = dev_get_platdata(dev);
-	struct rk_gmac_ops *ops =
-		(struct rk_gmac_ops *)dev_get_driver_data(dev);
-	struct clk clk;
-	int ret;
+	struct eqos_priv *priv = &dev->eqos;
+	struct rv1106_grf *grf;
+	unsigned int div;
 
-	ret = clk_get_by_index(dev, 0, &clk);
-	if (ret)
-		return ret;
+	enum {
+		RV1106_GMAC_CLK_RMII_DIV_SHIFT = 2,
+		RV1106_GMAC_CLK_RMII_DIV_MASK = GENMASK(3, 2),
+		RV1106_GMAC_CLK_RMII_DIV2 = BIT(2),
+		RV1106_GMAC_CLK_RMII_DIV20 = 0,
+	};
 
-	/* Since mac_clk is fed by an external clock we can use 0 here */
-	ret = clk_set_rate(&clk, 0);
-	if (ret)
-		return ret;
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
 
-	/* Set to RGMII mode */
-	ops->set_to_rgmii(pdata);
+	switch (priv->phy->speed) {
+	case 10:
+		div = RV1106_GMAC_CLK_RMII_DIV20;
+		break;
+	case 100:
+		div = RV1106_GMAC_CLK_RMII_DIV2;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phy->speed);
+		return -EINVAL;
+	}
 
-	return designware_eth_probe(dev);
+	rk_clrsetreg(&grf->gmac_clk_con, RV1106_GMAC_CLK_RMII_DIV_MASK, div);
+
+	return 0;
 }
 
-static int gmac_rockchip_eth_start(struct udevice *dev)
+static int rv1126_set_rgmii_speed(struct gmac_rockchip_platdata *pdata,
+				  struct rockchip_eth_dev *dev)
 {
-	struct eth_pdata *pdata = dev_get_platdata(dev);
-	struct dw_eth_dev *priv = dev_get_priv(dev);
-	struct rk_gmac_ops *ops =
-		(struct rk_gmac_ops *)dev_get_driver_data(dev);
+	struct eqos_priv *priv = &dev->eqos;
+	struct clk clk_speed;
 	int ret;
 
-	ret = designware_eth_init(priv, pdata->enetaddr);
-	if (ret)
+	ret = clk_get_by_name(priv->phy->dev, "clk_mac_speed",
+			      &clk_speed);
+	if (ret) {
+		printf("%s can't get clk_mac_speed clock (ret=%d):\n",
+		       __func__, ret);
 		return ret;
-	ret = ops->fix_mac_speed(priv);
-	if (ret)
+	}
+
+	switch ( priv->phy->speed) {
+	case 10:
+		ret = clk_set_rate(&clk_speed, 2500000);
+		if (ret)
+			return ret;
+		break;
+	case 100:
+		ret = clk_set_rate(&clk_speed, 25000000);
+		if (ret)
+			return ret;
+		break;
+	case 1000:
+		ret = clk_set_rate(&clk_speed, 125000000);
+		if (ret)
+			return ret;
+		break;
+	default:
+		debug("Unknown phy speed: %d\n", priv->phy->speed);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_DWC_ETH_QOS
+static void px30_gmac_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct px30_grf *grf;
+	enum {
+		px30_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		px30_GMAC_PHY_INTF_SEL_MASK  = GENMASK(4, 6),
+		px30_GMAC_PHY_INTF_SEL_RMII  = BIT(6),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	rk_clrsetreg(&grf->mac_con1,
+		     px30_GMAC_PHY_INTF_SEL_MASK,
+		     px30_GMAC_PHY_INTF_SEL_RMII);
+}
+
+static void rk1808_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk1808_grf *grf;
+	enum {
+		RK1808_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RK1808_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RK1808_GMAC_PHY_INTF_SEL_RGMII = BIT(4),
+
+		RK1808_RXCLK_DLY_ENA_GMAC_MASK = BIT(1),
+		RK1808_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK1808_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(1),
+
+		RK1808_TXCLK_DLY_ENA_GMAC_MASK = BIT(0),
+		RK1808_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK1808_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(0),
+	};
+	enum {
+		RK1808_CLK_RX_DL_CFG_GMAC_SHIFT = 0x8,
+		RK1808_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(15, 7),
+
+		RK1808_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RK1808_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(7, 0),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con1,
+		     RK1808_GMAC_PHY_INTF_SEL_MASK |
+		     RK1808_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK1808_TXCLK_DLY_ENA_GMAC_MASK,
+		     RK1808_GMAC_PHY_INTF_SEL_RGMII |
+		     RK1808_RXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK1808_TXCLK_DLY_ENA_GMAC_ENABLE);
+
+	rk_clrsetreg(&grf->mac_con0,
+		     RK1808_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK1808_CLK_TX_DL_CFG_GMAC_MASK,
+		     pdata->rx_delay << RK1808_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK1808_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+
+static void rk3228_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk322x_grf *grf;
+	enum {
+		RK3228_RMII_MODE_SHIFT = 10,
+		RK3228_RMII_MODE_MASK  = BIT(10),
+
+		RK3228_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RK3228_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RK3228_GMAC_PHY_INTF_SEL_RGMII = BIT(4),
+
+		RK3228_RXCLK_DLY_ENA_GMAC_MASK = BIT(1),
+		RK3228_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3228_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(1),
+
+		RK3228_TXCLK_DLY_ENA_GMAC_MASK = BIT(0),
+		RK3228_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3228_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(0),
+	};
+	enum {
+		RK3228_CLK_RX_DL_CFG_GMAC_SHIFT = 0x7,
+		RK3228_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(13, 7),
+
+		RK3228_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RK3228_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(6, 0),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con[1],
+		     RK3228_RMII_MODE_MASK |
+		     RK3228_GMAC_PHY_INTF_SEL_MASK |
+		     RK3228_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3228_TXCLK_DLY_ENA_GMAC_MASK,
+		     RK3228_GMAC_PHY_INTF_SEL_RGMII |
+		     RK3228_RXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK3228_TXCLK_DLY_ENA_GMAC_ENABLE);
+
+	rk_clrsetreg(&grf->mac_con[0],
+		     RK3228_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK3228_CLK_TX_DL_CFG_GMAC_MASK,
+		     pdata->rx_delay << RK3228_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK3228_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+
+static void rk3228_gmac_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk322x_grf *grf;
+	enum {
+		RK3228_GRF_CON_RMII_MODE_MASK = BIT(11),
+		RK3228_GRF_CON_RMII_MODE_SEL = BIT(11),
+		RK3228_RMII_MODE_MASK = BIT(10),
+		RK3228_RMII_MODE_SEL = BIT(10),
+		RK3228_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RK3228_GMAC_PHY_INTF_SEL_RMII = BIT(6),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con[1],
+		     RK3228_GRF_CON_RMII_MODE_MASK |
+		     RK3228_RMII_MODE_MASK |
+		     RK3228_GMAC_PHY_INTF_SEL_MASK,
+		     RK3228_GRF_CON_RMII_MODE_SEL |
+		     RK3228_RMII_MODE_SEL |
+		     RK3228_GMAC_PHY_INTF_SEL_RMII);
+}
+
+static void rk3288_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3288_grf *grf;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->soc_con1,
+		     RK3288_RMII_MODE_MASK | RK3288_GMAC_PHY_INTF_SEL_MASK,
+		     RK3288_GMAC_PHY_INTF_SEL_RGMII);
+
+	rk_clrsetreg(&grf->soc_con3,
+		     RK3288_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3288_TXCLK_DLY_ENA_GMAC_MASK |
+		     RK3288_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK3288_CLK_TX_DL_CFG_GMAC_MASK,
+		     RK3288_RXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK3288_TXCLK_DLY_ENA_GMAC_ENABLE |
+		     pdata->rx_delay << RK3288_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK3288_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+
+static void rk3308_gmac_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3308_grf *grf;
+	enum {
+		RK3308_GMAC_PHY_INTF_SEL_SHIFT = 2,
+		RK3308_GMAC_PHY_INTF_SEL_MASK  = GENMASK(4, 2),
+		RK3308_GMAC_PHY_INTF_SEL_RMII  = BIT(4),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	rk_clrsetreg(&grf->mac_con0,
+		     RK3308_GMAC_PHY_INTF_SEL_MASK,
+		     RK3308_GMAC_PHY_INTF_SEL_RMII);
+}
+
+static void rk3328_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3328_grf_regs *grf;
+	enum {
+		RK3328_RMII_MODE_SHIFT = 9,
+		RK3328_RMII_MODE_MASK  = BIT(9),
+
+		RK3328_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RK3328_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RK3328_GMAC_PHY_INTF_SEL_RGMII = BIT(4),
+
+		RK3328_RXCLK_DLY_ENA_GMAC_MASK = BIT(1),
+		RK3328_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3328_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(1),
+
+		RK3328_TXCLK_DLY_ENA_GMAC_MASK = BIT(0),
+		RK3328_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3328_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(0),
+	};
+	enum {
+		RK3328_CLK_RX_DL_CFG_GMAC_SHIFT = 0x7,
+		RK3328_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(13, 7),
+
+		RK3328_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RK3328_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(6, 0),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->mac_con[1],
+		     RK3328_RMII_MODE_MASK |
+		     RK3328_GMAC_PHY_INTF_SEL_MASK |
+		     RK3328_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3328_TXCLK_DLY_ENA_GMAC_MASK,
+		     RK3328_GMAC_PHY_INTF_SEL_RGMII |
+		     RK3328_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3328_TXCLK_DLY_ENA_GMAC_ENABLE);
+
+	rk_clrsetreg(&grf->mac_con[0],
+		     RK3328_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK3328_CLK_TX_DL_CFG_GMAC_MASK,
+		     pdata->rx_delay << RK3328_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK3328_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+
+static void rk3328_gmac_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3328_grf_regs *grf;
+	enum {
+		RK3328_RMII_MODE_MASK  = BIT(9),
+		RK3328_RMII_MODE = BIT(9),
+
+		RK3328_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RK3328_GMAC_PHY_INTF_SEL_RMII = BIT(6),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(pdata->integrated_phy ? &grf->mac_con[2] : &grf->mac_con[1],
+		     RK3328_RMII_MODE_MASK |
+		     RK3328_GMAC_PHY_INTF_SEL_MASK,
+		     RK3328_GMAC_PHY_INTF_SEL_RMII |
+		     RK3328_RMII_MODE);
+}
+
+static void rk3368_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3368_grf *grf;
+	enum {
+		RK3368_GMAC_PHY_INTF_SEL_RGMII = 1 << 9,
+		RK3368_GMAC_PHY_INTF_SEL_MASK = GENMASK(11, 9),
+		RK3368_RMII_MODE_MASK  = BIT(6),
+		RK3368_RMII_MODE       = BIT(6),
+	};
+	enum {
+		RK3368_RXCLK_DLY_ENA_GMAC_MASK = BIT(15),
+		RK3368_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3368_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(15),
+		RK3368_TXCLK_DLY_ENA_GMAC_MASK = BIT(7),
+		RK3368_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3368_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(7),
+		RK3368_CLK_RX_DL_CFG_GMAC_SHIFT = 8,
+		RK3368_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(14, 8),
+		RK3368_CLK_TX_DL_CFG_GMAC_SHIFT = 0,
+		RK3368_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(6, 0),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->soc_con15,
+		     RK3368_RMII_MODE_MASK | RK3368_GMAC_PHY_INTF_SEL_MASK,
+		     RK3368_GMAC_PHY_INTF_SEL_RGMII);
+
+	rk_clrsetreg(&grf->soc_con16,
+		     RK3368_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3368_TXCLK_DLY_ENA_GMAC_MASK |
+		     RK3368_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK3368_CLK_TX_DL_CFG_GMAC_MASK,
+		     RK3368_RXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK3368_TXCLK_DLY_ENA_GMAC_ENABLE |
+		     pdata->rx_delay << RK3368_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK3368_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+
+static void rk3399_gmac_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3399_grf_regs *grf;
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	rk_clrsetreg(&grf->soc_con5,
+		     RK3399_GMAC_PHY_INTF_SEL_MASK,
+		     RK3399_GMAC_PHY_INTF_SEL_RGMII);
+
+	rk_clrsetreg(&grf->soc_con6,
+		     RK3399_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3399_TXCLK_DLY_ENA_GMAC_MASK |
+		     RK3399_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK3399_CLK_TX_DL_CFG_GMAC_MASK,
+		     RK3399_RXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK3399_TXCLK_DLY_ENA_GMAC_ENABLE |
+		     pdata->rx_delay << RK3399_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK3399_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+
+static void rv1108_gmac_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rv1108_grf *grf;
+
+	enum {
+		RV1108_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RV1108_GMAC_PHY_INTF_SEL_RMII  = 4 << 4,
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->gmac_con0,
+		     RV1108_GMAC_PHY_INTF_SEL_MASK,
+		     RV1108_GMAC_PHY_INTF_SEL_RMII);
+}
+
+static void rk3228_gmac_integrated_phy_powerup(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk322x_grf *grf;
+	enum {
+		RK3228_GRF_CON_MUX_GMAC_INTEGRATED_PHY_MASK = BIT(15),
+		RK3228_GRF_CON_MUX_GMAC_INTEGRATED_PHY = BIT(15),
+	};
+	enum {
+		RK3228_MACPHY_CFG_CLK_50M_MASK = BIT(14),
+		RK3228_MACPHY_CFG_CLK_50M = BIT(14),
+
+		RK3228_MACPHY_RMII_MODE_MASK = GENMASK(7, 6),
+		RK3228_MACPHY_RMII_MODE = BIT(6),
+
+		RK3228_MACPHY_ENABLE_MASK = BIT(0),
+		RK3228_MACPHY_DISENABLE = 0,
+		RK3228_MACPHY_ENABLE = BIT(0),
+	};
+	enum {
+		RK3228_RK_GRF_CON2_MACPHY_ID_MASK = GENMASK(6, 0),
+		RK3228_RK_GRF_CON2_MACPHY_ID = 0x1234,
+	};
+	enum {
+		RK3228_RK_GRF_CON3_MACPHY_ID_MASK = GENMASK(5, 0),
+		RK3228_RK_GRF_CON3_MACPHY_ID = 0x35,
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->con_iomux,
+		     RK3228_GRF_CON_MUX_GMAC_INTEGRATED_PHY_MASK,
+		     RK3228_GRF_CON_MUX_GMAC_INTEGRATED_PHY);
+
+	rk_clrsetreg(&grf->macphy_con[2],
+		     RK3228_RK_GRF_CON2_MACPHY_ID_MASK,
+		     RK3228_RK_GRF_CON2_MACPHY_ID);
+
+	rk_clrsetreg(&grf->macphy_con[3],
+		     RK3228_RK_GRF_CON3_MACPHY_ID_MASK,
+		     RK3228_RK_GRF_CON3_MACPHY_ID);
+
+	/* disabled before trying to reset it &*/
+	rk_clrsetreg(&grf->macphy_con[0],
+		     RK3228_MACPHY_CFG_CLK_50M_MASK |
+		     RK3228_MACPHY_RMII_MODE_MASK |
+		     RK3228_MACPHY_ENABLE_MASK,
+		     RK3228_MACPHY_CFG_CLK_50M |
+		     RK3228_MACPHY_RMII_MODE |
+		     RK3228_MACPHY_DISENABLE);
+
+	reset_assert(&pdata->phy_reset);
+	udelay(10);
+	reset_deassert(&pdata->phy_reset);
+	udelay(10);
+
+	rk_clrsetreg(&grf->macphy_con[0],
+		     RK3228_MACPHY_ENABLE_MASK,
+		     RK3228_MACPHY_ENABLE);
+	udelay(30 * 1000);
+}
+
+static void rk3328_gmac_integrated_phy_powerup(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3328_grf_regs *grf;
+	enum {
+		RK3328_GRF_CON_RMII_MODE_MASK = BIT(9),
+		RK3328_GRF_CON_RMII_MODE = BIT(9),
+	};
+	enum {
+		RK3328_MACPHY_CFG_CLK_50M_MASK = BIT(14),
+		RK3328_MACPHY_CFG_CLK_50M = BIT(14),
+
+		RK3328_MACPHY_RMII_MODE_MASK = GENMASK(7, 6),
+		RK3328_MACPHY_RMII_MODE = BIT(6),
+
+		RK3328_MACPHY_ENABLE_MASK = BIT(0),
+		RK3328_MACPHY_DISENABLE = 0,
+		RK3328_MACPHY_ENABLE = BIT(0),
+	};
+	enum {
+		RK3328_RK_GRF_CON2_MACPHY_ID_MASK = GENMASK(6, 0),
+		RK3328_RK_GRF_CON2_MACPHY_ID = 0x1234,
+	};
+	enum {
+		RK3328_RK_GRF_CON3_MACPHY_ID_MASK = GENMASK(5, 0),
+		RK3328_RK_GRF_CON3_MACPHY_ID = 0x35,
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	rk_clrsetreg(&grf->macphy_con[1],
+		     RK3328_GRF_CON_RMII_MODE_MASK,
+		     RK3328_GRF_CON_RMII_MODE);
+
+	rk_clrsetreg(&grf->macphy_con[2],
+		     RK3328_RK_GRF_CON2_MACPHY_ID_MASK,
+		     RK3328_RK_GRF_CON2_MACPHY_ID);
+
+	rk_clrsetreg(&grf->macphy_con[3],
+		     RK3328_RK_GRF_CON3_MACPHY_ID_MASK,
+		     RK3328_RK_GRF_CON3_MACPHY_ID);
+
+	/* disabled before trying to reset it &*/
+	rk_clrsetreg(&grf->macphy_con[0],
+		     RK3328_MACPHY_CFG_CLK_50M_MASK |
+		     RK3328_MACPHY_RMII_MODE_MASK |
+		     RK3328_MACPHY_ENABLE_MASK,
+		     RK3328_MACPHY_CFG_CLK_50M |
+		     RK3328_MACPHY_RMII_MODE |
+		     RK3328_MACPHY_DISENABLE);
+
+	reset_assert(&pdata->phy_reset);
+	udelay(10);
+	reset_deassert(&pdata->phy_reset);
+	udelay(10);
+
+	rk_clrsetreg(&grf->macphy_con[0],
+		     RK3328_MACPHY_ENABLE_MASK,
+		     RK3328_MACPHY_ENABLE);
+	udelay(30 * 1000);
+}
+
+#else
+static void rk3568_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3568_grf *grf;
+	void *con1;
+
+	enum {
+		RK3568_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RK3568_GMAC_PHY_INTF_SEL_MASK = GENMASK(6, 4),
+		RK3568_GMAC_PHY_INTF_SEL_RMII = BIT(6),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	if (pdata->bus_id == 1)
+		con1 = &grf->mac1_con1;
+	else
+		con1 = &grf->mac0_con1;
+
+	rk_clrsetreg(con1,
+		     RK3568_GMAC_PHY_INTF_SEL_MASK,
+		     RK3568_GMAC_PHY_INTF_SEL_RMII);
+}
+
+static void rk3568_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3568_grf *grf;
+	void *con0, *con1;
+
+	enum {
+		RK3568_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RK3568_GMAC_PHY_INTF_SEL_MASK = GENMASK(6, 4),
+		RK3568_GMAC_PHY_INTF_SEL_RGMII = BIT(4),
+
+		RK3568_RXCLK_DLY_ENA_GMAC_MASK = BIT(1),
+		RK3568_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3568_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(1),
+
+		RK3568_TXCLK_DLY_ENA_GMAC_MASK = BIT(0),
+		RK3568_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3568_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(0),
+	};
+
+	enum {
+		RK3568_CLK_RX_DL_CFG_GMAC_SHIFT = 0x8,
+		RK3568_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(15, 8),
+
+		RK3568_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RK3568_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(7, 0),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	if (pdata->bus_id == 1) {
+		con0 = &grf->mac1_con0;
+		con1 = &grf->mac1_con1;
+	} else {
+		con0 = &grf->mac0_con0;
+		con1 = &grf->mac0_con1;
+	}
+
+	rk_clrsetreg(con0,
+		     RK3568_CLK_RX_DL_CFG_GMAC_MASK |
+		     RK3568_CLK_TX_DL_CFG_GMAC_MASK,
+		     pdata->rx_delay << RK3568_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RK3568_CLK_TX_DL_CFG_GMAC_SHIFT);
+
+	rk_clrsetreg(con1,
+		     RK3568_TXCLK_DLY_ENA_GMAC_MASK |
+		     RK3568_RXCLK_DLY_ENA_GMAC_MASK |
+		     RK3568_GMAC_PHY_INTF_SEL_MASK,
+		     RK3568_TXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK3568_RXCLK_DLY_ENA_GMAC_ENABLE |
+		     RK3568_GMAC_PHY_INTF_SEL_RGMII);
+}
+
+static void rk3588_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	unsigned int intf_sel, intf_sel_mask;
+	unsigned int clk_mode, clk_mode_mask;
+	struct rk3588_php_grf *php_grf;
+
+	enum {
+		RK3588_GMAC_PHY_INTF_SEL_SHIFT = 3,
+		RK3588_GMAC_PHY_INTF_SEL_MASK = GENMASK(5, 3),
+		RK3588_GMAC_PHY_INTF_SEL_RMII = BIT(5),
+	};
+
+	enum {
+		RK3588_GMAC_CLK_RMII_MODE_SHIFT = 0x0,
+		RK3588_GMAC_CLK_RMII_MODE_MASK = BIT(0),
+		RK3588_GMAC_CLK_RMII_MODE = 0x1,
+	};
+
+	php_grf = syscon_get_first_range(ROCKCHIP_SYSCON_PHP_GRF);
+
+	if (pdata->bus_id == 1) {
+		intf_sel = RK3588_GMAC_PHY_INTF_SEL_RMII << 6;
+		intf_sel_mask = RK3588_GMAC_PHY_INTF_SEL_MASK << 6;
+		clk_mode = RK3588_GMAC_CLK_RMII_MODE << 5;
+		clk_mode_mask = RK3588_GMAC_CLK_RMII_MODE_MASK << 5;
+	} else {
+		intf_sel = RK3588_GMAC_PHY_INTF_SEL_RMII;
+		intf_sel_mask = RK3588_GMAC_PHY_INTF_SEL_MASK;
+		clk_mode = RK3588_GMAC_CLK_RMII_MODE;
+		clk_mode_mask = RK3588_GMAC_CLK_RMII_MODE_MASK;
+	}
+
+	rk_clrsetreg(&php_grf->gmac_con0, intf_sel_mask, intf_sel);
+	rk_clrsetreg(&php_grf->clk_con1, clk_mode_mask, clk_mode);
+}
+
+static void rk3588_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	unsigned int rx_enable, rx_enable_mask, tx_enable, tx_enable_mask;
+	unsigned int intf_sel, intf_sel_mask;
+	unsigned int clk_mode, clk_mode_mask;
+	unsigned int rx_delay;
+	struct rk3588_php_grf *php_grf;
+	struct rk3588_sys_grf *grf;
+	void *offset_con;
+
+	enum {
+		RK3588_GMAC_PHY_INTF_SEL_SHIFT = 3,
+		RK3588_GMAC_PHY_INTF_SEL_MASK = GENMASK(5, 3),
+		RK3588_GMAC_PHY_INTF_SEL_RGMII = BIT(3),
+
+		RK3588_RXCLK_DLY_ENA_GMAC_MASK = BIT(3),
+		RK3588_RXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3588_RXCLK_DLY_ENA_GMAC_ENABLE = BIT(3),
+
+		RK3588_TXCLK_DLY_ENA_GMAC_MASK = BIT(2),
+		RK3588_TXCLK_DLY_ENA_GMAC_DISABLE = 0,
+		RK3588_TXCLK_DLY_ENA_GMAC_ENABLE = BIT(2),
+	};
+
+	enum {
+		RK3588_CLK_RX_DL_CFG_GMAC_SHIFT = 0x8,
+		RK3588_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(15, 8),
+
+		RK3588_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RK3588_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(7, 0),
+	};
+
+	enum {
+		RK3588_GMAC_CLK_RGMII_MODE_SHIFT = 0x0,
+		RK3588_GMAC_CLK_RGMII_MODE_MASK = BIT(0),
+		RK3588_GMAC_CLK_RGMII_MODE = 0x0,
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	php_grf = syscon_get_first_range(ROCKCHIP_SYSCON_PHP_GRF);
+
+	if (pdata->rx_delay < 0) {
+		rx_enable = RK3588_RXCLK_DLY_ENA_GMAC_DISABLE;
+		rx_delay = 0;
+	} else {
+		rx_enable = RK3588_RXCLK_DLY_ENA_GMAC_ENABLE;
+		rx_delay = pdata->rx_delay << RK3588_CLK_RX_DL_CFG_GMAC_SHIFT;
+	}
+
+	if (pdata->bus_id == 1) {
+		offset_con = &grf->soc_con9;
+		rx_enable = rx_delay << 2;
+		rx_enable_mask = RK3588_RXCLK_DLY_ENA_GMAC_MASK << 2;
+		tx_enable = RK3588_TXCLK_DLY_ENA_GMAC_ENABLE << 2;
+		tx_enable_mask = RK3588_TXCLK_DLY_ENA_GMAC_MASK << 2;
+		intf_sel = RK3588_GMAC_PHY_INTF_SEL_RGMII << 6;
+		intf_sel_mask = RK3588_GMAC_PHY_INTF_SEL_MASK << 6;
+		clk_mode = RK3588_GMAC_CLK_RGMII_MODE << 5;
+		clk_mode_mask = RK3588_GMAC_CLK_RGMII_MODE_MASK << 5;
+	} else {
+		offset_con = &grf->soc_con8;
+		rx_enable_mask = RK3588_RXCLK_DLY_ENA_GMAC_MASK;
+		tx_enable = RK3588_TXCLK_DLY_ENA_GMAC_ENABLE;
+		tx_enable_mask = RK3588_TXCLK_DLY_ENA_GMAC_MASK;
+		intf_sel = RK3588_GMAC_PHY_INTF_SEL_RGMII;
+		intf_sel_mask = RK3588_GMAC_PHY_INTF_SEL_MASK;
+		clk_mode = RK3588_GMAC_CLK_RGMII_MODE;
+		clk_mode_mask = RK3588_GMAC_CLK_RGMII_MODE_MASK;
+	}
+
+	rk_clrsetreg(offset_con,
+		     RK3588_CLK_TX_DL_CFG_GMAC_MASK |
+		     RK3588_CLK_RX_DL_CFG_GMAC_MASK,
+		     pdata->tx_delay << RK3588_CLK_TX_DL_CFG_GMAC_SHIFT |
+		     rx_delay);
+
+	rk_clrsetreg(&grf->soc_con7, tx_enable_mask | rx_enable_mask,
+		     tx_enable | rx_enable);
+
+	rk_clrsetreg(&php_grf->gmac_con0, intf_sel_mask, intf_sel);
+	rk_clrsetreg(&php_grf->clk_con1, clk_mode_mask, clk_mode);
+}
+
+static void rv1106_gmac_integrated_phy_powerup(struct gmac_rockchip_platdata *pdata)
+{
+	struct rv1106_grf *grf;
+	enum {
+		RV1106_VOGRF_GMAC_CLK_RMII_MODE_MASK = BIT(0),
+		RV1106_VOGRF_GMAC_CLK_RMII_MODE = BIT(0),
+	};
+
+	enum {
+		RV1106_MACPHY_ENABLE_MASK = BIT(1),
+		RV1106_MACPHY_DISENABLE = BIT(1),
+		RV1106_MACPHY_ENABLE = 0,
+		RV1106_MACPHY_XMII_SEL_MASK = GENMASK(6, 5),
+		RV1106_MACPHY_XMII_SEL = BIT(6),
+		RV1106_MACPHY_24M_CLK_SEL_MASK = GENMASK(9, 7),
+		RV1106_MACPHY_24M_CLK_SEL_24M = (BIT(8) | BIT(9)),
+		RV1106_MACPHY_PHY_ID_MASK = GENMASK(14, 10),
+		RV1106_MACPHY_PHY_ID = BIT(11),
+	};
+
+	enum {
+		RV1106_MACPHY_BGS_MASK = GENMASK(3, 0),
+		RV1106_MACPHY_BGS = BIT(2),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	reset_assert(&pdata->phy_reset);
+	udelay(20);
+
+	rk_clrsetreg(&grf->gmac_clk_con,
+		     RV1106_VOGRF_GMAC_CLK_RMII_MODE_MASK,
+		     RV1106_VOGRF_GMAC_CLK_RMII_MODE);
+
+	rk_clrsetreg(&grf->macphy_con0,
+		     RV1106_MACPHY_ENABLE_MASK |
+		     RV1106_MACPHY_XMII_SEL_MASK |
+		     RV1106_MACPHY_24M_CLK_SEL_MASK |
+		     RV1106_MACPHY_PHY_ID_MASK,
+		     RV1106_MACPHY_ENABLE |
+		     RV1106_MACPHY_XMII_SEL |
+		     RV1106_MACPHY_24M_CLK_SEL_24M |
+		     RV1106_MACPHY_PHY_ID);
+
+	rk_clrsetreg(&grf->macphy_con1,
+		     RV1106_MACPHY_BGS_MASK,
+		     RV1106_MACPHY_BGS);
+
+	reset_deassert(&pdata->phy_reset);
+
+	udelay(30 * 1000);
+}
+
+static void rv1126_set_to_rmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rv1126_grf *grf;
+
+	enum {
+		RV1126_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RV1126_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RV1126_GMAC_PHY_INTF_SEL_RMII = BIT(6),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	rk_clrsetreg(&grf->mac_con0,
+		     RV1126_GMAC_PHY_INTF_SEL_MASK,
+		     RV1126_GMAC_PHY_INTF_SEL_RMII);
+}
+
+static void rv1126_set_to_rgmii(struct gmac_rockchip_platdata *pdata)
+{
+	struct rv1126_grf *grf;
+
+	enum {
+		RV1126_GMAC_PHY_INTF_SEL_SHIFT = 4,
+		RV1126_GMAC_PHY_INTF_SEL_MASK  = GENMASK(6, 4),
+		RV1126_GMAC_PHY_INTF_SEL_RGMII = BIT(4),
+
+		RV1126_RXCLK_M1_DLY_ENA_GMAC_MASK = BIT(3),
+		RV1126_RXCLK_M1_DLY_ENA_GMAC_DISABLE = 0,
+		RV1126_RXCLK_M1_DLY_ENA_GMAC_ENABLE = BIT(3),
+
+		RV1126_TXCLK_M1_DLY_ENA_GMAC_MASK = BIT(2),
+		RV1126_TXCLK_M1_DLY_ENA_GMAC_DISABLE = 0,
+		RV1126_TXCLK_M1_DLY_ENA_GMAC_ENABLE = BIT(2),
+
+		RV1126_RXCLK_M0_DLY_ENA_GMAC_MASK = BIT(1),
+		RV1126_RXCLK_M0_DLY_ENA_GMAC_DISABLE = 0,
+		RV1126_RXCLK_M0_DLY_ENA_GMAC_ENABLE = BIT(1),
+
+		RV1126_TXCLK_M0_DLY_ENA_GMAC_MASK = BIT(0),
+		RV1126_TXCLK_M0_DLY_ENA_GMAC_DISABLE = 0,
+		RV1126_TXCLK_M0_DLY_ENA_GMAC_ENABLE = BIT(0),
+	};
+	enum {
+		RV1126_M0_CLK_RX_DL_CFG_GMAC_SHIFT = 0x8,
+		RV1126_M0_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(14, 8),
+
+		RV1126_M0_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RV1126_M0_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(6, 0),
+	};
+	enum {
+		RV1126_M1_CLK_RX_DL_CFG_GMAC_SHIFT = 0x8,
+		RV1126_M1_CLK_RX_DL_CFG_GMAC_MASK = GENMASK(14, 8),
+
+		RV1126_M1_CLK_TX_DL_CFG_GMAC_SHIFT = 0x0,
+		RV1126_M1_CLK_TX_DL_CFG_GMAC_MASK = GENMASK(6, 0),
+	};
+
+	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	rk_clrsetreg(&grf->mac_con0,
+		     RV1126_TXCLK_M0_DLY_ENA_GMAC_MASK |
+		     RV1126_RXCLK_M0_DLY_ENA_GMAC_MASK |
+		     RV1126_TXCLK_M1_DLY_ENA_GMAC_MASK |
+		     RV1126_RXCLK_M1_DLY_ENA_GMAC_MASK |
+		     RV1126_GMAC_PHY_INTF_SEL_MASK,
+		     RV1126_TXCLK_M0_DLY_ENA_GMAC_ENABLE |
+		     RV1126_RXCLK_M0_DLY_ENA_GMAC_ENABLE |
+		     RV1126_TXCLK_M1_DLY_ENA_GMAC_ENABLE |
+		     RV1126_RXCLK_M1_DLY_ENA_GMAC_ENABLE |
+		     RV1126_GMAC_PHY_INTF_SEL_RGMII);
+
+	rk_clrsetreg(&grf->mac_con1,
+		     RV1126_M0_CLK_RX_DL_CFG_GMAC_MASK |
+		     RV1126_M0_CLK_TX_DL_CFG_GMAC_MASK,
+		     pdata->rx_delay << RV1126_M0_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RV1126_M0_CLK_TX_DL_CFG_GMAC_SHIFT);
+
+	rk_clrsetreg(&grf->mac_con2,
+		     RV1126_M1_CLK_RX_DL_CFG_GMAC_MASK |
+		     RV1126_M1_CLK_TX_DL_CFG_GMAC_MASK,
+		     pdata->rx_delay << RV1126_M1_CLK_RX_DL_CFG_GMAC_SHIFT |
+		     pdata->tx_delay << RV1126_M1_CLK_TX_DL_CFG_GMAC_SHIFT);
+}
+#endif
+
+#ifdef CONFIG_DWC_ETH_QOS
+static void rk3588_set_clock_selection(struct gmac_rockchip_platdata *pdata)
+{
+	struct rk3588_php_grf *php_grf;
+	unsigned int val, mask;
+
+	enum {
+		RK3588_GMAC_CLK_SELET_SHIFT = 0x4,
+		RK3588_GMAC_CLK_SELET_MASK = BIT(4),
+		RK3588_GMAC_CLK_SELET_CRU = BIT(4),
+		RK3588_GMAC_CLK_SELET_IO = 0,
+	};
+
+	php_grf = syscon_get_first_range(ROCKCHIP_SYSCON_PHP_GRF);
+	val = pdata->clock_input ? RK3588_GMAC_CLK_SELET_IO :
+				   RK3588_GMAC_CLK_SELET_CRU;
+	mask = RK3588_GMAC_CLK_SELET_MASK;
+
+	if (pdata->bus_id == 1) {
+		val <<= 5;
+		mask <<= 5;
+	}
+
+	rk_clrsetreg(&php_grf->clk_con1, mask, val);
+}
+#endif
+
+static int gmac_rockchip_probe(struct udevice *dev)
+{
+	struct gmac_rockchip_platdata *pdata = dev_get_platdata(dev);
+	struct rk_gmac_ops *ops =
+		(struct rk_gmac_ops *)dev_get_driver_data(dev);
+#ifdef CONFIG_DWC_ETH_QOS
+	struct eqos_config *config;
+#else
+	struct dw_eth_pdata *dw_pdata;
+#endif
+	struct eth_pdata *eth_pdata;
+	struct clk clk;
+	ulong rate;
+	int ret;
+
+#ifdef CONFIG_DWC_ETH_QOS
+	eth_pdata = &pdata->eth_pdata;
+	config = (struct eqos_config *)&ops->config;
+	memcpy(config, &eqos_rockchip_config, sizeof(struct eqos_config));
+	eth_pdata->phy_interface = config->ops->eqos_get_interface(dev);
+#else
+	dw_pdata = &pdata->dw_eth_pdata;
+	eth_pdata = &dw_pdata->eth_pdata;
+#endif
+	pdata->bus_id = dev->seq;
+
+	/* Process 'assigned-{clocks/clock-parents/clock-rates}' properties */
+	ret = clk_set_defaults(dev);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+
+	ret = clk_get_by_index(dev, 0, &clk);
+	if (ret)
+		return ret;
+
+	pdata->phy_interface = eth_pdata->phy_interface;
+
+	if (ops->set_clock_selection)
+		ops->set_clock_selection(pdata);
+
+	if (pdata->integrated_phy && ops->integrated_phy_powerup)
+		ops->integrated_phy_powerup(pdata);
+
+	switch (eth_pdata->phy_interface) {
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+		/*
+		 * If the gmac clock is from internal pll, need to set and
+		 * check the return value for gmac clock at RGMII mode. If
+		 * the gmac clock is from external source, the clock rate
+		 * is not set, because of it is bypassed.
+		 */
+		if (!pdata->clock_input) {
+			rate = clk_set_rate(&clk, 125000000);
+			if (rate != 125000000)
+				return -EINVAL;
+		}
+
+		if (eth_pdata->phy_interface == PHY_INTERFACE_MODE_RGMII_RXID)
+			pdata->rx_delay = -1;
+
+		/* Set to RGMII mode */
+		if (ops->set_to_rgmii)
+			ops->set_to_rgmii(pdata);
+		else
+			return -EPERM;
+
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		/* The commet is the same as RGMII mode */
+		if (!pdata->clock_input) {
+			rate = clk_set_rate(&clk, 50000000);
+			if (rate != 50000000)
+				return -EINVAL;
+		}
+
+		/* Set to RMII mode */
+		if (ops->set_to_rmii)
+			ops->set_to_rmii(pdata);
+
+		break;
+	default:
+		debug("NO interface defined!\n");
+		return -ENXIO;
+	}
+
+#ifdef CONFIG_DWC_ETH_QOS
+	return eqos_probe(dev);
+#else
+	return designware_eth_probe(dev);
+#endif
+}
+
+static int gmac_rockchip_eth_write_hwaddr(struct udevice *dev)
+{
+#if defined(CONFIG_DWC_ETH_QOS)
+	return eqos_write_hwaddr(dev);
+#else
+	return designware_eth_write_hwaddr(dev);
+#endif
+}
+
+static int gmac_rockchip_eth_free_pkt(struct udevice *dev, uchar *packet,
+				      int length)
+{
+#ifdef CONFIG_DWC_ETH_QOS
+	return eqos_free_pkt(dev, packet, length);
+#else
+	return designware_eth_free_pkt(dev, packet, length);
+#endif
+}
+
+static int gmac_rockchip_eth_send(struct udevice *dev, void *packet,
+				  int length)
+{
+#ifdef CONFIG_DWC_ETH_QOS
+	return eqos_send(dev, packet, length);
+#else
+	return designware_eth_send(dev, packet, length);
+#endif
+}
+
+static int gmac_rockchip_eth_recv(struct udevice *dev, int flags,
+				  uchar **packetp)
+{
+#ifdef CONFIG_DWC_ETH_QOS
+	return eqos_recv(dev, flags, packetp);
+#else
+	return designware_eth_recv(dev, flags, packetp);
+#endif
+}
+
+static int gmac_rockchip_eth_start(struct udevice *dev)
+{
+	struct rockchip_eth_dev *priv = dev_get_priv(dev);
+	struct rk_gmac_ops *ops =
+		(struct rk_gmac_ops *)dev_get_driver_data(dev);
+	struct gmac_rockchip_platdata *pdata = dev_get_platdata(dev);
+#ifndef CONFIG_DWC_ETH_QOS
+	struct dw_eth_pdata *dw_pdata;
+	struct eth_pdata *eth_pdata;
+#endif
+	int ret;
+
+#ifdef CONFIG_DWC_ETH_QOS
+	ret = eqos_init(dev);
+#else
+	dw_pdata = &pdata->dw_eth_pdata;
+	eth_pdata = &dw_pdata->eth_pdata;
+	ret = designware_eth_init((struct dw_eth_dev *)priv,
+				  eth_pdata->enetaddr);
+#endif
+	if (ret)
 		return ret;
-	ret = designware_eth_enable(priv);
+	ret = ops->fix_mac_speed(pdata, priv);
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_DWC_ETH_QOS
+	eqos_enable(dev);
+#else
+	ret = designware_eth_enable((struct dw_eth_dev *)priv);
+	if (ret)
+		return ret;
+#endif
+
 	return 0;
 }
 
+static void gmac_rockchip_eth_stop(struct udevice *dev)
+{
+#ifdef CONFIG_DWC_ETH_QOS
+	eqos_stop(dev);
+#else
+	designware_eth_stop(dev);
+#endif
+}
+
 const struct eth_ops gmac_rockchip_eth_ops = {
 	.start			= gmac_rockchip_eth_start,
-	.send			= designware_eth_send,
-	.recv			= designware_eth_recv,
-	.free_pkt		= designware_eth_free_pkt,
-	.stop			= designware_eth_stop,
-	.write_hwaddr		= designware_eth_write_hwaddr,
+	.send			= gmac_rockchip_eth_send,
+	.recv			= gmac_rockchip_eth_recv,
+	.free_pkt		= gmac_rockchip_eth_free_pkt,
+	.stop			= gmac_rockchip_eth_stop,
+	.write_hwaddr		= gmac_rockchip_eth_write_hwaddr,
+};
+
+#ifndef CONFIG_DWC_ETH_QOS
+const struct rk_gmac_ops px30_gmac_ops = {
+	.fix_mac_speed = px30_gmac_fix_mac_speed,
+	.set_to_rmii = px30_gmac_set_to_rmii,
+};
+
+const struct rk_gmac_ops rk1808_gmac_ops = {
+	.fix_mac_speed = rk1808_gmac_fix_mac_speed,
+	.set_to_rgmii = rk1808_gmac_set_to_rgmii,
+};
+
+const struct rk_gmac_ops rk3228_gmac_ops = {
+	.fix_mac_speed = rk3228_gmac_fix_mac_speed,
+	.set_to_rmii = rk3228_gmac_set_to_rmii,
+	.set_to_rgmii = rk3228_gmac_set_to_rgmii,
+	.integrated_phy_powerup = rk3228_gmac_integrated_phy_powerup,
 };
 
 const struct rk_gmac_ops rk3288_gmac_ops = {
@@ -279,6 +1627,18 @@ const struct rk_gmac_ops rk3288_gmac_ops = {
 	.set_to_rgmii = rk3288_gmac_set_to_rgmii,
 };
 
+const struct rk_gmac_ops rk3308_gmac_ops = {
+	.fix_mac_speed = rk3308_gmac_fix_mac_speed,
+	.set_to_rmii = rk3308_gmac_set_to_rmii,
+};
+
+const struct rk_gmac_ops rk3328_gmac_ops = {
+	.fix_mac_speed = rk3328_gmac_fix_mac_speed,
+	.set_to_rmii = rk3328_gmac_set_to_rmii,
+	.set_to_rgmii = rk3328_gmac_set_to_rgmii,
+	.integrated_phy_powerup = rk3328_gmac_integrated_phy_powerup,
+};
+
 const struct rk_gmac_ops rk3368_gmac_ops = {
 	.fix_mac_speed = rk3368_gmac_fix_mac_speed,
 	.set_to_rgmii = rk3368_gmac_set_to_rgmii,
@@ -289,13 +1649,103 @@ const struct rk_gmac_ops rk3399_gmac_ops = {
 	.set_to_rgmii = rk3399_gmac_set_to_rgmii,
 };
 
+const struct rk_gmac_ops rv1108_gmac_ops = {
+	.fix_mac_speed = rv1108_set_rmii_speed,
+	.set_to_rmii = rv1108_gmac_set_to_rmii,
+};
+#else
+const struct rk_gmac_ops rk3568_gmac_ops = {
+	.fix_mac_speed = rv1126_set_rgmii_speed,
+	.set_to_rgmii = rk3568_set_to_rgmii,
+	.set_to_rmii = rk3568_set_to_rmii,
+};
+
+const struct rk_gmac_ops rk3588_gmac_ops = {
+	.fix_mac_speed = rk3588_set_rgmii_speed,
+	.set_to_rgmii = rk3588_set_to_rgmii,
+	.set_to_rmii = rk3588_set_to_rmii,
+	.set_clock_selection = rk3588_set_clock_selection,
+};
+
+const struct rk_gmac_ops rv1106_gmac_ops = {
+	.fix_mac_speed = rv1106_set_rmii_speed,
+	.integrated_phy_powerup = rv1106_gmac_integrated_phy_powerup,
+};
+
+const struct rk_gmac_ops rv1126_gmac_ops = {
+	.fix_mac_speed = rv1126_set_rgmii_speed,
+	.set_to_rgmii = rv1126_set_to_rgmii,
+	.set_to_rmii = rv1126_set_to_rmii,
+};
+#endif
+
 static const struct udevice_id rockchip_gmac_ids[] = {
+#ifndef CONFIG_DWC_ETH_QOS
+#ifdef CONFIG_ROCKCHIP_PX30
+	{ .compatible = "rockchip,px30-gmac",
+	  .data = (ulong)&px30_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK1808
+	{ .compatible = "rockchip,rk1808-gmac",
+	  .data = (ulong)&rk1808_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3228
+	{ .compatible = "rockchip,rk3228-gmac",
+	  .data = (ulong)&rk3228_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3288
 	{ .compatible = "rockchip,rk3288-gmac",
 	  .data = (ulong)&rk3288_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3308
+	{ .compatible = "rockchip,rk3308-mac",
+	  .data = (ulong)&rk3308_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3328
+	{ .compatible = "rockchip,rk3328-gmac",
+	  .data = (ulong)&rk3328_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3368
 	{ .compatible = "rockchip,rk3368-gmac",
 	  .data = (ulong)&rk3368_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3399
 	{ .compatible = "rockchip,rk3399-gmac",
 	  .data = (ulong)&rk3399_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RV1108
+	{ .compatible = "rockchip,rv1108-gmac",
+	  .data = (ulong)&rv1108_gmac_ops },
+#endif
+#else
+#ifdef CONFIG_ROCKCHIP_RK3568
+	{ .compatible = "rockchip,rk3568-gmac",
+	  .data = (ulong)&rk3568_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RK3588
+	{ .compatible = "rockchip,rk3588-gmac",
+	  .data = (ulong)&rk3588_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RV1106
+	{ .compatible = "rockchip,rv1106-gmac",
+	  .data = (ulong)&rv1106_gmac_ops },
+#endif
+
+#ifdef CONFIG_ROCKCHIP_RV1126
+	{ .compatible = "rockchip,rv1126-gmac",
+	  .data = (ulong)&rv1126_gmac_ops },
+#endif
+#endif
 	{ }
 };
 
@@ -306,7 +1756,7 @@ U_BOOT_DRIVER(eth_gmac_rockchip) = {
 	.ofdata_to_platdata = gmac_rockchip_ofdata_to_platdata,
 	.probe	= gmac_rockchip_probe,
 	.ops	= &gmac_rockchip_eth_ops,
-	.priv_auto_alloc_size = sizeof(struct dw_eth_dev),
+	.priv_auto_alloc_size = sizeof(struct rockchip_eth_dev),
 	.platdata_auto_alloc_size = sizeof(struct gmac_rockchip_platdata),
 	.flags = DM_FLAG_ALLOC_PRIV_DMA,
 };
diff --git a/drivers/net/keystone_net.c b/drivers/net/keystone_net.c
index 72ef42cca8..21ccab47ae 100644
--- a/drivers/net/keystone_net.c
+++ b/drivers/net/keystone_net.c
@@ -757,7 +757,7 @@ static int ks2_eth_start(struct udevice *dev)
 	qm_init();
 
 	if (ksnav_init(priv->netcp_pktdma, &priv->net_rx_buffs)) {
-		error("ksnav_init failed\n");
+		pr_err("ksnav_init failed\n");
 		goto err_knav_init;
 	}
 
@@ -773,7 +773,7 @@ static int ks2_eth_start(struct udevice *dev)
 
 		phy_startup(priv->phydev);
 		if (priv->phydev->link == 0) {
-			error("phy startup failed\n");
+			pr_err("phy startup failed\n");
 			goto err_phy_start;
 		}
 	}
@@ -923,7 +923,7 @@ static int ks2_eth_probe(struct udevice *dev)
 		 */
 		mdio_bus = mdio_alloc();
 		if (!mdio_bus) {
-			error("MDIO alloc failed\n");
+			pr_err("MDIO alloc failed\n");
 			return -ENOMEM;
 		}
 		priv->mdio_bus = mdio_bus;
@@ -935,7 +935,7 @@ static int ks2_eth_probe(struct udevice *dev)
 
 		ret = mdio_register(mdio_bus);
 		if (ret) {
-			error("MDIO bus register failed\n");
+			pr_err("MDIO bus register failed\n");
 			return ret;
 		}
 	} else {
@@ -1011,7 +1011,7 @@ static int ks2_eth_bind_slaves(struct udevice *dev, int gbe, int *gbe_0)
 					slave_name, offset_to_ofnode(slave),
 					&sl_dev);
 			if (ret) {
-				error("ks2_net - not able to bind slave interfaces\n");
+				pr_err("ks2_net - not able to bind slave interfaces\n");
 				return ret;
 			}
 		}
@@ -1031,7 +1031,7 @@ static int ks2_eth_bind_slaves(struct udevice *dev, int gbe, int *gbe_0)
 		ret = device_bind_driver_to_node(dev, "eth_ks2_sl", slave_name,
 					offset_to_ofnode(slave), &sl_dev);
 		if (ret) {
-			error("ks2_net - not able to bind slave interfaces\n");
+			pr_err("ks2_net - not able to bind slave interfaces\n");
 			return ret;
 		}
 	}
@@ -1074,7 +1074,7 @@ static int ks2_eth_parse_slave_interface(int netcp, int slave,
 
 		mdio = fdt_parent_offset(fdt, phy);
 		if (mdio < 0) {
-			error("mdio dt not found\n");
+			pr_err("mdio dt not found\n");
 			return -ENODEV;
 		}
 		priv->mdio_base = (void *)fdtdec_get_addr(fdt, mdio, "reg");
diff --git a/drivers/net/mpc8xx_fec.c b/drivers/net/mpc8xx_fec.c
index 71fe984a5d..1dd41df18b 100644
--- a/drivers/net/mpc8xx_fec.c
+++ b/drivers/net/mpc8xx_fec.c
@@ -7,10 +7,10 @@
 
 #include <common.h>
 #include <command.h>
-#include <commproc.h>
 #include <malloc.h>
 #include <net.h>
 #include <netdev.h>
+#include <asm/cpm_8xx.h>
 #include <asm/io.h>
 
 #include <phy.h>
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 4d02d8bb19..c395a817ca 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -111,6 +111,9 @@ config PHY_NATSEMI
 config PHY_REALTEK
 	bool "Realtek Ethernet PHYs support"
 
+config PHY_RK630
+	bool "Rockchip RK630 Ethernet PHYs support"
+
 config RTL8211X_PHY_FORCE_MASTER
 	bool "Ethernet PHY RTL8211x: force 1000BASE-T master mode"
 	depends on PHY_REALTEK
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 54f32f606b..686e546bc8 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_PHY_MICREL_KSZ8XXX) += micrel_ksz8xxx.o
 obj-$(CONFIG_PHY_MICREL_KSZ90X1) += micrel_ksz90x1.o
 obj-$(CONFIG_PHY_NATSEMI) += natsemi.o
 obj-$(CONFIG_PHY_REALTEK) += realtek.o
+obj-$(CONFIG_PHY_RK630) += rk630phy.o
 obj-$(CONFIG_PHY_SMSC) += smsc.o
 obj-$(CONFIG_PHY_TERANETICS) += teranetics.o
 obj-$(CONFIG_PHY_TI) += ti.o
diff --git a/drivers/net/phy/cortina.c b/drivers/net/phy/cortina.c
index e0e9ed9767..637d89a1e1 100644
--- a/drivers/net/phy/cortina.c
+++ b/drivers/net/phy/cortina.c
@@ -177,8 +177,6 @@ void cs4340_upload_firmware(struct phy_device *phydev)
 		mmc_init(mmc);
 		(void)mmc->block_dev.block_read(&mmc->block_dev, blk, cnt,
 						addr);
-		/* flush cache after read */
-		flush_cache((ulong)addr, cnt * 512);
 	}
 #endif
 
diff --git a/drivers/net/phy/micrel_ksz90x1.c b/drivers/net/phy/micrel_ksz90x1.c
index 0bb99e6bc6..b350a61aa6 100644
--- a/drivers/net/phy/micrel_ksz90x1.c
+++ b/drivers/net/phy/micrel_ksz90x1.c
@@ -9,11 +9,11 @@
  * (C) Copyright 2017 Adaptrum, Inc.
  * Written by Alexandru Gagniuc <alex.g@adaptrum.com> for Adaptrum, Inc.
  */
+
 #include <config.h>
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
-#include <fdtdec.h>
 #include <micrel.h>
 #include <phy.h>
 
@@ -120,8 +120,7 @@ static int ksz90x1_of_config_group(struct phy_device *phydev,
 		return -EOPNOTSUPP;
 
 	for (i = 0; i < ofcfg->grpsz; i++) {
-		val[i] = fdtdec_get_uint(gd->fdt_blob, dev_of_offset(dev),
-					 ofcfg->grp[i].name, -1);
+		val[i] = dev_read_u32_default(dev, ofcfg->grp[i].name, ~0);
 		offset = ofcfg->grp[i].off;
 		if (val[i] == -1) {
 			/* Default register value for KSZ9021 */
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 5be51d73ce..315d295f45 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -500,6 +500,9 @@ int phy_init(void)
 #ifdef CONFIG_PHY_REALTEK
 	phy_realtek_init();
 #endif
+#ifdef CONFIG_PHY_RK630
+	phy_rk630_init();
+#endif
 #ifdef CONFIG_PHY_SMSC
 	phy_smsc_init();
 #endif
@@ -542,6 +545,10 @@ int phy_register(struct phy_driver *drv)
 		drv->readext += gd->reloc_off;
 	if (drv->writeext)
 		drv->writeext += gd->reloc_off;
+	if (drv->read_mmd)
+		drv->read_mmd += gd->reloc_off;
+	if (drv->write_mmd)
+		drv->write_mmd += gd->reloc_off;
 #endif
 	return 0;
 }
@@ -611,7 +618,7 @@ static struct phy_driver *get_phy_driver(struct phy_device *phydev,
 }
 
 static struct phy_device *phy_device_create(struct mii_dev *bus, int addr,
-					    u32 phy_id,
+					    u32 phy_id, bool is_c45,
 					    phy_interface_t interface)
 {
 	struct phy_device *dev;
@@ -631,10 +638,15 @@ static struct phy_device *phy_device_create(struct mii_dev *bus, int addr,
 	dev->link = 0;
 	dev->interface = interface;
 
+#ifdef CONFIG_DM_ETH
+	dev->node = ofnode_null();
+#endif
+
 	dev->autoneg = AUTONEG_ENABLE;
 
 	dev->addr = addr;
 	dev->phy_id = phy_id;
+	dev->is_c45 = is_c45;
 	dev->bus = bus;
 
 	dev->drv = get_phy_driver(dev, interface);
@@ -683,12 +695,17 @@ static struct phy_device *create_phy_by_mask(struct mii_dev *bus,
 		unsigned phy_mask, int devad, phy_interface_t interface)
 {
 	u32 phy_id = 0xffffffff;
+	bool is_c45;
+
 	while (phy_mask) {
 		int addr = ffs(phy_mask) - 1;
 		int r = get_phy_id(bus, addr, devad, &phy_id);
 		/* If the PHY ID is mostly f's, we didn't find anything */
-		if (r == 0 && (phy_id & 0x1fffffff) != 0x1fffffff)
-			return phy_device_create(bus, addr, phy_id, interface);
+		if (r == 0 && (phy_id & 0x1fffffff) != 0x1fffffff) {
+			is_c45 = (devad == MDIO_DEVAD_NONE) ? false : true;
+			return phy_device_create(bus, addr, phy_id, is_c45,
+						 interface);
+		}
 		phy_mask &= ~(1 << addr);
 	}
 	return NULL;
@@ -866,9 +883,9 @@ struct phy_device *phy_connect(struct mii_dev *bus, int addr,
 	sn = fdt_first_subnode(gd->fdt_blob, dev_of_offset(dev));
 	while (sn > 0) {
 		name = fdt_get_name(gd->fdt_blob, sn, NULL);
-		if (name != NULL && strcmp(name, "fixed-link") == 0) {
-			phydev = phy_device_create(bus,
-						   sn, PHY_FIXED_ID, interface);
+		if (name && strcmp(name, "fixed-link") == 0) {
+			phydev = phy_device_create(bus, sn, PHY_FIXED_ID, false,
+						   interface);
 			break;
 		}
 		sn = fdt_next_subnode(gd->fdt_blob, sn);
diff --git a/drivers/net/pic32_eth.c b/drivers/net/pic32_eth.c
index 0b89911f04..7129372790 100644
--- a/drivers/net/pic32_eth.c
+++ b/drivers/net/pic32_eth.c
@@ -64,8 +64,8 @@ static int pic32_mii_init(struct pic32eth_dev *priv)
 	writel(ETHCON_ON | ETHCON_TXRTS | ETHCON_RXEN, &ectl_p->con1.clr);
 
 	/* wait till busy */
-	wait_for_bit(__func__, &ectl_p->stat.raw, ETHSTAT_BUSY, false,
-		     CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(&ectl_p->stat.raw, ETHSTAT_BUSY, false,
+			  CONFIG_SYS_HZ, false);
 
 	/* turn controller ON to access PHY over MII */
 	writel(ETHCON_ON, &ectl_p->con1.set);
@@ -239,8 +239,8 @@ static void pic32_ctrl_reset(struct pic32eth_dev *priv)
 	writel(ETHCON_ON | ETHCON_TXRTS | ETHCON_RXEN, &ectl_p->con1.clr);
 
 	/* wait till busy */
-	wait_for_bit(__func__, &ectl_p->stat.raw, ETHSTAT_BUSY, false,
-		     CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(&ectl_p->stat.raw, ETHSTAT_BUSY, false,
+			  CONFIG_SYS_HZ, false);
 	/* decrement received buffcnt to zero. */
 	while (readl(&ectl_p->stat.raw) & ETHSTAT_BUFCNT)
 		writel(ETHCON_BUFCDEC, &ectl_p->con1.set);
@@ -375,8 +375,8 @@ static void pic32_eth_stop(struct udevice *dev)
 	mdelay(10);
 
 	/* wait until everything is down */
-	wait_for_bit(__func__, &ectl_p->stat.raw, ETHSTAT_BUSY, false,
-		     2 * CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(&ectl_p->stat.raw, ETHSTAT_BUSY, false,
+			  2 * CONFIG_SYS_HZ, false);
 
 	/* clear any existing interrupt event */
 	writel(0xffffffff, &ectl_p->irq.clr);
diff --git a/drivers/net/pic32_mdio.c b/drivers/net/pic32_mdio.c
index 578fc96905..6ae5c40fa3 100644
--- a/drivers/net/pic32_mdio.c
+++ b/drivers/net/pic32_mdio.c
@@ -22,8 +22,8 @@ static int pic32_mdio_write(struct mii_dev *bus,
 	struct pic32_mii_regs *mii_regs = bus->priv;
 
 	/* Wait for the previous operation to finish */
-	wait_for_bit(__func__, &mii_regs->mind.raw, MIIMIND_BUSY,
-		     false, CONFIG_SYS_HZ, true);
+	wait_for_bit_le32(&mii_regs->mind.raw, MIIMIND_BUSY,
+			  false, CONFIG_SYS_HZ, true);
 
 	/* Put phyaddr and regaddr into MIIMADD */
 	v = (addr << MIIMADD_PHYADDR_SHIFT) | (reg & MIIMADD_REGADDR);
@@ -36,8 +36,8 @@ static int pic32_mdio_write(struct mii_dev *bus,
 	udelay(12);
 
 	/* Wait for write to complete */
-	wait_for_bit(__func__, &mii_regs->mind.raw, MIIMIND_BUSY,
-		     false, CONFIG_SYS_HZ, true);
+	wait_for_bit_le32(&mii_regs->mind.raw, MIIMIND_BUSY,
+			  false, CONFIG_SYS_HZ, true);
 
 	return 0;
 }
@@ -48,8 +48,8 @@ static int pic32_mdio_read(struct mii_dev *bus, int addr, int devaddr, int reg)
 	struct pic32_mii_regs *mii_regs = bus->priv;
 
 	/* Wait for the previous operation to finish */
-	wait_for_bit(__func__, &mii_regs->mind.raw, MIIMIND_BUSY,
-		     false, CONFIG_SYS_HZ, true);
+	wait_for_bit_le32(&mii_regs->mind.raw, MIIMIND_BUSY,
+			  false, CONFIG_SYS_HZ, true);
 
 	/* Put phyaddr and regaddr into MIIMADD */
 	v = (addr << MIIMADD_PHYADDR_SHIFT) | (reg & MIIMADD_REGADDR);
@@ -62,9 +62,9 @@ static int pic32_mdio_read(struct mii_dev *bus, int addr, int devaddr, int reg)
 	udelay(12);
 
 	/* Wait for read to complete */
-	wait_for_bit(__func__, &mii_regs->mind.raw,
-		     MIIMIND_NOTVALID | MIIMIND_BUSY,
-		     false, CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(&mii_regs->mind.raw,
+			  MIIMIND_NOTVALID | MIIMIND_BUSY,
+			  false, CONFIG_SYS_HZ, false);
 
 	/* Clear the command register */
 	writel(0, &mii_regs->mcmd.raw);
@@ -82,22 +82,22 @@ static int pic32_mdio_reset(struct mii_dev *bus)
 	writel(MIIMCFG_RSTMGMT, &mii_regs->mcfg.raw);
 
 	/* Wait for the operation to finish */
-	wait_for_bit(__func__, &mii_regs->mind.raw, MIIMIND_BUSY,
+	wait_for_bit_le32(&mii_regs->mind.raw, MIIMIND_BUSY,
 		     false, CONFIG_SYS_HZ, true);
 
 	/* Clear reset bit */
 	writel(0, &mii_regs->mcfg);
 
 	/* Wait for the operation to finish */
-	wait_for_bit(__func__, &mii_regs->mind.raw, MIIMIND_BUSY,
-		     false, CONFIG_SYS_HZ, true);
+	wait_for_bit_le32(&mii_regs->mind.raw, MIIMIND_BUSY,
+			  false, CONFIG_SYS_HZ, true);
 
 	/* Set the MII Management Clock (MDC) - no faster than 2.5 MHz */
 	writel(MIIMCFG_CLKSEL_DIV40, &mii_regs->mcfg.raw);
 
 	/* Wait for the operation to finish */
-	wait_for_bit(__func__, &mii_regs->mind.raw, MIIMIND_BUSY,
-		     false, CONFIG_SYS_HZ, true);
+	wait_for_bit_le32(&mii_regs->mind.raw, MIIMIND_BUSY,
+			  false, CONFIG_SYS_HZ, true);
 	return 0;
 }
 
diff --git a/drivers/net/ravb.c b/drivers/net/ravb.c
index 8db127ba06..0a6323ede8 100644
--- a/drivers/net/ravb.c
+++ b/drivers/net/ravb.c
@@ -220,8 +220,8 @@ static int ravb_reset(struct udevice *dev)
 	writel(CCC_OPC_CONFIG, eth->iobase + RAVB_REG_CCC);
 
 	/* Check the operating mode is changed to the config mode. */
-	return wait_for_bit(dev->name, (void *)eth->iobase + RAVB_REG_CSR,
-			    CSR_OPS_CONFIG, true, 100, true);
+	return wait_for_bit_le32(eth->iobase + RAVB_REG_CSR,
+				 CSR_OPS_CONFIG, true, 100, true);
 }
 
 static void ravb_base_desc_init(struct ravb_priv *eth)
diff --git a/drivers/net/xilinx_axi_emac.c b/drivers/net/xilinx_axi_emac.c
index 25c66c6098..315ad006d0 100644
--- a/drivers/net/xilinx_axi_emac.c
+++ b/drivers/net/xilinx_axi_emac.c
@@ -359,13 +359,19 @@ static int axi_ethernet_init(struct axidma_priv *priv)
 	 * will be valid until this bit is valid.
 	 * The bit is always a 1 for all other PHY interfaces.
 	 */
-	while (timeout && (!(in_be32(&regs->is) & XAE_INT_MGTRDY_MASK))) {
-		timeout--;
-		udelay(1);
-	}
-	if (!timeout) {
-		printf("%s: Timeout\n", __func__);
-		return 1;
+	if (!priv->eth_hasnobuf) {
+		err = wait_for_bit_le32(&regs->is, XAE_INT_MGTRDY_MASK,
+					true, 200, false);
+		if (err) {
+			printf("%s: Timeout\n", __func__);
+			return 1;
+		}
+
+		/*
+		 * Stop the device and reset HW
+		 * Disable interrupts
+		 */
+		writel(0, &regs->ie);
 	}
 
 	/* Stop the device and reset HW */
diff --git a/drivers/net/zynq_gem.c b/drivers/net/zynq_gem.c
index f6bbcdc48e..a58a48de92 100644
--- a/drivers/net/zynq_gem.c
+++ b/drivers/net/zynq_gem.c
@@ -191,8 +191,8 @@ static u32 phy_setup_op(struct zynq_gem_priv *priv, u32 phy_addr, u32 regnum,
 	struct zynq_gem_regs *regs = priv->iobase;
 	int err;
 
-	err = wait_for_bit(__func__, &regs->nwsr, ZYNQ_GEM_NWSR_MDIOIDLE_MASK,
-			    true, 20000, false);
+	err = wait_for_bit_le32(&regs->nwsr, ZYNQ_GEM_NWSR_MDIOIDLE_MASK,
+				true, 20000, false);
 	if (err)
 		return err;
 
@@ -204,8 +204,8 @@ static u32 phy_setup_op(struct zynq_gem_priv *priv, u32 phy_addr, u32 regnum,
 	/* Write mgtcr and wait for completion */
 	writel(mgtcr, &regs->phymntnc);
 
-	err = wait_for_bit(__func__, &regs->nwsr, ZYNQ_GEM_NWSR_MDIOIDLE_MASK,
-			    true, 20000, false);
+	err = wait_for_bit_le32(&regs->nwsr, ZYNQ_GEM_NWSR_MDIOIDLE_MASK,
+				true, 20000, false);
 	if (err)
 		return err;
 
@@ -508,8 +508,8 @@ static int zynq_gem_send(struct udevice *dev, void *ptr, int len)
 	if (priv->tx_bd->status & ZYNQ_GEM_TXBUF_EXHAUSTED)
 		printf("TX buffers exhausted in mid frame\n");
 
-	return wait_for_bit(__func__, &regs->txsr, ZYNQ_GEM_TSR_DONE,
-			    true, 20000, true);
+	return wait_for_bit_le32(&regs->txsr, ZYNQ_GEM_TSR_DONE,
+				 true, 20000, true);
 }
 
 /* Do not check frame_recd flag in rx_status register 0x20 - just poll BD */
diff --git a/drivers/nvme/nvme-uclass.c b/drivers/nvme/nvme-uclass.c
index 56a6171876..fdb5bc63d1 100644
--- a/drivers/nvme/nvme-uclass.c
+++ b/drivers/nvme/nvme-uclass.c
@@ -6,38 +6,9 @@
  */
 
 #include <common.h>
-#include <errno.h>
 #include <dm.h>
-#include <dm/device.h>
-#include "nvme.h"
-
-static int nvme_uclass_post_probe(struct udevice *udev)
-{
-	char name[20];
-	struct udevice *ns_udev;
-	int i, ret;
-	struct nvme_dev *ndev = dev_get_priv(udev);
-
-	/* Create a blk device for each namespace */
-	for (i = 0; i < ndev->nn; i++) {
-		/*
-		 * Encode the namespace id to the device name so that
-		 * we can extract it when doing the probe.
-		 */
-		sprintf(name, "blk#%d", i);
-
-		/* The real blksz and size will be set by nvme_blk_probe() */
-		ret = blk_create_devicef(udev, "nvme-blk", name, IF_TYPE_NVME,
-					 -1, 512, 0, &ns_udev);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
 
 UCLASS_DRIVER(nvme) = {
 	.name	= "nvme",
 	.id	= UCLASS_NVME,
-	.post_probe = nvme_uclass_post_probe,
 };
diff --git a/drivers/nvme/nvme.c b/drivers/nvme/nvme.c
index 1c3519ba74..55600c87eb 100644
--- a/drivers/nvme/nvme.c
+++ b/drivers/nvme/nvme.c
@@ -17,6 +17,8 @@
 #define NVME_AQ_DEPTH		2
 #define NVME_SQ_SIZE(depth)	(depth * sizeof(struct nvme_command))
 #define NVME_CQ_SIZE(depth)	(depth * sizeof(struct nvme_completion))
+#define NVME_CQ_ALLOCATION	ALIGN(NVME_CQ_SIZE(NVME_Q_DEPTH), \
+				      ARCH_DMA_MINALIGN)
 #define ADMIN_TIMEOUT		60
 #define IO_TIMEOUT		30
 #define MAX_PRP_POOL		512
@@ -74,6 +76,9 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	u64 *prp_pool;
 	int length = total_len;
 	int i, nprps;
+	u32 prps_per_page = page_size >> 3;
+	u32 num_pages;
+
 	length -= (page_size - offset);
 
 	if (length <= 0) {
@@ -90,24 +95,30 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	}
 
 	nprps = DIV_ROUND_UP(length, page_size);
+	num_pages = DIV_ROUND_UP(nprps + 1, prps_per_page);
 
 	if (nprps > dev->prp_entry_num) {
 		free(dev->prp_pool);
-		dev->prp_pool = malloc(nprps << 3);
+		/*
+		 * Always increase in increments of pages.  It doesn't waste
+		 * much memory and reduces the number of allocations.
+		 */
+		dev->prp_pool = memalign(page_size, num_pages * page_size);
 		if (!dev->prp_pool) {
 			printf("Error: malloc prp_pool fail\n");
 			return -ENOMEM;
 		}
-		dev->prp_entry_num = nprps;
+		dev->prp_entry_num = prps_per_page * num_pages;
 	}
 
 	prp_pool = dev->prp_pool;
 	i = 0;
 	while (nprps) {
-		if (i == ((page_size >> 3) - 1)) {
-			*(prp_pool + i) = cpu_to_le64((ulong)prp_pool +
+		if (i == prps_per_page) {
+			*(prp_pool + i) = *(prp_pool + i - 1);
+			*(prp_pool + i - 1) = cpu_to_le64((ulong)prp_pool +
 					page_size);
-			i = 0;
+			i = 1;
 			prp_pool += page_size;
 		}
 		*(prp_pool + i++) = cpu_to_le64(dma_addr);
@@ -116,6 +127,9 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	}
 	*prp2 = (ulong)dev->prp_pool;
 
+	flush_dcache_range((ulong)dev->prp_pool, (ulong)dev->prp_pool +
+			   dev->prp_entry_num * sizeof(u64));
+
 	return 0;
 }
 
@@ -128,12 +142,18 @@ static __le16 nvme_get_cmd_id(void)
 
 static u16 nvme_read_completion_status(struct nvme_queue *nvmeq, u16 index)
 {
-	u64 start = (ulong)&nvmeq->cqes[index];
-	u64 stop = start + sizeof(struct nvme_completion);
+	/*
+	 * Single CQ entries are always smaller than a cache line, so we
+	 * can't invalidate them individually. However CQ entries are
+	 * read only by the CPU, so it's safe to always invalidate all of them,
+	 * as the cache line should never become dirty.
+	 */
+	ulong start = (ulong)&nvmeq->cqes[0];
+	ulong stop = start + NVME_CQ_ALLOCATION;
 
 	invalidate_dcache_range(start, stop);
 
-	return le16_to_cpu(readw(&(nvmeq->cqes[index].status)));
+	return readw(&(nvmeq->cqes[index].status));
 }
 
 /**
@@ -197,7 +217,7 @@ static int nvme_submit_sync_cmd(struct nvme_queue *nvmeq,
 	}
 
 	if (result)
-		*result = le32_to_cpu(readl(&(nvmeq->cqes[head].result)));
+		*result = readl(&(nvmeq->cqes[head].result));
 
 	if (++head == nvmeq->q_depth) {
 		head = 0;
@@ -225,7 +245,7 @@ static struct nvme_queue *nvme_alloc_queue(struct nvme_dev *dev,
 		return NULL;
 	memset(nvmeq, 0, sizeof(*nvmeq));
 
-	nvmeq->cqes = (void *)memalign(4096, NVME_CQ_SIZE(depth));
+	nvmeq->cqes = (void *)memalign(4096, NVME_CQ_ALLOCATION);
 	if (!nvmeq->cqes)
 		goto free_nvmeq;
 	memset((void *)nvmeq->cqes, 0, NVME_CQ_SIZE(depth));
@@ -280,7 +300,7 @@ static int nvme_enable_ctrl(struct nvme_dev *dev)
 {
 	dev->ctrl_config &= ~NVME_CC_SHN_MASK;
 	dev->ctrl_config |= NVME_CC_ENABLE;
-	writel(cpu_to_le32(dev->ctrl_config), &dev->bar->cc);
+	writel(dev->ctrl_config, &dev->bar->cc);
 
 	return nvme_wait_ready(dev, true);
 }
@@ -289,7 +309,7 @@ static int nvme_disable_ctrl(struct nvme_dev *dev)
 {
 	dev->ctrl_config &= ~NVME_CC_SHN_MASK;
 	dev->ctrl_config &= ~NVME_CC_ENABLE;
-	writel(cpu_to_le32(dev->ctrl_config), &dev->bar->cc);
+	writel(dev->ctrl_config, &dev->bar->cc);
 
 	return nvme_wait_ready(dev, false);
 }
@@ -323,7 +343,7 @@ static void nvme_init_queue(struct nvme_queue *nvmeq, u16 qid)
 	nvmeq->q_db = &dev->dbs[qid * 2 * dev->db_stride];
 	memset((void *)nvmeq->cqes, 0, NVME_CQ_SIZE(nvmeq->q_depth));
 	flush_dcache_range((ulong)nvmeq->cqes,
-			   (ulong)nvmeq->cqes + NVME_CQ_SIZE(nvmeq->q_depth));
+			   (ulong)nvmeq->cqes + NVME_CQ_ALLOCATION);
 	dev->online_queues++;
 }
 
@@ -363,7 +383,6 @@ static int nvme_configure_admin_queue(struct nvme_dev *dev)
 
 	aqa = nvmeq->q_depth - 1;
 	aqa |= aqa << 16;
-	aqa |= aqa << 16;
 
 	dev->page_size = 1 << page_shift;
 
@@ -450,6 +469,9 @@ int nvme_identify(struct nvme_dev *dev, unsigned nsid,
 
 	c.identify.cns = cpu_to_le32(cns);
 
+	invalidate_dcache_range(dma_addr,
+				dma_addr + sizeof(struct nvme_id_ctrl));
+
 	ret = nvme_submit_admin_cmd(dev, &c, NULL);
 	if (!ret)
 		invalidate_dcache_range(dma_addr,
@@ -462,6 +484,7 @@ int nvme_get_features(struct nvme_dev *dev, unsigned fid, unsigned nsid,
 		      dma_addr_t dma_addr, u32 *result)
 {
 	struct nvme_command c;
+	int ret;
 
 	memset(&c, 0, sizeof(c));
 	c.features.opcode = nvme_admin_get_features;
@@ -469,12 +492,20 @@ int nvme_get_features(struct nvme_dev *dev, unsigned fid, unsigned nsid,
 	c.features.prp1 = cpu_to_le64(dma_addr);
 	c.features.fid = cpu_to_le32(fid);
 
+	ret = nvme_submit_admin_cmd(dev, &c, result);
+
 	/*
-	 * TODO: add cache invalidate operation when the size of
-	 * the DMA buffer is known
+	 * TODO: Add some cache invalidation when a DMA buffer is involved
+	 * in the request, here and before the command gets submitted. The
+	 * buffer size varies by feature, also some features use a different
+	 * field in the command packet to hold the buffer address.
+	 * Section 5.21.1 (Set Features command) in the NVMe specification
+	 * details the buffer requirements for each feature.
+	 *
+	 * At the moment there is no user of this function.
 	 */
 
-	return nvme_submit_admin_cmd(dev, &c, result);
+	return ret;
 }
 
 int nvme_set_features(struct nvme_dev *dev, unsigned fid, unsigned dword11,
@@ -489,8 +520,14 @@ int nvme_set_features(struct nvme_dev *dev, unsigned fid, unsigned dword11,
 	c.features.dword11 = cpu_to_le32(dword11);
 
 	/*
-	 * TODO: add cache flush operation when the size of
-	 * the DMA buffer is known
+	 * TODO: Add a cache clean (aka flush) operation when a DMA buffer is
+	 * involved in the request. The buffer size varies by feature, also
+	 * some features use a different field in the command packet to hold
+	 * the buffer address. Section 5.21.1 (Set Features command) in the
+	 * NVMe specification details the buffer requirements for each
+	 * feature.
+	 * At the moment the only user of this function is not using
+	 * any DMA buffer at all.
 	 */
 
 	return nvme_submit_admin_cmd(dev, &c, result);
@@ -573,14 +610,19 @@ static int nvme_setup_io_queues(struct nvme_dev *dev)
 
 static int nvme_get_info_from_identify(struct nvme_dev *dev)
 {
-	ALLOC_CACHE_ALIGN_BUFFER(char, buf, sizeof(struct nvme_id_ctrl));
-	struct nvme_id_ctrl *ctrl = (struct nvme_id_ctrl *)buf;
+	struct nvme_id_ctrl *ctrl;
 	int ret;
 	int shift = NVME_CAP_MPSMIN(dev->cap) + 12;
 
-	ret = nvme_identify(dev, 0, 1, (dma_addr_t)ctrl);
-	if (ret)
+	ctrl = memalign(dev->page_size, sizeof(struct nvme_id_ctrl));
+	if (!ctrl)
+		return -ENOMEM;
+
+	ret = nvme_identify(dev, 0, 1, (dma_addr_t)(long)ctrl);
+	if (ret) {
+		free(ctrl);
 		return -EIO;
+	}
 
 	dev->nn = le32_to_cpu(ctrl->nn);
 	dev->vwc = ctrl->vwc;
@@ -611,6 +653,19 @@ static int nvme_get_info_from_identify(struct nvme_dev *dev)
 		dev->max_transfer_shift = 20;
 	}
 
+	free(ctrl);
+	return 0;
+}
+
+int nvme_get_namespace_id(struct udevice *udev, u32 *ns_id, u8 *eui64)
+{
+	struct nvme_ns *ns = dev_get_priv(udev);
+
+	if (ns_id)
+		*ns_id = ns->ns_id;
+	if (eui64)
+		memcpy(eui64, ns->eui64, sizeof(ns->eui64));
+
 	return 0;
 }
 
@@ -639,25 +694,28 @@ static int nvme_blk_probe(struct udevice *udev)
 	struct blk_desc *desc = dev_get_uclass_platdata(udev);
 	struct nvme_ns *ns = dev_get_priv(udev);
 	u8 flbas;
-	ALLOC_CACHE_ALIGN_BUFFER(char, buf, sizeof(struct nvme_id_ns));
-	struct nvme_id_ns *id = (struct nvme_id_ns *)buf;
 	struct pci_child_platdata *pplat;
+	struct nvme_id_ns *id;
+
+	id = memalign(ndev->page_size, sizeof(struct nvme_id_ns));
+	if (!id)
+		return -ENOMEM;
 
-	memset(ns, 0, sizeof(*ns));
 	ns->dev = ndev;
 	/* extract the namespace id from the block device name */
-	ns->ns_id = trailing_strtol(udev->name) + 1;
-	if (nvme_identify(ndev, ns->ns_id, 0, (dma_addr_t)id))
+	ns->ns_id = trailing_strtol(udev->name);
+	if (nvme_identify(ndev, ns->ns_id, 0, (dma_addr_t)(long)id)) {
+		free(id);
 		return -EIO;
+	}
 
+	memcpy(&ns->eui64, &id->eui64, sizeof(id->eui64));
 	flbas = id->flbas & NVME_NS_FLBAS_LBA_MASK;
 	ns->flbas = flbas;
 	ns->lba_shift = id->lbaf[flbas].ds;
-	ns->mode_select_num_blocks = le64_to_cpu(id->nsze);
-	ns->mode_select_block_len = 1 << ns->lba_shift;
 	list_add(&ns->list, &ndev->namespaces);
 
-	desc->lba = ns->mode_select_num_blocks;
+	desc->lba = le64_to_cpu(id->nsze);
 	desc->log2blksz = ns->lba_shift;
 	desc->blksz = 1 << ns->lba_shift;
 	desc->bdev = udev;
@@ -667,6 +725,7 @@ static int nvme_blk_probe(struct udevice *udev)
 	memcpy(desc->revision, ndev->firmware_rev, sizeof(ndev->firmware_rev));
 	part_init(desc);
 
+	free(id);
 	return 0;
 }
 
@@ -686,9 +745,8 @@ static ulong nvme_blk_rw(struct udevice *udev, lbaint_t blknr,
 	u16 lbas = 1 << (dev->max_transfer_shift - ns->lba_shift);
 	u64 total_lbas = blkcnt;
 
-	if (!read)
-		flush_dcache_range((unsigned long)buffer,
-				   (unsigned long)buffer + total_len);
+	flush_dcache_range((unsigned long)buffer,
+			   (unsigned long)buffer + total_len);
 
 	c.rw.opcode = read ? nvme_cmd_read : nvme_cmd_write;
 	c.rw.flags = 0;
@@ -700,6 +758,10 @@ static ulong nvme_blk_rw(struct udevice *udev, lbaint_t blknr,
 	c.rw.appmask = 0;
 	c.rw.metadata = 0;
 
+	/* Enable FUA for data integrity if vwc is enabled */
+	if (dev->vwc)
+		c.rw.control |= NVME_RW_FUA;
+
 	while (total_lbas) {
 		if (total_lbas < lbas) {
 			lbas = (u16)total_lbas;
@@ -770,6 +832,7 @@ static int nvme_probe(struct udevice *udev)
 {
 	int ret;
 	struct nvme_dev *ndev = dev_get_priv(udev);
+	struct nvme_id_ns *id;
 
 	ndev->instance = trailing_strtol(udev->name);
 
@@ -790,14 +853,6 @@ static int nvme_probe(struct udevice *udev)
 	}
 	memset(ndev->queues, 0, NVME_Q_NUM * sizeof(struct nvme_queue *));
 
-	ndev->prp_pool = malloc(MAX_PRP_POOL);
-	if (!ndev->prp_pool) {
-		ret = -ENOMEM;
-		printf("Error: %s: Out of memory!\n", udev->name);
-		goto free_nvme;
-	}
-	ndev->prp_entry_num = MAX_PRP_POOL >> 3;
-
 	ndev->cap = nvme_readq(&ndev->bar->cap);
 	ndev->q_depth = min_t(int, NVME_CAP_MQES(ndev->cap) + 1, NVME_Q_DEPTH);
 	ndev->db_stride = 1 << NVME_CAP_STRIDE(ndev->cap);
@@ -807,14 +862,61 @@ static int nvme_probe(struct udevice *udev)
 	if (ret)
 		goto free_queue;
 
+	/* Allocate after the page size is known */
+	ndev->prp_pool = memalign(ndev->page_size, MAX_PRP_POOL);
+	if (!ndev->prp_pool) {
+		ret = -ENOMEM;
+		printf("Error: %s: Out of memory!\n", udev->name);
+		goto free_nvme;
+	}
+	ndev->prp_entry_num = MAX_PRP_POOL >> 3;
+
 	ret = nvme_setup_io_queues(ndev);
 	if (ret)
 		goto free_queue;
 
 	nvme_get_info_from_identify(ndev);
 
+	/* Create a blk device for each namespace */
+
+	id = memalign(ndev->page_size, sizeof(struct nvme_id_ns));
+	if (!id) {
+		ret = -ENOMEM;
+		goto free_queue;
+	}
+
+	for (int i = 1; i <= ndev->nn; i++) {
+		struct udevice *ns_udev;
+		char name[20];
+
+		memset(id, 0, sizeof(*id));
+		if (nvme_identify(ndev, i, 0, (dma_addr_t)(long)id)) {
+			ret = -EIO;
+			goto free_id;
+		}
+
+		/* skip inactive namespace */
+		if (!id->nsze)
+			continue;
+
+		/*
+		 * Encode the namespace id to the device name so that
+		 * we can extract it when doing the probe.
+		 */
+		sprintf(name, "blk#%d", i);
+
+		/* The real blksz and size will be set by nvme_blk_probe() */
+		ret = blk_create_devicef(udev, "nvme-blk", name, IF_TYPE_NVME,
+					 -1, 512, 0, &ns_udev);
+		if (ret)
+			goto free_id;
+	}
+
+	free(id);
 	return 0;
 
+free_id:
+	free(id);
 free_queue:
 	free((void *)ndev->queues);
 free_nvme:
diff --git a/drivers/nvme/nvme.h b/drivers/nvme/nvme.h
index 67bf6e187f..0358f86acb 100644
--- a/drivers/nvme/nvme.h
+++ b/drivers/nvme/nvme.h
@@ -638,11 +638,10 @@ struct nvme_ns {
 	struct list_head list;
 	struct nvme_dev *dev;
 	unsigned ns_id;
+	u8 eui64[8];
 	int devnum;
 	int lba_shift;
 	u8 flbas;
-	u64 mode_select_num_blocks;
-	u32 mode_select_block_len;
 };
 
 #endif /* __DRIVER_NVME_H__ */
diff --git a/drivers/nvme/nvme_show.c b/drivers/nvme/nvme_show.c
index 52351388e2..1aa3838c2a 100644
--- a/drivers/nvme/nvme_show.c
+++ b/drivers/nvme/nvme_show.c
@@ -112,14 +112,14 @@ int nvme_print_info(struct udevice *udev)
 	ALLOC_CACHE_ALIGN_BUFFER(char, buf_ctrl, sizeof(struct nvme_id_ctrl));
 	struct nvme_id_ctrl *ctrl = (struct nvme_id_ctrl *)buf_ctrl;
 
-	if (nvme_identify(dev, 0, 1, (dma_addr_t)ctrl))
+	if (nvme_identify(dev, 0, 1, (dma_addr_t)(long)ctrl))
 		return -EIO;
 
 	print_optional_admin_cmd(le16_to_cpu(ctrl->oacs), ns->devnum);
 	print_optional_nvm_cmd(le16_to_cpu(ctrl->oncs), ns->devnum);
 	print_format_nvme_attributes(ctrl->fna, ns->devnum);
 
-	if (nvme_identify(dev, ns->ns_id, 0, (dma_addr_t)id))
+	if (nvme_identify(dev, ns->ns_id, 0, (dma_addr_t)(long)id))
 		return -EIO;
 
 	print_formats(id, ns);
diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index e2a1c0a409..a076e48189 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -79,4 +79,12 @@ config PCIE_LAYERSCAPE
 	  PCIe controllers. The PCIe may works in RC or EP mode according to
 	  RCW[HOST_AGT_PEX] setting.
 
+config PCIE_DW_ROCKCHIP
+	bool "Rockchip DesignWare PCIe controller"
+	depends on DM_PCI
+	depends on ARCH_ROCKCHIP
+	select CONFIG_DM_REGULATOR_GPIO
+	help
+	  Enables support for the DW PCIe controller in the Rockchip SoC.
+
 endif
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index ad44e83996..6c9f4cedc2 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_SH7780_PCI) +=pci_sh7780.o
 obj-$(CONFIG_PCI_TEGRA) += pci_tegra.o
 obj-$(CONFIG_TSI108_PCI) += tsi108_pci.o
 obj-$(CONFIG_PCIE_DW_MVEBU) += pcie_dw_mvebu.o
+obj-$(CONFIG_PCIE_DW_ROCKCHIP) += pcie_dw_rockchip.o
 obj-$(CONFIG_PCIE_LAYERSCAPE) += pcie_layerscape.o
 obj-$(CONFIG_PCIE_LAYERSCAPE) += pcie_layerscape_fixup.o
 obj-$(CONFIG_PCI_XILINX) += pcie_xilinx.o
diff --git a/drivers/pci/fsl_pci_init.c b/drivers/pci/fsl_pci_init.c
index df76a94144..11104dcc69 100644
--- a/drivers/pci/fsl_pci_init.c
+++ b/drivers/pci/fsl_pci_init.c
@@ -886,7 +886,7 @@ int fsl_pcie_init_board(int busno)
 #endif
 
 #ifdef CONFIG_OF_BOARD_SETUP
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 
 void ft_fsl_pci_setup(void *blob, const char *pci_compat,
diff --git a/drivers/pci/pci-emul-uclass.c b/drivers/pci/pci-emul-uclass.c
index 0f8e3c9fcb..dcea192418 100644
--- a/drivers/pci/pci-emul-uclass.c
+++ b/drivers/pci/pci-emul-uclass.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <dm.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <pci.h>
 #include <dm/lists.h>
 
diff --git a/drivers/pci/pci_tegra.c b/drivers/pci/pci_tegra.c
index cb5cf8b043..c15d84b4c2 100644
--- a/drivers/pci/pci_tegra.c
+++ b/drivers/pci/pci_tegra.c
@@ -371,7 +371,7 @@ static int tegra_pcie_port_parse_dt(ofnode node, struct tegra_pcie_port *port)
 
 	addr = ofnode_get_property(node, "assigned-addresses", &len);
 	if (!addr) {
-		error("property \"assigned-addresses\" not found");
+		pr_err("property \"assigned-addresses\" not found");
 		return -FDT_ERR_NOTFOUND;
 	}
 
@@ -462,7 +462,7 @@ static int tegra_pcie_parse_port_info(ofnode node, uint *index, uint *lanes)
 
 	err = ofnode_read_u32_default(node, "nvidia,num-lanes", -1);
 	if (err < 0) {
-		error("failed to parse \"nvidia,num-lanes\" property");
+		pr_err("failed to parse \"nvidia,num-lanes\" property");
 		return err;
 	}
 
@@ -470,7 +470,7 @@ static int tegra_pcie_parse_port_info(ofnode node, uint *index, uint *lanes)
 
 	err = ofnode_read_pci_addr(node, 0, "reg", &addr);
 	if (err < 0) {
-		error("failed to parse \"reg\" property");
+		pr_err("failed to parse \"reg\" property");
 		return err;
 	}
 
@@ -493,25 +493,25 @@ static int tegra_pcie_parse_dt(struct udevice *dev, enum tegra_pci_id id,
 
 	err = dev_read_resource(dev, 0, &pcie->pads);
 	if (err < 0) {
-		error("resource \"pads\" not found");
+		pr_err("resource \"pads\" not found");
 		return err;
 	}
 
 	err = dev_read_resource(dev, 1, &pcie->afi);
 	if (err < 0) {
-		error("resource \"afi\" not found");
+		pr_err("resource \"afi\" not found");
 		return err;
 	}
 
 	err = dev_read_resource(dev, 2, &pcie->cs);
 	if (err < 0) {
-		error("resource \"cs\" not found");
+		pr_err("resource \"cs\" not found");
 		return err;
 	}
 
 	err = tegra_pcie_board_init();
 	if (err < 0) {
-		error("tegra_pcie_board_init() failed: err=%d", err);
+		pr_err("tegra_pcie_board_init() failed: err=%d", err);
 		return err;
 	}
 
@@ -520,7 +520,7 @@ static int tegra_pcie_parse_dt(struct udevice *dev, enum tegra_pci_id id,
 	if (pcie->phy) {
 		err = tegra_xusb_phy_prepare(pcie->phy);
 		if (err < 0) {
-			error("failed to prepare PHY: %d", err);
+			pr_err("failed to prepare PHY: %d", err);
 			return err;
 		}
 	}
@@ -532,7 +532,7 @@ static int tegra_pcie_parse_dt(struct udevice *dev, enum tegra_pci_id id,
 
 		err = tegra_pcie_parse_port_info(subnode, &index, &num_lanes);
 		if (err < 0) {
-			error("failed to obtain root port info");
+			pr_err("failed to obtain root port info");
 			continue;
 		}
 
@@ -562,7 +562,7 @@ static int tegra_pcie_parse_dt(struct udevice *dev, enum tegra_pci_id id,
 	err = tegra_pcie_get_xbar_config(dev_ofnode(dev), lanes, id,
 					 &pcie->xbar);
 	if (err < 0) {
-		error("invalid lane configuration");
+		pr_err("invalid lane configuration");
 		return err;
 	}
 
@@ -576,31 +576,31 @@ static int tegra_pcie_power_on(struct tegra_pcie *pcie)
 
 	ret = power_domain_on(&pcie->pwrdom);
 	if (ret) {
-		error("power_domain_on() failed: %d\n", ret);
+		pr_err("power_domain_on() failed: %d\n", ret);
 		return ret;
 	}
 
 	ret = clk_enable(&pcie->clk_afi);
 	if (ret) {
-		error("clk_enable(afi) failed: %d\n", ret);
+		pr_err("clk_enable(afi) failed: %d\n", ret);
 		return ret;
 	}
 
 	ret = clk_enable(&pcie->clk_pex);
 	if (ret) {
-		error("clk_enable(pex) failed: %d\n", ret);
+		pr_err("clk_enable(pex) failed: %d\n", ret);
 		return ret;
 	}
 
 	ret = reset_deassert(&pcie->reset_afi);
 	if (ret) {
-		error("reset_deassert(afi) failed: %d\n", ret);
+		pr_err("reset_deassert(afi) failed: %d\n", ret);
 		return ret;
 	}
 
 	ret = reset_deassert(&pcie->reset_pex);
 	if (ret) {
-		error("reset_deassert(pex) failed: %d\n", ret);
+		pr_err("reset_deassert(pex) failed: %d\n", ret);
 		return ret;
 	}
 
@@ -620,14 +620,14 @@ static int tegra_pcie_power_on(struct tegra_pcie *pcie)
 
 	err = tegra_powergate_power_off(TEGRA_POWERGATE_PCIE);
 	if (err < 0) {
-		error("failed to power off PCIe partition: %d", err);
+		pr_err("failed to power off PCIe partition: %d", err);
 		return err;
 	}
 
 	err = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_PCIE,
 						PERIPH_ID_PCIE);
 	if (err < 0) {
-		error("failed to power up PCIe partition: %d", err);
+		pr_err("failed to power up PCIe partition: %d", err);
 		return err;
 	}
 
@@ -647,7 +647,7 @@ static int tegra_pcie_power_on(struct tegra_pcie *pcie)
 
 	err = tegra_plle_enable();
 	if (err < 0) {
-		error("failed to enable PLLE: %d\n", err);
+		pr_err("failed to enable PLLE: %d\n", err);
 		return err;
 	}
 
@@ -707,7 +707,7 @@ static int tegra_pcie_phy_enable(struct tegra_pcie *pcie)
 	/* wait for the PLL to lock */
 	err = tegra_pcie_pll_wait(pcie, 500);
 	if (err < 0) {
-		error("PLL failed to lock: %d", err);
+		pr_err("PLL failed to lock: %d", err);
 		return err;
 	}
 
@@ -771,7 +771,7 @@ static int tegra_pcie_enable_controller(struct tegra_pcie *pcie)
 		err = tegra_pcie_phy_enable(pcie);
 
 	if (err < 0) {
-		error("failed to power on PHY: %d\n", err);
+		pr_err("failed to power on PHY: %d\n", err);
 		return err;
 	}
 #endif
@@ -780,7 +780,7 @@ static int tegra_pcie_enable_controller(struct tegra_pcie *pcie)
 #ifdef CONFIG_TEGRA186
 	err = reset_deassert(&pcie->reset_pcie_x);
 	if (err) {
-		error("reset_deassert(pcie_x) failed: %d\n", err);
+		pr_err("reset_deassert(pcie_x) failed: %d\n", err);
 		return err;
 	}
 #else
@@ -1145,25 +1145,25 @@ static int pci_tegra_probe(struct udevice *dev)
 
 	err = tegra_pcie_power_on(pcie);
 	if (err < 0) {
-		error("failed to power on");
+		pr_err("failed to power on");
 		return err;
 	}
 
 	err = tegra_pcie_enable_controller(pcie);
 	if (err < 0) {
-		error("failed to enable controller");
+		pr_err("failed to enable controller");
 		return err;
 	}
 
 	err = tegra_pcie_setup_translations(dev);
 	if (err < 0) {
-		error("failed to decode ranges");
+		pr_err("failed to decode ranges");
 		return err;
 	}
 
 	err = tegra_pcie_enable(pcie);
 	if (err < 0) {
-		error("failed to enable PCIe");
+		pr_err("failed to enable PCIe");
 		return err;
 	}
 
diff --git a/drivers/pci/pcie_layerscape_fixup.c b/drivers/pci/pcie_layerscape_fixup.c
index 9e6c2f5dfc..b4a5ac6bc6 100644
--- a/drivers/pci/pcie_layerscape_fixup.c
+++ b/drivers/pci/pcie_layerscape_fixup.c
@@ -12,7 +12,7 @@
 #include <asm/io.h>
 #include <errno.h>
 #ifdef CONFIG_OF_BOARD_SETUP
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #ifdef CONFIG_ARM
 #include <asm/arch/clock.h>
diff --git a/drivers/pci/pcie_xilinx.c b/drivers/pci/pcie_xilinx.c
index 08e2e93445..6b8b96a734 100644
--- a/drivers/pci/pcie_xilinx.c
+++ b/drivers/pci/pcie_xilinx.c
@@ -189,7 +189,7 @@ static int pcie_xilinx_ofdata_to_platdata(struct udevice *dev)
 	err = fdt_get_resource(gd->fdt_blob, dev_of_offset(dev), "reg",
 			       0, &reg_res);
 	if (err < 0) {
-		error("\"reg\" resource not found\n");
+		pr_err("\"reg\" resource not found\n");
 		return err;
 	}
 
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index 98f2a1b047..092a8a3eb0 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -59,6 +59,70 @@ config SPL_NOP_PHY
 	  This is useful when a driver uses the PHY framework but no real PHY
 	  hardware exists.
 
+config PHY_ROCKCHIP_INNO_USB2
+	bool "Support Rockchip INNO USB2PHY"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Support for Rockchip USB 2.0 PHY with Innosilicon IP block.
+
+config PHY_ROCKCHIP_NANENG_COMBOPHY
+	bool "Support Rockchip NANENG combo PHY Driver"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Enable this to support the Rockchip NANENG combo PHY.
+
+config PHY_ROCKCHIP_NANENG_USB2
+	bool "Support Rockchip Naneng USB2PHY"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Support for Rockchip USB 2.0 PHY with Naneng IP block.
+
+config PHY_ROCKCHIP_INNO_USB3
+	bool "Support Rockchip INNO USB3PHY"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Support for Rockchip USB 3.0 PHY with Innosilicon IP block.
+
+config PHY_ROCKCHIP_NANENG_EDP
+	bool "Support Rockchip Naneng eDP Transmitter PHY"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Support for Rockchip eDP Transmitter PHY with Naneng IP block.
+
+config PHY_ROCKCHIP_SAMSUNG_HDPTX
+	bool "Rockchip Samsung HDMI/DP Combo PHY driver"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Support for Rockchip HDMI/DP Combo PHY with Samsung IP block.
+
+config PHY_ROCKCHIP_SNPS_PCIE3
+	bool "Rockchip Snps PCIe3 PHY Driver"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Support for Rockchip PCIe3 PHY with Synopsys IP block.
+
+config PHY_ROCKCHIP_USBDP
+	tristate "Rockchip USBDP COMBO PHY Driver"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Enable this to support the Rockchip USB3.0/DP
+	  combo PHY with Samsung IP block.
+
+config PHY_ROCKCHIP_TYPEC
+	bool "Support Rockchip TYPEC PHY Driver"
+	depends on ARCH_ROCKCHIP
+	select PHY
+	help
+	  Enable this to support the Rockchip USB Type-C PHY.
+
 config PIPE3_PHY
 	bool "Support omap's PIPE3 PHY"
 	depends on PHY && ARCH_OMAP2PLUS
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index ab56c46bb4..27c423e97b 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -7,5 +7,14 @@
 
 obj-$(CONFIG_$(SPL_)PHY) += phy-uclass.o
 obj-$(CONFIG_$(SPL_)NOP_PHY) += nop-phy.o
+obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB2) += phy-rockchip-inno-usb2.o
+obj-$(CONFIG_PHY_ROCKCHIP_NANENG_USB2) += phy-rockchip-naneng-usb2.o
+obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB3) += phy-rockchip-inno-usb3.o
+obj-$(CONFIG_PHY_ROCKCHIP_NANENG_EDP) += phy-rockchip-naneng-edp.o
+obj-$(CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX) += phy-rockchip-samsung-hdptx.o
+obj-$(CONFIG_PHY_ROCKCHIP_SNPS_PCIE3) += phy-rockchip-snps-pcie3.o
+obj-$(CONFIG_PHY_ROCKCHIP_TYPEC) += phy-rockchip-typec.o
+obj-$(CONFIG_PHY_ROCKCHIP_USBDP) += phy-rockchip-usbdp.o
 obj-$(CONFIG_PHY_SANDBOX) += sandbox-phy.o
 obj-$(CONFIG_$(SPL_)PIPE3_PHY) += ti-pipe3-phy.o
+obj-$(CONFIG_PHY_ROCKCHIP_NANENG_COMBOPHY) += phy-rockchip-naneng-combphy.o
diff --git a/drivers/phy/marvell/comphy_cp110.c b/drivers/phy/marvell/comphy_cp110.c
index 3ac405a9be..37187885fa 100644
--- a/drivers/phy/marvell/comphy_cp110.c
+++ b/drivers/phy/marvell/comphy_cp110.c
@@ -509,7 +509,7 @@ static int comphy_pcie_power_up(u32 lane, u32 pcie_width, bool clk_src,
 				debug("Read from reg = %p - value = 0x%x\n",
 				      hpipe_addr + HPIPE_LANE_STATUS1_REG,
 				      data);
-				error("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
+				pr_err("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
 				ret = 0;
 			}
 		}
@@ -633,7 +633,7 @@ static int comphy_usb3_power_up(u32 lane, void __iomem *hpipe_base,
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n",
 		      hpipe_addr + HPIPE_LANE_STATUS1_REG, data);
-		error("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
+		pr_err("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
 		ret = 0;
 	}
 
@@ -666,14 +666,14 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
 			gd->fdt_blob, sata_node, "marvell,armada-8k-ahci");
 
 	if (sata_node == 0) {
-		error("SATA node not found in FDT\n");
+		pr_err("SATA node not found in FDT\n");
 		return 0;
 	}
 
 	sata_base = (void __iomem *)fdtdec_get_addr_size_auto_noparent(
 		gd->fdt_blob, sata_node, "reg", 0, NULL, true);
 	if (sata_base == NULL) {
-		error("SATA address not found in FDT\n");
+		pr_err("SATA address not found in FDT\n");
 		return 0;
 	}
 
@@ -976,7 +976,7 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n",
 		      hpipe_addr + HPIPE_LANE_STATUS1_REG, data);
-		error("SD_EXTERNAL_STATUS0_PLL_TX is %d, SD_EXTERNAL_STATUS0_PLL_RX is %d\n",
+		pr_err("SD_EXTERNAL_STATUS0_PLL_TX is %d, SD_EXTERNAL_STATUS0_PLL_RX is %d\n",
 		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK),
 		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK));
 		ret = 0;
@@ -1099,7 +1099,7 @@ static int comphy_sgmii_power_up(u32 lane, u32 sgmii_speed,
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n",
 		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		error("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
+		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
 		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
 		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
 		ret = 0;
@@ -1117,7 +1117,7 @@ static int comphy_sgmii_power_up(u32 lane, u32 sgmii_speed,
 	data = polling_with_timeout(addr, data, mask, 100);
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n", sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		error("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
+		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
 		ret = 0;
 	}
 
@@ -1398,7 +1398,7 @@ static int comphy_sfi_power_up(u32 lane, void __iomem *hpipe_base,
 	data = polling_with_timeout(addr, data, mask, 15000);
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n", sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		error("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
+		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
 		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
 		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
 		ret = 0;
@@ -1418,7 +1418,7 @@ static int comphy_sfi_power_up(u32 lane, void __iomem *hpipe_base,
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n",
 		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		error("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
+		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
 		ret = 0;
 	}
 
@@ -1577,7 +1577,7 @@ static int comphy_rxauii_power_up(u32 lane, void __iomem *hpipe_base,
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n",
 		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		error("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
+		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
 		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
 		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
 		ret = 0;
@@ -1596,7 +1596,7 @@ static int comphy_rxauii_power_up(u32 lane, void __iomem *hpipe_base,
 	if (data != 0) {
 		debug("Read from reg = %p - value = 0x%x\n",
 		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		error("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
+		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
 		ret = 0;
 	}
 
@@ -1742,7 +1742,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
 	if (data != 0) {
-		error("Impedance calibration is not done\n");
+		pr_err("Impedance calibration is not done\n");
 		debug("Read from reg = %p - value = 0x%x\n", addr, data);
 		ret = 0;
 	}
@@ -1751,7 +1751,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
 	if (data != 0) {
-		error("PLL calibration is not done\n");
+		pr_err("PLL calibration is not done\n");
 		debug("Read from reg = %p - value = 0x%x\n", addr, data);
 		ret = 0;
 	}
@@ -1761,7 +1761,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
 	if (data != 0) {
-		error("PLL is not ready\n");
+		pr_err("PLL is not ready\n");
 		debug("Read from reg = %p - value = 0x%x\n", addr, data);
 		ret = 0;
 	}
@@ -1818,7 +1818,7 @@ static void comphy_utmi_phy_init(u32 utmi_phy_count,
 					  cp110_utmi_data[i].usb_cfg_addr,
 					  cp110_utmi_data[i].utmi_cfg_addr,
 					  cp110_utmi_data[i].utmi_phy_port)) {
-			error("Failed to initialize UTMI PHY %d\n", i);
+			pr_err("Failed to initialize UTMI PHY %d\n", i);
 			continue;
 		}
 		printf("UTMI PHY %d initialized to ", i);
@@ -1864,7 +1864,7 @@ void comphy_dedicated_phys_init(void)
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 0, NULL, true);
 		if (cp110_utmi_data[i].utmi_base_addr == NULL) {
-			error("UTMI PHY base address is invalid\n");
+			pr_err("UTMI PHY base address is invalid\n");
 			i++;
 			continue;
 		}
@@ -1874,7 +1874,7 @@ void comphy_dedicated_phys_init(void)
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 1, NULL, true);
 		if (cp110_utmi_data[i].usb_cfg_addr == NULL) {
-			error("UTMI PHY base address is invalid\n");
+			pr_err("UTMI PHY base address is invalid\n");
 			i++;
 			continue;
 		}
@@ -1884,7 +1884,7 @@ void comphy_dedicated_phys_init(void)
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 2, NULL, true);
 		if (cp110_utmi_data[i].utmi_cfg_addr == NULL) {
-			error("UTMI PHY base address is invalid\n");
+			pr_err("UTMI PHY base address is invalid\n");
 			i++;
 			continue;
 		}
@@ -1896,7 +1896,7 @@ void comphy_dedicated_phys_init(void)
 		cp110_utmi_data[i].utmi_phy_port = fdtdec_get_int(
 			gd->fdt_blob, node, "utmi-port", UTMI_PHY_INVALID);
 		if (cp110_utmi_data[i].utmi_phy_port == UTMI_PHY_INVALID) {
-			error("UTMI PHY port type is invalid\n");
+			pr_err("UTMI PHY port type is invalid\n");
 			i++;
 			continue;
 		}
@@ -2049,7 +2049,7 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 			 * PHY_TYPE_UNCONNECTED state.
 			 */
 			ptr_comphy_map->type = PHY_TYPE_UNCONNECTED;
-			error("PLL is not locked - Failed to initialize lane %d\n",
+			pr_err("PLL is not locked - Failed to initialize lane %d\n",
 			      lane);
 		}
 	}
diff --git a/drivers/phy/phy-uclass.c b/drivers/phy/phy-uclass.c
index 68e518fc79..b0d918f326 100644
--- a/drivers/phy/phy-uclass.c
+++ b/drivers/phy/phy-uclass.c
@@ -98,39 +98,101 @@ int generic_phy_get_by_name(struct udevice *dev, const char *phy_name,
 
 int generic_phy_init(struct phy *phy)
 {
-	struct phy_ops const *ops = phy_dev_ops(phy->dev);
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
 
 	return ops->init ? ops->init(phy) : 0;
 }
 
 int generic_phy_reset(struct phy *phy)
 {
-	struct phy_ops const *ops = phy_dev_ops(phy->dev);
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
 
 	return ops->reset ? ops->reset(phy) : 0;
 }
 
 int generic_phy_exit(struct phy *phy)
 {
-	struct phy_ops const *ops = phy_dev_ops(phy->dev);
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
 
 	return ops->exit ? ops->exit(phy) : 0;
 }
 
 int generic_phy_power_on(struct phy *phy)
 {
-	struct phy_ops const *ops = phy_dev_ops(phy->dev);
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
 
 	return ops->power_on ? ops->power_on(phy) : 0;
 }
 
 int generic_phy_power_off(struct phy *phy)
 {
-	struct phy_ops const *ops = phy_dev_ops(phy->dev);
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
 
 	return ops->power_off ? ops->power_off(phy) : 0;
 }
 
+int generic_phy_configure(struct phy *phy, union phy_configure_opts *opts)
+{
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
+
+	return ops->configure ? ops->configure(phy, opts) : 0;
+}
+
+int generic_phy_validate(struct phy *phy, enum phy_mode mode, int submode,
+			 union phy_configure_opts *opts)
+{
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
+
+	return ops->validate ? ops->validate(phy, mode, submode, opts) : 0;
+}
+
+int generic_phy_set_mode_ext(struct phy *phy, enum phy_mode mode, int submode)
+{
+	struct phy_ops const *ops;
+	int ret;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
+
+	if (!ops->set_mode)
+		return 0;
+
+	ret = ops->set_mode(phy, mode, submode);
+	if (!ret)
+		phy->attrs.mode = mode;
+
+	return ret;
+}
+
 UCLASS_DRIVER(phy) = {
 	.id		= UCLASS_PHY,
 	.name		= "phy",
diff --git a/drivers/phy/ti-pipe3-phy.c b/drivers/phy/ti-pipe3-phy.c
index 680e32f3ea..babf2ffe39 100644
--- a/drivers/phy/ti-pipe3-phy.c
+++ b/drivers/phy/ti-pipe3-phy.c
@@ -261,7 +261,7 @@ static int pipe3_exit(struct phy *phy)
 	} while (--timeout);
 
 	if (!(val & PLL_TICOPWDN) || !(val & PLL_LDOPWDN)) {
-		error("%s: Failed to power down DPLL: PLL_STATUS 0x%x\n",
+		pr_err("%s: Failed to power down DPLL: PLL_STATUS 0x%x\n",
 		      __func__, val);
 		return -EBUSY;
 	}
@@ -284,14 +284,14 @@ static void *get_reg(struct udevice *dev, const char *name)
 	err = uclass_get_device_by_phandle(UCLASS_SYSCON, dev,
 					   name, &syscon);
 	if (err) {
-		error("unable to find syscon device for %s (%d)\n",
+		pr_err("unable to find syscon device for %s (%d)\n",
 		      name, err);
 		return NULL;
 	}
 
 	regmap = syscon_get_regmap(syscon);
 	if (IS_ERR(regmap)) {
-		error("unable to find regmap for %s (%ld)\n",
+		pr_err("unable to find regmap for %s (%ld)\n",
 		      name, PTR_ERR(regmap));
 		return NULL;
 	}
@@ -299,7 +299,7 @@ static void *get_reg(struct udevice *dev, const char *name)
 	cell = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), name,
 			   &len);
 	if (len < 2*sizeof(fdt32_t)) {
-		error("offset not available for %s\n", name);
+		pr_err("offset not available for %s\n", name);
 		return NULL;
 	}
 
@@ -318,13 +318,13 @@ static int pipe3_phy_probe(struct udevice *dev)
 
 	addr = devfdt_get_addr_size_index(dev, 2, &sz);
 	if (addr == FDT_ADDR_T_NONE) {
-		error("missing pll ctrl address\n");
+		pr_err("missing pll ctrl address\n");
 		return -EINVAL;
 	}
 
 	pipe3->pll_ctrl_base = map_physmem(addr, sz, MAP_NOCACHE);
 	if (!pipe3->pll_ctrl_base) {
-		error("unable to remap pll ctrl\n");
+		pr_err("unable to remap pll ctrl\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index bcbe4a18c1..cf4436ff3a 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -158,85 +158,24 @@ config PINCTRL_QCA953X
 	  the GPIO definitions and pin control functions for each available
 	  multiplex function.
 
-config PINCTRL_ROCKCHIP_RK3036
-	bool "Rockchip rk3036 pin control driver"
-	depends on DM
-	help
-	  Support pin multiplexing control on Rockchip rk3036 SoCs.
-
-	  The driver is controlled by a device tree node which contains both
-	  the GPIO definitions and pin control functions for each available
-	  multiplex function.
-
-config PINCTRL_ROCKCHIP_RK3188
-	bool "Rockchip rk3188 pin control driver"
-	depends on DM
-	help
-	  Support pin multiplexing control on Rockchip rk3188 SoCs.
-
-	  The driver is controlled by a device tree node which contains both
-	  the GPIO definitions and pin control functions for each available
-	  multiplex function.
-
-config PINCTRL_ROCKCHIP_RK322X
-	bool "Rockchip rk322x pin control driver"
-	depends on DM
-	help
-	  Support pin multiplexing control on Rockchip rk322x SoCs.
-
-	  The driver is controlled by a device tree node which contains both
-	  the GPIO definitions and pin control functions for each available
-	  multiplex function.
-
-config PINCTRL_ROCKCHIP_RK3288
-	bool "Rockchip rk3288 pin control driver"
-	depends on DM
-	help
-	  Support pin multiplexing control on Rockchip rk3288 SoCs.
-
-	  The driver is controlled by a device tree node which contains both
-	  the GPIO definitions and pin control functions for each available
-	  multiplex function.
-
-config PINCTRL_ROCKCHIP_RK3328
-	bool "Rockchip rk3328 pin control driver"
-	depends on DM
-	help
-	  Support pin multiplexing control on Rockchip rk3328 SoCs.
-
-	  The driver is controlled by a device tree node which contains both
-	  the GPIO definitions and pin control functions for each available
-	  multiplex function.
-
-config PINCTRL_ROCKCHIP_RK3368
-	bool "Rockchip RK3368 pin control driver"
-	depends on DM
-	help
-	  Support pin multiplexing control on Rockchip rk3368 SoCs.
-
-	  The driver is controlled by a device tree node which contains both
-	  the GPIO definitions and pin control functions for each available
-	  multiplex function.
-
-config PINCTRL_ROCKCHIP_RK3399
-	bool "Rockchip rk3399 pin control driver"
-	depends on DM
+config PINCTRL_ROCKCHIP
+	bool "Rockchip pin control driver"
+	depends on PINCTRL_FULL && ARCH_ROCKCHIP
+	default y
 	help
-	  Support pin multiplexing control on Rockchip rk3399 SoCs.
+	  Support pin multiplexing control on Rockchip SoCs.
 
 	  The driver is controlled by a device tree node which contains both
 	  the GPIO definitions and pin control functions for each available
 	  multiplex function.
 
-config PINCTRL_ROCKCHIP_RV1108
-	bool "Rockchip rv1108 pin control driver"
-	depends on DM
+config SPL_PINCTRL_ROCKCHIP
+	bool "Support Rockchip pin controllers in SPL"
+	depends on SPL_PINCTRL_FULL && ARCH_ROCKCHIP
+	default y
 	help
-	  Support pin multiplexing control on Rockchip rv1108 SoC.
-
-	  The driver is controlled by a device tree node which contains
-	  both the GPIO definitions and pin control functions for each
-	  available multiplex function.
+	  This option is an SPL-variant of the PINCTRL_ROCKCHIP option.
+	  See the help of PINCTRL_ROCKCHIP for details.
 
 config PINCTRL_SANDBOX
 	bool "Sandbox pinctrl driver"
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 64da7c608b..65005aac3d 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -10,7 +10,8 @@ obj-$(CONFIG_PINCTRL_AT91PIO4)		+= pinctrl-at91-pio4.o
 obj-y					+= nxp/
 obj-$(CONFIG_ARCH_ASPEED) += aspeed/
 obj-$(CONFIG_ARCH_ATH79) += ath79/
-obj-$(CONFIG_ARCH_ROCKCHIP) += rockchip/
+obj-$(CONFIG_$(SPL_)PINCTRL_ROCKCHIP)	+= pinctrl-rockchip.o
+obj-$(CONFIG_$(SPL_)PINCTRL_ROCKCHIP)	+= rockchip/
 obj-$(CONFIG_PINCTRL_SANDBOX)	+= pinctrl-sandbox.o
 
 obj-$(CONFIG_PINCTRL_UNIPHIER)	+= uniphier/
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
index 27165b0007..2bf853eba1 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
@@ -578,7 +578,7 @@ int armada_37xx_pinctrl_probe(struct udevice *dev)
 
 	info->base = (void __iomem *)devfdt_get_addr(dev);
 	if (!info->base) {
-		error("unable to find regmap\n");
+		pr_err("unable to find regmap\n");
 		return -ENODEV;
 	}
 
diff --git a/drivers/pinctrl/pinctrl-single.c b/drivers/pinctrl/pinctrl-single.c
index a38d774ddc..72f99be7e6 100644
--- a/drivers/pinctrl/pinctrl-single.c
+++ b/drivers/pinctrl/pinctrl-single.c
@@ -7,7 +7,7 @@
 #include <common.h>
 #include <dm.h>
 #include <dm/pinctrl.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <asm/io.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/pinctrl/pinctrl-sti.c b/drivers/pinctrl/pinctrl-sti.c
index 40341b4eeb..735e412f60 100644
--- a/drivers/pinctrl/pinctrl-sti.c
+++ b/drivers/pinctrl/pinctrl-sti.c
@@ -142,7 +142,7 @@ void sti_pin_configure(struct udevice *dev, struct sti_pin_desc *pin_desc)
 		break;
 
 	default:
-		error("%s invalid direction value: 0x%x\n",
+		pr_err("%s invalid direction value: 0x%x\n",
 		      __func__, pin_desc->dir);
 		BUG();
 		break;
@@ -237,14 +237,14 @@ static int sti_pinctrl_set_state(struct udevice *dev, struct udevice *config)
 						     prop_name, "#gpio-cells",
 						     0, 0, &args);
 		if (ret < 0) {
-			error("Can't get the gpio bank phandle: %d\n", ret);
+			pr_err("Can't get the gpio bank phandle: %d\n", ret);
 			return ret;
 		}
 
 		bank_name = fdt_getprop(blob, args.node, "st,bank-name",
 					&count);
 		if (count < 0) {
-			error("Can't find bank-name property %d\n", count);
+			pr_err("Can't find bank-name property %d\n", count);
 			return -EINVAL;
 		}
 
@@ -254,12 +254,12 @@ static int sti_pinctrl_set_state(struct udevice *dev, struct udevice *config)
 						   prop_name, cells,
 						   ARRAY_SIZE(cells));
 		if (count < 0) {
-			error("Bad pin configuration array %d\n", count);
+			pr_err("Bad pin configuration array %d\n", count);
 			return -EINVAL;
 		}
 
 		if (count > MAX_STI_PINCONF_ENTRIES) {
-			error("Unsupported pinconf array count %d\n", count);
+			pr_err("Unsupported pinconf array count %d\n", count);
 			return -EINVAL;
 		}
 
@@ -284,13 +284,13 @@ static int sti_pinctrl_probe(struct udevice *dev)
 	err = uclass_get_device_by_phandle(UCLASS_SYSCON, dev,
 					   "st,syscfg", &syscon);
 	if (err) {
-		error("unable to find syscon device\n");
+		pr_err("unable to find syscon device\n");
 		return err;
 	}
 
 	plat->regmap = syscon_get_regmap(syscon);
 	if (!plat->regmap) {
-		error("unable to find regmap\n");
+		pr_err("unable to find regmap\n");
 		return -ENODEV;
 	}
 
diff --git a/drivers/pinctrl/pinctrl-uclass.c b/drivers/pinctrl/pinctrl-uclass.c
index 114952a1da..ac6f975ae6 100644
--- a/drivers/pinctrl/pinctrl-uclass.c
+++ b/drivers/pinctrl/pinctrl-uclass.c
@@ -5,13 +5,14 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <linux/err.h>
 #include <linux/list.h>
 #include <dm.h>
 #include <dm/lists.h>
 #include <dm/pinctrl.h>
 #include <dm/util.h>
+#include <dm/of_access.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -63,16 +64,13 @@ static int pinctrl_config_one(struct udevice *config)
  */
 static int pinctrl_select_state_full(struct udevice *dev, const char *statename)
 {
-	const void *fdt = gd->fdt_blob;
-	int node = dev_of_offset(dev);
 	char propname[32]; /* long enough */
 	const fdt32_t *list;
 	uint32_t phandle;
-	int config_node;
 	struct udevice *config;
 	int state, size, i, ret;
 
-	state = fdt_stringlist_search(fdt, node, "pinctrl-names", statename);
+	state = dev_read_stringlist_search(dev, "pinctrl-names", statename);
 	if (state < 0) {
 		char *end;
 		/*
@@ -85,22 +83,15 @@ static int pinctrl_select_state_full(struct udevice *dev, const char *statename)
 	}
 
 	snprintf(propname, sizeof(propname), "pinctrl-%d", state);
-	list = fdt_getprop(fdt, node, propname, &size);
+	list = dev_read_prop(dev, propname, &size);
 	if (!list)
 		return -EINVAL;
 
 	size /= sizeof(*list);
 	for (i = 0; i < size; i++) {
 		phandle = fdt32_to_cpu(*list++);
-
-		config_node = fdt_node_offset_by_phandle(fdt, phandle);
-		if (config_node < 0) {
-			dev_err(dev, "prop %s index %d invalid phandle\n",
-				propname, i);
-			return -EINVAL;
-		}
-		ret = uclass_get_device_by_of_offset(UCLASS_PINCONFIG,
-						     config_node, &config);
+		ret = uclass_get_device_by_phandle_id(UCLASS_PINCONFIG, phandle,
+						      &config);
 		if (ret)
 			return ret;
 
@@ -253,6 +244,16 @@ int pinctrl_get_gpio_mux(struct udevice *dev, int banknum, int index)
 	return ops->get_gpio_mux(dev, banknum, index);
 }
 
+int pinctrl_get_pins_count(struct udevice *dev)
+{
+	struct pinctrl_ops *ops = pinctrl_get_ops(dev);
+
+	if (!ops->get_pins_count)
+		return -ENOSYS;
+
+	return ops->get_pins_count(dev);
+}
+
 /**
  * pinconfig_post_bind() - post binding for PINCTRL uclass
  * Recursively bind child nodes as pinconfig devices in case of full pinctrl.
diff --git a/drivers/pinctrl/pinctrl_stm32.c b/drivers/pinctrl/pinctrl_stm32.c
index fb2593c690..62ba089083 100644
--- a/drivers/pinctrl/pinctrl_stm32.c
+++ b/drivers/pinctrl/pinctrl_stm32.c
@@ -160,7 +160,7 @@ static int stm32_pinctrl_set_state_simple(struct udevice *dev,
 
 		config_node = fdt_node_offset_by_phandle(fdt, phandle);
 		if (config_node < 0) {
-			error("prop pinctrl-0 index %d invalid phandle\n", i);
+			pr_err("prop pinctrl-0 index %d invalid phandle\n", i);
 			return -EINVAL;
 		}
 
diff --git a/drivers/pinctrl/rockchip/Makefile b/drivers/pinctrl/rockchip/Makefile
index 5251771a10..9b3c7fc8d4 100644
--- a/drivers/pinctrl/rockchip/Makefile
+++ b/drivers/pinctrl/rockchip/Makefile
@@ -1,15 +1,19 @@
+# SPDX-License-Identifier: GPL-2.0+
 #
-# Copyright (c) 2015 Google, Inc
-# Written by Simon Glass <sjg@chromium.org>
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
+# Copyright (c) 2017 Rockchip Electronics Co., Ltd
 
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK3036) += pinctrl_rk3036.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK3188) += pinctrl_rk3188.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK322X) += pinctrl_rk322x.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK3288) += pinctrl_rk3288.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK3328) += pinctrl_rk3328.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK3368) += pinctrl_rk3368.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RK3399) += pinctrl_rk3399.o
-obj-$(CONFIG_PINCTRL_ROCKCHIP_RV1108) += pinctrl_rv1108.o
+obj-y += pinctrl-rockchip-core.o
+#obj-$(CONFIG_ROCKCHIP_RK3036) += pinctrl-rk3036.o
+#obj-$(CONFIG_ROCKCHIP_RK3128) += pinctrl-rk3128.o
+#obj-$(CONFIG_ROCKCHIP_RK3188) += pinctrl-rk3188.o
+#obj-$(CONFIG_ROCKCHIP_RK322X) += pinctrl-rk322x.o
+#obj-$(CONFIG_ROCKCHIP_RK3288) += pinctrl-rk3288.o
+#obj-$(CONFIG_ROCKCHIP_RK3308) += pinctrl-rk3308.o
+#obj-$(CONFIG_ROCKCHIP_RK3328) += pinctrl-rk3328.o
+#obj-$(CONFIG_ROCKCHIP_RK3368) += pinctrl-rk3368.o
+#obj-$(CONFIG_ROCKCHIP_RK3399) += pinctrl-rk3399.o
+obj-$(CONFIG_ROCKCHIP_RK3568) += pinctrl-rk3568.o
+obj-$(CONFIG_ROCKCHIP_RK3588) += pinctrl-rk3588.o
+obj-$(CONFIG_ROCKCHIP_RV1106) += pinctrl-rv1106.o
+#obj-$(CONFIG_ROCKCHIP_RV1108) += pinctrl-rv1108.o
+obj-$(CONFIG_ROCKCHIP_RV1126) += pinctrl-rv1126.o
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk3036.c b/drivers/pinctrl/rockchip/pinctrl_rk3036.c
index 94f6d7ad40..f516515816 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk3036.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk3036.c
@@ -10,10 +10,10 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/grf_rk3036.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/grf_rk3036.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/periph.h>
 #include <dm/pinctrl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk3188.c b/drivers/pinctrl/rockchip/pinctrl_rk3188.c
index 692d8e298d..2128d2bc53 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk3188.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk3188.c
@@ -10,11 +10,11 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/grf_rk3188.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/periph.h>
-#include <asm/arch/pmu_rk3188.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/grf_rk3188.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/periph.h>
+#include <asm/arch-rockchip/pmu_rk3188.h>
 #include <dm/pinctrl.h>
 #include <dm/root.h>
 
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk322x.c b/drivers/pinctrl/rockchip/pinctrl_rk322x.c
index 576b03739f..491185c98c 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk322x.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk322x.c
@@ -9,10 +9,10 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/grf_rk322x.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/grf_rk322x.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/periph.h>
 #include <dm/pinctrl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk3288.c b/drivers/pinctrl/rockchip/pinctrl_rk3288.c
index a21b64044b..b9bd00d3d7 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk3288.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk3288.c
@@ -11,11 +11,11 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/grf_rk3288.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/periph.h>
-#include <asm/arch/pmu_rk3288.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/grf_rk3288.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/periph.h>
+#include <asm/arch-rockchip/pmu_rk3288.h>
 #include <dm/pinctrl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk3328.c b/drivers/pinctrl/rockchip/pinctrl_rk3328.c
index c74163e026..00e01e376b 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk3328.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk3328.c
@@ -8,10 +8,10 @@
 #include <dm.h>
 #include <errno.h>
 #include <syscon.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/grf_rk3328.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/grf_rk3328.h>
+#include <asm/arch-rockchip/periph.h>
 #include <asm/io.h>
 #include <dm/pinctrl.h>
 
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk3368.c b/drivers/pinctrl/rockchip/pinctrl_rk3368.c
index 81ce2e31a7..d8a7841566 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk3368.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk3368.c
@@ -11,10 +11,10 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/grf_rk3368.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/grf_rk3368.h>
+#include <asm/arch-rockchip/periph.h>
 #include <dm/pinctrl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/pinctrl/rockchip/pinctrl_rk3399.c b/drivers/pinctrl/rockchip/pinctrl_rk3399.c
index cab268c7d6..e82c3c38d2 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rk3399.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rk3399.c
@@ -9,10 +9,10 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/grf_rk3399.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/periph.h>
-#include <asm/arch/clock.h>
+#include <asm/arch-rockchip/grf_rk3399.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/periph.h>
+#include <asm/arch-rockchip/clock.h>
 #include <dm/pinctrl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/pinctrl/rockchip/pinctrl_rv1108.c b/drivers/pinctrl/rockchip/pinctrl_rv1108.c
index cda94f4957..2003cfc75d 100644
--- a/drivers/pinctrl/rockchip/pinctrl_rv1108.c
+++ b/drivers/pinctrl/rockchip/pinctrl_rv1108.c
@@ -8,10 +8,10 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/grf_rv1108.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/periph.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/grf_rv1108.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/periph.h>
 #include <dm/pinctrl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index d8c107e206..8aacb5be89 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -2,10 +2,26 @@ menu "Power"
 
 source "drivers/power/domain/Kconfig"
 
+source "drivers/power/fuel_gauge/Kconfig"
+
+source "drivers/power/io-domain/Kconfig"
+
 source "drivers/power/pmic/Kconfig"
 
+source "drivers/power/power_delivery/Kconfig"
+
 source "drivers/power/regulator/Kconfig"
 
+source "drivers/power/dvfs/Kconfig"
+
+source "drivers/power/charge/Kconfig"
+
+config DM_CHARGE_DISPLAY
+	bool "Enable driver model for charge display support"
+	depends on DM
+	help
+	  This adds a simple uclass for charge display.
+
 choice
 	prompt "Select Sunxi PMIC Variant"
 	depends on ARCH_SUNXI
@@ -67,6 +83,21 @@ config SY8106A_POWER
 
 endchoice
 
+config CHARGE_ANIMATION
+	bool "Enable charge animation"
+	depends on DM_CHARGE_DISPLAY && DM_FUEL_GAUGE
+	select ARM_CPU_SUSPEND
+	help
+	  This adds a simple function for charge animation display.
+
+config ROCKCHIP_PM
+	bool "Enable Rockchip power manager for charge animation"
+	depends on CHARGE_ANIMATION
+	default y
+	help
+	  This adds power manage control of devices for low power
+	  during system suspend in charge animation.
+
 config AXP_DCDC1_VOLT
 	int "axp pmic dcdc1 voltage"
 	depends on AXP221_POWER || AXP809_POWER || AXP818_POWER
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index 90a3b00a7c..0ad93a981f 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -5,11 +5,15 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-$(CONFIG_DM_CHARGE_DISPLAY)	+= charge-display-uclass.o
+
 obj-$(CONFIG_AXP152_POWER)	+= axp152.o
 obj-$(CONFIG_AXP209_POWER)	+= axp209.o
 obj-$(CONFIG_AXP221_POWER)	+= axp221.o
 obj-$(CONFIG_AXP809_POWER)	+= axp809.o
 obj-$(CONFIG_AXP818_POWER)	+= axp818.o
+obj-$(CONFIG_CHARGE_ANIMATION)	+= charge_animation.o
+obj-$(CONFIG_ROCKCHIP_PM)	+= rockchip_pm.o
 obj-$(CONFIG_EXYNOS_TMU)	+= exynos-tmu.o
 obj-$(CONFIG_FTPMU010_POWER)	+= ftpmu010.o
 obj-$(CONFIG_SY8106A_POWER)	+= sy8106a.o
diff --git a/drivers/power/fuel_gauge/Makefile b/drivers/power/fuel_gauge/Makefile
index 3b349f939a..5aa110a8ec 100644
--- a/drivers/power/fuel_gauge/Makefile
+++ b/drivers/power/fuel_gauge/Makefile
@@ -5,4 +5,15 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-$(CONFIG_$(SPL_)DM_FUEL_GAUGE) += fuel_gauge_uclass.o
+
+obj-$(CONFIG_POWER_FG_CW201X) += fg_cw201x.o
 obj-$(CONFIG_POWER_FG_MAX17042) += fg_max17042.o
+obj-$(CONFIG_POWER_FG_RK818) += fg_rk818.o
+obj-$(CONFIG_POWER_FG_RK816) += fg_rk816.o
+
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_SPL_POWER_FG_RK817) += spl_fg_rk817.o
+else
+obj-$(CONFIG_POWER_FG_RK817) += fg_rk817.o
+endif
diff --git a/drivers/power/pmic/Kconfig b/drivers/power/pmic/Kconfig
index e3f9e4dfc0..166f60691f 100644
--- a/drivers/power/pmic/Kconfig
+++ b/drivers/power/pmic/Kconfig
@@ -10,6 +10,18 @@ config DM_PMIC
 	- 'drivers/power/pmic/pmic-uclass.c'
 	- 'include/power/pmic.h'
 
+config SPL_DM_PMIC
+        bool "Enable Driver Model for PMIC drivers (UCLASS_PMIC) in SPL"
+        depends on DM && SPL
+        ---help---
+        This config enables the driver-model PMIC support.
+        UCLASS_PMIC - designed to provide an I/O interface for PMIC devices.
+        For the multi-function PMIC devices, this can be used as parent I/O
+        device for each IC's interface. Then, each children uses its parent
+        for read/write. For detailed description, please refer to the files:
+        - 'drivers/power/pmic/pmic-uclass.c'
+        - 'include/power/pmic.h'
+
 config PMIC_CHILDREN
 	bool "Allow child devices for PMICs"
 	depends on DM_PMIC
@@ -109,6 +121,14 @@ config PMIC_RK8XX
 	accessed via an I2C interface. The device is used with Rockchip SoCs.
 	This driver implements register read/write operations.
 
+config PMIC_SPI_RK8XX
+	bool "Enable support for Rockchip PMIC SPI RK8XX"
+	depends on DM_PMIC
+	---help---
+	The Rockchip RK8xx PMIC provides four buck DC-DC convertors, LDOs. It is
+	accessed via an SPI interface. The device is used with Rockchip SoCs.
+	This driver implements register read/write operations.
+
 config PMIC_S2MPS11
 	bool "Enable Driver Model for PMIC Samsung S2MPS11"
 	depends on DM_PMIC
diff --git a/drivers/power/pmic/Makefile b/drivers/power/pmic/Makefile
index f7bdfa5609..e95c595541 100644
--- a/drivers/power/pmic/Makefile
+++ b/drivers/power/pmic/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_PMIC_AS3722) += as3722.o as3722_gpio.o
 obj-$(CONFIG_PMIC_MAX8997) += max8997.o
 obj-$(CONFIG_PMIC_PM8916) += pm8916.o
 obj-$(CONFIG_PMIC_RK8XX) += rk8xx.o
+obj-$(CONFIG_PMIC_SPI_RK8XX) += rk8xx_spi.o
 obj-$(CONFIG_PMIC_RN5T567) += rn5t567.o
 obj-$(CONFIG_PMIC_TPS65090) += tps65090.o
 obj-$(CONFIG_PMIC_S5M8767) += s5m8767.o
diff --git a/drivers/power/pmic/act8846.c b/drivers/power/pmic/act8846.c
index a6b0940956..7d107f4427 100644
--- a/drivers/power/pmic/act8846.c
+++ b/drivers/power/pmic/act8846.c
@@ -9,7 +9,7 @@
 #include <dm.h>
 #include <errno.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <power/act8846_pmic.h>
 #include <power/pmic.h>
 
diff --git a/drivers/power/pmic/as3722.c b/drivers/power/pmic/as3722.c
index 4efe8ee183..3b0427e0b9 100644
--- a/drivers/power/pmic/as3722.c
+++ b/drivers/power/pmic/as3722.c
@@ -46,14 +46,14 @@ static int as3722_read_id(struct udevice *dev, uint *idp, uint *revisionp)
 
 	ret = pmic_reg_read(dev, AS3722_ASIC_ID1);
 	if (ret < 0) {
-		error("failed to read ID1 register: %d", ret);
+		pr_err("failed to read ID1 register: %d", ret);
 		return ret;
 	}
 	*idp = ret;
 
 	ret = pmic_reg_read(dev, AS3722_ASIC_ID2);
 	if (ret < 0) {
-		error("failed to read ID2 register: %d", ret);
+		pr_err("failed to read ID2 register: %d", ret);
 		return ret;
 	}
 	*revisionp = ret;
@@ -71,7 +71,7 @@ int as3722_sd_set_voltage(struct udevice *dev, unsigned int sd, u8 value)
 
 	ret = pmic_reg_write(dev, AS3722_SD_VOLTAGE(sd), value);
 	if (ret < 0) {
-		error("failed to write SD%u voltage register: %d", sd, ret);
+		pr_err("failed to write SD%u voltage register: %d", sd, ret);
 		return ret;
 	}
 
@@ -87,7 +87,7 @@ int as3722_ldo_set_voltage(struct udevice *dev, unsigned int ldo, u8 value)
 
 	ret = pmic_reg_write(dev, AS3722_LDO_VOLTAGE(ldo), value);
 	if (ret < 0) {
-		error("failed to write LDO%u voltage register: %d", ldo,
+		pr_err("failed to write LDO%u voltage register: %d", ldo,
 		      ret);
 		return ret;
 	}
@@ -102,12 +102,12 @@ static int as3722_probe(struct udevice *dev)
 
 	ret = as3722_read_id(dev, &id, &revision);
 	if (ret < 0) {
-		error("failed to read ID: %d", ret);
+		pr_err("failed to read ID: %d", ret);
 		return ret;
 	}
 
 	if (id != AS3722_DEVICE_ID) {
-		error("unknown device");
+		pr_err("unknown device");
 		return -ENOENT;
 	}
 
diff --git a/drivers/power/pmic/as3722_gpio.c b/drivers/power/pmic/as3722_gpio.c
index d0b681ca4a..5cf4cb6b51 100644
--- a/drivers/power/pmic/as3722_gpio.c
+++ b/drivers/power/pmic/as3722_gpio.c
@@ -26,7 +26,7 @@ int as3722_gpio_configure(struct udevice *pmic, unsigned int gpio,
 
 	err = pmic_reg_write(pmic, AS3722_GPIO_CONTROL(gpio), value);
 	if (err) {
-		error("failed to configure GPIO#%u: %d", gpio, err);
+		pr_err("failed to configure GPIO#%u: %d", gpio, err);
 		return err;
 	}
 
@@ -46,7 +46,7 @@ static int as3722_gpio_set_value(struct udevice *dev, unsigned int gpio,
 
 	err = pmic_reg_read(pmic, AS3722_GPIO_SIGNAL_OUT);
 	if (err < 0) {
-		error("failed to read GPIO signal out register: %d", err);
+		pr_err("failed to read GPIO signal out register: %d", err);
 		return err;
 	}
 	value = err;
@@ -61,7 +61,7 @@ static int as3722_gpio_set_value(struct udevice *dev, unsigned int gpio,
 
 	err = pmic_reg_write(pmic, AS3722_GPIO_SIGNAL_OUT, value);
 	if (err) {
-		error("failed to set GPIO#%u %s: %d", gpio, l, err);
+		pr_err("failed to set GPIO#%u %s: %d", gpio, l, err);
 		return err;
 	}
 
@@ -84,13 +84,13 @@ int as3722_gpio_direction_output(struct udevice *dev, unsigned int gpio,
 
 	err = pmic_reg_write(pmic, AS3722_GPIO_CONTROL(gpio), value);
 	if (err) {
-		error("failed to configure GPIO#%u as output: %d", gpio, err);
+		pr_err("failed to configure GPIO#%u as output: %d", gpio, err);
 		return err;
 	}
 
 	err = as3722_gpio_set_value(pmic, gpio, value);
 	if (err < 0) {
-		error("failed to set GPIO#%u high: %d", gpio, err);
+		pr_err("failed to set GPIO#%u high: %d", gpio, err);
 		return err;
 	}
 
diff --git a/drivers/power/pmic/i2c_pmic_emul.c b/drivers/power/pmic/i2c_pmic_emul.c
index 2d35d09d45..38a2a04f17 100644
--- a/drivers/power/pmic/i2c_pmic_emul.c
+++ b/drivers/power/pmic/i2c_pmic_emul.c
@@ -31,7 +31,7 @@ static int sandbox_i2c_pmic_read_data(struct udevice *emul, uchar chip,
 	struct sandbox_i2c_pmic_plat_data *plat = dev_get_platdata(emul);
 
 	if (plat->rw_reg + len > SANDBOX_PMIC_REG_COUNT) {
-		error("Request exceeds PMIC register range! Max register: %#x",
+		pr_err("Request exceeds PMIC register range! Max register: %#x",
 		      SANDBOX_PMIC_REG_COUNT);
 		return -EFAULT;
 	}
@@ -68,7 +68,7 @@ static int sandbox_i2c_pmic_write_data(struct udevice *emul, uchar chip,
 	len--;
 
 	if (plat->rw_reg + len > SANDBOX_PMIC_REG_COUNT) {
-		error("Request exceeds PMIC register range! Max register: %#x",
+		pr_err("Request exceeds PMIC register range! Max register: %#x",
 		      SANDBOX_PMIC_REG_COUNT);
 	}
 
@@ -111,7 +111,7 @@ static int sandbox_i2c_pmic_ofdata_to_platdata(struct udevice *emul)
 					     SANDBOX_PMIC_REG_COUNT);
 
 	if (!reg_defaults) {
-		error("Property \"reg-defaults\" not found for device: %s!",
+		pr_err("Property \"reg-defaults\" not found for device: %s!",
 		      emul->name);
 		return -EINVAL;
 	}
diff --git a/drivers/power/pmic/lp873x.c b/drivers/power/pmic/lp873x.c
index f505468313..95c2b7e8c7 100644
--- a/drivers/power/pmic/lp873x.c
+++ b/drivers/power/pmic/lp873x.c
@@ -27,7 +27,7 @@ static int lp873x_write(struct udevice *dev, uint reg, const uint8_t *buff,
 			  int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -37,7 +37,7 @@ static int lp873x_write(struct udevice *dev, uint reg, const uint8_t *buff,
 static int lp873x_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 {
 	if (dm_i2c_read(dev, reg, buff, len)) {
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
diff --git a/drivers/power/pmic/lp87565.c b/drivers/power/pmic/lp87565.c
index 782a46c4cc..506769e362 100644
--- a/drivers/power/pmic/lp87565.c
+++ b/drivers/power/pmic/lp87565.c
@@ -29,7 +29,7 @@ static int lp87565_write(struct udevice *dev, uint reg, const uint8_t *buff,
 
 	ret = dm_i2c_write(dev, reg, buff, len);
 	if (ret)
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
@@ -40,7 +40,7 @@ static int lp87565_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 
 	ret = dm_i2c_read(dev, reg, buff, len);
 	if (ret)
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
diff --git a/drivers/power/pmic/max77686.c b/drivers/power/pmic/max77686.c
index ceca9f96a7..b3ed84992f 100644
--- a/drivers/power/pmic/max77686.c
+++ b/drivers/power/pmic/max77686.c
@@ -31,7 +31,7 @@ static int max77686_write(struct udevice *dev, uint reg, const uint8_t *buff,
 			  int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -41,7 +41,7 @@ static int max77686_write(struct udevice *dev, uint reg, const uint8_t *buff,
 static int max77686_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 {
 	if (dm_i2c_read(dev, reg, buff, len)) {
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
diff --git a/drivers/power/pmic/max8997.c b/drivers/power/pmic/max8997.c
index f749d7debf..5ebeb8a316 100644
--- a/drivers/power/pmic/max8997.c
+++ b/drivers/power/pmic/max8997.c
@@ -26,7 +26,7 @@ static int max8997_write(struct udevice *dev, uint reg, const uint8_t *buff,
 
 	ret = dm_i2c_write(dev, reg, buff, len);
 	if (ret)
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
@@ -37,7 +37,7 @@ static int max8997_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 
 	ret = dm_i2c_read(dev, reg, buff, len);
 	if (ret)
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
diff --git a/drivers/power/pmic/max8998.c b/drivers/power/pmic/max8998.c
index 7c4773c7b3..a7e04699e8 100644
--- a/drivers/power/pmic/max8998.c
+++ b/drivers/power/pmic/max8998.c
@@ -26,7 +26,7 @@ static int max8998_write(struct udevice *dev, uint reg, const uint8_t *buff,
 
 	ret = dm_i2c_write(dev, reg, buff, len);
 	if (ret)
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
@@ -37,7 +37,7 @@ static int max8998_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 
 	ret = dm_i2c_read(dev, reg, buff, len);
 	if (ret)
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
diff --git a/drivers/power/pmic/palmas.c b/drivers/power/pmic/palmas.c
index 804c0d13a0..1e1ecb382e 100644
--- a/drivers/power/pmic/palmas.c
+++ b/drivers/power/pmic/palmas.c
@@ -27,7 +27,7 @@ static int palmas_write(struct udevice *dev, uint reg, const uint8_t *buff,
 			  int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -37,7 +37,7 @@ static int palmas_write(struct udevice *dev, uint reg, const uint8_t *buff,
 static int palmas_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 {
 	if (dm_i2c_read(dev, reg, buff, len)) {
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
diff --git a/drivers/power/pmic/pfuze100.c b/drivers/power/pmic/pfuze100.c
index 5f361c7696..a06cbc07d4 100644
--- a/drivers/power/pmic/pfuze100.c
+++ b/drivers/power/pmic/pfuze100.c
@@ -33,7 +33,7 @@ static int pfuze100_write(struct udevice *dev, uint reg, const uint8_t *buff,
 			  int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -43,7 +43,7 @@ static int pfuze100_write(struct udevice *dev, uint reg, const uint8_t *buff,
 static int pfuze100_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 {
 	if (dm_i2c_read(dev, reg, buff, len)) {
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
diff --git a/drivers/power/pmic/pmic-uclass.c b/drivers/power/pmic/pmic-uclass.c
index 953bbe5026..127f24481a 100644
--- a/drivers/power/pmic/pmic-uclass.c
+++ b/drivers/power/pmic/pmic-uclass.c
@@ -13,6 +13,7 @@
 #include <dm/lists.h>
 #include <dm/device-internal.h>
 #include <dm/uclass-internal.h>
+#include <dm/of_access.h>
 #include <power/pmic.h>
 #include <linux/ctype.h>
 
@@ -26,28 +27,53 @@ int pmic_bind_children(struct udevice *pmic, ofnode parent,
 	struct driver *drv;
 	struct udevice *child;
 	const char *node_name;
+	const char *reg_name;
 	int bind_count = 0;
 	ofnode node;
-	int prefix_len;
 	int ret;
+	bool enable;
 
 	debug("%s for '%s' at node offset: %d\n", __func__, pmic->name,
 	      dev_of_offset(pmic));
 
-	for (node = ofnode_first_subnode(parent);
-	     ofnode_valid(node);
-	     node = ofnode_next_subnode(node)) {
+	ofnode_for_each_subnode(node, parent) {
 		node_name = ofnode_get_name(node);
 
 		debug("* Found child node: '%s'\n", node_name);
 
+		if (ofnode_is_np(node))
+			enable = of_device_is_available(ofnode_to_np(node));
+		else
+			enable = fdtdec_get_is_enabled(gd->fdt_blob,
+						       ofnode_to_offset(node));
+		if (!enable) {
+			debug("* But '%s' is disabled\n", node_name);
+			continue;
+		}
+
 		child = NULL;
 		for (info = child_info; info->prefix && info->driver; info++) {
 			debug("  - compatible prefix: '%s'\n", info->prefix);
 
-			prefix_len = strlen(info->prefix);
-			if (strncmp(info->prefix, node_name, prefix_len))
-				continue;
+			if (!strstr(node_name, info->prefix)) {
+				reg_name = ofnode_read_string(node,
+							      "regulator-name");
+				if (!reg_name)
+					continue;
+				if (!strstr(reg_name, info->prefix))
+					continue;
+			}
+
+			/*
+			 * If some child info->prefix are the same, try to
+			 * distinguish them by parent addr.
+			 *
+			 * Example: pmic@20, pmic@1a...
+			 */
+			if (info->addr) {
+				if (!strstr(dev_read_name(pmic), info->addr))
+					continue;
+			}
 
 			drv = lists_driver_lookup_name(info->driver);
 			if (!drv) {
@@ -163,6 +189,36 @@ int pmic_clrsetbits(struct udevice *dev, uint reg, uint clr, uint set)
 	return pmic_reg_write(dev, reg, byte);
 }
 
+int pmic_suspend(struct udevice *dev)
+{
+	const struct dm_pmic_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->suspend)
+		return -ENOSYS;
+
+	return ops->suspend(dev);
+}
+
+int pmic_resume(struct udevice *dev)
+{
+	const struct dm_pmic_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->resume)
+		return -ENOSYS;
+
+	return ops->resume(dev);
+}
+
+int pmic_shutdown(struct udevice *dev)
+{
+	const struct dm_pmic_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->shutdown)
+		return -ENOSYS;
+
+	return ops->shutdown(dev);
+}
+
 UCLASS_DRIVER(pmic) = {
 	.id		= UCLASS_PMIC,
 	.name		= "pmic",
diff --git a/drivers/power/pmic/rk8xx.c b/drivers/power/pmic/rk8xx.c
index eb3ec0f601..a70b371768 100644
--- a/drivers/power/pmic/rk8xx.c
+++ b/drivers/power/pmic/rk8xx.c
@@ -8,23 +8,199 @@
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
-#include <fdtdec.h>
-#include <libfdt.h>
+#include <irq-generic.h>
 #include <power/rk8xx_pmic.h>
 #include <power/pmic.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#if CONFIG_IS_ENABLED(IRQ)
+/* RK805 */
+static const struct virq_reg rk805_irqs[] = {
+	[RK8XX_IRQ_PWRON_FALL] = {
+		.mask = RK805_IRQ_PWRON_FALL_MSK,
+		.reg_offset = 0,
+	},
+	[RK8XX_IRQ_PWRON_RISE] = {
+		.mask = RK805_IRQ_PWRON_RISE_MSK,
+		.reg_offset = 0,
+	},
+};
+
+static struct virq_chip rk805_irq_chip = {
+	.status_base		= RK805_INT_STS_REG,
+	.mask_base		= RK805_INT_MSK_REG,
+	.num_regs		= 1,
+	.read			= pmic_reg_read,
+	.write			= pmic_reg_write,
+	.irqs			= rk805_irqs,
+	.num_irqs		= ARRAY_SIZE(rk805_irqs),
+};
+
+/* RK808 */
+static const struct virq_reg rk808_irqs[] = {
+	[RK8XX_IRQ_PLUG_OUT] = {
+		.mask = RK808_IRQ_PLUG_OUT_MSK,
+		.reg_offset = 1,
+	},
+};
+
+static struct virq_chip rk808_irq_chip = {
+	.status_base		= RK808_INT_STS_REG1,
+	.mask_base		= RK808_INT_MSK_REG1,
+	.irq_reg_stride		= 2,
+	.num_regs		= 2,
+	.read			= pmic_reg_read,
+	.write			= pmic_reg_write,
+	.irqs			= rk808_irqs,
+	.num_irqs		= ARRAY_SIZE(rk808_irqs),
+};
+
+/* RK816 */
+static const struct virq_reg rk816_irqs[] = {
+	[RK8XX_IRQ_PWRON_FALL] = {
+		.mask = RK816_IRQ_PWRON_FALL_MSK,
+		.reg_offset = 0,
+	},
+	[RK8XX_IRQ_PWRON_RISE] = {
+		.mask = RK816_IRQ_PWRON_RISE_MSK,
+		.reg_offset = 0,
+	},
+	[RK8XX_IRQ_PLUG_OUT] = {
+		.mask = RK816_IRQ_PLUG_OUT_MSK,
+		.reg_offset = 2,
+	},
+	[RK8XX_IRQ_CHG_OK] = {
+		.mask = RK816_IRQ_CHR_OK_MSK,
+		.reg_offset = 2,
+	},
+};
+
+static struct virq_chip rk816_irq_chip = {
+	.status_base		= RK816_INT_STS_REG1,
+	.mask_base		= RK816_INT_MSK_REG1,
+	.irq_unalign_reg_idx	= 1,	/* idx <= 1, stride = 3 */
+	.irq_unalign_reg_stride	= 3,
+	.irq_reg_stride		= 2,	/* idx > 1, stride = 2 */
+	.num_regs		= 3,
+	.read			= pmic_reg_read,
+	.write			= pmic_reg_write,
+	.irqs			= rk816_irqs,
+	.num_irqs		= ARRAY_SIZE(rk816_irqs),
+};
+
+/* RK818 */
+static const struct virq_reg rk818_irqs[] = {
+	[RK8XX_IRQ_PLUG_OUT] = {
+		.mask = RK818_IRQ_PLUG_OUT_MSK,
+		.reg_offset = 1,
+	},
+	[RK8XX_IRQ_CHG_OK] = {
+		.mask = RK818_IRQ_CHR_OK_MSK,
+		.reg_offset = 1,
+	},
+};
+
+static struct virq_chip rk818_irq_chip = {
+	.status_base		= RK818_INT_STS_REG1,
+	.mask_base		= RK818_INT_MSK_REG1,
+	.irq_reg_stride		= 2,
+	.num_regs		= 2,
+	.read			= pmic_reg_read,
+	.write			= pmic_reg_write,
+	.irqs			= rk818_irqs,
+	.num_irqs		= ARRAY_SIZE(rk818_irqs),
+};
+
+/* RK817/RK809 */
+static const struct virq_reg rk817_irqs[] = {
+	[RK8XX_IRQ_PWRON_FALL] = {
+		.mask = RK817_IRQ_PWRON_FALL_MSK,
+		.reg_offset = 0,
+	},
+	[RK8XX_IRQ_PWRON_RISE] = {
+		.mask = RK817_IRQ_PWRON_RISE_MSK,
+		.reg_offset = 0,
+	},
+	[RK8XX_IRQ_PLUG_OUT] = {
+		.mask = RK817_IRQ_PLUG_OUT_MSK,
+		.reg_offset = 1,
+	},
+	[RK8XX_IRQ_PLUG_IN] = {
+		.mask = RK817_IRQ_PLUG_IN_MSK,
+		.reg_offset = 1,
+	},
+};
+
+static struct virq_chip rk817_irq_chip = {
+	.status_base		= RK817_INT_STS_REG0,
+	.mask_base		= RK817_INT_MSK_REG0,
+	.irq_reg_stride		= 2,
+	.num_regs		= 3,
+	.read			= pmic_reg_read,
+	.write			= pmic_reg_write,
+	.irqs			= rk817_irqs,
+	.num_irqs		= ARRAY_SIZE(rk817_irqs),
+};
+#endif
+
+static struct reg_data rk817_init_reg[] = {
+/* enable the under-voltage protection,
+ * the under-voltage protection will shutdown the LDO3 and reset the PMIC
+ */
+	{ RK817_BUCK4_CMIN, 0x6b, 0x6e},
+	{ RK817_PMIC_SYS_CFG1, 0x20, 0x70},
+	/* Set pmic_sleep as none function */
+	{ RK817_PMIC_SYS_CFG3, 0x00, 0x18 },
+
+	/* Set pmic_int active low */
+	{ RK817_GPIO_INT_CFG,  0x00, 0x02 },
+};
+
+static struct reg_data rk818_init_current[] = {
+	{ REG_USB_CTRL, 0x07, 0x0f}, /* 2A */
+};
+
 static const struct pmic_child_info pmic_children_info[] = {
-	{ .prefix = "DCDC_REG", .driver = "rk8xx_buck"},
-	{ .prefix = "LDO_REG", .driver = "rk8xx_ldo"},
-	{ .prefix = "SWITCH_REG", .driver = "rk8xx_switch"},
+	{ .prefix = "DCDC", .driver = "rk8xx_buck"},
+	{ .prefix = "LDO", .driver = "rk8xx_ldo"},
+	{ .prefix = "SWITCH", .driver = "rk8xx_switch"},
+	{ },
+};
+
+static const struct pmic_child_info power_key_info[] = {
+	{ .prefix = "pwrkey", .driver = "rk8xx_pwrkey"},
+	{ },
+};
+
+static const struct pmic_child_info rtc_info[] = {
+	{ .prefix = "rtc", .driver = "rk8xx_rtc"},
+	{ },
+};
+
+static const struct pmic_child_info fuel_gauge_info[] = {
+	{ .addr = "1c", .prefix = "battery", .driver = "rk818_fg"},
+	{ .addr = "20", .prefix = "battery", .driver = "rk817_fg"},
+	{ .addr = "1a", .prefix = "battery", .driver = "rk816_fg"},
+	{ },
+};
+
+static const struct pmic_child_info rk817_codec_info[] = {
+	{ .prefix = "codec", .driver = "rk817_codec"},
 	{ },
 };
 
 static int rk8xx_reg_count(struct udevice *dev)
 {
-	return RK808_NUM_OF_REGS;
+	struct rk8xx_priv *priv = dev_get_priv(dev);
+
+	switch (priv->variant) {
+	case RK809_ID:
+	case RK817_ID:
+		return RK817_NUM_OF_REGS;
+	default:
+		return RK808_NUM_OF_REGS;
+	}
 }
 
 static int rk8xx_write(struct udevice *dev, uint reg, const uint8_t *buff,
@@ -34,7 +210,7 @@ static int rk8xx_write(struct udevice *dev, uint reg, const uint8_t *buff,
 
 	ret = dm_i2c_write(dev, reg, buff, len);
 	if (ret) {
-		debug("write error to device: %p register: %#x!", dev, reg);
+		printf("%s: write reg 0x%02x failed, ret=%d\n", __func__, reg, ret);
 		return ret;
 	}
 
@@ -47,13 +223,94 @@ static int rk8xx_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 
 	ret = dm_i2c_read(dev, reg, buff, len);
 	if (ret) {
-		debug("read error from device: %p register: %#x!", dev, reg);
+		printf("%s: read reg 0x%02x failed, ret=%d\n", __func__, reg, ret);
 		return ret;
 	}
 
 	return 0;
 }
 
+static int rk8xx_suspend(struct udevice *dev)
+{
+	struct rk8xx_priv *priv = dev_get_priv(dev);
+	int ret = 0;
+	u8 val;
+
+	switch (priv->variant) {
+	case RK809_ID:
+	case RK817_ID:
+		/* pmic_sleep active high */
+		ret = rk8xx_read(dev, RK817_PMIC_SYS_CFG3, &val, 1);
+		if (ret)
+			return ret;
+		priv->sleep_pin = val;
+		val &= ~0x38;
+		val |= 0x28;
+		ret = rk8xx_write(dev, RK817_PMIC_SYS_CFG3, &val, 1);
+		break;
+	default:
+		return 0;
+	}
+
+	return ret;
+}
+
+static int rk8xx_resume(struct udevice *dev)
+{
+	struct rk8xx_priv *priv = dev_get_priv(dev);
+	int ret = 0;
+
+	switch (priv->variant) {
+	case RK809_ID:
+	case RK817_ID:
+		ret = rk8xx_write(dev, RK817_PMIC_SYS_CFG3, &priv->sleep_pin, 1);
+		break;
+	default:
+		return 0;
+	}
+
+	return ret;
+}
+
+static int rk8xx_shutdown(struct udevice *dev)
+{
+	struct rk8xx_priv *priv = dev_get_priv(dev);
+	u8 val, dev_off, devctrl_reg;
+	int ret = 0;
+
+	switch (priv->variant) {
+	case RK808_ID:
+		devctrl_reg = REG_DEVCTRL;
+		dev_off = BIT(3);
+		break;
+	case RK805_ID:
+	case RK816_ID:
+	case RK818_ID:
+		devctrl_reg = REG_DEVCTRL;
+		dev_off = BIT(0);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		devctrl_reg = RK817_REG_SYS_CFG3;
+		dev_off = BIT(0);
+		break;
+	default:
+		printf("Unknown PMIC: RK%x\n", priv->variant);
+		return -EINVAL;
+	}
+
+	ret = rk8xx_read(dev, devctrl_reg, &val, 1);
+	if (ret)
+		return ret;
+
+	val |= dev_off;
+	ret = rk8xx_write(dev, devctrl_reg, &val, 1);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 #if CONFIG_IS_ENABLED(PMIC_CHILDREN)
 static int rk8xx_bind(struct udevice *dev)
 {
@@ -62,7 +319,7 @@ static int rk8xx_bind(struct udevice *dev)
 
 	regulators_node = dev_read_subnode(dev, "regulators");
 	if (!ofnode_valid(regulators_node)) {
-		debug("%s: %s regulators subnode not found!", __func__,
+		debug("%s: %s regulators subnode not found!\n", __func__,
 		      dev->name);
 		return -ENXIO;
 	}
@@ -73,21 +330,288 @@ static int rk8xx_bind(struct udevice *dev)
 	if (!children)
 		debug("%s: %s - no child found\n", __func__, dev->name);
 
+	children = pmic_bind_children(dev, dev->node, power_key_info);
+	if (!children)
+		debug("%s: %s - no child found\n", __func__, dev->name);
+
+	children = pmic_bind_children(dev, dev->node, rtc_info);
+	if (!children)
+		debug("%s: %s - no child found\n", __func__, dev->name);
+
+	children = pmic_bind_children(dev, dev->node, fuel_gauge_info);
+	if (!children)
+		debug("%s: %s - no child found\n", __func__, dev->name);
+
+	children = pmic_bind_children(dev, dev->node, rk817_codec_info);
+	if (!children)
+		debug("%s: %s - no child found\n", __func__, dev->name);
+
 	/* Always return success for this device */
 	return 0;
 }
 #endif
 
+#if CONFIG_IS_ENABLED(IRQ)
+/*
+ * When system suspend during U-Boot charge, make sure the plugout event
+ * be able to wakeup cpu in wfi/wfe state.
+ */
+#ifdef CONFIG_DM_CHARGE_DISPLAY
+static void rk8xx_plug_out_handler(int irq, void *data)
+{
+	printf("Plug out interrupt\n");
+}
+#endif
+
+static int rk8xx_ofdata_to_platdata(struct udevice *dev)
+{
+	struct rk8xx_priv *rk8xx = dev_get_priv(dev);
+	u32 interrupt, phandle, val;
+	int ret;
+
+	phandle = dev_read_u32_default(dev, "interrupt-parent", -ENODATA);
+	if (phandle == -ENODATA) {
+		printf("Read 'interrupt-parent' failed, ret=%d\n", phandle);
+		return phandle;
+	}
+
+	ret = dev_read_u32_array(dev, "interrupts", &interrupt, 1);
+	if (ret) {
+		printf("Read 'interrupts' failed, ret=%d\n", ret);
+		return ret;
+	}
+
+	rk8xx->irq = phandle_gpio_to_irq(phandle, interrupt);
+	if (rk8xx->irq < 0) {
+		printf("Failed to request rk8xx irq, ret=%d\n", rk8xx->irq);
+		return rk8xx->irq;
+	}
+
+	val = dev_read_u32_default(dev, "long-press-off-time-sec", 0);
+	if (val <= 6)
+		rk8xx->lp_off_time = RK8XX_LP_TIME_6S;
+	else if (val <= 8)
+		rk8xx->lp_off_time = RK8XX_LP_TIME_8S;
+	else if (val <= 10)
+		rk8xx->lp_off_time = RK8XX_LP_TIME_10S;
+	else
+		rk8xx->lp_off_time = RK8XX_LP_TIME_12S;
+
+	val = dev_read_u32_default(dev, "long-press-restart", 0);
+	if (val)
+		rk8xx->lp_action = RK8XX_LP_RESTART;
+	else
+		rk8xx->lp_action = RK8XX_LP_OFF;
+
+	val = dev_read_u32_default(dev, "not-save-power-en", 0);
+	rk8xx->not_save_power_en = val;
+
+	return 0;
+}
+
+static int rk8xx_irq_chip_init(struct udevice *dev)
+{
+	struct rk8xx_priv *priv = dev_get_priv(dev);
+	struct virq_chip *irq_chip = NULL;
+	int ret;
+
+	switch (priv->variant) {
+	case RK808_ID:
+		irq_chip = &rk808_irq_chip;
+		break;
+	case RK805_ID:
+		irq_chip = &rk805_irq_chip;
+		break;
+	case RK816_ID:
+		irq_chip = &rk816_irq_chip;
+		break;
+	case RK818_ID:
+		irq_chip = &rk818_irq_chip;
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		irq_chip = &rk817_irq_chip;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (irq_chip) {
+		ret = virq_add_chip(dev, irq_chip, priv->irq);
+		if (ret) {
+			printf("Failed to add irqchip(irq=%d), ret=%d\n",
+			       priv->irq, ret);
+			return ret;
+		}
+
+		priv->irq_chip = irq_chip;
+
+#ifdef CONFIG_DM_CHARGE_DISPLAY
+		int irq;
+
+		irq = virq_to_irq(irq_chip, RK8XX_IRQ_PLUG_OUT);
+		if (irq < 0) {
+			printf("Failed to register plugout irq, ret=%d\n", irq);
+			return irq;
+		}
+		irq_install_handler(irq, rk8xx_plug_out_handler, dev);
+		irq_handler_enable_suspend_only(irq);
+#endif
+	}
+
+	return 0;
+}
+#else
+static inline int rk8xx_ofdata_to_platdata(struct udevice *dev) { return 0; }
+static inline int rk8xx_irq_chip_init(struct udevice *dev) { return 0; }
+#endif
+
 static int rk8xx_probe(struct udevice *dev)
 {
 	struct rk8xx_priv *priv = dev_get_priv(dev);
-	uint8_t msb, lsb;
+	struct reg_data *init_current = NULL;
+	struct reg_data *init_data = NULL;
+	int init_current_num = 0;
+	int init_data_num = 0;
+	int ret = 0, i, show_variant;
+	uint8_t msb, lsb, id_msb, id_lsb;
+	uint8_t on_source = 0, off_source = 0;
+	uint8_t pwron_key = 0, lp_off_msk = 0, lp_act_msk = 0;
+	uint8_t power_en0, power_en1, power_en2, power_en3;
+	uint8_t on, off;
+	uint8_t value;
 
 	/* read Chip variant */
-	rk8xx_read(dev, ID_MSB, &msb, 1);
-	rk8xx_read(dev, ID_LSB, &lsb, 1);
+	if (device_is_compatible(dev, "rockchip,rk817") ||
+	    device_is_compatible(dev, "rockchip,rk809")) {
+		id_msb = RK817_ID_MSB;
+		id_lsb = RK817_ID_LSB;
+	} else {
+		id_msb = ID_MSB;
+		id_lsb = ID_LSB;
+	}
+
+	ret = rk8xx_read(dev, id_msb, &msb, 1);
+	if (ret)
+		return ret;
+	ret = rk8xx_read(dev, id_lsb, &lsb, 1);
+	if (ret)
+		return ret;
 
 	priv->variant = ((msb << 8) | lsb) & RK8XX_ID_MSK;
+	show_variant = priv->variant;
+	switch (priv->variant) {
+	case RK808_ID:
+		show_variant = 0x808;	/* RK808 hardware ID is 0 */
+		pwron_key = RK8XX_DEVCTRL_REG;
+		lp_off_msk = RK8XX_LP_OFF_MSK;
+		break;
+	case RK805_ID:
+	case RK816_ID:
+		on_source = RK8XX_ON_SOURCE;
+		off_source = RK8XX_OFF_SOURCE;
+		pwron_key = RK8XX_DEVCTRL_REG;
+		lp_off_msk = RK8XX_LP_OFF_MSK;
+		lp_act_msk = RK8XX_LP_ACTION_MSK;
+		break;
+	case RK818_ID:
+		on_source = RK8XX_ON_SOURCE;
+		off_source = RK8XX_OFF_SOURCE;
+		pwron_key = RK8XX_DEVCTRL_REG;
+		lp_off_msk = RK8XX_LP_OFF_MSK;
+		lp_act_msk = RK8XX_LP_ACTION_MSK;
+		/* set current if no fuel gauge */
+		if (!ofnode_valid(dev_read_subnode(dev, "battery"))) {
+			init_current = rk818_init_current;
+			init_current_num = ARRAY_SIZE(rk818_init_current);
+		}
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		on_source = RK817_ON_SOURCE;
+		off_source = RK817_OFF_SOURCE;
+		pwron_key = RK817_PWRON_KEY;
+		lp_off_msk = RK8XX_LP_OFF_MSK;
+		lp_act_msk = RK8XX_LP_ACTION_MSK;
+		init_data = rk817_init_reg;
+		init_data_num = ARRAY_SIZE(rk817_init_reg);
+		/* judge whether save the PMIC_POWER_EN register */
+		if (priv->not_save_power_en)
+			break;
+
+		ret = rk8xx_read(dev, RK817_POWER_EN0, &power_en0, 1);
+		if (ret)
+			return ret;
+		ret = rk8xx_read(dev, RK817_POWER_EN1, &power_en1, 1);
+		if (ret)
+			return ret;
+		ret = rk8xx_read(dev, RK817_POWER_EN2, &power_en2, 1);
+		if (ret)
+			return ret;
+		ret = rk8xx_read(dev, RK817_POWER_EN3, &power_en3, 1);
+		if (ret)
+			return ret;
+
+		value = (power_en0 & 0x0f) | ((power_en1 & 0x0f) << 4);
+		rk8xx_write(dev, RK817_POWER_EN_SAVE0, &value, 1);
+		value = (power_en2 & 0x0f) | ((power_en3 & 0x0f) << 4);
+		rk8xx_write(dev, RK817_POWER_EN_SAVE1, &value, 1);
+		break;
+	default:
+		printf("Unknown PMIC: RK%x!!\n", priv->variant);
+		return -EINVAL;
+	}
+
+	/* common init */
+	for (i = 0; i < init_data_num; i++) {
+		ret = pmic_clrsetbits(dev,
+				      init_data[i].reg,
+				      init_data[i].mask,
+				      init_data[i].val);
+		if (ret < 0) {
+			printf("%s: i2c set reg 0x%x failed, ret=%d\n",
+			       __func__, init_data[i].reg, ret);
+		}
+	}
+
+	/* current init */
+	for (i = 0; i < init_current_num; i++) {
+		ret = pmic_clrsetbits(dev,
+				      init_current[i].reg,
+				      init_current[i].mask,
+				      init_current[i].val);
+		if (ret < 0) {
+			printf("%s: i2c set reg 0x%x failed, ret=%d\n",
+			       __func__, init_current[i].reg, ret);
+		}
+	}
+
+	printf("PMIC:  RK%x ", show_variant);
+
+	if (on_source && off_source) {
+		rk8xx_read(dev, on_source, &on, 1);
+		rk8xx_read(dev, off_source, &off, 1);
+		printf("(on=0x%02x, off=0x%02x)", on, off);
+	}
+	printf("\n");
+
+	if (pwron_key) {
+		ret = rk8xx_read(dev, pwron_key, &value, 1);
+		if (ret)
+			return ret;
+		value &= ~(lp_off_msk | lp_act_msk);
+		if (lp_off_msk)
+			value |= priv->lp_off_time;
+		if (lp_act_msk)
+			value |= priv->lp_action;
+		rk8xx_write(dev, pwron_key, &value, 1);
+	}
+
+	ret = rk8xx_irq_chip_init(dev);
+	if (ret) {
+		printf("IRQ chip initial failed\n");
+		return ret;
+	}
 
 	return 0;
 }
@@ -96,10 +620,17 @@ static struct dm_pmic_ops rk8xx_ops = {
 	.reg_count = rk8xx_reg_count,
 	.read = rk8xx_read,
 	.write = rk8xx_write,
+	.suspend = rk8xx_suspend,
+	.resume = rk8xx_resume,
+	.shutdown = rk8xx_shutdown,
 };
 
 static const struct udevice_id rk8xx_ids[] = {
+	{ .compatible = "rockchip,rk805" },
 	{ .compatible = "rockchip,rk808" },
+	{ .compatible = "rockchip,rk809" },
+	{ .compatible = "rockchip,rk816" },
+	{ .compatible = "rockchip,rk817" },
 	{ .compatible = "rockchip,rk818" },
 	{ }
 };
@@ -111,7 +642,8 @@ U_BOOT_DRIVER(pmic_rk8xx) = {
 #if CONFIG_IS_ENABLED(PMIC_CHILDREN)
 	.bind = rk8xx_bind,
 #endif
-	.priv_auto_alloc_size   = sizeof(struct rk8xx_priv),
+	.ofdata_to_platdata = rk8xx_ofdata_to_platdata,
+	.priv_auto_alloc_size = sizeof(struct rk8xx_priv),
 	.probe = rk8xx_probe,
 	.ops = &rk8xx_ops,
 };
diff --git a/drivers/power/pmic/rn5t567.c b/drivers/power/pmic/rn5t567.c
index 001e69553e..9e5b0b119b 100644
--- a/drivers/power/pmic/rn5t567.c
+++ b/drivers/power/pmic/rn5t567.c
@@ -9,7 +9,7 @@
 #include <dm.h>
 #include <errno.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <power/rn5t567_pmic.h>
 #include <power/pmic.h>
 
diff --git a/drivers/power/pmic/s2mps11.c b/drivers/power/pmic/s2mps11.c
index 9d83059c40..522105e5ff 100644
--- a/drivers/power/pmic/s2mps11.c
+++ b/drivers/power/pmic/s2mps11.c
@@ -27,7 +27,7 @@ static int s2mps11_write(struct udevice *dev, uint reg, const uint8_t *buff,
 
 	ret = dm_i2c_write(dev, reg, buff, len);
 	if (ret)
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
@@ -38,7 +38,7 @@ static int s2mps11_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 
 	ret = dm_i2c_read(dev, reg, buff, len);
 	if (ret)
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 
 	return ret;
 }
diff --git a/drivers/power/pmic/s5m8767.c b/drivers/power/pmic/s5m8767.c
index f8ae5ea2db..3812e240ab 100644
--- a/drivers/power/pmic/s5m8767.c
+++ b/drivers/power/pmic/s5m8767.c
@@ -30,7 +30,7 @@ static int s5m8767_write(struct udevice *dev, uint reg, const uint8_t *buff,
 			  int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -40,7 +40,7 @@ static int s5m8767_write(struct udevice *dev, uint reg, const uint8_t *buff,
 static int s5m8767_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 {
 	if (dm_i2c_read(dev, reg, buff, len)) {
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
diff --git a/drivers/power/pmic/sandbox.c b/drivers/power/pmic/sandbox.c
index 6763303c66..e8d6faca16 100644
--- a/drivers/power/pmic/sandbox.c
+++ b/drivers/power/pmic/sandbox.c
@@ -31,7 +31,7 @@ static int sandbox_pmic_write(struct udevice *dev, uint reg,
 			      const uint8_t *buff, int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -42,7 +42,7 @@ static int sandbox_pmic_read(struct udevice *dev, uint reg,
 			     uint8_t *buff, int len)
 {
 	if (dm_i2c_read(dev, reg, buff, len)) {
-		error("read error from device: %p register: %#x!", dev, reg);
+		pr_err("read error from device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -52,7 +52,7 @@ static int sandbox_pmic_read(struct udevice *dev, uint reg,
 static int sandbox_pmic_bind(struct udevice *dev)
 {
 	if (!pmic_bind_children(dev, dev_ofnode(dev), pmic_children_info))
-		error("%s:%d PMIC: %s - no child found!", __func__, __LINE__,
+		pr_err("%s:%d PMIC: %s - no child found!", __func__, __LINE__,
 							  dev->name);
 
 	/* Always return success for this device - allows for PMIC I/O */
diff --git a/drivers/power/pmic/tps65090.c b/drivers/power/pmic/tps65090.c
index 4565e3b54c..ee5358bced 100644
--- a/drivers/power/pmic/tps65090.c
+++ b/drivers/power/pmic/tps65090.c
@@ -29,7 +29,7 @@ static int tps65090_write(struct udevice *dev, uint reg, const uint8_t *buff,
 			  int len)
 {
 	if (dm_i2c_write(dev, reg, buff, len)) {
-		error("write error to device: %p register: %#x!", dev, reg);
+		pr_err("write error to device: %p register: %#x!", dev, reg);
 		return -EIO;
 	}
 
@@ -42,7 +42,7 @@ static int tps65090_read(struct udevice *dev, uint reg, uint8_t *buff, int len)
 
 	ret = dm_i2c_read(dev, reg, buff, len);
 	if (ret) {
-		error("read error %d from device: %p register: %#x!", ret, dev,
+		pr_err("read error %d from device: %p register: %#x!", ret, dev,
 		      reg);
 		return -EIO;
 	}
diff --git a/drivers/power/regulator/Kconfig b/drivers/power/regulator/Kconfig
index c82a936e8a..37a75ccbcd 100644
--- a/drivers/power/regulator/Kconfig
+++ b/drivers/power/regulator/Kconfig
@@ -51,6 +51,14 @@ config DM_REGULATOR_PFUZE100
 	features for REGULATOR PFUZE100. The driver implements get/set api for:
 	value, enable and mode.
 
+config REGULATOR_FAN53555
+	bool "Enable driver for fan53555 regulators"
+	depends on DM_REGULATOR
+	---help---
+	Enable support for the regulator functions of the fan53555 DCDC. The
+	driver implements get/set api for the various BUCK.This driver is
+	controlled by a device tree node which includes voltage limits.
+
 config REGULATOR_PWM
 	bool "Enable driver for PWM regulators"
 	depends on DM_REGULATOR
@@ -77,6 +85,13 @@ config DM_REGULATOR_FIXED
 	features for fixed value regulators. The driver implements get/set api
 	for enable and get only for voltage value.
 
+config SPL_DM_REGULATOR_FIXED
+	bool "Enable Driver Model for REGULATOR Fixed value in SPL"
+	depends on DM_REGULATOR_FIXED
+	---help---
+	This config enables implementation of driver-model regulator uclass
+	features for fixed value regulators in SPL.
+
 config DM_REGULATOR_GPIO
 	bool "Enable Driver Model for GPIO REGULATOR"
 	depends on DM_REGULATOR
@@ -85,6 +100,14 @@ config DM_REGULATOR_GPIO
 	features for gpio regulators. The driver implements get/set for
 	voltage value.
 
+config REGULATOR_RK860X
+	bool "Enable driver for rk860x regulators"
+	depends on DM_REGULATOR
+	---help---
+	Enable support for the regulator functions of the rk860x DCDC. The
+	driver implements get/set api for the various BUCK.This driver is
+	controlled by a device tree node which includes voltage limits.
+
 config REGULATOR_RK8XX
 	bool "Enable driver for RK8XX regulators"
 	depends on DM_REGULATOR && PMIC_RK8XX
@@ -94,6 +117,15 @@ config REGULATOR_RK8XX
 	by the PMIC device. This driver is controlled by a device tree node
 	which includes voltage limits.
 
+config REGULATOR_RK806
+        bool "Enable driver for RK8XX regulators"
+        depends on DM_REGULATOR && PMIC_SPI_RK8XX
+        ---help---
+        Enable support for the regulator functions of the RK806 PMIC. The
+        driver implements get/set api for the various BUCKS and LDOs supported
+        by the PMIC device. This driver is controlled by a device tree node
+        which includes voltage limits
+
 config REGULATOR_S5M8767
 	bool "Enable support for S5M8767 regulator"
 	depends on DM_REGULATOR && PMIC_S5M8767
diff --git a/drivers/power/regulator/Makefile b/drivers/power/regulator/Makefile
index 18fb870e43..73671aa8bd 100644
--- a/drivers/power/regulator/Makefile
+++ b/drivers/power/regulator/Makefile
@@ -11,9 +11,12 @@ obj-$(CONFIG_REGULATOR_AS3722)	+= as3722_regulator.o
 obj-$(CONFIG_DM_REGULATOR_MAX77686) += max77686.o
 obj-$(CONFIG_DM_REGULATOR_PFUZE100) += pfuze100.o
 obj-$(CONFIG_REGULATOR_PWM) += pwm_regulator.o
+obj-$(CONFIG_REGULATOR_FAN53555) += fan53555_regulator.o
 obj-$(CONFIG_$(SPL_)DM_REGULATOR_FIXED) += fixed.o
 obj-$(CONFIG_$(SPL_)DM_REGULATOR_GPIO) += gpio-regulator.o
+obj-$(CONFIG_REGULATOR_RK860X) += rk860x_regulator.o
 obj-$(CONFIG_REGULATOR_RK8XX) += rk8xx.o
+obj-$(CONFIG_REGULATOR_RK806) += rk806.o
 obj-$(CONFIG_REGULATOR_S5M8767) += s5m8767.o
 obj-$(CONFIG_DM_REGULATOR_SANDBOX) += sandbox.o
 obj-$(CONFIG_REGULATOR_TPS65090) += tps65090_regulator.o
diff --git a/drivers/power/regulator/fixed.c b/drivers/power/regulator/fixed.c
index 35c292222b..c35ca2a18e 100644
--- a/drivers/power/regulator/fixed.c
+++ b/drivers/power/regulator/fixed.c
@@ -36,8 +36,9 @@ static int fixed_regulator_ofdata_to_platdata(struct udevice *dev)
 
 	/* Set type to fixed */
 	uc_pdata->type = REGULATOR_TYPE_FIXED;
-
-	if (dev_read_bool(dev, "enable-active-high"))
+	if (!dev_read_bool(dev, "enable-active-high"))
+		flags |= GPIOD_ACTIVE_LOW;
+	if (dev_read_bool(dev, "regulator-boot-on"))
 		flags |= GPIOD_IS_OUT_ACTIVE;
 
 	/* Get fixed regulator optional enable GPIO desc */
@@ -117,7 +118,7 @@ static int fixed_regulator_set_enable(struct udevice *dev, bool enable)
 
 	ret = dm_gpio_set_value(&dev_pdata->gpio, enable);
 	if (ret) {
-		error("Can't set regulator : %s gpio to: %d\n", dev->name,
+		pr_err("Can't set regulator : %s gpio to: %d\n", dev->name,
 		      enable);
 		return ret;
 	}
diff --git a/drivers/power/regulator/gpio-regulator.c b/drivers/power/regulator/gpio-regulator.c
index 42391c69b4..c73c2ae12a 100644
--- a/drivers/power/regulator/gpio-regulator.c
+++ b/drivers/power/regulator/gpio-regulator.c
@@ -29,9 +29,7 @@ static int gpio_regulator_ofdata_to_platdata(struct udevice *dev)
 	struct dm_regulator_uclass_platdata *uc_pdata;
 	struct gpio_regulator_platdata *dev_pdata;
 	struct gpio_desc *gpio;
-	const void *blob = gd->fdt_blob;
-	int node = dev_of_offset(dev);
-	int ret, count, i, j;
+	int ret, len, i, j;
 	u32 states_array[8];
 
 	dev_pdata = dev_get_platdata(dev);
@@ -54,13 +52,17 @@ static int gpio_regulator_ofdata_to_platdata(struct udevice *dev)
 	if (ret)
 		debug("regulator gpio - not found! Error: %d", ret);
 
-	count = fdtdec_get_int_array_count(blob, node, "states",
-					   states_array, 8);
+	len = dev_read_size(dev, "states");
+	if (len < 0)
+		return len;
 
-	if (!count)
+	len /= sizeof(fdt32_t);
+
+	ret = dev_read_u32_array(dev, "states", states_array, len);
+	if (ret)
 		return -EINVAL;
 
-	for (i = 0, j = 0; i < count; i += 2) {
+	for (i = 0, j = 0; i < len; i += 2) {
 		dev_pdata->voltages[j] = states_array[i];
 		dev_pdata->states[j] = states_array[i + 1];
 		j++;
@@ -109,7 +111,7 @@ static int gpio_regulator_set_value(struct udevice *dev, int uV)
 
 	ret = dm_gpio_set_value(&dev_pdata->gpio, enable);
 	if (ret) {
-		error("Can't set regulator : %s gpio to: %d\n", dev->name,
+		pr_err("Can't set regulator : %s gpio to: %d\n", dev->name,
 		      enable);
 		return ret;
 	}
diff --git a/drivers/power/regulator/max77686.c b/drivers/power/regulator/max77686.c
index 8780806cff..2212d36ed6 100644
--- a/drivers/power/regulator/max77686.c
+++ b/drivers/power/regulator/max77686.c
@@ -98,7 +98,7 @@ static int max77686_buck_volt2hex(int buck, int uV)
 	if (hex >= 0 && hex <= hex_max)
 		return hex;
 
-	error("Value: %d uV is wrong for BUCK%d", uV, buck);
+	pr_err("Value: %d uV is wrong for BUCK%d", uV, buck);
 	return -EINVAL;
 }
 
@@ -134,7 +134,7 @@ static int max77686_buck_hex2volt(int buck, int hex)
 	return uV;
 
 bad_hex:
-	error("Value: %#x is wrong for BUCK%d", hex, buck);
+	pr_err("Value: %#x is wrong for BUCK%d", hex, buck);
 	return -EINVAL;
 }
 
@@ -160,7 +160,7 @@ static int max77686_ldo_volt2hex(int ldo, int uV)
 	if (hex >= 0 && hex <= MAX77686_LDO_VOLT_MAX_HEX)
 		return hex;
 
-	error("Value: %d uV is wrong for LDO%d", uV, ldo);
+	pr_err("Value: %d uV is wrong for LDO%d", uV, ldo);
 	return -EINVAL;
 }
 
@@ -189,7 +189,7 @@ static int max77686_ldo_hex2volt(int ldo, int hex)
 	return uV;
 
 bad_hex:
-	error("Value: %#x is wrong for ldo%d", hex, ldo);
+	pr_err("Value: %#x is wrong for ldo%d", hex, ldo);
 	return -EINVAL;
 }
 
@@ -328,7 +328,7 @@ static int max77686_ldo_val(struct udevice *dev, int op, int *uV)
 
 	ldo = dev->driver_data;
 	if (ldo < 1 || ldo > MAX77686_LDO_NUM) {
-		error("Wrong ldo number: %d", ldo);
+		pr_err("Wrong ldo number: %d", ldo);
 		return -EINVAL;
 	}
 
@@ -366,7 +366,7 @@ static int max77686_buck_val(struct udevice *dev, int op, int *uV)
 
 	buck = dev->driver_data;
 	if (buck < 1 || buck > MAX77686_BUCK_NUM) {
-		error("Wrong buck number: %d", buck);
+		pr_err("Wrong buck number: %d", buck);
 		return -EINVAL;
 	}
 
@@ -423,7 +423,7 @@ static int max77686_ldo_mode(struct udevice *dev, int op, int *opmode)
 
 	ldo = dev->driver_data;
 	if (ldo < 1 || ldo > MAX77686_LDO_NUM) {
-		error("Wrong ldo number: %d", ldo);
+		pr_err("Wrong ldo number: %d", ldo);
 		return -EINVAL;
 	}
 
@@ -493,7 +493,7 @@ static int max77686_ldo_mode(struct udevice *dev, int op, int *opmode)
 	}
 
 	if (mode == 0xff) {
-		error("Wrong mode: %d for ldo%d", *opmode, ldo);
+		pr_err("Wrong mode: %d for ldo%d", *opmode, ldo);
 		return -EINVAL;
 	}
 
@@ -545,7 +545,7 @@ static int max77686_buck_mode(struct udevice *dev, int op, int *opmode)
 
 	buck = dev->driver_data;
 	if (buck < 1 || buck > MAX77686_BUCK_NUM) {
-		error("Wrong buck number: %d", buck);
+		pr_err("Wrong buck number: %d", buck);
 		return -EINVAL;
 	}
 
@@ -614,7 +614,7 @@ static int max77686_buck_mode(struct udevice *dev, int op, int *opmode)
 	}
 
 	if (mode == 0xff) {
-		error("Wrong mode: %d for buck: %d\n", *opmode, buck);
+		pr_err("Wrong mode: %d for buck: %d\n", *opmode, buck);
 		return -EINVAL;
 	}
 
diff --git a/drivers/power/regulator/pwm_regulator.c b/drivers/power/regulator/pwm_regulator.c
index b63f941990..4582737fe1 100644
--- a/drivers/power/regulator/pwm_regulator.c
+++ b/drivers/power/regulator/pwm_regulator.c
@@ -13,7 +13,7 @@
 #include <errno.h>
 #include <pwm.h>
 #include <power/regulator.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #include <fdtdec.h>
 
@@ -94,13 +94,10 @@ static int pwm_regulator_set_voltage(struct udevice *dev, int uvolt)
 static int pwm_regulator_ofdata_to_platdata(struct udevice *dev)
 {
 	struct pwm_regulator_info *priv = dev_get_priv(dev);
-	struct fdtdec_phandle_args args;
-	const void *blob = gd->fdt_blob;
-	int node = dev_of_offset(dev);
+	struct ofnode_phandle_args args;
 	int ret;
 
-	ret = fdtdec_parse_phandle_with_args(blob, node, "pwms", "#pwm-cells",
-					     0, 0, &args);
+	ret = dev_read_phandle_with_args(dev, "pwms", "#pwm-cells", 0, 0, &args);
 	if (ret) {
 		debug("%s: Cannot get PWM phandle: ret=%d\n", __func__, ret);
 		return ret;
@@ -109,14 +106,19 @@ static int pwm_regulator_ofdata_to_platdata(struct udevice *dev)
 	priv->period_ns = args.args[1];
 	priv->polarity = args.args[2];
 
-	priv->init_voltage = fdtdec_get_int(blob, node,
-			"regulator-init-microvolt", -1);
+	priv->init_voltage = dev_read_u32_default(dev, "regulator-init-microvolt", -1);
 	if (priv->init_voltage < 0) {
-		printf("Cannot find regulator pwm init_voltage\n");
-		return -EINVAL;
+		debug("Cannot find 'regulator-init-microvolt'\n");
+
+		/*
+		 * 1. Compatible legacy pwm-regulator driver on rkdevelop;
+		 * 2. Give pwm-regulator default init voltage 1.1v;
+		 */
+		priv->init_voltage = dev_read_u32_default(dev, "rockchip,pwm_voltage",
+							  1100000);
 	}
 
-	ret = uclass_get_device_by_of_offset(UCLASS_PWM, args.node, &priv->pwm);
+	ret = uclass_get_device_by_ofnode(UCLASS_PWM, args.node, &priv->pwm);
 	if (ret) {
 		debug("%s: Cannot get PWM: ret=%d\n", __func__, ret);
 		return ret;
@@ -137,8 +139,11 @@ static int pwm_regulator_probe(struct udevice *dev)
 	priv->max_voltage = uc_pdata->max_uV;
 	priv->min_voltage = uc_pdata->min_uV;
 
-	if (priv->init_voltage)
+	if (priv->init_voltage > 0) {
+		debug("pwm-regulator(%s): init %d uV\n",
+		       dev->name, priv->init_voltage);
 		pwm_regulator_set_voltage(dev, priv->init_voltage);
+	}
 
 	return 0;
 }
diff --git a/drivers/power/regulator/regulator-uclass.c b/drivers/power/regulator/regulator-uclass.c
index 426a933d66..4679249b38 100644
--- a/drivers/power/regulator/regulator-uclass.c
+++ b/drivers/power/regulator/regulator-uclass.c
@@ -8,6 +8,7 @@
 #include <common.h>
 #include <errno.h>
 #include <dm.h>
+#include <dm/device-internal.h>
 #include <dm/uclass-internal.h>
 #include <power/pmic.h>
 #include <power/regulator.h>
@@ -42,6 +43,8 @@ int regulator_set_value(struct udevice *dev, int uV)
 {
 	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
 	struct dm_regulator_uclass_platdata *uc_pdata;
+	u32 old_uV = -ENODATA, us;
+	int ret;
 
 	uc_pdata = dev_get_uclass_platdata(dev);
 	if (uc_pdata->min_uV != -ENODATA && uV < uc_pdata->min_uV)
@@ -52,7 +55,44 @@ int regulator_set_value(struct udevice *dev, int uV)
 	if (!ops || !ops->set_value)
 		return -ENOSYS;
 
-	return ops->set_value(dev, uV);
+	if (uc_pdata->ramp_delay != -ENODATA) {
+		if (!ops->get_value)
+			return -ENOSYS;
+		old_uV = ops->get_value(dev);
+		if (old_uV < 0)
+			return -EINVAL;
+	}
+
+	ret = ops->set_value(dev, uV);
+
+	if (!ret && (old_uV != -ENODATA) && (old_uV != uV)) {
+		us = DIV_ROUND_UP(abs(uV - old_uV), uc_pdata->ramp_delay);
+		udelay(us);
+		debug("%s: ramp=%d, old_uV=%d, uV=%d, us=%d\n",
+		      uc_pdata->name, uc_pdata->ramp_delay, old_uV, uV, us);
+	}
+
+	return ret;
+}
+
+int regulator_set_suspend_value(struct udevice *dev, int uV)
+{
+	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->set_suspend_value)
+		return -ENOSYS;
+
+	return ops->set_suspend_value(dev, uV);
+}
+
+int regulator_get_suspend_value(struct udevice *dev)
+{
+	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->get_suspend_value)
+		return -ENOSYS;
+
+	return ops->get_suspend_value(dev);
 }
 
 /*
@@ -116,6 +156,36 @@ int regulator_set_enable(struct udevice *dev, bool enable)
 	return ops->set_enable(dev, enable);
 }
 
+int regulator_set_suspend_enable(struct udevice *dev, bool enable)
+{
+	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->set_suspend_enable)
+		return -ENOSYS;
+
+	return ops->set_suspend_enable(dev, enable);
+}
+
+int regulator_get_suspend_enable(struct udevice *dev)
+{
+	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->get_suspend_enable)
+		return -ENOSYS;
+
+	return ops->get_suspend_enable(dev);
+}
+
+int regulator_set_ramp_delay(struct udevice *dev, u32 ramp_delay)
+{
+	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->set_ramp_delay)
+		return -ENOSYS;
+
+	return ops->set_ramp_delay(dev, ramp_delay);
+}
+
 int regulator_get_mode(struct udevice *dev)
 {
 	const struct dm_regulator_ops *ops = dev_get_driver_ops(dev);
@@ -175,17 +245,54 @@ int device_get_supply_regulator(struct udevice *dev, const char *supply_name,
 					    supply_name, devp);
 }
 
+static int regulator_init_suspend(struct udevice *dev)
+{
+	struct dm_regulator_uclass_platdata *uc_pdata;
+	int ret;
+
+	uc_pdata = dev_get_uclass_platdata(dev);
+
+	ret = regulator_set_suspend_enable(dev, uc_pdata->suspend_on);
+	if (!ret && uc_pdata->suspend_on)
+		return regulator_set_suspend_value(dev, uc_pdata->suspend_uV);
+
+	return 0;
+}
+
 int regulator_autoset(struct udevice *dev)
 {
 	struct dm_regulator_uclass_platdata *uc_pdata;
 	int ret = 0;
 
 	uc_pdata = dev_get_uclass_platdata(dev);
+
+	if (uc_pdata->ignore)
+		return ret;
+
+	if (uc_pdata->ramp_delay != -ENODATA)
+		regulator_set_ramp_delay(dev, uc_pdata->ramp_delay);
+
 	if (!uc_pdata->always_on && !uc_pdata->boot_on)
 		return -EMEDIUMTYPE;
 
-	if (uc_pdata->flags & REGULATOR_FLAG_AUTOSET_UV)
+	if (uc_pdata->flags & REGULATOR_FLAG_AUTOSET_UV) {
 		ret = regulator_set_value(dev, uc_pdata->min_uV);
+	} else {
+		if ((uc_pdata->type == REGULATOR_TYPE_BUCK) &&
+		    (uc_pdata->min_uV != -ENODATA) &&
+		    (uc_pdata->max_uV != -ENODATA) &&
+		    (uc_pdata->init_uV <= 0))
+			printf("%s %d uV\n",
+			       uc_pdata->name, regulator_get_value(dev));
+	}
+
+	if (uc_pdata->init_uV > 0) {
+		ret = regulator_set_value(dev, uc_pdata->init_uV);
+		if (!ret)
+			printf("%s init %d uV\n",
+			       uc_pdata->name, uc_pdata->init_uV);
+	}
+
 	if (!ret && (uc_pdata->flags & REGULATOR_FLAG_AUTOSET_UA))
 		ret = regulator_set_current(dev, uc_pdata->min_uA);
 
@@ -198,17 +305,26 @@ int regulator_autoset(struct udevice *dev)
 static void regulator_show(struct udevice *dev, int ret)
 {
 	struct dm_regulator_uclass_platdata *uc_pdata;
+	int uV = 0;
 
 	uc_pdata = dev_get_uclass_platdata(dev);
+	uV = regulator_get_value(dev);
+
+	printf("%25s@%15s: ", dev->name, uc_pdata->name);
+	printf("%7duV <-> %7duV, set %7duV, %s",
+	       uc_pdata->min_uV, uc_pdata->max_uV, uV,
+	       (uc_pdata->always_on || uc_pdata->boot_on) ?
+	       "enabling" : "disabled");
+
+	printf(" | supsend %7duV, %s",
+	       uc_pdata->suspend_uV,
+	       uc_pdata->suspend_on ? "enabling" : "disabled");
+	if (uc_pdata->init_uV != -ENODATA)
+		printf(" ; init %7duV", uc_pdata->init_uV);
 
-	printf("%s@%s: ", dev->name, uc_pdata->name);
-	if (uc_pdata->flags & REGULATOR_FLAG_AUTOSET_UV)
-		printf("set %d uV", uc_pdata->min_uV);
-	if (uc_pdata->flags & REGULATOR_FLAG_AUTOSET_UA)
-		printf("; set %d uA", uc_pdata->min_uA);
-	printf("; enabling");
 	if (ret)
 		printf(" (ret: %d)", ret);
+
 	printf("\n");
 }
 
@@ -297,15 +413,22 @@ static int regulator_post_bind(struct udevice *dev)
 	if (regulator_name_is_unique(dev, uc_pdata->name))
 		return 0;
 
+#ifdef CONFIG_USING_KERNEL_DTB
+	printf("Pre-reloc: %s\n", uc_pdata->name);
+
+	return 0;
+#else
 	debug("'%s' of dev: '%s', has nonunique value: '%s\n",
 	      property, dev->name, uc_pdata->name);
 
 	return -EINVAL;
+#endif
 }
 
 static int regulator_pre_probe(struct udevice *dev)
 {
 	struct dm_regulator_uclass_platdata *uc_pdata;
+	ofnode node;
 
 	uc_pdata = dev_get_uclass_platdata(dev);
 	if (!uc_pdata)
@@ -316,12 +439,26 @@ static int regulator_pre_probe(struct udevice *dev)
 						-ENODATA);
 	uc_pdata->max_uV = dev_read_u32_default(dev, "regulator-max-microvolt",
 						-ENODATA);
+	uc_pdata->init_uV = dev_read_u32_default(dev, "regulator-init-microvolt",
+						-ENODATA);
 	uc_pdata->min_uA = dev_read_u32_default(dev, "regulator-min-microamp",
 						-ENODATA);
 	uc_pdata->max_uA = dev_read_u32_default(dev, "regulator-max-microamp",
 						-ENODATA);
 	uc_pdata->always_on = dev_read_bool(dev, "regulator-always-on");
 	uc_pdata->boot_on = dev_read_bool(dev, "regulator-boot-on");
+	uc_pdata->ignore = dev_read_bool(dev, "regulator-loader-ignore");
+	uc_pdata->ramp_delay = dev_read_u32_default(dev, "regulator-ramp-delay",
+						    -ENODATA);
+	node = dev_read_subnode(dev, "regulator-state-mem");
+	if (ofnode_valid(node)) {
+		uc_pdata->suspend_on = !ofnode_read_bool(node, "regulator-off-in-suspend");
+		if (ofnode_read_u32(node, "regulator-suspend-microvolt", &uc_pdata->suspend_uV))
+			uc_pdata->suspend_uV = uc_pdata->max_uA;
+	} else {
+		uc_pdata->suspend_on = true;
+		uc_pdata->suspend_uV = uc_pdata->max_uA;
+	}
 
 	/* Those values are optional (-ENODATA if unset) */
 	if ((uc_pdata->min_uV != -ENODATA) &&
@@ -335,9 +472,123 @@ static int regulator_pre_probe(struct udevice *dev)
 	    (uc_pdata->min_uA == uc_pdata->max_uA))
 		uc_pdata->flags |= REGULATOR_FLAG_AUTOSET_UA;
 
+	debug("dev.name=%s: min_uV=%d, max_uV=%d, boot-on=%d, always-on=%d, "
+	      "off-in-suspend=%d, suspend_volt=%d\n",
+	      dev->name, uc_pdata->min_uV, uc_pdata->max_uV, uc_pdata->boot_on,
+	      uc_pdata->always_on, !uc_pdata->suspend_on, uc_pdata->suspend_uV);
+
 	return 0;
 }
 
+int regulators_enable_state_mem(bool verbose)
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret;
+
+	ret = uclass_get(UCLASS_REGULATOR, &uc);
+	if (ret)
+		return ret;
+	for (uclass_first_device(UCLASS_REGULATOR, &dev);
+	     dev;
+	     uclass_next_device(&dev)) {
+		ret = regulator_init_suspend(dev);
+
+		if (ret == -EMEDIUMTYPE)
+			ret = 0;
+		if (verbose)
+			regulator_show(dev, ret);
+		if (ret == -ENOSYS)
+			ret = 0;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_USING_KERNEL_DTB
+/*
+ * Skip probed pre-reloc regulators.
+ *
+ * Some regulator like fixed/gpio regultor applies a default output state
+ * when probed. It maybe reverse the state which was set by the pre-reloc
+ * regulator. Example: vcc3v3_pcie.
+ */
+int regulators_enable_boot_on(bool verbose)
+{
+	struct dm_regulator_uclass_platdata *uc_pdata;
+	struct udevice *dev;
+	struct uclass *uc;
+	char **pre_probed = NULL;
+	int i = 0, num = 0;
+	int ret;
+	bool skip;
+
+	ret = uclass_get(UCLASS_REGULATOR, &uc);
+	if (ret)
+		return ret;
+
+	/* find probed pre-reloc regulators */
+	for (uclass_find_first_device(UCLASS_REGULATOR, &dev);
+	     dev;
+	     uclass_find_next_device(&dev)) {
+		if (!(dev->flags & DM_FLAG_KNRL_DTB) &&
+		    (dev->flags & DM_FLAG_ACTIVATED))
+			num++;
+	}
+	if (num) {
+		pre_probed = calloc(num, sizeof(char *));
+		if (!pre_probed)
+			return -ENOMEM;
+
+		for (uclass_find_first_device(UCLASS_REGULATOR, &dev);
+		     dev;
+		     uclass_find_next_device(&dev)) {
+			if (!(dev->flags & DM_FLAG_KNRL_DTB) &&
+			    (dev->flags & DM_FLAG_ACTIVATED)) {
+				uc_pdata = dev_get_uclass_platdata(dev);
+				pre_probed[i++] = (char *)uc_pdata->name;
+			}
+		}
+	}
+
+	/* Skip kernel regulators whose name matches probed pre-reloc regulators */
+	for (uclass_find_first_device(UCLASS_REGULATOR, &dev);
+	     dev;
+	     uclass_find_next_device(&dev)) {
+		uc_pdata = dev_get_uclass_platdata(dev);
+		debug("%s: %s%s\n", __func__, uc_pdata->name,
+		      dev->flags & DM_FLAG_KNRL_DTB ? "" : "*");
+		if (dev->flags & DM_FLAG_KNRL_DTB) {
+			for (i = 0, skip = false; i < num; i++) {
+				if (!strcmp(pre_probed[i], uc_pdata->name)) {
+					skip = true;
+					break;
+				}
+			}
+			if (skip)
+				continue;
+		}
+
+		/* Probe and init */
+		ret = device_probe(dev);
+		if (ret)
+			continue;
+		ret = regulator_autoset(dev);
+		if (ret == -EMEDIUMTYPE)
+			ret = 0;
+		if (verbose)
+			regulator_show(dev, ret);
+		if (ret == -ENOSYS)
+			ret = 0;
+	}
+
+	if (pre_probed)
+		free(pre_probed);
+
+	return ret;
+}
+
+#else
 int regulators_enable_boot_on(bool verbose)
 {
 	struct udevice *dev;
@@ -351,10 +602,9 @@ int regulators_enable_boot_on(bool verbose)
 	     dev;
 	     uclass_next_device(&dev)) {
 		ret = regulator_autoset(dev);
-		if (ret == -EMEDIUMTYPE) {
+
+		if (ret == -EMEDIUMTYPE)
 			ret = 0;
-			continue;
-		}
 		if (verbose)
 			regulator_show(dev, ret);
 		if (ret == -ENOSYS)
@@ -363,6 +613,7 @@ int regulators_enable_boot_on(bool verbose)
 
 	return ret;
 }
+#endif
 
 UCLASS_DRIVER(regulator) = {
 	.id		= UCLASS_REGULATOR,
diff --git a/drivers/power/regulator/rk8xx.c b/drivers/power/regulator/rk8xx.c
index 76fc2eff60..4205a477ab 100644
--- a/drivers/power/regulator/rk8xx.c
+++ b/drivers/power/regulator/rk8xx.c
@@ -20,6 +20,9 @@
 #define ENABLE_DRIVER
 #endif
 
+/* Not used or exisit register and configure */
+#define NA			-1
+
 /* Field Definitions */
 #define RK808_BUCK_VSEL_MASK	0x3f
 #define RK808_BUCK4_VSEL_MASK	0xf
@@ -33,49 +36,178 @@
 #define RK818_USB_ILIM_SEL_MASK		0x0f
 #define RK818_USB_CHG_SD_VSEL_MASK	0x70
 
+/* RK809 BUCK5 */
+#define RK809_BUCK5_CONFIG(n)		(0xde + (n) * 1)
+#define RK809_BUCK5_VSEL_MASK		0x07
+
+/* RK817 BUCK */
+#define RK817_BUCK_ON_VSEL(n)		(0xbb + 3 * (n - 1))
+#define RK817_BUCK_SLP_VSEL(n)		(0xbc + 3 * (n - 1))
+#define RK817_BUCK_VSEL_MASK		0x7f
+#define RK817_BUCK_CONFIG(i)		(0xba + (i) * 3)
+
+/* RK817 LDO */
+#define RK817_LDO_ON_VSEL(n)		(0xcc + 2 * (n - 1))
+#define RK817_LDO_SLP_VSEL(n)		(0xcd + 2 * (n - 1))
+#define RK817_LDO_VSEL_MASK		0x7f
+
+/* RK817 ENABLE */
+#define RK817_POWER_EN(n)		(0xb1 + (n))
+#define RK817_POWER_SLP_EN(n)		(0xb5 + (n))
+
+/*
+ * Ramp delay
+ */
+#define RK805_RAMP_RATE_OFFSET		3
+#define RK805_RAMP_RATE_MASK		(3 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_3MV_PER_US	(0 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_6MV_PER_US	(1 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_12_5MV_PER_US	(2 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_25MV_PER_US	(3 << RK805_RAMP_RATE_OFFSET)
+
+#define RK808_RAMP_RATE_OFFSET		3
+#define RK808_RAMP_RATE_MASK		(3 << RK808_RAMP_RATE_OFFSET)
+#define RK808_RAMP_RATE_2MV_PER_US	(0 << RK808_RAMP_RATE_OFFSET)
+#define RK808_RAMP_RATE_4MV_PER_US	(1 << RK808_RAMP_RATE_OFFSET)
+#define RK808_RAMP_RATE_6MV_PER_US	(2 << RK808_RAMP_RATE_OFFSET)
+#define RK808_RAMP_RATE_10MV_PER_US	(3 << RK808_RAMP_RATE_OFFSET)
+
+#define RK817_RAMP_RATE_OFFSET		6
+#define RK817_RAMP_RATE_MASK		(0x3 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_3MV_PER_US	(0x0 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_6_3MV_PER_US	(0x1 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_12_5MV_PER_US	(0x2 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_25MV_PER_US	(0x3 << RK817_RAMP_RATE_OFFSET)
 
 struct rk8xx_reg_info {
 	uint min_uv;
 	uint step_uv;
-	s8 vsel_reg;
+	u8 vsel_reg;
+	u8 vsel_sleep_reg;
+	u8 config_reg;
 	u8 vsel_mask;
+	u8 min_sel;
+	/* only for buck now */
+	u8 max_sel;
+	u8 range_num;
 };
 
 static const struct rk8xx_reg_info rk808_buck[] = {
-	{ 712500, 12500, REG_BUCK1_ON_VSEL, RK808_BUCK_VSEL_MASK, },
-	{ 712500, 12500, REG_BUCK2_ON_VSEL, RK808_BUCK_VSEL_MASK, },
-	{ 712500, 12500, -1, RK808_BUCK_VSEL_MASK, },
-	{ 1800000, 100000, REG_BUCK4_ON_VSEL, RK808_BUCK4_VSEL_MASK, },
+	{ 712500,   12500, REG_BUCK1_ON_VSEL, REG_BUCK1_SLP_VSEL, REG_BUCK1_CONFIG, RK808_BUCK_VSEL_MASK, 0x00, 0x3f, 1},
+	{ 712500,   12500, REG_BUCK2_ON_VSEL, REG_BUCK2_SLP_VSEL, REG_BUCK2_CONFIG, RK808_BUCK_VSEL_MASK, 0x00, 0x3f, 1},
+	{ NA,       NA,    NA,		      NA,		  REG_BUCK3_CONFIG, NA,                   NA,   NA,   1},
+	{ 1800000, 100000, REG_BUCK4_ON_VSEL, REG_BUCK4_SLP_VSEL, REG_BUCK4_CONFIG, RK808_BUCK4_VSEL_MASK,0x00, 0x0f, 1},
+};
+
+static const struct rk8xx_reg_info rk816_buck[] = {
+	/* buck 1 */
+	{  712500,  12500, REG_BUCK1_ON_VSEL, REG_BUCK1_SLP_VSEL, REG_BUCK1_CONFIG, RK818_BUCK_VSEL_MASK, 0x00, 0x3b, 3},
+	{ 1800000, 200000, REG_BUCK1_ON_VSEL, REG_BUCK1_SLP_VSEL, REG_BUCK1_CONFIG, RK818_BUCK_VSEL_MASK, 0x3c, 0x3e, 3},
+	{ 2300000,      0, REG_BUCK1_ON_VSEL, REG_BUCK1_SLP_VSEL, REG_BUCK1_CONFIG, RK818_BUCK_VSEL_MASK, 0x3f, 0x3f, 3},
+	/* buck 2 */
+	{  712500,  12500, REG_BUCK2_ON_VSEL, REG_BUCK2_SLP_VSEL, REG_BUCK2_CONFIG, RK818_BUCK_VSEL_MASK, 0x00, 0x3b, 3},
+	{ 1800000, 200000, REG_BUCK2_ON_VSEL, REG_BUCK2_SLP_VSEL, REG_BUCK2_CONFIG, RK818_BUCK_VSEL_MASK, 0x3c, 0x3e, 3},
+	{ 2300000,      0, REG_BUCK2_ON_VSEL, REG_BUCK2_SLP_VSEL, REG_BUCK2_CONFIG, RK818_BUCK_VSEL_MASK, 0x3f, 0x3f, 3},
+	/* buck 3 */
+	{  NA,     NA,     NA,		      NA,		  REG_BUCK3_CONFIG, NA,                   NA,   NA,   1},
+	/* buck 4 */
+	{  800000, 100000, REG_BUCK4_ON_VSEL, REG_BUCK4_SLP_VSEL, REG_BUCK4_CONFIG, RK818_BUCK4_VSEL_MASK,0x00, 0x1b, 1},
+};
+
+static const struct rk8xx_reg_info rk809_buck5[] = {
+	/* buck 5 */
+	{ 1500000,	0, RK809_BUCK5_CONFIG(0), RK809_BUCK5_CONFIG(1), NA, RK809_BUCK5_VSEL_MASK, 0x00, 0x00, 4},
+	{ 1800000, 200000, RK809_BUCK5_CONFIG(0), RK809_BUCK5_CONFIG(1), NA, RK809_BUCK5_VSEL_MASK, 0x01, 0x03, 4},
+	{ 2800000, 200000, RK809_BUCK5_CONFIG(0), RK809_BUCK5_CONFIG(1), NA, RK809_BUCK5_VSEL_MASK, 0x04, 0x05, 4},
+	{ 3300000, 300000, RK809_BUCK5_CONFIG(0), RK809_BUCK5_CONFIG(1), NA, RK809_BUCK5_VSEL_MASK, 0x06, 0x07, 4},
+};
+
+static const struct rk8xx_reg_info rk817_buck[] = {
+	/* buck 1 */
+	{  500000,  12500, RK817_BUCK_ON_VSEL(1), RK817_BUCK_SLP_VSEL(1), RK817_BUCK_CONFIG(1), RK817_BUCK_VSEL_MASK, 0x00, 0x4f, 3},
+	{ 1500000, 100000, RK817_BUCK_ON_VSEL(1), RK817_BUCK_SLP_VSEL(1), RK817_BUCK_CONFIG(1), RK817_BUCK_VSEL_MASK, 0x50, 0x58, 3},
+	{ 2400000,	0, RK817_BUCK_ON_VSEL(1), RK817_BUCK_SLP_VSEL(1), RK817_BUCK_CONFIG(1), RK817_BUCK_VSEL_MASK, 0x59, 0x59, 3},
+	/* buck 2 */
+	{  500000,  12500, RK817_BUCK_ON_VSEL(2), RK817_BUCK_SLP_VSEL(2), RK817_BUCK_CONFIG(2), RK817_BUCK_VSEL_MASK, 0x00, 0x4f, 3},
+	{ 1500000, 100000, RK817_BUCK_ON_VSEL(2), RK817_BUCK_SLP_VSEL(2), RK817_BUCK_CONFIG(2), RK817_BUCK_VSEL_MASK, 0x50, 0x58, 3},
+	{ 2400000,	0, RK817_BUCK_ON_VSEL(2), RK817_BUCK_SLP_VSEL(2), RK817_BUCK_CONFIG(2), RK817_BUCK_VSEL_MASK, 0x59, 0x59, 3},
+	/* buck 3 */
+	{  500000,  12500, RK817_BUCK_ON_VSEL(3), RK817_BUCK_SLP_VSEL(3), RK817_BUCK_CONFIG(3), RK817_BUCK_VSEL_MASK, 0x00, 0x4f, 3},
+	{ 1500000, 100000, RK817_BUCK_ON_VSEL(3), RK817_BUCK_SLP_VSEL(3), RK817_BUCK_CONFIG(3), RK817_BUCK_VSEL_MASK, 0x50, 0x58, 3},
+	{ 2400000,	0, RK817_BUCK_ON_VSEL(3), RK817_BUCK_SLP_VSEL(3), RK817_BUCK_CONFIG(3), RK817_BUCK_VSEL_MASK, 0x59, 0x59, 3},
+	/* buck 4 */
+	{  500000,  12500, RK817_BUCK_ON_VSEL(4), RK817_BUCK_SLP_VSEL(4), RK817_BUCK_CONFIG(4), RK817_BUCK_VSEL_MASK, 0x00, 0x4f, 3},
+	{ 1500000, 100000, RK817_BUCK_ON_VSEL(4), RK817_BUCK_SLP_VSEL(4), RK817_BUCK_CONFIG(4), RK817_BUCK_VSEL_MASK, 0x50, 0x62, 3},
+	{ 3400000,	0, RK817_BUCK_ON_VSEL(4), RK817_BUCK_SLP_VSEL(4), RK817_BUCK_CONFIG(4), RK817_BUCK_VSEL_MASK, 0x63, 0x63, 3},
 };
 
 static const struct rk8xx_reg_info rk818_buck[] = {
-	{ 712500, 12500, REG_BUCK1_ON_VSEL, RK818_BUCK_VSEL_MASK, },
-	{ 712500, 12500, REG_BUCK2_ON_VSEL, RK818_BUCK_VSEL_MASK, },
-	{ 712500, 12500, -1, RK818_BUCK_VSEL_MASK, },
-	{ 1800000, 100000, REG_BUCK4_ON_VSEL, RK818_BUCK4_VSEL_MASK, },
+	{ 712500,   12500, REG_BUCK1_ON_VSEL, REG_BUCK1_SLP_VSEL, REG_BUCK1_CONFIG, RK818_BUCK_VSEL_MASK, 0x00, 0x3f, 1},
+	{ 712500,   12500, REG_BUCK2_ON_VSEL, REG_BUCK2_SLP_VSEL, REG_BUCK2_CONFIG, RK818_BUCK_VSEL_MASK, 0x00, 0x3f, 1},
+	{ NA,       NA,    NA,		      NA,		  REG_BUCK3_CONFIG, NA,                   NA,   NA,   1},
+	{ 1800000, 100000, REG_BUCK4_ON_VSEL, REG_BUCK4_SLP_VSEL, REG_BUCK4_CONFIG, RK818_BUCK4_VSEL_MASK,0x00, 0x10, 1},
 };
 
 #ifdef ENABLE_DRIVER
 static const struct rk8xx_reg_info rk808_ldo[] = {
-	{ 1800000, 100000, REG_LDO1_ON_VSEL, RK808_LDO_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO2_ON_VSEL, RK808_LDO_VSEL_MASK, },
-	{ 800000, 100000, REG_LDO3_ON_VSEL, RK808_BUCK4_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO4_ON_VSEL, RK808_LDO_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO5_ON_VSEL, RK808_LDO_VSEL_MASK, },
-	{ 800000, 100000, REG_LDO6_ON_VSEL, RK808_LDO_VSEL_MASK, },
-	{ 800000, 100000, REG_LDO7_ON_VSEL, RK808_LDO_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO8_ON_VSEL, RK808_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO1_ON_VSEL, REG_LDO1_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO2_ON_VSEL, REG_LDO2_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+	{  800000, 100000, REG_LDO3_ON_VSEL, REG_LDO3_SLP_VSEL, NA, RK808_BUCK4_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO4_ON_VSEL, REG_LDO4_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO5_ON_VSEL, REG_LDO5_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+	{  800000, 100000, REG_LDO6_ON_VSEL, REG_LDO6_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+	{  800000, 100000, REG_LDO7_ON_VSEL, REG_LDO7_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO8_ON_VSEL, REG_LDO8_SLP_VSEL, NA, RK808_LDO_VSEL_MASK, },
+};
+
+static const struct rk8xx_reg_info rk816_ldo[] = {
+	{ 800000, 100000, REG_LDO1_ON_VSEL, REG_LDO1_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 800000, 100000, REG_LDO2_ON_VSEL, REG_LDO2_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 800000, 100000, REG_LDO3_ON_VSEL, REG_LDO3_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 800000, 100000, REG_LDO4_ON_VSEL, REG_LDO4_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 800000, 100000, REG_LDO5_ON_VSEL, REG_LDO5_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 800000, 100000, REG_LDO6_ON_VSEL, REG_LDO6_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+};
+
+static const struct rk8xx_reg_info rk817_ldo[] = {
+	/* ldo1 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(1), RK817_LDO_SLP_VSEL(1), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(1), RK817_LDO_SLP_VSEL(1), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo2 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(2), RK817_LDO_SLP_VSEL(2), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(2), RK817_LDO_SLP_VSEL(2), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo3 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(3), RK817_LDO_SLP_VSEL(3), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(3), RK817_LDO_SLP_VSEL(3), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo4 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(4), RK817_LDO_SLP_VSEL(4), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(4), RK817_LDO_SLP_VSEL(4), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo5 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(5), RK817_LDO_SLP_VSEL(5), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(5), RK817_LDO_SLP_VSEL(5), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo6 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(6), RK817_LDO_SLP_VSEL(6), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(6), RK817_LDO_SLP_VSEL(6), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo7 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(7), RK817_LDO_SLP_VSEL(7), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(7), RK817_LDO_SLP_VSEL(7), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo8 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(8), RK817_LDO_SLP_VSEL(8), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(8), RK817_LDO_SLP_VSEL(8), NA, RK817_LDO_VSEL_MASK, 0x70, },
+	/* ldo9 */
+	{  600000, 25000, RK817_LDO_ON_VSEL(9), RK817_LDO_SLP_VSEL(9), NA, RK817_LDO_VSEL_MASK, 0x00, },
+	{ 3400000,     0, RK817_LDO_ON_VSEL(9), RK817_LDO_SLP_VSEL(9), NA, RK817_LDO_VSEL_MASK, 0x70, },
 };
 
 static const struct rk8xx_reg_info rk818_ldo[] = {
-	{ 1800000, 100000, REG_LDO1_ON_VSEL, RK818_LDO_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO2_ON_VSEL, RK818_LDO_VSEL_MASK, },
-	{ 800000, 100000, REG_LDO3_ON_VSEL, RK818_LDO3_ON_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO4_ON_VSEL, RK818_LDO_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO5_ON_VSEL, RK818_LDO_VSEL_MASK, },
-	{ 800000, 100000, REG_LDO6_ON_VSEL, RK818_LDO_VSEL_MASK, },
-	{ 800000, 100000, REG_LDO7_ON_VSEL, RK818_LDO_VSEL_MASK, },
-	{ 1800000, 100000, REG_LDO8_ON_VSEL, RK818_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO1_ON_VSEL, REG_LDO1_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO2_ON_VSEL, REG_LDO2_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{  800000, 100000, REG_LDO3_ON_VSEL, REG_LDO3_SLP_VSEL, NA, RK818_LDO3_ON_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO4_ON_VSEL, REG_LDO4_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO5_ON_VSEL, REG_LDO5_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{  800000, 100000, REG_LDO6_ON_VSEL, REG_LDO6_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{  800000, 100000, REG_LDO7_ON_VSEL, REG_LDO7_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
+	{ 1800000, 100000, REG_LDO8_ON_VSEL, REG_LDO8_SLP_VSEL, NA, RK818_LDO_VSEL_MASK, },
 };
 #endif
 
@@ -88,10 +220,54 @@ static const uint rk818_chrg_shutdown_vsel_array[] = {
 };
 
 static const struct rk8xx_reg_info *get_buck_reg(struct udevice *pmic,
-					     int num)
+						 int num, int uvolt)
 {
 	struct rk8xx_priv *priv = dev_get_priv(pmic);
+
 	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		switch (num) {
+		case 0:
+		case 1:
+			if (uvolt <= 1450000)
+				return &rk816_buck[num * 3 + 0];
+			else if (uvolt <= 2200000)
+				return &rk816_buck[num * 3 + 1];
+			else
+				return &rk816_buck[num * 3 + 2];
+		default:
+			return &rk816_buck[num + 4];
+		}
+
+	case RK809_ID:
+	case RK817_ID:
+		switch (num) {
+		case 0 ... 2:
+			if (uvolt < 1500000)
+				return &rk817_buck[num * 3 + 0];
+			else if (uvolt < 2400000)
+				return &rk817_buck[num * 3 + 1];
+			else
+				return &rk817_buck[num * 3 + 2];
+		case 3:
+			if (uvolt < 1500000)
+				return &rk817_buck[num * 3 + 0];
+			else if (uvolt < 3400000)
+				return &rk817_buck[num * 3 + 1];
+			else
+				return &rk817_buck[num * 3 + 2];
+		/* BUCK5 for RK809 */
+		default:
+			if (uvolt < 1800000)
+				return &rk809_buck5[0];
+			else if (uvolt < 2800000)
+				return &rk809_buck5[1];
+			else if (uvolt < 3300000)
+				return &rk809_buck5[2];
+			else
+				return &rk809_buck5[3];
+		}
 	case RK818_ID:
 		return &rk818_buck[num];
 	default:
@@ -101,44 +277,327 @@ static const struct rk8xx_reg_info *get_buck_reg(struct udevice *pmic,
 
 static int _buck_set_value(struct udevice *pmic, int buck, int uvolt)
 {
-	const struct rk8xx_reg_info *info = get_buck_reg(pmic, buck - 1);
+	const struct rk8xx_reg_info *info = get_buck_reg(pmic, buck, uvolt);
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
 	int mask = info->vsel_mask;
 	int val;
 
-	if (info->vsel_reg == -1)
+	if (info->vsel_reg == NA)
 		return -ENOSYS;
-	val = (uvolt - info->min_uv) / info->step_uv;
-	debug("%s: reg=%x, mask=%x, val=%x\n", __func__, info->vsel_reg, mask,
-	      val);
 
-	return pmic_clrsetbits(pmic, info->vsel_reg, mask, val);
+	if (info->step_uv == 0)	/* Fixed voltage */
+		val = info->min_sel;
+	else
+		val = ((uvolt - info->min_uv) / info->step_uv) + info->min_sel;
+
+	debug("%s: volt=%d, buck=%d, reg=0x%x, mask=0x%x, val=0x%x\n",
+	      __func__, uvolt, buck+1, info->vsel_reg, mask, val);
+
+	if (priv->variant == RK816_ID) {
+		pmic_clrsetbits(pmic, info->vsel_reg, mask, val);
+		return pmic_clrsetbits(pmic, RK816_REG_DCDC_EN2, 1 << 7, 1 << 7);
+	} else {
+		return pmic_clrsetbits(pmic, info->vsel_reg, mask, val);
+	}
 }
 
 static int _buck_set_enable(struct udevice *pmic, int buck, bool enable)
 {
-	uint mask;
+	uint mask, value, en_reg;
 	int ret;
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
 
-	buck--;
-	mask = 1 << buck;
-	if (enable) {
-		ret = pmic_clrsetbits(pmic, REG_DCDC_ILMAX, 0, 3 << (buck * 2));
-		if (ret)
-			return ret;
-		ret = pmic_clrsetbits(pmic, REG_DCDC_UV_ACT, 1 << buck, 0);
-		if (ret)
-			return ret;
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		if (buck >= 4) {
+			buck -= 4;
+			en_reg = RK816_REG_DCDC_EN2;
+		} else {
+			en_reg = RK816_REG_DCDC_EN1;
+		}
+		if (enable)
+			value = ((1 << buck) | (1 << (buck + 4)));
+		else
+			value = ((0 << buck) | (1 << (buck + 4)));
+		ret = pmic_reg_write(pmic, en_reg, value);
+		break;
+
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << buck;
+		if (enable) {
+			ret = pmic_clrsetbits(pmic, REG_DCDC_ILMAX,
+					      0, 3 << (buck * 2));
+			if (ret)
+				return ret;
+		}
+		ret = pmic_clrsetbits(pmic, REG_DCDC_EN, mask,
+				      enable ? mask : 0);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (buck < 4) {
+			if (enable)
+				value = ((1 << buck) | (1 << (buck + 4)));
+			else
+				value = ((0 << buck) | (1 << (buck + 4)));
+			ret = pmic_reg_write(pmic, RK817_POWER_EN(0), value);
+		/* BUCK5 for RK809 */
+		} else {
+			if (enable)
+				value = ((1 << 1) | (1 << 5));
+			else
+				value = ((0 << 1) | (1 << 5));
+			ret = pmic_reg_write(pmic, RK817_POWER_EN(3), value);
+		}
+		break;
+	default:
+		ret = -EINVAL;
 	}
 
-	return pmic_clrsetbits(pmic, REG_DCDC_EN, mask, enable ? mask : 0);
+	return ret;
 }
 
 #ifdef ENABLE_DRIVER
+static int _buck_set_suspend_value(struct udevice *pmic, int buck, int uvolt)
+{
+	const struct rk8xx_reg_info *info = get_buck_reg(pmic, buck, uvolt);
+	int mask = info->vsel_mask;
+	int val;
+
+	if (info->vsel_sleep_reg == NA)
+		return -ENOSYS;
+
+	if (info->step_uv == 0)
+		val = info->min_sel;
+	else
+		val = ((uvolt - info->min_uv) / info->step_uv) + info->min_sel;
+
+	debug("%s: volt=%d, buck=%d, reg=0x%x, mask=0x%x, val=0x%x\n",
+	      __func__, uvolt, buck+1, info->vsel_sleep_reg, mask, val);
+
+	return pmic_clrsetbits(pmic, info->vsel_sleep_reg, mask, val);
+}
+
+static int _buck_get_enable(struct udevice *pmic, int buck)
+{
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	uint mask = 0;
+	int ret = 0;
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		if (buck >= 4) {
+			mask = 1 << (buck - 4);
+			ret = pmic_reg_read(pmic, RK816_REG_DCDC_EN2);
+		} else {
+			mask = 1 << buck;
+			ret = pmic_reg_read(pmic, RK816_REG_DCDC_EN1);
+		}
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << buck;
+		ret = pmic_reg_read(pmic, REG_DCDC_EN);
+		if (ret < 0)
+			return ret;
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (buck < 4) {
+			mask = 1 << buck;
+			ret = pmic_reg_read(pmic, RK817_POWER_EN(0));
+		/* BUCK5 for RK809 */
+		} else {
+			mask = 1 << 1;
+			ret = pmic_reg_read(pmic, RK817_POWER_EN(3));
+		}
+		break;
+	}
+
+	if (ret < 0)
+		return ret;
+
+	return ret & mask ? true : false;
+}
+
+static int _buck_set_ramp_delay(struct udevice *pmic, int buck, u32 ramp_delay)
+{
+	const struct rk8xx_reg_info *info = get_buck_reg(pmic, buck, 0);
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	u32 ramp_value, ramp_mask;
+
+	if (info->config_reg == NA)
+		return -ENOSYS;
+
+	switch (priv->variant) {
+	case RK805_ID:
+		ramp_mask = RK805_RAMP_RATE_MASK;
+		ramp_value = RK805_RAMP_RATE_12_5MV_PER_US;
+		switch (ramp_delay) {
+		case 0 ... 3000:
+			ramp_value = RK805_RAMP_RATE_3MV_PER_US;
+			break;
+		case 3001 ... 6000:
+			ramp_value = RK805_RAMP_RATE_6MV_PER_US;
+			break;
+		case 6001 ... 12500:
+			ramp_value = RK805_RAMP_RATE_12_5MV_PER_US;
+			break;
+		case 12501 ... 25000:
+			ramp_value = RK805_RAMP_RATE_25MV_PER_US;
+			break;
+		default:
+			printf("buck%d ramp_delay: %d not supported\n",
+			       buck, ramp_delay);
+		}
+		break;
+	case RK808_ID:
+	case RK816_ID:
+	case RK818_ID:
+		ramp_value = RK808_RAMP_RATE_6MV_PER_US;
+		ramp_mask = RK808_RAMP_RATE_MASK;
+		switch (ramp_delay) {
+		case 1 ... 2000:
+			ramp_value = RK808_RAMP_RATE_2MV_PER_US;
+			break;
+		case 2001 ... 4000:
+			ramp_value = RK808_RAMP_RATE_4MV_PER_US;
+			break;
+		case 4001 ... 6000:
+			ramp_value = RK808_RAMP_RATE_6MV_PER_US;
+			break;
+		case 6001 ... 10000:
+			ramp_value = RK808_RAMP_RATE_6MV_PER_US;
+			break;
+		default:
+			printf("buck%d ramp_delay: %d not supported\n",
+			       buck, ramp_delay);
+		}
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		ramp_mask = RK817_RAMP_RATE_MASK;
+		ramp_value = RK817_RAMP_RATE_12_5MV_PER_US;
+		switch (ramp_delay) {
+		case 0 ... 3000:
+			ramp_value = RK817_RAMP_RATE_3MV_PER_US;
+			break;
+		case 3001 ... 6300:
+			ramp_value = RK817_RAMP_RATE_6_3MV_PER_US;
+			break;
+		case 6301 ... 12500:
+			ramp_value = RK817_RAMP_RATE_12_5MV_PER_US;
+			break;
+		case 12501 ... 25000:
+			ramp_value = RK817_RAMP_RATE_12_5MV_PER_US;
+			break;
+		default:
+			printf("buck%d ramp_delay: %d not supported\n",
+			       buck, ramp_delay);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return pmic_clrsetbits(pmic, info->config_reg, ramp_mask, ramp_value);
+}
+
+static int _buck_set_suspend_enable(struct udevice *pmic, int buck, bool enable)
+{
+	uint mask;
+	int ret;
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		mask = 1 << buck;
+		ret = pmic_clrsetbits(pmic, RK816_REG_DCDC_SLP_EN, mask,
+				      enable ? mask : 0);
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << buck;
+		ret = pmic_clrsetbits(pmic, REG_SLEEP_SET_OFF1, mask,
+				      enable ? 0 : mask);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (buck < 4)
+			mask = 1 << buck;
+		else
+			mask = 1 << 5;	/* BUCK5 for RK809 */
+		ret = pmic_clrsetbits(pmic, RK817_POWER_SLP_EN(0), mask,
+				      enable ? mask : 0);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int _buck_get_suspend_enable(struct udevice *pmic, int buck)
+{
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	int ret, val;
+	uint mask;
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		mask = 1 << buck;
+		val = pmic_reg_read(pmic, RK816_REG_DCDC_SLP_EN);
+		if (val < 0)
+			return val;
+		ret = val & mask ? 1 : 0;
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << buck;
+		val = pmic_reg_read(pmic, REG_SLEEP_SET_OFF1);
+		if (val < 0)
+			return val;
+		ret = val & mask ? 0 : 1;
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (buck < 4)
+			mask = 1 << buck;
+		else
+			mask = 1 << 5;	/* BUCK5 for RK809 */
+
+		val = pmic_reg_read(pmic, RK817_POWER_SLP_EN(0));
+		if (val < 0)
+			return val;
+		ret = val & mask ? 1 : 0;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
 static const struct rk8xx_reg_info *get_ldo_reg(struct udevice *pmic,
-					     int num)
+						int num, int uvolt)
 {
 	struct rk8xx_priv *priv = dev_get_priv(pmic);
+
 	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		return &rk816_ldo[num];
+	case RK809_ID:
+	case RK817_ID:
+		if (uvolt < 3400000)
+			return &rk817_ldo[num * 2 + 0];
+		else
+			return &rk817_ldo[num * 2 + 1];
 	case RK818_ID:
 		return &rk818_ldo[num];
 	default:
@@ -146,60 +605,300 @@ static const struct rk8xx_reg_info *get_ldo_reg(struct udevice *pmic,
 	}
 }
 
+static int _ldo_get_enable(struct udevice *pmic, int ldo)
+{
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	uint mask = 0;
+	int ret = 0;
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		if (ldo >= 4) {
+			mask = 1 << (ldo - 4);
+			ret = pmic_reg_read(pmic, RK816_REG_LDO_EN2);
+		} else {
+			mask = 1 << ldo;
+			ret = pmic_reg_read(pmic, RK816_REG_LDO_EN1);
+		}
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << ldo;
+		ret = pmic_reg_read(pmic, REG_LDO_EN);
+		if (ret < 0)
+			return ret;
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (ldo < 4) {
+			mask = 1 << ldo;
+			ret = pmic_reg_read(pmic, RK817_POWER_EN(1));
+		} else if (ldo < 8) {
+			mask = 1 << (ldo - 4);
+			ret = pmic_reg_read(pmic, RK817_POWER_EN(2));
+		} else if (ldo == 8) {
+			mask = 1 << 0;
+			ret = pmic_reg_read(pmic, RK817_POWER_EN(3));
+		} else {
+			return false;
+		}
+		break;
+	}
+
+	if (ret < 0)
+		return ret;
+
+	return ret & mask ? true : false;
+}
+
+static int _ldo_set_enable(struct udevice *pmic, int ldo, bool enable)
+{
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	uint mask, value, en_reg;
+	int ret = 0;
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		if (ldo >= 4) {
+			ldo -= 4;
+			en_reg = RK816_REG_LDO_EN2;
+		} else {
+			en_reg = RK816_REG_LDO_EN1;
+		}
+		if (enable)
+			value = ((1 << ldo) | (1 << (ldo + 4)));
+		else
+			value = ((0 << ldo) | (1 << (ldo + 4)));
+
+		ret = pmic_reg_write(pmic, en_reg, value);
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << ldo;
+		ret = pmic_clrsetbits(pmic, REG_LDO_EN, mask,
+				       enable ? mask : 0);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (ldo < 4) {
+			en_reg = RK817_POWER_EN(1);
+		} else if (ldo < 8) {
+			ldo -= 4;
+			en_reg = RK817_POWER_EN(2);
+		} else if (ldo == 8) {
+			ldo = 0;	/* BIT 0 */
+			en_reg = RK817_POWER_EN(3);
+		} else {
+			return -EINVAL;
+		}
+		if (enable)
+			value = ((1 << ldo) | (1 << (ldo + 4)));
+		else
+			value = ((0 << ldo) | (1 << (ldo + 4)));
+		ret = pmic_reg_write(pmic, en_reg, value);
+		break;
+	}
+
+	return ret;
+}
+
+static int _ldo_set_suspend_enable(struct udevice *pmic, int ldo, bool enable)
+{
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	uint mask;
+	int ret = 0;
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		mask = 1 << ldo;
+		ret = pmic_clrsetbits(pmic, RK816_REG_LDO_SLP_EN, mask,
+				      enable ? mask : 0);
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << ldo;
+		ret = pmic_clrsetbits(pmic, REG_SLEEP_SET_OFF2, mask,
+				      enable ? 0 : mask);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (ldo == 8) {
+			mask = 1 << 4;	/* LDO9 */
+			ret = pmic_clrsetbits(pmic, RK817_POWER_SLP_EN(0), mask,
+					      enable ? mask : 0);
+		} else {
+			mask = 1 << ldo;
+			ret = pmic_clrsetbits(pmic, RK817_POWER_SLP_EN(1), mask,
+					      enable ? mask : 0);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static int _ldo_get_suspend_enable(struct udevice *pmic, int ldo)
+{
+	struct rk8xx_priv *priv = dev_get_priv(pmic);
+	int val, ret = 0;
+	uint mask;
+
+	switch (priv->variant) {
+	case RK805_ID:
+	case RK816_ID:
+		mask = 1 << ldo;
+		val = pmic_reg_read(pmic, RK816_REG_LDO_SLP_EN);
+		if (val < 0)
+			return val;
+		ret = val & mask ? 1 : 0;
+		break;
+	case RK808_ID:
+	case RK818_ID:
+		mask = 1 << ldo;
+		val = pmic_reg_read(pmic, REG_SLEEP_SET_OFF2);
+		if (val < 0)
+			return val;
+		ret = val & mask ? 0 : 1;
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		if (ldo == 8) {
+			mask = 1 << 4;	/* LDO9 */
+			val = pmic_reg_read(pmic, RK817_POWER_SLP_EN(0));
+			if (val < 0)
+				return val;
+			ret = val & mask ? 1 : 0;
+		} else {
+			mask = 1 << ldo;
+			val = pmic_reg_read(pmic, RK817_POWER_SLP_EN(1));
+			if (val < 0)
+				return val;
+			ret = val & mask ? 1 : 0;
+		}
+		break;
+	}
+
+	return ret;
+}
+
 static int buck_get_value(struct udevice *dev)
 {
 	int buck = dev->driver_data - 1;
-	const struct rk8xx_reg_info *info = get_buck_reg(dev->parent, buck);
+	const struct rk8xx_reg_info *info = get_buck_reg(dev->parent, buck, 0);
 	int mask = info->vsel_mask;
-	int ret, val;
+	int i, ret, val;
 
-	if (info->vsel_reg == -1)
+	if (info->vsel_reg == NA)
 		return -ENOSYS;
+
 	ret = pmic_reg_read(dev->parent, info->vsel_reg);
 	if (ret < 0)
 		return ret;
+
 	val = ret & mask;
+	if (val >= info->min_sel && val <= info->max_sel)
+		goto finish;
 
-	return info->min_uv + val * info->step_uv;
+	/* unlucky to try */
+	for (i = 1; i < info->range_num; i++) {
+		info++;
+		if (val <= info->max_sel && val >= info->min_sel)
+			break;
+	}
+
+finish:
+	return info->min_uv + (val - info->min_sel) * info->step_uv;
 }
 
 static int buck_set_value(struct udevice *dev, int uvolt)
 {
-	int buck = dev->driver_data;
+	int buck = dev->driver_data - 1;
 
 	return _buck_set_value(dev->parent, buck, uvolt);
 }
 
+static int buck_get_suspend_value(struct udevice *dev)
+{
+	int buck = dev->driver_data - 1;
+	const struct rk8xx_reg_info *info = get_buck_reg(dev->parent, buck, 0);
+	int mask = info->vsel_mask;
+	int i, ret, val;
+
+	if (info->vsel_sleep_reg == NA)
+		return -ENOSYS;
+
+	ret = pmic_reg_read(dev->parent, info->vsel_sleep_reg);
+	if (ret < 0)
+		return ret;
+
+	val = ret & mask;
+	if (val <= info->max_sel && val >= info->min_sel)
+		goto finish;
+
+	/* unlucky to try */
+	for (i = 1; i < info->range_num; i++) {
+		info++;
+		if (val <= info->max_sel && val >= info->min_sel)
+			break;
+	}
+
+finish:
+	return info->min_uv + (val - info->min_sel) * info->step_uv;
+}
+
+static int buck_set_suspend_value(struct udevice *dev, int uvolt)
+{
+	int buck = dev->driver_data - 1;
+
+	return _buck_set_suspend_value(dev->parent, buck, uvolt);
+}
+
 static int buck_set_enable(struct udevice *dev, bool enable)
 {
-	int buck = dev->driver_data;
+	int buck = dev->driver_data - 1;
 
 	return _buck_set_enable(dev->parent, buck, enable);
 }
 
-static int buck_get_enable(struct udevice *dev)
+static int buck_set_suspend_enable(struct udevice *dev, bool enable)
 {
 	int buck = dev->driver_data - 1;
-	int ret;
-	uint mask;
 
-	mask = 1 << buck;
+	return _buck_set_suspend_enable(dev->parent, buck, enable);
+}
 
-	ret = pmic_reg_read(dev->parent, REG_DCDC_EN);
-	if (ret < 0)
-		return ret;
+static int buck_get_suspend_enable(struct udevice *dev)
+{
+	int buck = dev->driver_data - 1;
 
-	return ret & mask ? true : false;
+	return _buck_get_suspend_enable(dev->parent, buck);
+}
+
+static int buck_set_ramp_delay(struct udevice *dev, u32 ramp_delay)
+{
+	int buck = dev->driver_data - 1;
+
+	return _buck_set_ramp_delay(dev->parent, buck, ramp_delay);
+}
+
+static int buck_get_enable(struct udevice *dev)
+{
+	int buck = dev->driver_data - 1;
+
+	return _buck_get_enable(dev->parent, buck);
 }
 
 static int ldo_get_value(struct udevice *dev)
 {
 	int ldo = dev->driver_data - 1;
-	const struct rk8xx_reg_info *info = get_ldo_reg(dev->parent, ldo);
+	const struct rk8xx_reg_info *info = get_ldo_reg(dev->parent, ldo, 0);
 	int mask = info->vsel_mask;
 	int ret, val;
 
-	if (info->vsel_reg == -1)
+	if (info->vsel_reg == NA)
 		return -ENOSYS;
 	ret = pmic_reg_read(dev->parent, info->vsel_reg);
 	if (ret < 0)
@@ -212,71 +911,255 @@ static int ldo_get_value(struct udevice *dev)
 static int ldo_set_value(struct udevice *dev, int uvolt)
 {
 	int ldo = dev->driver_data - 1;
-	const struct rk8xx_reg_info *info = get_ldo_reg(dev->parent, ldo);
+	const struct rk8xx_reg_info *info = get_ldo_reg(dev->parent, ldo, uvolt);
 	int mask = info->vsel_mask;
 	int val;
 
-	if (info->vsel_reg == -1)
+	if (info->vsel_reg == NA)
 		return -ENOSYS;
-	val = (uvolt - info->min_uv) / info->step_uv;
-	debug("%s: reg=%x, mask=%x, val=%x\n", __func__, info->vsel_reg, mask,
-	      val);
+
+	if (info->step_uv == 0)
+		val = info->min_sel;
+	else
+		val = ((uvolt - info->min_uv) / info->step_uv) + info->min_sel;
+
+	debug("%s: volt=%d, ldo=%d, reg=0x%x, mask=0x%x, val=0x%x\n",
+	      __func__, uvolt, ldo+1, info->vsel_reg, mask, val);
 
 	return pmic_clrsetbits(dev->parent, info->vsel_reg, mask, val);
 }
 
-static int ldo_set_enable(struct udevice *dev, bool enable)
+static int ldo_set_suspend_value(struct udevice *dev, int uvolt)
 {
 	int ldo = dev->driver_data - 1;
-	uint mask;
+	const struct rk8xx_reg_info *info = get_ldo_reg(dev->parent, ldo, uvolt);
+	int mask = info->vsel_mask;
+	int val;
+
+	if (info->vsel_sleep_reg == NA)
+		return -ENOSYS;
+
+	if (info->step_uv == 0)
+		val = info->min_sel;
+	else
+		val = ((uvolt - info->min_uv) / info->step_uv) + info->min_sel;
 
-	mask = 1 << ldo;
+	debug("%s: volt=%d, ldo=%d, reg=0x%x, mask=0x%x, val=0x%x\n",
+	      __func__, uvolt, ldo+1, info->vsel_sleep_reg, mask, val);
 
-	return pmic_clrsetbits(dev->parent, REG_LDO_EN, mask,
-			       enable ? mask : 0);
+	return pmic_clrsetbits(dev->parent, info->vsel_sleep_reg, mask, val);
 }
 
-static int ldo_get_enable(struct udevice *dev)
+static int ldo_get_suspend_value(struct udevice *dev)
 {
 	int ldo = dev->driver_data - 1;
-	int ret;
-	uint mask;
+	const struct rk8xx_reg_info *info = get_ldo_reg(dev->parent, ldo, 0);
+	int mask = info->vsel_mask;
+	int val, ret;
 
-	mask = 1 << ldo;
+	if (info->vsel_sleep_reg == NA)
+		return -ENOSYS;
 
-	ret = pmic_reg_read(dev->parent, REG_LDO_EN);
+	ret = pmic_reg_read(dev->parent, info->vsel_sleep_reg);
 	if (ret < 0)
 		return ret;
 
-	return ret & mask ? true : false;
+	val = ret & mask;
+
+	return info->min_uv + val * info->step_uv;
+}
+
+static int ldo_set_enable(struct udevice *dev, bool enable)
+{
+	int ldo = dev->driver_data - 1;
+
+	return _ldo_set_enable(dev->parent, ldo, enable);
+}
+
+static int ldo_set_suspend_enable(struct udevice *dev, bool enable)
+{
+	int ldo = dev->driver_data - 1;
+
+	return _ldo_set_suspend_enable(dev->parent, ldo, enable);
+}
+
+static int ldo_get_suspend_enable(struct udevice *dev)
+{
+	int ldo = dev->driver_data - 1;
+
+	return _ldo_get_suspend_enable(dev->parent, ldo);
+}
+
+static int ldo_get_enable(struct udevice *dev)
+{
+	int ldo = dev->driver_data - 1;
+
+	return _ldo_get_enable(dev->parent, ldo);
 }
 
 static int switch_set_enable(struct udevice *dev, bool enable)
 {
-	int sw = dev->driver_data - 1;
-	uint mask;
+	struct rk8xx_priv *priv = dev_get_priv(dev->parent);
+	int ret = 0, sw = dev->driver_data - 1;
+	uint mask = 0;
 
-	mask = 1 << (sw + 5);
+	switch (priv->variant) {
+	case RK808_ID:
+		mask = 1 << (sw + 5);
+		ret = pmic_clrsetbits(dev->parent, REG_DCDC_EN, mask,
+				      enable ? mask : 0);
+		break;
+	case RK809_ID:
+		mask = (1 << (sw + 2)) | (1 << (sw + 6));
+		ret = pmic_clrsetbits(dev->parent, RK817_POWER_EN(3), mask,
+				      enable ? mask : (1 << (sw + 6)));
+		break;
+	case RK818_ID:
+		mask = 1 << 6;
+		ret = pmic_clrsetbits(dev->parent, REG_DCDC_EN, mask,
+				      enable ? mask : 0);
+		break;
+	}
 
-	return pmic_clrsetbits(dev->parent, REG_DCDC_EN, mask,
-			       enable ? mask : 0);
+	debug("%s: switch%d, enable=%d, mask=0x%x\n",
+	      __func__, sw + 1, enable, mask);
+
+	return ret;
 }
 
 static int switch_get_enable(struct udevice *dev)
 {
-	int sw = dev->driver_data - 1;
-	int ret;
-	uint mask;
+	struct rk8xx_priv *priv = dev_get_priv(dev->parent);
+	int ret = 0, sw = dev->driver_data - 1;
+	uint mask = 0;
 
-	mask = 1 << (sw + 5);
+	switch (priv->variant) {
+	case RK808_ID:
+		mask = 1 << (sw + 5);
+		ret = pmic_reg_read(dev->parent, REG_DCDC_EN);
+		break;
+	case RK809_ID:
+		mask = 1 << (sw + 2);
+		ret = pmic_reg_read(dev->parent, RK817_POWER_EN(3));
+		break;
+	case RK818_ID:
+		mask = 1 << 6;
+		ret = pmic_reg_read(dev->parent, REG_DCDC_EN);
+		break;
+	}
 
-	ret = pmic_reg_read(dev->parent, REG_DCDC_EN);
 	if (ret < 0)
 		return ret;
 
 	return ret & mask ? true : false;
 }
 
+static int switch_set_suspend_value(struct udevice *dev, int uvolt)
+{
+	return 0;
+}
+
+static int switch_get_suspend_value(struct udevice *dev)
+{
+	return 0;
+}
+
+static int switch_set_suspend_enable(struct udevice *dev, bool enable)
+{
+	struct rk8xx_priv *priv = dev_get_priv(dev->parent);
+	int ret = 0, sw = dev->driver_data - 1;
+	uint mask = 0;
+
+	switch (priv->variant) {
+	case RK808_ID:
+		mask = 1 << (sw + 5);
+		ret = pmic_clrsetbits(dev->parent, REG_SLEEP_SET_OFF1, mask,
+				      enable ? 0 : mask);
+		break;
+	case RK809_ID:
+		mask = 1 << (sw + 6);
+		ret = pmic_clrsetbits(dev->parent, RK817_POWER_SLP_EN(0), mask,
+				      enable ? mask : 0);
+		break;
+	case RK818_ID:
+		mask = 1 << 6;
+		ret = pmic_clrsetbits(dev->parent, REG_SLEEP_SET_OFF1, mask,
+				      enable ? 0 : mask);
+		break;
+	}
+
+	debug("%s: switch%d, enable=%d, mask=0x%x\n",
+	      __func__, sw + 1, enable, mask);
+
+	return ret;
+}
+
+static int switch_get_suspend_enable(struct udevice *dev)
+{
+	struct rk8xx_priv *priv = dev_get_priv(dev->parent);
+	int val, ret = 0, sw = dev->driver_data - 1;
+	uint mask = 0;
+
+	switch (priv->variant) {
+	case RK808_ID:
+		mask = 1 << (sw + 5);
+		val = pmic_reg_read(dev->parent, REG_SLEEP_SET_OFF1);
+		if (val < 0)
+			return val;
+		ret = val & mask ? 0 : 1;
+		break;
+	case RK809_ID:
+		mask = 1 << (sw + 6);
+		val = pmic_reg_read(dev->parent, RK817_POWER_SLP_EN(0));
+		if (val < 0)
+			return val;
+		ret = val & mask ? 1 : 0;
+		break;
+	case RK818_ID:
+		mask = 1 << 6;
+		val = pmic_reg_read(dev->parent, REG_SLEEP_SET_OFF1);
+		if (val < 0)
+			return val;
+		ret = val & mask ? 0 : 1;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * RK8xx switch does not need to set the voltage,
+ * but if dts set regulator-min-microvolt/regulator-max-microvolt,
+ * will cause regulator set value fail and not to enable this switch.
+ * So add an empty function to return success.
+ */
+static int switch_get_value(struct udevice *dev)
+{
+	const char *supply_name[] = { "vcc9-supply", "vcc8-supply", };
+	struct rk8xx_priv *priv = dev_get_priv(dev->parent);
+	struct udevice *supply;
+	int id = dev->driver_data - 1;
+
+	if (!switch_get_enable(dev))
+		return 0;
+
+	/* note: rk817 only contains switch0 */
+	if ((priv->variant == RK809_ID) || (priv->variant == RK817_ID)) {
+		if (!uclass_get_device_by_phandle(UCLASS_REGULATOR,
+						  dev_get_parent(dev),
+						  supply_name[id],
+						  &supply))
+			return regulator_get_value(supply);
+	}
+
+	return 0;
+}
+
+static int switch_set_value(struct udevice *dev, int uvolt)
+{
+	return 0;
+}
+
 static int rk8xx_buck_probe(struct udevice *dev)
 {
 	struct dm_regulator_uclass_platdata *uc_pdata;
@@ -316,20 +1199,35 @@ static int rk8xx_switch_probe(struct udevice *dev)
 static const struct dm_regulator_ops rk8xx_buck_ops = {
 	.get_value  = buck_get_value,
 	.set_value  = buck_set_value,
+	.set_suspend_value = buck_set_suspend_value,
+	.get_suspend_value = buck_get_suspend_value,
 	.get_enable = buck_get_enable,
 	.set_enable = buck_set_enable,
+	.set_suspend_enable = buck_set_suspend_enable,
+	.get_suspend_enable = buck_get_suspend_enable,
+	.set_ramp_delay = buck_set_ramp_delay,
 };
 
 static const struct dm_regulator_ops rk8xx_ldo_ops = {
 	.get_value  = ldo_get_value,
 	.set_value  = ldo_set_value,
+	.set_suspend_value = ldo_set_suspend_value,
+	.get_suspend_value = ldo_get_suspend_value,
 	.get_enable = ldo_get_enable,
 	.set_enable = ldo_set_enable,
+	.set_suspend_enable = ldo_set_suspend_enable,
+	.get_suspend_enable = ldo_get_suspend_enable,
 };
 
 static const struct dm_regulator_ops rk8xx_switch_ops = {
+	.get_value  = switch_get_value,
+	.set_value  = switch_set_value,
 	.get_enable = switch_get_enable,
 	.set_enable = switch_set_enable,
+	.set_suspend_enable = switch_set_suspend_enable,
+	.get_suspend_enable = switch_get_suspend_enable,
+	.set_suspend_value = switch_set_suspend_value,
+	.get_suspend_value = switch_get_suspend_value,
 };
 
 U_BOOT_DRIVER(rk8xx_buck) = {
diff --git a/drivers/power/regulator/sandbox.c b/drivers/power/regulator/sandbox.c
index 06c09fd051..f980a17389 100644
--- a/drivers/power/regulator/sandbox.c
+++ b/drivers/power/regulator/sandbox.c
@@ -87,7 +87,7 @@ int out_get_value(struct udevice *dev, int output_count, int reg_type,
 	int ret;
 
 	if (dev->driver_data > output_count) {
-		error("Unknown regulator number: %lu for PMIC %s!",
+		pr_err("Unknown regulator number: %lu for PMIC %s!",
 		      dev->driver_data, dev->name);
 		return -EINVAL;
 	}
@@ -95,7 +95,7 @@ int out_get_value(struct udevice *dev, int output_count, int reg_type,
 	reg = (dev->driver_data - 1) * OUT_REG_COUNT + reg_type;
 	ret = pmic_read(dev->parent, reg, &reg_val, 1);
 	if (ret) {
-		error("PMIC read failed: %d\n",  ret);
+		pr_err("PMIC read failed: %d\n",  ret);
 		return ret;
 	}
 
@@ -115,14 +115,14 @@ static int out_set_value(struct udevice *dev, int output_count, int reg_type,
 	int max_value;
 
 	if (dev->driver_data > output_count) {
-		error("Unknown regulator number: %lu for PMIC %s!",
+		pr_err("Unknown regulator number: %lu for PMIC %s!",
 		      dev->driver_data, dev->name);
 		return -EINVAL;
 	}
 
 	max_value = range[dev->driver_data - 1].max;
 	if (value > max_value) {
-		error("Wrong value for %s: %lu. Max is: %d.",
+		pr_err("Wrong value for %s: %lu. Max is: %d.",
 		      dev->name, dev->driver_data, max_value);
 		return -EINVAL;
 	}
@@ -134,7 +134,7 @@ static int out_set_value(struct udevice *dev, int output_count, int reg_type,
 	reg = (dev->driver_data - 1) * OUT_REG_COUNT + reg_type;
 	ret = pmic_write(dev->parent, reg, &reg_val, 1);
 	if (ret) {
-		error("PMIC write failed: %d\n",  ret);
+		pr_err("PMIC write failed: %d\n",  ret);
 		return ret;
 	}
 
@@ -154,7 +154,7 @@ static int out_get_mode(struct udevice *dev)
 	reg = (dev->driver_data - 1) * OUT_REG_COUNT + OUT_REG_OM;
 	ret = pmic_read(dev->parent, reg, &reg_val, 1);
 	if (ret) {
-		error("PMIC read failed: %d\n",  ret);
+		pr_err("PMIC read failed: %d\n",  ret);
 		return ret;
 	}
 
@@ -163,7 +163,7 @@ static int out_get_mode(struct udevice *dev)
 			return uc_pdata->mode[i].id;
 	}
 
-	error("Unknown operation mode for %s!", dev->name);
+	pr_err("Unknown operation mode for %s!", dev->name);
 	return -EINVAL;
 }
 
@@ -188,14 +188,14 @@ static int out_set_mode(struct udevice *dev, int mode)
 	}
 
 	if (reg_val == -1) {
-		error("Unknown operation mode for %s!", dev->name);
+		pr_err("Unknown operation mode for %s!", dev->name);
 		return -EINVAL;
 	}
 
 	reg = (dev->driver_data - 1) * OUT_REG_COUNT + OUT_REG_OM;
 	ret = pmic_write(dev->parent, reg, (uint8_t *)&reg_val, 1);
 	if (ret) {
-		error("PMIC write failed: %d\n",  ret);
+		pr_err("PMIC write failed: %d\n",  ret);
 		return ret;
 	}
 
diff --git a/drivers/pwm/rk_pwm.c b/drivers/pwm/rk_pwm.c
index 2364c2dfdd..439c455c97 100644
--- a/drivers/pwm/rk_pwm.c
+++ b/drivers/pwm/rk_pwm.c
@@ -9,31 +9,48 @@
 #include <clk.h>
 #include <div64.h>
 #include <dm.h>
+#include <dm/pinctrl.h>
 #include <pwm.h>
 #include <regmap.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/pwm.h>
+#include <asm/arch-rockchip/pwm.h>
 #include <power/regulator.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+struct rockchip_pwm_data {
+	struct rockchip_pwm_regs regs;
+	unsigned int prescaler;
+	bool supports_polarity;
+	bool supports_lock;
+	bool vop_pwm;
+	u32 enable_conf;
+	u32 enable_conf_mask;
+};
+
 struct rk_pwm_priv {
-	struct rk3288_pwm *regs;
+	fdt_addr_t base;
 	ulong freq;
-	uint enable_conf;
+	u32 conf_polarity;
+	bool vop_pwm_en; /* indicate voppwm mirror register state */
+	const struct rockchip_pwm_data *data;
 };
 
 static int rk_pwm_set_invert(struct udevice *dev, uint channel, bool polarity)
 {
 	struct rk_pwm_priv *priv = dev_get_priv(dev);
 
+	if (!priv->data->supports_polarity) {
+		debug("%s: Do not support polarity\n", __func__);
+		return 0;
+	}
+
 	debug("%s: polarity=%u\n", __func__, polarity);
-	priv->enable_conf &= ~(PWM_DUTY_MASK | PWM_INACTIVE_MASK);
 	if (polarity)
-		priv->enable_conf |= PWM_DUTY_NEGATIVE | PWM_INACTIVE_POSTIVE;
+		priv->conf_polarity = PWM_DUTY_NEGATIVE | PWM_INACTIVE_POSTIVE;
 	else
-		priv->enable_conf |= PWM_DUTY_POSTIVE | PWM_INACTIVE_NEGATIVE;
+		priv->conf_polarity = PWM_DUTY_POSTIVE | PWM_INACTIVE_NEGATIVE;
 
 	return 0;
 }
@@ -42,20 +59,51 @@ static int rk_pwm_set_config(struct udevice *dev, uint channel, uint period_ns,
 			     uint duty_ns)
 {
 	struct rk_pwm_priv *priv = dev_get_priv(dev);
-	struct rk3288_pwm *regs = priv->regs;
+	const struct rockchip_pwm_regs *regs = &priv->data->regs;
 	unsigned long period, duty;
+	u32 ctrl;
 
 	debug("%s: period_ns=%u, duty_ns=%u\n", __func__, period_ns, duty_ns);
-	writel(PWM_SEL_SRC_CLK | PWM_OUTPUT_LEFT | PWM_LP_DISABLE |
-		PWM_CONTINUOUS | priv->enable_conf |
-		RK_PWM_DISABLE,
-		&regs->ctrl);
 
-	period = lldiv((uint64_t)(priv->freq / 1000) * period_ns, 1000000);
-	duty = lldiv((uint64_t)(priv->freq / 1000) * duty_ns, 1000000);
+	ctrl = readl(priv->base + regs->ctrl);
+	if (priv->data->vop_pwm) {
+		if (priv->vop_pwm_en)
+			ctrl |= RK_PWM_ENABLE;
+		else
+			ctrl &= ~RK_PWM_ENABLE;
+	}
+
+	/*
+	 * Lock the period and duty of previous configuration, then
+	 * change the duty and period, that would not be effective.
+	 */
+	if (priv->data->supports_lock) {
+		ctrl |= PWM_LOCK;
+		writel(ctrl, priv->base + regs->ctrl);
+	}
+
+	period = lldiv((uint64_t)(priv->freq / 1000) * period_ns,
+		       priv->data->prescaler * 1000000);
+	duty = lldiv((uint64_t)(priv->freq / 1000) * duty_ns,
+		     priv->data->prescaler * 1000000);
+
+	writel(period, priv->base + regs->period);
+	writel(duty, priv->base + regs->duty);
+
+	if (priv->data->supports_polarity) {
+		ctrl &= ~(PWM_DUTY_MASK | PWM_INACTIVE_MASK);
+		ctrl |= priv->conf_polarity;
+	}
+
+	/*
+	 * Unlock and set polarity at the same time,
+	 * the configuration of duty, period and polarity
+	 * would be effective together at next period.
+	 */
+	if (priv->data->supports_lock)
+		ctrl &= ~PWM_LOCK;
+	writel(ctrl, priv->base + regs->ctrl);
 
-	writel(period, &regs->period_hpr);
-	writel(duty, &regs->duty_lpr);
 	debug("%s: period=%lu, duty=%lu\n", __func__, period, duty);
 
 	return 0;
@@ -64,10 +112,25 @@ static int rk_pwm_set_config(struct udevice *dev, uint channel, uint period_ns,
 static int rk_pwm_set_enable(struct udevice *dev, uint channel, bool enable)
 {
 	struct rk_pwm_priv *priv = dev_get_priv(dev);
-	struct rk3288_pwm *regs = priv->regs;
+	const struct rockchip_pwm_regs *regs = &priv->data->regs;
+	u32 ctrl;
 
 	debug("%s: Enable '%s'\n", __func__, dev->name);
-	clrsetbits_le32(&regs->ctrl, RK_PWM_ENABLE, enable ? RK_PWM_ENABLE : 0);
+
+	ctrl = readl(priv->base + regs->ctrl);
+	ctrl &= ~priv->data->enable_conf_mask;
+
+	if (enable)
+		ctrl |= priv->data->enable_conf;
+	else
+		ctrl &= ~priv->data->enable_conf;
+
+	writel(ctrl, priv->base + regs->ctrl);
+	if (priv->data->vop_pwm)
+		priv->vop_pwm_en = enable;
+
+	if (enable)
+		pinctrl_select_state(dev, "active");
 
 	return 0;
 }
@@ -76,7 +139,7 @@ static int rk_pwm_ofdata_to_platdata(struct udevice *dev)
 {
 	struct rk_pwm_priv *priv = dev_get_priv(dev);
 
-	priv->regs = (struct rk3288_pwm *)devfdt_get_addr(dev);
+	priv->base = dev_read_addr(dev);
 
 	return 0;
 }
@@ -92,8 +155,17 @@ static int rk_pwm_probe(struct udevice *dev)
 		debug("%s get clock fail!\n", __func__);
 		return -EINVAL;
 	}
-	priv->freq = clk_get_rate(&clk);
-	priv->enable_conf = PWM_DUTY_POSTIVE | PWM_INACTIVE_POSTIVE;
+
+	ret = clk_get_rate(&clk);
+	if (ret < 0) {
+		debug("%s pwm get clock rate fail!\n", __func__);
+		return -EINVAL;
+	}
+	priv->freq = ret;
+	priv->data = (struct rockchip_pwm_data *)dev_get_driver_data(dev);
+
+	if (priv->data->supports_polarity)
+		priv->conf_polarity = PWM_DUTY_POSTIVE | PWM_INACTIVE_POSTIVE;
 
 	return 0;
 }
@@ -104,8 +176,75 @@ static const struct pwm_ops rk_pwm_ops = {
 	.set_enable	= rk_pwm_set_enable,
 };
 
+static const struct rockchip_pwm_data pwm_data_v1 = {
+	.regs = {
+		.duty = 0x04,
+		.period = 0x08,
+		.cntr = 0x00,
+		.ctrl = 0x0c,
+	},
+	.prescaler = 2,
+	.supports_polarity = false,
+	.supports_lock = false,
+	.vop_pwm = false,
+	.enable_conf = PWM_CTRL_OUTPUT_EN | PWM_CTRL_TIMER_EN,
+	.enable_conf_mask = BIT(1) | BIT(3),
+};
+
+static const struct rockchip_pwm_data pwm_data_v2 = {
+	.regs = {
+		.duty = 0x08,
+		.period = 0x04,
+		.cntr = 0x00,
+		.ctrl = 0x0c,
+	},
+	.prescaler = 1,
+	.supports_polarity = true,
+	.supports_lock = false,
+	.vop_pwm = false,
+	.enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | RK_PWM_ENABLE |
+		       PWM_CONTINUOUS,
+	.enable_conf_mask = GENMASK(2, 0) | BIT(5) | BIT(8),
+};
+
+static const struct rockchip_pwm_data pwm_data_vop = {
+	.regs = {
+		.duty = 0x08,
+		.period = 0x04,
+		.cntr = 0x0c,
+		.ctrl = 0x00,
+	},
+	.prescaler = 1,
+	.supports_polarity = true,
+	.supports_lock = false,
+	.vop_pwm = true,
+	.enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | RK_PWM_ENABLE |
+		       PWM_CONTINUOUS,
+	.enable_conf_mask = GENMASK(2, 0) | BIT(5) | BIT(8),
+};
+
+static const struct rockchip_pwm_data pwm_data_v3 = {
+	.regs = {
+		.duty = 0x08,
+		.period = 0x04,
+		.cntr = 0x00,
+		.ctrl = 0x0c,
+	},
+	.prescaler = 1,
+	.supports_polarity = true,
+	.supports_lock = true,
+	.vop_pwm = false,
+	.enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | RK_PWM_ENABLE |
+		       PWM_CONTINUOUS,
+	.enable_conf_mask = GENMASK(2, 0) | BIT(5) | BIT(8),
+};
+
 static const struct udevice_id rk_pwm_ids[] = {
-	{ .compatible = "rockchip,rk3288-pwm" },
+	{ .compatible = "rockchip,rk2928-pwm", .data = (ulong)&pwm_data_v1},
+	{ .compatible = "rockchip,rk3288-pwm", .data = (ulong)&pwm_data_v2},
+	{ .compatible = "rockchip,rk3328-pwm", .data = (ulong)&pwm_data_v3},
+	{ .compatible = "rockchip,vop-pwm", .data = (ulong)&pwm_data_vop},
+	{ .compatible = "rockchip,rk3399-pwm", .data = (ulong)&pwm_data_v2},
 	{ }
 };
 
diff --git a/drivers/qe/fdt.c b/drivers/qe/fdt.c
index 4f48f984ab..9bbdc60353 100644
--- a/drivers/qe/fdt.c
+++ b/drivers/qe/fdt.c
@@ -8,7 +8,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 #include <fsl_qe.h>
 
diff --git a/drivers/qe/qe.c b/drivers/qe/qe.c
index 24e764dc7c..931c9d903f 100644
--- a/drivers/qe/qe.c
+++ b/drivers/qe/qe.c
@@ -221,8 +221,6 @@ void u_qe_init(void)
 		mmc_init(mmc);
 		(void)mmc->block_dev.block_read(&mmc->block_dev, blk, cnt,
 						addr);
-		/* flush cache after read */
-		flush_cache((ulong)addr, cnt * 512);
 	}
 #endif
 	u_qe_upload_firmware(addr);
diff --git a/drivers/ram/Kconfig b/drivers/ram/Kconfig
index 47969f3f28..60b50de313 100644
--- a/drivers/ram/Kconfig
+++ b/drivers/ram/Kconfig
@@ -19,7 +19,7 @@ config SPL_RAM
 
 config TPL_RAM
 	bool "Enable RAM support in TPL"
-	depends on RAM && TPL_DM
+	depends on RAM
 	help
 	  The RAM subsystem adds a small amount of overhead to the image.
 	  If this is acceptable and you have a need to use RAM drivers in
@@ -33,3 +33,25 @@ config STM32_SDRAM
 	  STM32F7 family devices support flexible memory controller(FMC) to
 	  support external memories like sdram, psram & nand.
 	  This driver is for the sdram memory interface with the FMC.
+
+config DM_RAMDISK
+	bool "Enable Driver Model for RAMDISK drivers"
+	depends on DM
+	help
+	  This enables the Ramdisk uclass support. These appear as block devices
+	  in U-Boot.
+
+config RAMDISK_RO
+	bool "Enable read only ramdisk support"
+	depends on DM_RAMDISK
+	select RKRAM_PARTITION
+	help
+	  This enables the read only ramdisk support.
+
+config DM_DMC
+	bool "Enable Driver Model for DMC drivers"
+	depends on DM
+	help
+	  This config enables the driver-model DMC support.
+
+source "drivers/ram/rockchip/Kconfig"
diff --git a/drivers/ram/Makefile b/drivers/ram/Makefile
index 51ae6be655..39b9cadc35 100644
--- a/drivers/ram/Makefile
+++ b/drivers/ram/Makefile
@@ -4,9 +4,15 @@
 #
 # SPDX-License-Identifier:      GPL-2.0+
 #
-obj-$(CONFIG_RAM) += ram-uclass.o
+obj-$(CONFIG_$(SPL_TPL_)DM) += ram-uclass.o
 obj-$(CONFIG_SANDBOX) += sandbox_ram.o
 obj-$(CONFIG_STM32_SDRAM) += stm32_sdram.o
 obj-$(CONFIG_ARCH_BMIPS) += bmips_ram.o
 
 obj-$(CONFIG_ARCH_ROCKCHIP) += rockchip/
+
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_DM_DMC) += dmc-uclass.o
+obj-$(CONFIG_DM_RAMDISK) += ramdisk-uclass.o
+obj-$(CONFIG_RAMDISK_RO) += ramdisk_ro.o
+endif
diff --git a/drivers/ram/rockchip/Makefile b/drivers/ram/rockchip/Makefile
index b09d03c2c9..48df397a22 100644
--- a/drivers/ram/rockchip/Makefile
+++ b/drivers/ram/rockchip/Makefile
@@ -4,4 +4,27 @@
 # SPDX-License-Identifier:      GPL-2.0+
 #
 
-obj-$(CONFIG_ROCKCHIP_RK3368) = dmc-rk3368.o
+obj-$(CONFIG_ROCKCHIP_SDRAM_COMMON) += sdram_common.o
+obj-$(CONFIG_ROCKCHIP_RK3368) += dmc-rk3368.o
+obj-$(CONFIG_ROCKCHIP_RV1108) += sdram_rv1108_pctl_phy.o sdram_rv1108.o
+obj-$(CONFIG_ROCKCHIP_RV1106) += sdram_rv1106.o
+obj-$(CONFIG_ROCKCHIP_RV1126) += sdram_rv1126.o sdram_pctl_px30.o
+obj-$(CONFIG_ROCKCHIP_RK3128) += sdram_rk3128.o
+obj-$(CONFIG_ROCKCHIP_RK3188) += sdram_rk3188.o
+obj-$(CONFIG_ROCKCHIP_RK322X) += sdram_rk322x.o
+obj-$(CONFIG_ROCKCHIP_RK3288) += sdram_rk3288.o
+obj-$(CONFIG_ROCKCHIP_RK3308) += sdram_rv1108_pctl_phy.o sdram_rk3308.o
+obj-$(CONFIG_ROCKCHIP_RK3328) += sdram_rk3328.o sdram_pctl_px30.o sdram_phy_px30.o
+obj-$(CONFIG_ROCKCHIP_RK3399) += sdram_rk3399.o
+obj-$(CONFIG_ROCKCHIP_RK3568) += sdram_rk3568.o
+obj-$(CONFIG_ROCKCHIP_RK3588) += sdram_rk3588.o
+obj-$(CONFIG_ROCKCHIP_PX30) += sdram_px30.o sdram_pctl_px30.o sdram_phy_px30.o
+obj-$(CONFIG_ROCKCHIP_PX30) += rockchip_sdram.o
+obj-$(CONFIG_ROCKCHIP_RK1808) += rockchip_sdram.o
+obj-$(CONFIG_ROCKCHIP_RV1108) += rockchip_sdram.o
+obj-$(CONFIG_ROCKCHIP_RK3036) += rockchip_sdram.o
+obj-$(CONFIG_ROCKCHIP_RK3308) += rockchip_sdram.o
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
+obj-$(CONFIG_ROCKCHIP_DMC) += rockchip_dmc.o
+obj-$(CONFIG_ROCKCHIP_DMC_FSP) += dmc_fsp.o
+endif
diff --git a/drivers/ram/rockchip/dmc-rk3368.c b/drivers/ram/rockchip/dmc-rk3368.c
index ca7b1ff0c8..7de63dae28 100644
--- a/drivers/ram/rockchip/dmc-rk3368.c
+++ b/drivers/ram/rockchip/dmc-rk3368.c
@@ -13,12 +13,12 @@
 #include <regmap.h>
 #include <syscon.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/cru_rk3368.h>
-#include <asm/arch/grf_rk3368.h>
-#include <asm/arch/ddr_rk3368.h>
-#include <asm/arch/sdram.h>
-#include <asm/arch/sdram_common.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3368.h>
+#include <asm/arch-rockchip/grf_rk3368.h>
+#include <asm/arch-rockchip/ddr_rk3368.h>
+#include <asm/arch-rockchip/sdram_rk3288.h>
+#include <asm/arch-rockchip/sdram.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -230,7 +230,7 @@ static int memory_init(struct rk3368_ddr_pctl *pctl,
 	tmp = get_timer(0);
 	do {
 		if (get_timer(tmp) > timeout_ms) {
-			error("%s: POWER_UP_START did not complete in %ld ms\n",
+			pr_err("%s: POWER_UP_START did not complete in %ld ms\n",
 			      __func__, timeout_ms);
 			return -ETIME;
 		}
@@ -422,7 +422,7 @@ static int dfi_cfg(struct rk3368_ddr_pctl *pctl)
 	tmp = get_timer(0);
 	do {
 		if (get_timer(tmp) > timeout_ms) {
-			error("%s: DFI init did not complete within %ld ms\n",
+			pr_err("%s: DFI init did not complete within %ld ms\n",
 			      __func__, timeout_ms);
 			return -ETIME;
 		}
@@ -457,7 +457,7 @@ static int pctl_calc_timings(struct rk3368_sdram_params *params,
 	u32 tfaw_as_ps;
 
 	if (params->ddr_speed_bin != DDR3_1600K) {
-		error("%s: unimplemented DDR3 speed bin %d\n",
+		pr_err("%s: unimplemented DDR3 speed bin %d\n",
 		      __func__, params->ddr_speed_bin);
 		return -1;
 	}
@@ -585,7 +585,7 @@ static int ddrphy_data_training(struct rk3368_ddr_pctl *pctl,
 	tmp = get_timer(0);
 	do {
 		if (get_timer(tmp) > timeout_ms) {
-			error("%s: did not complete within %ld ms\n",
+			pr_err("%s: did not complete within %ld ms\n",
 			      __func__, timeout_ms);
 			return -ETIME;
 		}
@@ -625,7 +625,7 @@ static int sdram_col_row_detect(struct udevice *dev)
 	}
 
 	if (col == 8) {
-		error("%s: col detect error\n", __func__);
+		pr_err("%s: col detect error\n", __func__);
 		return -EINVAL;
 	}
 
@@ -644,7 +644,7 @@ static int sdram_col_row_detect(struct udevice *dev)
 	}
 
 	if (row == 11) {
-		error("%s: row detect error\n", __func__);
+		pr_err("%s: row detect error\n", __func__);
 		return -EINVAL;
 	}
 
@@ -764,7 +764,7 @@ static int msch_niu_config(struct rk3368_msch *msch,
 		}
 	}
 
-	error("%s: ddrconf (NIU config) not found\n", __func__);
+	pr_err("%s: ddrconf (NIU config) not found\n", __func__);
 	return -EINVAL;
 }
 
@@ -845,7 +845,11 @@ static int setup_sdram(struct udevice *dev)
 	move_to_access_state(pctl);
 
 	/* TODO(prt): could detect rank in training... */
+#ifdef CONFIG_TARGET_EVB_PX5
+	params->chan.rank = 1;
+#else
 	params->chan.rank = 2;
+#endif
 	/* TODO(prt): bus width is not auto-detected (yet)... */
 	params->chan.bw = 2;  /* 32bit wide bus */
 	params->chan.dbw = params->chan.dbw;  /* 32bit wide bus */
@@ -893,18 +897,11 @@ static int conv_of_platdata(struct udevice *dev)
 {
 	struct rk3368_sdram_params *plat = dev_get_platdata(dev);
 	struct dtd_rockchip_rk3368_dmc *of_plat = &plat->of_plat;
-	int ret;
 
 	plat->ddr_freq = of_plat->rockchip_ddr_frequency;
 	plat->ddr_speed_bin = of_plat->rockchip_ddr_speed_bin;
 	plat->memory_schedule = of_plat->rockchip_memory_schedule;
 
-	ret = regmap_init_mem_platdata(dev, of_plat->reg,
-				       ARRAY_SIZE(of_plat->reg) / 2,
-				       &plat->map);
-	if (ret)
-		return ret;
-
 	return 0;
 }
 #endif
@@ -933,8 +930,8 @@ static int rk3368_dmc_probe(struct udevice *dev)
 	debug("%s: pmugrf=%p\n", __func__, priv->pmugrf);
 
 #ifdef CONFIG_TPL_BUILD
-	pctl = regmap_get_range(plat->map, 0);
-	ddrphy = regmap_get_range(plat->map, 1);
+	pctl = (struct rk3368_ddr_pctl *)plat->of_plat.reg[0];
+	ddrphy = (struct rk3368_ddrphy *)plat->of_plat.reg[2];
 	msch = syscon_get_first_range(ROCKCHIP_SYSCON_MSCH);
 	grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
 
diff --git a/drivers/ram/stm32_sdram.c b/drivers/ram/stm32_sdram.c
index b1b0289a1b..fdf088e783 100644
--- a/drivers/ram/stm32_sdram.c
+++ b/drivers/ram/stm32_sdram.c
@@ -262,7 +262,7 @@ static int stm32_fmc_ofdata_to_platdata(struct udevice *dev)
 		bank_name = (char *)ofnode_get_name(bank_node);
 		strsep(&bank_name, "@");
 		if (!bank_name) {
-			error("missing sdram bank index");
+			pr_err("missing sdram bank index");
 			return -EINVAL;
 		}
 
@@ -271,7 +271,7 @@ static int stm32_fmc_ofdata_to_platdata(struct udevice *dev)
 			       (long unsigned int *)&bank_params->target_bank);
 
 		if (bank_params->target_bank >= MAX_SDRAM_BANK) {
-			error("Found bank %d , but only bank 0 and 1 are supported",
+			pr_err("Found bank %d , but only bank 0 and 1 are supported",
 			      bank_params->target_bank);
 			return -EINVAL;
 		}
@@ -285,7 +285,7 @@ static int stm32_fmc_ofdata_to_platdata(struct udevice *dev)
 						  sizeof(struct stm32_sdram_control));
 
 		if (!params->bank_params[bank].sdram_control) {
-			error("st,sdram-control not found for %s",
+			pr_err("st,sdram-control not found for %s",
 			      ofnode_get_name(bank_node));
 			return -EINVAL;
 		}
@@ -298,7 +298,7 @@ static int stm32_fmc_ofdata_to_platdata(struct udevice *dev)
 						  sizeof(struct stm32_sdram_timing));
 
 		if (!params->bank_params[bank].sdram_timing) {
-			error("st,sdram-timing not found for %s",
+			pr_err("st,sdram-timing not found for %s",
 			      ofnode_get_name(bank_node));
 			return -EINVAL;
 		}
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index e6af7da8fe..f045b9a163 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -12,6 +12,18 @@ config DM_RESET
 	  although driving such reset isgnals using GPIOs may be more
 	  appropriate in this case.
 
+config SPL_DM_RESET
+        bool "Enable reset controllers using Driver Model in SPL"
+        depends on SPL_DM && OF_CONTROL
+        help
+          Enable support for the reset controller driver class. Many hardware
+          modules are equipped with a reset signal, typically driven by some
+          reset controller hardware module within the chip. In U-Boot, reset
+          controller drivers allow control over these reset signals. In some
+          cases this API is applicable to chips outside the CPU as well,
+          although driving such reset isgnals using GPIOs may be more
+          appropriate in this case.
+
 config SANDBOX_RESET
 	bool "Enable the sandbox reset test driver"
 	depends on DM_MAILBOX && SANDBOX
@@ -67,4 +79,26 @@ config AST2500_RESET
 	  resets that are supported by watchdog. The main limitation though
 	  is that some reset signals, like I2C or MISC reset multiple devices.
 
+config RESET_ROCKCHIP
+	bool "Reset controller driver for Rockchip SoCs"
+	depends on DM_RESET && CLK
+	default y
+	help
+	  Support for reset controller on rockchip SoC. The main limitation though
+	  is that some reset signals, like I2C or MISC reset multiple devices.
+
+config SPL_RESET_ROCKCHIP
+        bool "Reset controller driver for Rockchip SoCs in SPL"
+        depends on SPL_DM_RESET && SPL_CLK
+        help
+          Support for reset controller on rockchip SoC. The main limitation though
+          is that some reset signals, like I2C or MISC reset multiple devices.
+
+config RESET_SCMI
+	bool "Enable SCMI reset domain driver"
+	select SCMI_FIRMWARE
+	help
+	  Enable this option if you want to support reset controller
+	  devices exposed by a SCMI agent based on SCMI reset domain
+	  protocol communication with a SCMI server.
 endmenu
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index d5e06c2241..92b0c41375 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -2,7 +2,7 @@
 #
 # SPDX-License-Identifier: GPL-2.0
 
-obj-$(CONFIG_DM_RESET) += reset-uclass.o
+obj-$(CONFIG_$(SPL_)DM_RESET) += reset-uclass.o
 obj-$(CONFIG_SANDBOX_MBOX) += sandbox-reset.o
 obj-$(CONFIG_SANDBOX_MBOX) += sandbox-reset-test.o
 obj-$(CONFIG_STI_RESET) += sti-reset.o
@@ -11,3 +11,5 @@ obj-$(CONFIG_TEGRA186_RESET) += tegra186-reset.o
 obj-$(CONFIG_RESET_BCM6345) += reset-bcm6345.o
 obj-$(CONFIG_RESET_UNIPHIER) += reset-uniphier.o
 obj-$(CONFIG_AST2500_RESET) += ast2500-reset.o
+obj-$(CONFIG_$(SPL_)RESET_ROCKCHIP) += reset-rockchip.o
+obj-$(CONFIG_RESET_SCMI) += reset-scmi.o
diff --git a/drivers/reset/reset-uclass.c b/drivers/reset/reset-uclass.c
index 307a29705f..fa4f6538ed 100644
--- a/drivers/reset/reset-uclass.c
+++ b/drivers/reset/reset-uclass.c
@@ -81,6 +81,40 @@ int reset_get_by_index(struct udevice *dev, int index,
 	return 0;
 }
 
+int reset_get_bulk(struct udevice *dev, struct reset_ctl_bulk *bulk)
+{
+	int i, ret, err, count;
+	
+	bulk->count = 0;
+
+	count = dev_count_phandle_with_args(dev, "resets", "#reset-cells");
+	if (count < 1)
+		return count;
+
+	bulk->resets = devm_kcalloc(dev, count, sizeof(struct reset_ctl),
+				    GFP_KERNEL);
+	if (!bulk->resets)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		ret = reset_get_by_index(dev, i, &bulk->resets[i]);
+		if (ret < 0)
+			goto bulk_get_err;
+
+		++bulk->count;
+	}
+
+	return 0;
+
+bulk_get_err:
+	err = reset_release_all(bulk->resets, bulk->count);
+	if (err)
+		debug("%s: could release all resets for %p\n",
+		      __func__, dev);
+
+	return ret;
+}
+
 int reset_get_by_name(struct udevice *dev, const char *name,
 		     struct reset_ctl *reset_ctl)
 {
@@ -126,6 +160,19 @@ int reset_assert(struct reset_ctl *reset_ctl)
 	return ops->rst_assert(reset_ctl);
 }
 
+int reset_assert_bulk(struct reset_ctl_bulk *bulk)
+{
+	int i, ret;
+
+	for (i = 0; i < bulk->count; i++) {
+		ret = reset_assert(&bulk->resets[i]);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 int reset_deassert(struct reset_ctl *reset_ctl)
 {
 	struct reset_ops *ops = reset_dev_ops(reset_ctl->dev);
@@ -135,6 +182,19 @@ int reset_deassert(struct reset_ctl *reset_ctl)
 	return ops->rst_deassert(reset_ctl);
 }
 
+int reset_deassert_bulk(struct reset_ctl_bulk *bulk)
+{
+	int i, ret;
+
+	for (i = 0; i < bulk->count; i++) {
+		ret = reset_deassert(&bulk->resets[i]);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 int reset_release_all(struct reset_ctl *reset_ctl, int count)
 {
 	int i, ret;
diff --git a/drivers/reset/sandbox-reset-test.c b/drivers/reset/sandbox-reset-test.c
index e37d6c91ef..f0ceaa0483 100644
--- a/drivers/reset/sandbox-reset-test.c
+++ b/drivers/reset/sandbox-reset-test.c
@@ -12,6 +12,7 @@
 
 struct sandbox_reset_test {
 	struct reset_ctl ctl;
+	struct reset_ctl_bulk bulk;
 };
 
 int sandbox_reset_test_get(struct udevice *dev)
@@ -21,6 +22,13 @@ int sandbox_reset_test_get(struct udevice *dev)
 	return reset_get_by_name(dev, "test", &sbrt->ctl);
 }
 
+int sandbox_reset_test_get_bulk(struct udevice *dev)
+{
+	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
+
+	return reset_get_bulk(dev, &sbrt->bulk);
+}
+
 int sandbox_reset_test_assert(struct udevice *dev)
 {
 	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
@@ -28,6 +36,13 @@ int sandbox_reset_test_assert(struct udevice *dev)
 	return reset_assert(&sbrt->ctl);
 }
 
+int sandbox_reset_test_assert_bulk(struct udevice *dev)
+{
+	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
+
+	return reset_assert_bulk(&sbrt->bulk);
+}
+
 int sandbox_reset_test_deassert(struct udevice *dev)
 {
 	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
@@ -35,6 +50,13 @@ int sandbox_reset_test_deassert(struct udevice *dev)
 	return reset_deassert(&sbrt->ctl);
 }
 
+int sandbox_reset_test_deassert_bulk(struct udevice *dev)
+{
+	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
+
+	return reset_deassert_bulk(&sbrt->bulk);
+}
+
 int sandbox_reset_test_free(struct udevice *dev)
 {
 	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
@@ -42,6 +64,13 @@ int sandbox_reset_test_free(struct udevice *dev)
 	return reset_free(&sbrt->ctl);
 }
 
+int sandbox_reset_test_release_bulk(struct udevice *dev)
+{
+	struct sandbox_reset_test *sbrt = dev_get_priv(dev);
+
+	return reset_release_bulk(&sbrt->bulk);
+}
+
 static const struct udevice_id sandbox_reset_test_ids[] = {
 	{ .compatible = "sandbox,reset-ctl-test" },
 	{ }
diff --git a/drivers/reset/sandbox-reset.c b/drivers/reset/sandbox-reset.c
index 4258af521b..c310749dc8 100644
--- a/drivers/reset/sandbox-reset.c
+++ b/drivers/reset/sandbox-reset.c
@@ -10,7 +10,7 @@
 #include <asm/io.h>
 #include <asm/reset.h>
 
-#define SANDBOX_RESET_SIGNALS 3
+#define SANDBOX_RESET_SIGNALS 101
 
 struct sandbox_reset_signal {
 	bool asserted;
diff --git a/drivers/reset/sti-reset.c b/drivers/reset/sti-reset.c
index a79708cde2..6616a58846 100644
--- a/drivers/reset/sti-reset.c
+++ b/drivers/reset/sti-reset.c
@@ -201,20 +201,20 @@ phys_addr_t sti_reset_get_regmap(const char *compatible)
 	node = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
 					     compatible);
 	if (node < 0) {
-		error("unable to find %s node\n", compatible);
+		pr_err("unable to find %s node\n", compatible);
 		return node;
 	}
 
 	ret = uclass_get_device_by_of_offset(UCLASS_SYSCON, node, &syscon);
 	if (ret) {
-		error("%s: uclass_get_device_by_of_offset failed: %d\n",
+		pr_err("%s: uclass_get_device_by_of_offset failed: %d\n",
 		      __func__, ret);
 		return ret;
 	}
 
 	regmap = syscon_get_regmap(syscon);
 	if (!regmap) {
-		error("unable to get regmap for %s\n", syscon->name);
+		pr_err("unable to get regmap for %s\n", syscon->name);
 		return -ENODEV;
 	}
 
@@ -251,7 +251,7 @@ static int sti_reset_program_hw(struct reset_ctl *reset_ctl, int assert)
 			if (ch->deassert_cnt > 0)
 				return 0;
 		} else
-			error("Reset balancing error: reset_ctl=%p dev=%p id=%lu\n",
+			pr_err("Reset balancing error: reset_ctl=%p dev=%p id=%lu\n",
 			      reset_ctl, reset_ctl->dev, reset_ctl->id);
 	}
 
@@ -266,9 +266,9 @@ static int sti_reset_program_hw(struct reset_ctl *reset_ctl, int assert)
 		return 0;
 
 	reg = (void __iomem *)base + ch->ack_offset;
-	if (wait_for_bit(__func__, reg, BIT(ch->ack_bit), ctrl_val,
-			 1000, false)) {
-		error("Stuck on waiting ack reset_ctl=%p dev=%p id=%lu\n",
+	if (wait_for_bit_le32(reg, BIT(ch->ack_bit), ctrl_val,
+			      1000, false)) {
+		pr_err("Stuck on waiting ack reset_ctl=%p dev=%p id=%lu\n",
 		      reset_ctl, reset_ctl->dev, reset_ctl->id);
 
 		return -ETIMEDOUT;
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index d06130c7a2..81f81e68be 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -30,4 +30,10 @@ config RTC_DS1307
 	  Support for Dallas Semiconductor (now Maxim) DS1307 and DS1338/9 and
 	  compatible Real Time Clock devices.
 
+config RTC_RK8XX
+	bool "Enable RK808/RK818/RK805/816/817 rtc support"
+	depends on DM_RTC && PMIC_RK8XX
+	help
+	  This adds a driver for the RK808/RK818/RK805/816/817 rtc support.
+
 endmenu
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 003e31aeba..c129d90ded 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -45,6 +45,7 @@ obj-$(CONFIG_RTC_PCF8563) += pcf8563.o
 obj-$(CONFIG_RTC_PCF2127) += pcf2127.o
 obj-$(CONFIG_RTC_PL031) += pl031.o
 obj-$(CONFIG_RTC_PT7C4338) += pt7c4338.o
+obj-$(CONFIG_RTC_RK8XX) += rk8xx_rtc.o
 obj-$(CONFIG_RTC_RS5C372A) += rs5c372.o
 obj-$(CONFIG_RTC_RV3029) += rv3029.o
 obj-$(CONFIG_RTC_RX8025) += rx8025.o
diff --git a/drivers/rtc/rtc-uclass.c b/drivers/rtc/rtc-uclass.c
index 89312c51ff..38e6b73839 100644
--- a/drivers/rtc/rtc-uclass.c
+++ b/drivers/rtc/rtc-uclass.c
@@ -120,6 +120,16 @@ int rtc_write32(struct udevice *dev, unsigned int reg, u32 value)
 	return 0;
 }
 
+int rtc_alarm_trigger(struct udevice *dev)
+{
+	const struct rtc_ops *ops = dev_get_driver_ops(dev);
+
+	if (!ops || !ops->alarm_trigger)
+		return 0;
+
+	return ops->alarm_trigger(dev);
+}
+
 UCLASS_DRIVER(rtc) = {
 	.name		= "rtc",
 	.id		= UCLASS_RTC,
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index aeed538fa4..b921f78b61 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -36,7 +36,7 @@ config SERIAL_PRESENT
 
 config SPL_SERIAL_PRESENT
 	bool "Provide a serial driver in SPL"
-	depends on DM_SERIAL
+	depends on SPL_DM_SERIAL
 	default y
 	help
 	  In very space-constrained devices even the full UART driver is too
@@ -81,8 +81,8 @@ config SERIAL_RX_BUFFER_SIZE
 
 config SPL_DM_SERIAL
 	bool "Enable Driver Model for serial drivers in SPL"
-	depends on DM_SERIAL
-	default y if SPL && DM_SERIAL
+	depends on DM_SERIAL && SPL
+	default y
 	help
 	  Enable driver model for serial in SPL. This replaces
 	  drivers/serial/serial.c with the serial uclass, which
@@ -91,8 +91,8 @@ config SPL_DM_SERIAL
 
 config TPL_DM_SERIAL
 	bool "Enable Driver Model for serial drivers in TPL"
-	depends on DM_SERIAL
-	default y if TPL && DM_SERIAL
+	depends on DM_SERIAL && TPL
+	default y
 	help
 	  Enable driver model for serial in TPL. This replaces
 	  drivers/serial/serial.c with the serial uclass, which
@@ -346,6 +346,12 @@ config DEBUG_UART_SKIP_INIT
 	  Select this if the UART you want to use for debug output is already
 	  initialized by the time U-Boot starts its execution.
 
+config DEBUG_UART_ALWAYS
+	bool "Always use debug UART mode"
+	default y if !ROCKCHIP_PX5
+	help
+	  Say y to always use debug UART, skip complicated console UART register.
+
 config ALTERA_JTAG_UART
 	bool "Altera JTAG UART support"
 	depends on DM_SERIAL
diff --git a/drivers/serial/ns16550.c b/drivers/serial/ns16550.c
index c702304e79..cb7cfa8ba7 100644
--- a/drivers/serial/ns16550.c
+++ b/drivers/serial/ns16550.c
@@ -246,6 +246,12 @@ static inline void _debug_uart_init(void)
 	struct NS16550 *com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
 	int baud_divisor;
 
+	if (gd && gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return;
+
+	if (gd && gd->serial.using_pre_serial)
+		return;
+
 	/*
 	 * We copy the code from above because it is already horribly messy.
 	 * Trying to refactor to nicely remove the duplication doesn't seem
@@ -266,13 +272,109 @@ static inline void _debug_uart_init(void)
 
 static inline void _debug_uart_putc(int ch)
 {
-	struct NS16550 *com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
+	struct NS16550 *com_port;
+
+	if (gd && gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return;
+
+	if (gd && gd->serial.addr)
+		com_port = (struct NS16550 *)gd->serial.addr;
+	else
+		com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
 
 	while (!(serial_din(&com_port->lsr) & UART_LSR_THRE))
 		;
 	serial_dout(&com_port->thr, ch);
 }
 
+static inline int _debug_uart_getc(void)
+{
+	struct NS16550 *com_port;
+
+	if (gd && gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return 0;
+
+	if (gd && gd->serial.addr)
+		com_port = (struct NS16550 *)gd->serial.addr;
+	else
+		com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
+
+	while (!(serial_din(&com_port->lsr) & UART_LSR_DR))
+		;
+
+	return serial_din(&com_port->rbr);
+}
+
+static inline int _debug_uart_tstc(int input)
+{
+	struct NS16550 *com_port;
+
+	if (gd && gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return 0;
+
+	if (gd && gd->serial.addr)
+		com_port = (struct NS16550 *)gd->serial.addr;
+	else
+		com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
+
+	if (input)
+		return serial_din(&com_port->lsr) & UART_LSR_DR ? 1 : 0;
+	else
+		return serial_din(&com_port->lsr) & UART_LSR_THRE ? 0 : 1;
+}
+
+static inline int _debug_uart_clrc(void)
+{
+	struct NS16550 *com_port;
+
+	if (gd && gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return 0;
+
+	if (gd && gd->serial.addr)
+		com_port = (struct NS16550 *)gd->serial.addr;
+	else
+		com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
+
+	/*
+	 * Wait fifo flush.
+	 *
+	 * UART_USR: bit2 trans_fifo_empty:
+	 *	0 = Transmit FIFO is not empty
+	 *	1 = Transmit FIFO is empty
+	 */
+	while (!(serial_din(&com_port->rbr + 0x1f) & 0x04))
+		;
+
+	return 0;
+}
+
+/* should use gd->baudrate, it can be updated by env callback: on_baudrate() */
+static inline int _debug_uart_setbrg(void)
+{
+	struct NS16550 *com_port;
+	int baud_divisor;
+
+	if (gd && gd->flags & GD_FLG_DISABLE_CONSOLE)
+		return 0;
+
+	if (gd && gd->serial.addr) {
+		com_port = (struct NS16550 *)gd->serial.addr;
+		baud_divisor = ns16550_calc_divisor(com_port,
+			CONFIG_DEBUG_UART_CLOCK, gd->baudrate);
+	} else {
+		com_port = (struct NS16550 *)CONFIG_DEBUG_UART_BASE;
+		baud_divisor = ns16550_calc_divisor(com_port,
+			CONFIG_DEBUG_UART_CLOCK, CONFIG_BAUDRATE);
+	}
+
+	serial_dout(&com_port->lcr, UART_LCR_BKSE | UART_LCRVAL);
+	serial_dout(&com_port->dll, baud_divisor & 0xff);
+	serial_dout(&com_port->dlm, (baud_divisor >> 8) & 0xff);
+	serial_dout(&com_port->lcr, UART_LCRVAL);
+
+	return 0;
+}
+
 DEBUG_UART_FUNCS
 
 #endif
@@ -318,8 +420,15 @@ static int ns16550_serial_putc(struct udevice *dev, const char ch)
 {
 	struct NS16550 *const com_port = dev_get_priv(dev);
 
-	if (!(serial_in(&com_port->lsr) & UART_LSR_THRE))
-		return -EAGAIN;
+	/*
+	 * Use fifo function.
+	 *
+	 * UART_USR: bit1 trans_fifo_not_full:
+	 *	0 = Transmit FIFO is full;
+	 *	1 = Transmit FIFO is not full;
+	 */
+	while (!(serial_in(&com_port->rbr + 0x1f) & 0x02))
+		;
 	serial_out(ch, &com_port->thr);
 
 	/*
@@ -367,6 +476,23 @@ static int ns16550_serial_setbrg(struct udevice *dev, int baudrate)
 	return 0;
 }
 
+static int ns16550_serial_clear(struct udevice *dev)
+{
+	struct NS16550 *const com_port = dev_get_priv(dev);
+
+	/*
+	 * Wait fifo flush.
+	 *
+	 * UART_USR: bit2 trans_fifo_empty:
+	 *	0 = Transmit FIFO is not empty
+	 *	1 = Transmit FIFO is empty
+	 */
+	while (!(serial_in(&com_port->rbr + 0x1f) & 0x04))
+		;
+
+	return 0;
+}
+
 int ns16550_serial_probe(struct udevice *dev)
 {
 	struct NS16550 *const com_port = dev_get_priv(dev);
@@ -395,7 +521,7 @@ int ns16550_serial_ofdata_to_platdata(struct udevice *dev)
 
 	/* try Processor Local Bus device first */
 	addr = dev_read_addr(dev);
-#if defined(CONFIG_PCI) && defined(CONFIG_DM_PCI)
+#if defined(CONFIG_PCI) && CONFIG_IS_ENABLED(DM_PCI)
 	if (addr == FDT_ADDR_T_NONE) {
 		/* then try pci device */
 		struct fdt_pci_addr pci_addr;
@@ -442,7 +568,7 @@ int ns16550_serial_ofdata_to_platdata(struct udevice *dev)
 		if (!IS_ERR_VALUE(err))
 			plat->clock = err;
 	} else if (err != -ENOENT && err != -ENODEV && err != -ENOSYS) {
-		debug("ns16550 failed to get clock\n");
+		printf("ns16550 failed to get clock, err=%d\n", err);
 		return err;
 	}
 
@@ -467,8 +593,10 @@ const struct dm_serial_ops ns16550_serial_ops = {
 	.pending = ns16550_serial_pending,
 	.getc = ns16550_serial_getc,
 	.setbrg = ns16550_serial_setbrg,
+	.clear = ns16550_serial_clear,
 };
 
+#if CONFIG_IS_ENABLED(SERIAL_PRESENT)
 #if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
 /*
  * Please consider existing compatible strings before adding a new
@@ -491,8 +619,6 @@ static const struct udevice_id ns16550_serial_ids[] = {
 };
 #endif /* OF_CONTROL && !OF_PLATDATA */
 
-#if CONFIG_IS_ENABLED(SERIAL_PRESENT)
-
 /* TODO(sjg@chromium.org): Integrate this into a macro like CONFIG_IS_ENABLED */
 #if !defined(CONFIG_TPL_BUILD) || defined(CONFIG_TPL_DM_SERIAL)
 U_BOOT_DRIVER(ns16550_serial) = {
diff --git a/drivers/serial/serial-uclass.c b/drivers/serial/serial-uclass.c
index 2e5116f7ce..2c37643224 100644
--- a/drivers/serial/serial-uclass.c
+++ b/drivers/serial/serial-uclass.c
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <debug_uart.h>
 #include <dm.h>
 #include <environment.h>
 #include <errno.h>
@@ -27,6 +28,7 @@ static const unsigned long baudrate_table[] = CONFIG_SYS_BAUDRATE_TABLE;
 #error "Serial is required before relocation - define CONFIG_$(SPL_)SYS_MALLOC_F_LEN to make this work"
 #endif
 
+#ifndef CONFIG_DEBUG_UART_ALWAYS
 static int serial_check_stdout(const void *blob, struct udevice **devp)
 {
 	int node;
@@ -134,6 +136,9 @@ int serial_init(void)
 
 	return 0;
 }
+#else
+int serial_init(void) { return 0; }
+#endif
 
 /* Called after relocation */
 void serial_initialize(void)
@@ -184,6 +189,14 @@ static int __serial_tstc(struct udevice *dev)
 	return 1;
 }
 
+static void __serial_clear(struct udevice *dev)
+{
+	struct dm_serial_ops *ops = serial_get_ops(dev);
+
+	if (ops->clear)
+		ops->clear(dev);
+}
+
 #if CONFIG_IS_ENABLED(SERIAL_RX_BUFFER)
 static int _serial_tstc(struct udevice *dev)
 {
@@ -226,42 +239,108 @@ void serial_putc(char ch)
 {
 	if (gd->cur_serial_dev)
 		_serial_putc(gd->cur_serial_dev, ch);
+	else
+		printch(ch);
 }
 
 void serial_puts(const char *str)
 {
 	if (gd->cur_serial_dev)
 		_serial_puts(gd->cur_serial_dev, str);
+	else
+		printascii(str);
 }
 
 int serial_getc(void)
 {
-	if (!gd->cur_serial_dev)
-		return 0;
-
-	return _serial_getc(gd->cur_serial_dev);
+	if (gd->cur_serial_dev)
+		return _serial_getc(gd->cur_serial_dev);
+	else
+		return debug_uart_getc();
 }
 
 int serial_tstc(void)
 {
-	if (!gd->cur_serial_dev)
-		return 0;
-
-	return _serial_tstc(gd->cur_serial_dev);
+	if (gd->cur_serial_dev)
+		return _serial_tstc(gd->cur_serial_dev);
+	else
+		return debug_uart_tstc();
 }
 
 void serial_setbrg(void)
 {
 	struct dm_serial_ops *ops;
 
-	if (!gd->cur_serial_dev)
+	if (!gd->cur_serial_dev) {
+		debug_uart_setbrg();
 		return;
+	}
 
 	ops = serial_get_ops(gd->cur_serial_dev);
 	if (ops->setbrg)
 		ops->setbrg(gd->cur_serial_dev, gd->baudrate);
 }
 
+void serial_clear(void)
+{
+	if (gd->cur_serial_dev)
+		__serial_clear(gd->cur_serial_dev);
+	else
+		debug_uart_clrc();
+}
+
+void serial_dev_putc(struct udevice *dev, char ch)
+{
+	if (!dev)
+		return;
+
+	_serial_putc(dev, ch);
+}
+
+void serial_dev_puts(struct udevice *dev, const char *str)
+{
+	if (!dev)
+		return;
+
+	_serial_puts(dev, str);
+}
+
+int serial_dev_getc(struct udevice *dev)
+{
+	if (!dev)
+		return 0;
+
+	return _serial_getc(dev);
+}
+
+int serial_dev_tstc(struct udevice *dev)
+{
+	if (!dev)
+		return 0;
+
+	return _serial_tstc(dev);
+}
+
+void serial_dev_setbrg(struct udevice *dev, int baudrate)
+{
+	struct dm_serial_ops *ops;
+
+	if (!dev)
+		return;
+
+	ops = serial_get_ops(dev);
+	if (ops->setbrg)
+		ops->setbrg(dev, baudrate);
+}
+
+void serial_dev_clear(struct udevice *dev)
+{
+	if (!dev)
+		return;
+
+	__serial_clear(dev);
+}
+
 void serial_stdio_init(void)
 {
 }
diff --git a/drivers/serial/serial_mpc8xx.c b/drivers/serial/serial_mpc8xx.c
index 26a8085a69..7a5908f464 100644
--- a/drivers/serial/serial_mpc8xx.c
+++ b/drivers/serial/serial_mpc8xx.c
@@ -6,10 +6,10 @@
  */
 
 #include <common.h>
-#include <commproc.h>
 #include <command.h>
 #include <serial.h>
 #include <watchdog.h>
+#include <asm/cpm_8xx.h>
 #include <linux/compiler.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/serial/serial_pic32.c b/drivers/serial/serial_pic32.c
index b0e01aa0e5..0632d26211 100644
--- a/drivers/serial/serial_pic32.c
+++ b/drivers/serial/serial_pic32.c
@@ -51,8 +51,8 @@ static int pic32_serial_init(void __iomem *base, ulong clk, u32 baudrate)
 	u32 div = DIV_ROUND_CLOSEST(clk, baudrate * 16);
 
 	/* wait for TX FIFO to empty */
-	wait_for_bit(__func__, base + U_STA, UART_TX_EMPTY,
-		     true, CONFIG_SYS_HZ, false);
+	wait_for_bit_le32(base + U_STA, UART_TX_EMPTY,
+			  true, CONFIG_SYS_HZ, false);
 
 	/* send break */
 	writel(UART_TX_BRK, base + U_STASET);
diff --git a/drivers/serial/serial_rockchip.c b/drivers/serial/serial_rockchip.c
index 734cee2ba4..c269bbdd76 100644
--- a/drivers/serial/serial_rockchip.c
+++ b/drivers/serial/serial_rockchip.c
@@ -10,7 +10,7 @@
 #include <dt-structs.h>
 #include <ns16550.h>
 #include <serial.h>
-#include <asm/arch/clock.h>
+#include <asm/arch-rockchip/clock.h>
 
 #if defined(CONFIG_ROCKCHIP_RK3188)
 struct rockchip_uart_platdata {
diff --git a/drivers/serial/usbtty.c b/drivers/serial/usbtty.c
index 353109c070..182385e499 100644
--- a/drivers/serial/usbtty.c
+++ b/drivers/serial/usbtty.c
@@ -525,7 +525,7 @@ int drv_usbtty_init (void)
 	char * tt;
 	int snlen;
 
-	/* Ger seiral number */
+	/* Get serial number */
 	sn = env_get("serial#");
 	if (!sn)
 		sn = "000000000000";
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 3c5582a950..5f6956deba 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -1,4 +1,7 @@
-menu "SPI Support"
+menuconfig SPI
+	bool "SPI Support"
+
+if SPI
 
 config DM_SPI
 	bool "Enable Driver Model for SPI drivers"
@@ -13,6 +16,13 @@ config DM_SPI
 	  typically use driver-private data instead of extending the
 	  spi_slave structure.
 
+config SPI_MEM
+	bool "SPI memory extension"
+	help
+	  Enable this option if you want to enable the SPI memory extension.
+	  This extension is meant to simplify interaction with SPI memories
+	  by providing an high-level interface to send memory-like commands.
+
 if DM_SPI
 
 config ALTERA_SPI
@@ -23,6 +33,13 @@ config ALTERA_SPI
 	  IP core. Please find details on the "Embedded Peripherals IP
 	  User Guide" of Altera.
 
+config ATCSPI200_SPI
+	bool "Andestech ATCSPI200 SPI driver"
+	help
+	  Enable the Andestech ATCSPI200 SPI driver. This driver can be
+	  used to access the SPI flash on AE3XX and AE250 platforms embedding
+	  this Andestech IP core.
+
 config ATH79_SPI
 	bool "Atheros SPI driver"
 	depends on ARCH_ATH79
@@ -34,12 +51,35 @@ config ATH79_SPI
 
 config ATMEL_SPI
 	bool "Atmel SPI driver"
-	depends on ARCH_AT91
+	default y if ARCH_AT91
 	help
 	  This enables driver for the Atmel SPI Controller, present on
 	  many AT91 (ARM) chips. This driver can be used to access
 	  the SPI Flash, such as AT25DF321.
 
+config BCM63XX_HSSPI
+	bool "BCM63XX HSSPI driver"
+	depends on ARCH_BMIPS
+	help
+	  Enable the BCM6328 HSSPI driver. This driver can be used to
+	  access the SPI NOR flash on platforms embedding this Broadcom
+	  SPI core.
+
+config BCM63XX_SPI
+	bool "BCM6348 SPI driver"
+	depends on ARCH_BMIPS
+	help
+	  Enable the BCM6348/BCM6358 SPI driver. This driver can be used to
+	  access the SPI NOR flash on platforms embedding these Broadcom
+	  SPI cores.
+
+config BCMSTB_SPI
+	bool "BCMSTB SPI driver"
+	help
+	  Enable the Broadcom set-top box SPI driver. This driver can
+	  be used to access the SPI flash on platforms embedding this
+	  Broadcom SPI core.
+
 config CADENCE_QSPI
 	bool "Cadence QSPI driver"
 	help
@@ -91,6 +131,14 @@ config PIC32_SPI
 	  to access the SPI NOR flash, MMC-over-SPI on platforms based on
 	  Microchip PIC32 family devices.
 
+config RENESAS_RPC_SPI
+	bool "Renesas RPC SPI driver"
+	depends on RCAR_GEN3
+	help
+	  Enable the Renesas RPC SPI driver, used to access SPI NOR flash
+	  on Renesas RCar Gen3 SoCs. This uses driver model and requires a
+	  device tree binding to operate.
+
 config ROCKCHIP_SPI
 	bool "Rockchip SPI driver"
 	help
@@ -99,6 +147,14 @@ config ROCKCHIP_SPI
 	  This uses driver model and requires a device tree binding to
 	  operate.
 
+config ROCKCHIP_SFC
+	bool "Rockchip SFC driver"
+	help
+	  Enable the Rockchip SFC driver, used to access SPI NOR flash
+	  on Rockchip SoCs.
+	  This uses driver model and requires a device tree binding to
+	  operate.
+
 config SANDBOX_SPI
 	bool "Sandbox SPI driver"
 	depends on SANDBOX && DM
@@ -196,6 +252,12 @@ config SOFT_SPI
 	 Enable Soft SPI driver. This driver is to use GPIO simulate
 	 the SPI protocol.
 
+config CF_SPI
+	bool "ColdFire SPI driver"
+	help
+	  Enable the ColdFire SPI driver. This driver can be used on
+	  some m68k SoCs.
+
 config FSL_ESPI
 	bool "Freescale eSPI driver"
 	help
@@ -210,18 +272,64 @@ config FSL_QSPI
 	  used to access the SPI NOR flash on platforms embedding this
 	  Freescale IP core.
 
+config DAVINCI_SPI
+	bool "Davinci & Keystone SPI driver"
+	depends on ARCH_DAVINCI || ARCH_KEYSTONE
+	help
+	  Enable the Davinci SPI driver
+
+config SH_SPI
+	bool "SuperH SPI driver"
+	help
+	  Enable the SuperH SPI controller driver. This driver can be used
+	  on various SuperH SoCs, such as SH7757.
+
+config SH_QSPI
+	bool "Renesas Quad SPI driver"
+	help
+	  Enable the Renesas Quad SPI controller driver. This driver can be
+	  used on Renesas SoCs.
+
 config TI_QSPI
 	bool "TI QSPI driver"
 	help
 	  Enable the TI Quad-SPI (QSPI) driver for DRA7xx and AM43xx evms.
 	  This driver support spi flash single, quad and memory reads.
 
+config KIRKWOOD_SPI
+	bool "Marvell Kirkwood SPI Driver"
+	help
+	  Enable support for SPI on various Marvell SoCs, such as
+	  Kirkwood and Armada 375.
+
+config LPC32XX_SSP
+	bool "LPC32XX SPI Driver"
+	help
+	  Enable support for SPI on LPC32xx
+
 config MPC8XX_SPI
 	bool "MPC8XX SPI Driver"
-	depends on 8xx
+	depends on MPC8xx
 	help
 	  Enable support for SPI on MPC8XX
 
+config MPC8XXX_SPI
+	bool "MPC8XXX SPI Driver"
+	help
+	  Enable support for SPI on the MPC8XXX PowerPC SoCs.
+
+config MXC_SPI
+	bool "MXC SPI Driver"
+	help
+	  Enable the MXC SPI controller driver. This driver can be used
+	  on various i.MX SoCs such as i.MX31/35/51/6/7.
+
+config MXS_SPI
+	bool "MXS SPI Driver"
+	help
+	  Enable the MXS SPI controller driver. This driver can be used
+	  on the i.MX23 and i.MX28 SoCs.
+
 config OMAP3_SPI
 	bool "McSPI driver for OMAP"
 	help
@@ -229,4 +337,4 @@ config OMAP3_SPI
 	  (McSPI). This driver be used to access SPI chips on platforms
 	  embedding this OMAP3 McSPI IP core.
 
-endmenu # menu "SPI Support"
+endif # menu "SPI Support"
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 9f8b86de76..1c8ae20fee 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -10,15 +10,19 @@ ifdef CONFIG_DM_SPI
 obj-y += spi-uclass.o
 obj-$(CONFIG_SANDBOX) += spi-emul-uclass.o
 obj-$(CONFIG_SOFT_SPI) += soft_spi.o
+obj-$(CONFIG_SPI_MEM) += spi-mem.o
 else
 obj-y += spi.o
+obj-$(CONFIG_SPI_MEM) += spi-mem-nodm.o
 obj-$(CONFIG_SOFT_SPI) += soft_spi_legacy.o
 endif
 
 obj-$(CONFIG_ALTERA_SPI) += altera_spi.o
 obj-$(CONFIG_ATH79_SPI) += ath79_spi.o
-obj-$(CONFIG_ATMEL_DATAFLASH_SPI) += atmel_dataflash_spi.o
 obj-$(CONFIG_ATMEL_SPI) += atmel_spi.o
+obj-$(CONFIG_BCM63XX_HSSPI) += bcm63xx_hsspi.o
+obj-$(CONFIG_BCM63XX_SPI) += bcm63xx_spi.o
+obj-$(CONFIG_BCMSTB_SPI) += bcmstb_spi.o
 obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o
 obj-$(CONFIG_CF_SPI) += cf_spi.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
@@ -35,9 +39,12 @@ obj-$(CONFIG_MPC8XXX_SPI) += mpc8xxx_spi.o
 obj-$(CONFIG_MVEBU_A3700_SPI) += mvebu_a3700_spi.o
 obj-$(CONFIG_MXC_SPI) += mxc_spi.o
 obj-$(CONFIG_MXS_SPI) += mxs_spi.o
+obj-$(CONFIG_ATCSPI200_SPI) += atcspi200_spi.o
 obj-$(CONFIG_OMAP3_SPI) += omap3_spi.o
 obj-$(CONFIG_PIC32_SPI) += pic32_spi.o
+obj-$(CONFIG_RENESAS_RPC_SPI) += renesas_rpc_spi.o
 obj-$(CONFIG_ROCKCHIP_SPI) += rk_spi.o
+obj-$(CONFIG_ROCKCHIP_SFC) += rockchip_sfc.o
 obj-$(CONFIG_SANDBOX_SPI) += sandbox_spi.o
 obj-$(CONFIG_SH_SPI) += sh_spi.o
 obj-$(CONFIG_SH_QSPI) += sh_qspi.o
diff --git a/drivers/spi/atmel_spi.c b/drivers/spi/atmel_spi.c
index e2f8342e88..3cdfd366ab 100644
--- a/drivers/spi/atmel_spi.c
+++ b/drivers/spi/atmel_spi.c
@@ -236,7 +236,9 @@ struct atmel_spi_priv {
 	unsigned int freq;		/* Default frequency */
 	unsigned int mode;
 	ulong bus_clk_rate;
+#ifdef CONFIG_DM_GPIO
 	struct gpio_desc cs_gpios[MAX_CS_COUNT];
+#endif
 };
 
 static int atmel_spi_claim_bus(struct udevice *dev)
@@ -291,6 +293,7 @@ static int atmel_spi_release_bus(struct udevice *dev)
 
 static void atmel_spi_cs_activate(struct udevice *dev)
 {
+#ifdef CONFIG_DM_GPIO
 	struct udevice *bus = dev_get_parent(dev);
 	struct atmel_spi_priv *priv = dev_get_priv(bus);
 	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
@@ -300,10 +303,12 @@ static void atmel_spi_cs_activate(struct udevice *dev)
 		return;
 
 	dm_gpio_set_value(&priv->cs_gpios[cs], 0);
+#endif
 }
 
 static void atmel_spi_cs_deactivate(struct udevice *dev)
 {
+#ifdef CONFIG_DM_GPIO
 	struct udevice *bus = dev_get_parent(dev);
 	struct atmel_spi_priv *priv = dev_get_priv(bus);
 	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
@@ -313,6 +318,7 @@ static void atmel_spi_cs_deactivate(struct udevice *dev)
 		return;
 
 	dm_gpio_set_value(&priv->cs_gpios[cs], 1);
+#endif
 }
 
 static int atmel_spi_xfer(struct udevice *dev, unsigned int bitlen,
@@ -394,8 +400,8 @@ out:
 		 * Wait until the transfer is completely done before
 		 * we deactivate CS.
 		 */
-		wait_for_bit(__func__, &reg_base->sr,
-			     ATMEL_SPI_SR_TXEMPTY, true, 1000, false);
+		wait_for_bit_le32(&reg_base->sr,
+				  ATMEL_SPI_SR_TXEMPTY, true, 1000, false);
 
 		atmel_spi_cs_deactivate(dev);
 	}
@@ -462,8 +468,7 @@ static int atmel_spi_enable_clk(struct udevice *bus)
 static int atmel_spi_probe(struct udevice *bus)
 {
 	struct atmel_spi_platdata *bus_plat = dev_get_platdata(bus);
-	struct atmel_spi_priv *priv = dev_get_priv(bus);
-	int i, ret;
+	int ret;
 
 	ret = atmel_spi_enable_clk(bus);
 	if (ret)
@@ -471,10 +476,14 @@ static int atmel_spi_probe(struct udevice *bus)
 
 	bus_plat->regs = (struct at91_spi *)devfdt_get_addr(bus);
 
+#ifdef CONFIG_DM_GPIO
+	struct atmel_spi_priv *priv = dev_get_priv(bus);
+	int i;
+
 	ret = gpio_request_list_by_name(bus, "cs-gpios", priv->cs_gpios,
 					ARRAY_SIZE(priv->cs_gpios), 0);
 	if (ret < 0) {
-		error("Can't get %s gpios! Error: %d", bus->name, ret);
+		pr_err("Can't get %s gpios! Error: %d", bus->name, ret);
 		return ret;
 	}
 
@@ -485,6 +494,7 @@ static int atmel_spi_probe(struct udevice *bus)
 		dm_gpio_set_dir_flags(&priv->cs_gpios[i],
 				      GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	}
+#endif
 
 	writel(ATMEL_SPI_CR_SWRST, &bus_plat->regs->cr);
 
diff --git a/drivers/spi/cadence_qspi.c b/drivers/spi/cadence_qspi.c
index 9a6e41f330..7b312f8e3e 100644
--- a/drivers/spi/cadence_qspi.c
+++ b/drivers/spi/cadence_qspi.c
@@ -212,7 +212,7 @@ static int cadence_spi_xfer(struct udevice *dev, unsigned int bitlen,
 
 	/* Set Chip select */
 	cadence_qspi_apb_chipselect(base, spi_chip_select(dev),
-				    CONFIG_CQSPI_DECODER);
+				    plat->is_decoded_cs);
 
 	if ((flags & SPI_XFER_END) || (flags == 0)) {
 		if (priv->cmd_len == 0) {
@@ -296,7 +296,11 @@ static int cadence_spi_ofdata_to_platdata(struct udevice *bus)
 
 	plat->regbase = (void *)data[0];
 	plat->ahbbase = (void *)data[2];
-	plat->sram_size = fdtdec_get_int(blob, node, "sram-size", 128);
+	plat->is_decoded_cs = fdtdec_get_bool(blob, node, "cdns,is-decoded-cs");
+	plat->fifo_depth = fdtdec_get_uint(blob, node, "cdns,fifo-depth", 128);
+	plat->fifo_width = fdtdec_get_uint(blob, node, "cdns,fifo-width", 4);
+	plat->trigger_address = fdtdec_get_uint(blob, node,
+						"cdns,trigger-address", 0);
 
 	/* All other paramters are embedded in the child node */
 	subnode = fdt_first_subnode(blob, node);
@@ -310,12 +314,12 @@ static int cadence_spi_ofdata_to_platdata(struct udevice *bus)
 				       500000);
 
 	/* Read other parameters from DT */
-	plat->page_size = fdtdec_get_int(blob, subnode, "page-size", 256);
-	plat->block_size = fdtdec_get_int(blob, subnode, "block-size", 16);
-	plat->tshsl_ns = fdtdec_get_int(blob, subnode, "tshsl-ns", 200);
-	plat->tsd2d_ns = fdtdec_get_int(blob, subnode, "tsd2d-ns", 255);
-	plat->tchsh_ns = fdtdec_get_int(blob, subnode, "tchsh-ns", 20);
-	plat->tslch_ns = fdtdec_get_int(blob, subnode, "tslch-ns", 20);
+	plat->page_size = fdtdec_get_uint(blob, subnode, "page-size", 256);
+	plat->block_size = fdtdec_get_uint(blob, subnode, "block-size", 16);
+	plat->tshsl_ns = fdtdec_get_uint(blob, subnode, "cdns,tshsl-ns", 200);
+	plat->tsd2d_ns = fdtdec_get_uint(blob, subnode, "cdns,tsd2d-ns", 255);
+	plat->tchsh_ns = fdtdec_get_uint(blob, subnode, "cdns,tchsh-ns", 20);
+	plat->tslch_ns = fdtdec_get_uint(blob, subnode, "cdns,tslch-ns", 20);
 
 	debug("%s: regbase=%p ahbbase=%p max-frequency=%d page-size=%d\n",
 	      __func__, plat->regbase, plat->ahbbase, plat->max_hz,
diff --git a/drivers/spi/cadence_qspi.h b/drivers/spi/cadence_qspi.h
index d1927a4003..9106b09d29 100644
--- a/drivers/spi/cadence_qspi.h
+++ b/drivers/spi/cadence_qspi.h
@@ -18,14 +18,18 @@ struct cadence_spi_platdata {
 	unsigned int	max_hz;
 	void		*regbase;
 	void		*ahbbase;
+	bool		is_decoded_cs;
+	u32		fifo_depth;
+	u32		fifo_width;
+	u32		trigger_address;
 
+	/* Flash parameters */
 	u32		page_size;
 	u32		block_size;
 	u32		tshsl_ns;
 	u32		tsd2d_ns;
 	u32		tchsh_ns;
 	u32		tslch_ns;
-	u32		sram_size;
 };
 
 struct cadence_spi_priv {
diff --git a/drivers/spi/cadence_qspi_apb.c b/drivers/spi/cadence_qspi_apb.c
index e02f2217f4..70d0f431ad 100644
--- a/drivers/spi/cadence_qspi_apb.c
+++ b/drivers/spi/cadence_qspi_apb.c
@@ -30,17 +30,12 @@
 #include <linux/errno.h>
 #include <wait_bit.h>
 #include <spi.h>
-#include <bouncebuf.h>
 #include "cadence_qspi.h"
 
 #define CQSPI_REG_POLL_US			1 /* 1us */
 #define CQSPI_REG_RETRY				10000
 #define CQSPI_POLL_IDLE_RETRY			3
 
-#define CQSPI_FIFO_WIDTH			4
-
-#define CQSPI_REG_SRAM_THRESHOLD_WORDS		50
-
 /* Transfer mode */
 #define CQSPI_INST_TYPE_SINGLE			0
 #define CQSPI_INST_TYPE_DUAL			1
@@ -51,9 +46,6 @@
 #define CQSPI_DUMMY_CLKS_PER_BYTE		8
 #define CQSPI_DUMMY_BYTES_MAX			4
 
-#define CQSPI_REG_SRAM_FILL_THRESHOLD	\
-	((CQSPI_REG_SRAM_SIZE_WORD / 2) * CQSPI_FIFO_WIDTH)
-
 /****************************************************************************
  * Controller's configuration and status register (offset from QSPI_BASE)
  ****************************************************************************/
@@ -400,7 +392,7 @@ void cadence_qspi_apb_controller_init(struct cadence_spi_platdata *plat)
 	writel(0, plat->regbase + CQSPI_REG_REMAP);
 
 	/* Indirect mode configurations */
-	writel((plat->sram_size/2), plat->regbase + CQSPI_REG_SRAMPARTITION);
+	writel(plat->fifo_depth / 2, plat->regbase + CQSPI_REG_SRAMPARTITION);
 
 	/* Disable all interrupts */
 	writel(0, plat->regbase + CQSPI_REG_IRQMASK);
@@ -560,7 +552,7 @@ int cadence_qspi_apb_indirect_read_setup(struct cadence_spi_platdata *plat,
 		addr_bytes = cmdlen - 1;
 
 	/* Setup the indirect trigger address */
-	writel((u32)plat->ahbbase,
+	writel(plat->trigger_address,
 	       plat->regbase + CQSPI_REG_INDIRECTTRIGGER);
 
 	/* Configure the opcode */
@@ -634,8 +626,6 @@ int cadence_qspi_apb_indirect_read_execute(struct cadence_spi_platdata *plat,
 {
 	unsigned int remaining = n_rx;
 	unsigned int bytes_to_read = 0;
-	struct bounce_buffer bb;
-	u8 *bb_rxbuf;
 	int ret;
 
 	writel(n_rx, plat->regbase + CQSPI_REG_INDIRECTRDBYTES);
@@ -644,11 +634,6 @@ int cadence_qspi_apb_indirect_read_execute(struct cadence_spi_platdata *plat,
 	writel(CQSPI_REG_INDIRECTRD_START,
 	       plat->regbase + CQSPI_REG_INDIRECTRD);
 
-	ret = bounce_buffer_start(&bb, (void *)rxbuf, n_rx, GEN_BB_WRITE);
-	if (ret)
-		return ret;
-	bb_rxbuf = bb.bounce_buffer;
-
 	while (remaining > 0) {
 		ret = cadence_qspi_wait_for_data(plat);
 		if (ret < 0) {
@@ -659,24 +644,27 @@ int cadence_qspi_apb_indirect_read_execute(struct cadence_spi_platdata *plat,
 		bytes_to_read = ret;
 
 		while (bytes_to_read != 0) {
-			bytes_to_read *= CQSPI_FIFO_WIDTH;
+			bytes_to_read *= plat->fifo_width;
 			bytes_to_read = bytes_to_read > remaining ?
 					remaining : bytes_to_read;
-			readsl(plat->ahbbase, bb_rxbuf, bytes_to_read >> 2);
-			if (bytes_to_read % 4)
-				readsb(plat->ahbbase,
-				       bb_rxbuf + rounddown(bytes_to_read, 4),
-				       bytes_to_read % 4);
-
-			bb_rxbuf += bytes_to_read;
+			/*
+			 * Handle non-4-byte aligned access to avoid
+			 * data abort.
+			 */
+			if (((uintptr_t)rxbuf % 4) || (bytes_to_read % 4))
+				readsb(plat->ahbbase, rxbuf, bytes_to_read);
+			else
+				readsl(plat->ahbbase, rxbuf,
+				       bytes_to_read >> 2);
+			rxbuf += bytes_to_read;
 			remaining -= bytes_to_read;
 			bytes_to_read = cadence_qspi_get_rd_sram_level(plat);
 		}
 	}
 
 	/* Check indirect done status */
-	ret = wait_for_bit("QSPI", plat->regbase + CQSPI_REG_INDIRECTRD,
-			   CQSPI_REG_INDIRECTRD_DONE, 1, 10, 0);
+	ret = wait_for_bit_le32(plat->regbase + CQSPI_REG_INDIRECTRD,
+				CQSPI_REG_INDIRECTRD_DONE, 1, 10, 0);
 	if (ret) {
 		printf("Indirect read completion error (%i)\n", ret);
 		goto failrd;
@@ -685,7 +673,6 @@ int cadence_qspi_apb_indirect_read_execute(struct cadence_spi_platdata *plat,
 	/* Clear indirect completion status */
 	writel(CQSPI_REG_INDIRECTRD_DONE,
 	       plat->regbase + CQSPI_REG_INDIRECTRD);
-	bounce_buffer_stop(&bb);
 
 	return 0;
 
@@ -693,7 +680,6 @@ failrd:
 	/* Cancel the indirect read */
 	writel(CQSPI_REG_INDIRECTRD_CANCEL,
 	       plat->regbase + CQSPI_REG_INDIRECTRD);
-	bounce_buffer_stop(&bb);
 	return ret;
 }
 
@@ -710,7 +696,7 @@ int cadence_qspi_apb_indirect_write_setup(struct cadence_spi_platdata *plat,
 		return -EINVAL;
 	}
 	/* Setup the indirect trigger address */
-	writel((u32)plat->ahbbase,
+	writel(plat->trigger_address,
 	       plat->regbase + CQSPI_REG_INDIRECTTRIGGER);
 
 	/* Configure the opcode */
@@ -735,17 +721,6 @@ int cadence_qspi_apb_indirect_write_execute(struct cadence_spi_platdata *plat,
 	unsigned int remaining = n_tx;
 	unsigned int write_bytes;
 	int ret;
-	struct bounce_buffer bb;
-	u8 *bb_txbuf;
-
-	/*
-	 * Handle non-4-byte aligned accesses via bounce buffer to
-	 * avoid data abort.
-	 */
-	ret = bounce_buffer_start(&bb, (void *)txbuf, n_tx, GEN_BB_READ);
-	if (ret)
-		return ret;
-	bb_txbuf = bb.bounce_buffer;
 
 	/* Configure the indirect read transfer bytes */
 	writel(n_tx, plat->regbase + CQSPI_REG_INDIRECTWRBYTES);
@@ -756,32 +731,31 @@ int cadence_qspi_apb_indirect_write_execute(struct cadence_spi_platdata *plat,
 
 	while (remaining > 0) {
 		write_bytes = remaining > page_size ? page_size : remaining;
-		writesl(plat->ahbbase, bb_txbuf, write_bytes >> 2);
-		if (write_bytes % 4)
-			writesb(plat->ahbbase,
-				bb_txbuf + rounddown(write_bytes, 4),
-				write_bytes % 4);
-
-		ret = wait_for_bit("QSPI", plat->regbase + CQSPI_REG_SDRAMLEVEL,
-				   CQSPI_REG_SDRAMLEVEL_WR_MASK <<
-				   CQSPI_REG_SDRAMLEVEL_WR_LSB, 0, 10, 0);
+		/* Handle non-4-byte aligned access to avoid data abort. */
+		if (((uintptr_t)txbuf % 4) || (write_bytes % 4))
+			writesb(plat->ahbbase, txbuf, write_bytes);
+		else
+			writesl(plat->ahbbase, txbuf, write_bytes >> 2);
+
+		ret = wait_for_bit_le32(plat->regbase + CQSPI_REG_SDRAMLEVEL,
+					CQSPI_REG_SDRAMLEVEL_WR_MASK <<
+					CQSPI_REG_SDRAMLEVEL_WR_LSB, 0, 10, 0);
 		if (ret) {
 			printf("Indirect write timed out (%i)\n", ret);
 			goto failwr;
 		}
 
-		bb_txbuf += write_bytes;
+		txbuf += write_bytes;
 		remaining -= write_bytes;
 	}
 
 	/* Check indirect done status */
-	ret = wait_for_bit("QSPI", plat->regbase + CQSPI_REG_INDIRECTWR,
-			   CQSPI_REG_INDIRECTWR_DONE, 1, 10, 0);
+	ret = wait_for_bit_le32(plat->regbase + CQSPI_REG_INDIRECTWR,
+				CQSPI_REG_INDIRECTWR_DONE, 1, 10, 0);
 	if (ret) {
 		printf("Indirect write completion error (%i)\n", ret);
 		goto failwr;
 	}
-	bounce_buffer_stop(&bb);
 
 	/* Clear indirect completion status */
 	writel(CQSPI_REG_INDIRECTWR_DONE,
@@ -792,7 +766,6 @@ failwr:
 	/* Cancel the indirect write */
 	writel(CQSPI_REG_INDIRECTWR_CANCEL,
 	       plat->regbase + CQSPI_REG_INDIRECTWR);
-	bounce_buffer_stop(&bb);
 	return ret;
 }
 
diff --git a/drivers/spi/cf_spi.c b/drivers/spi/cf_spi.c
index 7be9427781..68317ed633 100644
--- a/drivers/spi/cf_spi.c
+++ b/drivers/spi/cf_spi.c
@@ -288,14 +288,6 @@ int spi_cs_is_valid(unsigned int bus, unsigned int cs)
 		return 0;
 }
 
-void spi_init_f(void)
-{
-}
-
-void spi_init_r(void)
-{
-}
-
 void spi_init(void)
 {
 	cfspi_init();
diff --git a/drivers/spi/davinci_spi.c b/drivers/spi/davinci_spi.c
index 291ef9576a..eda252d0b3 100644
--- a/drivers/spi/davinci_spi.c
+++ b/drivers/spi/davinci_spi.c
@@ -563,6 +563,7 @@ static const struct dm_spi_ops davinci_spi_ops = {
 static const struct udevice_id davinci_spi_ids[] = {
 	{ .compatible = "ti,keystone-spi" },
 	{ .compatible = "ti,dm6441-spi" },
+	{ .compatible = "ti,da830-spi" },
 	{ }
 };
 
diff --git a/drivers/spi/designware_spi.c b/drivers/spi/designware_spi.c
index 5aa507b2d8..5e2d290ddc 100644
--- a/drivers/spi/designware_spi.c
+++ b/drivers/spi/designware_spi.c
@@ -10,15 +10,17 @@
  * SPDX-License-Identifier:	GPL-2.0
  */
 
+#include <asm-generic/gpio.h>
 #include <common.h>
+#include <clk.h>
 #include <dm.h>
 #include <errno.h>
 #include <malloc.h>
 #include <spi.h>
 #include <fdtdec.h>
 #include <linux/compat.h>
+#include <linux/iopoll.h>
 #include <asm/io.h>
-#include <asm/arch/clock_manager.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -94,6 +96,10 @@ struct dw_spi_priv {
 	void __iomem *regs;
 	unsigned int freq;		/* Default frequency */
 	unsigned int mode;
+	struct clk clk;
+	unsigned long bus_clk_rate;
+
+	struct gpio_desc cs_gpio;	/* External chip-select gpio */
 
 	int bits_per_word;
 	u8 cs;			/* chip select pin */
@@ -108,24 +114,40 @@ struct dw_spi_priv {
 	void *rx_end;
 };
 
-static inline u32 dw_readl(struct dw_spi_priv *priv, u32 offset)
+static inline u32 dw_read(struct dw_spi_priv *priv, u32 offset)
 {
 	return __raw_readl(priv->regs + offset);
 }
 
-static inline void dw_writel(struct dw_spi_priv *priv, u32 offset, u32 val)
+static inline void dw_write(struct dw_spi_priv *priv, u32 offset, u32 val)
 {
 	__raw_writel(val, priv->regs + offset);
 }
 
-static inline u16 dw_readw(struct dw_spi_priv *priv, u32 offset)
+static int request_gpio_cs(struct udevice *bus)
 {
-	return __raw_readw(priv->regs + offset);
-}
+#if defined(CONFIG_DM_GPIO) && !defined(CONFIG_SPL_BUILD)
+	struct dw_spi_priv *priv = dev_get_priv(bus);
+	int ret;
 
-static inline void dw_writew(struct dw_spi_priv *priv, u32 offset, u16 val)
-{
-	__raw_writew(val, priv->regs + offset);
+	/* External chip select gpio line is optional */
+	ret = gpio_request_by_name(bus, "cs-gpio", 0, &priv->cs_gpio, 0);
+	if (ret == -ENOENT)
+		return 0;
+
+	if (ret < 0) {
+		printf("Error: %d: Can't get %s gpio!\n", ret, bus->name);
+		return ret;
+	}
+
+	if (dm_gpio_is_valid(&priv->cs_gpio)) {
+		dm_gpio_set_dir_flags(&priv->cs_gpio,
+				      GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	}
+
+	debug("%s: used external gpio for CS management\n", __func__);
+#endif
+	return 0;
 }
 
 static int dw_spi_ofdata_to_platdata(struct udevice *bus)
@@ -142,19 +164,19 @@ static int dw_spi_ofdata_to_platdata(struct udevice *bus)
 	debug("%s: regs=%p max-frequency=%d\n", __func__, plat->regs,
 	      plat->frequency);
 
-	return 0;
+	return request_gpio_cs(bus);
 }
 
 static inline void spi_enable_chip(struct dw_spi_priv *priv, int enable)
 {
-	dw_writel(priv, DW_SPI_SSIENR, (enable ? 1 : 0));
+	dw_write(priv, DW_SPI_SSIENR, (enable ? 1 : 0));
 }
 
 /* Restart the controller, disable all interrupts, clean rx fifo */
 static void spi_hw_init(struct dw_spi_priv *priv)
 {
 	spi_enable_chip(priv, 0);
-	dw_writel(priv, DW_SPI_IMR, 0xff);
+	dw_write(priv, DW_SPI_IMR, 0xff);
 	spi_enable_chip(priv, 1);
 
 	/*
@@ -165,25 +187,64 @@ static void spi_hw_init(struct dw_spi_priv *priv)
 		u32 fifo;
 
 		for (fifo = 1; fifo < 256; fifo++) {
-			dw_writew(priv, DW_SPI_TXFLTR, fifo);
-			if (fifo != dw_readw(priv, DW_SPI_TXFLTR))
+			dw_write(priv, DW_SPI_TXFLTR, fifo);
+			if (fifo != dw_read(priv, DW_SPI_TXFLTR))
 				break;
 		}
 
 		priv->fifo_len = (fifo == 1) ? 0 : fifo;
-		dw_writew(priv, DW_SPI_TXFLTR, 0);
+		dw_write(priv, DW_SPI_TXFLTR, 0);
 	}
 	debug("%s: fifo_len=%d\n", __func__, priv->fifo_len);
 }
 
+/*
+ * We define dw_spi_get_clk function as 'weak' as some targets
+ * (like SOCFPGA_GEN5 and SOCFPGA_ARRIA10) don't use standard clock API
+ * and implement dw_spi_get_clk their own way in their clock manager.
+ */
+__weak int dw_spi_get_clk(struct udevice *bus, ulong *rate)
+{
+	struct dw_spi_priv *priv = dev_get_priv(bus);
+	int ret;
+
+	ret = clk_get_by_index(bus, 0, &priv->clk);
+	if (ret)
+		return ret;
+
+	ret = clk_enable(&priv->clk);
+	if (ret && ret != -ENOSYS && ret != -ENOTSUPP)
+		return ret;
+
+	*rate = clk_get_rate(&priv->clk);
+	if (!*rate)
+		goto err_rate;
+
+	debug("%s: get spi controller clk via device tree: %lu Hz\n",
+	      __func__, *rate);
+
+	return 0;
+
+err_rate:
+	clk_disable(&priv->clk);
+	clk_free(&priv->clk);
+
+	return -EINVAL;
+}
+
 static int dw_spi_probe(struct udevice *bus)
 {
 	struct dw_spi_platdata *plat = dev_get_platdata(bus);
 	struct dw_spi_priv *priv = dev_get_priv(bus);
+	int ret;
 
 	priv->regs = plat->regs;
 	priv->freq = plat->frequency;
 
+	ret = dw_spi_get_clk(bus, &priv->bus_clk_rate);
+	if (ret)
+		return ret;
+
 	/* Currently only bits_per_word == 8 supported */
 	priv->bits_per_word = 8;
 
@@ -201,7 +262,7 @@ static inline u32 tx_max(struct dw_spi_priv *priv)
 	u32 tx_left, tx_room, rxtx_gap;
 
 	tx_left = (priv->tx_end - priv->tx) / (priv->bits_per_word >> 3);
-	tx_room = priv->fifo_len - dw_readw(priv, DW_SPI_TXFLR);
+	tx_room = priv->fifo_len - dw_read(priv, DW_SPI_TXFLR);
 
 	/*
 	 * Another concern is about the tx/rx mismatch, we
@@ -222,7 +283,7 @@ static inline u32 rx_max(struct dw_spi_priv *priv)
 {
 	u32 rx_left = (priv->rx_end - priv->rx) / (priv->bits_per_word >> 3);
 
-	return min_t(u32, rx_left, dw_readw(priv, DW_SPI_RXFLR));
+	return min_t(u32, rx_left, dw_read(priv, DW_SPI_RXFLR));
 }
 
 static void dw_writer(struct dw_spi_priv *priv)
@@ -238,34 +299,22 @@ static void dw_writer(struct dw_spi_priv *priv)
 			else
 				txw = *(u16 *)(priv->tx);
 		}
-		dw_writew(priv, DW_SPI_DR, txw);
+		dw_write(priv, DW_SPI_DR, txw);
 		debug("%s: tx=0x%02x\n", __func__, txw);
 		priv->tx += priv->bits_per_word >> 3;
 	}
 }
 
-static int dw_reader(struct dw_spi_priv *priv)
+static void dw_reader(struct dw_spi_priv *priv)
 {
-	unsigned start = get_timer(0);
-	u32 max;
+	u32 max = rx_max(priv);
 	u16 rxw;
 
-	/* Wait for rx data to be ready */
-	while (rx_max(priv) == 0) {
-		if (get_timer(start) > RX_TIMEOUT)
-			return -ETIMEDOUT;
-	}
-
-	max = rx_max(priv);
-
 	while (max--) {
-		rxw = dw_readw(priv, DW_SPI_DR);
+		rxw = dw_read(priv, DW_SPI_DR);
 		debug("%s: rx=0x%02x\n", __func__, rxw);
 
-		/*
-		 * Care about rx only if the transfer's original "rx" is
-		 * not null
-		 */
+		/* Care about rx if the transfer's original "rx" is not null */
 		if (priv->rx_end - priv->len) {
 			if (priv->bits_per_word == 8)
 				*(u8 *)(priv->rx) = rxw;
@@ -274,24 +323,30 @@ static int dw_reader(struct dw_spi_priv *priv)
 		}
 		priv->rx += priv->bits_per_word >> 3;
 	}
-
-	return 0;
 }
 
 static int poll_transfer(struct dw_spi_priv *priv)
 {
-	int ret;
-
 	do {
 		dw_writer(priv);
-		ret = dw_reader(priv);
-		if (ret < 0)
-			return ret;
+		dw_reader(priv);
 	} while (priv->rx_end > priv->rx);
 
 	return 0;
 }
 
+static void external_cs_manage(struct udevice *dev, bool on)
+{
+#if defined(CONFIG_DM_GPIO) && !defined(CONFIG_SPL_BUILD)
+	struct dw_spi_priv *priv = dev_get_priv(dev->parent);
+
+	if (!dm_gpio_is_valid(&priv->cs_gpio))
+		return;
+
+	dm_gpio_set_value(&priv->cs_gpio, on ? 1 : 0);
+#endif
+}
+
 static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		       const void *dout, void *din, unsigned long flags)
 {
@@ -301,6 +356,7 @@ static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	u8 *rx = din;
 	int ret = 0;
 	u32 cr0 = 0;
+	u32 val;
 	u32 cs;
 
 	/* spi core configured to do 8 bit transfers */
@@ -309,6 +365,10 @@ static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		return -1;
 	}
 
+	/* Start the transaction if necessary. */
+	if (flags & SPI_XFER_BEGIN)
+		external_cs_manage(dev, false);
+
 	cr0 = (priv->bits_per_word - 1) | (priv->type << SPI_FRF_OFFSET) |
 		(priv->mode << SPI_MODE_OFFSET) |
 		(priv->tmode << SPI_TMOD_OFFSET);
@@ -318,7 +378,11 @@ static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	else if (rx)
 		priv->tmode = SPI_TMOD_RO;
 	else
-		priv->tmode = SPI_TMOD_TO;
+		/*
+		 * In transmit only mode (SPI_TMOD_TO) input FIFO never gets
+		 * any data which breaks our logic in poll_transfer() above.
+		 */
+		priv->tmode = SPI_TMOD_TR;
 
 	cr0 &= ~SPI_TMOD_MASK;
 	cr0 |= (priv->tmode << SPI_TMOD_OFFSET);
@@ -336,8 +400,8 @@ static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 
 	debug("%s: cr0=%08x\n", __func__, cr0);
 	/* Reprogram cr0 only if changed */
-	if (dw_readw(priv, DW_SPI_CTRL0) != cr0)
-		dw_writew(priv, DW_SPI_CTRL0, cr0);
+	if (dw_read(priv, DW_SPI_CTRL0) != cr0)
+		dw_write(priv, DW_SPI_CTRL0, cr0);
 
 	/*
 	 * Configure the desired SS (slave select 0...3) in the controller
@@ -345,7 +409,7 @@ static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	 * automatically. So no cs_activate() etc is needed in this driver.
 	 */
 	cs = spi_chip_select(dev);
-	dw_writel(priv, DW_SPI_SER, 1 << cs);
+	dw_write(priv, DW_SPI_SER, 1 << cs);
 
 	/* Enable controller after writing control registers */
 	spi_enable_chip(priv, 1);
@@ -353,6 +417,23 @@ static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	/* Start transfer in a polling loop */
 	ret = poll_transfer(priv);
 
+	/*
+	 * Wait for current transmit operation to complete.
+	 * Otherwise if some data still exists in Tx FIFO it can be
+	 * silently flushed, i.e. dropped on disabling of the controller,
+	 * which happens when writing 0 to DW_SPI_SSIENR which happens
+	 * in the beginning of new transfer.
+	 */
+	if (readl_poll_timeout(priv->regs + DW_SPI_SR, val,
+			       (val & SR_TF_EMPT) && !(val & SR_BUSY),
+			       RX_TIMEOUT * 1000)) {
+		ret = -ETIMEDOUT;
+	}
+
+	/* Stop the transaction if necessary */
+	if (flags & SPI_XFER_END)
+		external_cs_manage(dev, true);
+
 	return ret;
 }
 
@@ -369,9 +450,9 @@ static int dw_spi_set_speed(struct udevice *bus, uint speed)
 	spi_enable_chip(priv, 0);
 
 	/* clk_div doesn't support odd number */
-	clk_div = cm_get_spi_controller_clk_hz() / speed;
+	clk_div = priv->bus_clk_rate / speed;
 	clk_div = (clk_div + 1) & 0xfffe;
-	dw_writel(priv, DW_SPI_BAUDR, clk_div);
+	dw_write(priv, DW_SPI_BAUDR, clk_div);
 
 	/* Enable controller after writing control registers */
 	spi_enable_chip(priv, 1);
diff --git a/drivers/spi/fsl_dspi.c b/drivers/spi/fsl_dspi.c
index 42086197d9..41d1ba2fa5 100644
--- a/drivers/spi/fsl_dspi.c
+++ b/drivers/spi/fsl_dspi.c
@@ -396,16 +396,6 @@ void spi_init(void)
 	/* Nothing to do */
 }
 
-void spi_init_f(void)
-{
-	/* Nothing to do */
-}
-
-void spi_init_r(void)
-{
-	/* Nothing to do */
-}
-
 int spi_cs_is_valid(unsigned int bus, unsigned int cs)
 {
 	if (((cs >= 0) && (cs < 8)) && ((bus >= 0) && (bus < 8)))
diff --git a/drivers/spi/fsl_qspi.c b/drivers/spi/fsl_qspi.c
index 1dfa89afc9..5dc69a6865 100644
--- a/drivers/spi/fsl_qspi.c
+++ b/drivers/spi/fsl_qspi.c
@@ -14,12 +14,14 @@
 #include <dm.h>
 #include <errno.h>
 #include <watchdog.h>
+#include <wait_bit.h>
 #include "fsl_qspi.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
 #define RX_BUFFER_SIZE		0x80
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \
+	defined(CONFIG_MX6ULL) || defined(CONFIG_MX7D)
 #define TX_BUFFER_SIZE		0x200
 #else
 #define TX_BUFFER_SIZE		0x40
@@ -267,7 +269,8 @@ static void qspi_set_lut(struct fsl_qspi_priv *priv)
 			     INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
 			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
 #endif
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \
+	defined(CONFIG_MX6ULL) || defined(CONFIG_MX7D)
 	/*
 	 * To MX6SX, OPRND0(TX_BUFFER_SIZE) can not work correctly.
 	 * So, Use IDATSZ in IPCR to determine the size and here set 0.
@@ -663,22 +666,20 @@ static void qspi_op_write(struct fsl_qspi_priv *priv, u8 *txbuf, u32 len)
 	tx_size = (len > TX_BUFFER_SIZE) ?
 		TX_BUFFER_SIZE : len;
 
-	size = tx_size / 4;
-	for (i = 0; i < size; i++) {
+	size = tx_size / 16;
+	/*
+	 * There must be atleast 128bit data
+	 * available in TX FIFO for any pop operation
+	 */
+	if (tx_size % 16)
+		size++;
+	for (i = 0; i < size * 4; i++) {
 		memcpy(&data, txbuf, 4);
 		data = qspi_endian_xchg(data);
 		qspi_write32(priv->flags, &regs->tbdr, data);
 		txbuf += 4;
 	}
 
-	size = tx_size % 4;
-	if (size) {
-		data = 0;
-		memcpy(&data, txbuf, size);
-		data = qspi_endian_xchg(data);
-		qspi_write32(priv->flags, &regs->tbdr, data);
-	}
-
 	qspi_write32(priv->flags, &regs->ipcr,
 		     (seqid << QSPI_IPCR_SEQID_SHIFT) | tx_size);
 	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
@@ -906,6 +907,11 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	qspi->slave.max_write_size = TX_BUFFER_SIZE;
 
 	mcr_val = qspi_read32(qspi->priv.flags, &regs->mcr);
+
+	/* Set endianness to LE for i.mx */
+	if (IS_ENABLED(CONFIG_MX6) || IS_ENABLED(CONFIG_MX7))
+		mcr_val = QSPI_MCR_END_CFD_LE;
+
 	qspi_write32(qspi->priv.flags, &regs->mcr,
 		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK |
 		     (mcr_val & QSPI_MCR_END_CFD_MASK));
@@ -991,7 +997,7 @@ static int fsl_qspi_probe(struct udevice *bus)
 	struct fsl_qspi_platdata *plat = dev_get_platdata(bus);
 	struct fsl_qspi_priv *priv = dev_get_priv(bus);
 	struct dm_spi_bus *dm_spi_bus;
-	int i;
+	int i, ret;
 
 	dm_spi_bus = bus->uclass_priv;
 
@@ -1011,7 +1017,24 @@ static int fsl_qspi_probe(struct udevice *bus)
 	priv->flash_num = plat->flash_num;
 	priv->num_chipselect = plat->num_chipselect;
 
+	/* make sure controller is not busy anywhere */
+	ret = wait_for_bit_le32(&priv->regs->sr,
+				QSPI_SR_BUSY_MASK |
+				QSPI_SR_AHB_ACC_MASK |
+				QSPI_SR_IP_ACC_MASK,
+				false, 100, false);
+
+	if (ret) {
+		debug("ERROR : The controller is busy\n");
+		return ret;
+	}
+
 	mcr_val = qspi_read32(priv->flags, &priv->regs->mcr);
+
+	/* Set endianness to LE for i.mx */
+	if (IS_ENABLED(CONFIG_MX6) || IS_ENABLED(CONFIG_MX7))
+		mcr_val = QSPI_MCR_END_CFD_LE;
+
 	qspi_write32(priv->flags, &priv->regs->mcr,
 		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK |
 		     (mcr_val & QSPI_MCR_END_CFD_MASK));
@@ -1156,10 +1179,23 @@ static int fsl_qspi_claim_bus(struct udevice *dev)
 	struct fsl_qspi_priv *priv;
 	struct udevice *bus;
 	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
+	int ret;
 
 	bus = dev->parent;
 	priv = dev_get_priv(bus);
 
+	/* make sure controller is not busy anywhere */
+	ret = wait_for_bit_le32(&priv->regs->sr,
+				QSPI_SR_BUSY_MASK |
+				QSPI_SR_AHB_ACC_MASK |
+				QSPI_SR_IP_ACC_MASK,
+				false, 100, false);
+
+	if (ret) {
+		debug("ERROR : The controller is busy\n");
+		return ret;
+	}
+
 	priv->cur_amba_base = priv->amba_base[slave_plat->cs];
 
 	qspi_module_disable(priv, 0);
@@ -1203,6 +1239,8 @@ static const struct dm_spi_ops fsl_qspi_ops = {
 static const struct udevice_id fsl_qspi_ids[] = {
 	{ .compatible = "fsl,vf610-qspi" },
 	{ .compatible = "fsl,imx6sx-qspi" },
+	{ .compatible = "fsl,imx6ul-qspi" },
+	{ .compatible = "fsl,imx7d-qspi" },
 	{ }
 };
 
diff --git a/drivers/spi/fsl_qspi.h b/drivers/spi/fsl_qspi.h
index 6cb361018b..e468eb2529 100644
--- a/drivers/spi/fsl_qspi.h
+++ b/drivers/spi/fsl_qspi.h
@@ -105,6 +105,10 @@ struct fsl_qspi_regs {
 #define QSPI_RBCT_RXBRD_SHIFT		8
 #define QSPI_RBCT_RXBRD_USEIPS		(1 << QSPI_RBCT_RXBRD_SHIFT)
 
+#define QSPI_SR_AHB_ACC_SHIFT		2
+#define QSPI_SR_AHB_ACC_MASK		(1 << QSPI_SR_AHB_ACC_SHIFT)
+#define QSPI_SR_IP_ACC_SHIFT		1
+#define QSPI_SR_IP_ACC_MASK		(1 << QSPI_SR_IP_ACC_SHIFT)
 #define QSPI_SR_BUSY_SHIFT		0
 #define QSPI_SR_BUSY_MASK		(1 << QSPI_SR_BUSY_SHIFT)
 
diff --git a/drivers/spi/ich.c b/drivers/spi/ich.c
index 22fc83dd72..927bbd708f 100644
--- a/drivers/spi/ich.c
+++ b/drivers/spi/ich.c
@@ -184,6 +184,19 @@ static inline void spi_use_in(struct spi_trans *trans, unsigned bytes)
 	trans->bytesin -= bytes;
 }
 
+static void spi_lock_down(struct ich_spi_platdata *plat, void *sbase)
+{
+	if (plat->ich_version == ICHV_7) {
+		struct ich7_spi_regs *ich7_spi = sbase;
+
+		setbits_le16(&ich7_spi->spis, SPIS_LOCK);
+	} else if (plat->ich_version == ICHV_9) {
+		struct ich9_spi_regs *ich9_spi = sbase;
+
+		setbits_le16(&ich9_spi->hsfs, HSFS_FLOCKDN);
+	}
+}
+
 static bool spi_lock_status(struct ich_spi_platdata *plat, void *sbase)
 {
 	int lock = 0;
@@ -592,6 +605,12 @@ static int ich_spi_probe(struct udevice *dev)
 		return ret;
 	}
 
+	/* Lock down SPI controller settings if required */
+	if (plat->lockdown) {
+		ich_spi_config_opcode(dev);
+		spi_lock_down(plat, priv->base);
+	}
+
 	priv->cur_speed = priv->max_speed;
 
 	return 0;
@@ -662,6 +681,9 @@ static int ich_spi_ofdata_to_platdata(struct udevice *dev)
 			plat->ich_version = ICHV_9;
 	}
 
+	plat->lockdown = fdtdec_get_bool(gd->fdt_blob, node,
+					 "intel,spi-lock-down");
+
 	return ret;
 }
 
diff --git a/drivers/spi/ich.h b/drivers/spi/ich.h
index c867c57be9..06b7fb9e01 100644
--- a/drivers/spi/ich.h
+++ b/drivers/spi/ich.h
@@ -174,6 +174,7 @@ enum ich_version {
 
 struct ich_spi_platdata {
 	enum ich_version ich_version;	/* Controller version, 7 or 9 */
+	bool lockdown;			/* lock down controller settings? */
 };
 
 struct ich_spi_priv {
diff --git a/drivers/spi/kirkwood_spi.c b/drivers/spi/kirkwood_spi.c
index 0c6bd295cd..1ad8cdee64 100644
--- a/drivers/spi/kirkwood_spi.c
+++ b/drivers/spi/kirkwood_spi.c
@@ -243,6 +243,10 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 
 /* Here now the DM part */
 
+struct mvebu_spi_dev {
+	bool			is_errata_50mhz_ac;
+};
+
 struct mvebu_spi_platdata {
 	struct kwspi_registers *spireg;
 };
@@ -269,10 +273,44 @@ static int mvebu_spi_set_speed(struct udevice *bus, uint hz)
 	return 0;
 }
 
+static void mvebu_spi_50mhz_ac_timing_erratum(struct udevice *bus, uint mode)
+{
+	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
+	struct kwspi_registers *reg = plat->spireg;
+	u32 data;
+
+	/*
+	 * Erratum description: (Erratum NO. FE-9144572) The device
+	 * SPI interface supports frequencies of up to 50 MHz.
+	 * However, due to this erratum, when the device core clock is
+	 * 250 MHz and the SPI interfaces is configured for 50MHz SPI
+	 * clock and CPOL=CPHA=1 there might occur data corruption on
+	 * reads from the SPI device.
+	 * Erratum Workaround:
+	 * Work in one of the following configurations:
+	 * 1. Set CPOL=CPHA=0 in "SPI Interface Configuration
+	 * Register".
+	 * 2. Set TMISO_SAMPLE value to 0x2 in "SPI Timing Parameters 1
+	 * Register" before setting the interface.
+	 */
+	data = readl(&reg->timing1);
+	data &= ~KW_SPI_TMISO_SAMPLE_MASK;
+
+	if (CONFIG_SYS_TCLK == 250000000 &&
+	    mode & SPI_CPOL &&
+	    mode & SPI_CPHA)
+		data |= KW_SPI_TMISO_SAMPLE_2;
+	else
+		data |= KW_SPI_TMISO_SAMPLE_1;
+
+	writel(data, &reg->timing1);
+}
+
 static int mvebu_spi_set_mode(struct udevice *bus, uint mode)
 {
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
 	struct kwspi_registers *reg = plat->spireg;
+	const struct mvebu_spi_dev *drvdata;
 	u32 data = readl(&reg->cfg);
 
 	data &= ~(KWSPI_CPHA | KWSPI_CPOL | KWSPI_RXLSBF | KWSPI_TXLSBF);
@@ -286,6 +324,10 @@ static int mvebu_spi_set_mode(struct udevice *bus, uint mode)
 
 	writel(data, &reg->cfg);
 
+	drvdata = (struct mvebu_spi_dev *)dev_get_driver_data(bus);
+	if (drvdata->is_errata_50mhz_ac)
+		mvebu_spi_50mhz_ac_timing_erratum(bus, mode);
+
 	return 0;
 }
 
@@ -343,10 +385,31 @@ static const struct dm_spi_ops mvebu_spi_ops = {
 	 */
 };
 
+static const struct mvebu_spi_dev armada_xp_spi_dev_data = {
+	.is_errata_50mhz_ac = false,
+};
+
+static const struct mvebu_spi_dev armada_375_spi_dev_data = {
+	.is_errata_50mhz_ac = false,
+};
+
+static const struct mvebu_spi_dev armada_380_spi_dev_data = {
+	.is_errata_50mhz_ac = true,
+};
+
 static const struct udevice_id mvebu_spi_ids[] = {
-	{ .compatible = "marvell,armada-375-spi" },
-	{ .compatible = "marvell,armada-380-spi" },
-	{ .compatible = "marvell,armada-xp-spi" },
+	{
+		.compatible = "marvell,armada-375-spi",
+		.data = (ulong)&armada_375_spi_dev_data
+	},
+	{
+		.compatible = "marvell,armada-380-spi",
+		.data = (ulong)&armada_380_spi_dev_data
+	},
+	{
+		.compatible = "marvell,armada-xp-spi",
+		.data = (ulong)&armada_xp_spi_dev_data
+	},
 	{ }
 };
 
diff --git a/drivers/spi/lpc32xx_ssp.c b/drivers/spi/lpc32xx_ssp.c
index c5b766c0dd..e2a593b934 100644
--- a/drivers/spi/lpc32xx_ssp.c
+++ b/drivers/spi/lpc32xx_ssp.c
@@ -66,17 +66,17 @@ struct spi_slave *spi_setup_slave(uint bus, uint cs, uint max_hz, uint mode)
 	/* we only set up SSP0 for now, so ignore bus */
 
 	if (mode & SPI_3WIRE) {
-		error("3-wire mode not supported");
+		pr_err("3-wire mode not supported");
 		return NULL;
 	}
 
 	if (mode & SPI_SLAVE) {
-		error("slave mode not supported\n");
+		pr_err("slave mode not supported\n");
 		return NULL;
 	}
 
 	if (mode & SPI_PREAMBLE) {
-		error("preamble byte skipping not supported\n");
+		pr_err("preamble byte skipping not supported\n");
 		return NULL;
 	}
 
diff --git a/drivers/spi/mpc8xx_spi.c b/drivers/spi/mpc8xx_spi.c
index b5bd558526..eb035e9510 100644
--- a/drivers/spi/mpc8xx_spi.c
+++ b/drivers/spi/mpc8xx_spi.c
@@ -19,7 +19,7 @@
 
 #include <common.h>
 #include <mpc8xx.h>
-#include <commproc.h>
+#include <asm/cpm_8xx.h>
 #include <linux/ctype.h>
 #include <malloc.h>
 #include <post.h>
diff --git a/drivers/spi/mvebu_a3700_spi.c b/drivers/spi/mvebu_a3700_spi.c
index ec4907391c..d1708a8d56 100644
--- a/drivers/spi/mvebu_a3700_spi.c
+++ b/drivers/spi/mvebu_a3700_spi.c
@@ -95,8 +95,9 @@ static int spi_legacy_shift_byte(struct spi_reg *reg, unsigned int bytelen,
 	din_8 = din;
 
 	while (bytelen) {
-		ret = wait_for_bit(__func__, &reg->ctrl,
-				   MVEBU_SPI_A3700_XFER_RDY, true, 100, false);
+		ret = wait_for_bit_le32(&reg->ctrl,
+					MVEBU_SPI_A3700_XFER_RDY,
+					true,100, false);
 		if (ret)
 			return ret;
 
@@ -109,9 +110,9 @@ static int spi_legacy_shift_byte(struct spi_reg *reg, unsigned int bytelen,
 		writel(pending_dout, &reg->dout);
 
 		if (din) {
-			ret = wait_for_bit(__func__, &reg->ctrl,
-					   MVEBU_SPI_A3700_XFER_RDY,
-					   true, 100, false);
+			ret = wait_for_bit_le32(&reg->ctrl,
+						MVEBU_SPI_A3700_XFER_RDY,
+						true, 100, false);
 			if (ret)
 				return ret;
 
@@ -160,8 +161,9 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 
 	/* Deactivate CS */
 	if (flags & SPI_XFER_END) {
-		ret = wait_for_bit(__func__, &reg->ctrl,
-				   MVEBU_SPI_A3700_XFER_RDY, true, 100, false);
+		ret = wait_for_bit_le32(&reg->ctrl,
+					MVEBU_SPI_A3700_XFER_RDY,
+					true, 100, false);
 		if (ret)
 			return ret;
 
@@ -231,8 +233,8 @@ static int mvebu_spi_probe(struct udevice *bus)
 	/* Flush read/write FIFO */
 	data = readl(&reg->cfg);
 	writel(data | MVEBU_SPI_A3700_FIFO_FLUSH, &reg->cfg);
-	ret = wait_for_bit(__func__, &reg->cfg, MVEBU_SPI_A3700_FIFO_FLUSH,
-			   false, 1000, false);
+	ret = wait_for_bit_le32(&reg->cfg, MVEBU_SPI_A3700_FIFO_FLUSH,
+				false, 1000, false);
 	if (ret)
 		return ret;
 
diff --git a/drivers/spi/mxc_spi.c b/drivers/spi/mxc_spi.c
index e1562c36b7..41f0cfcd6b 100644
--- a/drivers/spi/mxc_spi.c
+++ b/drivers/spi/mxc_spi.c
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <malloc.h>
 #include <spi.h>
 #include <linux/errno.h>
@@ -14,6 +15,8 @@
 #include <asm/arch/clock.h>
 #include <asm/mach-imx/spi.h>
 
+DECLARE_GLOBAL_DATA_PTR;
+
 #ifdef CONFIG_MX27
 /* i.MX27 has a completely wrong register layout and register definitions in the
  * datasheet, the correct one is in the Freescale's Linux driver */
@@ -22,10 +25,6 @@
 "See linux mxc_spi driver from Freescale for details."
 #endif
 
-static unsigned long spi_bases[] = {
-	MXC_SPI_BASE_ADDRESSES
-};
-
 __weak int board_spi_cs_gpio(unsigned bus, unsigned cs)
 {
 	return -1;
@@ -51,6 +50,7 @@ struct mxc_spi_slave {
 	int		ss_pol;
 	unsigned int	max_hz;
 	unsigned int	mode;
+	struct gpio_desc ss;
 };
 
 static inline struct mxc_spi_slave *to_mxc_spi_slave(struct spi_slave *slave)
@@ -58,19 +58,24 @@ static inline struct mxc_spi_slave *to_mxc_spi_slave(struct spi_slave *slave)
 	return container_of(slave, struct mxc_spi_slave, slave);
 }
 
-void spi_cs_activate(struct spi_slave *slave)
+static void mxc_spi_cs_activate(struct mxc_spi_slave *mxcs)
 {
-	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
-	if (mxcs->gpio > 0)
-		gpio_set_value(mxcs->gpio, mxcs->ss_pol);
+	if (CONFIG_IS_ENABLED(DM_SPI)) {
+		dm_gpio_set_value(&mxcs->ss, mxcs->ss_pol);
+	} else {
+		if (mxcs->gpio > 0)
+			gpio_set_value(mxcs->gpio, mxcs->ss_pol);
+	}
 }
 
-void spi_cs_deactivate(struct spi_slave *slave)
+static void mxc_spi_cs_deactivate(struct mxc_spi_slave *mxcs)
 {
-	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
-	if (mxcs->gpio > 0)
-		gpio_set_value(mxcs->gpio,
-			      !(mxcs->ss_pol));
+	if (CONFIG_IS_ENABLED(DM_SPI)) {
+		dm_gpio_set_value(&mxcs->ss, !(mxcs->ss_pol));
+	} else {
+		if (mxcs->gpio > 0)
+			gpio_set_value(mxcs->gpio, !(mxcs->ss_pol));
+	}
 }
 
 u32 get_cspi_div(u32 div)
@@ -211,10 +216,9 @@ static s32 spi_cfg_mxc(struct mxc_spi_slave *mxcs, unsigned int cs)
 }
 #endif
 
-int spi_xchg_single(struct spi_slave *slave, unsigned int bitlen,
+int spi_xchg_single(struct mxc_spi_slave *mxcs, unsigned int bitlen,
 	const u8 *dout, u8 *din, unsigned long flags)
 {
-	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
 	int nbytes = DIV_ROUND_UP(bitlen, 8);
 	u32 data, cnt, i;
 	struct cspi_regs *regs = (struct cspi_regs *)mxcs->base;
@@ -327,8 +331,9 @@ int spi_xchg_single(struct spi_slave *slave, unsigned int bitlen,
 
 }
 
-int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
-		void *din, unsigned long flags)
+static int mxc_spi_xfer_internal(struct mxc_spi_slave *mxcs,
+				 unsigned int bitlen, const void *dout,
+				 void *din, unsigned long flags)
 {
 	int n_bytes = DIV_ROUND_UP(bitlen, 8);
 	int n_bits;
@@ -337,11 +342,11 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	u8 *p_outbuf = (u8 *)dout;
 	u8 *p_inbuf = (u8 *)din;
 
-	if (!slave)
-		return -1;
+	if (!mxcs)
+		return -EINVAL;
 
 	if (flags & SPI_XFER_BEGIN)
-		spi_cs_activate(slave);
+		mxc_spi_cs_activate(mxcs);
 
 	while (n_bytes > 0) {
 		if (n_bytes < MAX_SPI_BYTES)
@@ -351,7 +356,7 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 
 		n_bits = blk_size * 8;
 
-		ret = spi_xchg_single(slave, n_bits, p_outbuf, p_inbuf, 0);
+		ret = spi_xchg_single(mxcs, n_bits, p_outbuf, p_inbuf, 0);
 
 		if (ret)
 			return ret;
@@ -363,12 +368,39 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	}
 
 	if (flags & SPI_XFER_END) {
-		spi_cs_deactivate(slave);
+		mxc_spi_cs_deactivate(mxcs);
 	}
 
 	return 0;
 }
 
+static int mxc_spi_claim_bus_internal(struct mxc_spi_slave *mxcs, int cs)
+{
+	struct cspi_regs *regs = (struct cspi_regs *)mxcs->base;
+	int ret;
+
+	reg_write(&regs->rxdata, 1);
+	udelay(1);
+	ret = spi_cfg_mxc(mxcs, cs);
+	if (ret) {
+		printf("mxc_spi: cannot setup SPI controller\n");
+		return ret;
+	}
+	reg_write(&regs->period, MXC_CSPIPERIOD_32KHZ);
+	reg_write(&regs->intr, 0);
+
+	return 0;
+}
+
+#ifndef CONFIG_DM_SPI
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
+
+	return mxc_spi_xfer_internal(mxcs, bitlen, dout, din, flags);
+}
+
 void spi_init(void)
 {
 }
@@ -390,6 +422,7 @@ static int setup_cs_gpio(struct mxc_spi_slave *mxcs,
 	if (mxcs->gpio == -1)
 		return 0;
 
+	gpio_request(mxcs->gpio, "spi-cs");
 	ret = gpio_direction_output(mxcs->gpio, !(mxcs->ss_pol));
 	if (ret) {
 		printf("mxc_spi: cannot setup gpio %d\n", mxcs->gpio);
@@ -399,6 +432,10 @@ static int setup_cs_gpio(struct mxc_spi_slave *mxcs,
 	return 0;
 }
 
+static unsigned long spi_bases[] = {
+	MXC_SPI_BASE_ADDRESSES
+};
+
 struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 			unsigned int max_hz, unsigned int mode)
 {
@@ -443,24 +480,104 @@ void spi_free_slave(struct spi_slave *slave)
 
 int spi_claim_bus(struct spi_slave *slave)
 {
-	int ret;
 	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
-	struct cspi_regs *regs = (struct cspi_regs *)mxcs->base;
 
-	reg_write(&regs->rxdata, 1);
-	udelay(1);
-	ret = spi_cfg_mxc(mxcs, slave->cs);
+	return mxc_spi_claim_bus_internal(mxcs, slave->cs);
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	/* TODO: Shut the controller down */
+}
+#else
+
+static int mxc_spi_probe(struct udevice *bus)
+{
+	struct mxc_spi_slave *plat = bus->platdata;
+	struct mxc_spi_slave *mxcs = dev_get_platdata(bus);
+	int node = dev_of_offset(bus);
+	const void *blob = gd->fdt_blob;
+	int ret;
+
+	if (gpio_request_by_name(bus, "cs-gpios", 0, &plat->ss,
+				 GPIOD_IS_OUT)) {
+		dev_err(bus, "No cs-gpios property\n");
+		return -EINVAL;
+	}
+
+	plat->base = dev_get_addr(bus);
+	if (plat->base == FDT_ADDR_T_NONE)
+		return -ENODEV;
+
+	ret = dm_gpio_set_value(&plat->ss, !(mxcs->ss_pol));
 	if (ret) {
-		printf("mxc_spi: cannot setup SPI controller\n");
+		dev_err(bus, "Setting cs error\n");
 		return ret;
 	}
-	reg_write(&regs->period, MXC_CSPIPERIOD_32KHZ);
-	reg_write(&regs->intr, 0);
+
+	mxcs->max_hz = fdtdec_get_int(blob, node, "spi-max-frequency",
+				      20000000);
 
 	return 0;
 }
 
-void spi_release_bus(struct spi_slave *slave)
+static int mxc_spi_xfer(struct udevice *dev, unsigned int bitlen,
+		const void *dout, void *din, unsigned long flags)
 {
-	/* TODO: Shut the controller down */
+	struct mxc_spi_slave *mxcs = dev_get_platdata(dev->parent);
+
+
+	return mxc_spi_xfer_internal(mxcs, bitlen, dout, din, flags);
+}
+
+static int mxc_spi_claim_bus(struct udevice *dev)
+{
+	struct mxc_spi_slave *mxcs = dev_get_platdata(dev->parent);
+	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
+
+	return mxc_spi_claim_bus_internal(mxcs, slave_plat->cs);
 }
+
+static int mxc_spi_release_bus(struct udevice *dev)
+{
+	return 0;
+}
+
+static int mxc_spi_set_speed(struct udevice *bus, uint speed)
+{
+	/* Nothing to do */
+	return 0;
+}
+
+static int mxc_spi_set_mode(struct udevice *bus, uint mode)
+{
+	struct mxc_spi_slave *mxcs = dev_get_platdata(bus);
+
+	mxcs->mode = mode;
+	mxcs->ss_pol = (mode & SPI_CS_HIGH) ? 1 : 0;
+
+	return 0;
+}
+
+static const struct dm_spi_ops mxc_spi_ops = {
+	.claim_bus	= mxc_spi_claim_bus,
+	.release_bus	= mxc_spi_release_bus,
+	.xfer		= mxc_spi_xfer,
+	.set_speed	= mxc_spi_set_speed,
+	.set_mode	= mxc_spi_set_mode,
+};
+
+static const struct udevice_id mxc_spi_ids[] = {
+	{ .compatible = "fsl,imx51-ecspi" },
+	{ }
+};
+
+U_BOOT_DRIVER(mxc_spi) = {
+	.name	= "mxc_spi",
+	.id	= UCLASS_SPI,
+	.of_match = mxc_spi_ids,
+	.ops	= &mxc_spi_ops,
+	.platdata_auto_alloc_size = sizeof(struct mxc_spi_slave),
+	.probe	= mxc_spi_probe,
+};
+#endif
diff --git a/drivers/spi/omap3_spi.c b/drivers/spi/omap3_spi.c
index ebbdcaf14a..1ac691a68e 100644
--- a/drivers/spi/omap3_spi.c
+++ b/drivers/spi/omap3_spi.c
@@ -456,9 +456,6 @@ static void _omap3_spi_claim_bus(struct omap3_spi_priv *priv)
 	conf |= OMAP3_MCSPI_MODULCTRL_SINGLE;
 
 	writel(conf, &priv->regs->modulctrl);
-
-	_omap3_spi_set_mode(priv);
-	_omap3_spi_set_speed(priv);
 }
 
 #ifndef CONFIG_DM_SPI
@@ -548,7 +545,8 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	}
 
 	if (max_hz > OMAP3_MCSPI_MAX_FREQ) {
-		printf("SPI error: unsupported frequency %i Hz. Max frequency is 48 Mhz\n", max_hz);
+		printf("SPI error: unsupported frequency %i Hz. Max frequency is 48 MHz\n",
+		       max_hz);
 		return NULL;
 	}
 
@@ -593,8 +591,6 @@ static int omap3_spi_claim_bus(struct udevice *dev)
 	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
 
 	priv->cs = slave_plat->cs;
-	priv->mode = slave_plat->mode;
-	priv->freq = slave_plat->max_hz;
 	_omap3_spi_claim_bus(priv);
 
 	return 0;
@@ -634,8 +630,10 @@ static int omap3_spi_probe(struct udevice *dev)
 		(struct omap2_mcspi_platform_config*)dev_get_driver_data(dev);
 
 	priv->regs = (struct mcspi *)(devfdt_get_addr(dev) + data->regs_offset);
-	priv->pin_dir = fdtdec_get_uint(blob, node, "ti,pindir-d0-out-d1-in",
-					    MCSPI_PINDIR_D0_IN_D1_OUT);
+	if (fdtdec_get_bool(blob, node, "ti,pindir-d0-out-d1-in"))
+		priv->pin_dir = MCSPI_PINDIR_D0_OUT_D1_IN;
+	else
+		priv->pin_dir = MCSPI_PINDIR_D0_IN_D1_OUT;
 	priv->wordlen = SPI_DEFAULT_WORDLEN;
 	return 0;
 }
@@ -649,13 +647,29 @@ static int omap3_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	return _spi_xfer(priv, bitlen, dout, din, flags);
 }
 
-static int omap3_spi_set_speed(struct udevice *bus, unsigned int speed)
+static int omap3_spi_set_speed(struct udevice *dev, unsigned int speed)
 {
+	struct udevice *bus = dev->parent;
+	struct omap3_spi_priv *priv = dev_get_priv(bus);
+	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
+
+	priv->cs = slave_plat->cs;
+	priv->freq = slave_plat->max_hz;
+	_omap3_spi_set_speed(priv);
+
 	return 0;
 }
 
-static int omap3_spi_set_mode(struct udevice *bus, uint mode)
+static int omap3_spi_set_mode(struct udevice *dev, uint mode)
 {
+	struct udevice *bus = dev->parent;
+	struct omap3_spi_priv *priv = dev_get_priv(bus);
+	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
+
+	priv->cs = slave_plat->cs;
+	priv->mode = slave_plat->mode;
+	_omap3_spi_set_mode(priv);
+
 	return 0;
 }
 
diff --git a/drivers/spi/rk_spi.c b/drivers/spi/rk_spi.c
index c70d636277..860f7b1671 100644
--- a/drivers/spi/rk_spi.c
+++ b/drivers/spi/rk_spi.c
@@ -47,11 +47,13 @@ struct rockchip_spi_priv {
 	u8 n_bytes;
 	unsigned int speed_hz;
 	unsigned int last_speed_hz;
-	unsigned int tmode;
 	uint input_rate;
+	uint cr0;
+	u32 rsd;			/* Rx sample delay cycles */
 };
 
 #define SPI_FIFO_DEPTH		32
+#define SPI_CR0_RSD_MAX		0x3
 
 static void rkspi_dump_regs(struct rockchip_spi *regs)
 {
@@ -94,7 +96,7 @@ static void rkspi_set_clk(struct rockchip_spi_priv *priv, uint speed)
 	 */
 	if (clk_div > 0xfffe) {
 		clk_div = 0xfffe;
-		debug("%s: can't divide down to %d hz (actual will be %d hz)\n",
+		debug("%s: can't divide down to %d Hz (actual will be %d Hz)\n",
 		      __func__, speed, priv->input_rate / clk_div);
 	}
 
@@ -182,9 +184,10 @@ static int rockchip_spi_ofdata_to_platdata(struct udevice *bus)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rockchip_spi_platdata *plat = dev_get_platdata(bus);
 	struct rockchip_spi_priv *priv = dev_get_priv(bus);
+	u32 rsd_nsecs;
 	int ret;
 
-	plat->base = devfdt_get_addr(bus);
+	plat->base = dev_read_addr(bus);
 
 	ret = clk_get_by_index(bus, 0, &priv->clk);
 	if (ret < 0) {
@@ -200,9 +203,26 @@ static int rockchip_spi_ofdata_to_platdata(struct udevice *bus)
 	plat->activate_delay_us =
 		dev_read_u32_default(bus, "spi-activate-delay", 0);
 
-	debug("%s: base=%x, max-frequency=%d, deactivate_delay=%d\n",
+	rsd_nsecs = dev_read_u32_default(bus, "rx-sample-delay-ns", 0);
+	if (rsd_nsecs > 0) {
+		u32 spi_clk, rsd;
+
+		spi_clk = clk_get_rate(&priv->clk);
+		/* rx sample delay is expressed in parent clock cycles (max 3) */
+		rsd = DIV_ROUND_CLOSEST(rsd_nsecs * (spi_clk >> 8), 1000000000 >> 8);
+		if (!rsd) {
+			pr_err("SPI spi_clk %dHz are too slow to express %u ns delay\n", spi_clk, rsd_nsecs);
+		} else if (rsd > SPI_CR0_RSD_MAX) {
+			rsd = SPI_CR0_RSD_MAX;
+			pr_err("SPI spi_clk %dHz are too fast to express %u ns delay, clamping at %u ns\n",
+			       spi_clk, rsd_nsecs, SPI_CR0_RSD_MAX * 1000000000U / spi_clk);
+		}
+		priv->rsd = rsd;
+	}
+
+	debug("%s: base=%x, max-frequency=%d, deactivate_delay=%d rsd=%d\n",
 	      __func__, (uint)plat->base, plat->frequency,
-	      plat->deactivate_delay_us);
+	      plat->deactivate_delay_us, priv->rsd);
 #endif
 
 	return 0;
@@ -267,7 +287,6 @@ static int rockchip_spi_probe(struct udevice *bus)
 	priv->input_rate = ret;
 	debug("%s: rate = %u\n", __func__, priv->input_rate);
 	priv->bits_per_word = 8;
-	priv->tmode = TMOD_TR; /* Tx & Rx */
 
 	return 0;
 }
@@ -331,19 +350,36 @@ static int rockchip_spi_claim_bus(struct udevice *dev)
 	ctrlr0 |= spi_tf << HALF_WORD_TX_SHIFT;
 
 	/* Rxd Sample Delay */
-	ctrlr0 |= 0 << RXDSD_SHIFT;
+	ctrlr0 |= priv->rsd << RXDSD_SHIFT;
 
 	/* Frame Format */
 	ctrlr0 |= FRF_SPI << FRF_SHIFT;
 
-	/* Tx and Rx mode */
-	ctrlr0 |= (priv->tmode & TMOD_MASK) << TMOD_SHIFT;
+	/* Save static configuration */
+	priv->cr0 = ctrlr0;
 
 	writel(ctrlr0, &regs->ctrlr0);
 
 	return 0;
 }
 
+static int rockchip_spi_config(struct rockchip_spi_priv *priv, const void *dout)
+{
+	struct rockchip_spi *regs = priv->regs;
+	uint ctrlr0 = priv->cr0;
+	u32 tmod;
+
+	if (dout)
+		tmod = TMOD_TR;
+	else
+		tmod = TMOD_RO;
+
+	ctrlr0 |= (tmod & TMOD_MASK) << TMOD_SHIFT;
+	writel(ctrlr0, &regs->ctrlr0);
+
+	return 0;
+}
+
 static int rockchip_spi_release_bus(struct udevice *dev)
 {
 	struct udevice *bus = dev->parent;
@@ -367,6 +403,8 @@ static int rockchip_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	int toread, towrite;
 	int ret;
 
+	rockchip_spi_config(priv, dout);
+
 	debug("%s: dout=%p, din=%p, len=%x, flags=%lx\n", __func__, dout, din,
 	      len, flags);
 	if (DEBUG_RK_SPI)
@@ -453,6 +491,8 @@ static const struct udevice_id rockchip_spi_ids[] = {
 	{ .compatible = "rockchip,rk3288-spi" },
 	{ .compatible = "rockchip,rk3368-spi" },
 	{ .compatible = "rockchip,rk3399-spi" },
+	{ .compatible = "rockchip,rk3066-spi" },
+	{ .compatible = "rockchip,rk3328-spi" },
 	{ }
 };
 
diff --git a/drivers/spi/sandbox_spi.c b/drivers/spi/sandbox_spi.c
index 092b13b00b..a70d986508 100644
--- a/drivers/spi/sandbox_spi.c
+++ b/drivers/spi/sandbox_spi.c
@@ -8,6 +8,8 @@
  * Licensed under the GPL-2 or later.
  */
 
+#define LOG_CATEGORY UCLASS_SPI
+
 #include <common.h>
 #include <dm.h>
 #include <malloc.h>
@@ -58,7 +60,6 @@ static int sandbox_spi_xfer(struct udevice *slave, unsigned int bitlen,
 	struct udevice *emul;
 	uint bytes = bitlen / 8, i;
 	int ret;
-	u8 *tx = (void *)dout, *rx = din;
 	uint busnum, cs;
 
 	if (bitlen == 0)
@@ -89,37 +90,16 @@ static int sandbox_spi_xfer(struct udevice *slave, unsigned int bitlen,
 	if (ret)
 		return ret;
 
-	/* make sure rx/tx buffers are full so clients can assume */
-	if (!tx) {
-		debug("sandbox_spi: xfer: auto-allocating tx scratch buffer\n");
-		tx = malloc(bytes);
-		if (!tx) {
-			debug("sandbox_spi: Out of memory\n");
-			return -ENOMEM;
-		}
-	}
-	if (!rx) {
-		debug("sandbox_spi: xfer: auto-allocating rx scratch buffer\n");
-		rx = malloc(bytes);
-		if (!rx) {
-			debug("sandbox_spi: Out of memory\n");
-			return -ENOMEM;
-		}
-	}
-
 	ops = spi_emul_get_ops(emul);
 	ret = ops->xfer(emul, bitlen, dout, din, flags);
 
-	debug("sandbox_spi: xfer: got back %i (that's %s)\n rx:",
-	      ret, ret ? "bad" : "good");
-	for (i = 0; i < bytes; ++i)
-		debug(" %u:%02x", i, rx[i]);
-	debug("\n");
-
-	if (tx != dout)
-		free(tx);
-	if (rx != din)
-		free(rx);
+	log_content("sandbox_spi: xfer: got back %i (that's %s)\n rx:",
+		    ret, ret ? "bad" : "good");
+	if (din) {
+		for (i = 0; i < bytes; ++i)
+			log_content(" %u:%02x", i, ((u8 *)din)[i]);
+	}
+	log_content("\n");
 
 	return ret;
 }
@@ -144,11 +124,22 @@ static int sandbox_cs_info(struct udevice *bus, uint cs,
 	return 0;
 }
 
+static int sandbox_spi_get_mmap(struct udevice *dev, ulong *map_basep,
+				uint *map_sizep, uint *offsetp)
+{
+	*map_basep = 0x1000;
+	*map_sizep = 0x2000;
+	*offsetp = 0x100;
+
+	return 0;
+}
+
 static const struct dm_spi_ops sandbox_spi_ops = {
 	.xfer		= sandbox_spi_xfer,
 	.set_speed	= sandbox_spi_set_speed,
 	.set_mode	= sandbox_spi_set_mode,
 	.cs_info	= sandbox_cs_info,
+	.get_mmap	= sandbox_spi_get_mmap,
 };
 
 static const struct udevice_id sandbox_spi_ids[] = {
diff --git a/drivers/spi/sh_qspi.c b/drivers/spi/sh_qspi.c
index 75999c812d..5075be3cd1 100644
--- a/drivers/spi/sh_qspi.c
+++ b/drivers/spi/sh_qspi.c
@@ -11,6 +11,7 @@
 #include <console.h>
 #include <malloc.h>
 #include <spi.h>
+#include <wait_bit.h>
 #include <asm/arch/rmobile.h>
 #include <asm/io.h>
 
@@ -35,33 +36,35 @@
 			SPCMD_BRDV0
 #define SPBFCR_TXRST	BIT(7)
 #define SPBFCR_RXRST	BIT(6)
+#define SPBFCR_TXTRG	0x30
+#define SPBFCR_RXTRG	0x07
 
 /* SH QSPI register set */
 struct sh_qspi_regs {
-	unsigned char spcr;
-	unsigned char sslp;
-	unsigned char sppcr;
-	unsigned char spsr;
-	unsigned long spdr;
-	unsigned char spscr;
-	unsigned char spssr;
-	unsigned char spbr;
-	unsigned char spdcr;
-	unsigned char spckd;
-	unsigned char sslnd;
-	unsigned char spnd;
-	unsigned char dummy0;
-	unsigned short spcmd0;
-	unsigned short spcmd1;
-	unsigned short spcmd2;
-	unsigned short spcmd3;
-	unsigned char spbfcr;
-	unsigned char dummy1;
-	unsigned short spbdcr;
-	unsigned long spbmul0;
-	unsigned long spbmul1;
-	unsigned long spbmul2;
-	unsigned long spbmul3;
+	u8	spcr;
+	u8	sslp;
+	u8	sppcr;
+	u8	spsr;
+	u32	spdr;
+	u8	spscr;
+	u8	spssr;
+	u8	spbr;
+	u8	spdcr;
+	u8	spckd;
+	u8	sslnd;
+	u8	spnd;
+	u8	dummy0;
+	u16	spcmd0;
+	u16	spcmd1;
+	u16	spcmd2;
+	u16	spcmd3;
+	u8	spbfcr;
+	u8	dummy1;
+	u16	spbdcr;
+	u32	spbmul0;
+	u32	spbmul1;
+	u32	spbmul2;
+	u32	spbmul3;
 };
 
 struct sh_qspi_slave {
@@ -200,11 +203,11 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 	     void *din, unsigned long flags)
 {
 	struct sh_qspi_slave *ss = to_sh_qspi(slave);
-	unsigned long nbyte;
-	int ret = 0;
-	unsigned char dtdata = 0, drdata;
-	unsigned char *tdata = &dtdata, *rdata = &drdata;
-	unsigned long *spbmul0 = &ss->regs->spbmul0;
+	u32 nbyte, chunk;
+	int i, ret = 0;
+	u8 dtdata = 0, drdata;
+	u8 *tdata = &dtdata, *rdata = &drdata;
+	u32 *spbmul0 = &ss->regs->spbmul0;
 
 	if (dout == NULL && din == NULL) {
 		if (flags & SPI_XFER_END)
@@ -230,46 +233,44 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		writel(nbyte, spbmul0);
 
 	if (dout != NULL)
-		tdata = (unsigned char *)dout;
+		tdata = (u8 *)dout;
 
 	if (din != NULL)
 		rdata = din;
 
 	while (nbyte > 0) {
-		while (!(readb(&ss->regs->spsr) & SPSR_SPTEF)) {
-			if (ctrlc()) {
-				puts("abort\n");
-				return 1;
-			}
-			udelay(10);
+		/*
+		 * Check if there is 32 Byte chunk and if there is, transfer
+		 * it in one burst, otherwise transfer on byte-by-byte basis.
+		 */
+		chunk = (nbyte >= 32) ? 32 : 1;
+
+		clrsetbits_8(&ss->regs->spbfcr, SPBFCR_TXTRG | SPBFCR_RXTRG,
+			     chunk == 32 ? SPBFCR_TXTRG | SPBFCR_RXTRG : 0);
+
+		ret = wait_for_bit_8(&ss->regs->spsr, SPSR_SPTEF,
+				     true, 1000, true);
+		if (ret)
+			return ret;
+
+		for (i = 0; i < chunk; i++) {
+			writeb(*tdata, &ss->regs->spdr);
+			if (dout != NULL)
+				tdata++;
 		}
 
-		writeb(*tdata, (unsigned char *)(&ss->regs->spdr));
+		ret = wait_for_bit_8(&ss->regs->spsr, SPSR_SPRFF,
+				     true, 1000, true);
+		if (ret)
+			return ret;
 
-		while ((readw(&ss->regs->spbdcr) != SPBDCR_RXBC0)) {
-			if (ctrlc()) {
-				puts("abort\n");
-				return 1;
-			}
-			udelay(1);
+		for (i = 0; i < chunk; i++) {
+			*rdata = readb(&ss->regs->spdr);
+			if (din != NULL)
+				rdata++;
 		}
 
-		while (!(readb(&ss->regs->spsr) & SPSR_SPRFF)) {
-			if (ctrlc()) {
-				puts("abort\n");
-				return 1;
-			}
-			udelay(10);
-		}
-
-		*rdata = readb((unsigned char *)(&ss->regs->spdr));
-
-		if (dout != NULL)
-			tdata++;
-		if (din != NULL)
-			rdata++;
-
-		nbyte--;
+		nbyte -= chunk;
 	}
 
 	if (flags & SPI_XFER_END)
diff --git a/drivers/spi/spi-uclass.c b/drivers/spi/spi-uclass.c
index e06a603ab1..2a0c212e6c 100644
--- a/drivers/spi/spi-uclass.c
+++ b/drivers/spi/spi-uclass.c
@@ -16,6 +16,8 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define SPI_DEFAULT_SPEED_HZ 100000
+
 static int spi_set_speed_mode(struct udevice *bus, int speed, int mode)
 {
 	struct dm_spi_ops *ops;
@@ -49,26 +51,31 @@ int dm_spi_claim_bus(struct udevice *dev)
 	struct dm_spi_ops *ops = spi_get_ops(bus);
 	struct dm_spi_bus *spi = dev_get_uclass_priv(bus);
 	struct spi_slave *slave = dev_get_parent_priv(dev);
-	int speed;
-	int ret;
+	uint speed, mode;
 
 	speed = slave->max_hz;
+	mode = slave->mode;
+
 	if (spi->max_hz) {
 		if (speed)
-			speed = min(speed, (int)spi->max_hz);
+			speed = min(speed, spi->max_hz);
 		else
 			speed = spi->max_hz;
 	}
 	if (!speed)
-		speed = 100000;
-	if (speed != slave->speed) {
-		ret = spi_set_speed_mode(bus, speed, slave->mode);
+		speed = SPI_DEFAULT_SPEED_HZ;
+
+	if (speed != spi->speed || mode != spi->mode) {
+		int ret = spi_set_speed_mode(bus, speed, slave->mode);
+
 		if (ret)
-			return ret;
-		slave->speed = speed;
+			return log_ret(ret);
+
+		spi->speed = speed;
+		spi->mode = mode;
 	}
 
-	return ops->claim_bus ? ops->claim_bus(dev) : 0;
+	return log_ret(ops->claim_bus ? ops->claim_bus(dev) : 0);
 }
 
 void dm_spi_release_bus(struct udevice *dev)
@@ -84,16 +91,33 @@ int dm_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		const void *dout, void *din, unsigned long flags)
 {
 	struct udevice *bus = dev->parent;
+	struct dm_spi_ops *ops = spi_get_ops(bus);
 
 	if (bus->uclass->uc_drv->id != UCLASS_SPI)
 		return -EOPNOTSUPP;
+	if (!ops->xfer)
+		return -ENOSYS;
 
-	return spi_get_ops(bus)->xfer(dev, bitlen, dout, din, flags);
+	return ops->xfer(dev, bitlen, dout, din, flags);
+}
+
+int dm_spi_get_mmap(struct udevice *dev, ulong *map_basep, uint *map_sizep,
+		    uint *offsetp)
+{
+	struct udevice *bus = dev->parent;
+	struct dm_spi_ops *ops = spi_get_ops(bus);
+
+	if (bus->uclass->uc_drv->id != UCLASS_SPI)
+		return -EOPNOTSUPP;
+	if (!ops->get_mmap)
+		return -ENOSYS;
+
+	return ops->get_mmap(dev, map_basep, map_sizep, offsetp);
 }
 
 int spi_claim_bus(struct spi_slave *slave)
 {
-	return dm_spi_claim_bus(slave->dev);
+	return log_ret(dm_spi_claim_bus(slave->dev));
 }
 
 void spi_release_bus(struct spi_slave *slave)
@@ -107,6 +131,30 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 	return dm_spi_xfer(slave->dev, bitlen, dout, din, flags);
 }
 
+int spi_write_then_read(struct spi_slave *slave, const u8 *opcode,
+			size_t n_opcode, const u8 *txbuf, u8 *rxbuf,
+			size_t n_buf)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	int ret;
+
+	if (n_buf == 0)
+		flags |= SPI_XFER_END;
+
+	ret = spi_xfer(slave, n_opcode * 8, opcode, NULL, flags);
+	if (ret) {
+		debug("spi: failed to send command (%zu bytes): %d\n",
+		      n_opcode, ret);
+	} else if (n_buf != 0) {
+		ret = spi_xfer(slave, n_buf * 8, txbuf, rxbuf, SPI_XFER_END);
+		if (ret)
+			debug("spi: failed to transfer %zu bytes of data: %d\n",
+			      n_buf, ret);
+	}
+
+	return ret;
+}
+
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 static int spi_child_post_bind(struct udevice *dev)
 {
@@ -128,22 +176,25 @@ static int spi_post_probe(struct udevice *bus)
 #endif
 #if defined(CONFIG_NEEDS_MANUAL_RELOC)
 	struct dm_spi_ops *ops = spi_get_ops(bus);
-
-
-	if (ops->claim_bus)
-		ops->claim_bus += gd->reloc_off;
-	if (ops->release_bus)
-		ops->release_bus += gd->reloc_off;
-	if (ops->set_wordlen)
-		ops->set_wordlen += gd->reloc_off;
-	if (ops->xfer)
-		ops->xfer += gd->reloc_off;
-	if (ops->set_speed)
-		ops->set_speed += gd->reloc_off;
-	if (ops->set_mode)
-		ops->set_mode += gd->reloc_off;
-	if (ops->cs_info)
-		ops->cs_info += gd->reloc_off;
+	static int reloc_done;
+
+	if (!reloc_done) {
+		if (ops->claim_bus)
+			ops->claim_bus += gd->reloc_off;
+		if (ops->release_bus)
+			ops->release_bus += gd->reloc_off;
+		if (ops->set_wordlen)
+			ops->set_wordlen += gd->reloc_off;
+		if (ops->xfer)
+			ops->xfer += gd->reloc_off;
+		if (ops->set_speed)
+			ops->set_speed += gd->reloc_off;
+		if (ops->set_mode)
+			ops->set_mode += gd->reloc_off;
+		if (ops->cs_info)
+			ops->cs_info += gd->reloc_off;
+		reloc_done++;
+	}
 #endif
 
 	return 0;
@@ -179,7 +230,32 @@ int spi_chip_select(struct udevice *dev)
 
 int spi_find_chip_select(struct udevice *bus, int cs, struct udevice **devp)
 {
+	struct dm_spi_ops *ops;
+	struct spi_cs_info info;
 	struct udevice *dev;
+	int ret;
+
+	/*
+	 * Ask the driver. For the moment we don't have CS info.
+	 * When we do we could provide the driver with a helper function
+	 * to figure out what chip selects are valid, or just handle the
+	 * request.
+	 */
+	ops = spi_get_ops(bus);
+	if (ops->cs_info) {
+		ret = ops->cs_info(bus, cs, &info);
+	} else {
+		/*
+		 * We could assume there is at least one valid chip select.
+		 * The driver didn't care enough to tell us.
+		 */
+		ret = 0;
+	}
+
+	if (ret) {
+		printf("Invalid cs %d (err=%d)\n", cs, ret);
+		return ret;
+	}
 
 	for (device_find_first_child(bus, &dev); dev;
 	     device_find_next_child(&dev)) {
@@ -214,7 +290,6 @@ int spi_cs_is_valid(unsigned int busnum, unsigned int cs)
 int spi_cs_info(struct udevice *bus, uint cs, struct spi_cs_info *info)
 {
 	struct spi_cs_info local_info;
-	struct dm_spi_ops *ops;
 	int ret;
 
 	if (!info)
@@ -223,25 +298,7 @@ int spi_cs_info(struct udevice *bus, uint cs, struct spi_cs_info *info)
 	/* If there is a device attached, return it */
 	info->dev = NULL;
 	ret = spi_find_chip_select(bus, cs, &info->dev);
-	if (!ret)
-		return 0;
-
-	/*
-	 * Otherwise ask the driver. For the moment we don't have CS info.
-	 * When we do we could provide the driver with a helper function
-	 * to figure out what chip selects are valid, or just handle the
-	 * request.
-	 */
-	ops = spi_get_ops(bus);
-	if (ops->cs_info)
-		return ops->cs_info(bus, cs, info);
-
-	/*
-	 * We could assume there is at least one valid chip select, but best
-	 * to be sure and return an error in this case. The driver didn't
-	 * care enough to tell us.
-	 */
-	return -ENODEV;
+	return ret == -ENODEV ? 0 : ret;
 }
 
 int spi_find_bus_and_cs(int busnum, int cs, struct udevice **busp,
@@ -272,6 +329,8 @@ int spi_get_bus_and_cs(int busnum, int cs, int speed, int mode,
 {
 	struct udevice *bus, *dev;
 	struct dm_spi_slave_platdata *plat;
+	struct dm_spi_bus *bus_data;
+	struct spi_slave *slave;
 	bool created = false;
 	int ret;
 
@@ -302,7 +361,13 @@ int spi_get_bus_and_cs(int busnum, int cs, int speed, int mode,
 		}
 		plat = dev_get_parent_platdata(dev);
 		plat->cs = cs;
-		plat->max_hz = speed;
+		if (speed) {
+			plat->max_hz = speed;
+		} else {
+			printf("Warning: SPI speed fallback to %u kHz\n",
+			       SPI_DEFAULT_SPEED_HZ / 1000);
+			plat->max_hz = SPI_DEFAULT_SPEED_HZ;
+		}
 		plat->mode = mode;
 		created = true;
 	} else if (ret) {
@@ -321,17 +386,21 @@ int spi_get_bus_and_cs(int busnum, int cs, int speed, int mode,
 		slave->dev = dev;
 	}
 
-	plat = dev_get_parent_platdata(dev);
-	if (!speed) {
-		speed = plat->max_hz;
-		mode = plat->mode;
+	slave = dev_get_parent_priv(dev);
+	bus_data = dev_get_uclass_priv(bus);
+
+	/*
+	 * In case the operation speed is not yet established by
+	 * dm_spi_claim_bus() ensure the bus is configured properly.
+	 */
+	if (!bus_data->speed) {
+		ret = spi_claim_bus(slave);
+		if (ret)
+			goto err;
 	}
-	ret = spi_set_speed_mode(bus, speed, mode);
-	if (ret)
-		goto err;
 
 	*busp = bus;
-	*devp = dev_get_parent_priv(dev);
+	*devp = slave;
 	debug("%s: bus=%p, slave=%p\n", __func__, bus, *devp);
 
 	return 0;
@@ -347,22 +416,6 @@ err:
 	return ret;
 }
 
-/* Compatibility function - to be removed */
-struct spi_slave *spi_setup_slave_fdt(const void *blob, int node,
-				      int bus_node)
-{
-	struct udevice *bus, *dev;
-	int ret;
-
-	ret = uclass_get_device_by_of_offset(UCLASS_SPI, bus_node, &bus);
-	if (ret)
-		return NULL;
-	ret = device_get_child_by_of_offset(bus, node, &dev);
-	if (ret)
-		return NULL;
-	return dev_get_parent_priv(dev);
-}
-
 /* Compatibility function - to be removed */
 struct spi_slave *spi_setup_slave(unsigned int busnum, unsigned int cs,
 				  unsigned int speed, unsigned int mode)
@@ -392,7 +445,8 @@ int spi_slave_ofdata_to_platdata(struct udevice *dev,
 	int value;
 
 	plat->cs = dev_read_u32_default(dev, "reg", -1);
-	plat->max_hz = dev_read_u32_default(dev, "spi-max-frequency", 0);
+	plat->max_hz = dev_read_u32_default(dev, "spi-max-frequency",
+					    SPI_DEFAULT_SPEED_HZ);
 	if (dev_read_bool(dev, "spi-cpol"))
 		mode |= SPI_CPOL;
 	if (dev_read_bool(dev, "spi-cpha"))
@@ -415,6 +469,9 @@ int spi_slave_ofdata_to_platdata(struct udevice *dev,
 	case 4:
 		mode |= SPI_TX_QUAD;
 		break;
+	case 8:
+		mode |= SPI_TX_OCTAL;
+		break;
 	default:
 		warn_non_spl("spi-tx-bus-width %d not supported\n", value);
 		break;
@@ -430,6 +487,9 @@ int spi_slave_ofdata_to_platdata(struct udevice *dev,
 	case 4:
 		mode |= SPI_RX_QUAD;
 		break;
+	case 8:
+		mode |= SPI_RX_OCTAL;
+		break;
 	default:
 		warn_non_spl("spi-rx-bus-width %d not supported\n", value);
 		break;
@@ -444,7 +504,7 @@ UCLASS_DRIVER(spi) = {
 	.id		= UCLASS_SPI,
 	.name		= "spi",
 	.flags		= DM_UC_FLAG_SEQ_ALIAS,
-#if !CONFIG_IS_ENABLED(OF_PLATDATA)
+#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
 	.post_bind	= dm_scan_fdt_dev,
 #endif
 	.post_probe	= spi_post_probe,
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7d81fbd7f8..45e73d28e4 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -12,7 +12,7 @@
 int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen)
 {
 	if (wordlen == 0 || wordlen > 32) {
-		printf("spi: invalid wordlen %d\n", wordlen);
+		printf("spi: invalid wordlen %u\n", wordlen);
 		return -1;
 	}
 
@@ -24,11 +24,12 @@ int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen)
 void *spi_do_alloc_slave(int offset, int size, unsigned int bus,
 			 unsigned int cs)
 {
-	struct spi_slave *slave;
-	void *ptr;
+	u8 *ptr;
 
 	ptr = malloc(size);
 	if (ptr) {
+		struct spi_slave *slave;
+
 		memset(ptr, '\0', size);
 		slave = (struct spi_slave *)(ptr + offset);
 		slave->bus = bus;
@@ -38,23 +39,3 @@ void *spi_do_alloc_slave(int offset, int size, unsigned int bus,
 
 	return ptr;
 }
-
-#ifdef CONFIG_OF_SPI
-struct spi_slave *spi_base_setup_slave_fdt(const void *blob, int busnum,
-					   int node)
-{
-	int cs, max_hz, mode = 0;
-
-	cs = fdtdec_get_int(blob, node, "reg", -1);
-	max_hz = fdtdec_get_int(blob, node, "spi-max-frequency", 100000);
-	if (fdtdec_get_bool(blob, node, "spi-cpol"))
-		mode |= SPI_CPOL;
-	if (fdtdec_get_bool(blob, node, "spi-cpha"))
-		mode |= SPI_CPHA;
-	if (fdtdec_get_bool(blob, node, "spi-cs-high"))
-		mode |= SPI_CS_HIGH;
-	if (fdtdec_get_bool(blob, node, "spi-half-duplex"))
-		mode |= SPI_PREAMBLE;
-	return spi_setup_slave(busnum, cs, max_hz, mode);
-}
-#endif
diff --git a/drivers/spi/stm32_qspi.c b/drivers/spi/stm32_qspi.c
index ef2b64ec5f..820202ec44 100644
--- a/drivers/spi/stm32_qspi.c
+++ b/drivers/spi/stm32_qspi.c
@@ -259,9 +259,11 @@ static unsigned int _stm32_qspi_gen_ccr(struct stm32_qspi_priv *priv)
 static void _stm32_qspi_enable_mmap(struct stm32_qspi_priv *priv,
 		struct spi_flash *flash)
 {
-	priv->command = flash->read_cmd | CMD_HAS_ADR | CMD_HAS_DATA
+	unsigned int ccr_reg;
+
+	priv->command = flash->read_opcode | CMD_HAS_ADR | CMD_HAS_DATA
 			| CMD_HAS_DUMMY;
-	priv->dummycycles = flash->dummy_byte * 8;
+	priv->dummycycles = flash->read_dummy;
 
 	unsigned int ccr_reg = _stm32_qspi_gen_ccr(priv);
 	ccr_reg |= (STM32_QSPI_CCR_MEM_MAP << STM32_QSPI_CCR_FMODE_SHIFT);
diff --git a/drivers/sysreset/Kconfig b/drivers/sysreset/Kconfig
index a6d48e8a66..3367c916e0 100644
--- a/drivers/sysreset/Kconfig
+++ b/drivers/sysreset/Kconfig
@@ -13,11 +13,40 @@ config SYSRESET
 	  to effect a reset. The uclass will try all available drivers when
 	  reset_walk() is called.
 
+config SPL_SYSRESET
+	bool "Enable support for system reset drivers in SPL mode"
+	depends on SYSRESET && SPL_DM
+	help
+	  Enable system reset drivers which can be used to reset the CPU or
+	  board. Each driver can provide a reset method which will be called
+	  to effect a reset. The uclass will try all available drivers when
+	  reset_walk() is called.
+
+config TPL_SYSRESET
+	bool "Enable support for system reset drivers in TPL mode"
+	depends on SYSRESET && TPL_DM
+	help
+	  Enable system reset drivers which can be used to reset the CPU or
+	  board. Each driver can provide a reset method which will be called
+	  to effect a reset. The uclass will try all available drivers when
+	  reset_walk() is called.
+
+config SYSRESET_REG
+	hex "The sysreset register for the sysreset"
+	depends on !SYSRESET
+	default 0xff490408
+
+config SYSRESET_VAL
+	hex "The sysreset value for the sysreset"
+	depends on !SYSRESET
+	default 0x0000fdb9
+
 if SYSRESET
 
 config SYSRESET_PSCI
 	bool "Enable support for PSCI System Reset"
 	depends on ARM_PSCI_FW
+	default y if ARCH_ROCKCHIP
 	help
 	  Enable PSCI SYSTEM_RESET function call.  To use this, PSCI firmware
 	  must be running on your system.
@@ -31,6 +60,12 @@ config SYSRESET_SYSCON
 	help
 	  Reboot support for generic SYSCON mapped register reset.
 
+config SYSRESET_SYSCON_REBOOT
+	bool "Enable support for syscon reboot mode driver"
+	default y if ARCH_ROCKCHIP
+	help
+	  Reboot mode command, like: reboot bootloader, etc.
+
 config SYSRESET_WATCHDOG
 	bool "Enable support for watchdog reboot driver"
 	select WDT
diff --git a/drivers/sysreset/Makefile b/drivers/sysreset/Makefile
index a5200d377d..f033560d62 100644
--- a/drivers/sysreset/Makefile
+++ b/drivers/sysreset/Makefile
@@ -4,22 +4,22 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-$(CONFIG_SYSRESET) += sysreset-uclass.o
-obj-$(CONFIG_SYSRESET_PSCI) += sysreset_psci.o
+obj-$(CONFIG_$(SPL_TPL_)SYSRESET) += sysreset-uclass.o
+
+ifndef CONFIG_SUPPORT_USBPLUG
+obj-$(CONFIG_$(SPL_TPL_)SYSRESET_SYSCON_REBOOT) += sysreset-syscon-reboot.o
+obj-$(CONFIG_$(SPL_TPL_)SYSRESET_PSCI) += sysreset_psci.o
+endif
+
 obj-$(CONFIG_SYSRESET_SYSCON) += sysreset_syscon.o
 obj-$(CONFIG_SYSRESET_WATCHDOG) += sysreset_watchdog.o
 
-ifndef CONFIG_SPL_BUILD
-obj-$(CONFIG_ROCKCHIP_RK3036) += sysreset_rk3036.o
-endif
-obj-$(CONFIG_ROCKCHIP_RK3188) += sysreset_rk3188.o
-obj-$(CONFIG_ROCKCHIP_RK3288) += sysreset_rk3288.o
-obj-$(CONFIG_ROCKCHIP_RK3328) += sysreset_rk3328.o
-obj-$(CONFIG_ROCKCHIP_RK3368) += sysreset_rk3368.o
-obj-$(CONFIG_ROCKCHIP_RK3399) += sysreset_rk3399.o
-obj-$(CONFIG_ROCKCHIP_RV1108) += sysreset_rv1108.o
 obj-$(CONFIG_SANDBOX) += sysreset_sandbox.o
 obj-$(CONFIG_ARCH_SNAPDRAGON) += sysreset_snapdragon.o
 obj-$(CONFIG_ARCH_STI) += sysreset_sti.o
 obj-$(CONFIG_TARGET_XTFPGA) += sysreset_xtfpga.o
 obj-$(CONFIG_ARCH_ASPEED) += sysreset_ast.o
+
+ifndef CONFIG_TPL_BUILD
+obj-$(CONFIG_ARCH_ROCKCHIP) += sysreset_rockchip.o
+endif
diff --git a/drivers/sysreset/sysreset-uclass.c b/drivers/sysreset/sysreset-uclass.c
index 3566d17fb1..63fd53204f 100644
--- a/drivers/sysreset/sysreset-uclass.c
+++ b/drivers/sysreset/sysreset-uclass.c
@@ -44,6 +44,25 @@ int sysreset_walk(enum sysreset_t type)
 	return ret;
 }
 
+static void sysreset_walk_reboot_mode(const char *mode)
+{
+	struct sysreset_ops *ops;
+	struct udevice *dev;
+
+	if (!mode)
+		return;
+
+	for (uclass_first_device(UCLASS_SYSRESET, &dev);
+	     dev;
+	     uclass_next_device(&dev)) {
+		ops = sysreset_get_ops(dev);
+		if (ops && ops->request_by_mode) {
+			ops->request_by_mode(dev, mode);
+			break;
+		}
+	}
+}
+
 void sysreset_walk_halt(enum sysreset_t type)
 {
 	int ret;
@@ -67,10 +86,19 @@ void reset_cpu(ulong addr)
 	sysreset_walk_halt(SYSRESET_WARM);
 }
 
+void reboot(const char *mode)
+{
+	sysreset_walk_reboot_mode(mode);
+	flushc();
+	sysreset_walk_halt(SYSRESET_COLD);
+}
 
 int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-	sysreset_walk_halt(SYSRESET_WARM);
+	if (argc > 1)
+		reboot(argv[1]);
+	else
+		reboot(NULL);
 
 	return 0;
 }
diff --git a/drivers/sysreset/sysreset_psci.c b/drivers/sysreset/sysreset_psci.c
index 4656d273c1..42a56e023b 100644
--- a/drivers/sysreset/sysreset_psci.c
+++ b/drivers/sysreset/sysreset_psci.c
@@ -35,7 +35,8 @@ static struct sysreset_ops psci_sysreset_ops = {
 	.request = psci_sysreset_request,
 };
 
-U_BOOT_DRIVER(psci_sysreset) = {
+/* Add an 'a_' prefix so it comes the first sysreset path. */
+U_BOOT_DRIVER(a_psci_sysreset) = {
 	.name = "psci-sysreset",
 	.id = UCLASS_SYSRESET,
 	.ops = &psci_sysreset_ops,
diff --git a/drivers/sysreset/sysreset_sti.c b/drivers/sysreset/sysreset_sti.c
index 9b58aa8e97..bf698a737b 100644
--- a/drivers/sysreset/sysreset_sti.c
+++ b/drivers/sysreset/sysreset_sti.c
@@ -39,7 +39,7 @@ static int sti_sysreset_probe(struct udevice *dev)
 					     "st,syscfg", NULL, 0, 0,
 					     &syscfg_phandle);
 	if (ret < 0) {
-		error("Can't get syscfg phandle: %d\n", ret);
+		pr_err("Can't get syscfg phandle: %d\n", ret);
 		return ret;
 	}
 
@@ -47,14 +47,14 @@ static int sti_sysreset_probe(struct udevice *dev)
 					     syscfg_phandle.node,
 					     &syscon);
 	if (ret) {
-		error("%s: uclass_get_device_by_of_offset failed: %d\n",
+		pr_err("%s: uclass_get_device_by_of_offset failed: %d\n",
 		      __func__, ret);
 		return ret;
 	}
 
 	regmap = syscon_get_regmap(syscon);
 	if (!regmap) {
-		error("unable to get regmap for %s\n", syscon->name);
+		pr_err("unable to get regmap for %s\n", syscon->name);
 		return -ENODEV;
 	}
 
diff --git a/drivers/sysreset/sysreset_syscon.c b/drivers/sysreset/sysreset_syscon.c
index 3818faeb46..3abce7f678 100644
--- a/drivers/sysreset/sysreset_syscon.c
+++ b/drivers/sysreset/sysreset_syscon.c
@@ -45,13 +45,13 @@ int syscon_reboot_probe(struct udevice *dev)
 	err = uclass_get_device_by_phandle(UCLASS_SYSCON, dev,
 					   "regmap", &syscon);
 	if (err) {
-		error("unable to find syscon device\n");
+		pr_err("unable to find syscon device\n");
 		return err;
 	}
 
 	priv->regmap = syscon_get_regmap(syscon);
 	if (!priv->regmap) {
-		error("unable to find regmap\n");
+		pr_err("unable to find regmap\n");
 		return -ENODEV;
 	}
 
diff --git a/drivers/sysreset/sysreset_watchdog.c b/drivers/sysreset/sysreset_watchdog.c
index 304ed052a2..ab250aea29 100644
--- a/drivers/sysreset/sysreset_watchdog.c
+++ b/drivers/sysreset/sysreset_watchdog.c
@@ -38,7 +38,7 @@ int wdt_reboot_probe(struct udevice *dev)
 	err = uclass_get_device_by_phandle(UCLASS_WDT, dev,
 					   "wdt", &priv->wdt);
 	if (err) {
-		error("unable to find wdt device\n");
+		pr_err("unable to find wdt device\n");
 		return err;
 	}
 
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 886f5fa546..daa36d5b7e 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -17,4 +17,10 @@ config IMX_THERMAL
           cpufreq is used as the cooling device to throttle CPUs when the
           passive trip is crossed.
 
+config ROCKCHIP_THERMAL
+	bool "Temperature sensor driver for Rockchip SoCs"
+	depends on CLK
+	help
+	  Support for Temperature Monitor (TEMPMON) found on Rockchip SoCs.
+
 endif # if DM_THERMAL
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index d768f5ef80..05f60926ac 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -7,3 +7,4 @@
 
 obj-$(CONFIG_DM_THERMAL) += thermal-uclass.o
 obj-$(CONFIG_IMX_THERMAL) += imx_thermal.o
+obj-$(CONFIG_ROCKCHIP_THERMAL) += rockchip_thermal.o
diff --git a/drivers/timer/rockchip_timer.c b/drivers/timer/rockchip_timer.c
index eb44965a19..5ce4de3886 100644
--- a/drivers/timer/rockchip_timer.c
+++ b/drivers/timer/rockchip_timer.c
@@ -6,8 +6,9 @@
 
 #include <common.h>
 #include <dm.h>
+#include <dm/ofnode.h>
 #include <mapmem.h>
-#include <asm/arch/timer.h>
+#include <asm/arch-rockchip/timer.h>
 #include <dt-structs.h>
 #include <timer.h>
 #include <asm/io.h>
@@ -25,17 +26,72 @@ struct rockchip_timer_priv {
 	struct rk_timer *timer;
 };
 
-static int rockchip_timer_get_count(struct udevice *dev, u64 *count)
+static inline int64_t rockchip_timer_get_curr_value(struct rk_timer *timer)
 {
-	struct rockchip_timer_priv *priv = dev_get_priv(dev);
 	uint64_t timebase_h, timebase_l;
 	uint64_t cntr;
 
-	timebase_l = readl(&priv->timer->timer_curr_value0);
-	timebase_h = readl(&priv->timer->timer_curr_value1);
+	timebase_l = readl(&timer->timer_curr_value0);
+	timebase_h = readl(&timer->timer_curr_value1);
 
-	/* timers are down-counting */
 	cntr = timebase_h << 32 | timebase_l;
+	return cntr;
+}
+
+#if CONFIG_IS_ENABLED(BOOTSTAGE)
+ulong timer_get_boot_us(void)
+{
+	uint64_t  ticks = 0;
+	uint32_t  rate;
+	uint64_t  us;
+	int ret;
+
+	ret = dm_timer_init();
+
+	if (!ret) {
+		/* The timer is available */
+		rate = timer_get_rate(gd->timer);
+		timer_get_count(gd->timer, &ticks);
+#if !CONFIG_IS_ENABLED(OF_PLATDATA)
+	} else if (ret == -EAGAIN) {
+		/* We have been called so early that the DM is not ready,... */
+		ofnode node = offset_to_ofnode(-1);
+		struct rk_timer *timer = NULL;
+
+		/*
+		 * ... so we try to access the raw timer, if it is specified
+		 * via the tick-timer property in /chosen.
+		 */
+		node = ofnode_get_chosen_node("tick-timer");
+		if (!ofnode_valid(node)) {
+			debug("%s: no /chosen/tick-timer\n", __func__);
+			return 0;
+		}
+
+		timer = (struct rk_timer *)ofnode_get_addr(node);
+
+		/* This timer is down-counting */
+		ticks = ~0uLL - rockchip_timer_get_curr_value(timer);
+		if (ofnode_read_u32(node, "clock-frequency", &rate)) {
+			debug("%s: could not read clock-frequency\n", __func__);
+			return 0;
+		}
+#endif
+	} else {
+		return 0;
+	}
+
+	us = (ticks * 1000) / rate;
+	return us;
+}
+#endif
+
+static int rockchip_timer_get_count(struct udevice *dev, u64 *count)
+{
+	struct rockchip_timer_priv *priv = dev_get_priv(dev);
+	uint64_t cntr = rockchip_timer_get_curr_value(priv->timer);
+
+	/* timers are down-counting */
 	*count = ~0ull - cntr;
 	return 0;
 }
@@ -45,7 +101,9 @@ static int rockchip_clk_ofdata_to_platdata(struct udevice *dev)
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct rockchip_timer_priv *priv = dev_get_priv(dev);
 
-	priv->timer = (struct rk_timer *)devfdt_get_addr(dev);
+	priv->timer = dev_read_addr_ptr(dev);
+	if (!priv->timer)
+		return -ENOENT;
 #endif
 
 	return 0;
@@ -58,6 +116,12 @@ static int rockchip_timer_start(struct udevice *dev)
 	const uint32_t reload_val_l = reload_val & 0xffffffff;
 	const uint32_t reload_val_h = reload_val >> 32;
 
+	/* don't reinit, if the timer is already running and set up */
+	if ((readl(&priv->timer->timer_ctrl_reg) & 1) == 1 &&
+	    (readl(&priv->timer->timer_load_count0) == reload_val_l) &&
+	    (readl(&priv->timer->timer_load_count1) == reload_val_h))
+		return 0;
+
 	/* disable timer and reset all control */
 	writel(0, &priv->timer->timer_ctrl_reg);
 	/* write reload value */
@@ -76,7 +140,7 @@ static int rockchip_timer_probe(struct udevice *dev)
 	struct rockchip_timer_priv *priv = dev_get_priv(dev);
 	struct rockchip_timer_plat *plat = dev_get_platdata(dev);
 
-	priv->timer = map_sysmem(plat->dtd.reg[1], plat->dtd.reg[3]);
+	priv->timer = map_sysmem(plat->dtd.reg[0], plat->dtd.reg[1]);
 	uc_priv->clock_rate = plat->dtd.clock_frequency;
 #endif
 
diff --git a/drivers/timer/timer-uclass.c b/drivers/timer/timer-uclass.c
index a84755f4c5..45397b230f 100644
--- a/drivers/timer/timer-uclass.c
+++ b/drivers/timer/timer-uclass.c
@@ -8,6 +8,7 @@
 #include <dm.h>
 #include <dm/lists.h>
 #include <dm/device-internal.h>
+#include <dm/root.h>
 #include <clk.h>
 #include <errno.h>
 #include <timer.h>
@@ -54,9 +55,10 @@ static int timer_pre_probe(struct udevice *dev)
 		if (IS_ERR_VALUE(ret))
 			return ret;
 		uc_priv->clock_rate = ret;
-	} else
-		uc_priv->clock_rate = fdtdec_get_int(gd->fdt_blob,
-				dev_of_offset(dev),	"clock-frequency", 0);
+	} else {
+		uc_priv->clock_rate =
+			dev_read_u32_default(dev, "clock-frequency", 0);
+	}
 #endif
 
 	return 0;
@@ -83,37 +85,43 @@ u64 timer_conv_64(u32 count)
 
 int notrace dm_timer_init(void)
 {
-	__maybe_unused const void *blob = gd->fdt_blob;
 	struct udevice *dev = NULL;
-	int node = -ENOENT;
+	__maybe_unused ofnode node;
 	int ret;
 
 	if (gd->timer)
 		return 0;
 
+	/*
+	 * Directly access gd->dm_root to suppress error messages, if the
+	 * virtual root driver does not yet exist.
+	 */
+	if (gd->dm_root == NULL)
+		return -EAGAIN;
+
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	/* Check for a chosen timer to be used for tick */
-	node = fdtdec_get_chosen_node(blob, "tick-timer");
+	node = ofnode_get_chosen_node("tick-timer");
+
+	if (ofnode_valid(node) &&
+	    uclass_get_device_by_ofnode(UCLASS_TIMER, node, &dev)) {
+		/*
+		 * If the timer is not marked to be bound before
+		 * relocation, bind it anyway.
+		 */
+		if (!lists_bind_fdt(dm_root(), node, &dev)) {
+			ret = device_probe(dev);
+			if (ret)
+				return ret;
+		}
+	}
 #endif
-	if (node < 0) {
-		/* No chosen timer, trying first available timer */
+
+	if (!dev) {
+		/* Fall back to the first available timer */
 		ret = uclass_first_device_err(UCLASS_TIMER, &dev);
 		if (ret)
 			return ret;
-	} else {
-		if (uclass_get_device_by_of_offset(UCLASS_TIMER, node, &dev)) {
-			/*
-			 * If the timer is not marked to be bound before
-			 * relocation, bind it anyway.
-			 */
-			if (node > 0 &&
-			    !lists_bind_fdt(gd->dm_root, offset_to_ofnode(node),
-					    &dev)) {
-				ret = device_probe(dev);
-				if (ret)
-					return ret;
-			}
-		}
 	}
 
 	if (dev) {
diff --git a/drivers/tpm/tpm_tis_infineon.c b/drivers/tpm/tpm_tis_infineon.c
index ef3ff0dbf6..e3e20d8996 100644
--- a/drivers/tpm/tpm_tis_infineon.c
+++ b/drivers/tpm/tpm_tis_infineon.c
@@ -539,7 +539,7 @@ static int tpm_tis_i2c_init(struct udevice *dev)
 	}
 
 	if (chip->chip_type != UNKNOWN && vendor != expected_did_vid) {
-		error("Vendor id did not match! ID was %08x\n", vendor);
+		pr_err("Vendor id did not match! ID was %08x\n", vendor);
 		return -ENODEV;
 	}
 
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 62126aad2f..dd28340316 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -47,8 +47,29 @@ config DM_USB
 	  declared with the U_BOOT_USB_DEVICE() macro and will be
 	  automatically probed when found on the bus.
 
+config SPL_DM_USB
+	bool "Enable driver model for USB in SPL"
+	depends on SPL_DM && DM_USB
+	default y
+
+config DM_USB_GADGET
+	bool "Enable driver model for USB Gadget"
+	depends on DM_USB
+	help
+	  Enable driver model for USB Gadget (Peripheral
+	  mode)
+
+config SPL_DM_USB_GADGET
+	bool "Enable driver model for USB Gadget in sPL"
+	depends on SPL_DM_USB
+	help
+	  Enable driver model for USB Gadget in SPL
+	  (Peripheral mode)
+
 source "drivers/usb/host/Kconfig"
 
+source "drivers/usb/cdns3/Kconfig"
+
 source "drivers/usb/dwc3/Kconfig"
 
 source "drivers/usb/musb-new/Kconfig"
@@ -61,21 +82,29 @@ comment "USB peripherals"
 
 config USB_STORAGE
 	bool "USB Mass Storage support"
+	depends on !(BLK && !DM_USB)
 	---help---
 	  Say Y here if you want to connect USB mass storage devices to your
 	  board's USB port.
 
 config USB_KEYBOARD
 	bool "USB Keyboard support"
+	select SYS_STDIO_DEREGISTER
 	---help---
 	  Say Y here if you want to use a USB keyboard for U-Boot command line
 	  input.
 
 if USB_KEYBOARD
 
+config USB_KEYBOARD_FN_KEYS
+	bool "USB keyboard function key support"
+	help
+	  Say Y here if you want support for keys F1 - F12, INS, HOME, DELETE,
+	  END, PAGE UP, and PAGE DOWN.
+
 choice
 	prompt "USB keyboard polling"
-	optional
+	default SYS_USB_EVENT_POLL
 	---help---
 	  Enable a polling mechanism for USB keyboard.
 
diff --git a/drivers/usb/common/Makefile b/drivers/usb/common/Makefile
index aee7e32e59..0e30558c78 100644
--- a/drivers/usb/common/Makefile
+++ b/drivers/usb/common/Makefile
@@ -3,6 +3,6 @@
 # SPDX-License-Identifier:      GPL-2.0+
 #
 
-obj-$(CONFIG_DM_USB) += common.o
+obj-$(CONFIG_$(SPL_)DM_USB) += common.o
 obj-$(CONFIG_USB_EHCI_FSL) += fsl-dt-fixup.o fsl-errata.o
 obj-$(CONFIG_USB_XHCI_FSL) += fsl-dt-fixup.o fsl-errata.o
diff --git a/drivers/usb/common/common.c b/drivers/usb/common/common.c
index 35c2dc18d9..467cc01f6f 100644
--- a/drivers/usb/common/common.c
+++ b/drivers/usb/common/common.c
@@ -8,8 +8,10 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <dm.h>
 #include <linux/usb/otg.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/phy.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -20,15 +22,14 @@ static const char *const usb_dr_modes[] = {
 	[USB_DR_MODE_OTG]		= "otg",
 };
 
-enum usb_dr_mode usb_get_dr_mode(int node)
+enum usb_dr_mode usb_get_dr_mode(ofnode node)
 {
-	const void *fdt = gd->fdt_blob;
 	const char *dr_mode;
 	int i;
 
-	dr_mode = fdt_getprop(fdt, node, "dr_mode", NULL);
+	dr_mode = ofnode_read_string(node, "dr_mode");
 	if (!dr_mode) {
-		error("usb dr_mode not found\n");
+		pr_err("usb dr_mode not found\n");
 		return USB_DR_MODE_UNKNOWN;
 	}
 
@@ -38,3 +39,54 @@ enum usb_dr_mode usb_get_dr_mode(int node)
 
 	return USB_DR_MODE_UNKNOWN;
 }
+
+static const char *const speed_names[] = {
+	[USB_SPEED_UNKNOWN] = "UNKNOWN",
+	[USB_SPEED_LOW] = "low-speed",
+	[USB_SPEED_FULL] = "full-speed",
+	[USB_SPEED_HIGH] = "high-speed",
+	[USB_SPEED_WIRELESS] = "wireless",
+	[USB_SPEED_SUPER] = "super-speed",
+};
+
+enum usb_device_speed usb_get_maximum_speed(ofnode node)
+{
+	const char *max_speed;
+	int i;
+
+	max_speed = ofnode_read_string(node, "maximum-speed");
+	if (!max_speed) {
+		pr_err("usb maximum-speed not found\n");
+		return USB_SPEED_UNKNOWN;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(speed_names); i++)
+		if (!strcmp(max_speed, speed_names[i]))
+			return i;
+
+	return USB_SPEED_UNKNOWN;
+}
+
+#if CONFIG_IS_ENABLED(OF_LIVE) && CONFIG_IS_ENABLED(DM_USB)
+static const char *const usbphy_modes[] = {
+	[USBPHY_INTERFACE_MODE_UNKNOWN]	= "",
+	[USBPHY_INTERFACE_MODE_UTMI]	= "utmi",
+	[USBPHY_INTERFACE_MODE_UTMIW]	= "utmi_wide",
+};
+
+enum usb_phy_interface usb_get_phy_mode(ofnode node)
+{
+	const char *phy_type;
+	int i;
+
+	phy_type = ofnode_get_property(node, "phy_type", NULL);
+	if (!phy_type)
+		return USBPHY_INTERFACE_MODE_UNKNOWN;
+
+	for (i = 0; i < ARRAY_SIZE(usbphy_modes); i++)
+		if (!strcmp(phy_type, usbphy_modes[i]))
+			return i;
+
+	return USBPHY_INTERFACE_MODE_UNKNOWN;
+}
+#endif
diff --git a/drivers/usb/common/fsl-errata.c b/drivers/usb/common/fsl-errata.c
index 823beb32f6..6e2a464e0a 100644
--- a/drivers/usb/common/fsl-errata.c
+++ b/drivers/usb/common/fsl-errata.c
@@ -198,6 +198,11 @@ bool has_erratum_a010151(void)
 	u32 svr = get_svr();
 	u32 soc = SVR_SOC_VER(svr);
 
+#ifdef CONFIG_ARM64
+	if (IS_SVR_DEV(svr, SVR_DEV(SVR_LS1043A)))
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+#endif
+
 	switch (soc) {
 #ifdef CONFIG_ARM64
 	case SVR_LS2080A:
@@ -209,8 +214,6 @@ bool has_erratum_a010151(void)
 	case SVR_LS1046A:
 	case SVR_LS1012A:
 		return IS_SVR_REV(svr, 1, 0);
-	case SVR_LS1043A:
-		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
 #endif
 #ifdef CONFIG_ARCH_LS1021A
 	case SOC_VER_LS1020:
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index a291ceb6ae..25e1a38aee 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -37,6 +37,28 @@ config USB_DWC3_OMAP
 
 	  Say 'Y' here if you have one such device
 
+config USB_DWC3_GENERIC
+	bool "Generic implementation of a DWC3 wrapper (aka dwc3 glue)"
+	depends on DM_USB && USB_DWC3 && MISC
+	help
+	  Select this for Xilinx ZynqMP and similar Platforms.
+	  This wrapper supports Host and Peripheral operation modes.
+
+config USB_DWC3_MESON_G12A
+	bool "Amlogic Meson G12A USB wrapper"
+	depends on DM_USB && USB_DWC3 && ARCH_MESON
+	imply PHY
+	help
+	  Select this for Amlogic Meson G12A Platforms.
+	  This wrapper supports Host and Peripheral operation modes.
+
+config USB_DWC3_UNIPHIER
+	bool "DesignWare USB3 Host Support on UniPhier Platforms"
+	depends on ARCH_UNIPHIER && USB_XHCI_DWC3
+	help
+	  Support of USB2/3 functionality in Socionext UniPhier platforms.
+	  Say 'Y' here if you have one such device.
+
 menu "PHY Subsystem"
 
 config USB_DWC3_PHY_OMAP
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 2964bae0d8..c8298a8e6d 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -9,5 +9,8 @@ dwc3-y					:= core.o
 obj-$(CONFIG_USB_DWC3_GADGET)		+= gadget.o ep0.o
 
 obj-$(CONFIG_USB_DWC3_OMAP)		+= dwc3-omap.o
+obj-$(CONFIG_USB_DWC3_MESON_G12A)	+= dwc3-meson-g12a.o
+obj-$(CONFIG_USB_DWC3_GENERIC)		+= dwc3-generic.o
+obj-$(CONFIG_USB_DWC3_UNIPHIER)		+= dwc3-uniphier.o
 obj-$(CONFIG_USB_DWC3_PHY_OMAP)		+= ti_usb_phy.o
 obj-$(CONFIG_USB_DWC3_PHY_SAMSUNG)	+= samsung_usb_phy.o
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 87b9c87edf..ca14bab386 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -16,10 +16,12 @@
 
 #include <common.h>
 #include <malloc.h>
+#include <fdtdec.h>
 #include <dwc3-uboot.h>
 #include <asm/dma-mapping.h>
 #include <linux/ioport.h>
-
+#include <dm.h>
+#include <generic-phy.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
@@ -29,6 +31,8 @@
 
 #include "linux-compat.h"
 
+DECLARE_GLOBAL_DATA_PTR;
+
 static LIST_HEAD(dwc3_list);
 /* -------------------------------------------------------------------------- */
 
@@ -111,7 +115,8 @@ static struct dwc3_event_buffer *dwc3_alloc_one_event_buffer(struct dwc3 *dwc,
 {
 	struct dwc3_event_buffer	*evt;
 
-	evt = devm_kzalloc(dwc->dev, sizeof(*evt), GFP_KERNEL);
+	evt = devm_kzalloc((struct udevice *)dwc->dev, sizeof(*evt),
+			   GFP_KERNEL);
 	if (!evt)
 		return ERR_PTR(-ENOMEM);
 
@@ -329,6 +334,34 @@ static void dwc3_cache_hwparams(struct dwc3 *dwc)
 	parms->hwparams8 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS8);
 }
 
+static void dwc3_hsphy_mode_setup(struct dwc3 *dwc)
+{
+	enum usb_phy_interface hsphy_mode = dwc->hsphy_mode;
+	u32 reg;
+
+	/* Set dwc3 usb2 phy config */
+	reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
+
+	switch (hsphy_mode) {
+	case USBPHY_INTERFACE_MODE_UTMI:
+		reg &= ~(DWC3_GUSB2PHYCFG_PHYIF_MASK |
+			DWC3_GUSB2PHYCFG_USBTRDTIM_MASK);
+		reg |= DWC3_GUSB2PHYCFG_PHYIF(UTMI_PHYIF_8_BIT) |
+			DWC3_GUSB2PHYCFG_USBTRDTIM(USBTRDTIM_UTMI_8_BIT);
+		break;
+	case USBPHY_INTERFACE_MODE_UTMIW:
+		reg &= ~(DWC3_GUSB2PHYCFG_PHYIF_MASK |
+			DWC3_GUSB2PHYCFG_USBTRDTIM_MASK);
+		reg |= DWC3_GUSB2PHYCFG_PHYIF(UTMI_PHYIF_16_BIT) |
+			DWC3_GUSB2PHYCFG_USBTRDTIM(USBTRDTIM_UTMI_16_BIT);
+		break;
+	default:
+		break;
+	}
+
+	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
+}
+
 /**
  * dwc3_phy_setup - Configure USB PHY Interface of DWC3 Core
  * @dwc: Pointer to our controller context structure
@@ -369,11 +402,18 @@ static void dwc3_phy_setup(struct dwc3 *dwc)
 	if (dwc->tx_de_emphasis_quirk)
 		reg |= DWC3_GUSB3PIPECTL_TX_DEEPH(dwc->tx_de_emphasis);
 
-	if (dwc->dis_u3_susphy_quirk)
+	/*
+	 * For some Rokchip SoCs like RK3588, if the USB3 PHY is suspended
+	 * in U-Boot would cause the PHY initialize abortively in Linux Kernel,
+	 * so disable the DWC3_GUSB3PIPECTL_SUSPHY feature here to fix it.
+	 */
+	if (dwc->dis_u3_susphy_quirk || CONFIG_IS_ENABLED(ARCH_ROCKCHIP))
 		reg &= ~DWC3_GUSB3PIPECTL_SUSPHY;
 
 	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);
 
+	dwc3_hsphy_mode_setup(dwc);
+
 	mdelay(100);
 
 	reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
@@ -390,6 +430,18 @@ static void dwc3_phy_setup(struct dwc3 *dwc)
 	if (dwc->dis_u2_susphy_quirk)
 		reg &= ~DWC3_GUSB2PHYCFG_SUSPHY;
 
+	if (dwc->dis_enblslpm_quirk)
+		reg &= ~DWC3_GUSB2PHYCFG_ENBLSLPM;
+
+	if (dwc->dis_u2_freeclk_exists_quirk)
+		reg &= ~DWC3_GUSB2PHYCFG_U2_FREECLK_EXISTS;
+
+	if (dwc->usb2_phyif_utmi_width == 16) {
+		reg &= ~(DWC3_GUSB2PHYCFG_PHYIF_MASK |
+			DWC3_GUSB2PHYCFG_USBTRDTIM_MASK);
+		reg |= DWC3_GUSB2PHYCFG_USBTRDTIM(USBTRDTIM_UTMI_16_BIT);
+		reg |= DWC3_GUSB2PHYCFG_PHYIF(UTMI_PHYIF_16_BIT);
+	}
 	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
 
 	mdelay(100);
@@ -443,6 +495,16 @@ static int dwc3_core_init(struct dwc3 *dwc)
 	if (ret)
 		goto err0;
 
+	if (dwc->revision >= DWC3_REVISION_250A) {
+		reg = dwc3_readl(dwc->regs, DWC3_GUCTL1);
+
+		if (dwc->maximum_speed == USB_SPEED_HIGH ||
+		    dwc->maximum_speed == USB_SPEED_FULL)
+			reg |= DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK;
+
+		dwc3_writel(dwc->regs, DWC3_GUCTL1, reg);
+	}
+
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 	reg &= ~DWC3_GCTL_SCALEDOWN_MASK;
 
@@ -580,6 +642,12 @@ static int dwc3_core_init_mode(struct dwc3 *dwc)
 	return 0;
 }
 
+static void dwc3_gadget_run(struct dwc3 *dwc)
+{
+	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_RUN_STOP);
+	mdelay(100);
+}
+
 static void dwc3_core_exit_mode(struct dwc3 *dwc)
 {
 	switch (dwc->dr_mode) {
@@ -597,6 +665,13 @@ static void dwc3_core_exit_mode(struct dwc3 *dwc)
 		/* do nothing */
 		break;
 	}
+
+	/*
+	 * switch back to peripheral mode
+	 * This enables the phy to enter idle and then, if enabled, suspend.
+	 */
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
+	dwc3_gadget_run(dwc);
 }
 
 #define DWC3_ALIGN_MASK		(16 - 1)
@@ -623,8 +698,11 @@ int dwc3_uboot_init(struct dwc3_device *dwc3_dev)
 	int			ret;
 
 	void			*mem;
+	const void *blob = gd->fdt_blob;
+	int node;
 
-	mem = devm_kzalloc(dev, sizeof(*dwc) + DWC3_ALIGN_MASK, GFP_KERNEL);
+	mem = devm_kzalloc((struct udevice *)dev,
+			   sizeof(*dwc) + DWC3_ALIGN_MASK, GFP_KERNEL);
 	if (!mem)
 		return -ENOMEM;
 
@@ -667,6 +745,7 @@ int dwc3_uboot_init(struct dwc3_device *dwc3_dev)
 	dwc->rx_detect_poll_quirk = dwc3_dev->rx_detect_poll_quirk;
 	dwc->dis_u3_susphy_quirk = dwc3_dev->dis_u3_susphy_quirk;
 	dwc->dis_u2_susphy_quirk = dwc3_dev->dis_u2_susphy_quirk;
+	dwc->dis_u1u2_quirk = dwc3_dev->dis_u2_susphy_quirk;
 
 	dwc->tx_de_emphasis_quirk = dwc3_dev->tx_de_emphasis_quirk;
 	if (dwc3_dev->tx_de_emphasis)
@@ -682,8 +761,21 @@ int dwc3_uboot_init(struct dwc3_device *dwc3_dev)
 	dwc->hird_threshold = hird_threshold
 		| (dwc->is_utmi_l1_suspend << 4);
 
+	dwc->hsphy_mode = dwc3_dev->hsphy_mode;
+
 	dwc->index = dwc3_dev->index;
 
+	if (dwc3_dev->usb2_phyif_utmi_width)
+		dwc->usb2_phyif_utmi_width = dwc3_dev->usb2_phyif_utmi_width;
+
+	node = fdt_node_offset_by_compatible(blob, -1,
+			"rockchip,rk3399-xhci");
+	if (node < 0)
+		debug("%s dwc3 node not found\n", __func__);
+	else
+		dwc->usb2_phyif_utmi_width =
+			fdtdec_get_int(blob, node, "snps,phyif-utmi-bits", -1);
+
 	dwc3_cache_hwparams(dwc);
 
 	ret = dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);
@@ -786,3 +878,212 @@ MODULE_ALIAS("platform:dwc3");
 MODULE_AUTHOR("Felipe Balbi <balbi@ti.com>");
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("DesignWare USB3 DRD Controller Driver");
+
+#if CONFIG_IS_ENABLED(PHY) && CONFIG_IS_ENABLED(DM_USB)
+int dwc3_setup_phy(struct udevice *dev, struct phy **array, int *num_phys)
+{
+	int i, ret, count;
+	struct phy *usb_phys;
+
+	/* Return if no phy declared */
+	if (!dev_read_prop(dev, "phys", NULL))
+		return 0;
+	count = dev_count_phandle_with_args(dev, "phys", "#phy-cells");
+	if (count <= 0)
+		return count;
+
+	usb_phys = devm_kcalloc(dev, count, sizeof(struct phy),
+				GFP_KERNEL);
+	if (!usb_phys)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		ret = generic_phy_get_by_index(dev, i, &usb_phys[i]);
+		if (ret && ret != -ENOENT) {
+			pr_err("Failed to get USB PHY%d for %s\n",
+			       i, dev->name);
+			return ret;
+		}
+	}
+
+	for (i = 0; i < count; i++) {
+		ret = generic_phy_init(&usb_phys[i]);
+		if (ret) {
+			pr_err("Can't init USB PHY%d for %s\n",
+			       i, dev->name);
+			goto phys_init_err;
+		}
+	}
+
+	for (i = 0; i < count; i++) {
+		ret = generic_phy_power_on(&usb_phys[i]);
+		if (ret) {
+			pr_err("Can't power USB PHY%d for %s\n",
+			       i, dev->name);
+			goto phys_poweron_err;
+		}
+	}
+
+	*array = usb_phys;
+	*num_phys =  count;
+	return 0;
+
+phys_poweron_err:
+	for (i = count - 1; i >= 0; i--)
+		generic_phy_power_off(&usb_phys[i]);
+
+	for (i = 0; i < count; i++)
+		generic_phy_exit(&usb_phys[i]);
+
+	return ret;
+
+phys_init_err:
+	for (; i >= 0; i--)
+		generic_phy_exit(&usb_phys[i]);
+
+	return ret;
+}
+
+int dwc3_shutdown_phy(struct udevice *dev, struct phy *usb_phys, int num_phys)
+{
+	int i, ret;
+
+	for (i = 0; i < num_phys; i++) {
+		if (!generic_phy_valid(&usb_phys[i]))
+			continue;
+
+		ret = generic_phy_power_off(&usb_phys[i]);
+		ret |= generic_phy_exit(&usb_phys[i]);
+		if (ret) {
+			pr_err("Can't shutdown USB PHY%d for %s\n",
+			       i, dev->name);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#if CONFIG_IS_ENABLED(DM_USB)
+void dwc3_of_parse(struct dwc3 *dwc)
+{
+	const u8 *tmp;
+	struct udevice *dev = dwc->dev;
+	u8 lpm_nyet_threshold;
+	u8 tx_de_emphasis;
+	u8 hird_threshold;
+
+	/* default to highest possible threshold */
+	lpm_nyet_threshold = 0xff;
+
+	/* default to -3.5dB de-emphasis */
+	tx_de_emphasis = 1;
+
+	/*
+	 * default to assert utmi_sleep_n and use maximum allowed HIRD
+	 * threshold value of 0b1100
+	 */
+	hird_threshold = 12;
+
+	dwc->hsphy_mode = usb_get_phy_mode(dev->node);
+
+	dwc->has_lpm_erratum = dev_read_bool(dev,
+				"snps,has-lpm-erratum");
+	tmp = dev_read_u8_array_ptr(dev, "snps,lpm-nyet-threshold", 1);
+	if (tmp)
+		lpm_nyet_threshold = *tmp;
+
+	dwc->is_utmi_l1_suspend = dev_read_bool(dev,
+				"snps,is-utmi-l1-suspend");
+	tmp = dev_read_u8_array_ptr(dev, "snps,hird-threshold", 1);
+	if (tmp)
+		hird_threshold = *tmp;
+
+	dwc->disable_scramble_quirk = dev_read_bool(dev,
+				"snps,disable_scramble_quirk");
+	dwc->u2exit_lfps_quirk = dev_read_bool(dev,
+				"snps,u2exit_lfps_quirk");
+	dwc->u2ss_inp3_quirk = dev_read_bool(dev,
+				"snps,u2ss_inp3_quirk");
+	dwc->req_p1p2p3_quirk = dev_read_bool(dev,
+				"snps,req_p1p2p3_quirk");
+	dwc->del_p1p2p3_quirk = dev_read_bool(dev,
+				"snps,del_p1p2p3_quirk");
+	dwc->del_phy_power_chg_quirk = dev_read_bool(dev,
+				"snps,del_phy_power_chg_quirk");
+	dwc->lfps_filter_quirk = dev_read_bool(dev,
+				"snps,lfps_filter_quirk");
+	dwc->rx_detect_poll_quirk = dev_read_bool(dev,
+				"snps,rx_detect_poll_quirk");
+	dwc->dis_u3_susphy_quirk = dev_read_bool(dev,
+				"snps,dis_u3_susphy_quirk");
+	dwc->dis_u2_susphy_quirk = dev_read_bool(dev,
+				"snps,dis_u2_susphy_quirk");
+	dwc->dis_enblslpm_quirk = dev_read_bool(dev,
+				"snps,dis_enblslpm_quirk");
+	dwc->dis_u2_freeclk_exists_quirk = dev_read_bool(dev,
+				"snps,dis-u2-freeclk-exists-quirk");
+	dwc->tx_de_emphasis_quirk = dev_read_bool(dev,
+				"snps,tx_de_emphasis_quirk");
+	tmp = dev_read_u8_array_ptr(dev, "snps,tx_de_emphasis", 1);
+	if (tmp)
+		tx_de_emphasis = *tmp;
+
+	dwc->lpm_nyet_threshold = lpm_nyet_threshold;
+	dwc->tx_de_emphasis = tx_de_emphasis;
+
+	dwc->hird_threshold = hird_threshold
+		| (dwc->is_utmi_l1_suspend << 4);
+}
+
+int dwc3_init(struct dwc3 *dwc)
+{
+	int ret;
+
+	dwc3_cache_hwparams(dwc);
+
+	ret = dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);
+	if (ret) {
+		dev_err(dwc->dev, "failed to allocate event buffers\n");
+		return -ENOMEM;
+	}
+
+	ret = dwc3_core_init(dwc);
+	if (ret) {
+		dev_err(dev, "failed to initialize core\n");
+		goto core_fail;
+	}
+
+	ret = dwc3_event_buffers_setup(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to setup event buffers\n");
+		goto event_fail;
+	}
+
+	ret = dwc3_core_init_mode(dwc);
+	if (ret)
+		goto mode_fail;
+
+	return 0;
+
+mode_fail:
+	dwc3_event_buffers_cleanup(dwc);
+
+event_fail:
+	dwc3_core_exit(dwc);
+
+core_fail:
+	dwc3_free_event_buffers(dwc);
+
+	return ret;
+}
+
+void dwc3_remove(struct dwc3 *dwc)
+{
+	dwc3_core_exit_mode(dwc);
+	dwc3_event_buffers_cleanup(dwc);
+	dwc3_free_event_buffers(dwc);
+	dwc3_core_exit(dwc);
+	kfree(dwc->mem);
+}
+#endif
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 72d2fcdd3f..a67c899436 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -22,6 +22,7 @@
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/otg.h>
+#include <linux/usb/phy.h>
 
 #define DWC3_MSG_MAX	500
 
@@ -74,6 +75,7 @@
 #define DWC3_GCTL		0xc110
 #define DWC3_GEVTEN		0xc114
 #define DWC3_GSTS		0xc118
+#define DWC3_GUCTL1		0xc11c
 #define DWC3_GSNPSID		0xc120
 #define DWC3_GGPIO		0xc124
 #define DWC3_GUID		0xc128
@@ -160,9 +162,24 @@
 #define DWC3_GCTL_GBLHIBERNATIONEN	(1 << 1)
 #define DWC3_GCTL_DSBLCLKGTNG		(1 << 0)
 
+/* Global User Control 1 Register */
+#define DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK BIT(26)
+
 /* Global USB2 PHY Configuration Register */
 #define DWC3_GUSB2PHYCFG_PHYSOFTRST	(1 << 31)
+#define DWC3_GUSB2PHYCFG_U2_FREECLK_EXISTS	(1 << 30)
+#define DWC3_GUSB2PHYCFG_ENBLSLPM   (1 << 8)
 #define DWC3_GUSB2PHYCFG_SUSPHY		(1 << 6)
+#define DWC3_GUSB2PHYCFG_PHYIF_8BIT	(0 << 3)
+#define DWC3_GUSB2PHYCFG_PHYIF_16BIT	(1 << 3)
+#define DWC3_GUSB2PHYCFG_PHYIF(n)	((n) << 3)
+#define DWC3_GUSB2PHYCFG_PHYIF_MASK	DWC3_GUSB2PHYCFG_PHYIF(1)
+#define DWC3_GUSB2PHYCFG_USBTRDTIM(n)	((n) << 10)
+#define DWC3_GUSB2PHYCFG_USBTRDTIM_MASK	DWC3_GUSB2PHYCFG_USBTRDTIM(0xf)
+#define USBTRDTIM_UTMI_8_BIT		9
+#define USBTRDTIM_UTMI_16_BIT		5
+#define UTMI_PHYIF_16_BIT		1
+#define UTMI_PHYIF_8_BIT		0
 
 /* Global USB3 PIPE Control Register */
 #define DWC3_GUSB3PIPECTL_PHYSOFTRST	(1 << 31)
@@ -641,6 +658,9 @@ struct dwc3_scratchpad_array {
  * @maximum_speed: maximum speed requested (mainly for testing purposes)
  * @revision: revision register contents
  * @dr_mode: requested mode of operation
+ * @hsphy_mode: UTMI phy mode, one of following:
+ *		- USBPHY_INTERFACE_MODE_UTMI
+ *		- USBPHY_INTERFACE_MODE_UTMIW
  * @dcfg: saved contents of DCFG register
  * @gctl: saved contents of GCTL register
  * @isoch_delay: wValue from Set Isochronous Delay request;
@@ -689,6 +709,7 @@ struct dwc3_scratchpad_array {
  * @rx_detect_poll_quirk: set if we enable rx_detect to polling lfps quirk
  * @dis_u3_susphy_quirk: set if we disable usb3 suspend phy
  * @dis_u2_susphy_quirk: set if we disable usb2 suspend phy
+ * @dis_u1u2_quirk: set if we reject transition to U1 or U2 state
  * @tx_de_emphasis_quirk: set if we enable Tx de-emphasis quirk
  * @tx_de_emphasis: Tx de-emphasis value
  * 	0	- -6dB de-emphasis
@@ -713,7 +734,11 @@ struct dwc3 {
 	/* device lock */
 	spinlock_t		lock;
 
+#if defined(__UBOOT__) && CONFIG_IS_ENABLED(DM_USB)
+	struct udevice		*dev;
+#else
 	struct device		*dev;
+#endif
 
 	struct platform_device	*xhci;
 	struct resource		xhci_resources[DWC3_XHCI_RESOURCES_NUM];
@@ -728,6 +753,7 @@ struct dwc3 {
 	size_t			regs_size;
 
 	enum usb_dr_mode	dr_mode;
+	enum usb_phy_interface	hsphy_mode;
 
 	/* used for suspend/resume */
 	u32			dcfg;
@@ -810,9 +836,13 @@ struct dwc3 {
 	unsigned		rx_detect_poll_quirk:1;
 	unsigned		dis_u3_susphy_quirk:1;
 	unsigned		dis_u2_susphy_quirk:1;
+	unsigned		dis_u1u2_quirk:1;
+	unsigned		dis_enblslpm_quirk:1;
+	unsigned		dis_u2_freeclk_exists_quirk:1;
 
 	unsigned		tx_de_emphasis_quirk:1;
 	unsigned		tx_de_emphasis:2;
+	unsigned		usb2_phyif_utmi_width:5;
 	int			index;
 	struct list_head        list;
 };
@@ -988,16 +1018,14 @@ struct dwc3_gadget_ep_cmd_params {
 
 /* prototypes */
 int dwc3_gadget_resize_tx_fifos(struct dwc3 *dwc);
+void dwc3_of_parse(struct dwc3 *dwc);
+int dwc3_init(struct dwc3 *dwc);
+void dwc3_remove(struct dwc3 *dwc);
 
-#ifdef CONFIG_USB_DWC3_HOST
-int dwc3_host_init(struct dwc3 *dwc);
-void dwc3_host_exit(struct dwc3 *dwc);
-#else
 static inline int dwc3_host_init(struct dwc3 *dwc)
 { return 0; }
 static inline void dwc3_host_exit(struct dwc3 *dwc)
 { }
-#endif
 
 #ifdef CONFIG_USB_DWC3_GADGET
 int dwc3_gadget_init(struct dwc3 *dwc);
diff --git a/drivers/usb/dwc3/dwc3-omap.c b/drivers/usb/dwc3/dwc3-omap.c
index 3dcc2f4847..b314e80498 100644
--- a/drivers/usb/dwc3/dwc3-omap.c
+++ b/drivers/usb/dwc3/dwc3-omap.c
@@ -17,6 +17,7 @@
 #include <common.h>
 #include <malloc.h>
 #include <asm/io.h>
+#include <dm.h>
 #include <dwc3-omap-uboot.h>
 #include <linux/usb/dwc3-omap.h>
 #include <linux/ioport.h>
@@ -377,7 +378,7 @@ int dwc3_omap_uboot_init(struct dwc3_omap_device *omap_dev)
 	struct device		*dev = NULL;
 	struct dwc3_omap	*omap;
 
-	omap = devm_kzalloc(dev, sizeof(*omap), GFP_KERNEL);
+	omap = devm_kzalloc((struct udevice *)dev, sizeof(*omap), GFP_KERNEL);
 	if (!omap)
 		return -ENOMEM;
 
diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index e61d98046f..8b98391ab9 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -13,7 +13,7 @@
  *
  * SPDX-License-Identifier:     GPL-2.0
  */
-
+#include <common.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
 
@@ -217,7 +217,7 @@ int dwc3_gadget_ep0_queue(struct usb_ep *ep, struct usb_request *request,
 	struct dwc3_ep			*dep = to_dwc3_ep(ep);
 	struct dwc3			*dwc = dep->dwc;
 
-	unsigned long			flags;
+	unsigned long			flags = 0;
 
 	int				ret;
 
@@ -284,7 +284,7 @@ int __dwc3_gadget_ep0_set_halt(struct usb_ep *ep, int value)
 
 int dwc3_gadget_ep0_set_halt(struct usb_ep *ep, int value)
 {
-	unsigned long			flags;
+	unsigned long			flags = 0;
 	int				ret;
 
 	spin_lock_irqsave(&dwc->lock, flags);
@@ -417,7 +417,7 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 				return -EINVAL;
 
 			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-			if (set)
+			if (set && !dwc->dis_u1u2_quirk)
 				reg |= DWC3_DCTL_INITU1ENA;
 			else
 				reg &= ~DWC3_DCTL_INITU1ENA;
@@ -431,7 +431,7 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 				return -EINVAL;
 
 			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-			if (set)
+			if (set && !dwc->dis_u1u2_quirk)
 				reg |= DWC3_DCTL_INITU2ENA;
 			else
 				reg &= ~DWC3_DCTL_INITU2ENA;
@@ -568,7 +568,10 @@ static int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 			 * nothing is pending from application.
 			 */
 			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-			reg |= (DWC3_DCTL_ACCEPTU1ENA | DWC3_DCTL_ACCEPTU2ENA);
+			if (dwc->dis_u1u2_quirk)
+				reg &= ~(DWC3_DCTL_ACCEPTU1ENA | DWC3_DCTL_ACCEPTU2ENA);
+			else
+				reg |= (DWC3_DCTL_ACCEPTU1ENA | DWC3_DCTL_ACCEPTU2ENA);
 			dwc3_writel(dwc->regs, DWC3_DCTL, reg);
 
 			dwc->resize_fifos = true;
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index e065c5aeb3..918fced6e0 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -17,7 +17,6 @@
 #include <common.h>
 #include <malloc.h>
 #include <asm/dma-mapping.h>
-#include <usb/lin_gadget_compat.h>
 #include <linux/bug.h>
 #include <linux/list.h>
 
@@ -244,7 +243,8 @@ void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
 
 	list_del(&req->list);
 	req->trb = NULL;
-	dwc3_flush_cache((uintptr_t)req->request.dma, req->request.length);
+	if (req->request.length)
+		dwc3_flush_cache((uintptr_t)req->request.dma, req->request.length);
 
 	if (req->request.status == -EINPROGRESS)
 		req->request.status = status;
@@ -594,7 +594,7 @@ static int dwc3_gadget_ep_enable(struct usb_ep *ep,
 		const struct usb_endpoint_descriptor *desc)
 {
 	struct dwc3_ep			*dep;
-	unsigned long			flags;
+	unsigned long			flags = 0;
 	int				ret;
 
 	if (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {
@@ -642,7 +642,7 @@ static int dwc3_gadget_ep_enable(struct usb_ep *ep,
 static int dwc3_gadget_ep_disable(struct usb_ep *ep)
 {
 	struct dwc3_ep			*dep;
-	unsigned long			flags;
+	unsigned long			flags = 0;
 	int				ret;
 
 	if (!ep) {
@@ -725,6 +725,16 @@ static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 			usb_endpoint_xfer_isoc(dep->endpoint.desc))
 		dep->free_slot++;
 
+	/*
+	 * According to the chapter 8.2.3.3 of DWC3 Databook,
+	 * for OUT endpoints, the total size of a Buffer Descriptor must be a
+	 * multiple of MaxPacketSize. So amend the TRB size to apply this rule.
+	 */
+	if (usb_endpoint_dir_out(dep->endpoint.desc)) {
+		length = dep->endpoint.maxpacket *
+			((length - 1) / dep->endpoint.maxpacket + 1);
+	}
+
 	trb->size = DWC3_TRB_SIZE_LENGTH(length);
 	trb->bpl = lower_32_bits(dma);
 	trb->bph = upper_32_bits(dma);
@@ -739,6 +749,9 @@ static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 			trb->ctrl = DWC3_TRBCTL_ISOCHRONOUS_FIRST;
 		else
 			trb->ctrl = DWC3_TRBCTL_ISOCHRONOUS;
+
+		/* always enable Interrupt on Missed ISOC */
+		trb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;
 		break;
 
 	case USB_ENDPOINT_XFER_BULK:
@@ -753,15 +766,14 @@ static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 		BUG();
 	}
 
+	/* always enable Continue on Short Packet */
+	trb->ctrl |= DWC3_TRB_CTRL_CSP;
+
 	if (!req->request.no_interrupt && !chain)
-		trb->ctrl |= DWC3_TRB_CTRL_IOC;
+		trb->ctrl |= DWC3_TRB_CTRL_IOC | DWC3_TRB_CTRL_ISP_IMI;
 
-	if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
-		trb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;
-		trb->ctrl |= DWC3_TRB_CTRL_CSP;
-	} else if (last) {
+	if (last)
 		trb->ctrl |= DWC3_TRB_CTRL_LST;
-	}
 
 	if (chain)
 		trb->ctrl |= DWC3_TRB_CTRL_CHN;
@@ -1064,7 +1076,7 @@ static int dwc3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,
 	struct dwc3_request		*req = to_dwc3_request(request);
 	struct dwc3_ep			*dep = to_dwc3_ep(ep);
 
-	unsigned long			flags;
+	unsigned long			flags = 0;
 
 	int				ret;
 
@@ -1103,7 +1115,7 @@ static int dwc3_gadget_ep_dequeue(struct usb_ep *ep,
 	struct dwc3_ep			*dep = to_dwc3_ep(ep);
 	struct dwc3			*dwc = dep->dwc;
 
-	unsigned long			flags;
+	unsigned long			flags = 0;
 	int				ret = 0;
 
 	spin_lock_irqsave(&dwc->lock, flags);
@@ -1185,7 +1197,7 @@ static int dwc3_gadget_ep_set_halt(struct usb_ep *ep, int value)
 {
 	struct dwc3_ep			*dep = to_dwc3_ep(ep);
 
-	unsigned long			flags;
+	unsigned long			flags = 0;
 
 	int				ret;
 
@@ -1199,7 +1211,7 @@ static int dwc3_gadget_ep_set_halt(struct usb_ep *ep, int value)
 static int dwc3_gadget_ep_set_wedge(struct usb_ep *ep)
 {
 	struct dwc3_ep			*dep = to_dwc3_ep(ep);
-	unsigned long			flags;
+	unsigned long			flags = 0;
 	int				ret;
 
 	spin_lock_irqsave(&dwc->lock, flags);
@@ -1260,7 +1272,7 @@ static int dwc3_gadget_wakeup(struct usb_gadget *g)
 	struct dwc3		*dwc = gadget_to_dwc(g);
 
 	unsigned long		timeout;
-	unsigned long		flags;
+	unsigned long		flags = 0;
 
 	u32			reg;
 
@@ -1339,7 +1351,7 @@ static int dwc3_gadget_set_selfpowered(struct usb_gadget *g,
 		int is_selfpowered)
 {
 	struct dwc3		*dwc = gadget_to_dwc(g);
-	unsigned long		flags;
+	unsigned long		flags = 0;
 
 	spin_lock_irqsave(&dwc->lock, flags);
 	dwc->is_selfpowered = !!is_selfpowered;
@@ -1405,7 +1417,7 @@ static int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on, int suspend)
 static int dwc3_gadget_pullup(struct usb_gadget *g, int is_on)
 {
 	struct dwc3		*dwc = gadget_to_dwc(g);
-	unsigned long		flags;
+	unsigned long		flags = 0;
 	int			ret;
 
 	is_on = !!is_on;
@@ -1446,7 +1458,7 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 {
 	struct dwc3		*dwc = gadget_to_dwc(g);
 	struct dwc3_ep		*dep;
-	unsigned long		flags;
+	unsigned long		flags = 0;
 	int			ret = 0;
 	u32			reg;
 
@@ -1545,7 +1557,7 @@ err1:
 static int dwc3_gadget_stop(struct usb_gadget *g)
 {
 	struct dwc3		*dwc = gadget_to_dwc(g);
-	unsigned long		flags;
+	unsigned long		flags = 0;
 
 	spin_lock_irqsave(&dwc->lock, flags);
 
@@ -1605,7 +1617,10 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 		} else {
 			int		ret;
 
-			usb_ep_set_maxpacket_limit(&dep->endpoint, 512);
+			if (dwc->maximum_speed < USB_SPEED_SUPER)
+				usb_ep_set_maxpacket_limit(&dep->endpoint, 512);
+			else
+				usb_ep_set_maxpacket_limit(&dep->endpoint, 1024);
 			dep->endpoint.max_streams = 15;
 			dep->endpoint.ops = &dwc3_gadget_ep_ops;
 			list_add_tail(&dep->endpoint.ep_list,
@@ -1798,12 +1813,17 @@ static void dwc3_endpoint_transfer_complete(struct dwc3 *dwc,
 {
 	unsigned		status = 0;
 	int			clean_busy;
+	u32			is_xfer_complete;
+	int			ret;
+
+	is_xfer_complete = (event->endpoint_event == DWC3_DEPEVT_XFERCOMPLETE);
 
 	if (event->status & DEPEVT_STATUS_BUSERR)
 		status = -ECONNRESET;
 
 	clean_busy = dwc3_cleanup_done_reqs(dwc, dep, event, status);
-	if (clean_busy)
+	if (clean_busy && (is_xfer_complete ||
+			   usb_endpoint_xfer_isoc(dep->endpoint.desc)))
 		dep->flags &= ~DWC3_EP_BUSY;
 
 	/*
@@ -1830,6 +1850,12 @@ static void dwc3_endpoint_transfer_complete(struct dwc3 *dwc,
 
 		dwc->u1u2 = 0;
 	}
+
+	if (!usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
+		ret = __dwc3_gadget_kick_transfer(dep, 0, is_xfer_complete);
+		if (!ret || ret == -EBUSY)
+			return;
+	}
 }
 
 static void dwc3_endpoint_interrupt(struct dwc3 *dwc,
@@ -2456,6 +2482,7 @@ static irqreturn_t dwc3_process_event_buf(struct dwc3 *dwc, u32 buf)
 	while (left > 0) {
 		union dwc3_event event;
 
+		invalidate_dcache_range((uintptr_t)evt->buf, evt->length);
 		event.raw = *(u32 *) (evt->buf + evt->lpos);
 
 		dwc3_process_event_entry(dwc, &event);
@@ -2490,7 +2517,7 @@ static irqreturn_t dwc3_process_event_buf(struct dwc3 *dwc, u32 buf)
 static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc)
 {
 	struct dwc3 *dwc = _dwc;
-	unsigned long flags;
+	unsigned long flags = 0;
 	irqreturn_t ret = IRQ_NONE;
 	int i;
 
@@ -2610,7 +2637,7 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 	if (ret)
 		goto err4;
 
-	ret = usb_add_gadget_udc(dwc->dev, &dwc->gadget);
+	ret = usb_add_gadget_udc((struct device *)dwc->dev, &dwc->gadget);
 	if (ret) {
 		dev_err(dwc->dev, "failed to register udc\n");
 		goto err4;
diff --git a/drivers/usb/dwc3/linux-compat.h b/drivers/usb/dwc3/linux-compat.h
index 9e944a31be..42c41ccc17 100644
--- a/drivers/usb/dwc3/linux-compat.h
+++ b/drivers/usb/dwc3/linux-compat.h
@@ -12,10 +12,7 @@
 #ifndef __DWC3_LINUX_COMPAT__
 #define __DWC3_LINUX_COMPAT__
 
-#define pr_debug(format)                debug(format)
-#define WARN(val, format, arg...)	debug(format, ##arg)
 #define dev_WARN(dev, format, arg...)	debug(format, ##arg)
-#define WARN_ON_ONCE(val)		debug("Error %d\n", val)
 
 static inline size_t strlcat(char *dest, const char *src, size_t n)
 {
@@ -23,9 +20,4 @@ static inline size_t strlcat(char *dest, const char *src, size_t n)
 	return strlen(dest) + strlen(src);
 }
 
-static inline void *devm_kzalloc(struct device *dev, unsigned int size,
-				 unsigned int flags)
-{
-	return kzalloc(size, flags);
-}
 #endif
diff --git a/drivers/usb/dwc3/ti_usb_phy.c b/drivers/usb/dwc3/ti_usb_phy.c
index 218a8e586c..2cf4253209 100644
--- a/drivers/usb/dwc3/ti_usb_phy.c
+++ b/drivers/usb/dwc3/ti_usb_phy.c
@@ -20,10 +20,10 @@
 #include <common.h>
 #include <malloc.h>
 #include <ti-usb-phy-uboot.h>
-#include <usb/lin_gadget_compat.h>
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <asm/arch/sys_proto.h>
+#include <dm.h>
 
 #include "linux-compat.h"
 
diff --git a/drivers/usb/emul/sandbox_flash.c b/drivers/usb/emul/sandbox_flash.c
index 98d20c0bc1..2f84b360ec 100644
--- a/drivers/usb/emul/sandbox_flash.c
+++ b/drivers/usb/emul/sandbox_flash.c
@@ -390,8 +390,7 @@ static int sandbox_flash_bind(struct udevice *dev)
 	fs[2].id = STRINGID_SERIAL;
 	fs[2].s = dev->name;
 
-	return usb_emul_setup_device(dev, PACKET_SIZE_64, plat->flash_strings,
-				     flash_desc_list);
+	return usb_emul_setup_device(dev, plat->flash_strings, flash_desc_list);
 }
 
 static int sandbox_flash_probe(struct udevice *dev)
diff --git a/drivers/usb/emul/sandbox_hub.c b/drivers/usb/emul/sandbox_hub.c
index 1432858fd5..9a0f47b81c 100644
--- a/drivers/usb/emul/sandbox_hub.c
+++ b/drivers/usb/emul/sandbox_hub.c
@@ -121,9 +121,12 @@ struct sandbox_hub_priv {
 	int change[SANDBOX_NUM_PORTS];
 };
 
-static struct udevice *hub_find_device(struct udevice *hub, int port)
+static struct udevice *hub_find_device(struct udevice *hub, int port,
+				       enum usb_device_speed *speed)
 {
 	struct udevice *dev;
+	struct usb_generic_descriptor **gen_desc;
+	struct usb_device_descriptor **dev_desc;
 
 	for (device_find_first_child(hub, &dev);
 	     dev;
@@ -131,8 +134,27 @@ static struct udevice *hub_find_device(struct udevice *hub, int port)
 		struct sandbox_hub_platdata *plat;
 
 		plat = dev_get_parent_platdata(dev);
-		if (plat->port == port)
+		if (plat->port == port) {
+			gen_desc = plat->plat.desc_list;
+			gen_desc = usb_emul_find_descriptor(gen_desc,
+							    USB_DT_DEVICE, 0);
+			dev_desc = (struct usb_device_descriptor **)gen_desc;
+
+			switch (le16_to_cpu((*dev_desc)->bcdUSB)) {
+			case 0x0100:
+				*speed = USB_SPEED_LOW;
+				break;
+			case 0x0101:
+				*speed = USB_SPEED_FULL;
+				break;
+			case 0x0200:
+			default:
+				*speed = USB_SPEED_HIGH;
+				break;
+			}
+
 			return dev;
+		}
 	}
 
 	return NULL;
@@ -146,7 +168,8 @@ static int clrset_post_state(struct udevice *hub, int port, int clear, int set)
 	int ret = 0;
 
 	if ((clear | set) & USB_PORT_STAT_POWER) {
-		struct udevice *dev = hub_find_device(hub, port);
+		enum usb_device_speed speed;
+		struct udevice *dev = hub_find_device(hub, port, &speed);
 
 		if (dev) {
 			if (set & USB_PORT_STAT_POWER) {
@@ -156,6 +179,10 @@ static int clrset_post_state(struct udevice *hub, int port, int clear, int set)
 				if (!ret) {
 					set |= USB_PORT_STAT_CONNECTION |
 						USB_PORT_STAT_ENABLE;
+					if (speed == USB_SPEED_LOW)
+						set |= USB_PORT_STAT_LOW_SPEED;
+					else if (speed == USB_SPEED_HIGH)
+						set |= USB_PORT_STAT_HIGH_SPEED;
 				}
 
 			} else if (clear & USB_PORT_STAT_POWER) {
@@ -274,15 +301,16 @@ static int sandbox_hub_submit_control_msg(struct udevice *bus,
 
 static int sandbox_hub_bind(struct udevice *dev)
 {
-	return usb_emul_setup_device(dev, PACKET_SIZE_64, hub_strings,
-				     hub_desc_list);
+	return usb_emul_setup_device(dev, hub_strings, hub_desc_list);
 }
 
 static int sandbox_child_post_bind(struct udevice *dev)
 {
 	struct sandbox_hub_platdata *plat = dev_get_parent_platdata(dev);
+	struct usb_emul_platdata *emul = dev_get_uclass_platdata(dev);
 
 	plat->port = dev_read_u32_default(dev, "reg", -1);
+	emul->port1 = plat->port + 1;
 
 	return 0;
 }
diff --git a/drivers/usb/emul/sandbox_keyb.c b/drivers/usb/emul/sandbox_keyb.c
index 27359851df..f7247eef8c 100644
--- a/drivers/usb/emul/sandbox_keyb.c
+++ b/drivers/usb/emul/sandbox_keyb.c
@@ -181,7 +181,8 @@ static int sandbox_keyb_control(struct udevice *dev, struct usb_device *udev,
 }
 
 static int sandbox_keyb_interrupt(struct udevice *dev, struct usb_device *udev,
-		unsigned long pipe, void *buffer, int length, int interval)
+		unsigned long pipe, void *buffer, int length, int interval,
+		bool nonblock)
 {
 	struct sandbox_keyb_priv *priv = dev_get_priv(dev);
 	uint8_t *data = buffer;
@@ -208,8 +209,7 @@ static int sandbox_keyb_bind(struct udevice *dev)
 	fs[2].id = STRINGID_SERIAL;
 	fs[2].s = dev->name;
 
-	return usb_emul_setup_device(dev, PACKET_SIZE_8, plat->keyb_strings,
-				     keyb_desc_list);
+	return usb_emul_setup_device(dev, plat->keyb_strings, keyb_desc_list);
 }
 
 static int sandbox_keyb_probe(struct udevice *dev)
diff --git a/drivers/usb/emul/usb-emul-uclass.c b/drivers/usb/emul/usb-emul-uclass.c
index 6e03c1e0d9..0aeddf826a 100644
--- a/drivers/usb/emul/usb-emul-uclass.c
+++ b/drivers/usb/emul/usb-emul-uclass.c
@@ -52,7 +52,7 @@ static int usb_emul_get_string(struct usb_string *strings, int index,
 	return -EINVAL;
 }
 
-static struct usb_generic_descriptor **find_descriptor(
+struct usb_generic_descriptor **usb_emul_find_descriptor(
 		struct usb_generic_descriptor **ptr, int type, int index)
 {
 	debug("%s: type=%x, index=%d\n", __func__, type, index);
@@ -91,8 +91,7 @@ static int usb_emul_get_descriptor(struct usb_dev_platdata *plat, int value,
 					   length);
 	}
 
-	ptr = find_descriptor((struct usb_generic_descriptor **)plat->desc_list,
-			      type, index);
+	ptr = usb_emul_find_descriptor(plat->desc_list, type, index);
 	if (!ptr) {
 		debug("%s: Could not find descriptor type %d, index %d\n",
 		      __func__, type, index);
@@ -107,7 +106,7 @@ static int usb_emul_get_descriptor(struct usb_dev_platdata *plat, int value,
 	return upto ? upto : length ? -EIO : 0;
 }
 
-static int usb_emul_find_devnum(int devnum, struct udevice **emulp)
+static int usb_emul_find_devnum(int devnum, int port1, struct udevice **emulp)
 {
 	struct udevice *dev;
 	struct uclass *uc;
@@ -120,7 +119,37 @@ static int usb_emul_find_devnum(int devnum, struct udevice **emulp)
 	uclass_foreach_dev(dev, uc) {
 		struct usb_dev_platdata *udev = dev_get_parent_platdata(dev);
 
-		if (udev->devnum == devnum) {
+		/*
+		 * devnum is initialzied to zero at the beginning of the
+		 * enumeration process in usb_setup_device(). At this
+		 * point, udev->devnum has not been assigned to any valid
+		 * USB address either, so we can't rely on the comparison
+		 * result between udev->devnum and devnum to select an
+		 * emulator device.
+		 */
+		if (!devnum) {
+			struct usb_emul_platdata *plat;
+
+			/*
+			 * If the parent is sandbox USB controller, we are
+			 * the root hub. And there is only one root hub
+			 * in the system.
+			 */
+			if (device_get_uclass_id(dev->parent) == UCLASS_USB) {
+				debug("%s: Found emulator '%s'\n",
+				      __func__, dev->name);
+				*emulp = dev;
+				return 0;
+			}
+
+			plat = dev_get_uclass_platdata(dev);
+			if (plat->port1 == port1) {
+				debug("%s: Found emulator '%s', port %d\n",
+				      __func__, dev->name, port1);
+				*emulp = dev;
+				return 0;
+			}
+		} else if (udev->devnum == devnum) {
 			debug("%s: Found emulator '%s', addr %d\n", __func__,
 			      dev->name, udev->devnum);
 			*emulp = dev;
@@ -132,18 +161,19 @@ static int usb_emul_find_devnum(int devnum, struct udevice **emulp)
 	return -ENOENT;
 }
 
-int usb_emul_find(struct udevice *bus, ulong pipe, struct udevice **emulp)
+int usb_emul_find(struct udevice *bus, ulong pipe, int port1,
+		  struct udevice **emulp)
 {
 	int devnum = usb_pipedevice(pipe);
 
-	return usb_emul_find_devnum(devnum, emulp);
+	return usb_emul_find_devnum(devnum, port1, emulp);
 }
 
 int usb_emul_find_for_dev(struct udevice *dev, struct udevice **emulp)
 {
 	struct usb_dev_platdata *udev = dev_get_parent_platdata(dev);
 
-	return usb_emul_find_devnum(udev->devnum, emulp);
+	return usb_emul_find_devnum(udev->devnum, 0, emulp);
 }
 
 int usb_emul_control(struct udevice *emul, struct usb_device *udev,
@@ -218,7 +248,8 @@ int usb_emul_bulk(struct udevice *emul, struct usb_device *udev,
 }
 
 int usb_emul_int(struct udevice *emul, struct usb_device *udev,
-		  unsigned long pipe, void *buffer, int length, int interval)
+		  unsigned long pipe, void *buffer, int length, int interval,
+		  bool nonblock)
 {
 	struct dm_usb_ops *ops = usb_get_emul_ops(emul);
 
@@ -226,11 +257,12 @@ int usb_emul_int(struct udevice *emul, struct usb_device *udev,
 		return -ENOSYS;
 	debug("%s: dev=%s\n", __func__, emul->name);
 
-	return ops->interrupt(emul, udev, pipe, buffer, length, interval);
+	return ops->interrupt(emul, udev, pipe, buffer, length, interval,
+			      nonblock);
 }
 
-int usb_emul_setup_device(struct udevice *dev, int maxpacketsize,
-			  struct usb_string *strings, void **desc_list)
+int usb_emul_setup_device(struct udevice *dev, struct usb_string *strings,
+			  void **desc_list)
 {
 	struct usb_dev_platdata *plat = dev_get_parent_platdata(dev);
 	struct usb_generic_descriptor **ptr;
@@ -264,18 +296,11 @@ int usb_emul_setup_device(struct udevice *dev, int maxpacketsize,
 	return 0;
 }
 
-void usb_emul_reset(struct udevice *dev)
-{
-	struct usb_dev_platdata *plat = dev_get_parent_platdata(dev);
-
-	plat->devnum = 0;
-	plat->configno = 0;
-}
-
 UCLASS_DRIVER(usb_emul) = {
 	.id		= UCLASS_USB_EMUL,
 	.name		= "usb_emul",
 	.post_bind	= dm_scan_fdt_dev,
+	.per_device_platdata_auto_alloc_size = sizeof(struct usb_emul_platdata),
 	.per_child_auto_alloc_size = sizeof(struct usb_device),
 	.per_child_platdata_auto_alloc_size = sizeof(struct usb_dev_platdata),
 };
diff --git a/drivers/usb/eth/lan78xx.c b/drivers/usb/eth/lan78xx.c
index d1e61c32da..11431381cb 100644
--- a/drivers/usb/eth/lan78xx.c
+++ b/drivers/usb/eth/lan78xx.c
@@ -297,7 +297,7 @@ static int lan78xx_basic_reset(struct usb_device *udev,
 	ret = lan7x_read_reg(udev, LAN78XX_USB_CFG0, &val);
 	if (ret)
 		return ret;
-	val |= LAN78XX_USB_CFG0_BIR;
+	val &= ~LAN78XX_USB_CFG0_BIR;
 	return lan7x_write_reg(udev, LAN78XX_USB_CFG0, val);
 }
 
diff --git a/drivers/usb/eth/mcs7830.c b/drivers/usb/eth/mcs7830.c
index 4abef5d5c8..941d612a68 100644
--- a/drivers/usb/eth/mcs7830.c
+++ b/drivers/usb/eth/mcs7830.c
@@ -418,25 +418,25 @@ static int mcs7830_basic_reset(struct usb_device *udev,
 
 	rc = mcs7830_set_autoneg(udev);
 	if (rc < 0) {
-		error("setting autoneg failed\n");
+		pr_err("setting autoneg failed\n");
 		return rc;
 	}
 
 	rc = mcs7830_write_mchash(udev, priv);
 	if (rc < 0) {
-		error("failed to set multicast hash\n");
+		pr_err("failed to set multicast hash\n");
 		return rc;
 	}
 
 	rc = mcs7830_write_config(udev, priv);
 	if (rc < 0) {
-		error("failed to set configuration\n");
+		pr_err("failed to set configuration\n");
 		return rc;
 	}
 
 	rc = mcs7830_apply_fixup(udev);
 	if (rc < 0) {
-		error("fixup application failed\n");
+		pr_err("fixup application failed\n");
 		return rc;
 	}
 
@@ -541,11 +541,11 @@ static int mcs7830_recv_common(struct ueth_data *ueth, uint8_t *buf)
 	debug("%s() RX want len %d, got len %d, rc %d\n",
 	      __func__, wantlen, gotlen, rc);
 	if (rc != 0) {
-		error("RX: failed to receive\n");
+		pr_err("RX: failed to receive\n");
 		return rc;
 	}
 	if (gotlen > wantlen) {
-		error("RX: got too many bytes (%d)\n", gotlen);
+		pr_err("RX: got too many bytes (%d)\n", gotlen);
 		return -EIO;
 	}
 
diff --git a/drivers/usb/eth/r8152.c b/drivers/usb/eth/r8152.c
index e09351b0d2..7fc4acc375 100644
--- a/drivers/usb/eth/r8152.c
+++ b/drivers/usb/eth/r8152.c
@@ -11,7 +11,6 @@
 #include <malloc.h>
 #include <memalign.h>
 #include <usb.h>
-#include <usb/lin_gadget_compat.h>
 #include <linux/mii.h>
 #include <linux/bitops.h>
 #include "usb_ether.h"
diff --git a/drivers/usb/eth/usb_ether.c b/drivers/usb/eth/usb_ether.c
index 36734e2e51..b76f5cc2fa 100644
--- a/drivers/usb/eth/usb_ether.c
+++ b/drivers/usb/eth/usb_ether.c
@@ -272,7 +272,7 @@ int usb_host_eth_scan(int mode)
 	}
 
 	usb_max_eth_dev = 0;
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	/*
 	 * TODO: We should add U_BOOT_USB_DEVICE() declarations to each USB
 	 * Ethernet driver and then most of this file can be removed.
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 225b66bc95..33cb3dcd9a 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -36,6 +36,30 @@ menuconfig USB_GADGET
 
 if USB_GADGET
 
+config USB_GADGET_MANUFACTURER
+	string "Vendor name of the USB device"
+	default "Allwinner Technology" if ARCH_SUNXI
+	default "U-Boot"
+	help
+	  Vendor name of the USB device emulated, reported to the host device.
+	  This is usually either the manufacturer of the device or the SoC.
+
+config USB_GADGET_VENDOR_NUM
+	hex "Vendor ID of the USB device"
+	default 0x1f3a if ARCH_SUNXI
+	default 0x0
+	help
+	  Vendor ID of the USB device emulated, reported to the host device.
+	  This is usually the board or SoC vendor's, unless you've registered
+	  for one.
+
+config USB_GADGET_PRODUCT_NUM
+	hex "Product ID of the USB device"
+	default 0x1010 if ARCH_SUNXI
+	default 0x0
+	help
+	  Product ID of the USB device emulated, reported to the host device.
+
 config USB_GADGET_ATMEL_USBA
 	bool "Atmel USBA"
 	select USB_GADGET_DUALSPEED
@@ -110,19 +134,63 @@ config USB_FUNCTION_SDP
 	  allows to download images into memory and execute (jump to) them
 	  using the same protocol as implemented by the i.MX family's boot ROM.
 
-config G_DNL_MANUFACTURER
-	string "Vendor name of USB device"
+endif # USB_GADGET_DOWNLOAD
 
-config G_DNL_VENDOR_NUM
-	hex "Vendor ID of USB device"
+config USB_ETHER
+	bool "USB Ethernet Gadget"
+	depends on NET
+	help
+	  Creates an Ethernet network device through a USB peripheral
+	  controller. This will create a network interface on both the device
+	  (U-Boot) and the host (remote device) that can be used just like any
+	  other nework interface.
+	  It will bind on the peripheral USB controller, ignoring the USB hosts
+	  controllers in the system.
+
+if USB_ETHER
+
+choice
+	prompt "USB Ethernet Gadget Model"
+	default USB_ETH_RNDIS
+	help
+	  There is several models (protocols) to implement Ethernet over USB
+	  devices. The main ones are Microsoft's RNDIS and USB's CDC-Ethernet
+	  (also called CDC-ECM). RNDIS is obviously compatible with Windows,
+	  while CDC-ECM is not. Most other operating systems support both, so
+	  if inter-operability is a concern, RNDIS is to be preferred.
+
+config USB_ETH_CDC
+	bool "CDC-ECM Protocol"
+	help
+	  CDC (Communications Device Class) is the standard for Ethernet over
+	  USB devices. While there's several alternatives, the most widely used
+	  protocol is ECM (Ethernet Control Model). However, compatibility with
+	  Windows is not that great.
+
+config USB_ETH_RNDIS
+	bool "RNDIS Protocol"
+	help
+	  The RNDIS (Remote Network Driver Interface Specification) is a
+	  Microsoft proprietary protocol to create an Ethernet device over USB.
+	  Windows obviously supports it, as well as all the major operating
+	  systems, so it's the best option for compatibility.
 
-config G_DNL_PRODUCT_NUM
-	hex "Product ID of USB device"
+endchoice
 
 config USBNET_DEVADDR
 	string "USB Gadget Ethernet device mac address"
 	default "de:ad:be:ef:00:01"
+	help
+	  Ethernet MAC address of the device-side (ie. local board's) MAC
+	  address of the usb_ether interface
 
-endif # USB_GADGET_DOWNLOAD
+config USBNET_HOST_ADDR
+	string "USB Gadget Ethernet host mac address"
+	default "de:ad:be:ef:00:00"
+	help
+	  Ethernet MAC address of the host-side (ie. remote device's) MAC
+	  address of the usb_ether interface
+
+endif # USB_ETHER
 
 endif # USB_GADGET
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 7258099c1c..97b904de85 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -9,8 +9,8 @@ obj-$(CONFIG_USB_GADGET) += epautoconf.o config.o usbstring.o
 obj-$(CONFIG_USB_ETHER) += epautoconf.o config.o usbstring.o
 
 ifdef CONFIG_SPL_BUILD
-obj-$(CONFIG_SPL_USB_GADGET_SUPPORT) += g_dnl.o
-obj-$(CONFIG_SPL_DFU_SUPPORT) += f_dfu.o
+obj-$(CONFIG_SPL_USB_GADGET) += g_dnl.o
+obj-$(CONFIG_SPL_DFU) += f_dfu.o
 obj-$(CONFIG_SPL_USB_SDP_SUPPORT) += f_sdp.o
 endif
 
diff --git a/drivers/usb/gadget/at91_udc.c b/drivers/usb/gadget/at91_udc.c
index 9df6d32c65..d88219ff92 100644
--- a/drivers/usb/gadget/at91_udc.c
+++ b/drivers/usb/gadget/at91_udc.c
@@ -25,7 +25,6 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/at91_udc.h>
 #include <malloc.h>
-#include <usb/lin_gadget_compat.h>
 
 #include "at91_udc.h"
 
@@ -1456,7 +1455,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 
 	ret = driver->bind(&udc->gadget);
 	if (ret) {
-		error("driver->bind() returned %d\n", ret);
+		pr_err("driver->bind() returned %d\n", ret);
 		udc->driver = NULL;
 	}
 
@@ -1468,7 +1467,7 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	struct at91_udc *udc = controller;
 
 	if (!driver || !driver->unbind || !driver->disconnect) {
-		error("bad paramter\n");
+		pr_err("bad paramter\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/usb/gadget/atmel_usba_udc.c b/drivers/usb/gadget/atmel_usba_udc.c
index ad31703c73..adb345340b 100644
--- a/drivers/usb/gadget/atmel_usba_udc.c
+++ b/drivers/usb/gadget/atmel_usba_udc.c
@@ -17,7 +17,6 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/atmel_usba_udc.h>
 #include <malloc.h>
-#include <usb/lin_gadget_compat.h>
 
 #include "atmel_usba_udc.h"
 
@@ -1228,7 +1227,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 
 	ret = driver->bind(&udc->gadget);
 	if (ret) {
-		error("driver->bind() returned %d\n", ret);
+		pr_err("driver->bind() returned %d\n", ret);
 		udc->driver = NULL;
 	}
 
@@ -1240,7 +1239,7 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	struct usba_udc *udc = &controller;
 
 	if (!driver || !driver->unbind || !driver->disconnect) {
-		error("bad paramter\n");
+		pr_err("bad paramter\n");
 		return -EINVAL;
 	}
 
@@ -1261,7 +1260,7 @@ static struct usba_ep *usba_udc_pdata(struct usba_platform_data *pdata,
 
 	eps = malloc(sizeof(struct usba_ep) * pdata->num_ep);
 	if (!eps) {
-		error("failed to alloc eps\n");
+		pr_err("failed to alloc eps\n");
 		return NULL;
 	}
 
diff --git a/drivers/usb/gadget/ci_udc.c b/drivers/usb/gadget/ci_udc.c
index 05c01ce5d6..a19dd0a14e 100644
--- a/drivers/usb/gadget/ci_udc.c
+++ b/drivers/usb/gadget/ci_udc.c
@@ -1009,7 +1009,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 	if (driver->speed != USB_SPEED_FULL && driver->speed != USB_SPEED_HIGH)
 		return -EINVAL;
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	ret = usb_setup_ehci_gadget(&controller.ctrl);
 #else
 	ret = usb_lowlevel_init(0, USB_INIT_DEVICE, (void **)&controller.ctrl);
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d0ee7847b9..89341e8832 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -13,8 +13,16 @@
 
 #define USB_BUFSIZ	4096
 
+/* Helper type for accessing packed u16 pointers */
+typedef struct { __le16 val; } __packed __le16_packed;
+
 static struct usb_composite_driver *composite;
 
+static inline void le16_add_cpu_packed(__le16_packed *var, u16 val)
+{
+	var->val = cpu_to_le16(le16_to_cpu(var->val) + val);
+}
+
 /**
  * usb_add_function() - add a function to a configuration
  * @config: the configuration
@@ -57,6 +65,8 @@ int usb_add_function(struct usb_configuration *config,
 		config->fullspeed = 1;
 	if (!config->highspeed && function->hs_descriptors)
 		config->highspeed = 1;
+	if (!config->superspeed && function->ss_descriptors)
+		config->superspeed = 1;
 
 done:
 	if (value)
@@ -165,7 +175,7 @@ static int config_buf(struct usb_configuration *config,
 	int				len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;
 	void				*next = buf + USB_DT_CONFIG_SIZE;
 	struct usb_descriptor_header    **descriptors;
-	struct usb_config_descriptor	*c = buf;
+	struct usb_config_descriptor	*c;
 	int				status;
 	struct usb_function		*f;
 
@@ -192,10 +202,17 @@ static int config_buf(struct usb_configuration *config,
 
 	/* add each function's descriptors */
 	list_for_each_entry(f, &config->functions, list) {
-		if (speed == USB_SPEED_HIGH)
+		switch (speed) {
+		case USB_SPEED_SUPER:
+			descriptors = f->ss_descriptors;
+			break;
+		case USB_SPEED_HIGH:
 			descriptors = f->hs_descriptors;
-		else
+			break;
+		default:
 			descriptors = f->descriptors;
+		}
+
 		if (!descriptors)
 			continue;
 		status = usb_descriptor_fillbuf(next, len,
@@ -219,7 +236,9 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 	int                             hs = 0;
 	struct usb_configuration	*c;
 
-	if (gadget_is_dualspeed(gadget)) {
+	if (gadget->speed == USB_SPEED_SUPER)
+		speed = gadget->speed;
+	else if (gadget_is_dualspeed(gadget)) {
 		if (gadget->speed == USB_SPEED_HIGH)
 			hs = 1;
 		if (type == USB_DT_OTHER_SPEED_CONFIG)
@@ -230,13 +249,20 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 
 	w_value &= 0xff;
 	list_for_each_entry(c, &cdev->configs, list) {
-		if (speed == USB_SPEED_HIGH) {
+		switch (speed) {
+		case USB_SPEED_SUPER:
+			if (!c->superspeed)
+				continue;
+			break;
+		case USB_SPEED_HIGH:
 			if (!c->highspeed)
 				continue;
-		} else {
+			break;
+		default:
 			if (!c->fullspeed)
 				continue;
 		}
+
 		if (w_value == 0)
 			return config_buf(c, speed, cdev->req->buf, type);
 		w_value--;
@@ -332,21 +358,24 @@ static int set_config(struct usb_composite_dev *cdev,
 		result = 0;
 
 	debug("%s: %s speed config #%d: %s\n", __func__,
-	     ({ char *speed;
-		     switch (gadget->speed) {
-		     case USB_SPEED_LOW:
-			     speed = "low";
-			     break;
-		     case USB_SPEED_FULL:
-			     speed = "full";
-			     break;
-		     case USB_SPEED_HIGH:
-			     speed = "high";
-			     break;
-		     default:
-			     speed = "?";
-			     break;
-		     };
+	      ({ char *speed;
+		switch (gadget->speed) {
+		case USB_SPEED_LOW:
+			speed = "low";
+			break;
+		case USB_SPEED_FULL:
+			speed = "full";
+			break;
+		case USB_SPEED_HIGH:
+			speed = "high";
+			break;
+		case USB_SPEED_SUPER:
+			speed = "super";
+			break;
+		default:
+			speed = "?";
+			break;
+		};
 		     speed;
 	     }), number, c ? c->label : "unconfigured");
 
@@ -367,10 +396,16 @@ static int set_config(struct usb_composite_dev *cdev,
 		 * function's setup callback instead of the current
 		 * configuration's setup callback.
 		 */
-		if (gadget->speed == USB_SPEED_HIGH)
+		switch (gadget->speed) {
+		case USB_SPEED_SUPER:
+			descriptors = f->ss_descriptors;
+			break;
+		case USB_SPEED_HIGH:
 			descriptors = f->hs_descriptors;
-		else
+			break;
+		default:
 			descriptors = f->descriptors;
+		}
 
 		for (; *descriptors; ++descriptors) {
 			if ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)
@@ -379,7 +414,7 @@ static int set_config(struct usb_composite_dev *cdev,
 			ep = (struct usb_endpoint_descriptor *)*descriptors;
 			addr = ((ep->bEndpointAddress & 0x80) >> 3)
 			     |	(ep->bEndpointAddress & 0x0f);
-			__set_bit(addr, f->endpoints);
+			generic_set_bit(addr, f->endpoints);
 		}
 
 		result = f->set_alt(f, tmp, 0);
@@ -447,14 +482,13 @@ int usb_add_config(struct usb_composite_dev *cdev,
 		list_del(&config->list);
 		config->cdev = NULL;
 	} else {
-		debug("cfg %d/%p speeds:%s%s\n",
-			config->bConfigurationValue, config,
-			config->highspeed ? " high" : "",
-			config->fullspeed
-				? (gadget_is_dualspeed(cdev->gadget)
-					? " full"
-					: " full/low")
-				: "");
+		debug("cfg %d/%p speeds:%s%s%s\n",
+		      config->bConfigurationValue, config,
+		      config->superspeed ? " super" : "",
+		      config->highspeed ? " high" : "",
+		      config->fullspeed ?
+		      (gadget_is_dualspeed(cdev->gadget) ?
+		      " full" : " full/low") : "");
 
 		for (i = 0; i < MAX_CONFIG_INTERFACES; i++) {
 			f = config->interface[i];
@@ -481,20 +515,21 @@ done:
  * the host side.
  */
 
-static void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)
+static void collect_langs(struct usb_gadget_strings **sp, void *buf)
 {
 	const struct usb_gadget_strings	*s;
 	u16				language;
-	__le16				*tmp;
+	__le16_packed			*tmp;
+	__le16_packed			*end = (buf + 252);
 
 	while (*sp) {
 		s = *sp;
 		language = cpu_to_le16(s->language);
-		for (tmp = buf; *tmp && tmp < &buf[126]; tmp++) {
-			if (*tmp == language)
+		for (tmp = buf; tmp->val && tmp < end; tmp++) {
+			if (tmp->val == language)
 				goto repeat;
 		}
-		*tmp++ = language;
+		tmp->val = language;
 repeat:
 		sp++;
 	}
@@ -689,6 +724,65 @@ static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
 				req->status, req->actual, req->length);
 }
 
+static int bos_desc(struct usb_composite_dev *cdev)
+{
+	struct usb_dev_cap_header	*cap;
+	struct usb_ext_cap_descriptor	*usb_ext;
+	struct usb_ss_cap_descriptor	*ss_cap;
+	struct usb_bos_descriptor	*bos = cdev->req->buf;
+
+	bos->bLength = USB_DT_BOS_SIZE;
+	bos->bDescriptorType = USB_DT_BOS;
+	bos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);
+	bos->bNumDeviceCaps = 0;
+
+	if (cdev->gadget->speed < USB_SPEED_SUPER) {
+		/* For rockusb with bcdUSB (0x0201) */
+		cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+		bos->wTotalLength = cpu_to_le16(bos->wTotalLength +
+						sizeof(*cap));
+		cap->bLength = sizeof(*cap);
+		cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		cap->bDevCapabilityType = 0;
+	} else {
+		/*
+		 * A SuperSpeed device shall include the USB2.0
+		 * extension descriptor and shall support LPM when
+		 * operating in USB2.0 HS mode.
+		 */
+		usb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+		le16_add_cpu_packed((__le16_packed *)&bos->wTotalLength,
+				    USB_DT_USB_EXT_CAP_SIZE);
+		usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
+		usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
+		usb_ext->bmAttributes = USB_LPM_SUPPORT;
+
+		/*
+		 * The Superspeed USB Capability descriptor shall be
+		 * implemented by all SuperSpeed devices.
+		 */
+		ss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+		le16_add_cpu_packed((__le16_packed *)&bos->wTotalLength,
+				    USB_DT_USB_SS_CAP_SIZE);
+		ss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;
+		ss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		ss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;
+		ss_cap->bmAttributes = 0; /* LTM is not supported yet */
+		ss_cap->wSpeedSupported = cpu_to_le16(USB_FULL_SPEED_OPERATION |
+				USB_HIGH_SPEED_OPERATION |
+				USB_5GBPS_OPERATION);
+		ss_cap->bFunctionalitySupport = USB_FULL_SPEED_OPERATION;
+		ss_cap->bU1devExitLat = USB_DEFAULT_U1_DEV_EXIT_LAT;
+		ss_cap->bU2DevExitLat = cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
+	}
+
+	return le16_to_cpu(bos->wTotalLength);
+}
+
 /*
  * The setup() callback implements all the ep0 functionality that's
  * not handled lower down, in hardware or the hardware driver(like
@@ -722,6 +816,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	gadget->ep0->driver_data = cdev;
 	standard = (ctrl->bRequestType & USB_TYPE_MASK)
 						== USB_TYPE_STANDARD;
+
 	if (!standard)
 		goto unknown;
 
@@ -736,8 +831,24 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		case USB_DT_DEVICE:
 			cdev->desc.bNumConfigurations =
 				count_configs(cdev, USB_DT_DEVICE);
-			cdev->desc.bMaxPacketSize0 =
-				cdev->gadget->ep0->maxpacket;
+
+			if (gadget_is_superspeed(gadget) &&
+			    gadget->speed >= USB_SPEED_SUPER) {
+				/*
+				 * bcdUSB should be 0x0300 for superspeed,
+				 * but we change it to 0x0301 for rockusb.
+				 */
+				if (!strncmp(cdev->driver->name,
+					     "rkusb_ums_dnl", 13))
+					cdev->desc.bcdUSB = cpu_to_le16(0x0301);
+				else
+					cdev->desc.bcdUSB = cpu_to_le16(0x0300);
+				cdev->desc.bMaxPacketSize0 = 9;
+			} else {
+				cdev->desc.bMaxPacketSize0 =
+					cdev->gadget->ep0->maxpacket;
+			}
+
 			value = min(w_length, (u16) sizeof cdev->desc);
 			memcpy(req->buf, &cdev->desc, value);
 			break;
@@ -764,6 +875,19 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				value = min(w_length, (u16) value);
 			break;
 		case USB_DT_BOS:
+			/* HACK: only for rockusb command.
+			 * Rockchip upgrade tool use bcdUSB (0x0201) field
+			 * distinguishing maskrom or loader device at present.
+			 * Unfortunately, it conflict with Windows 8 and beyond
+			 * which request BOS descriptor in this case that bcdUSB
+			 * is set to 0x0201.
+			 */
+			if (gadget_is_superspeed(gadget) ||
+			    !strncmp(cdev->driver->name, "rkusb_ums_dnl", 13)) {
+				value = bos_desc(cdev);
+				value = min(w_length, (u16) value);
+			}
+
 			/*
 			 * The USB compliance test (USB 2.0 Command Verifier)
 			 * issues this request. We should not run into the
@@ -838,6 +962,9 @@ unknown:
 			ctrl->bRequestType, ctrl->bRequest,
 			w_value, w_index, w_length);
 
+		if (!cdev->config)
+			goto done;
+
 		/*
 		 * functions always handle their interfaces and endpoints...
 		 * punt other recipients (other, WUSB, ...) to the current
@@ -845,10 +972,14 @@ unknown:
 		 */
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
+			if (!cdev->config)
+				break;
 			f = cdev->config->interface[intf];
 			break;
 
 		case USB_RECIP_ENDPOINT:
+			if (!cdev->config)
+				break;
 			endp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);
 			list_for_each_entry(f, &cdev->config->functions, list) {
 				if (test_bit(endp, f->endpoints))
@@ -871,10 +1002,12 @@ unknown:
 		 * special non-standard request.
 		 */
 		case USB_RECIP_DEVICE:
-			debug("cdev->config->next_interface_id: %d intf: %d\n",
-			       cdev->config->next_interface_id, intf);
-			if (cdev->config->next_interface_id == 1)
-				f = cdev->config->interface[intf];
+			if (cdev->config) {
+				debug("cdev->config->next_interface_id: %d intf: %d\n",
+				      cdev->config->next_interface_id, intf);
+				if (cdev->config->next_interface_id == 1)
+					f = cdev->config->interface[intf];
+			}
 			break;
 		}
 
@@ -882,7 +1015,7 @@ unknown:
 			value = f->setup(f, ctrl);
 		else {
 			c = cdev->config;
-			if (c && c->setup)
+			if (c->setup)
 				value = c->setup(c, ctrl);
 		}
 
diff --git a/drivers/usb/gadget/dwc2_udc_otg.c b/drivers/usb/gadget/dwc2_udc_otg.c
index cb44374e81..076bd2c08e 100644
--- a/drivers/usb/gadget/dwc2_udc_otg.c
+++ b/drivers/usb/gadget/dwc2_udc_otg.c
@@ -19,11 +19,17 @@
  */
 #undef DEBUG
 #include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <generic-phy.h>
+#include <malloc.h>
+#include <reset.h>
+
 #include <linux/errno.h>
 #include <linux/list.h>
-#include <malloc.h>
 
 #include <linux/usb/ch9.h>
+#include <linux/usb/otg.h>
 #include <linux/usb/gadget.h>
 
 #include <asm/byteorder.h>
@@ -32,9 +38,10 @@
 
 #include <asm/mach-types.h>
 
+#include <power/regulator.h>
+
 #include "dwc2_udc_otg_regs.h"
 #include "dwc2_udc_otg_priv.h"
-#include <usb/lin_gadget_compat.h>
 
 /***********************************************************/
 
@@ -142,7 +149,6 @@ static struct usb_ep_ops dwc2_ep_ops = {
 
 /***********************************************************/
 
-void __iomem		*regs_otg;
 struct dwc2_usbotg_reg *reg;
 
 bool dfu_usb_get_reset(void)
@@ -169,6 +175,7 @@ static void udc_disable(struct dwc2_udc *dev)
 	dev->ep0state = WAIT_FOR_SETUP;
 	dev->gadget.speed = USB_SPEED_UNKNOWN;
 	dev->usb_address = 0;
+	dev->connected = 0;
 
 	otg_phy_off(dev);
 }
@@ -225,6 +232,7 @@ static int udc_enable(struct dwc2_udc *dev)
 	return 0;
 }
 
+#if !CONFIG_IS_ENABLED(DM_USB_GADGET)
 /*
   Register entry point for the peripheral controller driver.
 */
@@ -299,6 +307,54 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	udc_disable(dev);
 	return 0;
 }
+#else /* !CONFIG_IS_ENABLED(DM_USB_GADGET) */
+
+static int dwc2_gadget_start(struct usb_gadget *g,
+			     struct usb_gadget_driver *driver)
+{
+	struct dwc2_udc *dev = the_controller;
+
+	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");
+
+	if (!driver ||
+	    (driver->speed != USB_SPEED_FULL &&
+	     driver->speed != USB_SPEED_HIGH) ||
+	    !driver->bind || !driver->disconnect || !driver->setup)
+		return -EINVAL;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first hook up the driver ... */
+	dev->driver = driver;
+
+	debug_cond(DEBUG_SETUP != 0,
+		   "Registered gadget driver %s\n", dev->gadget.name);
+	return udc_enable(dev);
+}
+
+static int dwc2_gadget_stop(struct usb_gadget *g)
+{
+	struct dwc2_udc *dev = the_controller;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (!dev->driver)
+		return -EINVAL;
+
+	dev->driver = 0;
+	stop_activity(dev, dev->driver);
+
+	udc_disable(dev);
+
+	return 0;
+}
+
+#endif /* !CONFIG_IS_ENABLED(DM_USB_GADGET) */
 
 /*
  *	done - retire a request; caller blocked irqs
@@ -402,6 +458,8 @@ static void reconfig_usbd(struct dwc2_udc *dev)
 	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
 	uint32_t dflt_gusbcfg;
 	uint32_t rx_fifo_sz, tx_fifo_sz, np_tx_fifo_sz;
+	u32 max_hw_ep;
+	int pdata_hw_ep;
 
 	debug("Reseting OTG controller\n");
 
@@ -484,10 +542,23 @@ static void reconfig_usbd(struct dwc2_udc *dev)
 	writel((np_tx_fifo_sz << 16) | rx_fifo_sz,
 	       &reg->gnptxfsiz);
 
-	for (i = 1; i < DWC2_MAX_HW_ENDPOINTS; i++)
-		writel((rx_fifo_sz + np_tx_fifo_sz + tx_fifo_sz*(i-1)) |
-			tx_fifo_sz << 16, &reg->dieptxf[i-1]);
+	/* retrieve the number of IN Endpoints (excluding ep0) */
+	max_hw_ep = (readl(&reg->ghwcfg4) & GHWCFG4_NUM_IN_EPS_MASK) >>
+		    GHWCFG4_NUM_IN_EPS_SHIFT;
+	pdata_hw_ep = dev->pdata->tx_fifo_sz_nb;
+
+	/* tx_fifo_sz_nb should equal to number of IN Endpoint */
+	if (pdata_hw_ep && max_hw_ep != pdata_hw_ep)
+		pr_warn("Got %d hw endpoint but %d tx-fifo-size in array !!\n",
+			max_hw_ep, pdata_hw_ep);
+
+	for (i = 0; i < max_hw_ep; i++) {
+		if (pdata_hw_ep)
+			tx_fifo_sz = dev->pdata->tx_fifo_sz_array[i];
 
+		writel((rx_fifo_sz + np_tx_fifo_sz + (tx_fifo_sz * i)) |
+			tx_fifo_sz << 16, &reg->dieptxf[i]);
+	}
 	/* Flush the RX FIFO */
 	writel(RX_FIFO_FLUSH, &reg->grstctl);
 	while (readl(&reg->grstctl) & RX_FIFO_FLUSH)
@@ -733,6 +804,10 @@ static void dwc2_fifo_flush(struct usb_ep *_ep)
 
 static const struct usb_gadget_ops dwc2_udc_ops = {
 	/* current versions must always be self-powered */
+#if CONFIG_IS_ENABLED(DM_USB_GADGET)
+	.udc_start		= dwc2_gadget_start,
+	.udc_stop		= dwc2_gadget_stop,
+#endif
 };
 
 static struct dwc2_udc memory = {
@@ -820,8 +895,6 @@ int dwc2_udc_probe(struct dwc2_plat_otg_data *pdata)
 
 	reg = (struct dwc2_usbotg_reg *)pdata->regs_otg;
 
-	/* regs_otg = (void *)pdata->regs_otg; */
-
 	dev->gadget.is_dualspeed = 1;	/* Hack only*/
 	dev->gadget.is_otg = 0;
 	dev->gadget.is_a_peripheral = 0;
@@ -835,7 +908,7 @@ int dwc2_udc_probe(struct dwc2_plat_otg_data *pdata)
 			    ROUND(sizeof(struct usb_ctrlrequest),
 				  CONFIG_SYS_CACHELINE_SIZE));
 	if (!usb_ctrl) {
-		error("No memory available for UDC!\n");
+		pr_err("No memory available for UDC!\n");
 		return -ENOMEM;
 	}
 
@@ -846,12 +919,323 @@ int dwc2_udc_probe(struct dwc2_plat_otg_data *pdata)
 	return retval;
 }
 
-int usb_gadget_handle_interrupts(int index)
+int dwc2_udc_handle_interrupt(void)
 {
 	u32 intr_status = readl(&reg->gintsts);
 	u32 gintmsk = readl(&reg->gintmsk);
 
 	if (intr_status & gintmsk)
 		return dwc2_udc_irq(1, (void *)the_controller);
+
+	return 0;
+}
+
+#if !CONFIG_IS_ENABLED(DM_USB_GADGET)
+
+int usb_gadget_handle_interrupts(int index)
+{
+	return dwc2_udc_handle_interrupt();
+}
+
+#else /* CONFIG_IS_ENABLED(DM_USB_GADGET) */
+
+struct dwc2_priv_data {
+	struct clk_bulk		clks;
+	struct reset_ctl_bulk	resets;
+	struct phy *phys;
+	int num_phys;
+	struct udevice *usb33d_supply;
+};
+
+int dm_usb_gadget_handle_interrupts(struct udevice *dev)
+{
+	return dwc2_udc_handle_interrupt();
+}
+
+int dwc2_phy_setup(struct udevice *dev, struct phy **array, int *num_phys)
+{
+	int i, ret, count;
+	struct phy *usb_phys;
+
+	/* Return if no phy declared */
+	if (!dev_read_prop(dev, "phys", NULL))
+		return 0;
+
+	count = dev_count_phandle_with_args(dev, "phys", "#phy-cells");
+	if (count <= 0)
+		return count;
+
+	usb_phys = devm_kcalloc(dev, count, sizeof(struct phy),
+				GFP_KERNEL);
+	if (!usb_phys)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		ret = generic_phy_get_by_index(dev, i, &usb_phys[i]);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Failed to get USB PHY%d for %s\n",
+				i, dev->name);
+			return ret;
+		}
+	}
+
+	for (i = 0; i < count; i++) {
+		ret = generic_phy_init(&usb_phys[i]);
+		if (ret) {
+			dev_err(dev, "Can't init USB PHY%d for %s\n",
+				i, dev->name);
+			goto phys_init_err;
+		}
+	}
+
+	for (i = 0; i < count; i++) {
+		ret = generic_phy_power_on(&usb_phys[i]);
+		if (ret) {
+			dev_err(dev, "Can't power USB PHY%d for %s\n",
+				i, dev->name);
+			goto phys_poweron_err;
+		}
+	}
+
+	*array = usb_phys;
+	*num_phys =  count;
+
 	return 0;
+
+phys_poweron_err:
+	for (i = count - 1; i >= 0; i--)
+		generic_phy_power_off(&usb_phys[i]);
+
+	for (i = 0; i < count; i++)
+		generic_phy_exit(&usb_phys[i]);
+
+	return ret;
+
+phys_init_err:
+	for (; i >= 0; i--)
+		generic_phy_exit(&usb_phys[i]);
+
+	return ret;
+}
+
+void dwc2_phy_shutdown(struct udevice *dev, struct phy *usb_phys, int num_phys)
+{
+	int i, ret;
+
+	for (i = 0; i < num_phys; i++) {
+		if (!generic_phy_valid(&usb_phys[i]))
+			continue;
+
+		ret = generic_phy_power_off(&usb_phys[i]);
+		ret |= generic_phy_exit(&usb_phys[i]);
+		if (ret) {
+			dev_err(dev, "Can't shutdown USB PHY%d for %s\n",
+				i, dev->name);
+		}
+	}
+}
+
+static int dwc2_udc_otg_ofdata_to_platdata(struct udevice *dev)
+{
+	struct dwc2_plat_otg_data *platdata = dev_get_platdata(dev);
+	ulong drvdata;
+	void (*set_params)(struct dwc2_plat_otg_data *data);
+	int ret;
+
+	if (usb_get_dr_mode(dev->node) != USB_DR_MODE_PERIPHERAL &&
+	    usb_get_dr_mode(dev->node) != USB_DR_MODE_OTG) {
+		dev_dbg(dev, "Invalid mode\n");
+		return -ENODEV;
+	}
+
+	platdata->regs_otg = dev_read_addr(dev);
+
+	platdata->rx_fifo_sz = dev_read_u32_default(dev, "g-rx-fifo-size", 0);
+	platdata->np_tx_fifo_sz = dev_read_u32_default(dev,
+						       "g-np-tx-fifo-size", 0);
+
+	platdata->tx_fifo_sz_nb =
+		dev_read_size(dev, "g-tx-fifo-size") / sizeof(u32);
+	if (platdata->tx_fifo_sz_nb > DWC2_MAX_HW_ENDPOINTS)
+		platdata->tx_fifo_sz_nb = DWC2_MAX_HW_ENDPOINTS;
+	if (platdata->tx_fifo_sz_nb) {
+		ret = dev_read_u32_array(dev, "g-tx-fifo-size",
+					 platdata->tx_fifo_sz_array,
+					 platdata->tx_fifo_sz_nb);
+		if (ret)
+			return ret;
+	}
+
+	platdata->force_b_session_valid =
+		dev_read_bool(dev, "u-boot,force-b-session-valid");
+
+	/* force platdata according compatible */
+	drvdata = dev_get_driver_data(dev);
+	if (drvdata) {
+		set_params = (void *)drvdata;
+		set_params(platdata);
+	}
+
+	return 0;
+}
+
+static void dwc2_set_stm32mp1_hsotg_params(struct dwc2_plat_otg_data *p)
+{
+	p->activate_stm_id_vb_detection = true;
+	p->usb_gusbcfg =
+		0 << 15		/* PHY Low Power Clock sel*/
+		| 0x9 << 10	/* USB Turnaround time (0x9 for HS phy) */
+		| 0 << 9	/* [0:HNP disable,1:HNP enable]*/
+		| 0 << 8	/* [0:SRP disable 1:SRP enable]*/
+		| 0 << 6	/* 0: high speed utmi+, 1: full speed serial*/
+		| 0x7 << 0;	/* FS timeout calibration**/
+
+	if (p->force_b_session_valid)
+		p->usb_gusbcfg |= 1 << 30; /* FDMOD: Force device mode */
+}
+
+static int dwc2_udc_otg_reset_init(struct udevice *dev,
+				   struct reset_ctl_bulk *resets)
+{
+	int ret;
+
+	ret = reset_get_bulk(dev, resets);
+	if (ret == -ENOTSUPP)
+		return 0;
+
+	if (ret)
+		return ret;
+
+	ret = reset_assert_bulk(resets);
+
+	if (!ret) {
+		udelay(2);
+		ret = reset_deassert_bulk(resets);
+	}
+	if (ret) {
+		reset_release_bulk(resets);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dwc2_udc_otg_clk_init(struct udevice *dev,
+				 struct clk_bulk *clks)
+{
+	int ret;
+
+	ret = clk_get_bulk(dev, clks);
+	if (ret == -ENOSYS)
+		return 0;
+
+	if (ret)
+		return ret;
+
+	ret = clk_enable_bulk(clks);
+	if (ret) {
+		clk_release_bulk(clks);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dwc2_udc_otg_probe(struct udevice *dev)
+{
+	struct dwc2_plat_otg_data *platdata = dev_get_platdata(dev);
+	struct dwc2_priv_data *priv = dev_get_priv(dev);
+	struct dwc2_usbotg_reg *usbotg_reg =
+		(struct dwc2_usbotg_reg *)platdata->regs_otg;
+	int ret;
+
+	ret = dwc2_udc_otg_clk_init(dev, &priv->clks);
+	if (ret)
+		return ret;
+
+	ret = dwc2_udc_otg_reset_init(dev, &priv->resets);
+	if (ret)
+		return ret;
+
+	ret = dwc2_phy_setup(dev, &priv->phys, &priv->num_phys);
+	if (ret)
+		return ret;
+
+	if (CONFIG_IS_ENABLED(DM_REGULATOR) &&
+	    platdata->activate_stm_id_vb_detection &&
+	    !platdata->force_b_session_valid) {
+		ret = device_get_supply_regulator(dev, "usb33d-supply",
+						  &priv->usb33d_supply);
+		if (ret) {
+			dev_err(dev, "can't get voltage level detector supply\n");
+			return ret;
+		}
+		ret = regulator_set_enable(priv->usb33d_supply, true);
+		if (ret) {
+			dev_err(dev, "can't enable voltage level detector supply\n");
+			return ret;
+		}
+		/* Enable vbus sensing */
+		setbits_le32(&usbotg_reg->ggpio,
+			     GGPIO_STM32_OTG_GCCFG_VBDEN |
+			     GGPIO_STM32_OTG_GCCFG_IDEN);
+	}
+
+	if (platdata->force_b_session_valid)
+		/* Override B session bits : value and enable */
+		setbits_le32(&usbotg_reg->gotgctl,
+			     A_VALOEN | A_VALOVAL | B_VALOEN | B_VALOVAL);
+
+	ret = dwc2_udc_probe(platdata);
+	if (ret)
+		return ret;
+
+	the_controller->driver = 0;
+
+	ret = usb_add_gadget_udc((struct device *)dev, &the_controller->gadget);
+
+	return ret;
+}
+
+static int dwc2_udc_otg_remove(struct udevice *dev)
+{
+	struct dwc2_priv_data *priv = dev_get_priv(dev);
+
+	usb_del_gadget_udc(&the_controller->gadget);
+
+	reset_release_bulk(&priv->resets);
+
+	clk_release_bulk(&priv->clks);
+
+	dwc2_phy_shutdown(dev, priv->phys, priv->num_phys);
+
+	return dm_scan_fdt_dev(dev);
+}
+
+static const struct udevice_id dwc2_udc_otg_ids[] = {
+	{ .compatible = "snps,dwc2" },
+	{ .compatible = "st,stm32mp1-hsotg",
+	  .data = (ulong)dwc2_set_stm32mp1_hsotg_params },
+	{},
+};
+
+U_BOOT_DRIVER(dwc2_udc_otg) = {
+	.name	= "dwc2-udc-otg",
+	.id	= UCLASS_USB_GADGET_GENERIC,
+	.of_match = dwc2_udc_otg_ids,
+	.ofdata_to_platdata = dwc2_udc_otg_ofdata_to_platdata,
+	.probe = dwc2_udc_otg_probe,
+	.remove = dwc2_udc_otg_remove,
+	.platdata_auto_alloc_size = sizeof(struct dwc2_plat_otg_data),
+	.priv_auto_alloc_size = sizeof(struct dwc2_priv_data),
+};
+
+int dwc2_udc_B_session_valid(struct udevice *dev)
+{
+	struct dwc2_plat_otg_data *platdata = dev_get_platdata(dev);
+	struct dwc2_usbotg_reg *usbotg_reg =
+		(struct dwc2_usbotg_reg *)platdata->regs_otg;
+
+	return readl(&usbotg_reg->gotgctl) & B_SESSION_VALID;
 }
+#endif /* CONFIG_IS_ENABLED(DM_USB_GADGET) */
diff --git a/drivers/usb/gadget/dwc2_udc_otg_phy.c b/drivers/usb/gadget/dwc2_udc_otg_phy.c
index 0c4620d56d..c6e1e02d7d 100644
--- a/drivers/usb/gadget/dwc2_udc_otg_phy.c
+++ b/drivers/usb/gadget/dwc2_udc_otg_phy.c
@@ -34,7 +34,6 @@
 
 #include "dwc2_udc_otg_regs.h"
 #include "dwc2_udc_otg_priv.h"
-#include <usb/lin_gadget_compat.h>
 
 #include <usb/dwc2_udc.h>
 
diff --git a/drivers/usb/gadget/dwc2_udc_otg_priv.h b/drivers/usb/gadget/dwc2_udc_otg_priv.h
index c40ecf8aca..669d3d0dc6 100644
--- a/drivers/usb/gadget/dwc2_udc_otg_priv.h
+++ b/drivers/usb/gadget/dwc2_udc_otg_priv.h
@@ -13,7 +13,6 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/list.h>
-#include <usb/lin_gadget_compat.h>
 #include <usb/dwc2_udc.h>
 
 /*-------------------------------------------------------------------------*/
@@ -25,7 +24,6 @@
 #define EP_FIFO_SIZE2		1024
 /* ep0-control, ep1in-bulk, ep2out-bulk, ep3in-int */
 #define DWC2_MAX_ENDPOINTS	4
-#define DWC2_MAX_HW_ENDPOINTS	16
 
 #define WAIT_FOR_SETUP          0
 #define DATA_STATE_XMIT         1
@@ -86,6 +84,7 @@ struct dwc2_udc {
 	unsigned char usb_address;
 
 	unsigned req_pending:1, req_std:1;
+	unsigned connected:1;
 };
 
 #define ep_is_in(EP) (((EP)->bEndpointAddress&USB_DIR_IN) == USB_DIR_IN)
diff --git a/drivers/usb/gadget/dwc2_udc_otg_regs.h b/drivers/usb/gadget/dwc2_udc_otg_regs.h
index c94396afc0..e32ad4a6a7 100644
--- a/drivers/usb/gadget/dwc2_udc_otg_regs.h
+++ b/drivers/usb/gadget/dwc2_udc_otg_regs.h
@@ -61,22 +61,26 @@ struct dwc2_usbotg_reg {
 	u32 grxstsp; /* Receive Status Debug Pop/Status Pop */
 	u32 grxfsiz; /* Receive FIFO Size */
 	u32 gnptxfsiz; /* Non-Periodic Transmit FIFO Size */
-	u8  res1[216];
+	u8  res0[12];
+	u32 ggpio;     /* 0x038 */
+	u8  res1[20];
+	u32 ghwcfg4; /* User HW Config4 */
+	u8  res2[176];
 	u32 dieptxf[15]; /* Device Periodic Transmit FIFO size register */
-	u8  res2[1728];
+	u8  res3[1728];
 	/* Device Configuration */
 	u32 dcfg; /* Device Configuration Register */
 	u32 dctl; /* Device Control */
 	u32 dsts; /* Device Status */
-	u8  res3[4];
+	u8  res4[4];
 	u32 diepmsk; /* Device IN Endpoint Common Interrupt Mask */
 	u32 doepmsk; /* Device OUT Endpoint Common Interrupt Mask */
 	u32 daint; /* Device All Endpoints Interrupt */
 	u32 daintmsk; /* Device All Endpoints Interrupt Mask */
-	u8  res4[224];
+	u8  res5[224];
 	struct dwc2_dev_in_endp in_endp[16];
 	struct dwc2_dev_out_endp out_endp[16];
-	u8  res5[768];
+	u8  res6[768];
 	struct ep_fifo ep[16];
 };
 
@@ -84,8 +88,15 @@ struct dwc2_usbotg_reg {
 /*definitions related to CSR setting */
 
 /* DWC2_UDC_OTG_GOTGCTL */
-#define B_SESSION_VALID		(0x1<<19)
-#define A_SESSION_VALID		(0x1<<18)
+#define B_SESSION_VALID			BIT(19)
+#define A_SESSION_VALID			BIT(18)
+#define B_VALOVAL			BIT(7)
+#define B_VALOEN			BIT(6)
+#define A_VALOVAL			BIT(5)
+#define A_VALOEN			BIT(4)
+
+/* DWC2_UDC_OTG_GOTINT */
+#define GOTGINT_SES_END_DET		(1<<2)
 
 /* DWC2_UDC_OTG_GAHBCFG */
 #define PTXFE_HALF			(0<<8)
@@ -119,6 +130,7 @@ struct dwc2_usbotg_reg {
 #define INT_NP_TX_FIFO_EMPTY		(0x1<<5)
 #define INT_RX_FIFO_NOT_EMPTY		(0x1<<4)
 #define INT_SOF			(0x1<<3)
+#define INT_OTG			(0x1<<2)
 #define INT_DEV_MODE			(0x0<<0)
 #define INT_HOST_MODE			(0x1<<1)
 #define INT_GOUTNakEff			(0x01<<7)
@@ -238,6 +250,7 @@ struct dwc2_usbotg_reg {
 #define DEV_SPEED_FULL_SPEED_11         (0x3 << 0)
 #define EP_MISS_CNT(x)                  (x << 18)
 #define DEVICE_ADDRESS(x)               (x << 4)
+#define DCFG_DEVADDR_MASK		(0x7f << 4)
 
 /* Core Reset Register (GRSTCTL) */
 #define TX_FIFO_FLUSH                   (0x1 << 5)
@@ -247,7 +260,7 @@ struct dwc2_usbotg_reg {
 
 /* Masks definitions */
 #define GINTMSK_INIT	(INT_OUT_EP | INT_IN_EP | INT_RESUME | INT_ENUMDONE\
-			| INT_RESET | INT_SUSPEND)
+			| INT_RESET | INT_SUSPEND | INT_OTG)
 #define DOEPMSK_INIT	(CTRL_OUT_EP_SETUP_PHASE_DONE | AHB_ERROR|TRANSFER_DONE)
 #define DIEPMSK_INIT	(NON_ISO_IN_EP_TIMEOUT|AHB_ERROR|TRANSFER_DONE)
 #define GAHBCFG_INIT	(PTXFE_HALF | NPTXFE_HALF | MODE_DMA | BURST_INCR4\
@@ -261,7 +274,7 @@ struct dwc2_usbotg_reg {
 #define DOEPT_SIZ_PKT_CNT(x)                      (x << 19)
 #define DOEPT_SIZ_XFER_SIZE(x)                    (x << 0)
 #define DOEPT_SIZ_XFER_SIZE_MAX_EP0               (0x7F << 0)
-#define DOEPT_SIZ_XFER_SIZE_MAX_EP                (0x7FFF << 0)
+#define DOEPT_SIZ_XFER_SIZE_MAX_EP                (0x7FFFF << 0)
 
 /* Device Endpoint-N Control Register (DIEPCTLn/DOEPCTLn) */
 #define DIEPCTL_TX_FIFO_NUM(x)                    (x << 22)
@@ -270,4 +283,13 @@ struct dwc2_usbotg_reg {
 /* Device ALL Endpoints Interrupt Register (DAINT) */
 #define DAINT_IN_EP_INT(x)                        (x << 0)
 #define DAINT_OUT_EP_INT(x)                       (x << 16)
+
+/* User HW Config4 */
+#define GHWCFG4_NUM_IN_EPS_MASK		(0xf << 26)
+#define GHWCFG4_NUM_IN_EPS_SHIFT	26
+
+/* OTG general core configuration register (OTG_GCCFG:0x38) for STM32MP1 */
+#define GGPIO_STM32_OTG_GCCFG_VBDEN               BIT(21)
+#define GGPIO_STM32_OTG_GCCFG_IDEN                BIT(22)
+
 #endif
diff --git a/drivers/usb/gadget/dwc2_udc_otg_xfer_dma.c b/drivers/usb/gadget/dwc2_udc_otg_xfer_dma.c
index 0d6d2fba8a..4fdcd5c56c 100644
--- a/drivers/usb/gadget/dwc2_udc_otg_xfer_dma.c
+++ b/drivers/usb/gadget/dwc2_udc_otg_xfer_dma.c
@@ -98,7 +98,7 @@ static int setdma_rx(struct dwc2_ep *ep, struct dwc2_request *req)
 
 	buf = req->req.buf + req->req.actual;
 	length = min_t(u32, req->req.length - req->req.actual,
-		       ep_num ? DMA_BUFFER_SIZE : ep->ep.maxpacket);
+		       ep_num ? DOEPT_SIZ_XFER_SIZE_MAX_EP : ep->ep.maxpacket);
 
 	ep->len = length;
 	ep->dma_buf = buf;
@@ -111,9 +111,10 @@ static int setdma_rx(struct dwc2_ep *ep, struct dwc2_request *req)
 	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
 
 	invalidate_dcache_range((unsigned long) ep->dma_buf,
-				(unsigned long) ep->dma_buf + ep->len);
+				(unsigned long) ep->dma_buf +
+				ROUND(ep->len, CONFIG_SYS_CACHELINE_SIZE));
 
-	writel((unsigned int) ep->dma_buf, &reg->out_endp[ep_num].doepdma);
+	writel((unsigned long) ep->dma_buf, &reg->out_endp[ep_num].doepdma);
 	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
 	       &reg->out_endp[ep_num].doeptsiz);
 	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
@@ -467,7 +468,7 @@ static void process_ep_out_intr(struct dwc2_udc *dev)
 static int dwc2_udc_irq(int irq, void *_dev)
 {
 	struct dwc2_udc *dev = _dev;
-	u32 intr_status;
+	u32 intr_status, gotgint;
 	u32 usb_status, gintmsk;
 	unsigned long flags = 0;
 
@@ -521,14 +522,24 @@ static int dwc2_udc_irq(int irq, void *_dev)
 		    && dev->driver) {
 			if (dev->driver->suspend)
 				dev->driver->suspend(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_OTG) {
+		gotgint = readl(&reg->gotgint);
+		debug_cond(DEBUG_ISR,
+			   "\tOTG interrupt: (GOTGINT):0x%x\n", gotgint);
 
-			/* HACK to let gadget detect disconnected state */
+		if (gotgint & GOTGINT_SES_END_DET) {
+			debug_cond(DEBUG_ISR, "\t\tSession End Detected\n");
+			/* Let gadget detect disconnected state */
 			if (dev->driver->disconnect) {
 				spin_unlock_irqrestore(&dev->lock, flags);
 				dev->driver->disconnect(&dev->gadget);
 				spin_lock_irqsave(&dev->lock, flags);
 			}
 		}
+		writel(gotgint, &reg->gotgint);
 	}
 
 	if (intr_status & INT_RESUME) {
@@ -544,6 +555,9 @@ static int dwc2_udc_irq(int irq, void *_dev)
 	}
 
 	if (intr_status & INT_RESET) {
+		u32 temp;
+		u32 connected = dev->connected;
+
 		usb_status = readl(&reg->gotgctl);
 		debug_cond(DEBUG_ISR,
 			"\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
@@ -554,7 +568,15 @@ static int dwc2_udc_irq(int irq, void *_dev)
 				debug_cond(DEBUG_ISR,
 					"\t\tOTG core got reset (%d)!!\n",
 					reset_available);
-				reconfig_usbd(dev);
+				/* Reset device address to zero */
+				temp = readl(&reg->dcfg);
+				temp &= ~DCFG_DEVADDR_MASK;
+				writel(temp, &reg->dcfg);
+
+				/* Soft reset the core if connected */
+				if (connected)
+					reconfig_usbd(dev);
+
 				dev->ep0state = WAIT_FOR_SETUP;
 				reset_available = 0;
 				dwc2_udc_pre_setup();
@@ -721,7 +743,7 @@ static int write_fifo_ep0(struct dwc2_ep *ep, struct dwc2_request *req)
 	return 0;
 }
 
-static int dwc2_fifo_read(struct dwc2_ep *ep, u32 *cp, int max)
+static int dwc2_fifo_read(struct dwc2_ep *ep, void *cp, int max)
 {
 	invalidate_dcache_range((unsigned long)cp, (unsigned long)cp +
 				ROUND(max, CONFIG_SYS_CACHELINE_SIZE));
@@ -1275,7 +1297,7 @@ static void dwc2_ep0_setup(struct dwc2_udc *dev)
 	nuke(ep, -EPROTO);
 
 	/* read control req from fifo (8 bytes) */
-	dwc2_fifo_read(ep, (u32 *)usb_ctrl, 8);
+	dwc2_fifo_read(ep, usb_ctrl, 8);
 
 	debug_cond(DEBUG_SETUP != 0,
 		   "%s: bRequestType = 0x%x(%s), bRequest = 0x%x"
@@ -1348,7 +1370,7 @@ static void dwc2_ep0_setup(struct dwc2_udc *dev)
 			if (usb_ctrl->bRequestType
 				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
 				break;
-
+			dev->connected = 1;
 			udc_set_address(dev, usb_ctrl->wValue);
 			return;
 
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 6d6dbcb09c..e566ad5a57 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -285,6 +285,9 @@ struct usb_ep *usb_ep_autoconfig(
 			return ep;
 	}
 
+	if (gadget->ops->match_ep)
+		ep = gadget->ops->match_ep(gadget, desc, NULL);
+
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
 		if (ep_matches(gadget, ep, desc))
diff --git a/drivers/usb/gadget/ether.c b/drivers/usb/gadget/ether.c
index 2cf5c8d31e..0c6b0fca53 100644
--- a/drivers/usb/gadget/ether.c
+++ b/drivers/usb/gadget/ether.c
@@ -105,9 +105,6 @@ struct eth_dev {
 	struct usb_gadget	*gadget;
 	struct usb_request	*req;		/* for control responses */
 	struct usb_request	*stat_req;	/* for cdc & rndis status */
-#ifdef CONFIG_DM_USB
-	struct udevice		*usb_udev;
-#endif
 
 	u8			config;
 	struct usb_ep		*in_ep, *out_ep, *status_ep;
@@ -273,8 +270,8 @@ static inline int BITRATE(struct usb_gadget *g)
  * static ushort idProduct;
  */
 
-#if defined(CONFIG_USBNET_MANUFACTURER)
-static char *iManufacturer = CONFIG_USBNET_MANUFACTURER;
+#if defined(CONFIG_USB_GADGET_MANUFACTURER)
+static char *iManufacturer = CONFIG_USB_GADGET_MANUFACTURER;
 #else
 static char *iManufacturer = "U-Boot";
 #endif
@@ -1059,7 +1056,7 @@ static int eth_set_config(struct eth_dev *dev, unsigned number,
 			&& dev->config
 			&& dev->tx_qlen != 0) {
 		/* tx fifo is full, but we can't clear it...*/
-		error("can't change configurations");
+		pr_err("can't change configurations");
 		return -ESPIPE;
 	}
 	eth_reset_config(dev);
@@ -1233,7 +1230,7 @@ static void rndis_command_complete(struct usb_ep *ep, struct usb_request *req)
 	/* received RNDIS command from USB_CDC_SEND_ENCAPSULATED_COMMAND */
 	status = rndis_msg_parser(dev->rndis_config, (u8 *) req->buf);
 	if (status < 0)
-		error("%s: rndis parse error %d", __func__, status);
+		pr_err("%s: rndis parse error %d", __func__, status);
 }
 
 #endif	/* RNDIS */
@@ -1554,7 +1551,7 @@ static int rx_submit(struct eth_dev *dev, struct usb_request *req,
 	retval = usb_ep_queue(dev->out_ep, req, gfp_flags);
 
 	if (retval)
-		error("rx submit --> %d", retval);
+		pr_err("rx submit --> %d", retval);
 
 	return retval;
 }
@@ -1624,7 +1621,7 @@ static int alloc_requests(struct eth_dev *dev, unsigned n, gfp_t gfp_flags)
 fail2:
 	usb_ep_free_request(dev->in_ep, dev->tx_req);
 fail1:
-	error("can't alloc requests");
+	pr_err("can't alloc requests");
 	return -1;
 }
 
@@ -2060,7 +2057,7 @@ static int eth_bind(struct usb_gadget *gadget)
 		 * anything less functional on CDC-capable hardware,
 		 * so we fail in this case.
 		 */
-		error("controller '%s' not recognized",
+		pr_err("controller '%s' not recognized",
 			gadget->name);
 		return -ENODEV;
 	}
@@ -2073,11 +2070,11 @@ static int eth_bind(struct usb_gadget *gadget)
 	 * to choose the right configuration otherwise.
 	 */
 	if (rndis) {
-#if defined(CONFIG_USB_RNDIS_VENDOR_ID) && defined(CONFIG_USB_RNDIS_PRODUCT_ID)
+#if defined(CONFIG_USB_GADGET_VENDOR_NUM) && defined(CONFIG_USB_GADGET_PRODUCT_NUM)
 		device_desc.idVendor =
-			__constant_cpu_to_le16(CONFIG_USB_RNDIS_VENDOR_ID);
+			__constant_cpu_to_le16(CONFIG_USB_GADGET_VENDOR_NUM);
 		device_desc.idProduct =
-			__constant_cpu_to_le16(CONFIG_USB_RNDIS_PRODUCT_ID);
+			__constant_cpu_to_le16(CONFIG_USB_GADGET_PRODUCT_NUM);
 #else
 		device_desc.idVendor =
 			__constant_cpu_to_le16(RNDIS_VENDOR_NUM);
@@ -2092,9 +2089,9 @@ static int eth_bind(struct usb_gadget *gadget)
 	 * supporting one submode of the "SAFE" variant of MDLM.)
 	 */
 	} else {
-#if defined(CONFIG_USB_CDC_VENDOR_ID) && defined(CONFIG_USB_CDC_PRODUCT_ID)
-		device_desc.idVendor = cpu_to_le16(CONFIG_USB_CDC_VENDOR_ID);
-		device_desc.idProduct = cpu_to_le16(CONFIG_USB_CDC_PRODUCT_ID);
+#if defined(CONFIG_USB_GADGET_VENDOR_NUM) && defined(CONFIG_USB_GADGET_PRODUCT_NUM)
+		device_desc.idVendor = cpu_to_le16(CONFIG_USB_GADGET_VENDOR_NUM);
+		device_desc.idProduct = cpu_to_le16(CONFIG_USB_GADGET_PRODUCT_NUM);
 #else
 		if (!cdc) {
 			device_desc.idVendor =
@@ -2121,7 +2118,7 @@ static int eth_bind(struct usb_gadget *gadget)
 	in_ep = usb_ep_autoconfig(gadget, &fs_source_desc);
 	if (!in_ep) {
 autoconf_fail:
-		error("can't autoconfigure on %s\n",
+		pr_err("can't autoconfigure on %s\n",
 			gadget->name);
 		return -ENODEV;
 	}
@@ -2142,7 +2139,7 @@ autoconf_fail:
 		if (status_ep) {
 			status_ep->driver_data = status_ep;	/* claim */
 		} else if (rndis) {
-			error("can't run RNDIS on %s", gadget->name);
+			pr_err("can't run RNDIS on %s", gadget->name);
 			return -ENODEV;
 #ifdef CONFIG_USB_ETH_CDC
 		} else if (cdc) {
@@ -2244,7 +2241,7 @@ autoconf_fail:
 	if (rndis) {
 		status = rndis_init();
 		if (status < 0) {
-			error("can't init RNDIS, %d", status);
+			pr_err("can't init RNDIS, %d", status);
 			goto fail;
 		}
 	}
@@ -2335,46 +2332,25 @@ fail0:
 	return 0;
 
 fail:
-	error("%s failed, status = %d", __func__, status);
+	pr_err("%s failed, status = %d", __func__, status);
 	eth_unbind(gadget);
 	return status;
 }
 
 /*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_DM_USB
-int dm_usb_init(struct eth_dev *e_dev)
-{
-	struct udevice *dev = NULL;
-	int ret;
-
-	ret = uclass_first_device(UCLASS_USB_DEV_GENERIC, &dev);
-	if (!dev || ret) {
-		error("No USB device found\n");
-		return -ENODEV;
-	}
-
-	e_dev->usb_udev = dev;
-
-	return ret;
-}
-#endif
+static void _usb_eth_halt(struct ether_priv *priv);
 
 static int _usb_eth_init(struct ether_priv *priv)
 {
 	struct eth_dev *dev = &priv->ethdev;
 	struct usb_gadget *gadget;
 	unsigned long ts;
+	int ret;
 	unsigned long timeout = USB_CONNECT_TIMEOUT;
 
-#ifdef CONFIG_DM_USB
-	if (dm_usb_init(dev)) {
-		error("USB ether not found\n");
-		return -ENODEV;
-	}
-#else
-	board_usb_init(0, USB_INIT_DEVICE);
-#endif
+	ret = usb_gadget_initialize(0);
+	if (ret)
+		return ret;
 
 	/* Configure default mac-addresses for the USB ethernet device */
 #ifdef CONFIG_USBNET_DEV_ADDR
@@ -2393,11 +2369,11 @@ static int _usb_eth_init(struct ether_priv *priv)
 			sizeof(host_addr));
 
 	if (!is_eth_addr_valid(dev_addr)) {
-		error("Need valid 'usbnet_devaddr' to be set");
+		pr_err("Need valid 'usbnet_devaddr' to be set");
 		goto fail;
 	}
 	if (!is_eth_addr_valid(host_addr)) {
-		error("Need valid 'usbnet_hostaddr' to be set");
+		pr_err("Need valid 'usbnet_hostaddr' to be set");
 		goto fail;
 	}
 
@@ -2427,7 +2403,7 @@ static int _usb_eth_init(struct ether_priv *priv)
 	while (!dev->network_started) {
 		/* Handle control-c and timeouts */
 		if (ctrlc() || (get_timer(ts) > timeout)) {
-			error("The remote end did not respond in time.");
+			pr_err("The remote end did not respond in time.");
 			goto fail;
 		}
 		usb_gadget_handle_interrupts(0);
@@ -2437,6 +2413,7 @@ static int _usb_eth_init(struct ether_priv *priv)
 	rx_submit(dev, dev->rx_req, 0);
 	return 0;
 fail:
+	_usb_eth_halt(priv);
 	return -1;
 }
 
@@ -2456,7 +2433,7 @@ static int _usb_eth_send(struct ether_priv *priv, void *packet, int length)
 		rndis_pkt = malloc(length +
 					sizeof(struct rndis_packet_msg_type));
 		if (!rndis_pkt) {
-			error("No memory to alloc RNDIS packet");
+			pr_err("No memory to alloc RNDIS packet");
 			goto drop;
 		}
 		rndis_add_hdr(rndis_pkt, length);
@@ -2516,7 +2493,7 @@ static int _usb_eth_recv(struct ether_priv *priv)
 	return 0;
 }
 
-void _usb_eth_halt(struct ether_priv *priv)
+static void _usb_eth_halt(struct ether_priv *priv)
 {
 	struct eth_dev *dev = &priv->ethdev;
 
@@ -2546,9 +2523,7 @@ void _usb_eth_halt(struct ether_priv *priv)
 	}
 
 	usb_gadget_unregister_driver(&priv->eth_driver);
-#ifndef CONFIG_DM_USB
-	board_usb_cleanup(0, USB_INIT_DEVICE);
-#endif
+	usb_gadget_release(0);
 }
 
 #ifndef CONFIG_DM_ETH
@@ -2574,7 +2549,7 @@ static int usb_eth_recv(struct eth_device *netdev)
 
 	ret = _usb_eth_recv(priv);
 	if (ret) {
-		error("error packet receive\n");
+		pr_err("error packet receive\n");
 		return ret;
 	}
 
@@ -2585,7 +2560,7 @@ static int usb_eth_recv(struct eth_device *netdev)
 		net_process_received_packet(net_rx_packets[0],
 					    dev->rx_req->length);
 	} else {
-		error("dev->rx_req invalid");
+		pr_err("dev->rx_req invalid");
 	}
 	packet_received = 0;
 	rx_submit(dev, dev->rx_req, 0);
@@ -2641,7 +2616,7 @@ static int usb_eth_recv(struct udevice *dev, int flags, uchar **packetp)
 
 	ret = _usb_eth_recv(priv);
 	if (ret) {
-		error("error packet receive\n");
+		pr_err("error packet receive\n");
 		return ret;
 	}
 
@@ -2650,7 +2625,7 @@ static int usb_eth_recv(struct udevice *dev, int flags, uchar **packetp)
 			*packetp = (uchar *)net_rx_packets[0];
 			return ethdev->rx_req->length;
 		} else {
-			error("dev->rx_req invalid");
+			pr_err("dev->rx_req invalid");
 			return -EFAULT;
 		}
 	}
@@ -2704,15 +2679,15 @@ int usb_ether_init(void)
 	struct udevice *usb_dev;
 	int ret;
 
-	ret = uclass_first_device(UCLASS_USB_DEV_GENERIC, &usb_dev);
+	ret = uclass_first_device(UCLASS_USB_GADGET_GENERIC, &usb_dev);
 	if (!usb_dev || ret) {
-		error("No USB device found\n");
+		pr_err("No USB device found\n");
 		return ret;
 	}
 
 	ret = device_bind_driver(usb_dev, "usb_ether", "usb_ether", &dev);
 	if (!dev || ret) {
-		error("usb - not able to bind usb_ether device\n");
+		pr_err("usb - not able to bind usb_ether device\n");
 		return ret;
 	}
 
diff --git a/drivers/usb/gadget/f_dfu.c b/drivers/usb/gadget/f_dfu.c
index bc4be712da..f811a30be5 100644
--- a/drivers/usb/gadget/f_dfu.c
+++ b/drivers/usb/gadget/f_dfu.c
@@ -749,6 +749,7 @@ static void dfu_unbind(struct usb_configuration *c, struct usb_function *f)
 
 	if (f_dfu->function) {
 		i = alt_num;
+		i++; /* free DFU Functional Descriptor */
 		while (i) {
 			free(f_dfu->function[--i]);
 			f_dfu->function[i] = NULL;
diff --git a/drivers/usb/gadget/f_fastboot.c b/drivers/usb/gadget/f_fastboot.c
index f3382a965b..7bb16b7bf0 100644
--- a/drivers/usb/gadget/f_fastboot.c
+++ b/drivers/usb/gadget/f_fastboot.c
@@ -12,6 +12,8 @@
  */
 #include <config.h>
 #include <common.h>
+#include <console.h>
+#include <android_bootloader.h>
 #include <errno.h>
 #include <fastboot.h>
 #include <malloc.h>
@@ -19,14 +21,31 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/composite.h>
 #include <linux/compiler.h>
+#include <u-boot/sha256.h>
 #include <version.h>
 #include <g_dnl.h>
+#include <fs.h>
+#include <android_avb/avb_ops_user.h>
+#include <android_avb/rk_avb_ops_user.h>
+#include <dm/uclass.h>
+#include <power/fuel_gauge.h>
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 #include <fb_mmc.h>
 #endif
 #ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
 #include <fb_nand.h>
 #endif
+#ifdef CONFIG_OPTEE_CLIENT
+#include <optee_include/OpteeClientInterface.h>
+#endif
+#include <boot_rkimg.h>
+#include <optee_include/tee_client_api.h>
+#ifdef CONFIG_FASTBOOT_OEM_UNLOCK
+#include <keymaster.h>
+#endif
+#ifdef CONFIG_ANDROID_AB
+#include <android_ab.h>
+#endif
 
 #define FASTBOOT_VERSION		"0.4"
 
@@ -39,6 +58,10 @@
 #define TX_ENDPOINT_MAXIMUM_PACKET_SIZE      (0x0040)
 
 #define EP_BUFFER_SIZE			4096
+#define SLEEP_COUNT 20000
+#define MAX_PART_NUM_STR_SIZE 4
+#define PARTITION_TYPE_STRINGS "partition-type"
+
 /*
  * EP_BUFFER_SIZE must always be an integral multiple of maxpacket size
  * (64 or 512 or 1024), else we break on certain controllers like DWC3
@@ -61,6 +84,10 @@ static inline struct f_fastboot *func_to_fastboot(struct usb_function *f)
 static struct f_fastboot *fastboot_func;
 static unsigned int download_size;
 static unsigned int download_bytes;
+static unsigned int upload_size;
+static unsigned int upload_bytes;
+static bool start_upload;
+static unsigned intthread_wakeup_needed;
 
 static struct usb_endpoint_descriptor fs_ep_in = {
 	.bLength            = USB_DT_ENDPOINT_SIZE,
@@ -94,6 +121,34 @@ static struct usb_endpoint_descriptor hs_ep_out = {
 	.wMaxPacketSize		= cpu_to_le16(512),
 };
 
+static struct usb_endpoint_descriptor ss_ep_in = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize		= cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor ss_ep_in_comp_desc = {
+	.bLength		= sizeof(ss_ep_in_comp_desc),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* .bMaxBurst		= DYNAMIC, */
+};
+
+static struct usb_endpoint_descriptor ss_ep_out = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_OUT,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize		= cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor ss_ep_out_comp_desc = {
+	.bLength		= sizeof(ss_ep_out_comp_desc),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* .bMaxBurst		= DYNAMIC, */
+};
+
 static struct usb_interface_descriptor interface_desc = {
 	.bLength		= USB_DT_INTERFACE_SIZE,
 	.bDescriptorType	= USB_DT_INTERFACE,
@@ -118,13 +173,44 @@ static struct usb_descriptor_header *fb_hs_function[] = {
 	NULL,
 };
 
+static struct usb_descriptor_header *fb_ss_function[] = {
+	(struct usb_descriptor_header *)&interface_desc,
+	(struct usb_descriptor_header *)&ss_ep_in,
+	(struct usb_descriptor_header *)&ss_ep_in_comp_desc,
+	(struct usb_descriptor_header *)&ss_ep_out,
+	(struct usb_descriptor_header *)&ss_ep_out_comp_desc,
+	NULL,
+};
+
 static struct usb_endpoint_descriptor *
 fb_ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
-	    struct usb_endpoint_descriptor *hs)
+	   struct usb_endpoint_descriptor *hs,
+	   struct usb_endpoint_descriptor *ss,
+	   struct usb_ss_ep_comp_descriptor *comp_desc,
+	   struct usb_ep *ep)
 {
-	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
-		return hs;
-	return fs;
+	struct usb_endpoint_descriptor *speed_desc = NULL;
+
+	/* select desired speed */
+	switch (g->speed) {
+	case USB_SPEED_SUPER:
+		if (gadget_is_superspeed(g)) {
+			speed_desc = ss;
+			ep->comp_desc = comp_desc;
+			break;
+		}
+		/* else: Fall trough */
+	case USB_SPEED_HIGH:
+		if (gadget_is_dualspeed(g)) {
+			speed_desc = hs;
+			break;
+		}
+		/* else: fall through */
+	default:
+		speed_desc = fs;
+	}
+
+	return speed_desc;
 }
 
 /*
@@ -149,25 +235,94 @@ static struct usb_gadget_strings *fastboot_strings[] = {
 
 static void rx_handler_command(struct usb_ep *ep, struct usb_request *req);
 static int strcmp_l1(const char *s1, const char *s2);
+static void wakeup_thread(void)
+{
+	intthread_wakeup_needed = false;
+}
 
+static void busy_indicator(void)
+{
+	static int state;
+
+	switch (state) {
+	case 0:
+		puts("\r|"); break;
+	case 1:
+		puts("\r/"); break;
+	case 2:
+		puts("\r-"); break;
+	case 3:
+		puts("\r\\"); break;
+	case 4:
+		puts("\r|"); break;
+	case 5:
+		puts("\r/"); break;
+	case 6:
+		puts("\r-"); break;
+	case 7:
+		puts("\r\\"); break;
+	default:
+		state = 0;
+	}
+	if (state++ == 8)
+		state = 0;
+}
 
-static char *fb_response_str;
-
-void fastboot_fail(const char *reason)
+static int fb_get_fstype(const char *ifname, const int part_num,
+			 const char **fs_type)
 {
-	strncpy(fb_response_str, "FAIL\0", 5);
-	strncat(fb_response_str, reason, FASTBOOT_RESPONSE_LEN - 4 - 1);
+	char part_num_str[MAX_PART_NUM_STR_SIZE] = {0};
+
+	snprintf(part_num_str, ARRAY_SIZE(part_num_str), ":%x", part_num);
+
+	if (fs_set_blk_dev(ifname, part_num_str, FS_TYPE_ANY))
+		return -1;
+
+	if (fs_get_fstype(fs_type))
+		return -1;
+
+	return 0;
 }
 
-void fastboot_okay(const char *reason)
+static int sleep_thread(void)
 {
-	strncpy(fb_response_str, "OKAY\0", 5);
-	strncat(fb_response_str, reason, FASTBOOT_RESPONSE_LEN - 4 - 1);
+	int rc = 0;
+	int i = 0, k = 0;
+
+	/* Wait until a signal arrives or we are woken up */
+	for (;;) {
+		if (!intthread_wakeup_needed)
+			break;
+
+		if (++i == SLEEP_COUNT) {
+			busy_indicator();
+			i = 0;
+			k++;
+		}
+
+		if (k == 10) {
+			/* Handle CTRL+C */
+			if (ctrlc())
+				return -EPIPE;
+
+			/* Check cable connection */
+			if (!g_dnl_board_usb_cable_connected())
+				return -EIO;
+
+			k = 0;
+		}
+
+		usb_gadget_handle_interrupts(0);
+	}
+	intthread_wakeup_needed = true;
+	return rc;
 }
 
 static void fastboot_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	int status = req->status;
+
+	wakeup_thread();
 	if (!status)
 		return;
 	printf("status: %d ep '%s' trans: %d\n", status, ep->name, req->actual);
@@ -212,6 +367,14 @@ static int fastboot_bind(struct usb_configuration *c, struct usb_function *f)
 		f->hs_descriptors = fb_hs_function;
 	}
 
+	if (gadget_is_superspeed(gadget)) {
+		/* Assume endpoint addresses are the same as full speed */
+		ss_ep_in.bEndpointAddress = fs_ep_in.bEndpointAddress;
+		ss_ep_out.bEndpointAddress = fs_ep_out.bEndpointAddress;
+		/* copy SS descriptors */
+		f->ss_descriptors = fb_ss_function;
+	}
+
 	s = env_get("serial#");
 	if (s)
 		g_dnl_set_serialnumber((char *)s);
@@ -274,7 +437,8 @@ static int fastboot_set_alt(struct usb_function *f,
 	debug("%s: func: %s intf: %d alt: %d\n",
 	      __func__, f->name, interface, alt);
 
-	d = fb_ep_desc(gadget, &fs_ep_out, &hs_ep_out);
+	d = fb_ep_desc(gadget, &fs_ep_out, &hs_ep_out, &ss_ep_out,
+		       &ss_ep_out_comp_desc, f_fb->out_ep);
 	ret = usb_ep_enable(f_fb->out_ep, d);
 	if (ret) {
 		puts("failed to enable out ep\n");
@@ -289,7 +453,8 @@ static int fastboot_set_alt(struct usb_function *f,
 	}
 	f_fb->out_req->complete = rx_handler_command;
 
-	d = fb_ep_desc(gadget, &fs_ep_in, &hs_ep_in);
+	d = fb_ep_desc(gadget, &fs_ep_in, &hs_ep_in, &ss_ep_in,
+		       &ss_ep_in_comp_desc, f_fb->in_ep);
 	ret = usb_ep_enable(f_fb->in_ep, d);
 	if (ret) {
 		puts("failed to enable in ep\n");
@@ -365,6 +530,12 @@ static int fastboot_tx_write(const char *buffer, unsigned int buffer_size)
 
 static int fastboot_tx_write_str(const char *buffer)
 {
+	int ret;
+
+	ret = sleep_thread();
+	if (ret < 0)
+		printf("warning: 0x%x, usb transmission is abnormal!\n", ret);
+
 	return fastboot_tx_write(buffer, strlen(buffer));
 }
 
@@ -381,12 +552,28 @@ int __weak fb_set_reboot_flag(void)
 static void cb_reboot(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
+
 	if (!strcmp_l1("reboot-bootloader", cmd)) {
 		if (fb_set_reboot_flag()) {
 			fastboot_tx_write_str("FAILCannot set reboot flag");
 			return;
 		}
 	}
+#ifdef CONFIG_ANDROID_BOOTLOADER
+	if (!strcmp_l1("reboot-fastboot", cmd)) {
+		if (android_bcb_write("boot-fastboot")) {
+			fastboot_tx_write_str("FAILCannot set boot-fastboot");
+			return;
+		}
+	}
+
+	if (!strcmp_l1("reboot-recovery", cmd)) {
+		if (android_bcb_write("boot-recovery")) {
+			fastboot_tx_write_str("FAILCannot set boot-recovery");
+			return;
+		}
+	}
+#endif
 	fastboot_func->in_req->complete = compl_do_reset;
 	fastboot_tx_write_str("OKAY");
 }
@@ -398,241 +585,1702 @@ static int strcmp_l1(const char *s1, const char *s2)
 	return strncmp(s1, s2, strlen(s1));
 }
 
-static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
-{
-	char *cmd = req->buf;
-	char response[FASTBOOT_RESPONSE_LEN];
-	const char *s;
-	size_t chars_left;
-
-	strcpy(response, "OKAY");
-	chars_left = sizeof(response) - strlen(response) - 1;
+struct name_string {
+	const char *str;
+	int expects_args;
+	char delim;
+};
 
-	strsep(&cmd, ":");
-	if (!cmd) {
-		error("missing variable");
-		fastboot_tx_write_str("FAILmissing var");
-		return;
-	}
+#define NAME_NO_ARGS(s)	{.str = s, .expects_args = 0}
+#define NAME_ARGS(s, d)	{.str = s, .expects_args = 1, .delim = d}
 
-	if (!strcmp_l1("version", cmd)) {
-		strncat(response, FASTBOOT_VERSION, chars_left);
-	} else if (!strcmp_l1("bootloader-version", cmd)) {
-		strncat(response, U_BOOT_VERSION, chars_left);
-	} else if (!strcmp_l1("downloadsize", cmd) ||
-		!strcmp_l1("max-download-size", cmd)) {
-		char str_num[12];
+static size_t name_check_match(const char *str, size_t len,
+			       const struct name_string *name)
+{
+	size_t str_len = strlen(name->str);
 
-		sprintf(str_num, "0x%08x", CONFIG_FASTBOOT_BUF_SIZE);
-		strncat(response, str_num, chars_left);
-	} else if (!strcmp_l1("serialno", cmd)) {
-		s = env_get("serial#");
-		if (s)
-			strncat(response, s, chars_left);
-		else
-			strcpy(response, "FAILValue not set");
-	} else {
-		char *envstr;
+	/* If name len is greater than input, return 0. */
+	if (str_len > len)
+		return 0;
 
-		envstr = malloc(strlen("fastboot.") + strlen(cmd) + 1);
-		if (!envstr) {
-			fastboot_tx_write_str("FAILmalloc error");
-			return;
-		}
+	/* If name str does not match input string, return 0. */
+	if (memcmp(name->str, str, str_len))
+		return 0;
 
-		sprintf(envstr, "fastboot.%s", cmd);
-		s = env_get(envstr);
-		if (s) {
-			strncat(response, s, chars_left);
-		} else {
-			printf("WARNING: unknown variable: %s\n", cmd);
-			strcpy(response, "FAILVariable not implemented");
-		}
+	if (name->expects_args) {
+		/* string should have space for delim */
+		if (len == str_len)
+			return 0;
 
-		free(envstr);
+		/* Check delim match */
+		if (name->delim != str[str_len])
+			return 0;
+	} else {
+		/* Name str len should match input len */
+		if (str_len != len)
+			return 0;
 	}
-	fastboot_tx_write_str(response);
+
+	return str_len + name->expects_args;
 }
 
-static unsigned int rx_bytes_expected(struct usb_ep *ep)
+static void fb_add_string(char *dst, size_t chars_left,
+			  const char *str, const char *args)
 {
-	int rx_remain = download_size - download_bytes;
-	unsigned int rem;
-	unsigned int maxpacket = ep->maxpacket;
-
-	if (rx_remain <= 0)
-		return 0;
-	else if (rx_remain > EP_BUFFER_SIZE)
-		return EP_BUFFER_SIZE;
+	if (!str)
+		return;
 
-	/*
-	 * Some controllers e.g. DWC3 don't like OUT transfers to be
-	 * not ending in maxpacket boundary. So just make them happy by
-	 * always requesting for integral multiple of maxpackets.
-	 * This shouldn't bother controllers that don't care about it.
-	 */
-	rem = rx_remain % maxpacket;
-	if (rem > 0)
-		rx_remain = rx_remain + (maxpacket - rem);
+	int ret = snprintf(dst, chars_left, str, args);
 
-	return rx_remain;
+	if (ret < 0)
+		pr_err("snprintf is error!");
 }
 
-#define BYTES_PER_DOT	0x20000
-static void rx_handler_dl_image(struct usb_ep *ep, struct usb_request *req)
+static void fb_add_number(char *dst, size_t chars_left,
+			  const char *format, size_t num)
 {
-	char response[FASTBOOT_RESPONSE_LEN];
-	unsigned int transfer_size = download_size - download_bytes;
-	const unsigned char *buffer = req->buf;
-	unsigned int buffer_size = req->actual;
-	unsigned int pre_dot_num, now_dot_num;
-
-	if (req->status != 0) {
-		printf("Bad status: %d\n", req->status);
+	if (!format)
 		return;
-	}
 
-	if (buffer_size < transfer_size)
-		transfer_size = buffer_size;
+	int ret = snprintf(dst, chars_left, format, num);
 
-	memcpy((void *)CONFIG_FASTBOOT_BUF_ADDR + download_bytes,
-	       buffer, transfer_size);
+	if (ret > chars_left)
+		pr_err("snprintf is error!");
+}
 
-	pre_dot_num = download_bytes / BYTES_PER_DOT;
-	download_bytes += transfer_size;
-	now_dot_num = download_bytes / BYTES_PER_DOT;
+static int fb_read_var(char *cmd, char *response,
+		       fb_getvar_t var, size_t chars_left)
+{
+	const char *s;
+	int ret = 0;
+
+	switch (var) {
+	case FB_VERSION:
+		fb_add_string(response, chars_left, FASTBOOT_VERSION, NULL);
+		break;
+	case FB_BOOTLOADER_VERSION:
+		fb_add_string(response, chars_left, U_BOOT_VERSION, NULL);
+		break;
+	case FB_BASEBAND_VERSION:
+		fb_add_string(response, chars_left, "N/A", NULL);
+		break;
+	case FB_PRODUCT:
+		fb_add_string(response, chars_left, CONFIG_SYS_BOARD, NULL);
+		break;
+	case FB_SERIAL_NO:
+		s = env_get("serial#");
+		if (s)
+			fb_add_string(response, chars_left, s, NULL);
+		else
+			ret = -1;
+		break;
+	case FB_SECURE:
+		fb_add_string(response, chars_left, "yes", NULL);
+		break;
+	case FB_VARIANT:
+		fb_add_string(response, chars_left, "userdebug", NULL);
+		break;
+	case FB_DWNLD_SIZE:
+		fb_add_number(response, chars_left, "0x%08x",
+			      CONFIG_FASTBOOT_BUF_SIZE);
+		break;
+	case FB_PART_SIZE:
+	case FB_PART_TYPE: {
+		char *part_name = cmd;
+
+		cmd = strsep(&part_name, ":");
+		if (!cmd || !part_name) {
+			fb_add_string(response, chars_left,
+				      "argument Invalid!", NULL);
+			ret = -1;
+			break;
+		}
 
-	if (pre_dot_num != now_dot_num) {
-		putc('.');
-		if (!(now_dot_num % 74))
-			putc('\n');
+#ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
+		disk_partition_t part_info;
+		struct blk_desc *dev_desc;
+		int part_num = -1;
+		const char *fs_type = NULL;
+
+#ifdef CONFIG_RKIMG_BOOTLOADER
+		dev_desc = rockchip_get_bootdev();
+#else
+		dev_desc = NULL;
+#endif
+		if (!dev_desc) {
+			fb_add_string(response, chars_left,
+				      "block device not found", NULL);
+			ret = -1;
+			break;
+		}
+
+		part_num = part_get_info_by_name(dev_desc, part_name,
+						 &part_info);
+		if (part_num < 0) {
+			fb_add_string(response, chars_left,
+				      "partition not found", NULL);
+			ret = -1;
+		} else if (!strncmp(PARTITION_TYPE_STRINGS, cmd,
+					strlen(PARTITION_TYPE_STRINGS))) {
+			if (fb_get_fstype("mmc", part_num, &fs_type)) {
+				fb_add_string(response, chars_left,
+					      (char *)part_info.type, NULL);
+			} else {
+				fb_add_string(response, chars_left,
+					      fs_type, NULL);
+			}
+		} else if (!strncmp("partition-size", cmd, 14)) {
+			u64 part_size;
+
+			part_size = (uint64_t)part_info.size;
+			snprintf(response, chars_left, "0x%llx",
+				 part_size * dev_desc->blksz);
+		}
+#else
+		fb_add_string(response, chars_left, "not implemented", NULL);
+		ret = -1;
+#endif
+		break;
 	}
+	case FB_BLK_SIZE: {
+#ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
+		struct blk_desc *dev_desc;
 
-	/* Check if transfer is done */
-	if (download_bytes >= download_size) {
-		/*
-		 * Reset global transfer variable, keep download_bytes because
-		 * it will be used in the next possible flashing command
-		 */
-		download_size = 0;
-		req->complete = rx_handler_command;
-		req->length = EP_BUFFER_SIZE;
+#ifdef CONFIG_RKIMG_BOOTLOADER
+		dev_desc = rockchip_get_bootdev();
+#else
+		dev_desc = NULL;
+#endif
+		if (!dev_desc) {
+			fb_add_string(response, chars_left,
+				      "block device not found", NULL);
+			ret = -1;
+		} else {
+			fb_add_number(response, chars_left,
+				      "0x%lx", dev_desc->blksz);
+		}
+#else
+		fb_add_string(response, chars_left, "not implemented", NULL);
+		ret = -1;
+#endif
+		break;
+	}
+	case FB_ERASE_SIZE: {
+#ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
+		lbaint_t erase_grp_size;
 
-		strcpy(response, "OKAY");
-		fastboot_tx_write_str(response);
+		erase_grp_size = fb_mmc_get_erase_grp_size();
+		if (erase_grp_size < 0) {
+			fb_add_string(response, chars_left,
+				      "block device not found", NULL);
+			ret = -1;
+		} else {
+			fb_add_number(response, chars_left, "0x"LBAF"",
+				      erase_grp_size);
+		}
+#else
+		fb_add_string(response, chars_left, "not implemented", NULL);
+		ret = -1;
+#endif
+		break;
+	}
+	case FB_UNLOCKED: {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		uint8_t flash_lock_state = 0;
 
-		printf("\ndownloading of %d bytes finished\n", download_bytes);
-	} else {
-		req->length = rx_bytes_expected(ep);
+		if (rk_avb_read_flash_lock_state(&flash_lock_state))
+			fb_add_string(response, chars_left, "yes", NULL);
+		else
+			fb_add_string(response, chars_left, "no", NULL);
+#else
+		fb_add_string(response, chars_left, "not implemented", NULL);
+		ret = -1;
+#endif
+		break;
+	}
+	case  FB_OFF_MODE_CHARGE: {
+		fb_add_string(response, chars_left, "not implemented", NULL);
+		break;
+	}
+	case FB_BATT_VOLTAGE: {
+		fb_add_string(response, chars_left, "not implemented", NULL);
+		break;
+	}
+	case FB_BATT_SOC_OK: {
+		fb_add_string(response, chars_left, "no", NULL);
+		break;
+	}
+	case FB_IS_USERSPACE: {
+		fb_add_string(response, chars_left, "no", NULL);
+		break;
 	}
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	case FB_HAS_COUNT: {
+		char slot_count[2];
+		char temp;
+
+		slot_count[1] = '\0';
+		if (rk_avb_read_slot_count(&temp) < 0) {
+			fb_add_number(response, chars_left, "%d", 0);
+			ret = -1;
+			break;
+		}
+		slot_count[0] = temp + 0x30;
+		fb_add_string(response, chars_left, slot_count, NULL);
+		break;
+	}
+	case FB_HAS_SLOT: {
+		char *part_name = cmd;
+		int has_slot = -1;
+
+		cmd = strsep(&part_name, ":");
+		if (!cmd || !part_name) {
+			fb_add_string(response, chars_left,
+				      "argument Invalid!", NULL);
+			ret = -1;
+			break;
+		}
 
-	req->actual = 0;
-	usb_ep_queue(ep, req, 0);
-}
+		has_slot = rk_avb_get_part_has_slot_info(part_name);
+		if (has_slot < 0)
+			fb_add_string(response, chars_left, "no", NULL);
+		else
+			fb_add_string(response, chars_left, "yes", NULL);
+		break;
+	}
+	case FB_CURR_SLOT: {
+		char slot_surrent[8] = {0};
 
-static void cb_download(struct usb_ep *ep, struct usb_request *req)
-{
-	char *cmd = req->buf;
-	char response[FASTBOOT_RESPONSE_LEN];
+		if (!rk_avb_get_current_slot(slot_surrent)) {
+			fb_add_string(response, chars_left,
+				      slot_surrent + 1, NULL);
+		} else {
+			fb_add_string(response, chars_left, "get error", NULL);
+			ret = -1;
+		}
+		break;
+	}
+	case FB_SLOT_SUFFIXES: {
+		char slot_suffixes_temp[4] = {0};
+		char slot_suffixes[9] = {0};
+		int slot_cnt = 0;
+
+		rk_avb_read_slot_suffixes(slot_suffixes_temp);
+		while (slot_suffixes_temp[slot_cnt] != '\0') {
+			slot_suffixes[slot_cnt * 2]
+				= slot_suffixes_temp[slot_cnt];
+			slot_suffixes[slot_cnt * 2 + 1] = ',';
+			slot_cnt++;
+		}
 
-	strsep(&cmd, ":");
-	download_size = simple_strtoul(cmd, NULL, 16);
-	download_bytes = 0;
+		slot_suffixes[(slot_cnt - 1) * 2 + 1] = '\0';
+		fb_add_string(response, chars_left, slot_suffixes, NULL);
+		break;
+	}
+	case FB_SLOT_SUCCESSFUL:{
+		char *slot_name = cmd;
+		AvbABData ab_info;
+
+		cmd = strsep(&slot_name, ":");
+		if (!cmd || !slot_name) {
+			fb_add_string(response, chars_left,
+				      "argument Invalid!", NULL);
+			ret = -1;
+			break;
+		}
 
-	printf("Starting download of %d bytes\n", download_size);
+		if (rk_avb_get_ab_info(&ab_info) < 0) {
+			fb_add_string(response, chars_left,
+				      "get ab info failed!", NULL);
+			ret = -1;
+			break;
+		}
 
-	if (0 == download_size) {
-		strcpy(response, "FAILdata invalid size");
-	} else if (download_size > CONFIG_FASTBOOT_BUF_SIZE) {
-		download_size = 0;
-		strcpy(response, "FAILdata too large");
-	} else {
-		sprintf(response, "DATA%08x", download_size);
-		req->complete = rx_handler_dl_image;
-		req->length = rx_bytes_expected(ep);
+		if (!strcmp(slot_name, "a")) {
+			if (ab_info.slots[0].successful_boot)
+				fb_add_string(response, chars_left,
+					      "yes", NULL);
+			else
+				fb_add_string(response, chars_left,
+					      "no", NULL);
+		} else if (!strcmp(slot_name, "b")) {
+			if (ab_info.slots[1].successful_boot)
+				fb_add_string(response, chars_left,
+					      "yes", NULL);
+			else
+				fb_add_string(response, chars_left,
+					      "no", NULL);
+		} else {
+			fb_add_string(response, chars_left, "no", NULL);
+		}
+		break;
 	}
-	fastboot_tx_write_str(response);
-}
+	case FB_SLOT_UNBOOTABLE: {
+		char *slot_name = cmd;
+		AvbABData ab_info;
 
-static void do_bootm_on_complete(struct usb_ep *ep, struct usb_request *req)
-{
-	char boot_addr_start[12];
-	char *bootm_args[] = { "bootm", boot_addr_start, NULL };
+		cmd = strsep(&slot_name, ":");
 
-	puts("Booting kernel..\n");
+		if (!cmd || !slot_name) {
+			fb_add_string(response, chars_left,
+				      "argument Invalid!", NULL);
+			ret = -1;
+			break;
+		}
 
-	sprintf(boot_addr_start, "0x%lx", (long)CONFIG_FASTBOOT_BUF_ADDR);
-	do_bootm(NULL, 0, 2, bootm_args);
+		if (rk_avb_get_ab_info(&ab_info) < 0) {
+			fb_add_string(response, chars_left,
+				      "get ab info failed!", NULL);
+			ret = -1;
+			break;
+		}
 
-	/* This only happens if image is somehow faulty so we start over */
-	do_reset(NULL, 0, 0, NULL);
-}
+		if (!strcmp(slot_name, "a")) {
+			if (!ab_info.slots[0].successful_boot &&
+			    !ab_info.slots[0].tries_remaining &&
+			    !ab_info.slots[0].priority)
+				fb_add_string(response, chars_left,
+					      "yes", NULL);
+			else
+				fb_add_string(response, chars_left, "no", NULL);
+		} else if (!strcmp(slot_name, "b")) {
+			if (!ab_info.slots[1].successful_boot &&
+			    !ab_info.slots[1].tries_remaining &&
+			    !ab_info.slots[1].priority)
+				fb_add_string(response, chars_left,
+					      "yes", NULL);
+			else
+				fb_add_string(response, chars_left, "no", NULL);
+		} else {
+			fb_add_string(response, chars_left, "no", NULL);
+		}
+		break;
+	}
+	case FB_SLOT_RETRY_COUNT: {
+		char *slot_name = cmd;
+		AvbABData ab_info;
+
+		cmd = strsep(&slot_name, ":");
+		if (!cmd || !slot_name) {
+			fb_add_string(response, chars_left,
+				      "argument Invalid!", NULL);
+			ret = -1;
+			break;
+		}
 
-static void cb_boot(struct usb_ep *ep, struct usb_request *req)
-{
-	fastboot_func->in_req->complete = do_bootm_on_complete;
-	fastboot_tx_write_str("OKAY");
-}
+		if (rk_avb_get_ab_info(&ab_info) < 0) {
+			fb_add_string(response, chars_left,
+				      "get ab info failed!", NULL);
+			ret = -1;
+			break;
+		}
 
-static void do_exit_on_complete(struct usb_ep *ep, struct usb_request *req)
-{
-	g_dnl_trigger_detach();
-}
+		if (!strcmp(slot_name, "a")) {
+			fb_add_number(response, chars_left,
+				      "%d", ab_info.slots[0].tries_remaining);
+		} else if (!strcmp(slot_name, "b")) {
+			fb_add_number(response, chars_left, "%d",
+				      ab_info.slots[1].tries_remaining);
 
-static void cb_continue(struct usb_ep *ep, struct usb_request *req)
-{
+		} else {
+			strcpy(response, "FAILno");
+		}
+		break;
+	}
+	case FB_AT_VBST: {
+		char vbst[VBOOT_STATE_SIZE] = {0};
+		char *p_vbst;
+
+		strcpy(response, "INFO");
+		rk_avb_get_at_vboot_state(vbst);
+		p_vbst = vbst;
+		do {
+			cmd = strsep(&p_vbst, "\n");
+			if (strlen(cmd) > 0) {
+				memcpy(&response[4], cmd, chars_left);
+				fastboot_tx_write_str(response);
+			}
+		} while (strlen(cmd));
+		break;
+	}
+	case FB_SNAPSHOT_STATUS: {
+#ifdef CONFIG_ANDROID_AB
+		struct misc_virtual_ab_message state;
+
+		memset(&state, 0x0, sizeof(state));
+		if (read_misc_virtual_ab_message(&state) != 0) {
+			printf("FB_SNAPSHOT_STATUS read_misc_virtual_ab_message failed!\n");
+			fb_add_string(response, chars_left, "get error", NULL);
+			ret = -1;
+		}
+
+		if (state.magic != MISC_VIRTUAL_AB_MAGIC_HEADER) {
+			printf("FB_SNAPSHOT_STATUS not virtual A/B metadata!\n");
+			fb_add_string(response, chars_left, "get error", NULL);
+			ret = -1;
+		}
+
+		if (state.merge_status == ENUM_MERGE_STATUS_MERGING) {
+			fb_add_string(response, chars_left, "merging", NULL);
+		} else if (state.merge_status == ENUM_MERGE_STATUS_SNAPSHOTTED) {
+			fb_add_string(response, chars_left, "snapshotted", NULL);
+		} else {
+			fb_add_string(response, chars_left, "none", NULL);
+		}
+#else
+		fb_add_string(response, chars_left, "get error", NULL);
+		ret = -1;
+#endif
+		break;
+	}
+
+#endif
+#ifdef CONFIG_OPTEE_CLIENT
+	case FB_AT_DH: {
+		char dhbuf[ATTEST_DH_SIZE];
+		uint32_t dh_len = ATTEST_DH_SIZE;
+		uint32_t res = trusty_attest_dh((uint8_t *)dhbuf, &dh_len);
+
+		if (res) {
+			fb_add_string(response, chars_left, "dh not set", NULL);
+			ret = -1;
+		} else {
+			fb_add_string(response, chars_left, dhbuf, NULL);
+		}
+		break;
+	}
+	case FB_AT_UUID: {
+		char uuid[ATTEST_UUID_SIZE] = {0};
+		uint32_t uuid_len = ATTEST_UUID_SIZE;
+		uint32_t res = trusty_attest_uuid((uint8_t *)uuid, &uuid_len);
+
+		uuid[ATTEST_UUID_SIZE - 1] = 0;
+		if (res) {
+			fb_add_string(response, chars_left, "dh not set", NULL);
+			ret = -1;
+		} else {
+			fb_add_string(response, chars_left, uuid, NULL);
+		}
+		break;
+	}
+#endif
+	default: {
+			char *envstr;
+
+			envstr = malloc(strlen("fastboot.") + strlen(cmd) + 1);
+			if (!envstr) {
+				fb_add_string(response, chars_left,
+					      "malloc error", NULL);
+				ret = -1;
+				break;
+			}
+
+			sprintf(envstr, "fastboot.%s", cmd);
+			s = env_get(envstr);
+			if (s) {
+				strncat(response, s, chars_left);
+			} else {
+				printf("WARNING: unknown variable: %s\n", cmd);
+				fb_add_string(response, chars_left,
+					      "not implemented", NULL);
+			}
+
+			free(envstr);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static const struct {
+	/*
+	 *any changes to this array require an update to the corresponding
+	 *enum in fastboot.h
+	 */
+	struct name_string name;
+	fb_getvar_t var;
+} getvar_table[] = {
+	{ NAME_NO_ARGS("version"), FB_VERSION},
+	{ NAME_NO_ARGS("version-bootloader"), FB_BOOTLOADER_VERSION},
+	{ NAME_NO_ARGS("version-baseband"), FB_BASEBAND_VERSION},
+	{ NAME_NO_ARGS("product"), FB_PRODUCT},
+	{ NAME_NO_ARGS("serialno"), FB_SERIAL_NO},
+	{ NAME_NO_ARGS("secure"), FB_SECURE},
+	{ NAME_NO_ARGS("max-download-size"), FB_DWNLD_SIZE},
+	{ NAME_NO_ARGS("logical-block-size"), FB_BLK_SIZE},
+	{ NAME_NO_ARGS("erase-block-size"), FB_ERASE_SIZE},
+	{ NAME_ARGS("partition-type", ':'), FB_PART_TYPE},
+	{ NAME_ARGS("partition-size", ':'), FB_PART_SIZE},
+	{ NAME_NO_ARGS("unlocked"), FB_UNLOCKED},
+	{ NAME_NO_ARGS("off-mode-charge"), FB_OFF_MODE_CHARGE},
+	{ NAME_NO_ARGS("battery-voltage"), FB_BATT_VOLTAGE},
+	{ NAME_NO_ARGS("variant"), FB_VARIANT},
+	{ NAME_NO_ARGS("battery-soc-ok"), FB_BATT_SOC_OK},
+	{ NAME_NO_ARGS("is-userspace"), FB_IS_USERSPACE},
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	/* Slots related */
+	{ NAME_NO_ARGS("slot-count"), FB_HAS_COUNT},
+	{ NAME_ARGS("has-slot", ':'), FB_HAS_SLOT},
+	{ NAME_NO_ARGS("current-slot"), FB_CURR_SLOT},
+	{ NAME_NO_ARGS("slot-suffixes"), FB_SLOT_SUFFIXES},
+	{ NAME_ARGS("slot-successful", ':'), FB_SLOT_SUCCESSFUL},
+	{ NAME_ARGS("slot-unbootable", ':'), FB_SLOT_UNBOOTABLE},
+	{ NAME_ARGS("slot-retry-count", ':'), FB_SLOT_RETRY_COUNT},
+	{ NAME_NO_ARGS("at-vboot-state"), FB_AT_VBST},
+	{ NAME_NO_ARGS("snapshot-update-status"), FB_SNAPSHOT_STATUS},
+#endif
+	/*
+	 * OEM specific :
+	 * Spec says names starting with lowercase letter are reserved.
+	 */
+#ifdef CONFIG_OPTEE_CLIENT
+	{ NAME_NO_ARGS("at-attest-dh"), FB_AT_DH},
+	{ NAME_NO_ARGS("at-attest-uuid"), FB_AT_UUID},
+#endif
+};
+
+static int fb_getvar_single(char *cmd, char *response, size_t chars_left)
+{
+	int i;
+	size_t match_len = 0;
+	size_t len = strlen(cmd);
+
+	for (i = 0; i < ARRAY_SIZE(getvar_table); i++) {
+		match_len = name_check_match(cmd, len, &getvar_table[i].name);
+		if (match_len)
+			break;
+	}
+
+	if (match_len == 0) {
+		fb_add_string(response, chars_left, "unknown variable", NULL);
+		return -1;
+	}
+
+	if (fb_read_var(cmd, response, getvar_table[i].var, chars_left) < 0)
+		return -1;
+
+	return 0;
+}
+
+static void fb_getvar_all(void)
+{
+	char response[FASTBOOT_RESPONSE_LEN] = {0};
+	char resp_tmp[FASTBOOT_RESPONSE_LEN] = {0};
+	char *actual_resp;
+	size_t chars_left;
+	int i, p;
+	disk_partition_t part_info;
+	struct blk_desc *dev_desc;
+
+	strcpy(response, "INFO");
+	chars_left = sizeof(response) - strlen(response) - 1;
+	actual_resp = response + strlen(response);
+
+	for (i = 0; i < ARRAY_SIZE(getvar_table); i++) {
+		fb_getvar_t var = getvar_table[i].var;
+
+		switch (var) {
+		case FB_PART_TYPE:
+		case FB_PART_SIZE: {
+			const char *fs_type = NULL;
+#ifdef CONFIG_RKIMG_BOOTLOADER
+			dev_desc = rockchip_get_bootdev();
+#else
+			dev_desc = NULL;
+#endif
+			if (!dev_desc) {
+				fb_add_string(actual_resp, chars_left,
+					      "%s:block device not found",
+					      getvar_table[i].name.str);
+				fastboot_tx_write_str(response);
+				break;
+			}
+
+			for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
+				if (part_get_info(dev_desc, p,
+						  &part_info) < 0) {
+					break;
+				}
+
+				if (var == FB_PART_TYPE) {
+					fs_type = NULL;
+					if (fb_get_fstype("mmc", p,
+							  &fs_type)) {
+						fb_add_string(
+							resp_tmp,
+							FASTBOOT_RESPONSE_LEN,
+							(char *)part_info.type,
+							NULL);
+					} else {
+						fb_add_string(
+							resp_tmp,
+							FASTBOOT_RESPONSE_LEN,
+							fs_type,
+							NULL);
+					}
+
+					snprintf(actual_resp,
+						 chars_left,
+						 "%s:%s:%s",
+						 getvar_table[i].name.str,
+						 part_info.name,
+						 resp_tmp);
+				} else {
+					uint64_t part_size;
+
+					part_size = (uint64_t)part_info.size;
+					snprintf(actual_resp,
+						 chars_left,
+						 "%s:%s:0x%llx",
+						 getvar_table[i].name.str,
+						 part_info.name,
+						 part_size * dev_desc->blksz);
+				}
+				fastboot_tx_write_str(response);
+			}
+			break;
+		}
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		case FB_HAS_SLOT: {
+			uchar *ptr_name_tmp;
+			char c = '_';
+			int has_slot = -1;
+
+#ifdef CONFIG_RKIMG_BOOTLOADER
+			dev_desc = rockchip_get_bootdev();
+#else
+			dev_desc = NULL;
+#endif
+			if (!dev_desc) {
+				fb_add_string(actual_resp, chars_left,
+					      "%s:block device not found",
+					      getvar_table[i].name.str);
+				fastboot_tx_write_str(response);
+				break;
+			}
+
+			for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
+				if (part_get_info(dev_desc, p,
+						  &part_info) < 0) {
+					break;
+				} else {
+					ptr_name_tmp = (uchar *)strrchr(
+						(char *)part_info.name, c);
+					if (ptr_name_tmp &&
+					    part_info.name[ptr_name_tmp -
+						part_info.name + 2] == '\0')
+						fb_add_string(
+							resp_tmp,
+							ptr_name_tmp -
+							part_info.name + 1,
+							(char *)part_info.name,
+							NULL);
+					else
+						strcpy(resp_tmp,
+						       (char *)part_info.name);
+
+					has_slot = rk_avb_get_part_has_slot_info(
+						resp_tmp);
+					if (has_slot < 0) {
+						snprintf(actual_resp,
+							 chars_left,
+							 "%s:%s:no",
+							 getvar_table[i].name.str,
+							 resp_tmp);
+					} else {
+						snprintf(actual_resp,
+							 chars_left,
+							 "%s:%s:yes",
+							 getvar_table[i].name.str,
+							 resp_tmp);
+						p++;
+					}
+
+					fastboot_tx_write_str(response);
+				}
+			}
+			break;
+		}
+
+		case FB_SLOT_SUCCESSFUL: {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+			AvbABData ab_info;
+
+			if (rk_avb_get_ab_info(&ab_info) < 0) {
+				fb_add_string(actual_resp,
+					      chars_left,
+					      "%s:get ab info failed!",
+					      getvar_table[i].name.str);
+				fastboot_tx_write_str(response);
+				break;
+			}
+
+			if (ab_info.slots[0].successful_boot)
+				fb_add_string(actual_resp, chars_left,
+					      "%s:a:yes",
+					      getvar_table[i].name.str);
+			else
+				fb_add_string(actual_resp, chars_left,
+					      "%s:a:no",
+					      getvar_table[i].name.str);
+			fastboot_tx_write_str(response);
+
+			if (ab_info.slots[1].successful_boot)
+				fb_add_string(actual_resp, chars_left,
+					      "%s:b:yes",
+					      getvar_table[i].name.str);
+			else
+				fb_add_string(actual_resp, chars_left,
+					      "%s:b:no",
+					      getvar_table[i].name.str);
+			fastboot_tx_write_str(response);
+#else
+			fb_add_string(actual_resp, chars_left,
+				      "%s:not find ab info!",
+				      getvar_table[i].name.str);
+			fastboot_tx_write_str(response);
+#endif
+			break;
+		}
+
+		case FB_SLOT_UNBOOTABLE: {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+			AvbABData ab_info;
+
+			if (rk_avb_get_ab_info(&ab_info) < 0) {
+				fb_add_string(actual_resp, chars_left,
+					      "%s:not find ab info!",
+					      getvar_table[i].name.str);
+				fastboot_tx_write_str(response);
+				break;
+			}
+
+			if (!ab_info.slots[0].successful_boot &&
+			    !ab_info.slots[0].tries_remaining &&
+			    !ab_info.slots[0].priority)
+				fb_add_string(actual_resp, chars_left,
+					      "%s:a:yes",
+					      getvar_table[i].name.str);
+			else
+				fb_add_string(actual_resp, chars_left,
+					      "%s:a:no",
+					      getvar_table[i].name.str);
+			fastboot_tx_write_str(response);
+
+			if (!ab_info.slots[1].successful_boot &&
+			    !ab_info.slots[1].tries_remaining &&
+			    !ab_info.slots[1].priority)
+				fb_add_string(actual_resp, chars_left,
+					      "%s:b:yes",
+					      getvar_table[i].name.str);
+			else
+				fb_add_string(actual_resp, chars_left,
+					      "%s:b:no",
+					      getvar_table[i].name.str);
+
+			fastboot_tx_write_str(response);
+#else
+			fb_add_string(actual_resp, chars_left,
+				      "%s:not find ab info!",
+				      getvar_table[i].name.str);
+			fastboot_tx_write_str(response);
+#endif
+			break;
+		}
+
+		case FB_SLOT_RETRY_COUNT: {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+			AvbABData ab_info;
+
+			if (rk_avb_get_ab_info(&ab_info) < 0) {
+				fb_add_string(actual_resp, chars_left,
+					      "%s:not find ab info!",
+					      getvar_table[i].name.str);
+				fastboot_tx_write_str(response);
+				break;
+			}
+
+			snprintf(actual_resp, chars_left, "%s:a:%d",
+				 getvar_table[i].name.str,
+				 ab_info.slots[1].tries_remaining);
+			fastboot_tx_write_str(response);
+			snprintf(actual_resp, chars_left, "%s:b:%d",
+				 getvar_table[i].name.str,
+				 ab_info.slots[1].tries_remaining);
+			fastboot_tx_write_str(response);
+#else
+			fb_add_string(actual_resp, chars_left,
+				      "%s:not find ab info!",
+				      getvar_table[i].name.str);
+			fastboot_tx_write_str(response);
+#endif
+			break;
+		}
+#endif
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		case FB_AT_VBST:
+			break;
+#endif
+		default:
+			fb_getvar_single((char *)getvar_table[i].name.str,
+					 resp_tmp, FASTBOOT_RESPONSE_LEN);
+			snprintf(actual_resp, chars_left, "%s:%s",
+				 getvar_table[i].name.str, resp_tmp);
+			fastboot_tx_write_str(response);
+		}
+	}
+}
+
+#ifdef CONFIG_ANDROID_AB
+static int get_current_slot(void)
+{
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	char cmd[8] = {0};
+	unsigned int slot_number = -1;
+
+	memset(cmd, 0x0, sizeof(cmd));
+	rk_avb_get_current_slot(cmd);
+	if (strncmp("_a", cmd, 2) == 0) {
+		slot_number = 0;
+	} else if (strncmp("_b", cmd, 2) == 0) {
+		slot_number = 1;
+	} else {
+		pr_err("%s: FAILunkown slot name\n", __func__);
+		return -1;
+	}
+
+	return slot_number;
+#else
+	pr_err("%s: FAILnot implemented\n", __func__);
+	return -1;
+#endif
+}
+
+#ifdef CONFIG_FASTBOOT_FLASH
+static int should_prevent_userdata_wipe(void)
+{
+	struct misc_virtual_ab_message state;
+
+	memset(&state, 0x0, sizeof(state));
+	if (read_misc_virtual_ab_message(&state) != 0) {
+		pr_err("%s: read_misc_virtual_ab_message failed!\n", __func__);
+		return 0;
+	}
+
+	if (state.magic != MISC_VIRTUAL_AB_MAGIC_HEADER) {
+		pr_err("%s: NOT virtual A/B metadata!\n", __func__);
+		return 0;
+	}
+
+	if (state.merge_status == (uint8_t)ENUM_MERGE_STATUS_MERGING ||
+		(state.merge_status == (uint8_t)ENUM_MERGE_STATUS_SNAPSHOTTED &&
+		state.source_slot != get_current_slot())) {
+		return 1;
+	}
+
+	return 0;
+}
+#endif
+
+static int get_virtual_ab_merge_status(void)
+{
+	struct misc_virtual_ab_message state;
+
+	memset(&state, 0x0, sizeof(state));
+	if (read_misc_virtual_ab_message(&state) != 0) {
+		pr_err("%s: read_misc_virtual_ab_message failed!\n", __func__);
+		return -1;
+	}
+
+	if (state.magic != MISC_VIRTUAL_AB_MAGIC_HEADER) {
+		pr_err("%s: NOT virtual A/B metadata!\n", __func__);
+		return -1;
+	}
+
+	return state.merge_status;
+}
+#endif
+
+static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
+{
+	char *cmd = req->buf;
+	char response[FASTBOOT_RESPONSE_LEN] = {0};
+	const char *str_read_all = "all";
+	size_t len = 0;
+	size_t chars_left;
+
+	strsep(&cmd, ":");
+	if (!cmd) {
+		pr_err("missing variable");
+		fastboot_tx_write_str("FAILmissing var");
+		return;
+	}
+
+	len = strlen(cmd);
+	if (len == strlen(str_read_all) &&
+	    (strncmp(cmd, str_read_all, len) == 0)) {
+		fb_getvar_all();
+		fastboot_tx_write_str("OKAYDone!");
+	} else {
+		strcpy(response, "OKAY");
+		chars_left = sizeof(response) - strlen(response) - 1;
+
+		if (fb_getvar_single(cmd, &response[strlen(response)],
+				     chars_left) < 0) {
+			strcpy(cmd, "FAILunknown variable");
+			strncat(cmd, &response[strlen(response)], chars_left);
+			fastboot_tx_write_str(cmd);
+			return;
+		}
+		fastboot_tx_write_str(response);
+	}
+
+	return;
+}
+
+static unsigned int rx_bytes_expected(struct usb_ep *ep)
+{
+	int rx_remain = download_size - download_bytes;
+	unsigned int rem;
+	unsigned int maxpacket = ep->maxpacket;
+
+	if (rx_remain <= 0)
+		return 0;
+	else if (rx_remain > EP_BUFFER_SIZE)
+		return EP_BUFFER_SIZE;
+
+	/*
+	 * Some controllers e.g. DWC3 don't like OUT transfers to be
+	 * not ending in maxpacket boundary. So just make them happy by
+	 * always requesting for integral multiple of maxpackets.
+	 * This shouldn't bother controllers that don't care about it.
+	 */
+	rem = rx_remain % maxpacket;
+	if (rem > 0)
+		rx_remain = rx_remain + (maxpacket - rem);
+
+	return rx_remain;
+}
+
+#define BYTES_PER_DOT	0x20000
+static void rx_handler_dl_image(struct usb_ep *ep, struct usb_request *req)
+{
+	char response[FASTBOOT_RESPONSE_LEN];
+	unsigned int transfer_size = download_size - download_bytes;
+	const unsigned char *buffer = req->buf;
+	unsigned int buffer_size = req->actual;
+	unsigned int pre_dot_num, now_dot_num;
+
+	if (req->status != 0) {
+		printf("Bad status: %d\n", req->status);
+		return;
+	}
+
+	if (buffer_size < transfer_size)
+		transfer_size = buffer_size;
+
+	memcpy((void *)CONFIG_FASTBOOT_BUF_ADDR + download_bytes,
+	       buffer, transfer_size);
+
+	pre_dot_num = download_bytes / BYTES_PER_DOT;
+	download_bytes += transfer_size;
+	now_dot_num = download_bytes / BYTES_PER_DOT;
+
+	if (pre_dot_num != now_dot_num) {
+		putc('.');
+		if (!(now_dot_num % 74))
+			putc('\n');
+	}
+
+	/* Check if transfer is done */
+	if (download_bytes >= download_size) {
+		/*
+		 * Reset global transfer variable, keep download_bytes because
+		 * it will be used in the next possible flashing command
+		 */
+		download_size = 0;
+		req->complete = rx_handler_command;
+		req->length = EP_BUFFER_SIZE;
+
+		strcpy(response, "OKAY");
+		fastboot_tx_write_str(response);
+
+		printf("\ndownloading of %d bytes finished\n", download_bytes);
+	} else {
+		req->length = rx_bytes_expected(ep);
+	}
+
+	req->actual = 0;
+	usb_ep_queue(ep, req, 0);
+}
+
+static void cb_download(struct usb_ep *ep, struct usb_request *req)
+{
+	char *cmd = req->buf;
+	char response[FASTBOOT_RESPONSE_LEN];
+
+	strsep(&cmd, ":");
+	download_size = simple_strtoul(cmd, NULL, 16);
+	download_bytes = 0;
+
+	printf("Starting download of %d bytes\n", download_size);
+
+	if (0 == download_size) {
+		strcpy(response, "FAILdata invalid size");
+	} else if (download_size > CONFIG_FASTBOOT_BUF_SIZE) {
+		download_size = 0;
+		strcpy(response, "FAILdata too large");
+	} else {
+		sprintf(response, "DATA%08x", download_size);
+		req->complete = rx_handler_dl_image;
+		req->length = rx_bytes_expected(ep);
+	}
+
+	fastboot_tx_write_str(response);
+}
+
+static void tx_handler_ul(struct usb_ep *ep, struct usb_request *req)
+{
+	unsigned int xfer_size = 0;
+	unsigned int pre_dot_num, now_dot_num;
+	unsigned int remain_size = 0;
+	unsigned int transferred_size = req->actual;
+
+	if (req->status != 0) {
+		printf("Bad status: %d\n", req->status);
+		return;
+	}
+
+	if (start_upload) {
+		pre_dot_num = upload_bytes / BYTES_PER_DOT;
+		upload_bytes += transferred_size;
+		now_dot_num = upload_bytes / BYTES_PER_DOT;
+
+		if (pre_dot_num != now_dot_num) {
+			putc('.');
+			if (!(now_dot_num % 74))
+				putc('\n');
+		}
+	}
+
+	remain_size = upload_size - upload_bytes;
+	xfer_size = (remain_size > EP_BUFFER_SIZE) ?
+		    EP_BUFFER_SIZE : remain_size;
+
+	debug("%s: remain_size=%d, transferred_size=%d",
+	      __func__, remain_size, transferred_size);
+	debug("xfer_size=%d, upload_bytes=%d, upload_size=%d!\n",
+	      xfer_size, upload_bytes, upload_size);
+
+	if (remain_size <= 0) {
+		fastboot_func->in_req->complete = fastboot_complete;
+		wakeup_thread();
+		fastboot_tx_write_str("OKAY");
+		printf("\nuploading of %d bytes finished\n", upload_bytes);
+		upload_bytes = 0;
+		upload_size = 0;
+		start_upload = false;
+		return;
+	}
+
+	/* Remove the transfer callback which response the upload */
+	/* request from host */
+	if (!upload_bytes)
+		start_upload = true;
+
+	fastboot_tx_write((char *)((phys_addr_t)CONFIG_FASTBOOT_BUF_ADDR + \
+			  upload_bytes),
+			  xfer_size);
+}
+
+static void cb_upload(struct usb_ep *ep, struct usb_request *req)
+{
+	char response[FASTBOOT_RESPONSE_LEN];
+
+	printf("Starting upload of %d bytes\n", upload_size);
+
+	if (0 == upload_size) {
+		strcpy(response, "FAILdata invalid size");
+	} else {
+		start_upload = false;
+		sprintf(response, "DATA%08x", upload_size);
+		fastboot_func->in_req->complete = tx_handler_ul;
+	}
+
+	fastboot_tx_write_str(response);
+}
+
+static void do_bootm_on_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	char boot_addr_start[12];
+	char *bootm_args[] = { "bootm", boot_addr_start, NULL };
+
+	puts("Booting kernel..\n");
+
+	sprintf(boot_addr_start, "0x%lx", (long)CONFIG_FASTBOOT_BUF_ADDR);
+	do_bootm(NULL, 0, 2, bootm_args);
+
+	/* This only happens if image is somehow faulty so we start over */
+	do_reset(NULL, 0, 0, NULL);
+}
+
+static void cb_boot(struct usb_ep *ep, struct usb_request *req)
+{
+	fastboot_func->in_req->complete = do_bootm_on_complete;
+	fastboot_tx_write_str("OKAY");
+}
+
+static void do_exit_on_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	g_dnl_trigger_detach();
+}
+
+static void cb_continue(struct usb_ep *ep, struct usb_request *req)
+{
 	fastboot_func->in_req->complete = do_exit_on_complete;
 	fastboot_tx_write_str("OKAY");
 }
 
+static void cb_set_active(struct usb_ep *ep, struct usb_request *req)
+{
+	char *cmd = req->buf;
+
+	debug("%s: %s\n", __func__, cmd);
+
+	strsep(&cmd, ":");
+	if (!cmd) {
+		pr_err("missing slot name");
+		fastboot_tx_write_str("FAILmissing slot name");
+		return;
+	}
+#ifdef CONFIG_ANDROID_AB
+	if (get_virtual_ab_merge_status() == ENUM_MERGE_STATUS_MERGING) {
+		pr_err("virtual A/B is merging, abort the operation");
+		fastboot_tx_write_str("FAILvirtual A/B is merging, abort");
+		return;
+	}
+#endif
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	unsigned int slot_number;
+	if (strncmp("a", cmd, 1) == 0) {
+		slot_number = 0;
+		rk_avb_set_slot_active(&slot_number);
+	} else if (strncmp("b", cmd, 1) == 0) {
+		slot_number = 1;
+		rk_avb_set_slot_active(&slot_number);
+	} else {
+		fastboot_tx_write_str("FAILunkown slot name");
+		return;
+	}
+
+	fastboot_tx_write_str("OKAY");
+	return;
+#else
+	fastboot_tx_write_str("FAILnot implemented");
+	return;
+#endif
+}
+
 #ifdef CONFIG_FASTBOOT_FLASH
 static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
-	char response[FASTBOOT_RESPONSE_LEN];
+	char response[FASTBOOT_RESPONSE_LEN] = {0};
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	uint8_t flash_lock_state;
+
+	if (rk_avb_read_flash_lock_state(&flash_lock_state)) {
+		/* write the device flashing unlock when first read */
+		if (rk_avb_write_flash_lock_state(1)) {
+			fastboot_tx_write_str("FAILflash lock state write failure");
+			return;
+		}
+		if (rk_avb_read_flash_lock_state(&flash_lock_state)) {
+			fastboot_tx_write_str("FAILflash lock state read failure");
+			return;
+		}
+	}
 
+	if (flash_lock_state == 0) {
+		fastboot_tx_write_str("FAILThe device is locked, can not flash!");
+		printf("The device is locked, can not flash!\n");
+		return;
+	}
+#endif
 	strsep(&cmd, ":");
 	if (!cmd) {
-		error("missing partition name");
+		pr_err("missing partition name");
 		fastboot_tx_write_str("FAILmissing partition name");
 		return;
 	}
-
-	/* initialize the response buffer */
-	fb_response_str = response;
-
-	fastboot_fail("no flash device defined");
+#ifdef CONFIG_ANDROID_AB
+	if ((strcmp(cmd, PART_USERDATA) == 0) || (strcmp(cmd, PART_METADATA) == 0)) {
+		if (should_prevent_userdata_wipe()) {
+			pr_err("FAILThe virtual A/B merging, can not flash userdata or metadata!\n");
+			fastboot_tx_write_str("FAILvirtual A/B merging,abort flash!");
+			return;
+		}
+	}
+#endif
+	fastboot_fail("no flash device defined", response);
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 	fb_mmc_flash_write(cmd, (void *)CONFIG_FASTBOOT_BUF_ADDR,
-			   download_bytes);
+				download_bytes, response);
 #endif
 #ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
-	fb_nand_flash_write(cmd,
-			    (void *)CONFIG_FASTBOOT_BUF_ADDR,
-			    download_bytes);
+	fb_nand_flash_write(cmd, (void *)CONFIG_FASTBOOT_BUF_ADDR,
+				download_bytes, response);
 #endif
 	fastboot_tx_write_str(response);
 }
+
+static void cb_flashing(struct usb_ep *ep, struct usb_request *req)
+{
+	char *cmd = req->buf;
+
+	if (strncmp("lock", cmd + 9, 4) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		uint8_t flash_lock_state;
+		flash_lock_state = 0;
+		if (rk_avb_write_flash_lock_state(flash_lock_state))
+			fastboot_tx_write_str("FAILflash lock state"
+					      " write failure");
+		else
+			fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+#endif
+	} else if (strncmp("unlock", cmd + 9, 6) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		uint8_t flash_lock_state;
+		flash_lock_state = 1;
+		if (rk_avb_write_flash_lock_state(flash_lock_state))
+			fastboot_tx_write_str("FAILflash lock state"
+					      " write failure");
+		else
+			fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+#endif
+	} else if (strncmp("lock_critical", cmd + 9, 12) == 0) {
+		fastboot_tx_write_str("FAILnot implemented");
+	} else if (strncmp("unlock_critical", cmd + 9, 14) == 0) {
+		fastboot_tx_write_str("FAILnot implemented");
+	} else if (strncmp("get_unlock_ability", cmd + 9, 17) == 0) {
+		fastboot_tx_write_str("FAILnot implemented");
+	} else if (strncmp("get_unlock_bootloader_nonce", cmd + 4, 27) == 0) {
+		fastboot_tx_write_str("FAILnot implemented");
+	} else if (strncmp("unlock_bootloader", cmd + 9, 17) == 0) {
+		fastboot_tx_write_str("FAILnot implemented");
+	} else if (strncmp("lock_bootloader", cmd + 9, 15) == 0) {
+		fastboot_tx_write_str("FAILnot implemented");
+	} else {
+		fastboot_tx_write_str("FAILunknown flashing command");
+	}
+}
+#endif
+
+static void cb_oem_perm_attr(void)
+{
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+#ifndef CONFIG_ROCKCHIP_PRELOADER_PUB_KEY
+	sha256_context ctx;
+	uint8_t digest[SHA256_SUM_LEN] = {0};
+	uint8_t digest_temp[SHA256_SUM_LEN] = {0};
+	uint8_t perm_attr_temp[PERM_ATTR_TOTAL_SIZE] = {0};
+	uint8_t flag = 0;
+#endif
+	if (PERM_ATTR_TOTAL_SIZE != download_bytes) {
+		printf("Permanent attribute size is not equal!\n");
+		fastboot_tx_write_str("FAILincorrect perm attribute size");
+		return;
+	}
+#ifndef CONFIG_ROCKCHIP_PRELOADER_PUB_KEY
+	if (rk_avb_read_perm_attr_flag(&flag)) {
+		printf("rk_avb_read_perm_attr_flag error!\n");
+		fastboot_tx_write_str("FAILperm attr read failed");
+		return;
+	}
+
+	if (flag == PERM_ATTR_SUCCESS_FLAG) {
+		if (rk_avb_read_attribute_hash(digest_temp,
+					       SHA256_SUM_LEN)) {
+			printf("The efuse IO can not be used!\n");
+			fastboot_tx_write_str("FAILefuse IO can not be used");
+			return;
+		}
+
+		if (memcmp(digest, digest_temp, SHA256_SUM_LEN) != 0) {
+			if (rk_avb_read_permanent_attributes(perm_attr_temp,
+							     PERM_ATTR_TOTAL_SIZE)) {
+				printf("rk_avb_write_permanent_attributes error!\n");
+				fastboot_tx_write_str("FAILread perm attr error");
+				return;
+			}
+
+			sha256_starts(&ctx);
+			sha256_update(&ctx,
+				      (const uint8_t *)perm_attr_temp,
+				      PERM_ATTR_TOTAL_SIZE);
+			sha256_finish(&ctx, digest);
+			if (memcmp(digest, digest_temp, SHA256_SUM_LEN) == 0) {
+				printf("The hash has been written!\n");
+				fastboot_tx_write_str("OKAY");
+				return;
+			}
+		}
+
+		if (rk_avb_write_perm_attr_flag(0)) {
+			fastboot_tx_write_str("FAILperm attr flag write failure");
+			return;
+		}
+	}
+#endif
+	if (rk_avb_write_permanent_attributes((uint8_t *)
+					      CONFIG_FASTBOOT_BUF_ADDR,
+					      download_bytes)) {
+		if (rk_avb_write_perm_attr_flag(0)) {
+			fastboot_tx_write_str("FAILperm attr flag write failure");
+			return;
+		}
+		fastboot_tx_write_str("FAILperm attr write failed");
+		return;
+	}
+#ifndef CONFIG_ROCKCHIP_PRELOADER_PUB_KEY
+	memset(digest, 0, SHA256_SUM_LEN);
+	sha256_starts(&ctx);
+	sha256_update(&ctx, (const uint8_t *)CONFIG_FASTBOOT_BUF_ADDR,
+		      PERM_ATTR_TOTAL_SIZE);
+	sha256_finish(&ctx, digest);
+
+	if (rk_avb_write_attribute_hash((uint8_t *)digest,
+					SHA256_SUM_LEN)) {
+		if (rk_avb_read_attribute_hash(digest_temp,
+						SHA256_SUM_LEN)) {
+			printf("The efuse IO can not be used!\n");
+			fastboot_tx_write_str("FAILefuse IO can not be used");
+			return;
+		}
+		if (memcmp(digest, digest_temp, SHA256_SUM_LEN) != 0) {
+			if (rk_avb_write_perm_attr_flag(0)) {
+				fastboot_tx_write_str("FAILperm attr flag write failure");
+				return;
+			}
+			printf("The hash has been written, but is different!\n");
+			fastboot_tx_write_str("FAILhash comparison failure");
+			return;
+		}
+	}
+#endif
+	if (rk_avb_write_perm_attr_flag(PERM_ATTR_SUCCESS_FLAG)) {
+		fastboot_tx_write_str("FAILperm attr flag write failure");
+		return;
+	}
+
+	fastboot_tx_write_str("OKAY");
+#else
+	fastboot_tx_write_str("FAILnot implemented");
+#endif
+}
+
+static void cb_oem_perm_attr_rsa_cer(void)
+{
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	if (download_bytes != 256) {
+		printf("Permanent attribute rsahash size is not equal!\n");
+		fastboot_tx_write_str("FAILperm attribute rsahash size error");
+		return;
+	}
+
+	if (rk_avb_set_perm_attr_cer((uint8_t *)CONFIG_FASTBOOT_BUF_ADDR,
+				     download_bytes)) {
+		fastboot_tx_write_str("FAILSet perm attr cer fail!");
+		return;
+	}
+
+	fastboot_tx_write_str("OKAY");
+#else
+	fastboot_tx_write_str("FAILnot implemented");
 #endif
+}
 
 static void cb_oem(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
+
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 	if (strncmp("format", cmd + 4, 6) == 0) {
 		char cmdbuf[32];
-                sprintf(cmdbuf, "gpt write mmc %x $partitions",
+		sprintf(cmdbuf, "gpt write mmc %x $partitions",
 			CONFIG_FASTBOOT_FLASH_MMC_DEV);
-                if (run_command(cmdbuf, 0))
-			fastboot_tx_write_str("FAIL");
-                else
-			fastboot_tx_write_str("OKAY");
+#ifdef CONFIG_ANDROID_AB
+		if (should_prevent_userdata_wipe()) {
+			printf("FAILThe virtual A/B merging, can not format!\n");
+			fastboot_tx_write_str("FAILvirtual A/B merging,abort format!");
+		} else {
+			if (run_command(cmdbuf, 0))
+				fastboot_tx_write_str("FAILmmc write failure");
+			else
+				fastboot_tx_write_str("OKAY");
+		}
+#else
+	if (run_command(cmdbuf, 0))
+		fastboot_tx_write_str("FAILmmc write failure");
+	else
+		fastboot_tx_write_str("OKAY");
+#endif
 	} else
 #endif
 	if (strncmp("unlock", cmd + 4, 8) == 0) {
+#ifdef CONFIG_FASTBOOT_OEM_UNLOCK
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
 		fastboot_tx_write_str("FAILnot implemented");
-	}
-	else {
+		return;
+#else
+		uint8_t unlock = 0;
+		TEEC_Result result;
+		debug("oem unlock\n");
+		result = trusty_read_oem_unlock(&unlock);
+		if (result) {
+			printf("read oem unlock status with error : 0x%x\n", result);
+			fastboot_tx_write_str("FAILRead oem unlock status failed");
+			return;
+		}
+		if (unlock) {
+			printf("oem unlock ignored, device already unlocked\n");
+			fastboot_tx_write_str("FAILalready unlocked");
+			return;
+		}
+		printf("oem unlock requested:\n");
+		printf("\tUnlocking forces a factory reset and could\n");
+		printf("\topen your device up to a world of hurt.  If you\n");
+		printf("\tare sure you know what you're doing, then accept\n");
+		printf("\tvia 'fastboot oem unlock_accept'.\n");
+		env_set("unlock", "unlock");
+		fastboot_tx_write_str("OKAY");
+#endif
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#endif
+	} else if (strncmp("unlock_accept", cmd + 4, 13) == 0) {
+#ifdef CONFIG_FASTBOOT_OEM_UNLOCK
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#else
+		char *unlock = env_get("unlock");
+		TEEC_Result result;
+		debug("oem unlock_accept\n");
+		if (unlock == NULL || strncmp("unlock", unlock, 6) != 0) {
+			printf("oem unlock_accept ignored, not pending\n");
+			fastboot_tx_write_str("FAILoem unlock not requested");
+			return;
+		}
+		env_set("unlock", "");
+		printf("Erasing userdata partition\n");
+		struct blk_desc *dev_desc;
+		disk_partition_t part_info;
+		dev_desc = rockchip_get_bootdev();
+		if (!dev_desc) {
+			printf("%s: dev_desc is NULL!\n", __func__);
+			return;
+		}
+		int ret = part_get_info_by_name(dev_desc, "userdata",
+				&part_info);
+		if (ret < 0) {
+			printf("not found userdata partition");
+			printf("Erase failed with error %d\n", ret);
+			fastboot_tx_write_str("FAILErasing userdata failed");
+			return;
+		}
+		ret = blk_derase(dev_desc, part_info.start, part_info.size);
+		if (ret != part_info.size) {
+			printf("Erase failed with error %d\n", ret);
+			fastboot_tx_write_str("FAILErasing userdata failed");
+			return;
+		}
+		printf("Erasing succeeded\n");
+
+		result = trusty_write_oem_unlock(1);
+		if (result) {
+			printf("write oem unlock status with error : 0x%x\n", result);
+			fastboot_tx_write_str("FAILWrite oem unlock status failed");
+			return;
+		}
+		fastboot_tx_write_str("OKAY");
+
+		/*
+		 * now reboot into recovery to do a format of the
+		 * userdata partition so it's ready to use on next boot
+		 */
+		board_run_recovery_wipe_data();
+#endif
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#endif
+	} else if (strncmp("lock", cmd + 4, 8) == 0) {
+#ifdef CONFIG_FASTBOOT_OEM_UNLOCK
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#else
+		TEEC_Result result;
+		uint8_t unlock = 0;
+		trusty_read_oem_unlock(&unlock);
+		if (!unlock) {
+			printf("oem lock ignored, already locked\n");
+			fastboot_tx_write_str("FAILalready locked");
+			return;
+		}
+
+		result = trusty_write_oem_unlock(0);
+		if (result) {
+			printf("write oem unlock status with error : 0x%x\n", result);
+			fastboot_tx_write_str("FAILWrite oem unlock status failed");
+			return;
+		}
+		fastboot_tx_write_str("OKAY");
+#endif
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#endif
+	} else if (strncmp("at-get-ca-request", cmd + 4, 17) == 0) {
+#ifdef CONFIG_OPTEE_CLIENT
+		uint8_t out[ATTEST_CA_OUT_SIZE];
+		uint32_t operation_size = download_bytes;
+		uint32_t out_len = ATTEST_CA_OUT_SIZE;
+		uint32_t res = 0;
+
+		res = trusty_attest_get_ca((uint8_t *)CONFIG_FASTBOOT_BUF_ADDR,
+					   &operation_size, out, &out_len);
+		if (res) {
+			fastboot_tx_write_str("FAILtrusty_attest_get_ca failed");
+			return;
+		}
+		upload_size = out_len;
+		memcpy((void *)CONFIG_FASTBOOT_BUF_ADDR, out, out_len);
+		fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#endif
+	} else if (strncmp("at-set-ca-response", cmd + 4, 18) == 0) {
+#ifdef CONFIG_OPTEE_CLIENT
+		uint32_t ca_response_size = download_bytes;
+		uint32_t res = 0;
+
+		res = trusty_attest_set_ca((uint8_t *)CONFIG_FASTBOOT_BUF_ADDR,
+					   &ca_response_size);
+		if (res)
+			fastboot_tx_write_str("FAILtrusty_attest_set_ca failed");
+		else
+			fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#endif
+	} else if (strncmp("at-get-vboot-unlock-challenge", cmd + 4, 29) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		uint32_t challenge_len = 0;
+		int ret = 0;
+
+		ret = rk_generate_unlock_challenge((void *)CONFIG_FASTBOOT_BUF_ADDR, &challenge_len);
+		if (ret == 0) {
+			upload_size = challenge_len;
+			fastboot_tx_write_str("OKAY");
+		} else {
+			fastboot_tx_write_str("FAILgenerate unlock challenge fail!");
+		}
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+		return;
+#endif
+	} else if (strncmp("at-lock-vboot", cmd + 4, 13) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		uint8_t lock_state;
+		lock_state = 0;
+		if (rk_avb_write_lock_state(lock_state))
+			fastboot_tx_write_str("FAILwrite lock state failed");
+		else
+			fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+#endif
+	} else if (strncmp("at-unlock-vboot", cmd + 4, 15) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		uint8_t lock_state;
+		char out_is_trusted = true;
+
+		if (rk_avb_read_lock_state(&lock_state))
+			fastboot_tx_write_str("FAILlock sate read failure");
+		if (lock_state >> 1 == 1) {
+			fastboot_tx_write_str("FAILThe vboot is disable!");
+		} else {
+			lock_state = 1;
+#ifdef CONFIG_RK_AVB_LIBAVB_ENABLE_ATH_UNLOCK
+			if (rk_auth_unlock((void *)CONFIG_FASTBOOT_BUF_ADDR,
+					   &out_is_trusted)) {
+				printf("rk_auth_unlock ops error!\n");
+				fastboot_tx_write_str("FAILrk_auth_unlock ops error!");
+				return;
+			}
+#endif
+			if (out_is_trusted == true) {
+				if (rk_avb_write_lock_state(lock_state))
+					fastboot_tx_write_str("FAILwrite lock state failed");
+				else
+					fastboot_tx_write_str("OKAY");
+			} else {
+				fastboot_tx_write_str("FAILauthenticated unlock fail");
+			}
+		}
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+#endif
+	} else if (strncmp("fuse at-perm-attr", cmd + 4, 16) == 0) {
+		cb_oem_perm_attr();
+	} else if (strncmp("fuse at-rsa-perm-attr", cmd + 4, 25) == 0) {
+		cb_oem_perm_attr_rsa_cer();
+	} else if (strncmp("fuse at-bootloader-vboot-key", cmd + 4, 27) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		sha256_context ctx;
+		uint8_t digest[SHA256_SUM_LEN];
+
+		if (download_bytes != VBOOT_KEY_HASH_SIZE) {
+			fastboot_tx_write_str("FAILinvalid vboot key length");
+			printf("The vboot key size error!\n");
+			return;
+		}
+
+		sha256_starts(&ctx);
+		sha256_update(&ctx, (const uint8_t *)CONFIG_FASTBOOT_BUF_ADDR,
+			      VBOOT_KEY_SIZE);
+		sha256_finish(&ctx, digest);
+
+		if (rk_avb_write_vbootkey_hash((uint8_t *)digest,
+					       SHA256_SUM_LEN)) {
+			fastboot_tx_write_str("FAILvbootkey hash write failure");
+			return;
+		}
+		fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+#endif
+	} else if (strncmp("init-ab-metadata", cmd + 4, 16) == 0) {
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+		if (rk_avb_init_ab_metadata()) {
+			fastboot_tx_write_str("FAILinit ab data fail!");
+			return;
+		}
+		fastboot_tx_write_str("OKAY");
+#else
+		fastboot_tx_write_str("FAILnot implemented");
+#endif
+	} else {
 		fastboot_tx_write_str("FAILunknown oem command");
 	}
 }
@@ -641,24 +2289,29 @@ static void cb_oem(struct usb_ep *ep, struct usb_request *req)
 static void cb_erase(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
-	char response[FASTBOOT_RESPONSE_LEN];
+	char response[FASTBOOT_RESPONSE_LEN] = {0};
 
 	strsep(&cmd, ":");
 	if (!cmd) {
-		error("missing partition name");
+		pr_err("missing partition name");
 		fastboot_tx_write_str("FAILmissing partition name");
 		return;
 	}
-
-	/* initialize the response buffer */
-	fb_response_str = response;
-
-	fastboot_fail("no flash device defined");
+#ifdef CONFIG_ANDROID_AB
+	if ((strcmp(cmd, PART_USERDATA) == 0) || (strcmp(cmd, PART_METADATA) == 0)) {
+		if (should_prevent_userdata_wipe()) {
+			pr_err("virtual A/B merging, can not erase userdata or metadata!\n");
+			fastboot_tx_write_str("FAILvirtual A/B merging,abort erase!");
+			return;
+		}
+	}
+#endif
+	fastboot_fail("no flash device defined", response);
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
-	fb_mmc_erase(cmd);
+	fb_mmc_erase(cmd, response);
 #endif
 #ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
-	fb_nand_erase(cmd);
+	fb_nand_erase(cmd, response);
 #endif
 	fastboot_tx_write_str(response);
 }
@@ -679,14 +2332,24 @@ static const struct cmd_dispatch_info cmd_dispatch_info[] = {
 	}, {
 		.cmd = "download:",
 		.cb = cb_download,
+	}, {
+		.cmd = "upload",
+		.cb = cb_upload,
 	}, {
 		.cmd = "boot",
 		.cb = cb_boot,
 	}, {
 		.cmd = "continue",
 		.cb = cb_continue,
+	}, {
+		.cmd = "set_active",
+		.cb = cb_set_active,
 	},
 #ifdef CONFIG_FASTBOOT_FLASH
+	{
+		.cmd = "flashing",
+		.cb = cb_flashing,
+	},
 	{
 		.cmd = "flash",
 		.cb = cb_flash,
@@ -718,7 +2381,7 @@ static void rx_handler_command(struct usb_ep *ep, struct usb_request *req)
 	}
 
 	if (!func_cb) {
-		error("unknown command: %.*s", req->actual, cmdbuf);
+		pr_err("unknown command: %.*s", req->actual, cmdbuf);
 		fastboot_tx_write_str("FAILunknown command");
 	} else {
 		if (req->actual < req->length) {
@@ -726,7 +2389,7 @@ static void rx_handler_command(struct usb_ep *ep, struct usb_request *req)
 			buf[req->actual] = 0;
 			func_cb(ep, req);
 		} else {
-			error("buffer overflow");
+			pr_err("buffer overflow");
 			fastboot_tx_write_str("FAILbuffer overflow");
 		}
 	}
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 1ecb92ac6b..b30dfa1bcc 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -241,6 +241,7 @@
 /* #define DUMP_MSGS */
 
 #include <config.h>
+#include <hexdump.h>
 #include <malloc.h>
 #include <common.h>
 #include <console.h>
@@ -250,12 +251,14 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <usb_mass_storage.h>
+#include <rockusb.h>
 
 #include <asm/unaligned.h>
+#include <linux/bitops.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/composite.h>
-#include <usb/lin_gadget_compat.h>
+#include <linux/bitmap.h>
 #include <g_dnl.h>
 
 /*------------------------------------------------------------------------*/
@@ -283,26 +286,6 @@ static const char fsg_string_interface[] = "Mass Storage";
 struct kref {int x; };
 struct completion {int x; };
 
-inline void set_bit(int nr, volatile void *addr)
-{
-	int	mask;
-	unsigned int *a = (unsigned int *) addr;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	*a |= mask;
-}
-
-inline void clear_bit(int nr, volatile void *addr)
-{
-	int	mask;
-	unsigned int *a = (unsigned int *) addr;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	*a &= ~mask;
-}
-
 struct fsg_dev;
 struct fsg_common;
 
@@ -1670,6 +1653,9 @@ static int send_status(struct fsg_common *common)
 
 
 /*-------------------------------------------------------------------------*/
+#ifdef CONFIG_CMD_ROCKUSB
+#include "f_rockusb.c"
+#endif
 
 /* Check whether the command is properly formed and whether its data size
  * and direction agree with the values we already have. */
@@ -1744,7 +1730,7 @@ static int check_command(struct fsg_common *common, int cmnd_size,
 		    common->lun, lun);
 
 	/* Check the LUN */
-	if (common->lun >= 0 && common->lun < common->nluns) {
+	if (common->lun < common->nluns) {
 		curlun = &common->luns[common->lun];
 		if (common->cmnd[0] != SC_REQUEST_SENSE) {
 			curlun->sense_data = SS_NO_SENSE;
@@ -1795,6 +1781,7 @@ static int do_scsi_command(struct fsg_common *common)
 	int			i;
 	static char		unknown[16];
 	struct fsg_lun		*curlun = &common->luns[common->lun];
+	const char		*cdev_name __maybe_unused;
 
 	dump_cdb(common);
 
@@ -1810,6 +1797,16 @@ static int do_scsi_command(struct fsg_common *common)
 	common->short_packet_received = 0;
 
 	down_read(&common->filesem);	/* We're using the backing file */
+
+	cdev_name = common->fsg->function.config->cdev->driver->name;
+	if (IS_RKUSB_UMS_DNL(cdev_name)) {
+		rc = rkusb_cmd_process(common, bh, &reply);
+		if (rc == RKUSB_RC_FINISHED || rc == RKUSB_RC_ERROR)
+			goto finish;
+		else if (rc == RKUSB_RC_UNKNOWN_CMND)
+			goto unknown_cmnd;
+	}
+
 	switch (common->cmnd[0]) {
 
 	case SC_INQUIRY:
@@ -2038,6 +2035,8 @@ unknown_cmnd:
 		}
 		break;
 	}
+
+finish:
 	up_read(&common->filesem);
 
 	if (reply == -EINTR)
@@ -2086,7 +2085,7 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 		 * we can simply accept and discard any data received
 		 * until the next reset. */
 		wedge_bulk_in_endpoint(fsg);
-		set_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
+		generic_set_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
 		return -EINVAL;
 	}
 
@@ -2236,21 +2235,25 @@ reset:
 
 	/* Enable the endpoints */
 	d = fsg_ep_desc(common->gadget,
-			&fsg_fs_bulk_in_desc, &fsg_hs_bulk_in_desc);
+			&fsg_fs_bulk_in_desc, &fsg_hs_bulk_in_desc,
+			&fsg_ss_bulk_in_desc, &fsg_ss_bulk_in_comp_desc,
+			fsg->bulk_in);
 	rc = enable_endpoint(common, fsg->bulk_in, d);
 	if (rc)
 		goto reset;
 	fsg->bulk_in_enabled = 1;
 
 	d = fsg_ep_desc(common->gadget,
-			&fsg_fs_bulk_out_desc, &fsg_hs_bulk_out_desc);
+			&fsg_fs_bulk_out_desc, &fsg_hs_bulk_out_desc,
+			&fsg_ss_bulk_out_desc, &fsg_ss_bulk_out_comp_desc,
+			fsg->bulk_out);
 	rc = enable_endpoint(common, fsg->bulk_out, d);
 	if (rc)
 		goto reset;
 	fsg->bulk_out_enabled = 1;
 	common->bulk_out_maxpacket =
 				le16_to_cpu(get_unaligned(&d->wMaxPacketSize));
-	clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
+	generic_clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
 
 	/* Allocate the requests */
 	for (i = 0; i < FSG_NUM_BUFFERS; ++i) {
@@ -2693,7 +2696,10 @@ static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 	fsg->bulk_out = ep;
 
 	/* Copy descriptors */
-	f->descriptors = usb_copy_descriptors(fsg_fs_function);
+	if (IS_RKUSB_UMS_DNL(c->cdev->driver->name))
+		f->descriptors = usb_copy_descriptors(rkusb_fs_function);
+	else
+		f->descriptors = usb_copy_descriptors(fsg_fs_function);
 	if (unlikely(!f->descriptors))
 		return -ENOMEM;
 
@@ -2703,12 +2709,35 @@ static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 			fsg_fs_bulk_in_desc.bEndpointAddress;
 		fsg_hs_bulk_out_desc.bEndpointAddress =
 			fsg_fs_bulk_out_desc.bEndpointAddress;
-		f->hs_descriptors = usb_copy_descriptors(fsg_hs_function);
+
+		if (IS_RKUSB_UMS_DNL(c->cdev->driver->name))
+			f->hs_descriptors =
+				usb_copy_descriptors(rkusb_hs_function);
+		else
+			f->hs_descriptors =
+				usb_copy_descriptors(fsg_hs_function);
 		if (unlikely(!f->hs_descriptors)) {
 			free(f->descriptors);
 			return -ENOMEM;
 		}
 	}
+
+	if (gadget_is_superspeed(gadget)) {
+		/* Assume endpoint addresses are the same as full speed */
+		fsg_ss_bulk_in_desc.bEndpointAddress =
+			fsg_fs_bulk_in_desc.bEndpointAddress;
+		fsg_ss_bulk_out_desc.bEndpointAddress =
+			fsg_fs_bulk_out_desc.bEndpointAddress;
+
+		if (IS_RKUSB_UMS_DNL(c->cdev->driver->name))
+			f->ss_descriptors =
+				usb_copy_descriptors(rkusb_ss_function);
+
+		if (unlikely(!f->ss_descriptors)) {
+			free(f->descriptors);
+			return -ENOMEM;
+		}
+	}
 	return 0;
 
 autoconf_fail:
diff --git a/drivers/usb/gadget/f_sdp.c b/drivers/usb/gadget/f_sdp.c
index 0fae66beab..bfab01be63 100644
--- a/drivers/usb/gadget/f_sdp.c
+++ b/drivers/usb/gadget/f_sdp.c
@@ -32,6 +32,7 @@
 #include <spl.h>
 #include <image.h>
 #include <imximage.h>
+#include <watchdog.h>
 
 #define HID_REPORT_ID_MASK	0x000000ff
 
@@ -100,6 +101,7 @@ struct f_sdp {
 	enum sdp_state			state;
 	enum sdp_state			next_state;
 	u32				dnl_address;
+	u32				dnl_bytes;
 	u32				dnl_bytes_remaining;
 	u32				jmp_address;
 	bool				always_send_status;
@@ -229,6 +231,11 @@ static struct usb_gadget_strings *sdp_generic_strings[] = {
 	NULL,
 };
 
+static inline void *sdp_ptr(u32 val)
+{
+	return (void *)(uintptr_t)val;
+}
+
 static void sdp_rx_command_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_sdp *sdp = req->context;
@@ -237,12 +244,12 @@ static void sdp_rx_command_complete(struct usb_ep *ep, struct usb_request *req)
 	u8 report = data[0];
 
 	if (status != 0) {
-		error("Status: %d", status);
+		pr_err("Status: %d\n", status);
 		return;
 	}
 
 	if (report != 1) {
-		error("Unexpected report %d", report);
+		pr_err("Unexpected report %d\n", report);
 		return;
 	}
 
@@ -271,6 +278,7 @@ static void sdp_rx_command_complete(struct usb_ep *ep, struct usb_request *req)
 		sdp->state = SDP_STATE_RX_FILE_DATA;
 		sdp->dnl_address = be32_to_cpu(cmd->addr);
 		sdp->dnl_bytes_remaining = be32_to_cpu(cmd->cnt);
+		sdp->dnl_bytes = sdp->dnl_bytes_remaining;
 		sdp->next_state = SDP_STATE_IDLE;
 
 		printf("Downloading file of size %d to 0x%08x... ",
@@ -309,7 +317,7 @@ static void sdp_rx_command_complete(struct usb_ep *ep, struct usb_request *req)
 		sdp->next_state = SDP_STATE_IDLE;
 		break;
 	default:
-		error("Unknown command: %04x\n", be16_to_cpu(cmd->cmd));
+		pr_err("Unknown command: %04x\n", be16_to_cpu(cmd->cmd));
 	}
 }
 
@@ -322,12 +330,12 @@ static void sdp_rx_data_complete(struct usb_ep *ep, struct usb_request *req)
 	int datalen = req->length - 1;
 
 	if (status != 0) {
-		error("Status: %d", status);
+		pr_err("Status: %d\n", status);
 		return;
 	}
 
 	if (report != 2) {
-		error("Unexpected report %d", report);
+		pr_err("Unexpected report %d\n", report);
 		return;
 	}
 
@@ -343,13 +351,16 @@ static void sdp_rx_data_complete(struct usb_ep *ep, struct usb_request *req)
 	}
 
 	if (sdp->state == SDP_STATE_RX_FILE_DATA) {
-		memcpy((void *)sdp->dnl_address, req->buf + 1, datalen);
+		memcpy(sdp_ptr(sdp->dnl_address), req->buf + 1, datalen);
 		sdp->dnl_address += datalen;
 	}
 
 	if (sdp->dnl_bytes_remaining)
 		return;
 
+#ifndef CONFIG_SPL_BUILD
+	env_set_hex("filesize", sdp->dnl_bytes);
+#endif
 	printf("done\n");
 
 	switch (sdp->state) {
@@ -360,7 +371,7 @@ static void sdp_rx_data_complete(struct usb_ep *ep, struct usb_request *req)
 		sdp->state = SDP_STATE_TX_SEC_CONF;
 		break;
 	default:
-		error("Invalid state: %d", sdp->state);
+		pr_err("Invalid state: %d\n", sdp->state);
 	}
 }
 
@@ -370,7 +381,7 @@ static void sdp_tx_complete(struct usb_ep *ep, struct usb_request *req)
 	int status = req->status;
 
 	if (status != 0) {
-		error("Status: %d", status);
+		pr_err("Status: %d\n", status);
 		return;
 	}
 
@@ -393,7 +404,7 @@ static void sdp_tx_complete(struct usb_ep *ep, struct usb_request *req)
 			sdp->state = SDP_STATE_IDLE;
 		break;
 	default:
-		error("Wrong State: %d", sdp->state);
+		pr_err("Wrong State: %d\n", sdp->state);
 		sdp->state = SDP_STATE_IDLE;
 		break;
 	}
@@ -602,6 +613,8 @@ int sdp_init(int controller_index)
 			puts("\rCTRL+C - Operation aborted.\n");
 			return 1;
 		}
+
+		WATCHDOG_RESET();
 		usb_gadget_handle_interrupts(controller_index);
 	}
 
@@ -619,14 +632,27 @@ static u32 sdp_jump_imxheader(void *address)
 	}
 
 	printf("Jumping to 0x%08x\n", headerv2->entry);
-	entry = (void *)headerv2->entry;
+	entry = sdp_ptr(headerv2->entry);
 	entry();
 
 	/* The image probably never returns hence we won't reach that point */
 	return 0;
 }
 
-static void sdp_handle_in_ep(void)
+#ifdef CONFIG_SPL_BUILD
+#ifdef CONFIG_SPL_LOAD_FIT
+static ulong sdp_fit_read(struct spl_load_info *load, ulong sector,
+			  ulong count, void *buf)
+{
+	debug("%s: sector %lx, count %lx, buf %lx\n",
+	      __func__, sector, count, (ulong)buf);
+	memcpy(buf, (void *)(load->dev + sector), count);
+	return count;
+}
+#endif
+#endif
+
+static void sdp_handle_in_ep(struct spl_image_info *spl_image)
 {
 	u8 *data = sdp_func->in_req->buf;
 	u32 status;
@@ -662,7 +688,7 @@ static void sdp_handle_in_ep(void)
 		if (datalen > 64)
 			datalen = 64;
 
-		memcpy(&data[1], (void *)sdp_func->dnl_address, datalen);
+		memcpy(&data[1], sdp_ptr(sdp_func->dnl_address), datalen);
 		sdp_func->in_req->length = 65;
 
 		sdp_func->dnl_bytes_remaining -= datalen;
@@ -673,15 +699,30 @@ static void sdp_handle_in_ep(void)
 		break;
 	case SDP_STATE_JUMP:
 		printf("Jumping to header at 0x%08x\n", sdp_func->jmp_address);
-		status = sdp_jump_imxheader((void *)sdp_func->jmp_address);
+		status = sdp_jump_imxheader(sdp_ptr(sdp_func->jmp_address));
 
 		/* If imx header fails, try some U-Boot specific headers */
 		if (status) {
 #ifdef CONFIG_SPL_BUILD
+			image_header_t *header =
+				sdp_ptr(sdp_func->jmp_address);
+#ifdef CONFIG_SPL_LOAD_FIT
+			if (image_get_magic(header) == FDT_MAGIC) {
+				struct spl_load_info load;
+
+				debug("Found FIT\n");
+				load.dev = header;
+				load.bl_len = 1;
+				load.read = sdp_fit_read;
+				spl_load_simple_fit(spl_image, &load, 0,
+						    header);
+
+				return;
+			}
+#endif
 			/* In SPL, allow jumps to U-Boot images */
 			struct spl_image_info spl_image = {};
-			spl_parse_image_header(&spl_image,
-				(struct image_header *)sdp_func->jmp_address);
+			spl_parse_image_header(&spl_image, header);
 			jump_to_image_no_args(&spl_image);
 #else
 			/* In U-Boot, allow jumps to scripts */
@@ -703,18 +744,32 @@ static void sdp_handle_in_ep(void)
 	};
 }
 
-void sdp_handle(int controller_index)
+#ifndef CONFIG_SPL_BUILD
+int sdp_handle(int controller_index)
+#else
+int spl_sdp_handle(int controller_index, struct spl_image_info *spl_image)
+#endif
 {
 	printf("SDP: handle requests...\n");
 	while (1) {
 		if (ctrlc()) {
 			puts("\rCTRL+C - Operation aborted.\n");
-			return;
+			return -EINVAL;
 		}
 
+#ifdef CONFIG_SPL_BUILD
+		if (spl_image->flags & SPL_FIT_FOUND)
+			return 0;
+#endif
+
+		WATCHDOG_RESET();
 		usb_gadget_handle_interrupts(controller_index);
 
-		sdp_handle_in_ep();
+#ifdef CONFIG_SPL_BUILD
+		sdp_handle_in_ep(spl_image);
+#else
+		sdp_handle_in_ep(NULL);
+#endif
 	}
 }
 
diff --git a/drivers/usb/gadget/f_thor.c b/drivers/usb/gadget/f_thor.c
index cd4d9e659a..57110b7041 100644
--- a/drivers/usb/gadget/f_thor.c
+++ b/drivers/usb/gadget/f_thor.c
@@ -48,7 +48,7 @@ DEFINE_CACHE_ALIGN_BUFFER(unsigned char, thor_rx_data_buf,
 /* ********************************************************** */
 /*         THOR protocol - transmission handling	      */
 /* ********************************************************** */
-DEFINE_CACHE_ALIGN_BUFFER(char, f_name, F_NAME_BUF_SIZE);
+DEFINE_CACHE_ALIGN_BUFFER(char, f_name, F_NAME_BUF_SIZE + 1);
 static unsigned long long int thor_file_size;
 static int alt_setting_num;
 
@@ -174,7 +174,7 @@ static long long int download_head(unsigned long long total,
 					transfer_buffer, THOR_STORE_UNIT_SIZE,
 					(*cnt)++);
 			if (ret) {
-				error("DFU write failed [%d] cnt: %d",
+				pr_err("DFU write failed [%d] cnt: %d",
 				      ret, *cnt);
 				return ret;
 			}
@@ -218,20 +218,20 @@ static int download_tail(long long int left, int cnt)
 
 	dfu_entity = dfu_get_entity(alt_setting_num);
 	if (!dfu_entity) {
-		error("Alt setting: %d entity not found!\n", alt_setting_num);
+		pr_err("Alt setting: %d entity not found!\n", alt_setting_num);
 		return -ENOENT;
 	}
 
 	transfer_buffer = dfu_get_buf(dfu_entity);
 	if (!transfer_buffer) {
-		error("Transfer buffer not allocated!");
+		pr_err("Transfer buffer not allocated!");
 		return -ENXIO;
 	}
 
 	if (left) {
 		ret = dfu_write(dfu_entity, transfer_buffer, left, cnt++);
 		if (ret) {
-			error("DFU write failed [%d]: left: %llu", ret, left);
+			pr_err("DFU write failed [%d]: left: %llu", ret, left);
 			return ret;
 		}
 	}
@@ -245,7 +245,7 @@ static int download_tail(long long int left, int cnt)
 	 */
 	ret = dfu_flush(dfu_entity, transfer_buffer, 0, cnt);
 	if (ret)
-		error("DFU flush failed!");
+		pr_err("DFU flush failed!");
 
 	return ret;
 }
@@ -263,8 +263,10 @@ static long long int process_rqt_download(const struct rqt_box *rqt)
 
 	switch (rqt->rqt_data) {
 	case RQT_DL_INIT:
-		thor_file_size = rqt->int_data[0];
-		debug("INIT: total %d bytes\n", rqt->int_data[0]);
+		thor_file_size = (unsigned long long int)rqt->int_data[0] +
+				 (((unsigned long long int)rqt->int_data[1])
+				  << 32);
+		debug("INIT: total %llu bytes\n", thor_file_size);
 		break;
 	case RQT_DL_FILE_INFO:
 		file_type = rqt->int_data[0];
@@ -275,8 +277,11 @@ static long long int process_rqt_download(const struct rqt_box *rqt)
 			break;
 		}
 
-		thor_file_size = rqt->int_data[1];
+		thor_file_size = (unsigned long long int)rqt->int_data[1] +
+				 (((unsigned long long int)rqt->int_data[2])
+				  << 32);
 		memcpy(f_name, rqt->str_data[0], F_NAME_BUF_SIZE);
+		f_name[F_NAME_BUF_SIZE] = '\0';
 
 		debug("INFO: name(%s, %d), size(%llu), type(%d)\n",
 		      f_name, 0, thor_file_size, file_type);
@@ -285,7 +290,7 @@ static long long int process_rqt_download(const struct rqt_box *rqt)
 
 		alt_setting_num = dfu_get_alt(f_name);
 		if (alt_setting_num < 0) {
-			error("Alt setting [%d] to write not found!",
+			pr_err("Alt setting [%d] to write not found!",
 			      alt_setting_num);
 			rsp->ack = -ENODEV;
 			ret = rsp->ack;
@@ -311,7 +316,7 @@ static long long int process_rqt_download(const struct rqt_box *rqt)
 		debug("DL EXIT\n");
 		break;
 	default:
-		error("Operation not supported: %d", rqt->rqt_data);
+		pr_err("Operation not supported: %d", rqt->rqt_data);
 		ret = -ENOTSUPP;
 	}
 
@@ -342,7 +347,7 @@ static int process_data(void)
 		puts("RQT: UPLOAD not supported!\n");
 		break;
 	default:
-		error("unknown request (%d)", rqt->rqt);
+		pr_err("unknown request (%d)", rqt->rqt);
 	}
 
 	return ret;
@@ -541,7 +546,7 @@ static int thor_rx_data(void)
 
 		status = usb_ep_queue(dev->out_ep, dev->out_req, 0);
 		if (status) {
-			error("kill %s:  resubmit %d bytes --> %d",
+			pr_err("kill %s:  resubmit %d bytes --> %d",
 			      dev->out_ep->name, dev->out_req->length, status);
 			usb_ep_set_halt(dev->out_ep);
 			return -EAGAIN;
@@ -575,7 +580,7 @@ static void thor_tx_data(unsigned char *data, int len)
 
 	status = usb_ep_queue(dev->in_ep, dev->in_req, 0);
 	if (status) {
-		error("kill %s:  resubmit %d bytes --> %d",
+		pr_err("kill %s:  resubmit %d bytes --> %d",
 		      dev->in_ep->name, dev->in_req->length, status);
 		usb_ep_set_halt(dev->in_ep);
 	}
@@ -608,7 +613,7 @@ static void thor_rx_tx_complete(struct usb_ep *ep, struct usb_request *req)
 	case -ESHUTDOWN:		/* disconnect from host */
 	case -EREMOTEIO:                /* short read */
 	case -EOVERFLOW:
-		error("ERROR:%d", status);
+		pr_err("ERROR:%d", status);
 		break;
 	}
 
@@ -616,22 +621,6 @@ static void thor_rx_tx_complete(struct usb_ep *ep, struct usb_request *req)
 	      status, req->actual, req->length);
 }
 
-static struct usb_request *thor_start_ep(struct usb_ep *ep)
-{
-	struct usb_request *req;
-
-	req = alloc_ep_req(ep, THOR_PACKET_SIZE);
-	debug("%s: ep:%p req:%p\n", __func__, ep, req);
-
-	if (!req)
-		return NULL;
-
-	memset(req->buf, 0, req->length);
-	req->complete = thor_rx_tx_complete;
-
-	return req;
-}
-
 static void thor_setup_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	if (req->status || req->actual != req->length)
@@ -664,7 +653,7 @@ thor_func_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
 		break;
 
 	default:
-		error("thor_setup: unknown request: %d", ctrl->bRequest);
+		pr_err("thor_setup: unknown request: %d", ctrl->bRequest);
 	}
 
 	if (value >= 0) {
@@ -748,6 +737,13 @@ int thor_handle(void)
 	return 0;
 }
 
+static void free_ep_req(struct usb_ep *ep, struct usb_request *req)
+{
+	if (req->buf)
+		free(req->buf);
+	usb_ep_free_request(ep, req);
+}
+
 static int thor_func_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_gadget *gadget = c->cdev->gadget;
@@ -856,21 +852,18 @@ static int thor_func_bind(struct usb_configuration *c, struct usb_function *f)
 	return 0;
 
  fail:
+	if (dev->req)
+		free_ep_req(gadget->ep0, dev->req);
 	free(dev);
 	return status;
 }
 
-static void free_ep_req(struct usb_ep *ep, struct usb_request *req)
-{
-	free(req->buf);
-	usb_ep_free_request(ep, req);
-}
-
 static void thor_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_thor *f_thor = func_to_thor(f);
 	struct thor_dev *dev = f_thor->dev;
 
+	free_ep_req(dev->gadget->ep0, dev->req);
 	free(dev);
 	memset(thor_func, 0, sizeof(*thor_func));
 	thor_func = NULL;
@@ -885,16 +878,14 @@ static void thor_func_disable(struct usb_function *f)
 
 	/* Avoid freeing memory when ep is still claimed */
 	if (dev->in_ep->driver_data) {
-		free_ep_req(dev->in_ep, dev->in_req);
 		usb_ep_disable(dev->in_ep);
+		free_ep_req(dev->in_ep, dev->in_req);
 		dev->in_ep->driver_data = NULL;
 	}
 
 	if (dev->out_ep->driver_data) {
-		free(dev->out_req->buf);
-		dev->out_req->buf = NULL;
-		usb_ep_free_request(dev->out_ep, dev->out_req);
 		usb_ep_disable(dev->out_ep);
+		usb_ep_free_request(dev->out_ep, dev->out_req);
 		dev->out_ep->driver_data = NULL;
 	}
 
@@ -920,16 +911,17 @@ static int thor_eps_setup(struct usb_function *f)
 
 	result = usb_ep_enable(ep, d);
 	if (result)
-		goto exit;
+		goto err;
 
 	ep->driver_data = cdev; /* claim */
-	req = thor_start_ep(ep);
+	req = alloc_ep_req(ep, THOR_PACKET_SIZE);
 	if (!req) {
-		usb_ep_disable(ep);
 		result = -EIO;
-		goto exit;
+		goto err_disable_in_ep;
 	}
 
+	memset(req->buf, 0, req->length);
+	req->complete = thor_rx_tx_complete;
 	dev->in_req = req;
 	ep = dev->out_ep;
 	d = ep_desc(gadget, &hs_out_desc, &fs_out_desc);
@@ -937,22 +929,41 @@ static int thor_eps_setup(struct usb_function *f)
 
 	result = usb_ep_enable(ep, d);
 	if (result)
-		goto exit;
+		goto err_free_in_req;
 
 	ep->driver_data = cdev; /* claim */
-	req = thor_start_ep(ep);
+	req = usb_ep_alloc_request(ep, 0);
 	if (!req) {
-		usb_ep_disable(ep);
 		result = -EIO;
-		goto exit;
+		goto err_disable_out_ep;
 	}
 
+	req->complete = thor_rx_tx_complete;
 	dev->out_req = req;
 	/* ACM control EP */
 	ep = dev->int_ep;
+	d = ep_desc(gadget, &hs_int_desc, &fs_int_desc);
+	debug("(d)bEndpointAddress: 0x%x\n", d->bEndpointAddress);
+
+	result = usb_ep_enable(ep, d);
+	if (result)
+		goto err;
+
 	ep->driver_data = cdev;	/* claim */
 
- exit:
+	return 0;
+
+ err_disable_out_ep:
+	usb_ep_disable(dev->out_ep);
+
+ err_free_in_req:
+	free_ep_req(dev->in_ep, dev->in_req);
+	dev->in_req = NULL;
+
+ err_disable_in_ep:
+	usb_ep_disable(dev->in_ep);
+
+ err:
 	return result;
 }
 
@@ -973,7 +984,7 @@ static int thor_func_set_alt(struct usb_function *f,
 		debug("Communication Data interface\n");
 		result = thor_eps_setup(f);
 		if (result)
-			error("%s: EPs setup failed!", __func__);
+			pr_err("%s: EPs setup failed!", __func__);
 		dev->configuration_done = 1;
 		break;
 	}
diff --git a/drivers/usb/gadget/f_thor.h b/drivers/usb/gadget/f_thor.h
index 83412851dd..7820788a14 100644
--- a/drivers/usb/gadget/f_thor.h
+++ b/drivers/usb/gadget/f_thor.h
@@ -35,7 +35,7 @@ struct usb_cdc_attribute_vendor_descriptor {
 	__u8 DAUValue;
 } __packed;
 
-#define VER_PROTOCOL_MAJOR	4
+#define VER_PROTOCOL_MAJOR	5
 #define VER_PROTOCOL_MINOR	0
 
 enum rqt {
diff --git a/drivers/usb/gadget/g_dnl.c b/drivers/usb/gadget/g_dnl.c
index 039331a5af..400b016049 100644
--- a/drivers/usb/gadget/g_dnl.c
+++ b/drivers/usb/gadget/g_dnl.c
@@ -26,9 +26,9 @@
 
 /*
  * One needs to define the following:
- * CONFIG_G_DNL_VENDOR_NUM
- * CONFIG_G_DNL_PRODUCT_NUM
- * CONFIG_G_DNL_MANUFACTURER
+ * CONFIG_USB_GADGET_VENDOR_NUM
+ * CONFIG_USB_GADGET_PRODUCT_NUM
+ * CONFIG_USB_GADGET_MANUFACTURER
  * at e.g. ./configs/<board>_defconfig
  */
 
@@ -46,12 +46,13 @@
 
 static const char product[] = "USB download gadget";
 static char g_dnl_serial[MAX_STRING_SERIAL];
-static const char manufacturer[] = CONFIG_G_DNL_MANUFACTURER;
+static const char manufacturer[] = CONFIG_USB_GADGET_MANUFACTURER;
 
 void g_dnl_set_serialnumber(char *s)
 {
 	memset(g_dnl_serial, 0, MAX_STRING_SERIAL);
-	strncpy(g_dnl_serial, s, MAX_STRING_SERIAL - 1);
+	if (s)
+		strncpy(g_dnl_serial, s, MAX_STRING_SERIAL - 1);
 }
 
 static struct usb_device_descriptor device_desc = {
@@ -62,8 +63,8 @@ static struct usb_device_descriptor device_desc = {
 	.bDeviceClass = USB_CLASS_PER_INTERFACE,
 	.bDeviceSubClass = 0, /*0x02:CDC-modem , 0x00:CDC-serial*/
 
-	.idVendor = __constant_cpu_to_le16(CONFIG_G_DNL_VENDOR_NUM),
-	.idProduct = __constant_cpu_to_le16(CONFIG_G_DNL_PRODUCT_NUM),
+	.idVendor = __constant_cpu_to_le16(CONFIG_USB_GADGET_VENDOR_NUM),
+	.idProduct = __constant_cpu_to_le16(CONFIG_USB_GADGET_PRODUCT_NUM),
 	/* .iProduct = DYNAMIC */
 	/* .iSerialNumber = DYNAMIC */
 	.bNumConfigurations = 1,
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index f320708431..91b0285244 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -149,13 +149,11 @@
 #define gadget_is_dwc3(g)        0
 #endif
 
-
-
-/*
- * CONFIG_USB_GADGET_SX2
- * CONFIG_USB_GADGET_AU1X00
- * ...
- */
+#ifdef CONFIG_USB_CDNS3_GADGET
+#define gadget_is_cdns3(g)        (!strcmp("cdns3-gadget", (g)->name))
+#else
+#define gadget_is_cdns3(g)        0
+#endif
 
 /**
  * usb_gadget_controller_number - support bcdDevice id convention
@@ -214,5 +212,9 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x21;
 	else if (gadget_is_fotg210(gadget))
 		return 0x22;
+	else if (gadget_is_dwc3(gadget))
+		return 0x23;
+	else if (gadget_is_cdns3(gadget))
+		return 0x24;
 	return -ENOENT;
 }
diff --git a/drivers/usb/gadget/pxa25x_udc.c b/drivers/usb/gadget/pxa25x_udc.c
index 6a8949da34..fb29d82a9c 100644
--- a/drivers/usb/gadget/pxa25x_udc.c
+++ b/drivers/usb/gadget/pxa25x_udc.c
@@ -30,7 +30,6 @@
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
-#include <usb/lin_gadget_compat.h>
 #include <asm/arch/pxa-regs.h>
 
 #include "pxa25x_udc.h"
diff --git a/drivers/usb/gadget/storage_common.c b/drivers/usb/gadget/storage_common.c
index b6df130a14..c85a86cd2d 100644
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -125,7 +125,7 @@
 # define dump_msg(fsg, label, buf, length) do {                         \
 	if (length < 512) {						\
 		DBG(fsg, "%s, length %u:\n", label, length);		\
-		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET,	\
+		print_hex_dump("", DUMP_PREFIX_OFFSET,	\
 			       16, 1, buf, length, 0);			\
 	}								\
 } while (0)
@@ -140,7 +140,7 @@
 #  ifdef VERBOSE_DEBUG
 
 #    define dump_cdb(fsg)						\
-	print_hex_dump(KERN_DEBUG, "SCSI CDB: ", DUMP_PREFIX_NONE,	\
+	print_hex_dump("SCSI CDB: ", DUMP_PREFIX_NONE,	\
 		       16, 1, (fsg)->cmnd, (fsg)->cmnd_size, 0)		\
 
 #  else
@@ -309,7 +309,7 @@ static struct fsg_lun *fsg_lun_from_dev(struct device *dev)
 #define FSG_NUM_BUFFERS	2
 
 /* Default size of buffer length. */
-#define FSG_BUFLEN	((u32)16384)
+#define FSG_BUFLEN	((u32)262144)
 
 /* Maximal number of LUNs supported in mass storage function */
 #define FSG_MAX_LUNS	8
@@ -530,14 +530,76 @@ static struct usb_descriptor_header *fsg_hs_function[] = {
 	NULL,
 };
 
+static struct usb_endpoint_descriptor
+fsg_ss_bulk_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor
+fsg_ss_bulk_in_comp_desc = {
+	.bLength		= sizeof(fsg_ss_bulk_in_comp_desc),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* .bMaxBurst		= DYNAMIC, */
+};
+
+static struct usb_endpoint_descriptor
+fsg_ss_bulk_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor
+fsg_ss_bulk_out_comp_desc = {
+	.bLength		= sizeof(fsg_ss_bulk_out_comp_desc),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* .bMaxBurst		= DYNAMIC, */
+};
+
 /* Maxpacket and other transfer characteristics vary by speed. */
 static struct usb_endpoint_descriptor *
 fsg_ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
-		struct usb_endpoint_descriptor *hs)
+	    struct usb_endpoint_descriptor *hs,
+	    struct usb_endpoint_descriptor *ss,
+	    struct usb_ss_ep_comp_descriptor *comp_desc,
+	    struct usb_ep *ep)
 {
-	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
-		return hs;
-	return fs;
+	struct usb_endpoint_descriptor *speed_desc = NULL;
+
+	/* select desired speed */
+	switch (g->speed) {
+	case USB_SPEED_SUPER:
+		if (gadget_is_superspeed(g)) {
+			speed_desc = ss;
+			ep->comp_desc = comp_desc;
+			break;
+		}
+		/* else: Fall trough */
+	case USB_SPEED_HIGH:
+		if (gadget_is_dualspeed(g)) {
+			speed_desc = hs;
+			break;
+		}
+		/* else: fall through */
+	default:
+		speed_desc = fs;
+	}
+
+	/*
+	 * Config the ep maxpacket according to the right descriptors
+	 * for a given endpoint.
+	 */
+	ep->maxpacket = usb_endpoint_maxp(speed_desc) & USB_ENDPOINT_MAXP_MASK;
+
+	return speed_desc;
 }
 
 /* Static strings, in UTF-8 (for simplicity we use only ASCII characters) */
diff --git a/drivers/usb/gadget/udc/Makefile b/drivers/usb/gadget/udc/Makefile
index 1699ccdf94..edecf2658e 100644
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -4,4 +4,9 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+ifndef CONFIG_$(SPL_)DM_USB_GADGET
 obj-$(CONFIG_USB_DWC3_GADGET)	+= udc-core.o
+endif
+
+obj-$(CONFIG_$(SPL_)DM_USB_GADGET)	+= udc-core.o
+obj-$(CONFIG_$(SPL_)DM) += udc-uclass.o
diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c
index 326757b547..83744c1542 100644
--- a/drivers/usb/gadget/udc/udc-core.c
+++ b/drivers/usb/gadget/udc/udc-core.c
@@ -19,7 +19,8 @@
 #include <asm/cache.h>
 #include <asm/dma-mapping.h>
 #include <common.h>
-
+#include <dm.h>
+#include <dm/device-internal.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
@@ -267,6 +268,27 @@ EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
 
 /* ------------------------------------------------------------------------- */
 
+/**
+ * usb_gadget_udc_set_speed - tells usb device controller speed supported by
+ *    current driver
+ * @udc: The device we want to set maximum speed
+ * @speed: The maximum speed to allowed to run
+ *
+ * This call is issued by the UDC Class driver before calling
+ * usb_gadget_udc_start() in order to make sure that we don't try to
+ * connect on speeds the gadget driver doesn't support.
+ */
+static inline void usb_gadget_udc_set_speed(struct usb_udc *udc,
+					    enum usb_device_speed speed)
+{
+	if (udc->gadget->ops->udc_set_speed) {
+		enum usb_device_speed s;
+
+		s = min(speed, udc->gadget->max_speed);
+		udc->gadget->ops->udc_set_speed(udc->gadget, s);
+	}
+}
+
 static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)
 {
 	int ret;
@@ -276,6 +298,8 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 
 	udc->driver = driver;
 
+	usb_gadget_udc_set_speed(udc, driver->speed);
+
 	ret = driver->bind(udc->gadget);
 	if (ret)
 		goto err1;
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index eb035a476b..ec633f8398 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -21,6 +21,14 @@ config USB_XHCI_DWC3
 	  Say Y or if your system has a Dual Role SuperSpeed
 	  USB controller based on the DesignWare USB3 IP Core.
 
+config USB_XHCI_DWC3_OF_SIMPLE
+	bool "DesignWare USB3 DRD Generic OF Simple Glue Layer"
+	depends on DM_USB
+	default y if DRA7XX
+	help
+	  Support USB2/3 functionality in simple SoC integrations with
+	  USB controller based on the DesignWare USB3 IP Core.
+
 config USB_XHCI_MVEBU
 	bool "MVEBU USB 3.0 support"
 	default y
@@ -38,20 +46,13 @@ config USB_XHCI_PCI
 	help
 	  Enables support for the PCI-based xHCI controller.
 
-config USB_XHCI_ROCKCHIP
-	bool "Support for Rockchip on-chip xHCI USB controller"
-	depends on ARCH_ROCKCHIP
-	depends on DM_REGULATOR
-	depends on DM_USB
+config USB_XHCI_RCAR
+	bool "Renesas RCar USB 3.0 support"
 	default y
+	depends on ARCH_RMOBILE
 	help
-	  Enables support for the on-chip xHCI controller on Rockchip SoCs.
-
-config USB_XHCI_ZYNQMP
-	bool "Support for Xilinx ZynqMP on-chip xHCI USB controller"
-	depends on ARCH_ZYNQMP
-	help
-	  Enables support for the on-chip xHCI controller on Xilinx ZynqMP SoCs.
+	  Choose this option to add support for USB 3.0 driver on Renesas
+	  RCar Gen3 SoCs.
 
 config USB_XHCI_DRA7XX_INDEX
 	int "DRA7XX xHCI USB index"
@@ -101,8 +102,8 @@ config USB_EHCI_MARVELL
 	  Enables support for the on-chip EHCI controller on MVEBU SoCs.
 
 config USB_EHCI_MX6
-	bool "Support for i.MX6 on-chip EHCI USB controller"
-	depends on ARCH_MX6
+	bool "Support for i.MX6/i.MX7ULP on-chip EHCI USB controller"
+	depends on ARCH_MX6 || ARCH_MX7ULP
 	default y
 	---help---
 	  Enables support for the on-chip EHCI controller on i.MX6 SoCs.
@@ -122,7 +123,14 @@ config USB_EHCI_OMAP
 	  Enables support for the on-chip EHCI controller on OMAP3 and later
 	  SoCs.
 
-if USB_EHCI_MX7
+config USB_EHCI_VF
+	bool "Support for Vybrid on-chip EHCI USB controller"
+	depends on ARCH_VF610
+	default y
+	help
+	  Enables support for the on-chip EHCI controller on Vybrid SoCs.
+
+if USB_EHCI_MX6 || USB_EHCI_MX7
 
 config MXC_USB_OTG_HACTIVE
 	bool "USB Power pin high active"
@@ -148,14 +156,6 @@ config USB_EHCI_PCI
 	help
 	  Enables support for the PCI-based EHCI controller.
 
-config USB_EHCI_RCAR_GEN3
-	bool "Support for Renesas RCar M3/H3 EHCI USB controller"
-	depends on RCAR_GEN3
-	default y
-	---help---
-	  Enables support for the on-chip EHCI controller on Renesas
-	  R8A7795 and R8A7796 SoCs.
-
 config USB_EHCI_ZYNQ
 	bool "Support for Xilinx Zynq on-chip EHCI USB controller"
 	depends on ARCH_ZYNQ
@@ -185,6 +185,13 @@ config USB_OHCI_HCD
 	  based system where you're not sure, the "lspci -v" entry will list the
 	  right "prog-if" for your USB controller(s):  EHCI, OHCI, or UHCI.
 
+config USB_OHCI_PCI
+	bool "Support for PCI-based OHCI USB controller"
+	depends on DM_USB
+	default n
+	help
+	  Enables support for the PCI-based OHCI controller.
+
 if USB_OHCI_HCD
 
 config USB_OHCI_GENERIC
@@ -195,6 +202,11 @@ config USB_OHCI_GENERIC
 	---help---
 	  Enables support for generic OHCI controller.
 
+config USB_OHCI_DA8XX
+	bool "Support for da850 OHCI USB controller"
+	help
+	  Enable support for the da850 USB controller.
+
 endif # USB_OHCI_HCD
 
 config USB_UHCI_HCD
@@ -224,3 +236,24 @@ config USB_DWC2
 	  Hi-Speed (480 Mbps), Full-Speed (12 Mbps), and Low-Speed (1.5 Mbps)
 	  operation is compliant to the controller Supplement. If you want to
 	  enable this controller in host mode, say Y.
+
+if USB_DWC2
+config USB_DWC2_BUFFER_SIZE
+	int "Data buffer size in kB"
+	default 64
+	---help---
+	  By default 64 kB buffer is used but if amount of RAM avaialble on
+	  the target is not enough to accommodate allocation of buffer of
+	  that size it is possible to shrink it. Smaller sizes should be fine
+	  because larger transactions could be split in smaller ones.
+
+endif # USB_DWC2
+
+config USB_R8A66597_HCD
+	bool "Renesas R8A66597 USB Core support"
+	depends on OF_CONTROL
+	depends on DM_USB
+	select USB_HOST
+	---help---
+	  This enables support for the on-chip Renesas R8A66597 USB 2.0
+	  controller, present in various RZ and SH SoCs.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index ab5a99faa8..a9e03333d0 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -5,8 +5,8 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-ifdef CONFIG_DM_USB
-obj-$(CONFIG_CMD_USB) += usb-uclass.o
+ifdef CONFIG_$(SPL_)DM_USB
+obj-y += usb-uclass.o
 obj-$(CONFIG_SANDBOX) += usb-sandbox.o
 endif
 
@@ -14,12 +14,11 @@ endif
 obj-$(CONFIG_USB_OHCI_NEW) += ohci-hcd.o
 obj-$(CONFIG_USB_ATMEL) += ohci-at91.o
 obj-$(CONFIG_USB_OHCI_DA8XX) += ohci-da8xx.o
-obj-$(CONFIG_USB_ISP116X_HCD) += isp116x-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD) += r8a66597-hcd.o
 obj-$(CONFIG_USB_SL811HS) += sl811-hcd.o
 obj-$(CONFIG_USB_OHCI_EP93XX) += ohci-ep93xx.o
-obj-$(CONFIG_USB_OHCI_SUNXI) += ohci-sunxi.o
 obj-$(CONFIG_USB_OHCI_LPC32XX) += ohci-lpc32xx.o
+obj-$(CONFIG_USB_OHCI_PCI) += ohci-pci.o
 obj-$(CONFIG_USB_OHCI_GENERIC) += ohci-generic.o
 
 # echi
@@ -36,30 +35,26 @@ obj-$(CONFIG_USB_EHCI_MX5) += ehci-mx5.o
 obj-$(CONFIG_USB_EHCI_MX6) += ehci-mx6.o
 obj-$(CONFIG_USB_EHCI_MX7) += ehci-mx6.o
 obj-$(CONFIG_USB_EHCI_OMAP) += ehci-omap.o
-obj-$(CONFIG_USB_EHCI_PPC4XX) += ehci-ppc4xx.o
 obj-$(CONFIG_USB_EHCI_MARVELL) += ehci-marvell.o
 obj-$(CONFIG_USB_EHCI_MSM) += ehci-msm.o
 obj-$(CONFIG_USB_EHCI_PCI) += ehci-pci.o
 obj-$(CONFIG_USB_EHCI_SPEAR) += ehci-spear.o
-obj-$(CONFIG_USB_EHCI_SUNXI) += ehci-sunxi.o
 obj-$(CONFIG_USB_EHCI_TEGRA) += ehci-tegra.o
 obj-$(CONFIG_USB_EHCI_VCT) += ehci-vct.o
 obj-$(CONFIG_USB_EHCI_VF) += ehci-vf.o
 obj-$(CONFIG_USB_EHCI_RMOBILE) += ehci-rmobile.o
-obj-$(CONFIG_USB_EHCI_RCAR_GEN3) += ehci-rcar_gen3.o
 obj-$(CONFIG_USB_EHCI_ZYNQ) += ehci-zynq.o
 
 # xhci
 obj-$(CONFIG_USB_XHCI_HCD) += xhci.o xhci-mem.o xhci-ring.o
 obj-$(CONFIG_USB_XHCI_DWC3) += xhci-dwc3.o
-obj-$(CONFIG_USB_XHCI_ROCKCHIP) += xhci-rockchip.o
-obj-$(CONFIG_USB_XHCI_ZYNQMP) += xhci-zynqmp.o
-obj-$(CONFIG_USB_XHCI_KEYSTONE) += xhci-keystone.o
+obj-$(CONFIG_USB_XHCI_DWC3_OF_SIMPLE) += dwc3-of-simple.o
 obj-$(CONFIG_USB_XHCI_EXYNOS) += xhci-exynos5.o
 obj-$(CONFIG_USB_XHCI_FSL) += xhci-fsl.o
 obj-$(CONFIG_USB_XHCI_MVEBU) += xhci-mvebu.o
 obj-$(CONFIG_USB_XHCI_OMAP) += xhci-omap.o
 obj-$(CONFIG_USB_XHCI_PCI) += xhci-pci.o
+obj-$(CONFIG_USB_XHCI_RCAR) += xhci-rcar.o
 
 # designware
 obj-$(CONFIG_USB_DWC2) += dwc2.o
diff --git a/drivers/usb/host/dwc2.c b/drivers/usb/host/dwc2.c
index 64c42ac471..9a28821014 100644
--- a/drivers/usb/host/dwc2.c
+++ b/drivers/usb/host/dwc2.c
@@ -16,6 +16,7 @@
 #include <wait_bit.h>
 #include <asm/io.h>
 #include <power/regulator.h>
+#include <reset.h>
 
 #include "dwc2.h"
 
@@ -25,15 +26,18 @@ DECLARE_GLOBAL_DATA_PTR;
 #define DWC2_HC_CHANNEL			0
 
 #define DWC2_STATUS_BUF_SIZE		64
-#define DWC2_DATA_BUF_SIZE		(64 * 1024)
+#define DWC2_DATA_BUF_SIZE		(CONFIG_USB_DWC2_BUFFER_SIZE * 1024)
 
 #define MAX_DEVICE			16
 #define MAX_ENDPOINT			16
 
 struct dwc2_priv {
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	uint8_t aligned_buffer[DWC2_DATA_BUF_SIZE] __aligned(ARCH_DMA_MINALIGN);
 	uint8_t status_buffer[DWC2_STATUS_BUF_SIZE] __aligned(ARCH_DMA_MINALIGN);
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *vbus_supply;
+#endif
 #else
 	uint8_t *aligned_buffer;
 	uint8_t *status_buffer;
@@ -49,9 +53,11 @@ struct dwc2_priv {
 	 */
 	bool hnp_srp_disable;
 	bool oc_disable;
+
+	struct reset_ctl_bulk	resets;
 };
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 /* We need cacheline-aligned buffers for DMA transfers and dcache support */
 DEFINE_ALIGN_BUFFER(uint8_t, aligned_buffer_addr, DWC2_DATA_BUF_SIZE,
 		ARCH_DMA_MINALIGN);
@@ -108,10 +114,10 @@ static void dwc_otg_flush_tx_fifo(struct dwc2_core_regs *regs, const int num)
 
 	writel(DWC2_GRSTCTL_TXFFLSH | (num << DWC2_GRSTCTL_TXFNUM_OFFSET),
 	       &regs->grstctl);
-	ret = wait_for_bit(__func__, &regs->grstctl, DWC2_GRSTCTL_TXFFLSH,
-			   false, 1000, false);
+	ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_TXFFLSH,
+				false, 1000, false);
 	if (ret)
-		printf("%s: Timeout!\n", __func__);
+		dev_info(dev, "%s: Timeout!\n", __func__);
 
 	/* Wait for 3 PHY Clocks */
 	udelay(1);
@@ -127,10 +133,10 @@ static void dwc_otg_flush_rx_fifo(struct dwc2_core_regs *regs)
 	int ret;
 
 	writel(DWC2_GRSTCTL_RXFFLSH, &regs->grstctl);
-	ret = wait_for_bit(__func__, &regs->grstctl, DWC2_GRSTCTL_RXFFLSH,
-			   false, 1000, false);
+	ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_RXFFLSH,
+				false, 1000, false);
 	if (ret)
-		printf("%s: Timeout!\n", __func__);
+		dev_info(dev, "%s: Timeout!\n", __func__);
 
 	/* Wait for 3 PHY Clocks */
 	udelay(1);
@@ -145,17 +151,17 @@ static void dwc_otg_core_reset(struct dwc2_core_regs *regs)
 	int ret;
 
 	/* Wait for AHB master IDLE state. */
-	ret = wait_for_bit(__func__, &regs->grstctl, DWC2_GRSTCTL_AHBIDLE,
-			   true, 1000, false);
+	ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_AHBIDLE,
+				true, 1000, false);
 	if (ret)
-		printf("%s: Timeout!\n", __func__);
+		dev_info(dev, "%s: Timeout!\n", __func__);
 
 	/* Core Soft Reset */
 	writel(DWC2_GRSTCTL_CSFTRST, &regs->grstctl);
-	ret = wait_for_bit(__func__, &regs->grstctl, DWC2_GRSTCTL_CSFTRST,
-			   false, 1000, false);
+	ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_CSFTRST,
+				false, 1000, false);
 	if (ret)
-		printf("%s: Timeout!\n", __func__);
+		dev_info(dev, "%s: Timeout!\n", __func__);
 
 	/*
 	 * Wait for core to come out of reset.
@@ -165,31 +171,55 @@ static void dwc_otg_core_reset(struct dwc2_core_regs *regs)
 	mdelay(100);
 }
 
-#if defined(CONFIG_DM_USB) && defined(CONFIG_DM_REGULATOR)
+#if CONFIG_IS_ENABLED(DM_USB) && defined(CONFIG_DM_REGULATOR)
 static int dwc_vbus_supply_init(struct udevice *dev)
 {
-	struct udevice *vbus_supply;
+	struct dwc2_priv *priv = dev_get_priv(dev);
 	int ret;
 
-	ret = device_get_supply_regulator(dev, "vbus-supply", &vbus_supply);
+	ret = device_get_supply_regulator(dev, "vbus-supply",
+					  &priv->vbus_supply);
 	if (ret) {
 		debug("%s: No vbus supply\n", dev->name);
 		return 0;
 	}
 
-	ret = regulator_set_enable(vbus_supply, true);
+	ret = regulator_set_enable(priv->vbus_supply, true);
 	if (ret) {
-		error("Error enabling vbus supply\n");
+		dev_err(dev, "Error enabling vbus supply\n");
 		return ret;
 	}
 
 	return 0;
 }
+
+static int dwc_vbus_supply_exit(struct udevice *dev)
+{
+	struct dwc2_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	if (priv->vbus_supply) {
+		ret = regulator_set_enable(priv->vbus_supply, false);
+		if (ret) {
+			dev_err(dev, "Error disabling vbus supply\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
 #else
 static int dwc_vbus_supply_init(struct udevice *dev)
 {
 	return 0;
 }
+
+#if CONFIG_IS_ENABLED(DM_USB)
+static int dwc_vbus_supply_exit(struct udevice *dev)
+{
+	return 0;
+}
+#endif
 #endif
 
 /*
@@ -267,10 +297,10 @@ static void dwc_otg_core_host_init(struct udevice *dev,
 		clrsetbits_le32(&regs->hc_regs[i].hcchar,
 				DWC2_HCCHAR_EPDIR,
 				DWC2_HCCHAR_CHEN | DWC2_HCCHAR_CHDIS);
-		ret = wait_for_bit(__func__, &regs->hc_regs[i].hcchar,
-				   DWC2_HCCHAR_CHEN, false, 1000, false);
+		ret = wait_for_bit_le32(&regs->hc_regs[i].hcchar,
+					DWC2_HCCHAR_CHEN, false, 1000, false);
 		if (ret)
-			printf("%s: Timeout!\n", __func__);
+			dev_info("%s: Timeout!\n", __func__);
 	}
 
 	/* Turn on the vbus power. */
@@ -375,7 +405,7 @@ static void dwc_otg_core_init(struct dwc2_priv *priv)
 		usbcfg &= ~DWC2_GUSBCFG_DDRSEL;
 #endif
 	} else {	/* UTMI+ interface */
-#if (CONFIG_DWC2_UTMI_PHY_WIDTH == 16)
+#if (CONFIG_DWC2_UTMI_WIDTH == 16)
 		usbcfg |= DWC2_GUSBCFG_PHYIF;
 #endif
 	}
@@ -783,8 +813,8 @@ int wait_for_chhltd(struct dwc2_hc_regs *hc_regs, uint32_t *sub, u8 *toggle)
 	int ret;
 	uint32_t hcint, hctsiz;
 
-	ret = wait_for_bit(__func__, &hc_regs->hcint, DWC2_HCINT_CHHLTD, true,
-			   1000, false);
+	ret = wait_for_bit_le32(&hc_regs->hcint, DWC2_HCINT_CHHLTD, true,
+				2000, false);
 	if (ret)
 		return ret;
 
@@ -1081,7 +1111,8 @@ static int _submit_control_msg(struct dwc2_priv *priv, struct usb_device *dev,
 }
 
 int _submit_int_msg(struct dwc2_priv *priv, struct usb_device *dev,
-		    unsigned long pipe, void *buffer, int len, int interval)
+		    unsigned long pipe, void *buffer, int len, int interval,
+		    bool nonblock)
 {
 	unsigned long timeout;
 	int ret;
@@ -1091,13 +1122,40 @@ int _submit_int_msg(struct dwc2_priv *priv, struct usb_device *dev,
 	timeout = get_timer(0) + USB_TIMEOUT_MS(pipe);
 	for (;;) {
 		if (get_timer(0) > timeout) {
-			printf("Timeout poll on interrupt endpoint\n");
+			dev_err(dev, "Timeout poll on interrupt endpoint\n");
 			return -ETIMEDOUT;
 		}
 		ret = _submit_bulk_msg(priv, dev, pipe, buffer, len);
-		if (ret != -EAGAIN)
+		if ((ret != -EAGAIN) || nonblock)
+			return ret;
+	}
+}
+
+static int dwc2_reset(struct udevice *dev)
+{
+	int ret;
+	struct dwc2_priv *priv = dev_get_priv(dev);
+
+	ret = reset_get_bulk(dev, &priv->resets);
+	if (ret) {
+		dev_warn(dev, "Can't get reset: %d\n", ret);
+		/* Return 0 if error due to !CONFIG_DM_RESET and reset
+		 * DT property is not present.
+		 */
+		if (ret == -ENOENT || ret == -ENOTSUPP)
+			return 0;
+		else
 			return ret;
 	}
+
+	ret = reset_deassert_bulk(&priv->resets);
+	if (ret) {
+		reset_release_bulk(&priv->resets);
+		dev_err(dev, "Failed to reset: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
 }
 
 static int dwc2_init_common(struct udevice *dev, struct dwc2_priv *priv)
@@ -1105,13 +1163,20 @@ static int dwc2_init_common(struct udevice *dev, struct dwc2_priv *priv)
 	struct dwc2_core_regs *regs = priv->regs;
 	uint32_t snpsid;
 	int i, j;
+	int ret;
+
+	ret = dwc2_reset(dev);
+	if (ret)
+		return ret;
 
 	snpsid = readl(&regs->gsnpsid);
-	printf("Core Release: %x.%03x\n", snpsid >> 12 & 0xf, snpsid & 0xfff);
+	dev_info(dev, "Core Release: %x.%03x\n",
+		 snpsid >> 12 & 0xf, snpsid & 0xfff);
 
 	if ((snpsid & DWC2_SNPSID_DEVID_MASK) != DWC2_SNPSID_DEVID_VER_2xx &&
 	    (snpsid & DWC2_SNPSID_DEVID_MASK) != DWC2_SNPSID_DEVID_VER_3xx) {
-		printf("SNPSID invalid (not DWC2 OTG device): %08x\n", snpsid);
+		dev_info(dev, "SNPSID invalid (not DWC2 OTG device): %08x\n",
+			 snpsid);
 		return -ENODEV;
 	}
 
@@ -1161,7 +1226,7 @@ static void dwc2_uninit_common(struct dwc2_core_regs *regs)
 			DWC2_HPRT0_PRTRST);
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		       int len, struct devrequest *setup)
 {
@@ -1175,9 +1240,10 @@ int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 }
 
 int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
-		   int len, int interval)
+		   int len, int interval, bool nonblock)
 {
-	return _submit_int_msg(&local, dev, pipe, buffer, len, interval);
+	return _submit_int_msg(&local, dev, pipe, buffer, len, interval,
+			       nonblock);
 }
 
 /* U-Boot USB control interface */
@@ -1206,7 +1272,7 @@ int usb_lowlevel_stop(int index)
 }
 #endif
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int dwc2_submit_control_msg(struct udevice *dev, struct usb_device *udev,
 				   unsigned long pipe, void *buffer, int length,
 				   struct devrequest *setup)
@@ -1231,13 +1297,14 @@ static int dwc2_submit_bulk_msg(struct udevice *dev, struct usb_device *udev,
 
 static int dwc2_submit_int_msg(struct udevice *dev, struct usb_device *udev,
 			       unsigned long pipe, void *buffer, int length,
-			       int interval)
+			       int interval, bool nonblock)
 {
 	struct dwc2_priv *priv = dev_get_priv(dev);
 
 	debug("%s: dev='%s', udev=%p\n", __func__, dev->name, udev);
 
-	return _submit_int_msg(priv, udev, pipe, buffer, length, interval);
+	return _submit_int_msg(priv, udev, pipe, buffer, length, interval,
+			       nonblock);
 }
 
 static int dwc2_usb_ofdata_to_platdata(struct udevice *dev)
@@ -1245,7 +1312,7 @@ static int dwc2_usb_ofdata_to_platdata(struct udevice *dev)
 	struct dwc2_priv *priv = dev_get_priv(dev);
 	fdt_addr_t addr;
 
-	addr = devfdt_get_addr(dev);
+	addr = dev_read_addr(dev);
 	if (addr == FDT_ADDR_T_NONE)
 		return -EINVAL;
 	priv->regs = (struct dwc2_core_regs *)addr;
@@ -1263,15 +1330,26 @@ static int dwc2_usb_probe(struct udevice *dev)
 
 	bus_priv->desc_before_addr = true;
 
+#ifdef CONFIG_ARCH_ROCKCHIP
+	priv->hnp_srp_disable = true;
+#endif
+
 	return dwc2_init_common(dev, priv);
 }
 
 static int dwc2_usb_remove(struct udevice *dev)
 {
 	struct dwc2_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = dwc_vbus_supply_exit(dev);
+	if (ret)
+		return ret;
 
 	dwc2_uninit_common(priv->regs);
 
+	reset_release_bulk(&priv->resets);
+
 	return 0;
 }
 
@@ -1283,6 +1361,7 @@ struct dm_usb_ops dwc2_usb_ops = {
 
 static const struct udevice_id dwc2_usb_ids[] = {
 	{ .compatible = "brcm,bcm2835-usb" },
+	{ .compatible = "brcm,bcm2708-usb" },
 	{ .compatible = "snps,dwc2" },
 	{ }
 };
diff --git a/drivers/usb/host/dwc2.h b/drivers/usb/host/dwc2.h
index 4482dc621d..574607a2ac 100644
--- a/drivers/usb/host/dwc2.h
+++ b/drivers/usb/host/dwc2.h
@@ -775,7 +775,9 @@ struct dwc2_core_regs {
 #define DWC2_PHY_TYPE_UTMI		1
 #define DWC2_PHY_TYPE_ULPI		2
 #define CONFIG_DWC2_PHY_TYPE		DWC2_PHY_TYPE_UTMI	/* PHY type */
+#ifndef CONFIG_DWC2_UTMI_WIDTH
 #define CONFIG_DWC2_UTMI_WIDTH		8	/* UTMI bus width (8/16) */
+#endif
 
 #undef CONFIG_DWC2_PHY_ULPI_DDR			/* ULPI PHY uses DDR mode */
 #define CONFIG_DWC2_PHY_ULPI_EXT_VBUS		/* ULPI PHY controls VBUS */
diff --git a/drivers/usb/host/ehci-atmel.c b/drivers/usb/host/ehci-atmel.c
index f6c6b019ca..6ea5764b99 100644
--- a/drivers/usb/host/ehci-atmel.c
+++ b/drivers/usb/host/ehci-atmel.c
@@ -15,9 +15,7 @@
 
 #include "ehci.h"
 
-DECLARE_GLOBAL_DATA_PTR;
-
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 
 int ehci_hcd_init(int index, enum usb_init_type init,
 		struct ehci_hccr **hccr, struct ehci_hcor **hcor)
diff --git a/drivers/usb/host/ehci-exynos.c b/drivers/usb/host/ehci-exynos.c
index 30297b02d3..a2c6d5abfb 100644
--- a/drivers/usb/host/ehci-exynos.c
+++ b/drivers/usb/host/ehci-exynos.c
@@ -10,7 +10,7 @@
 #include <common.h>
 #include <dm.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <usb.h>
 #include <asm/arch/cpu.h>
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 62c431b99f..0f8bf28057 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -26,7 +26,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 1
 #endif
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 struct ehci_fsl_priv {
 	struct ehci_ctrl ehci;
 	fdt_addr_t hcd_base;
@@ -35,7 +35,7 @@ struct ehci_fsl_priv {
 #endif
 
 static void set_txfifothresh(struct usb_ehci *, u32);
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int ehci_fsl_init(struct ehci_fsl_priv *priv, struct usb_ehci *ehci,
 		  struct ehci_hccr *hccr, struct ehci_hcor *hcor);
 #else
@@ -55,7 +55,7 @@ static int usb_phy_clk_valid(struct usb_ehci *ehci)
 	}
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int ehci_fsl_ofdata_to_platdata(struct udevice *dev)
 {
 	struct ehci_fsl_priv *priv = dev_get_priv(dev);
@@ -76,8 +76,12 @@ static int ehci_fsl_init_after_reset(struct ehci_ctrl *ctrl)
 	struct usb_ehci *ehci = NULL;
 	struct ehci_fsl_priv *priv = container_of(ctrl, struct ehci_fsl_priv,
 						   ehci);
-
+#ifdef CONFIG_PPC
+	ehci = (struct usb_ehci *)lower_32_bits(priv->hcd_base);
+#else
 	ehci = (struct usb_ehci *)priv->hcd_base;
+#endif
+
 	if (ehci_fsl_init(priv, ehci, priv->ehci.hccr, priv->ehci.hcor) < 0)
 		return -ENXIO;
 
@@ -103,17 +107,21 @@ static int ehci_fsl_probe(struct udevice *dev)
 		debug("Can't get the EHCI register base address\n");
 		return -ENXIO;
 	}
+#ifdef CONFIG_PPC
+	ehci = (struct usb_ehci *)lower_32_bits(priv->hcd_base);
+#else
 	ehci = (struct usb_ehci *)priv->hcd_base;
+#endif
 	hccr = (struct ehci_hccr *)(&ehci->caplength);
 	hcor = (struct ehci_hcor *)
-		((u32)hccr + HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+		((void *)hccr + HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
 
 	if (ehci_fsl_init(priv, ehci, hccr, hcor) < 0)
 		return -ENXIO;
 
-	debug("ehci-fsl: init hccr %x and hcor %x hc_length %d\n",
-	      (u32)hccr, (u32)hcor,
-	      (u32)HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+	debug("ehci-fsl: init hccr %p and hcor %p hc_length %d\n",
+	      (void *)hccr, (void *)hcor,
+	      HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
 
 	return ehci_register(dev, hccr, hcor, &fsl_ehci_ops, 0, USB_INIT_HOST);
 }
@@ -177,7 +185,7 @@ int ehci_hcd_stop(int index)
 }
 #endif
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int ehci_fsl_init(struct ehci_fsl_priv *priv, struct usb_ehci *ehci,
 		  struct ehci_hccr *hccr, struct ehci_hcor *hcor)
 #else
@@ -186,7 +194,7 @@ static int ehci_fsl_init(int index, struct usb_ehci *ehci,
 #endif
 {
 	const char *phy_type = NULL;
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 	size_t len;
 	char current_usb_controller[5];
 #endif
@@ -212,7 +220,7 @@ static int ehci_fsl_init(int index, struct usb_ehci *ehci,
 	out_be32(&ehci->snoop2, 0x80000000 | SNOOP_SIZE_2GB);
 
 	/* Init phy */
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	if (priv->phy_type)
 		phy_type = priv->phy_type;
 #else
diff --git a/drivers/usb/host/ehci-generic.c b/drivers/usb/host/ehci-generic.c
index 03f8d321af..9b7576d513 100644
--- a/drivers/usb/host/ehci-generic.c
+++ b/drivers/usb/host/ehci-generic.c
@@ -12,6 +12,7 @@
 #include <asm/io.h>
 #include <dm.h>
 #include "ehci.h"
+#include <power/regulator.h>
 
 /*
  * Even though here we don't explicitly use "struct ehci_ctrl"
@@ -23,10 +24,56 @@ struct generic_ehci {
 	struct clk *clocks;
 	struct reset_ctl *resets;
 	struct phy phy;
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *vbus_supply;
+#endif
 	int clock_count;
 	int reset_count;
 };
 
+#ifdef CONFIG_DM_REGULATOR
+static int ehci_enable_vbus_supply(struct udevice *dev)
+{
+	struct generic_ehci *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = device_get_supply_regulator(dev, "vbus-supply",
+					  &priv->vbus_supply);
+	if (ret && ret != -ENOENT)
+		return ret;
+
+	if (priv->vbus_supply) {
+		ret = regulator_set_enable(priv->vbus_supply, true);
+		if (ret) {
+			dev_err(dev, "Error enabling VBUS supply\n");
+			return ret;
+		}
+	} else {
+		dev_dbg(dev, "No vbus supply\n");
+	}
+
+	return 0;
+}
+
+static int ehci_disable_vbus_supply(struct generic_ehci *priv)
+{
+	if (priv->vbus_supply)
+		return regulator_set_enable(priv->vbus_supply, false);
+	else
+		return 0;
+}
+#else
+static int ehci_enable_vbus_supply(struct udevice *dev)
+{
+	return 0;
+}
+
+static int ehci_disable_vbus_supply(struct generic_ehci *priv)
+{
+	return 0;
+}
+#endif
+
 static int ehci_usb_probe(struct udevice *dev)
 {
 	struct generic_ehci *priv = dev_get_priv(dev);
@@ -50,8 +97,8 @@ static int ehci_usb_probe(struct udevice *dev)
 			if (err < 0)
 				break;
 			err = clk_enable(&priv->clocks[i]);
-			if (err) {
-				error("failed to enable clock %d\n", i);
+			if (err && err != -ENOSYS) {
+				dev_err(dev, "failed to enable clock %d\n", i);
 				clk_free(&priv->clocks[i]);
 				goto clk_err;
 			}
@@ -59,7 +106,8 @@ static int ehci_usb_probe(struct udevice *dev)
 		}
 	} else {
 		if (clock_nb != -ENOENT) {
-			error("failed to get clock phandle(%d)\n", clock_nb);
+			dev_err(dev, "failed to get clock phandle(%d)\n",
+				clock_nb);
 			return clock_nb;
 		}
 	}
@@ -80,7 +128,8 @@ static int ehci_usb_probe(struct udevice *dev)
 				break;
 
 			if (reset_deassert(&priv->resets[i])) {
-				error("failed to deassert reset %d\n", i);
+				dev_err(dev, "failed to deassert reset %d\n",
+					i);
 				reset_free(&priv->resets[i]);
 				goto reset_err;
 			}
@@ -88,27 +137,21 @@ static int ehci_usb_probe(struct udevice *dev)
 		}
 	} else {
 		if (reset_nb != -ENOENT) {
-			error("failed to get reset phandle(%d)\n", reset_nb);
+			dev_err(dev, "failed to get reset phandle(%d)\n",
+				reset_nb);
 			goto clk_err;
 		}
 	}
 
-	err = generic_phy_get_by_index(dev, 0, &priv->phy);
-	if (err) {
-		if (err != -ENOENT) {
-			error("failed to get usb phy\n");
-			goto reset_err;
-		}
-	} else {
+	err = ehci_enable_vbus_supply(dev);
+	if (err)
+		goto reset_err;
 
-		err = generic_phy_init(&priv->phy);
-		if (err) {
-			error("failed to init usb phy\n");
-			goto reset_err;
-		}
-	}
+	err = ehci_setup_phy(dev, &priv->phy, 0);
+	if (err)
+		goto regulator_err;
 
-	hccr = map_physmem(devfdt_get_addr(dev), 0x100, MAP_NOCACHE);
+	hccr = map_physmem(dev_read_addr(dev), 0x100, MAP_NOCACHE);
 	hcor = (struct ehci_hcor *)((uintptr_t)hccr +
 				    HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
 
@@ -119,20 +162,23 @@ static int ehci_usb_probe(struct udevice *dev)
 	return 0;
 
 phy_err:
-	if (generic_phy_valid(&priv->phy)) {
-		ret = generic_phy_exit(&priv->phy);
-		if (ret)
-			error("failed to release phy\n");
-	}
+	ret = ehci_shutdown_phy(dev, &priv->phy);
+	if (ret)
+		dev_err(dev, "failed to shutdown usb phy\n");
+
+regulator_err:
+	ret = ehci_disable_vbus_supply(priv);
+	if (ret)
+		dev_err(dev, "failed to disable VBUS supply\n");
 
 reset_err:
 	ret = reset_release_all(priv->resets, priv->reset_count);
 	if (ret)
-		error("failed to assert all resets\n");
+		dev_err(dev, "failed to assert all resets\n");
 clk_err:
 	ret = clk_release_all(priv->clocks, priv->clock_count);
 	if (ret)
-		error("failed to disable all clocks\n");
+		dev_err(dev, "failed to disable all clocks\n");
 
 	return err;
 }
@@ -146,11 +192,13 @@ static int ehci_usb_remove(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	if (generic_phy_valid(&priv->phy)) {
-		ret = generic_phy_exit(&priv->phy);
-		if (ret)
-			return ret;
-	}
+	ret = ehci_shutdown_phy(dev, &priv->phy);
+	if (ret)
+		return ret;
+
+	ret = ehci_disable_vbus_supply(priv);
+	if (ret)
+		return ret;
 
 	ret =  reset_release_all(priv->resets, priv->reset_count);
 	if (ret)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3243c1d1cf..ca5d022ed2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -31,7 +31,7 @@
  */
 #define HCHALT_TIMEOUT (8 * 1000)
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 static struct ehci_ctrl ehcic[CONFIG_USB_MAX_CONTROLLER_COUNT];
 #endif
 
@@ -112,7 +112,7 @@ static struct descriptor {
 
 static struct ehci_ctrl *ehci_get_ctrl(struct usb_device *udev)
 {
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	return dev_get_priv(usb_get_bus(udev->dev));
 #else
 	return udev->controller;
@@ -210,9 +210,6 @@ static int ehci_shutdown(struct ehci_ctrl *ctrl)
 	uint32_t cmd, reg;
 	int max_ports = HCS_N_PORTS(ehci_readl(&ctrl->hccr->cr_hcsparams));
 
-	if (!ctrl || !ctrl->hcor)
-		return -EINVAL;
-
 	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
 	/* If not run, directly return */
 	if (!(cmd & CMD_RUN))
@@ -311,7 +308,7 @@ ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
 	volatile struct qTD *vtd;
 	unsigned long ts;
 	uint32_t *tdp;
-	uint32_t endpt, maxpacket, token, usbsts;
+	uint32_t endpt, maxpacket, token, usbsts, qhtoken;
 	uint32_t c, toggle;
 	uint32_t cmd;
 	int timeout;
@@ -549,22 +546,21 @@ ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
 	flush_dcache_range((unsigned long)qtd,
 			   ALIGN_END_ADDR(struct qTD, qtd, qtd_count));
 
-	/* Set async. queue head pointer. */
-	ehci_writel(&ctrl->hcor->or_asynclistaddr, virt_to_phys(&ctrl->qh_list));
-
 	usbsts = ehci_readl(&ctrl->hcor->or_usbsts);
 	ehci_writel(&ctrl->hcor->or_usbsts, (usbsts & 0x3f));
 
 	/* Enable async. schedule. */
 	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
-	cmd |= CMD_ASE;
-	ehci_writel(&ctrl->hcor->or_usbcmd, cmd);
+	if (!(cmd & CMD_ASE)) {
+		cmd |= CMD_ASE;
+		ehci_writel(&ctrl->hcor->or_usbcmd, cmd);
 
-	ret = handshake((uint32_t *)&ctrl->hcor->or_usbsts, STS_ASS, STS_ASS,
-			100 * 1000);
-	if (ret < 0) {
-		printf("EHCI fail timeout STS_ASS set\n");
-		goto fail;
+		ret = handshake((uint32_t *)&ctrl->hcor->or_usbsts, STS_ASS, STS_ASS,
+				100 * 1000);
+		if (ret < 0) {
+			printf("EHCI fail timeout STS_ASS set\n");
+			goto fail;
+		}
 	}
 
 	/* Wait for TDs to be processed. */
@@ -585,6 +581,11 @@ ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
 			break;
 		WATCHDOG_RESET();
 	} while (get_timer(ts) < timeout);
+	qhtoken = hc32_to_cpu(qh->qh_overlay.qt_token);
+
+	ctrl->qh_list.qh_link = cpu_to_hc32(virt_to_phys(&ctrl->qh_list) | QH_LINK_TYPE_QH);
+	flush_dcache_range((unsigned long)&ctrl->qh_list,
+		ALIGN_END_ADDR(struct QH, &ctrl->qh_list, 1));
 
 	/*
 	 * Invalidate the memory area occupied by buffer
@@ -595,32 +596,20 @@ ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
 	 * dangerous operation, it's responsibility of the calling
 	 * code to make sure enough space is reserved.
 	 */
-	invalidate_dcache_range((unsigned long)buffer,
-		ALIGN((unsigned long)buffer + length, ARCH_DMA_MINALIGN));
+	if (buffer != NULL && length > 0)
+		invalidate_dcache_range((unsigned long)buffer,
+			ALIGN((unsigned long)buffer + length, ARCH_DMA_MINALIGN));
 
 	/* Check that the TD processing happened */
 	if (QT_TOKEN_GET_STATUS(token) & QT_TOKEN_STATUS_ACTIVE)
 		printf("EHCI timed out on TD - token=%#x\n", token);
 
-	/* Disable async schedule. */
-	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
-	cmd &= ~CMD_ASE;
-	ehci_writel(&ctrl->hcor->or_usbcmd, cmd);
-
-	ret = handshake((uint32_t *)&ctrl->hcor->or_usbsts, STS_ASS, 0,
-			100 * 1000);
-	if (ret < 0) {
-		printf("EHCI fail timeout STS_ASS reset\n");
-		goto fail;
-	}
-
-	token = hc32_to_cpu(qh->qh_overlay.qt_token);
-	if (!(QT_TOKEN_GET_STATUS(token) & QT_TOKEN_STATUS_ACTIVE)) {
-		debug("TOKEN=%#x\n", token);
-		switch (QT_TOKEN_GET_STATUS(token) &
+	if (!(QT_TOKEN_GET_STATUS(qhtoken) & QT_TOKEN_STATUS_ACTIVE)) {
+		debug("TOKEN=%#x\n", qhtoken);
+		switch (QT_TOKEN_GET_STATUS(qhtoken) &
 			~(QT_TOKEN_STATUS_SPLITXSTATE | QT_TOKEN_STATUS_PERR)) {
 		case 0:
-			toggle = QT_TOKEN_GET_DT(token);
+			toggle = QT_TOKEN_GET_DT(qhtoken);
 			usb_settoggle(dev, usb_pipeendpoint(pipe),
 				       usb_pipeout(pipe), toggle);
 			dev->status = 0;
@@ -638,11 +627,11 @@ ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
 			break;
 		default:
 			dev->status = USB_ST_CRC_ERR;
-			if (QT_TOKEN_GET_STATUS(token) & QT_TOKEN_STATUS_HALTED)
+			if (QT_TOKEN_GET_STATUS(qhtoken) & QT_TOKEN_STATUS_HALTED)
 				dev->status |= USB_ST_STALLED;
 			break;
 		}
-		dev->act_len = length - QT_TOKEN_GET_TOTALBYTES(token);
+		dev->act_len = length - QT_TOKEN_GET_TOTALBYTES(qhtoken);
 	} else {
 		dev->act_len = 0;
 #ifndef CONFIG_USB_EHCI_FARADAY
@@ -742,8 +731,8 @@ static int ehci_submit_root(struct usb_device *dev, unsigned long pipe,
 		switch (le16_to_cpu(req->value) >> 8) {
 		case USB_DT_HUB:
 			debug("USB_DT_HUB config\n");
-			srcptr = &descriptor.hub;
-			srclen = descriptor.hub.bLength;
+			srcptr = &ctrl->hub;
+			srclen = ctrl->hub.bLength;
 			break;
 		default:
 			debug("unknown value %x\n", le16_to_cpu(req->value));
@@ -966,7 +955,7 @@ static void ehci_setup_ops(struct ehci_ctrl *ctrl, const struct ehci_ops *ops)
 	}
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 void ehci_set_controller_priv(int index, void *priv, const struct ehci_ops *ops)
 {
 	struct ehci_ctrl *ctrl = &ehcic[index];
@@ -1064,6 +1053,8 @@ static int ehci_common_init(struct ehci_ctrl *ctrl, uint tweaks)
 		put_unaligned(get_unaligned(&descriptor.hub.wHubCharacteristics)
 				| 0x01, &descriptor.hub.wHubCharacteristics);
 
+	memcpy(&ctrl->hub, &descriptor, sizeof(struct usb_hub_descriptor));
+
 	/* Start the host controller. */
 	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
 	/*
@@ -1090,7 +1081,7 @@ static int ehci_common_init(struct ehci_ctrl *ctrl, uint tweaks)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int usb_lowlevel_stop(int index)
 {
 	ehci_shutdown(&ehcic[index]);
@@ -1112,6 +1103,8 @@ int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
 	rc = ehci_hcd_init(index, init, &ctrl->hccr, &ctrl->hcor);
 	if (rc)
 		return rc;
+	if (!ctrl->hccr || !ctrl->hcor)
+		return -1;
 	if (init == USB_INIT_DEVICE)
 		goto done;
 
@@ -1473,7 +1466,8 @@ out:
 }
 
 static int _ehci_submit_int_msg(struct usb_device *dev, unsigned long pipe,
-				void *buffer, int length, int interval)
+				void *buffer, int length, int interval,
+				bool nonblock)
 {
 	void *backbuffer;
 	struct int_queue *queue;
@@ -1509,7 +1503,7 @@ static int _ehci_submit_int_msg(struct usb_device *dev, unsigned long pipe,
 	return result;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
 			    void *buffer, int length)
 {
@@ -1523,9 +1517,10 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 }
 
 int submit_int_msg(struct usb_device *dev, unsigned long pipe,
-		   void *buffer, int length, int interval)
+		   void *buffer, int length, int interval, bool nonblock)
 {
-	return _ehci_submit_int_msg(dev, pipe, buffer, length, interval);
+	return _ehci_submit_int_msg(dev, pipe, buffer, length, interval,
+				    nonblock);
 }
 
 struct int_queue *create_int_queue(struct usb_device *dev,
@@ -1547,7 +1542,7 @@ int destroy_int_queue(struct usb_device *dev, struct int_queue *queue)
 }
 #endif
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int ehci_submit_control_msg(struct udevice *dev, struct usb_device *udev,
 				   unsigned long pipe, void *buffer, int length,
 				   struct devrequest *setup)
@@ -1567,10 +1562,11 @@ static int ehci_submit_bulk_msg(struct udevice *dev, struct usb_device *udev,
 
 static int ehci_submit_int_msg(struct udevice *dev, struct usb_device *udev,
 			       unsigned long pipe, void *buffer, int length,
-			       int interval)
+			       int interval, bool nonblock)
 {
 	debug("%s: dev='%s', udev=%p\n", __func__, dev->name, udev);
-	return _ehci_submit_int_msg(udev, pipe, buffer, length, interval);
+	return _ehci_submit_int_msg(udev, pipe, buffer, length, interval,
+				    nonblock);
 }
 
 static struct int_queue *ehci_create_int_queue(struct udevice *dev,
@@ -1596,17 +1592,31 @@ static int ehci_destroy_int_queue(struct udevice *dev, struct usb_device *udev,
 	return _ehci_destroy_int_queue(udev, queue);
 }
 
+static int ehci_get_max_xfer_size(struct udevice *dev, size_t *size)
+{
+	/*
+	 * EHCD can handle any transfer length as long as there is enough
+	 * free heap space left, hence set the theoretical max number here.
+	 */
+	*size = SIZE_MAX;
+
+	return 0;
+}
+
 int ehci_register(struct udevice *dev, struct ehci_hccr *hccr,
 		  struct ehci_hcor *hcor, const struct ehci_ops *ops,
 		  uint tweaks, enum usb_init_type init)
 {
 	struct usb_bus_priv *priv = dev_get_uclass_priv(dev);
 	struct ehci_ctrl *ctrl = dev_get_priv(dev);
-	int ret;
+	int ret = -1;
 
 	debug("%s: dev='%s', ctrl=%p, hccr=%p, hcor=%p, init=%d\n", __func__,
 	      dev->name, ctrl, hccr, hcor, init);
 
+	if (!ctrl || !hccr || !hcor)
+		goto err;
+
 	priv->desc_before_addr = true;
 
 	ehci_setup_ops(ctrl, ops);
@@ -1658,6 +1668,73 @@ struct dm_usb_ops ehci_usb_ops = {
 	.create_int_queue = ehci_create_int_queue,
 	.poll_int_queue = ehci_poll_int_queue,
 	.destroy_int_queue = ehci_destroy_int_queue,
+	.get_max_xfer_size  = ehci_get_max_xfer_size,
 };
 
 #endif
+
+#ifdef CONFIG_PHY
+int ehci_setup_phy(struct udevice *dev, struct phy *phy, int index)
+{
+	int ret;
+
+	if (!phy)
+		return 0;
+
+	ret = generic_phy_get_by_index(dev, index, phy);
+	if (ret) {
+		if (ret != -ENOENT) {
+			dev_err(dev, "failed to get usb phy\n");
+			return ret;
+		}
+	} else {
+		ret = generic_phy_init(phy);
+		if (ret) {
+			dev_err(dev, "failed to init usb phy\n");
+			return ret;
+		}
+
+		ret = generic_phy_power_on(phy);
+		if (ret) {
+			dev_err(dev, "failed to power on usb phy\n");
+			return generic_phy_exit(phy);
+		}
+	}
+
+	return 0;
+}
+
+int ehci_shutdown_phy(struct udevice *dev, struct phy *phy)
+{
+	int ret = 0;
+
+	if (!phy)
+		return 0;
+
+	if (generic_phy_valid(phy)) {
+		ret = generic_phy_power_off(phy);
+		if (ret) {
+			dev_err(dev, "failed to power off usb phy\n");
+			return ret;
+		}
+
+		ret = generic_phy_exit(phy);
+		if (ret) {
+			dev_err(dev, "failed to power off usb phy\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+#else
+int ehci_setup_phy(struct udevice *dev, struct phy *phy, int index)
+{
+	return 0;
+}
+
+int ehci_shutdown_phy(struct udevice *dev, struct phy *phy)
+{
+	return 0;
+}
+#endif
diff --git a/drivers/usb/host/ehci-marvell.c b/drivers/usb/host/ehci-marvell.c
index 7a0f2083ad..1ac860eb40 100644
--- a/drivers/usb/host/ehci-marvell.c
+++ b/drivers/usb/host/ehci-marvell.c
@@ -39,7 +39,7 @@ DECLARE_GLOBAL_DATA_PTR;
 /*
  * USB 2.0 Bridge Address Decoding registers setup
  */
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 
 struct ehci_mvebu_priv {
 	struct ehci_ctrl ehci;
@@ -229,4 +229,4 @@ int ehci_hcd_stop(int index)
 	return 0;
 }
 
-#endif /* CONFIG_DM_USB */
+#endif /* CONFIG_IS_ENABLED(DM_USB) */
diff --git a/drivers/usb/host/ehci-msm.c b/drivers/usb/host/ehci-msm.c
index 2c0c63322c..44cd11cc81 100644
--- a/drivers/usb/host/ehci-msm.c
+++ b/drivers/usb/host/ehci-msm.c
@@ -11,8 +11,6 @@
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
-#include <fdtdec.h>
-#include <libfdt.h>
 #include <usb.h>
 #include <usb/ehci-ci.h>
 #include <usb/ulpi.h>
@@ -133,8 +131,7 @@ static int ehci_usb_remove(struct udevice *dev)
 	setbits_le32(&ehci->usbcmd, CMD_RESET);
 
 	/* Wait for reset */
-	if (wait_for_bit(__func__, &ehci->usbcmd, CMD_RESET, false, 30,
-			 false)) {
+	if (wait_for_bit_le32(&ehci->usbcmd, CMD_RESET, false, 30, false)) {
 		printf("Stuck on USB reset.\n");
 		return -ETIMEDOUT;
 	}
@@ -147,7 +144,7 @@ static int ehci_usb_ofdata_to_platdata(struct udevice *dev)
 	struct msm_ehci_priv *priv = dev_get_priv(dev);
 
 	priv->ulpi_vp.port_num = 0;
-	priv->ehci = (void *)devfdt_get_addr(dev);
+	priv->ehci = dev_read_addr_ptr(dev);
 
 	if (priv->ehci == (void *)FDT_ADDR_T_NONE)
 		return -EINVAL;
@@ -174,5 +171,6 @@ U_BOOT_DRIVER(usb_ehci) = {
 	.remove = ehci_usb_remove,
 	.ops	= &ehci_usb_ops,
 	.priv_auto_alloc_size = sizeof(struct msm_ehci_priv),
+	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
 	.flags	= DM_FLAG_ALLOC_PRIV_DMA,
 };
diff --git a/drivers/usb/host/ehci-mx5.c b/drivers/usb/host/ehci-mx5.c
index 2b36cebdb3..19f31485db 100644
--- a/drivers/usb/host/ehci-mx5.c
+++ b/drivers/usb/host/ehci-mx5.c
@@ -13,6 +13,8 @@
 #include <asm/io.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/clock.h>
+#include <dm.h>
+#include <power/regulator.h>
 
 #include "ehci.h"
 
@@ -224,6 +226,7 @@ __weak void mx5_ehci_powerup_fixup(struct ehci_ctrl *ctrl, uint32_t *status_reg,
 	mdelay(50);
 }
 
+#if !CONFIG_IS_ENABLED(DM_USB)
 static const struct ehci_ops mx5_ehci_ops = {
 	.powerup_fixup		= mx5_ehci_powerup_fixup,
 };
@@ -268,3 +271,103 @@ int ehci_hcd_stop(int index)
 {
 	return 0;
 }
+#else /* CONFIG_IS_ENABLED(DM_USB) */
+struct ehci_mx5_priv_data {
+	struct ehci_ctrl ctrl;
+	struct usb_ehci *ehci;
+	struct udevice *vbus_supply;
+	enum usb_init_type init_type;
+	int portnr;
+};
+
+static const struct ehci_ops mx5_ehci_ops = {
+	.powerup_fixup		= mx5_ehci_powerup_fixup,
+};
+
+static int ehci_usb_ofdata_to_platdata(struct udevice *dev)
+{
+	struct usb_platdata *plat = dev_get_platdata(dev);
+	const char *mode;
+
+	mode = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "dr_mode", NULL);
+	if (mode) {
+		if (strcmp(mode, "peripheral") == 0)
+			plat->init_type = USB_INIT_DEVICE;
+		else if (strcmp(mode, "host") == 0)
+			plat->init_type = USB_INIT_HOST;
+		else
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ehci_usb_probe(struct udevice *dev)
+{
+	struct usb_platdata *plat = dev_get_platdata(dev);
+	struct usb_ehci *ehci = (struct usb_ehci *)devfdt_get_addr(dev);
+	struct ehci_mx5_priv_data *priv = dev_get_priv(dev);
+	enum usb_init_type type = plat->init_type;
+	struct ehci_hccr *hccr;
+	struct ehci_hcor *hcor;
+	int ret;
+
+	set_usboh3_clk();
+	enable_usboh3_clk(true);
+	set_usb_phy_clk();
+	enable_usb_phy1_clk(true);
+	enable_usb_phy2_clk(true);
+	mdelay(1);
+
+	priv->ehci = ehci;
+	priv->portnr = dev->seq;
+	priv->init_type = type;
+
+	ret = device_get_supply_regulator(dev, "vbus-supply",
+					  &priv->vbus_supply);
+	if (ret)
+		debug("%s: No vbus supply\n", dev->name);
+
+	if (!ret && priv->vbus_supply) {
+		ret = regulator_set_enable(priv->vbus_supply,
+					   (type == USB_INIT_DEVICE) ?
+					   false : true);
+		if (ret) {
+			puts("Error enabling VBUS supply\n");
+			return ret;
+		}
+	}
+
+	hccr = (struct ehci_hccr *)((uint32_t)&ehci->caplength);
+	hcor = (struct ehci_hcor *)((uint32_t)hccr +
+			HC_LENGTH(ehci_readl(&(hccr)->cr_capbase)));
+	setbits_le32(&ehci->usbmode, CM_HOST);
+
+	__raw_writel(CONFIG_MXC_USB_PORTSC, &ehci->portsc);
+	setbits_le32(&ehci->portsc, USB_EN);
+
+	mxc_set_usbcontrol(priv->portnr, CONFIG_MXC_USB_FLAGS);
+	mdelay(10);
+
+	return ehci_register(dev, hccr, hcor, &mx5_ehci_ops, 0,
+			     priv->init_type);
+}
+
+static const struct udevice_id mx5_usb_ids[] = {
+	{ .compatible = "fsl,imx53-usb" },
+	{ }
+};
+
+U_BOOT_DRIVER(usb_mx5) = {
+	.name	= "ehci_mx5",
+	.id	= UCLASS_USB,
+	.of_match = mx5_usb_ids,
+	.ofdata_to_platdata = ehci_usb_ofdata_to_platdata,
+	.probe	= ehci_usb_probe,
+	.remove = ehci_deregister,
+	.ops	= &ehci_usb_ops,
+	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
+	.priv_auto_alloc_size = sizeof(struct ehci_mx5_priv_data),
+	.flags	= DM_FLAG_ALLOC_PRIV_DMA,
+};
+#endif /* !CONFIG_IS_ENABLED(DM_USB) */
diff --git a/drivers/usb/host/ehci-mx6.c b/drivers/usb/host/ehci-mx6.c
index fe2627ea93..81197f8b18 100644
--- a/drivers/usb/host/ehci-mx6.c
+++ b/drivers/usb/host/ehci-mx6.c
@@ -19,6 +19,7 @@
 #include <dm.h>
 #include <asm/mach-types.h>
 #include <power/regulator.h>
+#include <linux/usb/otg.h>
 
 #include "ehci.h"
 
@@ -64,10 +65,12 @@ DECLARE_GLOBAL_DATA_PTR;
 #define UCMD_RUN_STOP           (1 << 0) /* controller run/stop */
 #define UCMD_RESET		(1 << 1) /* controller reset */
 
-#if defined(CONFIG_MX6)
+#if defined(CONFIG_MX6) || defined(CONFIG_MX7ULP)
 static const unsigned phy_bases[] = {
 	USB_PHY0_BASE_ADDR,
+#if defined(USB_PHY1_BASE_ADDR)
 	USB_PHY1_BASE_ADDR,
+#endif
 };
 
 static void usb_internal_phy_clock_gate(int index, int on)
@@ -84,6 +87,20 @@ static void usb_internal_phy_clock_gate(int index, int on)
 
 static void usb_power_config(int index)
 {
+#if defined(CONFIG_MX7ULP)
+	struct usbphy_regs __iomem *usbphy =
+		(struct usbphy_regs __iomem *)USB_PHY0_BASE_ADDR;
+
+	if (index > 0)
+		return;
+
+	writel(ANADIG_USB2_CHRG_DETECT_EN_B |
+		   ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B,
+		   &usbphy->usb1_chrg_detect);
+
+	scg_enable_usb_pll(true);
+
+#else
 	struct anatop_regs __iomem *anatop =
 		(struct anatop_regs __iomem *)ANATOP_BASE_ADDR;
 	void __iomem *chrg_detect;
@@ -123,6 +140,8 @@ static void usb_power_config(int index)
 		     ANADIG_USB2_PLL_480_CTRL_POWER |
 		     ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS,
 		     pll_480_ctrl_set);
+
+#endif
 }
 
 /* Return 0 : host node, <>0 : device mode */
@@ -142,13 +161,12 @@ static int usb_phy_enable(int index, struct usb_ehci *ehci)
 
 	/* Stop then Reset */
 	clrbits_le32(usb_cmd, UCMD_RUN_STOP);
-	ret = wait_for_bit(__func__, usb_cmd, UCMD_RUN_STOP, false, 10000,
-			   false);
+	ret = wait_for_bit_le32(usb_cmd, UCMD_RUN_STOP, false, 10000, false);
 	if (ret)
 		return ret;
 
 	setbits_le32(usb_cmd, UCMD_RESET);
-	ret = wait_for_bit(__func__, usb_cmd, UCMD_RESET, false, 10000, false);
+	ret = wait_for_bit_le32(usb_cmd, UCMD_RESET, false, 10000, false);
 	if (ret)
 		return ret;
 
@@ -186,6 +204,14 @@ int usb_phy_mode(int port)
 		return USB_INIT_HOST;
 }
 
+#if defined(CONFIG_MX7ULP)
+struct usbnc_regs {
+	u32 ctrl1;
+	u32 ctrl2;
+	u32 reserve0[2];
+	u32 hsic_ctrl;
+};
+#else
 /* Base address for this IP block is 0x02184800 */
 struct usbnc_regs {
 	u32	ctrl[4];	/* otg/host1-3 */
@@ -194,6 +220,8 @@ struct usbnc_regs {
 	u32	otg_phy_ctrl_0;
 	u32	uh1_phy_ctrl_0;
 };
+#endif
+
 #elif defined(CONFIG_MX7)
 struct usbnc_regs {
 	u32 ctrl1;
@@ -214,20 +242,12 @@ static void usb_power_config(int index)
 	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USB_BASE_ADDR +
 			(0x10000 * index) + USBNC_OFFSET);
 	void __iomem *phy_cfg2 = (void __iomem *)(&usbnc->phy_cfg2);
-	void __iomem *ctrl = (void __iomem *)(&usbnc->ctrl1);
 
 	/*
 	 * Clear the ACAENB to enable usb_otg_id detection,
 	 * otherwise it is the ACA detection enabled.
 	 */
 	clrbits_le32(phy_cfg2, USBNC_PHYCFG2_ACAENB);
-
-	/* Set power polarity to high active */
-#ifdef CONFIG_MXC_USB_OTG_HACTIVE
-	setbits_le32(ctrl, UCTRL_PWR_POL);
-#else
-	clrbits_le32(ctrl, UCTRL_PWR_POL);
-#endif
 }
 
 int usb_phy_mode(int port)
@@ -252,7 +272,7 @@ static void usb_oc_config(int index)
 	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USB_BASE_ADDR +
 			USB_OTHERREGS_OFFSET);
 	void __iomem *ctrl = (void __iomem *)(&usbnc->ctrl[index]);
-#elif defined(CONFIG_MX7)
+#elif defined(CONFIG_MX7) || defined(CONFIG_MX7ULP)
 	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USB_BASE_ADDR +
 			(0x10000 * index) + USBNC_OFFSET);
 	void __iomem *ctrl = (void __iomem *)(&usbnc->ctrl1);
@@ -266,6 +286,13 @@ static void usb_oc_config(int index)
 #endif
 
 	setbits_le32(ctrl, UCTRL_OVER_CUR_DIS);
+
+	/* Set power polarity to high active */
+#ifdef CONFIG_MXC_USB_OTG_HACTIVE
+	setbits_le32(ctrl, UCTRL_PWR_POL);
+#else
+	clrbits_le32(ctrl, UCTRL_PWR_POL);
+#endif
 }
 
 /**
@@ -329,7 +356,7 @@ int ehci_mx6_common_init(struct usb_ehci *ehci, int index)
 	usb_power_config(index);
 	usb_oc_config(index);
 
-#if defined(CONFIG_MX6)
+#if defined(CONFIG_MX6) || defined(CONFIG_MX7ULP)
 	usb_internal_phy_clock_gate(index, 1);
 	usb_phy_enable(index, ehci);
 #endif
@@ -337,14 +364,14 @@ int ehci_mx6_common_init(struct usb_ehci *ehci, int index)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int ehci_hcd_init(int index, enum usb_init_type init,
 		struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 {
 	enum usb_init_type type;
 #if defined(CONFIG_MX6)
 	u32 controller_spacing = 0x200;
-#elif defined(CONFIG_MX7)
+#elif defined(CONFIG_MX7) || defined(CONFIG_MX7ULP)
 	u32 controller_spacing = 0x10000;
 #endif
 	struct usb_ehci *ehci = (struct usb_ehci *)(USB_BASE_ADDR +
@@ -406,6 +433,7 @@ static int mx6_init_after_reset(struct ehci_ctrl *dev)
 	if (ret)
 		return ret;
 
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
 	if (priv->vbus_supply) {
 		ret = regulator_set_enable(priv->vbus_supply,
 					   (type == USB_INIT_DEVICE) ?
@@ -415,6 +443,7 @@ static int mx6_init_after_reset(struct ehci_ctrl *dev)
 			return ret;
 		}
 	}
+#endif
 
 	if (type == USB_INIT_DEVICE)
 		return 0;
@@ -445,7 +474,7 @@ static int ehci_usb_phy_mode(struct udevice *dev)
 	 * About fsl,usbphy, Refer to
 	 * Documentation/devicetree/bindings/usb/ci-hdrc-usb2.txt.
 	 */
-	if (is_mx6()) {
+	if (is_mx6() || is_mx7ulp()) {
 		phy_off = fdtdec_lookup_phandle(blob,
 						offset,
 						"fsl,usbphy");
@@ -483,23 +512,60 @@ static int ehci_usb_phy_mode(struct udevice *dev)
 static int ehci_usb_ofdata_to_platdata(struct udevice *dev)
 {
 	struct usb_platdata *plat = dev_get_platdata(dev);
-	const char *mode;
+	enum usb_dr_mode dr_mode;
 
-	mode = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "dr_mode", NULL);
-	if (mode) {
-		if (strcmp(mode, "peripheral") == 0)
-			plat->init_type = USB_INIT_DEVICE;
-		else if (strcmp(mode, "host") == 0)
-			plat->init_type = USB_INIT_HOST;
-		else if (strcmp(mode, "otg") == 0)
-			return ehci_usb_phy_mode(dev);
-		else
-			return -EINVAL;
+	dr_mode = usb_get_dr_mode(dev->node);
 
-		return 0;
-	}
+	switch (dr_mode) {
+	case USB_DR_MODE_HOST:
+		plat->init_type = USB_INIT_HOST;
+		break;
+	case USB_DR_MODE_PERIPHERAL:
+		plat->init_type = USB_INIT_DEVICE;
+		break;
+	case USB_DR_MODE_OTG:
+	case USB_DR_MODE_UNKNOWN:
+		return ehci_usb_phy_mode(dev);
+	};
+
+	return 0;
+}
+
+static int ehci_usb_bind(struct udevice *dev)
+{
+	/*
+	 * TODO:
+	 * This driver is only partly converted to DT probing and still uses
+	 * a tremendous amount of hard-coded addresses. To make things worse,
+	 * the driver depends on specific sequential indexing of controllers,
+	 * from which it derives offsets in the PHY and ANATOP register sets.
+	 *
+	 * Here we attempt to calculate these indexes from DT information as
+	 * well as we can. The USB controllers on all existing iMX6 SoCs
+	 * are placed next to each other, at addresses incremented by 0x200,
+	 * and iMX7 their addresses are shifted by 0x10000.
+	 * Thus, the index is derived from the multiple of 0x200 (0x10000 for
+	 * iMX7) offset from the first controller address.
+	 *
+	 * However, to complete conversion of this driver to DT probing, the
+	 * following has to be done:
+	 * - DM clock framework support for iMX must be implemented
+	 * - usb_power_config() has to be converted to clock framework
+	 *   -> Thus, the ad-hoc "index" variable goes away.
+	 * - USB PHY handling has to be factored out into separate driver
+	 *   -> Thus, the ad-hoc "index" variable goes away from the PHY
+	 *      code, the PHY driver must parse it's address from DT. This
+	 *      USB driver must find the PHY driver via DT phandle.
+	 *   -> usb_power_config() shall be moved to PHY driver
+	 * With these changes in place, the ad-hoc indexing goes away and
+	 * the driver is fully converted to DT probing.
+	 */
+	u32 controller_spacing = is_mx7() ? 0x10000 : 0x200;
+	fdt_addr_t addr = devfdt_get_addr_index(dev, 0);
 
-	return ehci_usb_phy_mode(dev);
+	dev->req_seq = (addr - USB_BASE_ADDR) / controller_spacing;
+
+	return 0;
 }
 
 static int ehci_usb_probe(struct udevice *dev)
@@ -516,15 +582,17 @@ static int ehci_usb_probe(struct udevice *dev)
 	priv->portnr = dev->seq;
 	priv->init_type = type;
 
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
 	ret = device_get_supply_regulator(dev, "vbus-supply",
 					  &priv->vbus_supply);
 	if (ret)
 		debug("%s: No vbus supply\n", dev->name);
-
+#endif
 	ret = ehci_mx6_common_init(ehci, priv->portnr);
 	if (ret)
 		return ret;
 
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
 	if (priv->vbus_supply) {
 		ret = regulator_set_enable(priv->vbus_supply,
 					   (type == USB_INIT_DEVICE) ?
@@ -534,6 +602,7 @@ static int ehci_usb_probe(struct udevice *dev)
 			return ret;
 		}
 	}
+#endif
 
 	if (priv->init_type == USB_INIT_HOST) {
 		setbits_le32(&ehci->usbmode, CM_HOST);
@@ -560,6 +629,7 @@ U_BOOT_DRIVER(usb_mx6) = {
 	.id	= UCLASS_USB,
 	.of_match = mx6_usb_ids,
 	.ofdata_to_platdata = ehci_usb_ofdata_to_platdata,
+	.bind	= ehci_usb_bind,
 	.probe	= ehci_usb_probe,
 	.remove = ehci_deregister,
 	.ops	= &ehci_usb_ops,
diff --git a/drivers/usb/host/ehci-mxs.c b/drivers/usb/host/ehci-mxs.c
index 6b8d969bb0..9872415562 100644
--- a/drivers/usb/host/ehci-mxs.c
+++ b/drivers/usb/host/ehci-mxs.c
@@ -156,7 +156,7 @@ int ehci_hcd_stop(int index)
 
 	tmp = ehci_readl(&hcor->or_usbcmd);
 	tmp &= ~CMD_RUN;
-	ehci_writel(tmp, &hcor->or_usbcmd);
+	ehci_writel(&hcor->or_usbcmd, tmp);
 
 	/* Disable the PHY */
 	tmp = USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF |
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index dceba4bd7a..7a220a3dd5 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -17,17 +17,23 @@
 /* Information about a USB port */
 struct ehci_pci_priv {
 	struct ehci_ctrl ehci;
+	struct phy phy;
 };
 
-#ifdef CONFIG_DM_USB
-
-static void ehci_pci_init(struct udevice *dev, struct ehci_hccr **ret_hccr,
+#if CONFIG_IS_ENABLED(DM_USB)
+static int ehci_pci_init(struct udevice *dev, struct ehci_hccr **ret_hccr,
 			  struct ehci_hcor **ret_hcor)
 {
+	struct ehci_pci_priv *priv = dev_get_priv(dev);
 	struct ehci_hccr *hccr;
 	struct ehci_hcor *hcor;
+	int ret;
 	u32 cmd;
 
+	ret = ehci_setup_phy(dev, &priv->phy, 0);
+	if (ret)
+		return ret;
+
 	hccr = (struct ehci_hccr *)dm_pci_map_bar(dev,
 			PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
 	hcor = (struct ehci_hcor *)((uintptr_t) hccr +
@@ -44,6 +50,8 @@ static void ehci_pci_init(struct udevice *dev, struct ehci_hccr **ret_hccr,
 	dm_pci_read_config32(dev, PCI_COMMAND, &cmd);
 	cmd |= PCI_COMMAND_MASTER;
 	dm_pci_write_config32(dev, PCI_COMMAND, cmd);
+
+	return 0;
 }
 
 #else
@@ -114,19 +122,34 @@ int ehci_hcd_stop(int index)
 {
 	return 0;
 }
-#endif /* nCONFIG_DM_USB */
+#endif /* !CONFIG_IS_ENABLED(DM_USB) */
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int ehci_pci_probe(struct udevice *dev)
 {
 	struct ehci_hccr *hccr;
 	struct ehci_hcor *hcor;
+	int ret;
 
-	ehci_pci_init(dev, &hccr, &hcor);
+	ret = ehci_pci_init(dev, &hccr, &hcor);
+	if (ret)
+		return ret;
 
 	return ehci_register(dev, hccr, hcor, NULL, 0, USB_INIT_HOST);
 }
 
+static int ehci_pci_remove(struct udevice *dev)
+{
+	struct ehci_pci_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ehci_deregister(dev);
+	if (ret)
+		return ret;
+
+	return ehci_shutdown_phy(dev, &priv->phy);
+}
+
 static const struct udevice_id ehci_pci_ids[] = {
 	{ .compatible = "ehci-pci" },
 	{ }
@@ -136,7 +159,7 @@ U_BOOT_DRIVER(ehci_pci) = {
 	.name	= "ehci_pci",
 	.id	= UCLASS_USB,
 	.probe = ehci_pci_probe,
-	.remove = ehci_deregister,
+	.remove = ehci_pci_remove,
 	.of_match = ehci_pci_ids,
 	.ops	= &ehci_usb_ops,
 	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
@@ -151,4 +174,4 @@ static struct pci_device_id ehci_pci_supported[] = {
 
 U_BOOT_PCI_DEVICE(ehci_pci, ehci_pci_supported);
 
-#endif /* CONFIG_DM_USB */
+#endif /* CONFIG_IS_ENABLED(DM_USB) */
diff --git a/drivers/usb/host/ehci-rcar_gen3.c b/drivers/usb/host/ehci-rcar_gen3.c
index 525e7f3573..16d4713bd4 100644
--- a/drivers/usb/host/ehci-rcar_gen3.c
+++ b/drivers/usb/host/ehci-rcar_gen3.c
@@ -59,7 +59,7 @@ int ehci_hcd_stop(int index)
 
 	/* Reset EHCI */
 	setbits_le32((uintptr_t)(base + EHCI_USBCMD), CMD_RESET);
-	ret = wait_for_bit("ehci-rcar", (void *)(uintptr_t)base + EHCI_USBCMD,
+	ret = wait_for_bit_le32((void *)(uintptr_t)base + EHCI_USBCMD,
 			   CMD_RESET, false, 10, true);
 	if (ret) {
 		printf("ehci-rcar: reset failed (index=%i, ret=%i).\n",
diff --git a/drivers/usb/host/ehci-sunxi.c b/drivers/usb/host/ehci-sunxi.c
index 6ecb7c4d12..ed9763c63d 100644
--- a/drivers/usb/host/ehci-sunxi.c
+++ b/drivers/usb/host/ehci-sunxi.c
@@ -27,19 +27,23 @@
 
 struct ehci_sunxi_priv {
 	struct ehci_ctrl ehci;
+	struct sunxi_ccm_reg *ccm;
 	int ahb_gate_mask; /* Mask of ahb_gate0 clk gate bits for this hcd */
 	int phy_index;     /* Index of the usb-phy attached to this hcd */
 };
 
 static int ehci_usb_probe(struct udevice *dev)
 {
-	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
 	struct usb_platdata *plat = dev_get_platdata(dev);
 	struct ehci_sunxi_priv *priv = dev_get_priv(dev);
 	struct ehci_hccr *hccr = (struct ehci_hccr *)devfdt_get_addr(dev);
 	struct ehci_hcor *hcor;
 	int extra_ahb_gate_mask = 0;
 
+	priv->ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	if (IS_ERR(priv->ccm))
+		return PTR_ERR(priv->ccm);
+
 	/*
 	 * This should go away once we've moved to the driver model for
 	 * clocks resp. phys.
@@ -53,10 +57,10 @@ static int ehci_usb_probe(struct udevice *dev)
 	extra_ahb_gate_mask <<= priv->phy_index * AHB_CLK_DIST;
 	priv->phy_index++; /* Non otg phys start at 1 */
 
-	setbits_le32(&ccm->ahb_gate0,
+	setbits_le32(&priv->ccm->ahb_gate0,
 		     priv->ahb_gate_mask | extra_ahb_gate_mask);
 #ifdef CONFIG_SUNXI_GEN_SUN6I
-	setbits_le32(&ccm->ahb_reset0_cfg,
+	setbits_le32(&priv->ccm->ahb_reset0_cfg,
 		     priv->ahb_gate_mask | extra_ahb_gate_mask);
 #endif
 
@@ -71,7 +75,6 @@ static int ehci_usb_probe(struct udevice *dev)
 
 static int ehci_usb_remove(struct udevice *dev)
 {
-	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
 	struct ehci_sunxi_priv *priv = dev_get_priv(dev);
 	int ret;
 
@@ -82,9 +85,9 @@ static int ehci_usb_remove(struct udevice *dev)
 	sunxi_usb_phy_exit(priv->phy_index);
 
 #ifdef CONFIG_SUNXI_GEN_SUN6I
-	clrbits_le32(&ccm->ahb_reset0_cfg, priv->ahb_gate_mask);
+	clrbits_le32(&priv->ccm->ahb_reset0_cfg, priv->ahb_gate_mask);
 #endif
-	clrbits_le32(&ccm->ahb_gate0, priv->ahb_gate_mask);
+	clrbits_le32(&priv->ccm->ahb_gate0, priv->ahb_gate_mask);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index 1c72330b0c..f317cf00ea 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -16,7 +16,7 @@
 #include <asm/arch-tegra/clk_rst.h>
 #include <usb.h>
 #include <usb/ulpi.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 #include "ehci.h"
 
diff --git a/drivers/usb/host/ehci-vf.c b/drivers/usb/host/ehci-vf.c
index 5bb3763814..599c021476 100644
--- a/drivers/usb/host/ehci-vf.c
+++ b/drivers/usb/host/ehci-vf.c
@@ -20,7 +20,7 @@
 #include <asm/mach-imx/iomux-v3.h>
 #include <asm/mach-imx/regs-usbphy.h>
 #include <usb/ehci-ci.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdtdec.h>
 
 #include "ehci.h"
@@ -154,7 +154,7 @@ int ehci_vf_common_init(struct usb_ehci *ehci, int index)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int ehci_hcd_init(int index, enum usb_init_type init,
 		struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 7c39becd24..98a6b4a908 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -10,6 +10,7 @@
 #define USB_EHCI_H
 
 #include <usb.h>
+#include <generic-phy.h>
 
 /* Section 2.2.3 - N_PORTS */
 #define MAX_HC_PORTS		15
@@ -101,11 +102,11 @@ struct usb_linux_config_descriptor {
 } __attribute__ ((packed));
 
 #if defined CONFIG_EHCI_DESC_BIG_ENDIAN
-#define ehci_readl(x)		cpu_to_be32(readl(x))
-#define ehci_writel(a, b)	writel(cpu_to_be32(b), a)
+#define ehci_readl(x)		be32_to_cpu(__raw_readl(x))
+#define ehci_writel(a, b)	__raw_writel(cpu_to_be32(b), a)
 #else
-#define ehci_readl(x)		cpu_to_le32(readl(x))
-#define ehci_writel(a, b)	writel(cpu_to_le32(b), a)
+#define ehci_readl(x)		readl(x)
+#define ehci_writel(a, b)	writel(b, a)
 #endif
 
 #if defined CONFIG_EHCI_MMIO_BIG_ENDIAN
@@ -252,6 +253,7 @@ struct ehci_ctrl {
 	int periodic_schedules;
 	int ntds;
 	struct ehci_ops ops;
+	struct usb_hub_descriptor hub;
 	void *priv;	/* client's private data */
 };
 
@@ -289,4 +291,8 @@ int ehci_register(struct udevice *dev, struct ehci_hccr *hccr,
 int ehci_deregister(struct udevice *dev);
 extern struct dm_usb_ops ehci_usb_ops;
 
+/* EHCI PHY functions */
+int ehci_setup_phy(struct udevice *dev, struct phy *phy, int index);
+int ehci_shutdown_phy(struct udevice *dev, struct phy *phy);
+
 #endif /* USB_EHCI_H */
diff --git a/drivers/usb/host/ohci-da8xx.c b/drivers/usb/host/ohci-da8xx.c
index 9816628065..f09b2043b5 100644
--- a/drivers/usb/host/ohci-da8xx.c
+++ b/drivers/usb/host/ohci-da8xx.c
@@ -5,9 +5,54 @@
  */
 
 #include <common.h>
-
+#include <asm/io.h>
+#include <clk.h>
+#include <dm.h>
+#include <dm/ofnode.h>
+#include <generic-phy.h>
+#include <reset.h>
+#include "ohci.h"
 #include <asm/arch/da8xx-usb.h>
 
+struct da8xx_ohci {
+	ohci_t ohci;
+	struct clk *clocks;	/* clock list */
+	struct phy phy;
+	int clock_count;	/* number of clock in clock list */
+};
+
+static int usb_phy_on(void)
+{
+	unsigned long timeout;
+
+	clrsetbits_le32(&davinci_syscfg_regs->cfgchip2,
+			(CFGCHIP2_RESET | CFGCHIP2_PHYPWRDN |
+			CFGCHIP2_OTGPWRDN | CFGCHIP2_OTGMODE |
+			CFGCHIP2_REFFREQ | CFGCHIP2_USB1PHYCLKMUX),
+			(CFGCHIP2_SESENDEN | CFGCHIP2_VBDTCTEN |
+			CFGCHIP2_PHY_PLLON | CFGCHIP2_REFFREQ_24MHZ |
+			CFGCHIP2_USB2PHYCLKMUX | CFGCHIP2_USB1SUSPENDM));
+
+	/* wait until the usb phy pll locks */
+	timeout = get_timer(0);
+	while (get_timer(timeout) < 10) {
+		if (readl(&davinci_syscfg_regs->cfgchip2) & CFGCHIP2_PHYCLKGD)
+			return 1;
+	}
+
+	/* USB phy was not turned on */
+	return 0;
+}
+
+static void usb_phy_off(void)
+{
+	/* Power down the on-chip PHY. */
+	clrsetbits_le32(&davinci_syscfg_regs->cfgchip2,
+			CFGCHIP2_PHY_PLLON | CFGCHIP2_USB1SUSPENDM,
+			CFGCHIP2_PHYPWRDN | CFGCHIP2_OTGPWRDN |
+			CFGCHIP2_RESET);
+}
+
 int usb_cpu_init(void)
 {
 	/* enable psc for usb2.0 */
@@ -38,3 +83,95 @@ int usb_cpu_init_fail(void)
 {
 	return usb_cpu_stop();
 }
+
+#if CONFIG_IS_ENABLED(DM_USB)
+static int ohci_da8xx_probe(struct udevice *dev)
+{
+	struct ohci_regs *regs = (struct ohci_regs *)devfdt_get_addr(dev);
+	struct da8xx_ohci *priv = dev_get_priv(dev);
+	int i, err, ret, clock_nb;
+
+	err = 0;
+	priv->clock_count = 0;
+	clock_nb = dev_count_phandle_with_args(dev, "clocks", "#clock-cells");
+
+	if (clock_nb < 0)
+		return clock_nb;
+
+	if (clock_nb > 0) {
+		priv->clocks = devm_kcalloc(dev, clock_nb, sizeof(struct clk),
+					    GFP_KERNEL);
+		if (!priv->clocks)
+			return -ENOMEM;
+
+		for (i = 0; i < clock_nb; i++) {
+			err = clk_get_by_index(dev, i, &priv->clocks[i]);
+			if (err < 0)
+				break;
+
+			err = clk_enable(&priv->clocks[i]);
+			if (err) {
+				dev_err(dev, "failed to enable clock %d\n", i);
+				clk_free(&priv->clocks[i]);
+				goto clk_err;
+			}
+			priv->clock_count++;
+		}
+	}
+
+	err = usb_cpu_init();
+
+	if (err)
+		goto clk_err;
+
+	err = ohci_register(dev, regs);
+	if (err)
+		goto phy_err;
+
+	return 0;
+
+phy_err:
+	ret = usb_cpu_stop();
+	if (ret)
+		dev_err(dev, "failed to shutdown usb phy\n");
+
+clk_err:
+	ret = clk_release_all(priv->clocks, priv->clock_count);
+	if (ret)
+		dev_err(dev, "failed to disable all clocks\n");
+
+	return err;
+}
+
+static int ohci_da8xx_remove(struct udevice *dev)
+{
+	struct da8xx_ohci *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ohci_deregister(dev);
+	if (ret)
+		return ret;
+
+	ret = usb_cpu_stop();
+	if (ret)
+		return ret;
+
+	return clk_release_all(priv->clocks, priv->clock_count);
+}
+
+static const struct udevice_id da8xx_ohci_ids[] = {
+	{ .compatible = "ti,da830-ohci" },
+	{ }
+};
+
+U_BOOT_DRIVER(ohci_generic) = {
+	.name	= "ohci-da8xx",
+	.id	= UCLASS_USB,
+	.of_match = da8xx_ohci_ids,
+	.probe = ohci_da8xx_probe,
+	.remove = ohci_da8xx_remove,
+	.ops	= &ohci_usb_ops,
+	.priv_auto_alloc_size = sizeof(struct da8xx_ohci),
+	.flags	= DM_FLAG_ALLOC_PRIV_DMA | DM_FLAG_OS_PREPARE,
+};
+#endif
diff --git a/drivers/usb/host/ohci-generic.c b/drivers/usb/host/ohci-generic.c
index e22ee97939..87c6d2d59f 100644
--- a/drivers/usb/host/ohci-generic.c
+++ b/drivers/usb/host/ohci-generic.c
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
+#include <asm/io.h>
 #include <common.h>
 #include <clk.h>
 #include <dm.h>
@@ -25,9 +26,59 @@ struct generic_ohci {
 	int reset_count;	/* number of reset in reset list */
 };
 
+static int ohci_setup_phy(struct udevice *dev, int index)
+{
+	struct generic_ohci *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = generic_phy_get_by_index(dev, index, &priv->phy);
+	if (ret) {
+		if (ret != -ENOENT) {
+			dev_err(dev, "failed to get usb phy\n");
+			return ret;
+		}
+	} else {
+		ret = generic_phy_init(&priv->phy);
+		if (ret) {
+			dev_err(dev, "failed to init usb phy\n");
+			return ret;
+		}
+
+		ret = generic_phy_power_on(&priv->phy);
+		if (ret) {
+			dev_err(dev, "failed to power on usb phy\n");
+			return generic_phy_exit(&priv->phy);
+		}
+	}
+
+	return 0;
+}
+
+static int ohci_shutdown_phy(struct udevice *dev)
+{
+	struct generic_ohci *priv = dev_get_priv(dev);
+	int ret = 0;
+
+	if (generic_phy_valid(&priv->phy)) {
+		ret = generic_phy_power_off(&priv->phy);
+		if (ret) {
+			dev_err(dev, "failed to power off usb phy\n");
+			return ret;
+		}
+
+		ret = generic_phy_exit(&priv->phy);
+		if (ret) {
+			dev_err(dev, "failed to power off usb phy\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int ohci_usb_probe(struct udevice *dev)
 {
-	struct ohci_regs *regs = (struct ohci_regs *)devfdt_get_addr(dev);
+	struct ohci_regs *regs;
 	struct generic_ohci *priv = dev_get_priv(dev);
 	int i, err, ret, clock_nb, reset_nb;
 
@@ -46,15 +97,15 @@ static int ohci_usb_probe(struct udevice *dev)
 				break;
 
 			err = clk_enable(&priv->clocks[i]);
-			if (err) {
-				error("failed to enable clock %d\n", i);
+			if (err && err != -ENOSYS) {
+				dev_err(dev, "failed to enable clock %d\n", i);
 				clk_free(&priv->clocks[i]);
 				goto clk_err;
 			}
 			priv->clock_count++;
 		}
 	} else if (clock_nb != -ENOENT) {
-		error("failed to get clock phandle(%d)\n", clock_nb);
+		dev_err(dev, "failed to get clock phandle(%d)\n", clock_nb);
 		return clock_nb;
 	}
 
@@ -74,32 +125,22 @@ static int ohci_usb_probe(struct udevice *dev)
 
 			err = reset_deassert(&priv->resets[i]);
 			if (err) {
-				error("failed to deassert reset %d\n", i);
+				dev_err(dev, "failed to deassert reset %d\n", i);
 				reset_free(&priv->resets[i]);
 				goto reset_err;
 			}
 			priv->reset_count++;
 		}
 	} else if (reset_nb != -ENOENT) {
-		error("failed to get reset phandle(%d)\n", reset_nb);
+		dev_err(dev, "failed to get reset phandle(%d)\n", reset_nb);
 		goto clk_err;
 	}
 
-	err = generic_phy_get_by_index(dev, 0, &priv->phy);
-	if (err) {
-		if (err != -ENOENT) {
-			error("failed to get usb phy\n");
-			goto reset_err;
-		}
-	} else {
-
-		err = generic_phy_init(&priv->phy);
-		if (err) {
-			error("failed to init usb phy\n");
-			goto reset_err;
-		}
-	}
+	err = ohci_setup_phy(dev, 0);
+	if (err)
+		goto reset_err;
 
+	regs = map_physmem(dev_read_addr(dev), 0x100, MAP_NOCACHE);
 	err = ohci_register(dev, regs);
 	if (err)
 		goto phy_err;
@@ -107,20 +148,18 @@ static int ohci_usb_probe(struct udevice *dev)
 	return 0;
 
 phy_err:
-	if (generic_phy_valid(&priv->phy)) {
-		ret = generic_phy_exit(&priv->phy);
-		if (ret)
-			error("failed to release phy\n");
-	}
+	ret = ohci_shutdown_phy(dev);
+	if (ret)
+		dev_err(dev, "failed to shutdown usb phy\n");
 
 reset_err:
 	ret = reset_release_all(priv->resets, priv->reset_count);
 	if (ret)
-		error("failed to assert all resets\n");
+		dev_err(dev, "failed to assert all resets\n");
 clk_err:
 	ret = clk_release_all(priv->clocks, priv->clock_count);
 	if (ret)
-		error("failed to disable all clocks\n");
+		dev_err(dev, "failed to disable all clocks\n");
 
 	return err;
 }
@@ -134,11 +173,9 @@ static int ohci_usb_remove(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	if (generic_phy_valid(&priv->phy)) {
-		ret = generic_phy_exit(&priv->phy);
-		if (ret)
-			return ret;
-	}
+	ret = ohci_shutdown_phy(dev);
+	if (ret)
+		return ret;
 
 	ret = reset_release_all(priv->resets, priv->reset_count);
 	if (ret)
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index fdfc870efa..76b9c8d4f4 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -51,8 +51,9 @@
 #endif
 
 #if defined(CONFIG_CPU_ARM920T) || \
-    defined(CONFIG_PCI_OHCI) || \
-    defined(CONFIG_SYS_OHCI_USE_NPS)
+	defined(CONFIG_PCI_OHCI) || \
+	defined(CONFIG_DM_PCI) || \
+	defined(CONFIG_SYS_OHCI_USE_NPS)
 # define OHCI_USE_NPS		/* force NoPowerSwitching mode */
 #endif
 
@@ -65,6 +66,7 @@
 #define OHCI_CONTROL_INIT \
 	(OHCI_CTRL_CBSR & 0x3) | OHCI_CTRL_IE | OHCI_CTRL_PLE
 
+#if !CONFIG_IS_ENABLED(DM_USB)
 #ifdef CONFIG_PCI_OHCI
 static struct pci_device_id ohci_pci_ids[] = {
 	{0x10b9, 0x5237},	/* ULI1575 PCI OHCI module ids */
@@ -74,6 +76,7 @@ static struct pci_device_id ohci_pci_ids[] = {
 	{0, 0}
 };
 #endif
+#endif
 
 #ifdef CONFIG_PCI_EHCI_DEVNO
 static struct pci_device_id ehci_pci_ids[] = {
@@ -121,7 +124,7 @@ static struct pci_device_id ehci_pci_ids[] = {
 #define invalidate_dcache_iso_td(addr) invalidate_dcache_buffer(addr, 32)
 #define invalidate_dcache_hcca(addr) invalidate_dcache_buffer(addr, 256)
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 /*
  * The various ohci_mdelay(1) calls in the code seem unnecessary. We keep
  * them around when building for older boards not yet converted to the dm
@@ -132,7 +135,7 @@ static struct pci_device_id ehci_pci_ids[] = {
 #define ohci_mdelay(x) mdelay(x)
 #endif
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 /* global ohci_t */
 static ohci_t gohci;
 /* this must be aligned to a 256 byte boundary */
@@ -1546,10 +1549,8 @@ static int submit_common_msg(ohci_t *ohci, struct usb_device *dev,
 		return -1;
 	}
 
-#if 0
 	mdelay(10);
 	/* ohci_dump_status(ohci); */
-#endif
 
 	timeout = USB_TIMEOUT_MS(pipe);
 
@@ -1692,7 +1693,7 @@ static int _ohci_destroy_int_queue(ohci_t *ohci, struct usb_device *dev,
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 /* submit routines called from usb.c */
 int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		int transfer_len)
@@ -1703,7 +1704,7 @@ int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 }
 
 int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
-		int transfer_len, int interval)
+		int transfer_len, int interval, bool nonblock)
 {
 	info("submit_int_msg");
 	return submit_common_msg(&gohci, dev, pipe, buffer, transfer_len, NULL,
@@ -1981,7 +1982,7 @@ static int hc_interrupt(ohci_t *ohci)
 
 /*-------------------------------------------------------------------------*/
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 
 /*-------------------------------------------------------------------------*/
 
@@ -2047,8 +2048,11 @@ int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
 		pci_read_config_dword(pdev, PCI_BASE_ADDRESS_0, &base);
 		printf("OHCI regs address 0x%08x\n", base);
 		gohci.regs = (struct ohci_regs *)base;
-	} else
+	} else {
+		printf("%s: OHCI devnr: %d not found\n", __func__,
+		       CONFIG_PCI_OHCI_DEVNO);
 		return -1;
+	}
 #else
 	gohci.regs = (struct ohci_regs *)CONFIG_SYS_USB_OHCI_REGS_BASE;
 #endif
@@ -2131,7 +2135,7 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe,
 }
 #endif
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int ohci_submit_control_msg(struct udevice *dev, struct usb_device *udev,
 				   unsigned long pipe, void *buffer, int length,
 				   struct devrequest *setup)
@@ -2152,7 +2156,7 @@ static int ohci_submit_bulk_msg(struct udevice *dev, struct usb_device *udev,
 
 static int ohci_submit_int_msg(struct udevice *dev, struct usb_device *udev,
 			       unsigned long pipe, void *buffer, int length,
-			       int interval)
+			       int interval, bool nonblock)
 {
 	ohci_t *ohci = dev_get_priv(usb_get_bus(dev));
 
diff --git a/drivers/usb/host/ohci-lpc32xx.c b/drivers/usb/host/ohci-lpc32xx.c
index 2f2b4b90de..44a49807a4 100644
--- a/drivers/usb/host/ohci-lpc32xx.c
+++ b/drivers/usb/host/ohci-lpc32xx.c
@@ -143,8 +143,8 @@ static int usbpll_setup(void)
 	setbits_le32(&clk_pwr->usb_ctrl, CLK_USBCTRL_POSTDIV_2POW(0x01));
 	setbits_le32(&clk_pwr->usb_ctrl, CLK_USBCTRL_PLL_PWRUP);
 
-	ret = wait_for_bit(__func__, &clk_pwr->usb_ctrl, CLK_USBCTRL_PLL_STS,
-			   true, CONFIG_SYS_HZ, false);
+	ret = wait_for_bit_le32(&clk_pwr->usb_ctrl, CLK_USBCTRL_PLL_STS,
+				true, CONFIG_SYS_HZ, false);
 	if (ret)
 		return ret;
 
@@ -178,8 +178,8 @@ int usb_cpu_init(void)
 
 	/* enable I2C clock */
 	writel(OTG_CLK_I2C_EN, &otg->otg_clk_ctrl);
-	ret = wait_for_bit(__func__, &otg->otg_clk_sts, OTG_CLK_I2C_EN, true,
-			   CONFIG_SYS_HZ, false);
+	ret = wait_for_bit_le32(&otg->otg_clk_sts, OTG_CLK_I2C_EN, true,
+				CONFIG_SYS_HZ, false);
 	if (ret)
 		return ret;
 
@@ -199,8 +199,8 @@ int usb_cpu_init(void)
 			 OTG_CLK_I2C_EN | OTG_CLK_HOST_EN;
 	writel(mask, &otg->otg_clk_ctrl);
 
-	ret = wait_for_bit(__func__, &otg->otg_clk_sts, mask, true,
-			   CONFIG_SYS_HZ, false);
+	ret = wait_for_bit_le32(&otg->otg_clk_sts, mask, true,
+				CONFIG_SYS_HZ, false);
 	if (ret)
 		return ret;
 
diff --git a/drivers/usb/host/ohci-sunxi.c b/drivers/usb/host/ohci-sunxi.c
index 133774f6e6..35efa88795 100644
--- a/drivers/usb/host/ohci-sunxi.c
+++ b/drivers/usb/host/ohci-sunxi.c
@@ -26,6 +26,7 @@
 #endif
 
 struct ohci_sunxi_priv {
+	struct sunxi_ccm_reg *ccm;
 	ohci_t ohci;
 	int ahb_gate_mask; /* Mask of ahb_gate0 clk gate bits for this hcd */
 	int usb_gate_mask; /* Mask of usb_clk_cfg clk gate bits for this hcd */
@@ -34,12 +35,15 @@ struct ohci_sunxi_priv {
 
 static int ohci_usb_probe(struct udevice *dev)
 {
-	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
 	struct usb_bus_priv *bus_priv = dev_get_uclass_priv(dev);
 	struct ohci_sunxi_priv *priv = dev_get_priv(dev);
 	struct ohci_regs *regs = (struct ohci_regs *)devfdt_get_addr(dev);
 	int extra_ahb_gate_mask = 0;
 
+	priv->ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	if (IS_ERR(priv->ccm))
+		return PTR_ERR(priv->ccm);
+
 	bus_priv->companion = true;
 
 	/*
@@ -57,11 +61,11 @@ static int ohci_usb_probe(struct udevice *dev)
 	priv->usb_gate_mask <<= priv->phy_index;
 	priv->phy_index++; /* Non otg phys start at 1 */
 
-	setbits_le32(&ccm->ahb_gate0,
+	setbits_le32(&priv->ccm->ahb_gate0,
 		     priv->ahb_gate_mask | extra_ahb_gate_mask);
-	setbits_le32(&ccm->usb_clk_cfg, priv->usb_gate_mask);
+	setbits_le32(&priv->ccm->usb_clk_cfg, priv->usb_gate_mask);
 #ifdef CONFIG_SUNXI_GEN_SUN6I
-	setbits_le32(&ccm->ahb_reset0_cfg,
+	setbits_le32(&priv->ccm->ahb_reset0_cfg,
 		     priv->ahb_gate_mask | extra_ahb_gate_mask);
 #endif
 
@@ -73,7 +77,6 @@ static int ohci_usb_probe(struct udevice *dev)
 
 static int ohci_usb_remove(struct udevice *dev)
 {
-	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
 	struct ohci_sunxi_priv *priv = dev_get_priv(dev);
 	int ret;
 
@@ -84,10 +87,10 @@ static int ohci_usb_remove(struct udevice *dev)
 	sunxi_usb_phy_exit(priv->phy_index);
 
 #ifdef CONFIG_SUNXI_GEN_SUN6I
-	clrbits_le32(&ccm->ahb_reset0_cfg, priv->ahb_gate_mask);
+	clrbits_le32(&priv->ccm->ahb_reset0_cfg, priv->ahb_gate_mask);
 #endif
-	clrbits_le32(&ccm->usb_clk_cfg, priv->usb_gate_mask);
-	clrbits_le32(&ccm->ahb_gate0, priv->ahb_gate_mask);
+	clrbits_le32(&priv->ccm->usb_clk_cfg, priv->usb_gate_mask);
+	clrbits_le32(&priv->ccm->ahb_gate0, priv->ahb_gate_mask);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 2350831932..889b4f4a87 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -14,8 +14,8 @@
 #include <asm/io.h>
 
 #ifdef CONFIG_SYS_OHCI_SWAP_REG_ACCESS
-# define ohci_readl(a) __swap_32(readl(a))
-# define ohci_writel(v, a) writel(__swap_32(v), a)
+# define ohci_readl(a) __swap_32(in_be32((u32 *)a))
+# define ohci_writel(a, b) out_be32((u32 *)b, __swap_32(a))
 #else
 # define ohci_readl(a) readl(a)
 # define ohci_writel(v, a) writel(v, a)
@@ -27,7 +27,7 @@
 #define ED_ALIGNMENT 16
 #endif
 
-#if defined CONFIG_DM_USB && ARCH_DMA_MINALIGN > 32
+#if CONFIG_IS_ENABLED(DM_USB) && ARCH_DMA_MINALIGN > 32
 #define TD_ALIGNMENT ARCH_DMA_MINALIGN
 #else
 #define TD_ALIGNMENT 32
@@ -406,7 +406,7 @@ typedef struct ohci {
 	const char	*slot_name;
 } ohci_t;
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 extern struct dm_usb_ops ohci_usb_ops;
 
 int ohci_register(struct udevice *dev, struct ohci_regs *regs);
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 6ef51906c2..5578c8fe21 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -8,8 +8,11 @@
 
 #include <common.h>
 #include <console.h>
+#include <dm.h>
 #include <usb.h>
 #include <asm/io.h>
+#include <linux/iopoll.h>
+#include <power/regulator.h>
 
 #include "r8a66597.h"
 
@@ -19,34 +22,53 @@
 #define R8A66597_DPRINT(...)
 #endif
 
-static const char hcd_name[] = "r8a66597_hcd";
-static struct r8a66597 gr8a66597;
+static inline struct usb_device *usb_dev_get_parent(struct usb_device *udev)
+{
+	struct udevice *parent = udev->dev->parent;
+
+	/*
+	 * When called from usb-uclass.c: usb_scan_device() udev->dev points
+	 * to the parent udevice, not the actual udevice belonging to the
+	 * udev as the device is not instantiated yet.
+	 *
+	 * If dev is an usb-bus, then we are called from usb_scan_device() for
+	 * an usb-device plugged directly into the root port, return NULL.
+	 */
+	if (device_get_uclass_id(udev->dev) == UCLASS_USB)
+		return NULL;
+
+	/*
+	 * If these 2 are not the same we are being called from
+	 * usb_scan_device() and udev itself is the parent.
+	 */
+	if (dev_get_parent_priv(udev->dev) != udev)
+		return udev;
+
+	/* We are being called normally, use the parent pointer */
+	if (device_get_uclass_id(parent) == UCLASS_USB_HUB)
+		return dev_get_parent_priv(parent);
+
+	return NULL;
+}
 
 static void get_hub_data(struct usb_device *dev, u16 *hub_devnum, u16 *hubport)
 {
-	int i;
+	struct usb_device *parent = usb_dev_get_parent(dev);
 
 	*hub_devnum = 0;
 	*hubport = 0;
 
 	/* check a device connected to root_hub */
-	if ((dev->parent && dev->parent->devnum == 1) ||
-	    (dev->devnum == 1))
+	if ((parent && parent->devnum == 1) ||
+	    dev->devnum == 1)
 		return;
 
-	for (i = 0; i < USB_MAXCHILDREN; i++) {
-		if (dev->parent->children[i] == dev) {
-			*hub_devnum = (u8)dev->parent->devnum;
-			*hubport = i;
-			return;
-		}
-	}
-
-	printf("get_hub_data error.\n");
+	*hub_devnum = (u8)parent->devnum;
+	*hubport = parent->portnr - 1;
 }
 
 static void set_devadd(struct r8a66597 *r8a66597, u8 r8a66597_address,
-			struct usb_device *dev, int port)
+		       struct usb_device *dev, int port)
 {
 	u16 val, usbspd, upphub, hubport;
 	unsigned long devadd_reg = get_devadd_addr(r8a66597_address);
@@ -62,17 +84,6 @@ static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
 	u16 tmp;
 	int i = 0;
 
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
-	do {
-		r8a66597_write(r8a66597, SCKE, SYSCFG0);
-		tmp = r8a66597_read(r8a66597, SYSCFG0);
-		if (i++ > 1000) {
-			printf("register access fail.\n");
-			return -1;
-		}
-	} while ((tmp & SCKE) != SCKE);
-	r8a66597_write(r8a66597, 0x04, 0x02);
-#else
 	do {
 		r8a66597_write(r8a66597, USBE, SYSCFG0);
 		tmp = r8a66597_read(r8a66597, SYSCFG0);
@@ -82,32 +93,30 @@ static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
 		}
 	} while ((tmp & USBE) != USBE);
 	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
-	r8a66597_mdfy(r8a66597, CONFIG_R8A66597_XTAL, XTAL, SYSCFG0);
-
-	i = 0;
-	r8a66597_bset(r8a66597, XCKE, SYSCFG0);
-	do {
-		udelay(1000);
-		tmp = r8a66597_read(r8a66597, SYSCFG0);
-		if (i++ > 500) {
-			printf("register access fail.\n");
-			return -1;
-		}
-	} while ((tmp & SCKE) != SCKE);
-#endif	/* #if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) */
+	/*
+	 * RZ/A Only:
+	 * Bits XTAL(UCKSEL) and UPLLE in SYSCFG0 for USB0 controls both USB0
+	 * and USB1, so we must always set the USB0 register
+	 */
+#if (CONFIG_R8A66597_XTAL == 1)
+	setbits(le16, R8A66597_BASE0, XTAL);
+#endif
+	mdelay(1);
+	setbits(le16, R8A66597_BASE0, UPLLE);
+	mdelay(1);
+	r8a66597_bset(r8a66597, SUSPM, SUSPMODE0);
 
 	return 0;
 }
 
 static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
 {
-	r8a66597_bclr(r8a66597, SCKE, SYSCFG0);
-	udelay(1);
-#if !defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
-	r8a66597_bclr(r8a66597, PLLC, SYSCFG0);
-	r8a66597_bclr(r8a66597, XCKE, SYSCFG0);
+	r8a66597_bclr(r8a66597, SUSPM, SUSPMODE0);
+
+	clrbits(le16, R8A66597_BASE0, UPLLE);
+	mdelay(1);
 	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
-#endif
+	mdelay(1);
 }
 
 static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
@@ -117,8 +126,6 @@ static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 	val = port ? DRPD : DCFM | DRPD;
 	r8a66597_bset(r8a66597, val, get_syscfg_reg(port));
 	r8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));
-
-	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));
 }
 
 static void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)
@@ -148,7 +155,6 @@ static int enable_controller(struct r8a66597 *r8a66597)
 	if (ret < 0)
 		return ret;
 
-	r8a66597_bset(r8a66597, CONFIG_R8A66597_LDRV & LDRV, PINCFG);
 	r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
 	r8a66597_bset(r8a66597, INTL, SOFCFG);
@@ -156,9 +162,9 @@ static int enable_controller(struct r8a66597 *r8a66597)
 	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++)
 		r8a66597_write(r8a66597, 0, get_intenb_reg(port));
 
-	r8a66597_bset(r8a66597, CONFIG_R8A66597_ENDIAN & BIGEND, CFIFOSEL);
-	r8a66597_bset(r8a66597, CONFIG_R8A66597_ENDIAN & BIGEND, D0FIFOSEL);
-	r8a66597_bset(r8a66597, CONFIG_R8A66597_ENDIAN & BIGEND, D1FIFOSEL);
+	r8a66597_bclr(r8a66597, BIGEND, CFIFOSEL);
+	r8a66597_bclr(r8a66597, BIGEND, D0FIFOSEL);
+	r8a66597_bclr(r8a66597, BIGEND, D1FIFOSEL);
 	r8a66597_bset(r8a66597, TRNENSEL, SOFCFG);
 
 	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++)
@@ -266,12 +272,22 @@ static int send_setup_packet(struct r8a66597 *r8a66597, struct usb_device *dev,
 	unsigned long setup_addr = USBREQ;
 	u16 intsts1;
 	int timeout = 3000;
+	u16 dcpctr;
 	u16 devsel = setup->request == USB_REQ_SET_ADDRESS ? 0 : dev->devnum;
 
 	r8a66597_write(r8a66597, make_devsel(devsel) |
 				 (8 << dev->maxpacketsize), DCPMAXP);
 	r8a66597_write(r8a66597, ~(SIGN | SACK), INTSTS1);
 
+	dcpctr = r8a66597_read(r8a66597, DCPCTR);
+	if ((dcpctr & PID) == PID_BUF) {
+		if (readw_poll_timeout(r8a66597->reg + DCPCTR, dcpctr,
+				       dcpctr & BSTS, 1000) < 0) {
+			printf("DCPCTR BSTS timeout!\n");
+			return -ETIMEDOUT;
+		}
+	}
+
 	for (i = 0; i < 4; i++) {
 		r8a66597_write(r8a66597, le16_to_cpu(p[i]), setup_addr);
 		setup_addr += 2;
@@ -307,7 +323,7 @@ static int send_bulk_packet(struct r8a66597 *r8a66597, struct usb_device *dev,
 	R8A66597_DPRINT("%s\n", __func__);
 
 	r8a66597_mdfy(r8a66597, MBW | BULK_OUT_PIPENUM,
-			MBW | CURPIPE, CFIFOSEL);
+		      MBW | CURPIPE, CFIFOSEL);
 	r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, BULK_OUT_PIPENUM);
 	tmp = r8a66597_read(r8a66597, CFIFOCTR);
 	if ((tmp & FRDY) == 0) {
@@ -331,7 +347,7 @@ static int send_bulk_packet(struct r8a66597 *r8a66597, struct usb_device *dev,
 	dev->act_len += size;
 
 	r8a66597_mdfy(r8a66597, PID_BUF, PID,
-			get_pipectr_addr(BULK_OUT_PIPENUM));
+		      get_pipectr_addr(BULK_OUT_PIPENUM));
 
 	while (!(r8a66597_read(r8a66597, BEMPSTS) & (1 << BULK_OUT_PIPENUM)))
 		if (ctrlc())
@@ -340,7 +356,7 @@ static int send_bulk_packet(struct r8a66597 *r8a66597, struct usb_device *dev,
 
 	if (dev->act_len >= transfer_len)
 		r8a66597_mdfy(r8a66597, PID_NAK, PID,
-				get_pipectr_addr(BULK_OUT_PIPENUM));
+			      get_pipectr_addr(BULK_OUT_PIPENUM));
 
 	return 0;
 }
@@ -361,17 +377,17 @@ static int receive_bulk_packet(struct r8a66597 *r8a66597,
 	/* prepare */
 	if (dev->act_len == 0) {
 		r8a66597_mdfy(r8a66597, PID_NAK, PID,
-				get_pipectr_addr(pipenum));
+			      get_pipectr_addr(pipenum));
 		r8a66597_write(r8a66597, ~(1 << pipenum), BRDYSTS);
 
 		r8a66597_write(r8a66597, TRCLR, get_pipetre_addr(pipenum));
 		r8a66597_write(r8a66597,
-				(transfer_len + maxpacket - 1) / maxpacket,
+			       (transfer_len + maxpacket - 1) / maxpacket,
 				get_pipetrn_addr(pipenum));
 		r8a66597_bset(r8a66597, TRENB, get_pipetre_addr(pipenum));
 
 		r8a66597_mdfy(r8a66597, PID_BUF, PID,
-				get_pipectr_addr(pipenum));
+			      get_pipectr_addr(pipenum));
 	}
 
 	r8a66597_mdfy(r8a66597, MBW | pipenum, MBW | CURPIPE, CFIFOSEL);
@@ -448,7 +464,7 @@ static int receive_control_packet(struct r8a66597 *r8a66597,
 }
 
 static int send_status_packet(struct r8a66597 *r8a66597,
-			       unsigned long pipe)
+			      unsigned long pipe)
 {
 	r8a66597_bset(r8a66597, SQSET, DCPCTR);
 	r8a66597_mdfy(r8a66597, PID_NAK, PID, DCPCTR);
@@ -539,16 +555,15 @@ static int check_usb_device_connecting(struct r8a66597 *r8a66597)
 	return -1;	/* fail */
 }
 
-/*-------------------------------------------------------------------------*
- * Virtual Root Hub
- *-------------------------------------------------------------------------*/
+/* Virtual Root Hub */
 
 #include <usbroothubdes.h>
 
-static int r8a66597_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
-			void *buffer, int transfer_len, struct devrequest *cmd)
+static int r8a66597_submit_rh_msg(struct udevice *udev, struct usb_device *dev,
+				  unsigned long pipe, void *buffer,
+				  int transfer_len, struct devrequest *cmd)
 {
-	struct r8a66597 *r8a66597 = &gr8a66597;
+	struct r8a66597 *r8a66597 = dev_get_priv(udev);
 	int leni = transfer_len;
 	int len = 0;
 	int stat = 0;
@@ -616,40 +631,40 @@ static int r8a66597_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
 		}
 		break;
 	case RH_SET_ADDRESS:
-		gr8a66597.rh_devnum = wValue;
+		r8a66597->rh_devnum = wValue;
 		break;
 	case RH_GET_DESCRIPTOR:
 		switch ((wValue & 0xff00) >> 8) {
 		case (0x01): /* device descriptor */
 			len = min_t(unsigned int,
-				  leni,
+				    leni,
 				  min_t(unsigned int,
-				      sizeof(root_hub_dev_des),
+					sizeof(root_hub_dev_des),
 				      wLength));
 			memcpy(buffer, root_hub_dev_des, len);
 			break;
 		case (0x02): /* configuration descriptor */
 			len = min_t(unsigned int,
-				  leni,
+				    leni,
 				  min_t(unsigned int,
-				      sizeof(root_hub_config_des),
+					sizeof(root_hub_config_des),
 				      wLength));
 			memcpy(buffer, root_hub_config_des, len);
 			break;
 		case (0x03): /* string descriptors */
 			if (wValue == 0x0300) {
 				len = min_t(unsigned int,
-					  leni,
+					    leni,
 					  min_t(unsigned int,
-					      sizeof(root_hub_str_index0),
+						sizeof(root_hub_str_index0),
 					      wLength));
 				memcpy(buffer, root_hub_str_index0, len);
 			}
 			if (wValue == 0x0301) {
 				len = min_t(unsigned int,
-					  leni,
+					    leni,
 					  min_t(unsigned int,
-					      sizeof(root_hub_str_index1),
+						sizeof(root_hub_str_index1),
 					      wLength));
 				memcpy(buffer, root_hub_str_index1, len);
 			}
@@ -682,7 +697,8 @@ static int r8a66597_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
 		} else {
 			data[0] += 2;
 			data[8] = (temp & RH_B_DR) >> 8;
-			data[10] = data[9] = 0xff;
+			data[9] = 0xff;
+			data[10] = 0xff;
 		}
 
 		len = min_t(unsigned int, leni,
@@ -692,7 +708,7 @@ static int r8a66597_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
 	}
 
 	case RH_GET_CONFIGURATION:
-		*(__u8 *) buffer = 0x01;
+		*(__u8 *)buffer = 0x01;
 		len = 1;
 		break;
 	case RH_SET_CONFIGURATION:
@@ -712,50 +728,22 @@ static int r8a66597_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
 	return stat;
 }
 
-int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
-		    int transfer_len)
+static int r8a66597_submit_control_msg(struct udevice *udev,
+				       struct usb_device *dev,
+				       unsigned long pipe, void *buffer,
+				       int length, struct devrequest *setup)
 {
-	struct r8a66597 *r8a66597 = &gr8a66597;
-	int ret = 0;
-
-	R8A66597_DPRINT("%s\n", __func__);
-	R8A66597_DPRINT("pipe = %08x, buffer = %p, len = %d, devnum = %d\n",
-			pipe, buffer, transfer_len, dev->devnum);
-
-	set_devadd(r8a66597, dev->devnum, dev, 0);
-
-	pipe_buffer_setting(r8a66597, dev, pipe);
-
-	dev->act_len = 0;
-	while (dev->act_len < transfer_len && ret == 0) {
-		if (ctrlc())
-			return -1;
-
-		if (usb_pipein(pipe))
-			ret = receive_bulk_packet(r8a66597, dev, pipe, buffer,
-							transfer_len);
-		else
-			ret = send_bulk_packet(r8a66597, dev, pipe, buffer,
-							transfer_len);
-	}
-
-	if (ret == 0)
-		dev->status = 0;
-
-	return ret;
-}
-
-int submit_control_msg(struct usb_device *dev, unsigned long pipe,
-		       void *buffer, int transfer_len, struct devrequest *setup)
-{
-	struct r8a66597 *r8a66597 = &gr8a66597;
+	struct r8a66597 *r8a66597 = dev_get_priv(udev);
 	u16 r8a66597_address = setup->request == USB_REQ_SET_ADDRESS ?
 					0 : dev->devnum;
 
+	debug("%s: dev='%s', udev=%p, udev->dev='%s', portnr=%d\n", __func__,
+	      udev->name, dev, dev->dev->name, dev->portnr);
+
 	R8A66597_DPRINT("%s\n", __func__);
 	if (usb_pipedevice(pipe) == r8a66597->rh_devnum)
-		return r8a66597_submit_rh_msg(dev, pipe, buffer, transfer_len,
-						setup);
+		return r8a66597_submit_rh_msg(udev, dev, pipe, buffer,
+					      length, setup);
 
 	R8A66597_DPRINT("%s: setup\n", __func__);
 	set_devadd(r8a66597, r8a66597_address, dev, 0);
@@ -768,7 +756,7 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe,
 	dev->act_len = 0;
 	if (usb_pipein(pipe))
 		if (receive_control_packet(r8a66597, dev, buffer,
-						transfer_len) < 0)
+					   length) < 0)
 			return -1;
 
 	if (send_status_packet(r8a66597, pipe) < 0)
@@ -779,40 +767,131 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe,
 	return 0;
 }
 
-int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
-			int transfer_len, int interval)
+static int r8a66597_submit_bulk_msg(struct udevice *udev,
+				    struct usb_device *dev, unsigned long pipe,
+				    void *buffer, int length)
 {
-	/* no implement */
+	struct r8a66597 *r8a66597 = dev_get_priv(udev);
+	int ret = 0;
+
+	debug("%s: dev='%s', udev=%p\n", __func__, udev->name, dev);
+
 	R8A66597_DPRINT("%s\n", __func__);
-	return 0;
+	R8A66597_DPRINT("pipe = %08x, buffer = %p, len = %d, devnum = %d\n",
+			pipe, buffer, length, dev->devnum);
+
+	set_devadd(r8a66597, dev->devnum, dev, 0);
+
+	pipe_buffer_setting(r8a66597, dev, pipe);
+
+	dev->act_len = 0;
+	while (dev->act_len < length && ret == 0) {
+		if (ctrlc())
+			return -1;
+
+		if (usb_pipein(pipe))
+			ret = receive_bulk_packet(r8a66597, dev, pipe, buffer,
+						  length);
+		else
+			ret = send_bulk_packet(r8a66597, dev, pipe, buffer,
+					       length);
+	}
+
+	if (ret == 0)
+		dev->status = 0;
+
+	return ret;
 }
 
-int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
+static int r8a66597_usb_ofdata_to_platdata(struct udevice *dev)
 {
-	struct r8a66597 *r8a66597 = &gr8a66597;
+	struct r8a66597 *priv = dev_get_priv(dev);
+	fdt_addr_t addr;
 
-	R8A66597_DPRINT("%s\n", __func__);
+	addr = dev_read_addr(dev);
+	if (addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+	priv->reg = addr;
 
-	memset(r8a66597, 0, sizeof(*r8a66597));
-	r8a66597->reg = CONFIG_R8A66597_BASE_ADDR;
+	return 0;
+}
 
-	disable_controller(r8a66597);
+static int r8a66597_usb_probe(struct udevice *dev)
+{
+	struct r8a66597 *priv = dev_get_priv(dev);
+	struct usb_bus_priv *bus_priv = dev_get_uclass_priv(dev);
+	int ret;
+
+	bus_priv->desc_before_addr = true;
+
+	if (CONFIG_IS_ENABLED(DM_REGULATOR)) {
+		ret = device_get_supply_regulator(dev, "vbus-supply",
+						  &priv->vbus_supply);
+		if (ret) {
+			dev_err(dev,
+				"can't get VBUS supply\n");
+			return ret;
+		}
+
+		ret = regulator_set_enable(priv->vbus_supply, true);
+		if (ret) {
+			dev_err(dev,
+				"can't enable VBUS supply\n");
+			return ret;
+		}
+	}
+
+	disable_controller(priv);
 	mdelay(100);
 
-	enable_controller(r8a66597);
-	r8a66597_port_power(r8a66597, 0 , 1);
+	enable_controller(priv);
+	r8a66597_port_power(priv, 0, 1);
 
 	/* check usb device */
-	check_usb_device_connecting(r8a66597);
+	check_usb_device_connecting(priv);
 
 	mdelay(50);
 
 	return 0;
 }
 
-int usb_lowlevel_stop(int index)
+static int r8a66597_usb_remove(struct udevice *dev)
 {
-	disable_controller(&gr8a66597);
+	struct r8a66597 *priv = dev_get_priv(dev);
+	int ret;
+
+	disable_controller(priv);
+
+	if (CONFIG_IS_ENABLED(DM_REGULATOR)) {
+		ret = regulator_set_enable(priv->vbus_supply, false);
+		if (ret) {
+			dev_err(dev,
+				"can't disable VBUS supply\n");
+			return ret;
+		}
+	}
 
 	return 0;
 }
+
+struct dm_usb_ops r8a66597_usb_ops = {
+	.control = r8a66597_submit_control_msg,
+	.bulk = r8a66597_submit_bulk_msg,
+};
+
+static const struct udevice_id r8a66597_usb_ids[] = {
+	{ .compatible = "renesas,rza1-usbhs" },
+	{ }
+};
+
+U_BOOT_DRIVER(usb_r8a66597) = {
+	.name	= "r8a66597_usb",
+	.id	= UCLASS_USB,
+	.of_match = r8a66597_usb_ids,
+	.ofdata_to_platdata = r8a66597_usb_ofdata_to_platdata,
+	.probe	= r8a66597_usb_probe,
+	.remove = r8a66597_usb_remove,
+	.ops	= &r8a66597_usb_ops,
+	.priv_auto_alloc_size = sizeof(struct r8a66597),
+	.flags	= DM_FLAG_ALLOC_PRIV_DMA,
+};
diff --git a/drivers/usb/host/r8a66597.h b/drivers/usb/host/r8a66597.h
index 67dc3c4588..ad06d36978 100644
--- a/drivers/usb/host/r8a66597.h
+++ b/drivers/usb/host/r8a66597.h
@@ -73,9 +73,9 @@
 #define PIPE3TRE	0x98
 #define PIPE3TRN	0x9A
 #define PIPE4TRE	0x9C
-#define	PIPE4TRN	0x9E
-#define	PIPE5TRE	0xA0
-#define	PIPE5TRN	0xA2
+#define PIPE4TRN	0x9E
+#define PIPE5TRE	0xA0
+#define PIPE5TRN	0xA2
 #define DEVADD0		0xD0
 #define DEVADD1		0xD2
 #define DEVADD2		0xD4
@@ -87,306 +87,298 @@
 #define DEVADD8		0xE0
 #define DEVADD9		0xE2
 #define DEVADDA		0xE4
+#define SUSPMODE0	0x102	/* RZ/A only */
 
 /* System Configuration Control Register */
-#define	XTAL		0xC000	/* b15-14: Crystal selection */
-#define	  XTAL48	 0x8000	  /* 48MHz */
-#define	  XTAL24	 0x4000	  /* 24MHz */
-#define	  XTAL12	 0x0000	  /* 12MHz */
-#define	XCKE		0x2000	/* b13: External clock enable */
-#define	PLLC		0x0800	/* b11: PLL control */
-#define	SCKE		0x0400	/* b10: USB clock enable */
-#define	PCSDIS		0x0200	/* b9: not CS wakeup */
-#define	LPSME		0x0100	/* b8: Low power sleep mode */
-#define	HSE		0x0080	/* b7: Hi-speed enable */
-#define	DCFM		0x0040	/* b6: Controller function select  */
-#define	DRPD		0x0020	/* b5: D+/- pull down control */
-#define	DPRPU		0x0010	/* b4: D+ pull up control */
-#define	USBE		0x0001	/* b0: USB module operation enable */
+#define HSE		0x0080	/* b7: Hi-speed enable */
+#define DCFM		0x0040	/* b6: Controller function select  */
+#define DRPD		0x0020	/* b5: D+/- pull down control */
+#define DPRPU		0x0010	/* b4: D+ pull up control */
+#define XTAL		0x0004	/* b2: Crystal selection */
+#define XTAL12		0x0004	/* 12MHz */
+#define XTAL48		0x0000	/* 48MHz */
+#define UPLLE		0x0002	/* b1: internal PLL control */
+#define USBE		0x0001	/* b0: USB module operation enable */
 
 /* System Configuration Status Register */
-#define	OVCBIT		0x8000	/* b15-14: Over-current bit */
-#define	OVCMON		0xC000	/* b15-14: Over-current monitor */
-#define	SOFEA		0x0020	/* b5: SOF monitor */
-#define	IDMON		0x0004	/* b3: ID-pin monitor */
-#define	LNST		0x0003	/* b1-0: D+, D- line status */
-#define	  SE1		 0x0003	  /* SE1 */
-#define	  FS_KSTS	 0x0002	  /* Full-Speed K State */
-#define	  FS_JSTS	 0x0001	  /* Full-Speed J State */
-#define	  LS_JSTS	 0x0002	  /* Low-Speed J State */
-#define	  LS_KSTS	 0x0001	  /* Low-Speed K State */
-#define	  SE0		 0x0000	  /* SE0 */
+#define OVCBIT		0x8000	/* b15-14: Over-current bit */
+#define OVCMON		0xC000	/* b15-14: Over-current monitor */
+#define SOFEA		0x0020	/* b5: SOF monitor */
+#define IDMON		0x0004	/* b3: ID-pin monitor */
+#define LNST		0x0003	/* b1-0: D+, D- line status */
+#define SE1		0x0003	/* SE1 */
+#define FS_KSTS		0x0002	/* Full-Speed K State */
+#define FS_JSTS		0x0001	/* Full-Speed J State */
+#define LS_JSTS		0x0002	/* Low-Speed J State */
+#define LS_KSTS		0x0001	/* Low-Speed K State */
+#define SE0		0x0000	/* SE0 */
 
 /* Device State Control Register */
-#define	EXTLP0		0x0400	/* b10: External port */
-#define	VBOUT		0x0200	/* b9: VBUS output */
-#define	WKUP		0x0100	/* b8: Remote wakeup */
-#define	RWUPE		0x0080	/* b7: Remote wakeup sense */
-#define	USBRST		0x0040	/* b6: USB reset enable */
-#define	RESUME		0x0020	/* b5: Resume enable */
-#define	UACT		0x0010	/* b4: USB bus enable */
-#define	RHST		0x0007	/* b1-0: Reset handshake status */
-#define	  HSPROC	 0x0004	  /* HS handshake is processing */
-#define	  HSMODE	 0x0003	  /* Hi-Speed mode */
-#define	  FSMODE	 0x0002	  /* Full-Speed mode */
-#define	  LSMODE	 0x0001	  /* Low-Speed mode */
-#define	  UNDECID	 0x0000	  /* Undecided */
+#define EXTLP0		0x0400	/* b10: External port */
+#define VBOUT		0x0200	/* b9: VBUS output */
+#define WKUP		0x0100	/* b8: Remote wakeup */
+#define RWUPE		0x0080	/* b7: Remote wakeup sense */
+#define USBRST		0x0040	/* b6: USB reset enable */
+#define RESUME		0x0020	/* b5: Resume enable */
+#define UACT		0x0010	/* b4: USB bus enable */
+#define RHST		0x0007	/* b1-0: Reset handshake status */
+#define HSPROC		0x0004	/* HS handshake is processing */
+#define HSMODE		0x0003	/* Hi-Speed mode */
+#define FSMODE		0x0002	/* Full-Speed mode */
+#define LSMODE		0x0001	/* Low-Speed mode */
+#define UNDECID		0x0000	/* Undecided */
 
 /* Test Mode Register */
-#define	UTST			0x000F	/* b3-0: Test select */
-#define	  H_TST_PACKET		 0x000C	  /* HOST TEST Packet */
-#define	  H_TST_SE0_NAK		 0x000B	  /* HOST TEST SE0 NAK */
-#define	  H_TST_K		 0x000A	  /* HOST TEST K */
-#define	  H_TST_J		 0x0009	  /* HOST TEST J */
-#define	  H_TST_NORMAL		 0x0000	  /* HOST Normal Mode */
-#define	  P_TST_PACKET		 0x0004	  /* PERI TEST Packet */
-#define	  P_TST_SE0_NAK		 0x0003	  /* PERI TEST SE0 NAK */
-#define	  P_TST_K		 0x0002	  /* PERI TEST K */
-#define	  P_TST_J		 0x0001	  /* PERI TEST J */
-#define	  P_TST_NORMAL		 0x0000	  /* PERI Normal Mode */
+#define UTST		0x000F	/* b3-0: Test select */
+#define H_TST_PACKET	0x000C	/* HOST TEST Packet */
+#define H_TST_SE0_NAK	0x000B	/* HOST TEST SE0 NAK */
+#define H_TST_K		0x000A	/* HOST TEST K */
+#define H_TST_J		0x0009	/* HOST TEST J */
+#define H_TST_NORMAL	0x0000	/* HOST Normal Mode */
+#define P_TST_PACKET	0x0004	/* PERI TEST Packet */
+#define P_TST_SE0_NAK	0x0003	/* PERI TEST SE0 NAK */
+#define P_TST_K		0x0002	/* PERI TEST K */
+#define P_TST_J		0x0001	/* PERI TEST J */
+#define P_TST_NORMAL	0x0000	/* PERI Normal Mode */
 
 /* Data Pin Configuration Register */
-#define	LDRV			0x8000	/* b15: Drive Current Adjust */
-#define	  VIF1			  0x0000		/* VIF = 1.8V */
-#define	  VIF3			  0x8000		/* VIF = 3.3V */
-#define	INTA			0x0001	/* b1: USB INT-pin active */
+#define LDRV		0x8000	/* b15: Drive Current Adjust */
+#define VIF1		0x0000	/* VIF = 1.8V */
+#define VIF3		0x8000	/* VIF = 3.3V */
+#define INTA		0x0001	/* b1: USB INT-pin active */
 
 /* DMAx Pin Configuration Register */
-#define	DREQA			0x4000	/* b14: Dreq active select */
-#define	BURST			0x2000	/* b13: Burst mode */
-#define	DACKA			0x0400	/* b10: Dack active select */
-#define	DFORM			0x0380	/* b9-7: DMA mode select */
-#define	  CPU_ADR_RD_WR		 0x0000	  /* Address + RD/WR mode (CPU bus) */
-#define	  CPU_DACK_RD_WR	 0x0100	  /* DACK + RD/WR mode (CPU bus) */
-#define	  CPU_DACK_ONLY		 0x0180	  /* DACK only mode (CPU bus) */
-#define	  SPLIT_DACK_ONLY	 0x0200	  /* DACK only mode (SPLIT bus) */
-#define	DENDA			0x0040	/* b6: Dend active select */
-#define	PKTM			0x0020	/* b5: Packet mode */
-#define	DENDE			0x0010	/* b4: Dend enable */
-#define	OBUS			0x0004	/* b2: OUTbus mode */
+#define DREQA		0x4000	/* b14: Dreq active select */
+#define BURST		0x2000	/* b13: Burst mode */
+#define DACKA		0x0400	/* b10: Dack active select */
+#define DFORM		0x0380	/* b9-7: DMA mode select */
+#define CPU_ADR_RD_WR	0x0000	/* Address + RD/WR mode (CPU bus) */
+#define CPU_DACK_RD_WR	0x0100	/* DACK + RD/WR mode (CPU bus) */
+#define CPU_DACK_ONLY	0x0180	/* DACK only mode (CPU bus) */
+#define SPLIT_DACK_ONLY	0x0200	/* DACK only mode (SPLIT bus) */
+#define DENDA		0x0040	/* b6: Dend active select */
+#define PKTM		0x0020	/* b5: Packet mode */
+#define DENDE		0x0010	/* b4: Dend enable */
+#define OBUS		0x0004	/* b2: OUTbus mode */
 
 /* CFIFO/DxFIFO Port Select Register */
-#define	RCNT		0x8000	/* b15: Read count mode */
-#define	REW		0x4000	/* b14: Buffer rewind */
-#define	DCLRM		0x2000	/* b13: DMA buffer clear mode */
-#define	DREQE		0x1000	/* b12: DREQ output enable */
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
-#define	MBW		0x0800
-#else
-#define	MBW		0x0400	/* b10: Maximum bit width for FIFO access */
-#endif
-#define	  MBW_8		 0x0000	  /*  8bit */
-#define	  MBW_16	 0x0400	  /* 16bit */
-#define	BIGEND		0x0100	/* b8: Big endian mode */
-#define	  BYTE_LITTLE	 0x0000		/* little dendian */
-#define	  BYTE_BIG	 0x0100		/* big endifan */
-#define	ISEL		0x0020	/* b5: DCP FIFO port direction select */
-#define	CURPIPE		0x000F	/* b2-0: PIPE select */
+#define RCNT		0x8000	/* b15: Read count mode */
+#define REW		0x4000	/* b14: Buffer rewind */
+#define DCLRM		0x2000	/* b13: DMA buffer clear mode */
+#define DREQE		0x1000	/* b12: DREQ output enable */
+#define MBW		0x0800	/* b10: Maximum bit width for FIFO access */
+#define MBW_8		0x0000	/*  8bit */
+#define MBW_16		0x0400	/* 16bit */
+#define MBW_32		0x0800	/* 32bit */
+#define BIGEND		0x0100	/* b8: Big endian mode */
+#define BYTE_LITTLE	0x0000	/* little dendian */
+#define BYTE_BIG	0x0100	/* big endifan */
+#define ISEL		0x0020	/* b5: DCP FIFO port direction select */
+#define CURPIPE		0x000F	/* b2-0: PIPE select */
 
 /* CFIFO/DxFIFO Port Control Register */
-#define	BVAL		0x8000	/* b15: Buffer valid flag */
-#define	BCLR		0x4000	/* b14: Buffer clear */
-#define	FRDY		0x2000	/* b13: FIFO ready */
-#define	DTLN		0x0FFF	/* b11-0: FIFO received data length */
+#define BVAL		0x8000	/* b15: Buffer valid flag */
+#define BCLR		0x4000	/* b14: Buffer clear */
+#define FRDY		0x2000	/* b13: FIFO ready */
+#define DTLN		0x0FFF	/* b11-0: FIFO received data length */
 
 /* Interrupt Enable Register 0 */
-#define	VBSE	0x8000	/* b15: VBUS interrupt */
-#define	RSME	0x4000	/* b14: Resume interrupt */
-#define	SOFE	0x2000	/* b13: Frame update interrupt */
-#define	DVSE	0x1000	/* b12: Device state transition interrupt */
-#define	CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
-#define	BEMPE	0x0400	/* b10: Buffer empty interrupt */
-#define	NRDYE	0x0200	/* b9: Buffer not ready interrupt */
-#define	BRDYE	0x0100	/* b8: Buffer ready interrupt */
+#define VBSE	0x8000	/* b15: VBUS interrupt */
+#define RSME	0x4000	/* b14: Resume interrupt */
+#define SOFE	0x2000	/* b13: Frame update interrupt */
+#define DVSE	0x1000	/* b12: Device state transition interrupt */
+#define CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
+#define BEMPE	0x0400	/* b10: Buffer empty interrupt */
+#define NRDYE	0x0200	/* b9: Buffer not ready interrupt */
+#define BRDYE	0x0100	/* b8: Buffer ready interrupt */
 
 /* Interrupt Enable Register 1 */
-#define	OVRCRE		0x8000	/* b15: Over-current interrupt */
-#define	BCHGE		0x4000	/* b14: USB us chenge interrupt */
-#define	DTCHE		0x1000	/* b12: Detach sense interrupt */
-#define	ATTCHE		0x0800	/* b11: Attach sense interrupt */
-#define	EOFERRE		0x0040	/* b6: EOF error interrupt */
-#define	SIGNE		0x0020	/* b5: SETUP IGNORE interrupt */
-#define	SACKE		0x0010	/* b4: SETUP ACK interrupt */
+#define OVRCRE		0x8000	/* b15: Over-current interrupt */
+#define BCHGE		0x4000	/* b14: USB us chenge interrupt */
+#define DTCHE		0x1000	/* b12: Detach sense interrupt */
+#define ATTCHE		0x0800	/* b11: Attach sense interrupt */
+#define EOFERRE		0x0040	/* b6: EOF error interrupt */
+#define SIGNE		0x0020	/* b5: SETUP IGNORE interrupt */
+#define SACKE		0x0010	/* b4: SETUP ACK interrupt */
 
 /* BRDY Interrupt Enable/Status Register */
-#define	BRDY9		0x0200	/* b9: PIPE9 */
-#define	BRDY8		0x0100	/* b8: PIPE8 */
-#define	BRDY7		0x0080	/* b7: PIPE7 */
-#define	BRDY6		0x0040	/* b6: PIPE6 */
-#define	BRDY5		0x0020	/* b5: PIPE5 */
-#define	BRDY4		0x0010	/* b4: PIPE4 */
-#define	BRDY3		0x0008	/* b3: PIPE3 */
-#define	BRDY2		0x0004	/* b2: PIPE2 */
-#define	BRDY1		0x0002	/* b1: PIPE1 */
-#define	BRDY0		0x0001	/* b1: PIPE0 */
+#define BRDY9		0x0200	/* b9: PIPE9 */
+#define BRDY8		0x0100	/* b8: PIPE8 */
+#define BRDY7		0x0080	/* b7: PIPE7 */
+#define BRDY6		0x0040	/* b6: PIPE6 */
+#define BRDY5		0x0020	/* b5: PIPE5 */
+#define BRDY4		0x0010	/* b4: PIPE4 */
+#define BRDY3		0x0008	/* b3: PIPE3 */
+#define BRDY2		0x0004	/* b2: PIPE2 */
+#define BRDY1		0x0002	/* b1: PIPE1 */
+#define BRDY0		0x0001	/* b1: PIPE0 */
 
 /* NRDY Interrupt Enable/Status Register */
-#define	NRDY9		0x0200	/* b9: PIPE9 */
-#define	NRDY8		0x0100	/* b8: PIPE8 */
-#define	NRDY7		0x0080	/* b7: PIPE7 */
-#define	NRDY6		0x0040	/* b6: PIPE6 */
-#define	NRDY5		0x0020	/* b5: PIPE5 */
-#define	NRDY4		0x0010	/* b4: PIPE4 */
-#define	NRDY3		0x0008	/* b3: PIPE3 */
-#define	NRDY2		0x0004	/* b2: PIPE2 */
-#define	NRDY1		0x0002	/* b1: PIPE1 */
-#define	NRDY0		0x0001	/* b1: PIPE0 */
+#define NRDY9		0x0200	/* b9: PIPE9 */
+#define NRDY8		0x0100	/* b8: PIPE8 */
+#define NRDY7		0x0080	/* b7: PIPE7 */
+#define NRDY6		0x0040	/* b6: PIPE6 */
+#define NRDY5		0x0020	/* b5: PIPE5 */
+#define NRDY4		0x0010	/* b4: PIPE4 */
+#define NRDY3		0x0008	/* b3: PIPE3 */
+#define NRDY2		0x0004	/* b2: PIPE2 */
+#define NRDY1		0x0002	/* b1: PIPE1 */
+#define NRDY0		0x0001	/* b1: PIPE0 */
 
 /* BEMP Interrupt Enable/Status Register */
-#define	BEMP9		0x0200	/* b9: PIPE9 */
-#define	BEMP8		0x0100	/* b8: PIPE8 */
-#define	BEMP7		0x0080	/* b7: PIPE7 */
-#define	BEMP6		0x0040	/* b6: PIPE6 */
-#define	BEMP5		0x0020	/* b5: PIPE5 */
-#define	BEMP4		0x0010	/* b4: PIPE4 */
-#define	BEMP3		0x0008	/* b3: PIPE3 */
-#define	BEMP2		0x0004	/* b2: PIPE2 */
-#define	BEMP1		0x0002	/* b1: PIPE1 */
-#define	BEMP0		0x0001	/* b0: PIPE0 */
+#define BEMP9		0x0200	/* b9: PIPE9 */
+#define BEMP8		0x0100	/* b8: PIPE8 */
+#define BEMP7		0x0080	/* b7: PIPE7 */
+#define BEMP6		0x0040	/* b6: PIPE6 */
+#define BEMP5		0x0020	/* b5: PIPE5 */
+#define BEMP4		0x0010	/* b4: PIPE4 */
+#define BEMP3		0x0008	/* b3: PIPE3 */
+#define BEMP2		0x0004	/* b2: PIPE2 */
+#define BEMP1		0x0002	/* b1: PIPE1 */
+#define BEMP0		0x0001	/* b0: PIPE0 */
 
 /* SOF Pin Configuration Register */
-#define	TRNENSEL	0x0100	/* b8: Select transaction enable period */
-#define	BRDYM		0x0040	/* b6: BRDY clear timing */
-#define	INTL		0x0020	/* b5: Interrupt sense select */
-#define	EDGESTS		0x0010	/* b4:  */
-#define	SOFMODE		0x000C	/* b3-2: SOF pin select */
-#define	  SOF_125US	 0x0008	  /* SOF OUT 125us Frame Signal */
-#define	  SOF_1MS	 0x0004	  /* SOF OUT 1ms Frame Signal */
-#define	  SOF_DISABLE	 0x0000	  /* SOF OUT Disable */
+#define TRNENSEL	0x0100	/* b8: Select transaction enable period */
+#define BRDYM		0x0040	/* b6: BRDY clear timing */
+#define INTL		0x0020	/* b5: Interrupt sense select */
+#define EDGESTS		0x0010	/* b4:  */
+#define SOFMODE		0x000C	/* b3-2: SOF pin select */
+#define SOF_125US	0x0008	/* SOF OUT 125us Frame Signal */
+#define SOF_1MS		0x0004	/* SOF OUT 1ms Frame Signal */
+#define SOF_DISABLE	0x0000	/* SOF OUT Disable */
 
 /* Interrupt Status Register 0 */
-#define	VBINT	0x8000	/* b15: VBUS interrupt */
-#define	RESM	0x4000	/* b14: Resume interrupt */
-#define	SOFR	0x2000	/* b13: SOF frame update interrupt */
-#define	DVST	0x1000	/* b12: Device state transition interrupt */
-#define	CTRT	0x0800	/* b11: Control transfer stage transition interrupt */
-#define	BEMP	0x0400	/* b10: Buffer empty interrupt */
-#define	NRDY	0x0200	/* b9: Buffer not ready interrupt */
-#define	BRDY	0x0100	/* b8: Buffer ready interrupt */
-#define	VBSTS	0x0080	/* b7: VBUS input port */
-#define	DVSQ	0x0070	/* b6-4: Device state */
-#define	  DS_SPD_CNFG	 0x0070	  /* Suspend Configured */
-#define	  DS_SPD_ADDR	 0x0060	  /* Suspend Address */
-#define	  DS_SPD_DFLT	 0x0050	  /* Suspend Default */
-#define	  DS_SPD_POWR	 0x0040	  /* Suspend Powered */
-#define	  DS_SUSP	 0x0040	  /* Suspend */
-#define	  DS_CNFG	 0x0030	  /* Configured */
-#define	  DS_ADDS	 0x0020	  /* Address */
-#define	  DS_DFLT	 0x0010	  /* Default */
-#define	  DS_POWR	 0x0000	  /* Powered */
-#define	DVSQS		0x0030	/* b5-4: Device state */
-#define	VALID		0x0008	/* b3: Setup packet detected flag */
-#define	CTSQ		0x0007	/* b2-0: Control transfer stage */
-#define	  CS_SQER	 0x0006	  /* Sequence error */
-#define	  CS_WRND	 0x0005	  /* Control write nodata status stage */
-#define	  CS_WRSS	 0x0004	  /* Control write status stage */
-#define	  CS_WRDS	 0x0003	  /* Control write data stage */
-#define	  CS_RDSS	 0x0002	  /* Control read status stage */
-#define	  CS_RDDS	 0x0001	  /* Control read data stage */
-#define	  CS_IDST	 0x0000	  /* Idle or setup stage */
+#define VBINT	0x8000	/* b15: VBUS interrupt */
+#define RESM	0x4000	/* b14: Resume interrupt */
+#define SOFR	0x2000	/* b13: SOF frame update interrupt */
+#define DVST	0x1000	/* b12: Device state transition interrupt */
+#define CTRT	0x0800	/* b11: Control transfer stage transition interrupt */
+#define BEMP	0x0400	/* b10: Buffer empty interrupt */
+#define NRDY	0x0200	/* b9: Buffer not ready interrupt */
+#define BRDY	0x0100	/* b8: Buffer ready interrupt */
+#define VBSTS	0x0080	/* b7: VBUS input port */
+#define DVSQ	0x0070	/* b6-4: Device state */
+#define DS_SPD_CNFG	0x0070	/* Suspend Configured */
+#define DS_SPD_ADDR	0x0060	/* Suspend Address */
+#define DS_SPD_DFLT	0x0050	/* Suspend Default */
+#define DS_SPD_POWR	0x0040	/* Suspend Powered */
+#define DS_SUSP		0x0040	/* Suspend */
+#define DS_CNFG		0x0030	/* Configured */
+#define DS_ADDS		0x0020	/* Address */
+#define DS_DFLT		0x0010	/* Default */
+#define DS_POWR		0x0000	/* Powered */
+#define DVSQS		0x0030	/* b5-4: Device state */
+#define VALID		0x0008	/* b3: Setup packet detected flag */
+#define CTSQ		0x0007	/* b2-0: Control transfer stage */
+#define CS_SQER		0x0006	/* Sequence error */
+#define CS_WRND		0x0005	/* Control write nodata status stage */
+#define CS_WRSS		0x0004	/* Control write status stage */
+#define CS_WRDS		0x0003	/* Control write data stage */
+#define CS_RDSS		0x0002	/* Control read status stage */
+#define CS_RDDS		0x0001	/* Control read data stage */
+#define CS_IDST		0x0000	/* Idle or setup stage */
 
 /* Interrupt Status Register 1 */
-#define	OVRCR		0x8000	/* b15: Over-current interrupt */
-#define	BCHG		0x4000	/* b14: USB bus chenge interrupt */
-#define	DTCH		0x1000	/* b12: Detach sense interrupt */
-#define	ATTCH		0x0800	/* b11: Attach sense interrupt */
-#define	EOFERR		0x0040	/* b6: EOF-error interrupt */
-#define	SIGN		0x0020	/* b5: Setup ignore interrupt */
-#define	SACK		0x0010	/* b4: Setup acknowledge interrupt */
+#define OVRCR		0x8000	/* b15: Over-current interrupt */
+#define BCHG		0x4000	/* b14: USB bus chenge interrupt */
+#define DTCH		0x1000	/* b12: Detach sense interrupt */
+#define ATTCH		0x0800	/* b11: Attach sense interrupt */
+#define EOFERR		0x0040	/* b6: EOF-error interrupt */
+#define SIGN		0x0020	/* b5: Setup ignore interrupt */
+#define SACK		0x0010	/* b4: Setup acknowledge interrupt */
 
 /* Frame Number Register */
-#define	OVRN		0x8000	/* b15: Overrun error */
-#define	CRCE		0x4000	/* b14: Received data error */
-#define	FRNM		0x07FF	/* b10-0: Frame number */
+#define OVRN		0x8000	/* b15: Overrun error */
+#define CRCE		0x4000	/* b14: Received data error */
+#define FRNM		0x07FF	/* b10-0: Frame number */
 
 /* Micro Frame Number Register */
-#define	UFRNM		0x0007	/* b2-0: Micro frame number */
+#define UFRNM		0x0007	/* b2-0: Micro frame number */
 
 /* Default Control Pipe Maxpacket Size Register */
 /* Pipe Maxpacket Size Register */
-#define	DEVSEL	0xF000	/* b15-14: Device address select */
-#define	MAXP	0x007F	/* b6-0: Maxpacket size of default control pipe */
+#define DEVSEL	0xF000	/* b15-14: Device address select */
+#define MAXP	0x007F	/* b6-0: Maxpacket size of default control pipe */
 
 /* Default Control Pipe Control Register */
-#define	BSTS		0x8000	/* b15: Buffer status */
-#define	SUREQ		0x4000	/* b14: Send USB request  */
-#define	CSCLR		0x2000	/* b13: complete-split status clear */
-#define	CSSTS		0x1000	/* b12: complete-split status */
-#define	SUREQCLR	0x0800	/* b11: stop setup request */
-#define	SQCLR		0x0100	/* b8: Sequence toggle bit clear */
-#define	SQSET		0x0080	/* b7: Sequence toggle bit set */
-#define	SQMON		0x0040	/* b6: Sequence toggle bit monitor */
-#define	PBUSY		0x0020	/* b5: pipe busy */
-#define	PINGE		0x0010	/* b4: ping enable */
-#define	CCPL		0x0004	/* b2: Enable control transfer complete */
-#define	PID		0x0003	/* b1-0: Response PID */
-#define	  PID_STALL11	 0x0003	  /* STALL */
-#define	  PID_STALL	 0x0002	  /* STALL */
-#define	  PID_BUF	 0x0001	  /* BUF */
-#define	  PID_NAK	 0x0000	  /* NAK */
+#define BSTS		0x8000	/* b15: Buffer status */
+#define SUREQ		0x4000	/* b14: Send USB request  */
+#define CSCLR		0x2000	/* b13: complete-split status clear */
+#define CSSTS		0x1000	/* b12: complete-split status */
+#define SUREQCLR	0x0800	/* b11: stop setup request */
+#define SQCLR		0x0100	/* b8: Sequence toggle bit clear */
+#define SQSET		0x0080	/* b7: Sequence toggle bit set */
+#define SQMON		0x0040	/* b6: Sequence toggle bit monitor */
+#define PBUSY		0x0020	/* b5: pipe busy */
+#define PINGE		0x0010	/* b4: ping enable */
+#define CCPL		0x0004	/* b2: Enable control transfer complete */
+#define PID		0x0003	/* b1-0: Response PID */
+#define PID_STALL11	0x0003	/* STALL */
+#define PID_STALL	0x0002	/* STALL */
+#define PID_BUF		0x0001	/* BUF */
+#define PID_NAK		0x0000	/* NAK */
 
 /* Pipe Window Select Register */
-#define	PIPENM		0x0007	/* b2-0: Pipe select */
+#define PIPENM		0x0007	/* b2-0: Pipe select */
 
 /* Pipe Configuration Register */
-#define	R8A66597_TYP	0xC000	/* b15-14: Transfer type */
-#define	  R8A66597_ISO	 0xC000		  /* Isochronous */
-#define	  R8A66597_INT	 0x8000		  /* Interrupt */
-#define	  R8A66597_BULK	 0x4000		  /* Bulk */
-#define	R8A66597_BFRE	0x0400	/* b10: Buffer ready interrupt mode select */
-#define	R8A66597_DBLB	0x0200	/* b9: Double buffer mode select */
-#define	R8A66597_CNTMD	0x0100	/* b8: Continuous transfer mode select */
-#define	R8A66597_SHTNAK	0x0080	/* b7: Transfer end NAK */
-#define	R8A66597_DIR	0x0010	/* b4: Transfer direction select */
-#define	R8A66597_EPNUM	0x000F	/* b3-0: Eendpoint number select */
+#define R8A66597_TYP	0xC000	/* b15-14: Transfer type */
+#define R8A66597_ISO	0xC000	/* Isochronous */
+#define R8A66597_INT	0x8000	/* Interrupt */
+#define R8A66597_BULK	0x4000	/* Bulk */
+#define R8A66597_BFRE	0x0400	/* b10: Buffer ready interrupt mode select */
+#define R8A66597_DBLB	0x0200	/* b9: Double buffer mode select */
+#define R8A66597_CNTMD	0x0100	/* b8: Continuous transfer mode select */
+#define R8A66597_SHTNAK	0x0080	/* b7: Transfer end NAK */
+#define R8A66597_DIR	0x0010	/* b4: Transfer direction select */
+#define R8A66597_EPNUM	0x000F	/* b3-0: Eendpoint number select */
 
 /* Pipe Buffer Configuration Register */
-#define	BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
-#define	BUFNMB		0x007F	/* b6-0: Pipe buffer number */
-#define	PIPE0BUF	256
-#define	PIPExBUF	64
+#define BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
+#define BUFNMB		0x007F	/* b6-0: Pipe buffer number */
+#define PIPE0BUF	256
+#define PIPExBUF	64
 
 /* Pipe Maxpacket Size Register */
-#define	MXPS		0x07FF	/* b10-0: Maxpacket size */
+#define MXPS	0x07FF	/* b10-0: Maxpacket size */
 
 /* Pipe Cycle Configuration Register */
-#define	IFIS	0x1000	/* b12: Isochronous in-buffer flush mode select */
-#define	IITV	0x0007	/* b2-0: Isochronous interval */
+#define IFIS	0x1000	/* b12: Isochronous in-buffer flush mode select */
+#define IITV	0x0007	/* b2-0: Isochronous interval */
 
 /* Pipex Control Register */
-#define	BSTS	0x8000	/* b15: Buffer status */
-#define	INBUFM	0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
-#define	CSCLR	0x2000	/* b13: complete-split status clear */
-#define	CSSTS	0x1000	/* b12: complete-split status */
-#define	ATREPM	0x0400	/* b10: Auto repeat mode */
-#define	ACLRM	0x0200	/* b9: Out buffer auto clear mode */
-#define	SQCLR	0x0100	/* b8: Sequence toggle bit clear */
-#define	SQSET	0x0080	/* b7: Sequence toggle bit set */
-#define	SQMON	0x0040	/* b6: Sequence toggle bit monitor */
-#define	PBUSY	0x0020	/* b5: pipe busy */
-#define	PID	0x0003	/* b1-0: Response PID */
+#define BSTS	0x8000	/* b15: Buffer status */
+#define INBUFM	0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
+#define CSCLR	0x2000	/* b13: complete-split status clear */
+#define CSSTS	0x1000	/* b12: complete-split status */
+#define ATREPM	0x0400	/* b10: Auto repeat mode */
+#define ACLRM	0x0200	/* b9: Out buffer auto clear mode */
+#define SQCLR	0x0100	/* b8: Sequence toggle bit clear */
+#define SQSET	0x0080	/* b7: Sequence toggle bit set */
+#define SQMON	0x0040	/* b6: Sequence toggle bit monitor */
+#define PBUSY	0x0020	/* b5: pipe busy */
+#define PID	0x0003	/* b1-0: Response PID */
 
 /* PIPExTRE */
-#define	TRENB		0x0200	/* b9: Transaction counter enable */
-#define	TRCLR		0x0100	/* b8: Transaction counter clear */
+#define TRENB		0x0200	/* b9: Transaction counter enable */
+#define TRCLR		0x0100	/* b8: Transaction counter clear */
 
 /* PIPExTRN */
-#define	TRNCNT		0xFFFF	/* b15-0: Transaction counter */
+#define TRNCNT		0xFFFF	/* b15-0: Transaction counter */
 
 /* DEVADDx */
-#define	UPPHUB		0x7800
-#define	HUBPORT		0x0700
-#define	USBSPD		0x00C0
-#define	RTPORT		0x0001
+#define UPPHUB		0x7800
+#define HUBPORT		0x0700
+#define USBSPD		0x00C0
+#define RTPORT		0x0001
+
+/* Suspend Mode Register */
+#define SUSPM		0x4000	/* b14: Suspend */
 
 #define R8A66597_MAX_NUM_PIPE		10
 #define R8A66597_BUF_BSIZE		8
 #define R8A66597_MAX_DEVICE		10
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
-#define R8A66597_MAX_ROOT_HUB		1
-#else
 #define R8A66597_MAX_ROOT_HUB		2
-#endif
 #define R8A66597_MAX_SAMPLING		5
 #define R8A66597_RH_POLL_TIME		10
 
@@ -396,9 +388,7 @@
 #define BULK_OUT_PIPENUM	4
 #define BULK_OUT_BUFNUM		40
 
-#define check_bulk_or_isoc(pipenum)	((pipenum >= 1 && pipenum <= 5))
-#define check_interrupt(pipenum)	((pipenum >= 6 && pipenum <= 9))
-#define make_devsel(addr)		(addr << 12)
+#define make_devsel(addr)		((addr) << 12)
 
 struct r8a66597 {
 	unsigned long reg;
@@ -407,11 +397,12 @@ struct r8a66597 {
 	unsigned short port_change;
 	u16 speed;	/* HSMODE or FSMODE or LSMODE */
 	unsigned char rh_devnum;
+	struct udevice *vbus_supply;
 };
 
 static inline u16 r8a66597_read(struct r8a66597 *r8a66597, unsigned long offset)
 {
-	return inw(r8a66597->reg + offset);
+	return readw(r8a66597->reg + offset);
 }
 
 static inline void r8a66597_read_fifo(struct r8a66597 *r8a66597,
@@ -419,32 +410,25 @@ static inline void r8a66597_read_fifo(struct r8a66597 *r8a66597,
 				      int len)
 {
 	int i;
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
 	unsigned long fifoaddr = r8a66597->reg + offset;
 	unsigned long count;
 	unsigned long *p = buf;
 
 	count = len / 4;
 	for (i = 0; i < count; i++)
-		p[i] = inl(r8a66597->reg + offset);
+		p[i] = readl(r8a66597->reg + offset);
 
 	if (len & 0x00000003) {
-		unsigned long tmp = inl(fifoaddr);
+		unsigned long tmp = readl(fifoaddr);
+
 		memcpy((unsigned char *)buf + count * 4, &tmp, len & 0x03);
 	}
-#else
-	unsigned short *p = buf;
-
-	len = (len + 1) / 2;
-	for (i = 0; i < len; i++)
-		p[i] = inw(r8a66597->reg + offset);
-#endif
 }
 
 static inline void r8a66597_write(struct r8a66597 *r8a66597, u16 val,
 				  unsigned long offset)
 {
-	outw(val, r8a66597->reg + offset);
+	writew(val, r8a66597->reg + offset);
 }
 
 static inline void r8a66597_write_fifo(struct r8a66597 *r8a66597,
@@ -453,43 +437,30 @@ static inline void r8a66597_write_fifo(struct r8a66597 *r8a66597,
 {
 	int i;
 	unsigned long fifoaddr = r8a66597->reg + offset;
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
 	unsigned long count;
 	unsigned char *pb;
 	unsigned long *p = buf;
 
 	count = len / 4;
 	for (i = 0; i < count; i++)
-		outl(p[i], fifoaddr);
+		writel(p[i], fifoaddr);
 
 	if (len & 0x00000003) {
 		pb = (unsigned char *)buf + count * 4;
 		for (i = 0; i < (len & 0x00000003); i++) {
 			if (r8a66597_read(r8a66597, CFIFOSEL) & BIGEND)
-				outb(pb[i], fifoaddr + i);
+				writeb(pb[i], fifoaddr + i);
 			else
-				outb(pb[i], fifoaddr + 3 - i);
+				writeb(pb[i], fifoaddr + 3 - i);
 		}
 	}
-#else
-	int odd = len & 0x0001;
-	unsigned short *p = buf;
-
-	len = len / 2;
-	for (i = 0; i < len; i++)
-		outw(p[i], fifoaddr);
-
-	if (odd) {
-		unsigned char *pb = (unsigned char *)(buf + len);
-		outb(*pb, fifoaddr);
-	}
-#endif
 }
 
 static inline void r8a66597_mdfy(struct r8a66597 *r8a66597,
 				 u16 val, u16 pat, unsigned long offset)
 {
 	u16 tmp;
+
 	tmp = r8a66597_read(r8a66597, offset);
 	tmp = tmp & (~pat);
 	tmp = tmp | val;
@@ -554,7 +525,6 @@ static inline void r8a66597_port_power(struct r8a66597 *r8a66597, int port,
 #define get_pipetrn_addr(pipenum)	(PIPE1TRN + (pipenum - 1) * 4)
 #define get_devadd_addr(address)	(DEVADD0 + address * 2)
 
-
 /* USB HUB CONSTANTS (not OHCI-specific; see hub.h, based on usb_ohci.h) */
 
 /* destination of request */
@@ -637,11 +607,11 @@ static inline void r8a66597_port_power(struct r8a66597 *r8a66597, int port,
 
 /* roothub.a masks */
 #define RH_A_NDP	(0xff << 0)	/* number of downstream ports */
-#define RH_A_PSM	(1 << 8)	/* power switching mode */
-#define RH_A_NPS	(1 << 9)	/* no power switching */
-#define RH_A_DT		(1 << 10)	/* device type (mbz) */
-#define RH_A_OCPM	(1 << 11)	/* over current protection mode */
-#define RH_A_NOCP	(1 << 12)	/* no over current protection */
+#define RH_A_PSM	BIT(8)	/* power switching mode */
+#define RH_A_NPS	BIT(9)	/* no power switching */
+#define RH_A_DT		BIT(10)	/* device type (mbz) */
+#define RH_A_OCPM	BIT(11)	/* over current protection mode */
+#define RH_A_NOCP	BIT(12)	/* no over current protection */
 #define RH_A_POTPGT	(0xff << 24)	/* power on to power good time */
 
 #endif	/* __R8A66597_H__ */
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index b29c67e189..58a98ea793 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -385,7 +385,7 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 }
 
 int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
-		   int len, int interval)
+		   int len, int interval, bool nonblock)
 {
 	PDEBUG(0, "dev = %p pipe = %#lx buf = %p size = %d int = %d\n", dev, pipe,
 	       buffer, len, interval);
diff --git a/drivers/usb/host/usb-sandbox.c b/drivers/usb/host/usb-sandbox.c
index 5e3d96c208..bc91241aa7 100644
--- a/drivers/usb/host/usb-sandbox.c
+++ b/drivers/usb/host/usb-sandbox.c
@@ -12,6 +12,10 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+struct sandbox_usb_ctrl {
+	int rootdev;
+};
+
 static void usbmon_trace(struct udevice *bus, ulong pipe,
 			 struct devrequest *setup, struct udevice *emul)
 {
@@ -40,15 +44,24 @@ static int sandbox_submit_control(struct udevice *bus,
 				      void *buffer, int length,
 				      struct devrequest *setup)
 {
+	struct sandbox_usb_ctrl *ctrl = dev_get_priv(bus);
 	struct udevice *emul;
 	int ret;
 
 	/* Just use child of dev as emulator? */
 	debug("%s: bus=%s\n", __func__, bus->name);
-	ret = usb_emul_find(bus, pipe, &emul);
+	ret = usb_emul_find(bus, pipe, udev->portnr, &emul);
 	usbmon_trace(bus, pipe, setup, emul);
 	if (ret)
 		return ret;
+
+	if (usb_pipedevice(pipe) == ctrl->rootdev) {
+		if (setup->request == USB_REQ_SET_ADDRESS) {
+			debug("%s: Set root hub's USB address\n", __func__);
+			ctrl->rootdev = le16_to_cpu(setup->value);
+		}
+	}
+
 	ret = usb_emul_control(emul, udev, pipe, buffer, length, setup);
 	if (ret < 0) {
 		debug("ret=%d\n", ret);
@@ -70,7 +83,7 @@ static int sandbox_submit_bulk(struct udevice *bus, struct usb_device *udev,
 
 	/* Just use child of dev as emulator? */
 	debug("%s: bus=%s\n", __func__, bus->name);
-	ret = usb_emul_find(bus, pipe, &emul);
+	ret = usb_emul_find(bus, pipe, udev->portnr, &emul);
 	usbmon_trace(bus, pipe, NULL, emul);
 	if (ret)
 		return ret;
@@ -89,24 +102,35 @@ static int sandbox_submit_bulk(struct udevice *bus, struct usb_device *udev,
 
 static int sandbox_submit_int(struct udevice *bus, struct usb_device *udev,
 			      unsigned long pipe, void *buffer, int length,
-			      int interval)
+			      int interval, bool nonblock)
 {
 	struct udevice *emul;
 	int ret;
 
 	/* Just use child of dev as emulator? */
 	debug("%s: bus=%s\n", __func__, bus->name);
-	ret = usb_emul_find(bus, pipe, &emul);
+	ret = usb_emul_find(bus, pipe, udev->portnr, &emul);
 	usbmon_trace(bus, pipe, NULL, emul);
 	if (ret)
 		return ret;
-	ret = usb_emul_int(emul, udev, pipe, buffer, length, interval);
+	ret = usb_emul_int(emul, udev, pipe, buffer, length, interval,
+			   nonblock);
 
 	return ret;
 }
 
 static int sandbox_alloc_device(struct udevice *dev, struct usb_device *udev)
 {
+	struct sandbox_usb_ctrl *ctrl = dev_get_priv(dev);
+
+	/*
+	 * Root hub will be the first device to be initailized.
+	 * If this device is a root hub, initialize its device speed
+	 * to high speed as we are a USB 2.0 controller.
+	 */
+	if (ctrl->rootdev == 0)
+		udev->speed = USB_SPEED_HIGH;
+
 	return 0;
 }
 
@@ -133,4 +157,5 @@ U_BOOT_DRIVER(usb_sandbox) = {
 	.of_match = sandbox_usb_ids,
 	.probe = sandbox_usb_probe,
 	.ops	= &sandbox_usb_ops,
+	.priv_auto_alloc_size = sizeof(struct sandbox_usb_ctrl),
 };
diff --git a/drivers/usb/host/usb-uclass.c b/drivers/usb/host/usb-uclass.c
index 0b8a501ce8..733e32db2b 100644
--- a/drivers/usb/host/usb-uclass.c
+++ b/drivers/usb/host/usb-uclass.c
@@ -34,7 +34,7 @@ int usb_disable_asynch(int disable)
 }
 
 int submit_int_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
-		   int length, int interval)
+		   int length, int interval, bool nonblock)
 {
 	struct udevice *bus = udev->controller_dev;
 	struct dm_usb_ops *ops = usb_get_ops(bus);
@@ -42,7 +42,8 @@ int submit_int_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
 	if (!ops->interrupt)
 		return -ENOSYS;
 
-	return ops->interrupt(bus, udev, pipe, buffer, length, interval);
+	return ops->interrupt(bus, udev, pipe, buffer, length, interval,
+			      nonblock);
 }
 
 int submit_control_msg(struct usb_device *udev, unsigned long pipe,
@@ -150,9 +151,21 @@ int usb_update_hub_device(struct usb_device *udev)
 	return ops->update_hub_device(bus, udev);
 }
 
+int usb_get_max_xfer_size(struct usb_device *udev, size_t *size)
+{
+	struct udevice *bus = udev->controller_dev;
+	struct dm_usb_ops *ops = usb_get_ops(bus);
+
+	if (!ops->get_max_xfer_size)
+		return -ENOSYS;
+
+	return ops->get_max_xfer_size(bus, size);
+}
+
 int usb_stop(void)
 {
 	struct udevice *bus;
+	struct udevice *rh;
 	struct uclass *uc;
 	struct usb_uclass_priv *uc_priv;
 	int err = 0, ret;
@@ -168,23 +181,20 @@ int usb_stop(void)
 		ret = device_remove(bus, DM_REMOVE_NORMAL);
 		if (ret && !err)
 			err = ret;
-	}
-#ifdef CONFIG_BLK
-	ret = blk_unbind_all(IF_TYPE_USB);
-	if (ret && !err)
-		err = ret;
-#endif
-#ifdef CONFIG_SANDBOX
-	struct udevice *dev;
 
-	/* Reset all enulation devices */
-	ret = uclass_get(UCLASS_USB_EMUL, &uc);
-	if (ret)
-		return ret;
+		/* Locate root hub device */
+		device_find_first_child(bus, &rh);
+		if (rh) {
+			/*
+			 * All USB devices are children of root hub.
+			 * Unbinding root hub will unbind all of its children.
+			 */
+			ret = device_unbind(rh);
+			if (ret && !err)
+				err = ret;
+		}
+	}
 
-	uclass_foreach_dev(dev, uc)
-		usb_emul_reset(dev);
-#endif
 #ifdef CONFIG_USB_STORAGE
 	usb_stor_reset();
 #endif
@@ -204,7 +214,7 @@ static void usb_scan_bus(struct udevice *bus, bool recurse)
 
 	assert(recurse);	/* TODO: Support non-recusive */
 
-	printf("scanning bus %d for devices... ", bus->seq);
+	printf("scanning bus %s for devices... ", bus->name);
 	debug("\n");
 	ret = usb_scan_device(bus, 0, USB_SPEED_FULL, &dev);
 	if (ret)
@@ -236,7 +246,6 @@ int usb_init(void)
 	struct usb_bus_priv *priv;
 	struct udevice *bus;
 	struct uclass *uc;
-	int count = 0;
 	int ret;
 
 	asynch_allowed = 1;
@@ -249,8 +258,22 @@ int usb_init(void)
 
 	uclass_foreach_dev(bus, uc) {
 		/* init low_level USB */
-		printf("USB%d:   ", count);
-		count++;
+		printf("Bus %s: ", bus->name);
+
+#ifdef CONFIG_SANDBOX
+		/*
+		 * For Sandbox, we need scan the device tree each time when we
+		 * start the USB stack, in order to re-create the emulated USB
+		 * devices and bind drivers for them before we actually do the
+		 * driver probe.
+		 */
+		ret = dm_scan_fdt_dev(bus);
+		if (ret) {
+			printf("Sandbox USB device scan failed (%d)\n", ret);
+			continue;
+		}
+#endif
+
 		ret = device_probe(bus);
 		if (ret == -ENODEV) {	/* No such device. */
 			puts("Port not available.\n");
@@ -306,10 +329,8 @@ int usb_init(void)
 	remove_inactive_children(uc, bus);
 
 	/* if we were not able to find at least one working bus, bail out */
-	if (!count)
-		printf("No controllers found\n");
-	else if (controllers_initialized == 0)
-		printf("USB error: all controllers failed lowlevel init\n");
+	if (controllers_initialized == 0)
+		printf("No working controllers found\n");
 
 	return usb_started ? 0 : -1;
 }
diff --git a/drivers/usb/host/xhci-dwc3.c b/drivers/usb/host/xhci-dwc3.c
index 4191a89421..91eaa687e1 100644
--- a/drivers/usb/host/xhci-dwc3.c
+++ b/drivers/usb/host/xhci-dwc3.c
@@ -10,11 +10,11 @@
 
 #include <common.h>
 #include <dm.h>
-#include <fdtdec.h>
 #include <generic-phy.h>
 #include <usb.h>
+#include <dwc3-uboot.h>
 
-#include "xhci.h"
+#include <usb/xhci.h>
 #include <asm/io.h>
 #include <linux/usb/dwc3.h>
 #include <linux/usb/otg.h>
@@ -22,7 +22,8 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 struct xhci_dwc3_platdata {
-	struct phy usb_phy;
+	struct phy *usb_phys;
+	int num_phys;
 };
 
 void dwc3_set_mode(struct dwc3 *dwc3_reg, u32 mode)
@@ -111,39 +112,52 @@ void dwc3_set_fladj(struct dwc3 *dwc3_reg, u32 val)
 			GFLADJ_30MHZ(val));
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int xhci_dwc3_probe(struct udevice *dev)
 {
-	struct xhci_dwc3_platdata *plat = dev_get_platdata(dev);
 	struct xhci_hcor *hcor;
 	struct xhci_hccr *hccr;
 	struct dwc3 *dwc3_reg;
 	enum usb_dr_mode dr_mode;
+	struct xhci_dwc3_platdata *plat = dev_get_platdata(dev);
+	const char *phy;
+	u32 reg;
 	int ret;
 
 	hccr = (struct xhci_hccr *)((uintptr_t)dev_read_addr(dev));
 	hcor = (struct xhci_hcor *)((uintptr_t)hccr +
 			HC_LENGTH(xhci_readl(&(hccr)->cr_capbase)));
 
-	ret = generic_phy_get_by_index(dev, 0, &plat->usb_phy);
-	if (ret) {
-		if (ret != -ENOENT) {
-			error("Failed to get USB PHY for %s\n", dev->name);
-			return ret;
-		}
-	} else {
-		ret = generic_phy_init(&plat->usb_phy);
-		if (ret) {
-			error("Can't init USB PHY for %s\n", dev->name);
-			return ret;
-		}
-	}
+	ret = dwc3_setup_phy(dev, &plat->usb_phys, &plat->num_phys);
+	if (ret && (ret != -ENOTSUPP))
+		return ret;
 
 	dwc3_reg = (struct dwc3 *)((char *)(hccr) + DWC3_REG_OFFSET);
 
 	dwc3_core_init(dwc3_reg);
 
-	dr_mode = usb_get_dr_mode(dev_of_offset(dev));
+	/* Set dwc3 usb2 phy config */
+	reg = readl(&dwc3_reg->g_usb2phycfg[0]);
+
+	phy = dev_read_string(dev, "phy_type");
+	if (phy && strcmp(phy, "utmi_wide") == 0) {
+		reg |= DWC3_GUSB2PHYCFG_PHYIF;
+		reg &= ~DWC3_GUSB2PHYCFG_USBTRDTIM_MASK;
+		reg |= DWC3_GUSB2PHYCFG_USBTRDTIM_16BIT;
+	}
+
+	if (dev_read_bool(dev, "snps,dis_enblslpm-quirk"))
+		reg &= ~DWC3_GUSB2PHYCFG_ENBLSLPM;
+
+	if (dev_read_bool(dev, "snps,dis-u2-freeclk-exists-quirk"))
+		reg &= ~DWC3_GUSB2PHYCFG_U2_FREECLK_EXISTS;
+
+	if (dev_read_bool(dev, "snps,dis_u2_susphy_quirk"))
+		reg &= ~DWC3_GUSB2PHYCFG_SUSPHY;
+
+	writel(reg, &dwc3_reg->g_usb2phycfg[0]);
+
+	dr_mode = usb_get_dr_mode(dev->node);
 	if (dr_mode == USB_DR_MODE_UNKNOWN)
 		/* by default set dual role mode to HOST */
 		dr_mode = USB_DR_MODE_HOST;
@@ -156,15 +170,8 @@ static int xhci_dwc3_probe(struct udevice *dev)
 static int xhci_dwc3_remove(struct udevice *dev)
 {
 	struct xhci_dwc3_platdata *plat = dev_get_platdata(dev);
-	int ret;
 
-	if (generic_phy_valid(&plat->usb_phy)) {
-		ret = generic_phy_exit(&plat->usb_phy);
-		if (ret) {
-			error("Can't deinit USB PHY for %s\n", dev->name);
-			return ret;
-		}
-	}
+	dwc3_shutdown_phy(dev, plat->usb_phys, plat->num_phys);
 
 	return xhci_deregister(dev);
 }
diff --git a/drivers/usb/host/xhci-exynos5.c b/drivers/usb/host/xhci-exynos5.c
index bf7286554e..26d88eb1b9 100644
--- a/drivers/usb/host/xhci-exynos5.c
+++ b/drivers/usb/host/xhci-exynos5.c
@@ -16,7 +16,7 @@
 #include <common.h>
 #include <dm.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <usb.h>
 #include <watchdog.h>
@@ -28,7 +28,7 @@
 #include <linux/compat.h>
 #include <linux/usb/dwc3.h>
 
-#include "xhci.h"
+#include <usb/xhci.h>
 
 /* Declare global data pointer */
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/drivers/usb/host/xhci-fsl.c b/drivers/usb/host/xhci-fsl.c
index f77c78d422..3ee83f45d2 100644
--- a/drivers/usb/host/xhci-fsl.c
+++ b/drivers/usb/host/xhci-fsl.c
@@ -14,15 +14,12 @@
 #include <linux/compat.h>
 #include <linux/usb/xhci-fsl.h>
 #include <linux/usb/dwc3.h>
-#include "xhci.h"
+#include <usb/xhci.h>
 #include <fsl_errata.h>
 #include <fsl_usb.h>
 #include <dm.h>
 
-/* Declare global data pointer */
-DECLARE_GLOBAL_DATA_PTR;
-
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 static struct fsl_xhci fsl_xhci;
 unsigned long ctr_addr[] = FSL_USB_XHCI_ADDR;
 #else
@@ -110,7 +107,7 @@ static int fsl_xhci_core_exit(struct fsl_xhci *fsl_xhci)
 	return 0;
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int xhci_fsl_probe(struct udevice *dev)
 {
 	struct xhci_fsl_priv *priv = dev_get_priv(dev);
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index d5eab3a615..28fa0f7faf 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -22,7 +22,7 @@
 #include <asm/cache.h>
 #include <linux/errno.h>
 
-#include "xhci.h"
+#include <usb/xhci.h>
 
 #define CACHELINE_SIZE		CONFIG_SYS_CACHELINE_SIZE
 /**
@@ -370,6 +370,9 @@ static int xhci_scratchpad_alloc(struct xhci_ctrl *ctrl)
 	ctrl->dcbaa->dev_context_ptrs[0] =
 		cpu_to_le64((uintptr_t)scratchpad->sp_array);
 
+	xhci_flush_cache((uintptr_t)&ctrl->dcbaa->dev_context_ptrs[0],
+		sizeof(ctrl->dcbaa->dev_context_ptrs[0]));
+
 	page_size = xhci_readl(&hcor->or_pagesize) & 0xffff;
 	for (i = 0; i < 16; i++) {
 		if ((0x1 & page_size) != 0)
@@ -724,7 +727,7 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl,
 	int slot_id = udev->slot_id;
 	int speed = udev->speed;
 	int route = 0;
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	struct usb_device *dev = udev;
 	struct usb_hub_device *hub;
 #endif
@@ -740,7 +743,7 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl,
 	/* Only the control endpoint is valid - one endpoint context */
 	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX(1));
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	/* Calculate the route string for this device */
 	port_num = dev->portnr;
 	while (!usb_hub_is_root_hub(dev->dev)) {
@@ -783,15 +786,25 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl,
 		BUG();
 	}
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	/* Set up TT fields to support FS/LS devices */
 	if (speed == USB_SPEED_LOW || speed == USB_SPEED_FULL) {
-		dev = dev_get_parent_priv(udev->dev);
-		if (dev->speed == USB_SPEED_HIGH) {
-			hub = dev_get_uclass_priv(udev->dev);
+		struct udevice *parent = udev->dev;
+
+		dev = udev;
+		do {
+			port_num = dev->portnr;
+			dev = dev_get_parent_priv(parent);
+			if (usb_hub_is_root_hub(dev->dev))
+				break;
+			parent = dev->dev->parent;
+		} while (dev->speed != USB_SPEED_HIGH);
+
+		if (!usb_hub_is_root_hub(dev->dev)) {
+			hub = dev_get_uclass_priv(dev->dev);
 			if (hub->tt.multi)
 				slot_ctx->dev_info |= cpu_to_le32(DEV_MTT);
-			slot_ctx->tt_info |= cpu_to_le32(TT_PORT(udev->portnr));
+			slot_ctx->tt_info |= cpu_to_le32(TT_PORT(port_num));
 			slot_ctx->tt_info |= cpu_to_le32(TT_SLOT(dev->slot_id));
 		}
 	}
@@ -840,6 +853,12 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl,
 	trb_64 = (uintptr_t)virt_dev->eps[0].ring->first_seg->trbs;
 	ep0_ctx->deq = cpu_to_le64(trb_64 | virt_dev->eps[0].ring->cycle_state);
 
+	/*
+	 * xHCI spec 6.2.3:
+	 * software shall set 'Average TRB Length' to 8 for control endpoints.
+	 */
+	ep0_ctx->tx_info = cpu_to_le32(EP_AVG_TRB_LENGTH(8));
+
 	/* Steps 7 and 8 were done in xhci_alloc_virt_device() */
 
 	xhci_flush_cache((uintptr_t)ep0_ctx, sizeof(struct xhci_ep_ctx));
diff --git a/drivers/usb/host/xhci-mvebu.c b/drivers/usb/host/xhci-mvebu.c
index b9201a5a6a..73a1268080 100644
--- a/drivers/usb/host/xhci-mvebu.c
+++ b/drivers/usb/host/xhci-mvebu.c
@@ -13,7 +13,7 @@
 #include <power/regulator.h>
 #include <asm/gpio.h>
 
-#include "xhci.h"
+#include <usb/xhci.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -35,7 +35,7 @@ struct mvebu_xhci {
  * Dummy implementation that can be overwritten by a board
  * specific function
  */
-__weak int board_xhci_enable(void)
+__weak int board_xhci_enable(fdt_addr_t base)
 {
 	return 0;
 }
@@ -62,7 +62,7 @@ static int xhci_usb_probe(struct udevice *dev)
 	}
 
 	/* Enable USB xHCI (VBUS, reset etc) in board specific code */
-	board_xhci_enable();
+	board_xhci_enable(devfdt_get_addr_index(dev, 1));
 
 	return xhci_register(dev, ctx->hcd, hcor);
 }
@@ -85,6 +85,7 @@ static int xhci_usb_ofdata_to_platdata(struct udevice *dev)
 
 static const struct udevice_id xhci_usb_ids[] = {
 	{ .compatible = "marvell,armada3700-xhci" },
+	{ .compatible = "marvell,armada-380-xhci" },
 	{ .compatible = "marvell,armada-8k-xhci" },
 	{ }
 };
diff --git a/drivers/usb/host/xhci-omap.c b/drivers/usb/host/xhci-omap.c
index d6c5744818..d70ae0c221 100644
--- a/drivers/usb/host/xhci-omap.c
+++ b/drivers/usb/host/xhci-omap.c
@@ -20,35 +20,13 @@
 #include <linux/usb/dwc3.h>
 #include <linux/usb/xhci-omap.h>
 
-#include "xhci.h"
+#include <usb/xhci.h>
 
 /* Declare global data pointer */
 DECLARE_GLOBAL_DATA_PTR;
 
 static struct omap_xhci omap;
 
-__weak int omap_xhci_board_usb_init(int index, enum usb_init_type init)
-{
-	enable_usb_clocks(index);
-	return 0;
-}
-
-int board_usb_init(int index, enum usb_init_type init)
-{
-	return omap_xhci_board_usb_init(index, init);
-}
-
-__weak int omap_xhci_board_usb_cleanup(int index, enum usb_init_type init)
-{
-	disable_usb_clocks(index);
-	return 0;
-}
-
-int board_usb_cleanup(int index, enum usb_init_type init)
-{
-	return omap_xhci_board_usb_cleanup(index, init);
-}
-
 static int omap_xhci_core_init(struct omap_xhci *omap)
 {
 	int ret = 0;
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e4a0ef4a1a..88a67a7f81 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -10,7 +10,7 @@
 #include <dm.h>
 #include <pci.h>
 #include <usb.h>
-#include "xhci.h"
+#include <usb/xhci.h>
 
 static void xhci_pci_init(struct udevice *dev, struct xhci_hccr **ret_hccr,
 			  struct xhci_hcor **ret_hcor)
@@ -24,9 +24,8 @@ static void xhci_pci_init(struct udevice *dev, struct xhci_hccr **ret_hccr,
 	hcor = (struct xhci_hcor *)((uintptr_t) hccr +
 			HC_LENGTH(xhci_readl(&hccr->cr_capbase)));
 
-	debug("XHCI-PCI init hccr 0x%x and hcor 0x%x hc_length %d\n",
-	      (u32)hccr, (u32)hcor,
-	      (u32)HC_LENGTH(xhci_readl(&hccr->cr_capbase)));
+	debug("XHCI-PCI init hccr %p and hcor %p hc_length %d\n",
+	      hccr, hcor, (u32)HC_LENGTH(xhci_readl(&hccr->cr_capbase)));
 
 	*ret_hccr = hccr;
 	*ret_hcor = hcor;
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 579e6707eb..58bfc81941 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -20,7 +20,7 @@
 #include <asm/unaligned.h>
 #include <linux/errno.h>
 
-#include "xhci.h"
+#include <usb/xhci.h>
 
 /**
  * Is this TRB a link TRB or was the last TRB the last TRB in this event ring
@@ -557,7 +557,7 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 {
 	int num_trbs = 0;
 	struct xhci_generic_trb *start_trb;
-	bool first_trb = 0;
+	bool first_trb = false;
 	int start_cycle;
 	u32 field = 0;
 	u32 length_field = 0;
@@ -828,7 +828,7 @@ int xhci_ctrl_tx(struct usb_device *udev, unsigned long pipe,
 		field |= 0x1;
 
 	/* xHCI 1.0 6.4.1.2.1: Transfer Type field */
-	if (HC_VERSION(xhci_readl(&ctrl->hccr->cr_capbase)) == 0x100) {
+	if (HC_VERSION(xhci_readl(&ctrl->hccr->cr_capbase)) >= 0x100) {
 		if (length > 0) {
 			if (req->requesttype & USB_DIR_IN)
 				field |= (TRB_DATA_IN << TRB_TX_TYPE_SHIFT);
diff --git a/drivers/usb/host/xhci-zynqmp.c b/drivers/usb/host/xhci-zynqmp.c
index cec1bc46d0..3c45859a3d 100644
--- a/drivers/usb/host/xhci-zynqmp.c
+++ b/drivers/usb/host/xhci-zynqmp.c
@@ -11,9 +11,10 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <usb.h>
 #include <linux/errno.h>
-#include <asm/arch-zynqmp/hardware.h>
+#include <asm/arch/hardware.h>
 #include <linux/compat.h>
 #include <linux/usb/dwc3.h>
 #include "xhci.h"
@@ -57,13 +58,15 @@ DECLARE_GLOBAL_DATA_PTR;
 #define USBOTGSS_IRQ_SET_1_DMADISABLECLR_EN	BIT(17)
 
 struct zynqmp_xhci {
+	struct usb_platdata usb_plat;
+	struct xhci_ctrl ctrl;
 	struct xhci_hccr *hcd;
 	struct dwc3 *dwc3_reg;
 };
 
-static struct zynqmp_xhci zynqmp_xhci;
-
-unsigned long ctr_addr[] = CONFIG_ZYNQMP_XHCI_LIST;
+struct zynqmp_xhci_platdata {
+	fdt_addr_t hcd_base;
+};
 
 static int zynqmp_xhci_core_init(struct zynqmp_xhci *zynqmp_xhci)
 {
@@ -81,46 +84,66 @@ static int zynqmp_xhci_core_init(struct zynqmp_xhci *zynqmp_xhci)
 	return ret;
 }
 
-int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
+void xhci_hcd_stop(int index)
 {
-	struct zynqmp_xhci *ctx = &zynqmp_xhci;
-	int ret = 0;
-	uint32_t hclen;
+	/*
+	 * Currently zynqmp socs do not support PHY shutdown from
+	 * sw. But this support may be added in future socs.
+	 */
 
-	if (index < 0 || index >= ARRAY_SIZE(ctr_addr))
-		return -EINVAL;
+	return;
+}
 
-	ctx->hcd = (struct xhci_hccr *)ctr_addr[index];
-	ctx->dwc3_reg = (struct dwc3 *)((void *)ctx->hcd + DWC3_REG_OFFSET);
+static int xhci_usb_probe(struct udevice *dev)
+{
+	struct zynqmp_xhci_platdata *plat = dev_get_platdata(dev);
+	struct zynqmp_xhci *ctx = dev_get_priv(dev);
+	struct xhci_hcor *hcor;
+	int ret;
 
-	ret = board_usb_init(index, USB_INIT_HOST);
-	if (ret != 0) {
-		puts("Failed to initialize board for USB\n");
-		return ret;
-	}
+	ctx->hcd = (struct xhci_hccr *)plat->hcd_base;
+	ctx->dwc3_reg = (struct dwc3 *)((char *)(ctx->hcd) + DWC3_REG_OFFSET);
 
 	ret = zynqmp_xhci_core_init(ctx);
-	if (ret < 0) {
-		puts("Failed to initialize xhci\n");
-		return ret;
+	if (ret) {
+		puts("XHCI: failed to initialize controller\n");
+		return -EINVAL;
 	}
 
-	*hccr = (struct xhci_hccr *)ctx->hcd;
-	hclen = HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase));
-	*hcor = (struct xhci_hcor *)((uintptr_t) *hccr + hclen);
+	hcor = (struct xhci_hcor *)((ulong)ctx->hcd +
+				  HC_LENGTH(xhci_readl(&ctx->hcd->cr_capbase)));
 
-	debug("zynqmp-xhci: init hccr %p and hcor %p hc_length %d\n",
-	      *hccr, *hcor, hclen);
+	return xhci_register(dev, ctx->hcd, hcor);
+}
 
-	return ret;
+static int xhci_usb_remove(struct udevice *dev)
+{
+	return xhci_deregister(dev);
 }
 
-void xhci_hcd_stop(int index)
+static int xhci_usb_ofdata_to_platdata(struct udevice *dev)
 {
-	/*
-	 * Currently zynqmp socs do not support PHY shutdown from
-	 * sw. But this support may be added in future socs.
-	 */
+	struct zynqmp_xhci_platdata *plat = dev_get_platdata(dev);
+	const void *blob = gd->fdt_blob;
+
+	/* Get the base address for XHCI controller from the device node */
+	plat->hcd_base = fdtdec_get_addr(blob, dev_of_offset(dev), "reg");
+	if (plat->hcd_base == FDT_ADDR_T_NONE) {
+		debug("Can't get the XHCI register base address\n");
+		return -ENXIO;
+	}
 
-	return;
+	return 0;
 }
+
+U_BOOT_DRIVER(dwc3_generic_host) = {
+	.name = "dwc3-generic-host",
+	.id = UCLASS_USB,
+	.ofdata_to_platdata = xhci_usb_ofdata_to_platdata,
+	.probe = xhci_usb_probe,
+	.remove = xhci_usb_remove,
+	.ops = &xhci_usb_ops,
+	.platdata_auto_alloc_size = sizeof(struct zynqmp_xhci_platdata),
+	.priv_auto_alloc_size = sizeof(struct zynqmp_xhci),
+	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+};
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 9b82ee5c60..e04b6366e4 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -29,7 +29,7 @@
 #include <asm/cache.h>
 #include <asm/unaligned.h>
 #include <linux/errno.h>
-#include "xhci.h"
+#include <usb/xhci.h>
 
 #ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 1
@@ -109,13 +109,13 @@ static struct descriptor {
 	},
 };
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 static struct xhci_ctrl xhcic[CONFIG_USB_MAX_CONTROLLER_COUNT];
 #endif
 
 struct xhci_ctrl *xhci_get_ctrl(struct usb_device *udev)
 {
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	struct udevice *dev;
 
 	/* Find the USB controller */
@@ -257,6 +257,188 @@ static unsigned int xhci_get_ep_index(struct usb_endpoint_descriptor *desc)
 	return index;
 }
 
+/*
+ * Convert bInterval expressed in microframes (in 1-255 range) to exponent of
+ * microframes, rounded down to nearest power of 2.
+ */
+static unsigned int xhci_microframes_to_exponent(unsigned int desc_interval,
+						 unsigned int min_exponent,
+						 unsigned int max_exponent)
+{
+	unsigned int interval;
+
+	interval = fls(desc_interval) - 1;
+	interval = clamp_val(interval, min_exponent, max_exponent);
+	if ((1 << interval) != desc_interval)
+		debug("rounding interval to %d microframes, "\
+		      "ep desc says %d microframes\n",
+		      1 << interval, desc_interval);
+
+	return interval;
+}
+
+static unsigned int xhci_parse_microframe_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	if (endpt_desc->bInterval == 0)
+		return 0;
+
+	return xhci_microframes_to_exponent(endpt_desc->bInterval, 0, 15);
+}
+
+static unsigned int xhci_parse_frame_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	return xhci_microframes_to_exponent(endpt_desc->bInterval * 8, 3, 10);
+}
+
+/*
+ * Convert interval expressed as 2^(bInterval - 1) == interval into
+ * straight exponent value 2^n == interval.
+ */
+static unsigned int xhci_parse_exponent_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	unsigned int interval;
+
+	interval = clamp_val(endpt_desc->bInterval, 1, 16) - 1;
+	if (interval != endpt_desc->bInterval - 1)
+		debug("ep %#x - rounding interval to %d %sframes\n",
+		      endpt_desc->bEndpointAddress, 1 << interval,
+		      udev->speed == USB_SPEED_FULL ? "" : "micro");
+
+	if (udev->speed == USB_SPEED_FULL) {
+		/*
+		 * Full speed isoc endpoints specify interval in frames,
+		 * not microframes. We are using microframes everywhere,
+		 * so adjust accordingly.
+		 */
+		interval += 3;	/* 1 frame = 2^3 uframes */
+	}
+
+	return interval;
+}
+
+/*
+ * Return the polling or NAK interval.
+ *
+ * The polling interval is expressed in "microframes". If xHCI's Interval field
+ * is set to N, it will service the endpoint every 2^(Interval)*125us.
+ *
+ * The NAK interval is one NAK per 1 to 255 microframes, or no NAKs if interval
+ * is set to 0.
+ */
+static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	unsigned int interval = 0;
+
+	switch (udev->speed) {
+	case USB_SPEED_HIGH:
+		/* Max NAK rate */
+		if (usb_endpoint_xfer_control(endpt_desc) ||
+		    usb_endpoint_xfer_bulk(endpt_desc)) {
+			interval = xhci_parse_microframe_interval(udev,
+								  endpt_desc);
+			break;
+		}
+		/* Fall through - SS and HS isoc/int have same decoding */
+
+	case USB_SPEED_SUPER:
+		if (usb_endpoint_xfer_int(endpt_desc) ||
+		    usb_endpoint_xfer_isoc(endpt_desc)) {
+			interval = xhci_parse_exponent_interval(udev,
+								endpt_desc);
+		}
+		break;
+
+	case USB_SPEED_FULL:
+		if (usb_endpoint_xfer_isoc(endpt_desc)) {
+			interval = xhci_parse_exponent_interval(udev,
+								endpt_desc);
+			break;
+		}
+		/*
+		 * Fall through for interrupt endpoint interval decoding
+		 * since it uses the same rules as low speed interrupt
+		 * endpoints.
+		 */
+
+	case USB_SPEED_LOW:
+		if (usb_endpoint_xfer_int(endpt_desc) ||
+		    usb_endpoint_xfer_isoc(endpt_desc)) {
+			interval = xhci_parse_frame_interval(udev, endpt_desc);
+		}
+		break;
+
+	default:
+		BUG();
+	}
+
+	return interval;
+}
+
+/*
+ * The "Mult" field in the endpoint context is only set for SuperSpeed isoc eps.
+ * High speed endpoint descriptors can define "the number of additional
+ * transaction opportunities per microframe", but that goes in the Max Burst
+ * endpoint context field.
+ */
+static u32 xhci_get_endpoint_mult(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc,
+	struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc)
+{
+	if (udev->speed < USB_SPEED_SUPER ||
+	    !usb_endpoint_xfer_isoc(endpt_desc))
+		return 0;
+
+	return ss_ep_comp_desc->bmAttributes;
+}
+
+static u32 xhci_get_endpoint_max_burst(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc,
+	struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc)
+{
+	/* Super speed and Plus have max burst in ep companion desc */
+	if (udev->speed >= USB_SPEED_SUPER)
+		return ss_ep_comp_desc->bMaxBurst;
+
+	if (udev->speed == USB_SPEED_HIGH &&
+	    (usb_endpoint_xfer_isoc(endpt_desc) ||
+	     usb_endpoint_xfer_int(endpt_desc)))
+		return usb_endpoint_maxp_mult(endpt_desc) - 1;
+
+	return 0;
+}
+
+/*
+ * Return the maximum endpoint service interval time (ESIT) payload.
+ * Basically, this is the maxpacket size, multiplied by the burst size
+ * and mult size.
+ */
+static u32 xhci_get_max_esit_payload(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc,
+	struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc)
+{
+	int max_burst;
+	int max_packet;
+
+	/* Only applies for interrupt or isochronous endpoints */
+	if (usb_endpoint_xfer_control(endpt_desc) ||
+	    usb_endpoint_xfer_bulk(endpt_desc))
+		return 0;
+
+	/* SuperSpeed Isoc ep with less than 48k per esit */
+	if (udev->speed >= USB_SPEED_SUPER)
+		return le16_to_cpu(ss_ep_comp_desc->wBytesPerInterval);
+
+	max_packet = usb_endpoint_maxp(endpt_desc);
+	max_burst = usb_endpoint_maxp_mult(endpt_desc);
+
+	/* A 0 in max burst means 1 transfer per ESIT */
+	return max_packet * max_burst;
+}
+
 /**
  * Issue a configure endpoint command or evaluate context command
  * and wait for it to finish.
@@ -324,6 +506,12 @@ static int xhci_set_configuration(struct usb_device *udev)
 	int slot_id = udev->slot_id;
 	struct xhci_virt_device *virt_dev = ctrl->devs[slot_id];
 	struct usb_interface *ifdesc;
+	u32 max_esit_payload;
+	unsigned int interval;
+	unsigned int mult;
+	unsigned int max_burst;
+	unsigned int avg_trb_len;
+	unsigned int err_count = 0;
 
 	out_ctx = virt_dev->out_ctx;
 	in_ctx = virt_dev->in_ctx;
@@ -349,7 +537,7 @@ static int xhci_set_configuration(struct usb_device *udev)
 	/* slot context */
 	xhci_slot_copy(ctrl, in_ctx, out_ctx);
 	slot_ctx = xhci_get_slot_ctx(ctrl, in_ctx);
-	slot_ctx->dev_info &= ~(LAST_CTX_MASK);
+	slot_ctx->dev_info &= ~(cpu_to_le32(LAST_CTX_MASK));
 	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX(max_ep_flag + 1) | 0);
 
 	xhci_endpoint_copy(ctrl, in_ctx, out_ctx, 0);
@@ -357,10 +545,28 @@ static int xhci_set_configuration(struct usb_device *udev)
 	/* filling up ep contexts */
 	for (cur_ep = 0; cur_ep < num_of_ep; cur_ep++) {
 		struct usb_endpoint_descriptor *endpt_desc = NULL;
+		struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc = NULL;
 
 		endpt_desc = &ifdesc->ep_desc[cur_ep];
+		ss_ep_comp_desc = &ifdesc->ss_ep_comp_desc[cur_ep];
 		trb_64 = 0;
 
+		/*
+		 * Get values to fill the endpoint context, mostly from ep
+		 * descriptor. The average TRB buffer lengt for bulk endpoints
+		 * is unclear as we have no clue on scatter gather list entry
+		 * size. For Isoc and Int, set it to max available.
+		 * See xHCI 1.1 spec 4.14.1.1 for details.
+		 */
+		max_esit_payload = xhci_get_max_esit_payload(udev, endpt_desc,
+							     ss_ep_comp_desc);
+		interval = xhci_get_endpoint_interval(udev, endpt_desc);
+		mult = xhci_get_endpoint_mult(udev, endpt_desc,
+					      ss_ep_comp_desc);
+		max_burst = xhci_get_endpoint_max_burst(udev, endpt_desc,
+							ss_ep_comp_desc);
+		avg_trb_len = max_esit_payload;
+
 		ep_index = xhci_get_ep_index(endpt_desc);
 		ep_ctx[ep_index] = xhci_get_ep_ctx(ctrl, in_ctx, ep_index);
 
@@ -372,20 +578,38 @@ static int xhci_set_configuration(struct usb_device *udev)
 		/*NOTE: ep_desc[0] actually represents EP1 and so on */
 		dir = (((endpt_desc->bEndpointAddress) & (0x80)) >> 7);
 		ep_type = (((endpt_desc->bmAttributes) & (0x3)) | (dir << 2));
+
+		ep_ctx[ep_index]->ep_info =
+			cpu_to_le32(EP_MAX_ESIT_PAYLOAD_HI(max_esit_payload) |
+			EP_INTERVAL(interval) | EP_MULT(mult));
+
 		ep_ctx[ep_index]->ep_info2 =
 			cpu_to_le32(ep_type << EP_TYPE_SHIFT);
 		ep_ctx[ep_index]->ep_info2 |=
 			cpu_to_le32(MAX_PACKET
 			(get_unaligned(&endpt_desc->wMaxPacketSize)));
 
+		/* Allow 3 retries for everything but isoc, set CErr = 3 */
+		if (!usb_endpoint_xfer_isoc(endpt_desc))
+			err_count = 3;
 		ep_ctx[ep_index]->ep_info2 |=
-			cpu_to_le32(((0 & MAX_BURST_MASK) << MAX_BURST_SHIFT) |
-			((3 & ERROR_COUNT_MASK) << ERROR_COUNT_SHIFT));
+			cpu_to_le32(MAX_BURST(max_burst) |
+			ERROR_COUNT(err_count));
 
 		trb_64 = (uintptr_t)
 				virt_dev->eps[ep_index].ring->enqueue;
 		ep_ctx[ep_index]->deq = cpu_to_le64(trb_64 |
 				virt_dev->eps[ep_index].ring->cycle_state);
+
+		/*
+		 * xHCI spec 6.2.3:
+		 * 'Average TRB Length' should be 8 for control endpoints.
+		 */
+		if (usb_endpoint_xfer_control(endpt_desc))
+			avg_trb_len = 8;
+		ep_ctx[ep_index]->tx_info =
+			cpu_to_le32(EP_MAX_ESIT_PAYLOAD_LO(max_esit_payload) |
+			EP_AVG_TRB_LENGTH(avg_trb_len));
 	}
 
 	return xhci_configure_endpoints(udev, false);
@@ -518,7 +742,7 @@ static int _xhci_alloc_device(struct usb_device *udev)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int usb_alloc_device(struct usb_device *udev)
 {
 	return _xhci_alloc_device(udev);
@@ -546,16 +770,13 @@ int xhci_check_maxpacket(struct usb_device *udev)
 	int max_packet_size;
 	int hw_max_packet_size;
 	int ret = 0;
-	struct usb_interface *ifdesc;
-
-	ifdesc = &udev->config.if_desc[0];
 
 	out_ctx = ctrl->devs[slot_id]->out_ctx;
 	xhci_inval_cache((uintptr_t)out_ctx->bytes, out_ctx->size);
 
 	ep_ctx = xhci_get_ep_ctx(ctrl, out_ctx, ep_index);
 	hw_max_packet_size = MAX_PACKET_DECODED(le32_to_cpu(ep_ctx->ep_info2));
-	max_packet_size = usb_endpoint_maxp(&ifdesc->ep_desc[0]);
+	max_packet_size = udev->epmaxpacketin[0];
 	if (hw_max_packet_size != max_packet_size) {
 		debug("Max Packet Size for ep 0 changed.\n");
 		debug("Max packet size in usb_device = %d\n", max_packet_size);
@@ -567,7 +788,8 @@ int xhci_check_maxpacket(struct usb_device *udev)
 				ctrl->devs[slot_id]->out_ctx, ep_index);
 		in_ctx = ctrl->devs[slot_id]->in_ctx;
 		ep_ctx = xhci_get_ep_ctx(ctrl, in_ctx, ep_index);
-		ep_ctx->ep_info2 &= cpu_to_le32(~MAX_PACKET_MASK);
+		ep_ctx->ep_info2 &= cpu_to_le32(~((0xffff & MAX_PACKET_MASK)
+						<< MAX_PACKET_SHIFT));
 		ep_ctx->ep_info2 |= cpu_to_le32(MAX_PACKET(max_packet_size));
 
 		/*
@@ -730,7 +952,7 @@ static int xhci_submit_root(struct usb_device *udev, unsigned long pipe,
 		case USB_DT_HUB:
 		case USB_DT_SS_HUB:
 			debug("USB_DT_HUB config\n");
-			srcptr = &descriptor.hub;
+			srcptr = &ctrl->hub;
 			srclen = 0x8;
 			break;
 		default:
@@ -888,13 +1110,21 @@ unknown:
  * @return 0
  */
 static int _xhci_submit_int_msg(struct usb_device *udev, unsigned long pipe,
-				void *buffer, int length, int interval)
+				void *buffer, int length, int interval,
+				bool nonblock)
 {
+	if (usb_pipetype(pipe) != PIPE_INTERRUPT) {
+		printf("non-interrupt pipe (type=%lu)", usb_pipetype(pipe));
+		return -EINVAL;
+	}
+
 	/*
-	 * TODO: Not addressing any interrupt type transfer requests
-	 * Add support for it later.
+	 * xHCI uses normal TRBs for both bulk and interrupt. When the
+	 * interrupt endpoint is to be serviced, the xHC will consume
+	 * (at most) one TD. A TD (comprised of sg list entries) can
+	 * take several service intervals to transmit.
 	 */
-	return -EINVAL;
+	return xhci_bulk_tx(udev, pipe, length, buffer);
 }
 
 /**
@@ -998,6 +1228,8 @@ static int xhci_lowlevel_init(struct xhci_ctrl *ctrl)
 		put_unaligned(get_unaligned(&descriptor.hub.wHubCharacteristics)
 				| 0x01, &descriptor.hub.wHubCharacteristics);
 
+	memcpy(&ctrl->hub, &descriptor, sizeof(struct usb_hub_descriptor));
+
 	if (xhci_start(hcor)) {
 		xhci_reset(hcor);
 		return -ENODEV;
@@ -1028,7 +1260,7 @@ static int xhci_lowlevel_stop(struct xhci_ctrl *ctrl)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int submit_control_msg(struct usb_device *udev, unsigned long pipe,
 		       void *buffer, int length, struct devrequest *setup)
 {
@@ -1049,9 +1281,10 @@ int submit_bulk_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
 }
 
 int submit_int_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
-		   int length, int interval)
+		   int length, int interval, bool nonblock)
 {
-	return _xhci_submit_int_msg(udev, pipe, buffer, length, interval);
+	return _xhci_submit_int_msg(udev, pipe, buffer, length, interval,
+				    nonblock);
 }
 
 /**
@@ -1112,9 +1345,9 @@ int usb_lowlevel_stop(int index)
 
 	return 0;
 }
-#endif /* CONFIG_DM_USB */
+#endif /* CONFIG_IS_ENABLED(DM_USB) */
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 
 static int xhci_submit_control_msg(struct udevice *dev, struct usb_device *udev,
 				   unsigned long pipe, void *buffer, int length,
@@ -1158,10 +1391,11 @@ static int xhci_submit_bulk_msg(struct udevice *dev, struct usb_device *udev,
 
 static int xhci_submit_int_msg(struct udevice *dev, struct usb_device *udev,
 			       unsigned long pipe, void *buffer, int length,
-			       int interval)
+			       int interval, bool nonblock)
 {
 	debug("%s: dev='%s', udev=%p\n", __func__, dev->name, udev);
-	return _xhci_submit_int_msg(udev, pipe, buffer, length, interval);
+	return _xhci_submit_int_msg(udev, pipe, buffer, length, interval,
+				    nonblock);
 }
 
 static int xhci_alloc_device(struct udevice *dev, struct usb_device *udev)
@@ -1196,7 +1430,7 @@ static int xhci_update_hub_device(struct udevice *dev, struct usb_device *udev)
 
 	ctrl_ctx = xhci_get_input_control_ctx(in_ctx);
 	/* Initialize the input context control */
-	ctrl_ctx->add_flags |= cpu_to_le32(SLOT_FLAG);
+	ctrl_ctx->add_flags = cpu_to_le32(SLOT_FLAG);
 	ctrl_ctx->drop_flags = 0;
 
 	xhci_inval_cache((uintptr_t)out_ctx->bytes, out_ctx->size);
@@ -1207,8 +1441,15 @@ static int xhci_update_hub_device(struct udevice *dev, struct usb_device *udev)
 
 	/* Update hub related fields */
 	slot_ctx->dev_info |= cpu_to_le32(DEV_HUB);
-	if (hub->tt.multi && udev->speed == USB_SPEED_HIGH)
+	/*
+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,
+	 * but it may be already set to 1 when setup an xHCI virtual
+	 * device, so clear it anyway.
+	 */
+	if (hub->tt.multi)
 		slot_ctx->dev_info |= cpu_to_le32(DEV_MTT);
+	else if (udev->speed == USB_SPEED_FULL)
+		slot_ctx->dev_info &= cpu_to_le32(~DEV_MTT);
 	slot_ctx->dev_info2 |= cpu_to_le32(XHCI_MAX_PORTS(udev->maxchild));
 	/*
 	 * Set TT think time - convert from ns to FS bit times.
@@ -1224,10 +1465,25 @@ static int xhci_update_hub_device(struct udevice *dev, struct usb_device *udev)
 		think_time = (think_time / 666) - 1;
 	if (udev->speed == USB_SPEED_HIGH)
 		slot_ctx->tt_info |= cpu_to_le32(TT_THINK_TIME(think_time));
+	slot_ctx->dev_state = 0;
 
 	return xhci_configure_endpoints(udev, false);
 }
 
+static int xhci_get_max_xfer_size(struct udevice *dev, size_t *size)
+{
+	/*
+	 * xHCD allocates one segment which includes 64 TRBs for each endpoint
+	 * and the last TRB in this segment is configured as a link TRB to form
+	 * a TRB ring. Each TRB can transfer up to 64K bytes, however data
+	 * buffers referenced by transfer TRBs shall not span 64KB boundaries.
+	 * Hence the maximum number of TRBs we can use in one transfer is 62.
+	 */
+	*size = (TRBS_PER_SEGMENT - 2) * TRB_MAX_BUFF_SIZE;
+
+	return 0;
+}
+
 int xhci_register(struct udevice *dev, struct xhci_hccr *hccr,
 		  struct xhci_hcor *hcor)
 {
@@ -1281,6 +1537,7 @@ struct dm_usb_ops xhci_usb_ops = {
 	.interrupt = xhci_submit_int_msg,
 	.alloc_device = xhci_alloc_device,
 	.update_hub_device = xhci_update_hub_device,
+	.get_max_xfer_size  = xhci_get_max_xfer_size,
 };
 
 #endif
diff --git a/drivers/usb/musb-new/Kconfig b/drivers/usb/musb-new/Kconfig
index caba42c26f..bf86bc589d 100644
--- a/drivers/usb/musb-new/Kconfig
+++ b/drivers/usb/musb-new/Kconfig
@@ -5,15 +5,27 @@ comment "MUSB Controller Driver"
 
 config USB_MUSB_HOST
 	bool "MUSB host mode support"
+	select SPL_SPRINTF if SPL
+	select TPL_SPRINTF if TPL
 	help
 	  Enables the MUSB USB dual-role controller in host mode.
 
 config USB_MUSB_GADGET
 	bool "MUSB gadget mode support"
 	select USB_GADGET_DUALSPEED
+	select SPL_SPRINTF if SPL
+	select TPL_SPRINTF if TPL
 	help
 	  Enables the MUSB USB dual-role controller in gadget mode.
 
+config USB_MUSB_DA8XX
+	bool "Enable DA8xx MUSB Controller"
+	depends on DM_USB
+	help
+	  Say y here to enable support for the dual role high
+	  speed USB controller based on the Mentor Graphics
+	  silicon IP.
+
 config USB_MUSB_TI
 	bool "Enable TI OTG USB controller"
 	depends on DM_USB
diff --git a/drivers/usb/musb-new/Makefile b/drivers/usb/musb-new/Makefile
index 296f230fbf..9fcabcfa63 100644
--- a/drivers/usb/musb-new/Makefile
+++ b/drivers/usb/musb-new/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_USB_MUSB_GADGET) += musb_gadget.o musb_gadget_ep0.o musb_core.o
 obj-$(CONFIG_USB_MUSB_GADGET) += musb_uboot.o
 obj-$(CONFIG_USB_MUSB_HOST) += musb_host.o musb_core.o musb_uboot.o
 obj-$(CONFIG_USB_MUSB_DSPS) += musb_dsps.o
+obj-$(CONFIG_USB_MUSB_DA8XX)	+= da8xx.o
 obj-$(CONFIG_USB_MUSB_AM35X) += am35x.o
 obj-$(CONFIG_USB_MUSB_OMAP2PLUS) += omap2430.o
 obj-$(CONFIG_USB_MUSB_PIC32) += pic32.o
diff --git a/drivers/usb/musb-new/linux-compat.h b/drivers/usb/musb-new/linux-compat.h
index 4dae83ed68..f366ae58e8 100644
--- a/drivers/usb/musb-new/linux-compat.h
+++ b/drivers/usb/musb-new/linux-compat.h
@@ -5,14 +5,6 @@
 #include <linux/list.h>
 #include <linux/compat.h>
 
-#define pr_debug(fmt, args...) debug(fmt, ##args)
-
-#define WARN(condition, fmt, args...) ({	\
-	int ret_warn = !!condition;		\
-	if (ret_warn)				\
-		printf(fmt, ##args);		\
-	ret_warn; })
-
 #define device_init_wakeup(dev, a) do {} while (0)
 
 #define platform_data device_data
diff --git a/drivers/usb/musb-new/musb_uboot.c b/drivers/usb/musb-new/musb_uboot.c
index 8662c0ff70..497e211c4c 100644
--- a/drivers/usb/musb-new/musb_uboot.c
+++ b/drivers/usb/musb-new/musb_uboot.c
@@ -22,7 +22,7 @@ struct int_queue {
 	struct urb urb;
 };
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 struct musb_host_data musb_host;
 #endif
 
@@ -113,7 +113,7 @@ static int _musb_submit_bulk_msg(struct musb_host_data *host,
 
 static int _musb_submit_int_msg(struct musb_host_data *host,
 	struct usb_device *dev, unsigned long pipe,
-	void *buffer, int len, int interval)
+	void *buffer, int len, int interval, bool nonblock)
 {
 	construct_urb(&host->urb, &host->hep, dev, USB_ENDPOINT_XFER_INT, pipe,
 		      buffer, len, NULL, interval);
@@ -249,7 +249,7 @@ int musb_lowlevel_init(struct musb_host_data *host)
 	return 0;
 }
 
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 int usb_lowlevel_stop(int index)
 {
 	if (!musb_host.host) {
@@ -274,9 +274,10 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe,
 }
 
 int submit_int_msg(struct usb_device *dev, unsigned long pipe,
-		   void *buffer, int length, int interval)
+		   void *buffer, int length, int interval, bool nonblock)
 {
-	return _musb_submit_int_msg(&musb_host, dev, pipe, buffer, length, interval);
+	return _musb_submit_int_msg(&musb_host, dev, pipe, buffer, length,
+				    interval, nonblock);
 }
 
 struct int_queue *create_int_queue(struct usb_device *dev,
@@ -306,9 +307,9 @@ int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
 {
 	return musb_lowlevel_init(&musb_host);
 }
-#endif /* !CONFIG_DM_USB */
+#endif /* !CONFIG_IS_ENABLED(DM_USB) */
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static int musb_submit_control_msg(struct udevice *dev, struct usb_device *udev,
 				   unsigned long pipe, void *buffer, int length,
 				   struct devrequest *setup)
@@ -326,10 +327,11 @@ static int musb_submit_bulk_msg(struct udevice *dev, struct usb_device *udev,
 
 static int musb_submit_int_msg(struct udevice *dev, struct usb_device *udev,
 			       unsigned long pipe, void *buffer, int length,
-			       int interval)
+			       int interval, bool nonblock)
 {
 	struct musb_host_data *host = dev_get_priv(dev);
-	return _musb_submit_int_msg(host, udev, pipe, buffer, length, interval);
+	return _musb_submit_int_msg(host, udev, pipe, buffer, length, interval,
+				    nonblock);
 }
 
 static struct int_queue *musb_create_int_queue(struct udevice *dev,
@@ -370,7 +372,7 @@ struct dm_usb_ops musb_usb_ops = {
 	.destroy_int_queue = musb_destroy_int_queue,
 	.reset_root_port = musb_reset_root_port,
 };
-#endif /* CONFIG_DM_USB */
+#endif /* CONFIG_IS_ENABLED(DM_USB) */
 #endif /* CONFIG_USB_MUSB_HOST */
 
 #ifdef CONFIG_USB_MUSB_GADGET
@@ -431,7 +433,7 @@ int musb_register(struct musb_hdrc_platform_data *plat, void *bdata,
 	struct musb **musbp;
 
 	switch (plat->mode) {
-#if defined(CONFIG_USB_MUSB_HOST) && !defined(CONFIG_DM_USB)
+#if defined(CONFIG_USB_MUSB_HOST) && !CONFIG_IS_ENABLED(DM_USB)
 	case MUSB_HOST:
 		musbp = &musb_host.host;
 		break;
diff --git a/drivers/usb/musb-new/omap2430.c b/drivers/usb/musb-new/omap2430.c
index ba22dfe6cb..7d60b17add 100644
--- a/drivers/usb/musb-new/omap2430.c
+++ b/drivers/usb/musb-new/omap2430.c
@@ -9,201 +9,19 @@
  *
  * SPDX-License-Identifier:	GPL-2.0
  */
-#ifndef __UBOOT__
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/pm_runtime.h>
-#include <linux/err.h>
-#include <linux/usb/musb-omap.h>
-#else
 #include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <linux/usb/otg.h>
 #include <asm/omap_common.h>
 #include <asm/omap_musb.h>
 #include <twl4030.h>
 #include <twl6030.h>
 #include "linux-compat.h"
-#endif
-
 #include "musb_core.h"
 #include "omap2430.h"
-
-#ifndef __UBOOT__
-struct omap2430_glue {
-	struct device		*dev;
-	struct platform_device	*musb;
-	enum omap_musb_vbus_id_status status;
-	struct work_struct	omap_musb_mailbox_work;
-};
-#define glue_to_musb(g)		platform_get_drvdata(g->musb)
-
-struct omap2430_glue		*_glue;
-
-static struct timer_list musb_idle_timer;
-
-static void musb_do_idle(unsigned long _musb)
-{
-	struct musb	*musb = (void *)_musb;
-	unsigned long	flags;
-	u8	power;
-	u8	devctl;
-
-	spin_lock_irqsave(&musb->lock, flags);
-
-	switch (musb->xceiv->state) {
-	case OTG_STATE_A_WAIT_BCON:
-
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
-			MUSB_DEV_MODE(musb);
-		} else {
-			musb->xceiv->state = OTG_STATE_A_IDLE;
-			MUSB_HST_MODE(musb);
-		}
-		break;
-	case OTG_STATE_A_SUSPEND:
-		/* finish RESUME signaling? */
-		if (musb->port1_status & MUSB_PORT_STAT_RESUME) {
-			power = musb_readb(musb->mregs, MUSB_POWER);
-			power &= ~MUSB_POWER_RESUME;
-			dev_dbg(musb->controller, "root port resume stopped, power %02x\n", power);
-			musb_writeb(musb->mregs, MUSB_POWER, power);
-			musb->is_active = 1;
-			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
-						| MUSB_PORT_STAT_RESUME);
-			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
-			usb_hcd_poll_rh_status(musb_to_hcd(musb));
-			/* NOTE: it might really be A_WAIT_BCON ... */
-			musb->xceiv->state = OTG_STATE_A_HOST;
-		}
-		break;
-	case OTG_STATE_A_HOST:
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl &  MUSB_DEVCTL_BDEVICE)
-			musb->xceiv->state = OTG_STATE_B_IDLE;
-		else
-			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
-	default:
-		break;
-	}
-	spin_unlock_irqrestore(&musb->lock, flags);
-}
-
-
-static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
-{
-	unsigned long		default_timeout = jiffies + msecs_to_jiffies(3);
-	static unsigned long	last_timer;
-
-	if (timeout == 0)
-		timeout = default_timeout;
-
-	/* Never idle if active, or when VBUS timeout is not set as host */
-	if (musb->is_active || ((musb->a_wait_bcon == 0)
-			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
-		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			otg_state_string(musb->xceiv->state));
-		del_timer(&musb_idle_timer);
-		last_timer = jiffies;
-		return;
-	}
-
-	if (time_after(last_timer, timeout)) {
-		if (!timer_pending(&musb_idle_timer))
-			last_timer = timeout;
-		else {
-			dev_dbg(musb->controller, "Longer idle timer already pending, ignoring\n");
-			return;
-		}
-	}
-	last_timer = timeout;
-
-	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
-		otg_state_string(musb->xceiv->state),
-		(unsigned long)jiffies_to_msecs(timeout - jiffies));
-	mod_timer(&musb_idle_timer, timeout);
-}
-
-static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
-{
-	struct usb_otg	*otg = musb->xceiv->otg;
-	u8		devctl;
-	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
-	int ret = 1;
-	/* HDRC controls CPEN, but beware current surges during device
-	 * connect.  They can trigger transient overcurrent conditions
-	 * that must be ignored.
-	 */
-
-	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-
-	if (is_on) {
-		if (musb->xceiv->state == OTG_STATE_A_IDLE) {
-			/* start the session */
-			devctl |= MUSB_DEVCTL_SESSION;
-			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-			/*
-			 * Wait for the musb to set as A device to enable the
-			 * VBUS
-			 */
-			while (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {
-
-				cpu_relax();
-
-				if (time_after(jiffies, timeout)) {
-					dev_err(musb->controller,
-					"configured as A device timeout");
-					ret = -EINVAL;
-					break;
-				}
-			}
-
-			if (ret && otg->set_vbus)
-				otg_set_vbus(otg, 1);
-		} else {
-			musb->is_active = 1;
-			otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
-			devctl |= MUSB_DEVCTL_SESSION;
-			MUSB_HST_MODE(musb);
-		}
-	} else {
-		musb->is_active = 0;
-
-		/* NOTE:  we're skipping A_WAIT_VFALL -> A_IDLE and
-		 * jumping right to B_IDLE...
-		 */
-
-		otg->default_a = 0;
-		musb->xceiv->state = OTG_STATE_B_IDLE;
-		devctl &= ~MUSB_DEVCTL_SESSION;
-
-		MUSB_DEV_MODE(musb);
-	}
-	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-
-	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
-		/* otg %3x conf %08x prcm %08x */ "\n",
-		otg_state_string(musb->xceiv->state),
-		musb_readb(musb->mregs, MUSB_DEVCTL));
-}
-
-static int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)
-{
-	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-
-	devctl |= MUSB_DEVCTL_SESSION;
-	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-
-	return 0;
-}
-#endif
+#include "musb_uboot.h"
 
 static inline void omap2430_low_level_exit(struct musb *musb)
 {
@@ -224,100 +42,15 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
-#ifndef __UBOOT__
-void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
-{
-	struct omap2430_glue	*glue = _glue;
-	struct musb		*musb = glue_to_musb(glue);
-
-	glue->status = status;
-	if (!musb) {
-		dev_err(glue->dev, "musb core is not yet ready\n");
-		return;
-	}
-
-	schedule_work(&glue->omap_musb_mailbox_work);
-}
-EXPORT_SYMBOL_GPL(omap_musb_mailbox);
-
-static void omap_musb_set_mailbox(struct omap2430_glue *glue)
-{
-	struct musb *musb = glue_to_musb(glue);
-	struct device *dev = musb->controller;
-	struct musb_hdrc_platform_data *pdata = dev->platform_data;
-	struct omap_musb_board_data *data = pdata->board_data;
-	struct usb_otg *otg = musb->xceiv->otg;
-
-	switch (glue->status) {
-	case OMAP_MUSB_ID_GROUND:
-		dev_dbg(dev, "ID GND\n");
-
-		otg->default_a = true;
-		musb->xceiv->state = OTG_STATE_A_IDLE;
-		musb->xceiv->last_event = USB_EVENT_ID;
-		if (!is_otg_enabled(musb) || musb->gadget_driver) {
-			pm_runtime_get_sync(dev);
-			usb_phy_init(musb->xceiv);
-			omap2430_musb_set_vbus(musb, 1);
-		}
-		break;
-
-	case OMAP_MUSB_VBUS_VALID:
-		dev_dbg(dev, "VBUS Connect\n");
-
-		otg->default_a = false;
-		musb->xceiv->state = OTG_STATE_B_IDLE;
-		musb->xceiv->last_event = USB_EVENT_VBUS;
-		if (musb->gadget_driver)
-			pm_runtime_get_sync(dev);
-		usb_phy_init(musb->xceiv);
-		break;
-
-	case OMAP_MUSB_ID_FLOAT:
-	case OMAP_MUSB_VBUS_OFF:
-		dev_dbg(dev, "VBUS Disconnect\n");
-
-		musb->xceiv->last_event = USB_EVENT_NONE;
-		if (is_otg_enabled(musb) || is_peripheral_enabled(musb))
-			if (musb->gadget_driver) {
-				pm_runtime_mark_last_busy(dev);
-				pm_runtime_put_autosuspend(dev);
-			}
-
-		if (data->interface_type == MUSB_INTERFACE_UTMI) {
-			if (musb->xceiv->otg->set_vbus)
-				otg_set_vbus(musb->xceiv->otg, 0);
-		}
-		usb_phy_shutdown(musb->xceiv);
-		break;
-	default:
-		dev_dbg(dev, "ID float\n");
-	}
-}
-
-
-static void omap_musb_mailbox_work(struct work_struct *mailbox_work)
-{
-	struct omap2430_glue *glue = container_of(mailbox_work,
-				struct omap2430_glue, omap_musb_mailbox_work);
-	omap_musb_set_mailbox(glue);
-}
-#endif
 
 static int omap2430_musb_init(struct musb *musb)
 {
 	u32 l;
 	int status = 0;
 	unsigned long int start;
-#ifndef __UBOOT__
-	struct device *dev = musb->controller;
-	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
-	struct omap_musb_board_data *data = plat->board_data;
-#else
+
 	struct omap_musb_board_data *data =
 		(struct omap_musb_board_data *)musb->controller;
-#endif
 
 	/* Reset the controller */
 	musb_writel(musb->mregs, OTG_SYSCONFIG, SOFTRST);
@@ -335,24 +68,6 @@ static int omap2430_musb_init(struct musb *musb)
 		}
 	}
 
-#ifndef __UBOOT__
-	/* We require some kind of external transceiver, hooked
-	 * up through ULPI.  TWL4030-family PMICs include one,
-	 * which needs a driver, drivers aren't always needed.
-	 */
-	musb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
-	if (IS_ERR_OR_NULL(musb->xceiv)) {
-		pr_err("HS USB OTG: no transceiver configured\n");
-		return -ENODEV;
-	}
-
-	status = pm_runtime_get_sync(dev);
-	if (status < 0) {
-		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);
-		goto err1;
-	}
-#endif
-
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 
 	if (data->interface_type == MUSB_INTERFACE_UTMI) {
@@ -372,64 +87,14 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_SYSSTATUS),
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
-
-#ifndef __UBOOT__
-	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
-
-	if (glue->status != OMAP_MUSB_UNKNOWN)
-		omap_musb_set_mailbox(glue);
-
-	pm_runtime_put_noidle(musb->controller);
-#endif
 	return 0;
 
 err1:
 	return status;
 }
 
-#ifndef __UBOOT__
-static void omap2430_musb_enable(struct musb *musb)
-#else
 static int omap2430_musb_enable(struct musb *musb)
-#endif
 {
-#ifndef __UBOOT__
-	u8		devctl;
-	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
-	struct device *dev = musb->controller;
-	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
-	struct musb_hdrc_platform_data *pdata = dev->platform_data;
-	struct omap_musb_board_data *data = pdata->board_data;
-
-	switch (glue->status) {
-
-	case OMAP_MUSB_ID_GROUND:
-		usb_phy_init(musb->xceiv);
-		if (data->interface_type != MUSB_INTERFACE_UTMI)
-			break;
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		/* start the session */
-		devctl |= MUSB_DEVCTL_SESSION;
-		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-		while (musb_readb(musb->mregs, MUSB_DEVCTL) &
-				MUSB_DEVCTL_BDEVICE) {
-			cpu_relax();
-
-			if (time_after(jiffies, timeout)) {
-				dev_err(dev, "configured as A device timeout");
-				break;
-			}
-		}
-		break;
-
-	case OMAP_MUSB_VBUS_VALID:
-		usb_phy_init(musb->xceiv);
-		break;
-
-	default:
-		break;
-	}
-#else
 #ifdef CONFIG_TWL4030_USB
 	if (twl4030_usb_ulpi_init()) {
 		serial_printf("ERROR: %s Could not initialize PHY\n",
@@ -448,18 +113,11 @@ static int omap2430_musb_enable(struct musb *musb)
 #endif
 
 	return 0;
-#endif
 }
 
 static void omap2430_musb_disable(struct musb *musb)
 {
-#ifndef __UBOOT__
-	struct device *dev = musb->controller;
-	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	if (glue->status != OMAP_MUSB_UNKNOWN)
-		usb_phy_shutdown(musb->xceiv);
-#endif
 }
 
 static int omap2430_musb_exit(struct musb *musb)
@@ -471,174 +129,152 @@ static int omap2430_musb_exit(struct musb *musb)
 	return 0;
 }
 
-#ifndef __UBOOT__
-static const struct musb_platform_ops omap2430_ops = {
-#else
 const struct musb_platform_ops omap2430_ops = {
-#endif
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
-
-#ifndef __UBOOT__
-	.set_mode	= omap2430_musb_set_mode,
-	.try_idle	= omap2430_musb_try_idle,
-
-	.set_vbus	= omap2430_musb_set_vbus,
-#endif
-
 	.enable		= omap2430_musb_enable,
 	.disable	= omap2430_musb_disable,
 };
 
-#ifndef __UBOOT__
-static u64 omap2430_dmamask = DMA_BIT_MASK(32);
+#if CONFIG_IS_ENABLED(DM_USB)
+
+struct omap2430_musb_platdata {
+	void *base;
+	void *ctrl_mod_base;
+	struct musb_hdrc_platform_data plat;
+	struct musb_hdrc_config musb_config;
+	struct omap_musb_board_data otg_board_data;
+};
 
-static int __devinit omap2430_probe(struct platform_device *pdev)
+static int omap2430_musb_ofdata_to_platdata(struct udevice *dev)
 {
-	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
-	struct platform_device		*musb;
-	struct omap2430_glue		*glue;
-	int				ret = -ENOMEM;
-
-	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
-	if (!glue) {
-		dev_err(&pdev->dev, "failed to allocate glue context\n");
-		goto err0;
+	struct omap2430_musb_platdata *platdata = dev_get_platdata(dev);
+	const void *fdt = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+
+	platdata->base = (void *)dev_read_addr_ptr(dev);
+
+	platdata->musb_config.multipoint = fdtdec_get_int(fdt, node,
+							  "multipoint",
+							  -1);
+	if (platdata->musb_config.multipoint < 0) {
+		pr_err("MUSB multipoint DT entry missing\n");
+		return -ENOENT;
 	}
 
-	musb = platform_device_alloc("musb-hdrc", -1);
-	if (!musb) {
-		dev_err(&pdev->dev, "failed to allocate musb device\n");
-		goto err0;
+	platdata->musb_config.dyn_fifo = 1;
+	platdata->musb_config.num_eps = fdtdec_get_int(fdt, node,
+						       "num-eps", -1);
+	if (platdata->musb_config.num_eps < 0) {
+		pr_err("MUSB num-eps DT entry missing\n");
+		return -ENOENT;
 	}
 
-	musb->dev.parent		= &pdev->dev;
-	musb->dev.dma_mask		= &omap2430_dmamask;
-	musb->dev.coherent_dma_mask	= omap2430_dmamask;
-
-	glue->dev			= &pdev->dev;
-	glue->musb			= musb;
-	glue->status			= OMAP_MUSB_UNKNOWN;
-
-	pdata->platform_ops		= &omap2430_ops;
-
-	platform_set_drvdata(pdev, glue);
-
-	/*
-	 * REVISIT if we ever have two instances of the wrapper, we will be
-	 * in big trouble
-	 */
-	_glue	= glue;
-
-	INIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);
-
-	ret = platform_device_add_resources(musb, pdev->resource,
-			pdev->num_resources);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to add resources\n");
-		goto err1;
+	platdata->musb_config.ram_bits = fdtdec_get_int(fdt, node,
+							"ram-bits", -1);
+	if (platdata->musb_config.ram_bits < 0) {
+		pr_err("MUSB ram-bits DT entry missing\n");
+		return -ENOENT;
 	}
 
-	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
-	if (ret) {
-		dev_err(&pdev->dev, "failed to add platform_data\n");
-		goto err1;
+	platdata->plat.power = fdtdec_get_int(fdt, node,
+								"power", -1);
+	if (platdata->plat.power < 0) {
+		pr_err("MUSB power DT entry missing\n");
+		return -ENOENT;
 	}
 
-	pm_runtime_enable(&pdev->dev);
-
-	ret = platform_device_add(musb);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err1;
+	platdata->otg_board_data.interface_type = fdtdec_get_int(fdt, node,
+									"interface-type", -1);
+	if (platdata->otg_board_data.interface_type < 0) {
+		pr_err("MUSB interface-type DT entry missing\n");
+		return -ENOENT;
 	}
 
-	return 0;
-
-err1:
-	platform_device_put(musb);
-
-err0:
-	return ret;
-}
-
-static int __devexit omap2430_remove(struct platform_device *pdev)
-{
-	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
-
-	cancel_work_sync(&glue->omap_musb_mailbox_work);
-	platform_device_del(glue->musb);
-	platform_device_put(glue->musb);
-
+#if 0 /* In a perfect world, mode would be set to OTG, mode 3 from DT */
+	platdata->plat.mode = fdtdec_get_int(fdt, node,
+										"mode", -1);
+	if (platdata->plat.mode < 0) {
+		pr_err("MUSB mode DT entry missing\n");
+		return -ENOENT;
+	}
+#else /* MUSB_OTG, it doesn't work */
+#ifdef CONFIG_USB_MUSB_HOST /* Host seems to be the only option that works */
+	platdata->plat.mode = MUSB_HOST;
+#else /* For that matter, MUSB_PERIPHERAL doesn't either */
+	platdata->plat.mode = MUSB_PERIPHERAL;
+#endif
+#endif
+	platdata->otg_board_data.dev = dev;
+	platdata->plat.config = &platdata->musb_config;
+	platdata->plat.platform_ops = &omap2430_ops;
+	platdata->plat.board_data = &platdata->otg_board_data;
 	return 0;
 }
 
-#ifdef CONFIG_PM
-
-static int omap2430_runtime_suspend(struct device *dev)
+static int omap2430_musb_probe(struct udevice *dev)
 {
-	struct omap2430_glue		*glue = dev_get_drvdata(dev);
-	struct musb			*musb = glue_to_musb(glue);
-
-	if (musb) {
-		musb->context.otg_interfsel = musb_readl(musb->mregs,
-				OTG_INTERFSEL);
-
-		omap2430_low_level_exit(musb);
-		usb_phy_set_suspend(musb->xceiv, 1);
+#ifdef CONFIG_USB_MUSB_HOST
+	struct musb_host_data *host = dev_get_priv(dev);
+#endif
+	struct omap2430_musb_platdata *platdata = dev_get_platdata(dev);
+	struct usb_bus_priv *priv = dev_get_uclass_priv(dev);
+	struct omap_musb_board_data *otg_board_data;
+	int ret;
+	void *base = dev_read_addr_ptr(dev);
+
+	priv->desc_before_addr = true;
+
+	otg_board_data = &platdata->otg_board_data;
+
+#ifdef CONFIG_USB_MUSB_HOST
+	host->host = musb_init_controller(&platdata->plat,
+					  (struct device *)otg_board_data,
+					  platdata->base);
+	if (!host->host) {
+		return -EIO;
 	}
 
-	return 0;
+	ret = musb_lowlevel_init(host);
+#else
+	ret = musb_register(&platdata->plat,
+			  (struct device *)otg_board_data,
+			  platdata->base);
+#endif
+	return ret;
 }
 
-static int omap2430_runtime_resume(struct device *dev)
+static int omap2430_musb_remove(struct udevice *dev)
 {
-	struct omap2430_glue		*glue = dev_get_drvdata(dev);
-	struct musb			*musb = glue_to_musb(glue);
+	struct musb_host_data *host = dev_get_priv(dev);
 
-	if (musb) {
-		omap2430_low_level_init(musb);
-		musb_writel(musb->mregs, OTG_INTERFSEL,
-				musb->context.otg_interfsel);
-
-		usb_phy_set_suspend(musb->xceiv, 0);
-	}
+	musb_stop(host->host);
 
 	return 0;
 }
 
-static struct dev_pm_ops omap2430_pm_ops = {
-	.runtime_suspend = omap2430_runtime_suspend,
-	.runtime_resume = omap2430_runtime_resume,
+static const struct udevice_id omap2430_musb_ids[] = {
+	{ .compatible = "ti,omap3-musb" },
+	{ .compatible = "ti,omap4-musb" },
+	{ }
 };
 
-#define DEV_PM_OPS	(&omap2430_pm_ops)
+U_BOOT_DRIVER(omap2430_musb) = {
+	.name	= "omap2430-musb",
+#ifdef CONFIG_USB_MUSB_HOST
+	.id		= UCLASS_USB,
 #else
-#define DEV_PM_OPS	NULL
+	.id		= UCLASS_USB_GADGET_GENERIC,
 #endif
-
-static struct platform_driver omap2430_driver = {
-	.probe		= omap2430_probe,
-	.remove		= __devexit_p(omap2430_remove),
-	.driver		= {
-		.name	= "musb-omap2430",
-		.pm	= DEV_PM_OPS,
-	},
+	.of_match = omap2430_musb_ids,
+	.ofdata_to_platdata = omap2430_musb_ofdata_to_platdata,
+	.probe = omap2430_musb_probe,
+	.remove = omap2430_musb_remove,
+#ifdef CONFIG_USB_MUSB_HOST
+	.ops = &musb_usb_ops,
+#endif
+	.platdata_auto_alloc_size = sizeof(struct omap2430_musb_platdata),
+	.priv_auto_alloc_size = sizeof(struct musb_host_data),
 };
 
-MODULE_DESCRIPTION("OMAP2PLUS MUSB Glue Layer");
-MODULE_AUTHOR("Felipe Balbi <balbi@ti.com>");
-MODULE_LICENSE("GPL v2");
-
-static int __init omap2430_init(void)
-{
-	return platform_driver_register(&omap2430_driver);
-}
-subsys_initcall(omap2430_init);
-
-static void __exit omap2430_exit(void)
-{
-	platform_driver_unregister(&omap2430_driver);
-}
-module_exit(omap2430_exit);
-#endif
+#endif /* CONFIG_IS_ENABLED(DM_USB) */
diff --git a/drivers/usb/musb-new/sunxi.c b/drivers/usb/musb-new/sunxi.c
index 5c1a902e42..d5bba5996a 100644
--- a/drivers/usb/musb-new/sunxi.c
+++ b/drivers/usb/musb-new/sunxi.c
@@ -76,6 +76,13 @@
  * From usbc/usbc.c
  ******************************************************************************/
 
+struct sunxi_glue {
+	struct musb_host_data mdata;
+	struct sunxi_ccm_reg *ccm;
+	struct device dev;
+};
+#define to_sunxi_glue(d)	container_of(d, struct sunxi_glue, dev)
+
 static u32 USBC_WakeUp_ClearChangeDetect(u32 reg_val)
 {
 	u32 temp = reg_val;
@@ -256,15 +263,15 @@ static void sunxi_musb_disable(struct musb *musb)
 
 static int sunxi_musb_init(struct musb *musb)
 {
-	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_glue *glue = to_sunxi_glue(musb->controller);
 
 	pr_debug("%s():\n", __func__);
 
 	musb->isr = sunxi_musb_interrupt;
 
-	setbits_le32(&ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_USB0);
+	setbits_le32(&glue->ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_USB0);
 #ifdef CONFIG_SUNXI_GEN_SUN6I
-	setbits_le32(&ccm->ahb_reset0_cfg, 1 << AHB_GATE_OFFSET_USB0);
+	setbits_le32(&glue->ccm->ahb_reset0_cfg, 1 << AHB_GATE_OFFSET_USB0);
 #endif
 	sunxi_usb_phy_init(0);
 
@@ -308,43 +315,52 @@ static struct musb_hdrc_platform_data musb_plat = {
 	.platform_ops	= &sunxi_musb_ops,
 };
 
-#ifdef CONFIG_USB_MUSB_HOST
-static int musb_usb_remove(struct udevice *dev);
-
 static int musb_usb_probe(struct udevice *dev)
 {
-	struct musb_host_data *host = dev_get_priv(dev);
+	struct sunxi_glue *glue = dev_get_priv(dev);
+	struct musb_host_data *host = &glue->mdata;
 	struct usb_bus_priv *priv = dev_get_uclass_priv(dev);
+	void *base = dev_read_addr_ptr(dev);
 	int ret;
 
+	if (!base)
+		return -EINVAL;
+
+	glue->ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	if (IS_ERR(glue->ccm))
+		return PTR_ERR(glue->ccm);
+
 	priv->desc_before_addr = true;
 
-	host->host = musb_init_controller(&musb_plat, NULL,
-					  (void *)SUNXI_USB0_BASE);
+#ifdef CONFIG_USB_MUSB_HOST
+	host->host = musb_init_controller(&musb_plat, &glue->dev, base);
 	if (!host->host)
 		return -EIO;
 
 	ret = musb_lowlevel_init(host);
-	if (ret == 0)
-		printf("MUSB OTG\n");
-	else
-		musb_usb_remove(dev);
+	if (!ret)
+		printf("Allwinner mUSB OTG (Host)\n");
+#else
+	ret = musb_register(&musb_plat, &glue->dev, base);
+	if (!ret)
+		printf("Allwinner mUSB OTG (Peripheral)\n");
+#endif
 
 	return ret;
 }
 
 static int musb_usb_remove(struct udevice *dev)
 {
-	struct musb_host_data *host = dev_get_priv(dev);
-	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_glue *glue = dev_get_priv(dev);
+	struct musb_host_data *host = &glue->mdata;
 
 	musb_stop(host->host);
 
 	sunxi_usb_phy_exit(0);
 #ifdef CONFIG_SUNXI_GEN_SUN6I
-	clrbits_le32(&ccm->ahb_reset0_cfg, 1 << AHB_GATE_OFFSET_USB0);
+	clrbits_le32(&glue->ccm->ahb_reset0_cfg, 1 << AHB_GATE_OFFSET_USB0);
 #endif
-	clrbits_le32(&ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_USB0);
+	clrbits_le32(&glue->ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_USB0);
 
 	free(host->host);
 	host->host = NULL;
@@ -352,30 +368,27 @@ static int musb_usb_remove(struct udevice *dev)
 	return 0;
 }
 
-U_BOOT_DRIVER(usb_musb) = {
-	.name	= "sunxi-musb",
-	.id	= UCLASS_USB,
-	.probe = musb_usb_probe,
-	.remove = musb_usb_remove,
-	.ops	= &musb_usb_ops,
-	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
-	.priv_auto_alloc_size = sizeof(struct musb_host_data),
+static const struct udevice_id sunxi_musb_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10-musb" },
+	{ .compatible = "allwinner,sun6i-a31-musb" },
+	{ .compatible = "allwinner,sun8i-a33-musb" },
+	{ .compatible = "allwinner,sun8i-h3-musb" },
+	{ }
 };
-#endif
 
-void sunxi_musb_board_init(void)
-{
+U_BOOT_DRIVER(usb_musb) = {
+	.name		= "sunxi-musb",
 #ifdef CONFIG_USB_MUSB_HOST
-	struct udevice *dev;
-
-	/*
-	 * Bind the driver directly for now as musb linux kernel support is
-	 * still pending upstream so our dts files do not have the necessary
-	 * nodes yet. TODO: Remove this as soon as the dts nodes are in place
-	 * and bind by compatible instead.
-	 */
-	device_bind_driver(dm_root(), "sunxi-musb", "sunxi-musb", &dev);
+	.id		= UCLASS_USB,
 #else
-	musb_register(&musb_plat, NULL, (void *)SUNXI_USB0_BASE);
+	.id		= UCLASS_USB_GADGET_GENERIC,
 #endif
-}
+	.of_match	= sunxi_musb_ids,
+	.probe		= musb_usb_probe,
+	.remove		= musb_usb_remove,
+#ifdef CONFIG_USB_MUSB_HOST
+	.ops		= &musb_usb_ops,
+#endif
+	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
+	.priv_auto_alloc_size = sizeof(struct sunxi_glue),
+};
diff --git a/drivers/usb/musb-new/ti-musb.c b/drivers/usb/musb-new/ti-musb.c
index de101319cd..e0077ea523 100644
--- a/drivers/usb/musb-new/ti-musb.c
+++ b/drivers/usb/musb-new/ti-musb.c
@@ -20,7 +20,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 
 /* USB 2.0 PHY Control */
 #define CM_PHY_PWRDN			(1 << 0)
@@ -106,7 +106,7 @@ static int ti_musb_ofdata_to_platdata(struct udevice *dev)
 							  "mentor,multipoint",
 							  -1);
 	if (platdata->musb_config.multipoint < 0) {
-		error("MUSB multipoint DT entry missing\n");
+		pr_err("MUSB multipoint DT entry missing\n");
 		return -ENOENT;
 	}
 
@@ -115,14 +115,14 @@ static int ti_musb_ofdata_to_platdata(struct udevice *dev)
 	platdata->musb_config.num_eps = fdtdec_get_int(fdt, node,
 						       "mentor,num-eps", -1);
 	if (platdata->musb_config.num_eps < 0) {
-		error("MUSB num-eps DT entry missing\n");
+		pr_err("MUSB num-eps DT entry missing\n");
 		return -ENOENT;
 	}
 
 	platdata->musb_config.ram_bits = fdtdec_get_int(fdt, node,
 							"mentor,ram-bits", -1);
 	if (platdata->musb_config.ram_bits < 0) {
-		error("MUSB ram-bits DT entry missing\n");
+		pr_err("MUSB ram-bits DT entry missing\n");
 		return -ENOENT;
 	}
 
@@ -132,7 +132,7 @@ static int ti_musb_ofdata_to_platdata(struct udevice *dev)
 
 	platdata->plat.power = fdtdec_get_int(fdt, node, "mentor,power", -1);
 	if (platdata->plat.power < 0) {
-		error("MUSB mentor,power DT entry missing\n");
+		pr_err("MUSB mentor,power DT entry missing\n");
 		return -ENOENT;
 	}
 
@@ -183,7 +183,7 @@ static int ti_musb_host_ofdata_to_platdata(struct udevice *dev)
 
 	ret = ti_musb_ofdata_to_platdata(dev);
 	if (ret) {
-		error("platdata dt parse error\n");
+		pr_err("platdata dt parse error\n");
 		return ret;
 	}
 
@@ -205,14 +205,12 @@ U_BOOT_DRIVER(ti_musb_host) = {
 
 static int ti_musb_wrapper_bind(struct udevice *parent)
 {
-	const void *fdt = gd->fdt_blob;
-	int node;
+	ofnode node;
 	int ret;
 
-	for (node = fdt_first_subnode(fdt, dev_of_offset(parent)); node > 0;
-	     node = fdt_next_subnode(fdt, node)) {
+	ofnode_for_each_subnode(node, parent->node) {
 		struct udevice *dev;
-		const char *name = fdt_get_name(fdt, node, NULL);
+		const char *name = ofnode_get_name(node);
 		enum usb_dr_mode dr_mode;
 		struct driver *drv;
 
@@ -226,10 +224,13 @@ static int ti_musb_wrapper_bind(struct udevice *parent)
 			break;
 		case USB_DR_MODE_HOST:
 			/* Bind MUSB host */
-			ret = device_bind_driver_to_node(parent, "ti-musb-host",
-					name, offset_to_ofnode(node), &dev);
+			ret = device_bind_driver_to_node(parent,
+							 "ti-musb-host",
+							 name,
+							 node,
+							 &dev);
 			if (ret) {
-				error("musb - not able to bind usb host node\n");
+				pr_err("musb - not able to bind usb host node\n");
 				return ret;
 			}
 			break;
@@ -252,4 +253,4 @@ U_BOOT_DRIVER(ti_musb_wrapper) = {
 	.bind = ti_musb_wrapper_bind,
 };
 
-#endif /* CONFIG_DM_USB */
+#endif /* CONFIG_IS_ENABLED(DM_USB) */
diff --git a/drivers/usb/musb-new/usb-compat.h b/drivers/usb/musb-new/usb-compat.h
index 760bd787bc..f2c18ad3a2 100644
--- a/drivers/usb/musb-new/usb-compat.h
+++ b/drivers/usb/musb-new/usb-compat.h
@@ -67,7 +67,7 @@ static inline int usb_hcd_unmap_urb_for_dma(struct usb_hcd *hcd,
 	return 0;
 }
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 static inline struct usb_device *usb_dev_get_parent(struct usb_device *udev)
 {
 	struct udevice *parent = udev->dev->parent;
diff --git a/drivers/usb/musb/musb_hcd.c b/drivers/usb/musb/musb_hcd.c
index fee0848ade..82fcb76081 100644
--- a/drivers/usb/musb/musb_hcd.c
+++ b/drivers/usb/musb/musb_hcd.c
@@ -1056,8 +1056,8 @@ int usb_lowlevel_stop(int index)
  * This function supports usb interrupt transfers. Currently, usb interrupt
  * transfers are not supported.
  */
-int submit_int_msg(struct usb_device *dev, unsigned long pipe,
-				void *buffer, int len, int interval)
+int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		   int len, int interval, bool nonblock)
 {
 	int dir_out = usb_pipeout(pipe);
 	int ep = usb_pipeendpoint(pipe);
diff --git a/drivers/usb/phy/omap_usb_phy.c b/drivers/usb/phy/omap_usb_phy.c
index 7c7fba21f4..0461f21575 100644
--- a/drivers/usb/phy/omap_usb_phy.c
+++ b/drivers/usb/phy/omap_usb_phy.c
@@ -20,7 +20,7 @@
 #include <linux/usb/dwc3.h>
 #include <linux/usb/xhci-omap.h>
 
-#include "../host/xhci.h"
+#include <usb/xhci.h>
 
 #ifdef CONFIG_OMAP_USB3PHY1_HOST
 struct usb3_dpll_params {
diff --git a/drivers/usb/phy/rockchip_usb2_phy.c b/drivers/usb/phy/rockchip_usb2_phy.c
index 1958478d62..88c03c8aec 100644
--- a/drivers/usb/phy/rockchip_usb2_phy.c
+++ b/drivers/usb/phy/rockchip_usb2_phy.c
@@ -5,8 +5,13 @@
  */
 
 #include <common.h>
+#include <asm/arch-rockchip/clock.h>
 #include <asm/io.h>
-#include <libfdt.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <syscon.h>
+#include <linux/libfdt.h>
 
 #include "../gadget/dwc2_udc_otg_priv.h"
 
@@ -30,6 +35,7 @@ struct usb2phy_reg {
  */
 struct rockchip_usb2_phy_cfg {
 	struct usb2phy_reg port_reset;
+	struct usb2phy_reg siddq;
 	struct usb2phy_reg soft_con;
 	struct usb2phy_reg suspend;
 };
@@ -41,6 +47,7 @@ struct rockchip_usb2_phy_dt_id {
 
 static const struct rockchip_usb2_phy_cfg rk3288_pdata = {
 	.port_reset     = {0x00, 12, 12, 0, 1},
+	.siddq		= {0x00, 13, 13, 0, 1},
 	.soft_con       = {0x08, 2, 2, 0, 1},
 	.suspend	= {0x0c, 5, 0, 0x01, 0x2A},
 };
@@ -62,6 +69,92 @@ static void property_enable(struct dwc2_plat_otg_data *pdata,
 	writel(val, pdata->regs_phy + reg->offset);
 }
 
+int rockchip_u2phy_vbus_detect(void)
+{
+	u32 val = 0;
+
+#ifdef CONFIG_ROCKCHIP_RK3288
+	u32 grf_base = (u32)syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	val = readl(grf_base + 0x288);
+	val = (val & BIT(14)) >> 14;
+#endif
+
+	return val;
+}
+
+static int otg_phy_parse(struct dwc2_udc *dev)
+{
+	int node, phy_node;
+	u32 grf_base, grf_offset;
+	const void *blob = gd->fdt_blob;
+	const fdt32_t *reg;
+	fdt_addr_t addr;
+	struct dwc2_plat_otg_data *pdata = dev->pdata;
+
+	/* Find the usb_otg node */
+	node = fdt_node_offset_by_compatible(blob, -1, "snps,dwc2");
+
+#if defined(CONFIG_ROCKCHIP_RK3288)
+retry:
+#endif
+	if (node > 0) {
+		reg = fdt_getprop(blob, node, "reg", NULL);
+		if (!reg)
+			return -EINVAL;
+
+		addr = fdt_translate_address(blob, node, reg);
+		if (addr == OF_BAD_ADDR) {
+			pr_err("Not found usb_otg address\n");
+			return -EINVAL;
+		}
+
+#if defined(CONFIG_ROCKCHIP_RK3288)
+		if (addr != 0xff580000) {
+			node = fdt_node_offset_by_compatible(blob, node,
+							     "snps,dwc2");
+			goto retry;
+		}
+#endif
+	} else {
+		/*
+		 * With kernel dtb support, rk3288 dwc2 otg node
+		 * use the rockchip legacy dwc2 driver "dwc_otg_310"
+		 * with the compatible "rockchip,rk3288_usb20_otg".
+		 */
+#if defined(CONFIG_ROCKCHIP_RK3288)
+		node = fdt_node_offset_by_compatible(blob, -1,
+				"rockchip,rk3288_usb20_otg");
+#endif
+		if (node < 0) {
+			pr_err("Not found usb_otg device\n");
+			return -ENODEV;
+		}
+	}
+
+	/* Find the usb phy node */
+	node = fdtdec_lookup_phandle(blob, node, "phys");
+	if (node <= 0) {
+		pr_err("Not found usbphy device\n");
+		return -ENODEV;
+	}
+
+	/* Find the usb otg-phy node */
+	phy_node = fdt_parent_offset(blob, node);
+	if (phy_node <= 0) {
+		pr_err("Not found sub usbphy device\n");
+		return -ENODEV;
+	}
+
+	grf_base = (u32)syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	grf_offset = fdtdec_get_addr(blob, node, "reg");
+
+	/* Pad dwc2_plat_otg_data related to phy */
+	pdata->phy_of_node = phy_node;
+	pdata->regs_phy = grf_base + grf_offset;
+
+	return 0;
+}
 
 void otg_phy_init(struct dwc2_udc *dev)
 {
@@ -70,6 +163,11 @@ void otg_phy_init(struct dwc2_udc *dev)
 	struct rockchip_usb2_phy_dt_id *of_id;
 	int i;
 
+	if (!pdata->regs_phy && otg_phy_parse(dev)) {
+		pr_err("otg-phy parse error\n");
+		return;
+	}
+
 	for (i = 0; i < ARRAY_SIZE(rockchip_usb2_phy_dt_ids); i++) {
 		of_id = &rockchip_usb2_phy_dt_ids[i];
 		if (fdt_node_check_compatible(gd->fdt_blob, pdata->phy_of_node,
@@ -85,6 +183,10 @@ void otg_phy_init(struct dwc2_udc *dev)
 		return;
 	}
 	pdata->priv = phy_cfg;
+
+	/* power up usb phy analog blocks by set siddq 0 */
+	property_enable(pdata, &phy_cfg->siddq, false);
+
 	/* disable software control */
 	property_enable(pdata, &phy_cfg->soft_con, false);
 
@@ -100,6 +202,11 @@ void otg_phy_off(struct dwc2_udc *dev)
 	struct dwc2_plat_otg_data *pdata = dev->pdata;
 	struct rockchip_usb2_phy_cfg *phy_cfg = pdata->priv;
 
+	if (!pdata->regs_phy && otg_phy_parse(dev)) {
+		pr_err("otg-phy parse error\n");
+		return;
+	}
+
 	/* enable software control */
 	property_enable(pdata, &phy_cfg->soft_con, true);
 	/* enter suspend */
diff --git a/drivers/usb/ulpi/Kconfig b/drivers/usb/ulpi/Kconfig
index 329d2df3ed..001564d40c 100644
--- a/drivers/usb/ulpi/Kconfig
+++ b/drivers/usb/ulpi/Kconfig
@@ -3,7 +3,6 @@ comment "ULPI drivers"
 choice
 	prompt "ULPI Viewport type"
 	optional
-	default n
 	help
 	  Select ULPI viewport (SoC-side interface to ULPI) implementation
 	  appropriate for the device if you want to communicate with
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index fc46b6774d..629b6523a2 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -78,4 +78,10 @@ config WDT_ORION
 	   Select this to enable Orion watchdog timer, which can be found on some
 	   Marvell Armada chips.
 
+config ROCKCHIP_WATCHDOG
+	bool "Rockchip watchdog"
+	depends on WDT && ARCH_ROCKCHIP
+	help
+	  Say Y here to enable Rockchip watchdog driver.
+
 endmenu
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index ab6a6b79e1..8504408958 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -22,3 +22,6 @@ obj-$(CONFIG_WDT_ASPEED) += ast_wdt.o
 obj-$(CONFIG_WDT_BCM6345) += bcm6345_wdt.o
 obj-$(CONFIG_BCM2835_WDT)       += bcm2835_wdt.o
 obj-$(CONFIG_WDT_ORION) += orion_wdt.o
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
+obj-$(CONFIG_ROCKCHIP_WATCHDOG) += rockchip_wdt.o
+endif
diff --git a/dts/Kconfig b/dts/Kconfig
index b4b7ddc144..f1c1d9a15e 100644
--- a/dts/Kconfig
+++ b/dts/Kconfig
@@ -5,11 +5,26 @@
 config SUPPORT_OF_CONTROL
 	bool
 
+config DTC
+	bool
+
+config PYLIBFDT
+	bool
+
+config DTOC
+	bool
+	select PYLIBFDT
+
+config BINMAN
+	bool
+	select DTOC
+
 menu "Device Tree Control"
 	depends on SUPPORT_OF_CONTROL
 
 config OF_CONTROL
 	bool "Run-time configuration via Device Tree"
+	select DTC
 	help
 	  This feature provides for run-time configuration of U-Boot
 	  via a flattened device tree.
@@ -32,6 +47,16 @@ config SPL_OF_CONTROL
 	  which is not enough to support device tree. Enable this option to
 	  allow such boards to be supported by U-Boot SPL.
 
+config SPL_DTB_MINIMUM
+	bool "Provide a minimum SPL DTB "
+	depends on SPL_OF_CONTROL
+	default n
+	help
+	  Some boards need a SPL DTB as smaller as possible to save dm scan
+	  time and space. It provides a SPL DTB only include the node with
+	  property "u-boot,dm-spl". The property "u-boot,pre-reloc" doesn't
+	  work any more.
+
 config TPL_OF_CONTROL
 	bool "Enable run-time configuration via Device Tree in TPL"
 	depends on TPL && OF_CONTROL
@@ -86,6 +111,13 @@ config OF_HOSTFILE
 	  This is only useful for Sandbox.  Use the -d flag to U-Boot to
 	  specify the file to read.
 
+config OF_PRIOR_STAGE
+	bool "Prior stage bootloader DTB for DT control"
+	help
+	  If this option is enabled, the device tree used for DT
+	  control will be read from a device tree binary, at a memory
+	  location passed to U-Boot by the prior stage bootloader.
+
 endchoice
 
 config DEFAULT_DEVICE_TREE
@@ -98,7 +130,7 @@ config DEFAULT_DEVICE_TREE
 
 config OF_LIST
 	string "List of device tree files to include for DT control"
-	depends on SPL_LOAD_FIT || FIT_EMBED
+	depends on SPL_LOAD_FIT || MULTI_DTB_FIT
 	default DEFAULT_DEVICE_TREE
 	help
 	  This option specifies a list of device tree files to use for DT
@@ -108,9 +140,109 @@ config OF_LIST
 	  device tree files (without the directory or .dtb suffix)
 	  separated by <space>.
 
+
+config DTB_RESELECT
+	bool "Support swapping dtbs at a later point in boot"
+	depends on MULTI_DTB_FIT
+	help
+	  It is possible during initial boot you may need to use a generic
+	  dtb until you can fully determine the board your running on. This
+	  config allows boards to implement a function at a later point
+	  during boot to switch to the "correct" dtb.
+
+config MULTI_DTB_FIT
+	bool "Support embedding several DTBs in a FIT image for u-boot"
+	help
+	  This option provides hooks to allow U-boot to parse an
+	  appended FIT image and enable board specific code to then select
+	  the correct DTB to be used. Use this if you need to support
+	  multiple DTBs but don't use the SPL.
+
+
+config SPL_MULTI_DTB_FIT
+	depends on SPL_LOAD_FIT && SPL_OF_CONTROL && !SPL_OF_PLATDATA
+	bool "Support embedding several DTBs in a FIT image for the SPL"
+	help
+	  This option provides the SPL with the ability to select its own
+	  DTB at runtime from an appended FIT image containing several DTBs.
+	  This allows using the same SPL binary on multiple platforms.
+	  The primary purpose is to handle different versions of
+	  the same platform without tweaking the platform code if the
+	  differences can be expressed in the DTBs (common examples are: bus
+	  capabilities, pad configurations).
+
+config SPL_OF_LIST
+	string "List of device tree files to include for DT control in SPL"
+	depends on SPL_MULTI_DTB_FIT
+	default OF_LIST
+	help
+	  This option specifies a list of device tree files to use for DT
+	  control in the SPL. These will be packaged into a FIT. At run-time,
+	  the SPL will select the correct DT to use by examining the
+	  hardware (e.g. reading a board ID value). This is a list of
+	  device tree files (without the directory or .dtb suffix)
+	  separated by <space>.
+
+choice
+	prompt "SPL OF LIST compression"
+	depends on SPL_MULTI_DTB_FIT
+	default SPL_MULTI_DTB_FIT_LZO
+
+config SPL_MULTI_DTB_FIT_LZO
+	bool "LZO"
+	depends on SYS_MALLOC_F
+	select SPL_LZO
+	help
+	  Compress the FIT image containing the DTBs available for the SPL
+	  using LZO compression. (requires lzop on host).
+
+config SPL_MULTI_DTB_FIT_GZIP
+	bool "GZIP"
+	depends on SYS_MALLOC_F
+	select SPL_GZIP
+	help
+	  Compress the FIT image containing the DTBs available for the SPL
+	  using GZIP compression. (requires gzip on host)
+
+config SPL_MULTI_DTB_FIT_NO_COMPRESSION
+	bool "No compression"
+	help
+	  Do not compress the FIT image containing the DTBs available for the SPL.
+	  Use this options only if LZO is not available and the DTBs are very small.
+endchoice
+
+choice
+	prompt "Location of uncompressed DTBs "
+	depends on (SPL_MULTI_DTB_FIT_GZIP || SPL_MULTI_DTB_FIT_LZO)
+	default SPL_MULTI_DTB_FIT_DYN_ALLOC if SYS_MALLOC_F
+
+config SPL_MULTI_DTB_FIT_DYN_ALLOC
+	bool "Dynamically allocate the memory"
+	depends on SYS_MALLOC_F
+
+config SPL_MULTI_DTB_FIT_USER_DEFINED_AREA
+	bool "User-defined location"
+endchoice
+
+config SPL_MULTI_DTB_FIT_UNCOMPRESS_SZ
+	hex "Size of memory reserved to uncompress the DTBs"
+	depends on (SPL_MULTI_DTB_FIT_GZIP || SPL_MULTI_DTB_FIT_LZO)
+	default 0x8000
+	help
+	   This is the size of this area where the DTBs are uncompressed.
+	   If this area is dynamically allocated, make sure that
+	   SPL_SYS_MALLOC_F_LEN is big enough to contain it.
+
+config SPL_MULTI_DTB_FIT_USER_DEF_ADDR
+	hex "Address of memory where dtbs are uncompressed"
+	depends on SPL_MULTI_DTB_FIT_USER_DEFINED_AREA
+	help
+	   the FIT image containing the DTBs is uncompressed in an area defined
+	   at compilation time. This is the address of this area. It must be
+	   aligned on 2-byte boundary.
+
 config OF_SPL_REMOVE_PROPS
 	string "List of device tree properties to drop for SPL"
-	depends on SPL_OF_CONTROL
 	default "interrupt-parent" if SPL_PINCTRL && SPL_CLK
 	default "clocks clock-names interrupt-parent" if SPL_PINCTRL
 	default "pinctrl-0 pinctrl-names interrupt-parent" if SPL_CLK
@@ -123,9 +255,20 @@ config OF_SPL_REMOVE_PROPS
 	  can be discarded. This option defines the list of properties to
 	  discard.
 
+config OF_U_BOOT_REMOVE_PROPS
+	string "List of device tree properties to drop for U-Boot"
+	depends on USING_KERNEL_DTB
+	default ""
+	help
+	  Since kernel dtb feature is enabled, U-Boot prop use the same device tree as SPL.
+	  At sometimes there is different require for list of device tree properties to drop
+	  for U-Boot prop, so providing this configure which has higher priority, that if it
+	  is defined empty string, fallback to use OF_SPL_REMOVE_PROPS.
+
 config SPL_OF_PLATDATA
 	bool "Generate platform data for use in SPL"
 	depends on SPL_OF_CONTROL
+	select DTOC
 	help
 	  For very constrained SPL environments the overhead of decoding
 	  device tree nodes and converting their contents into platform data
@@ -147,6 +290,7 @@ config SPL_OF_PLATDATA
 config TPL_OF_PLATDATA
 	bool "Generate platform data for use in TPL"
 	depends on TPL_OF_CONTROL
+	select DTOC
 	help
 	  For very constrained SPL environments the overhead of decoding
 	  device tree nodes and converting their contents into platform data
@@ -166,3 +310,12 @@ config TPL_OF_PLATDATA
 	  information.
 
 endmenu
+
+config MKIMAGE_DTC_PATH
+	string "Path to dtc binary for use within mkimage"
+	default "dtc"
+	help
+	  The mkimage host tool will, in order to generate FIT images make
+	  calls to the dtc application in order to create the output.  In
+	  some cases the system dtc may not support all required features
+	  and the path to a different version should be given here.
diff --git a/dts/Makefile b/dts/Makefile
index 3a93dafb51..5383dd6f9a 100644
--- a/dts/Makefile
+++ b/dts/Makefile
@@ -22,10 +22,68 @@ DTB := $(ARCH_PATH)/$(DEVICE_TREE).dtb
 dtb_depends += $(DTB:.dtb=.dts)
 endif
 
+# Pass the original device tree file through fdtgrep twice. The first pass
+# removes any unwanted nodes (i.e. those which don't have the
+# 'u-boot,dm-pre-reloc' property and thus are not needed by SPL. The second
+# pass removes various unused properties from the remaining nodes.
+# The output is typically a much smaller device tree file.
+ifeq ($(CONFIG_TPL_BUILD),y)
+fdtgrep_props := -b u-boot,dm-pre-reloc -b u-boot,dm-tpl
+else
+fdtgrep_props := -b u-boot,dm-pre-reloc -b u-boot,dm-spl
+endif
+
+quiet_cmd_fdtgrep = FDTGREP $@
+      cmd_fdtgrep = $(objtree)/tools/fdtgrep $(fdtgrep_props) -RT $< \
+                -n /chosen -n /config -O dtb | \
+        $(objtree)/tools/fdtgrep -r -O dtb - -o $@ \
+                $(addprefix -P ,$(subst $\",,$(CONFIG_OF_SPL_REMOVE_PROPS)))
+
+quiet_cmd_fdtgrep_uboot = FDTGREP $@
+      cmd_fdtgrep_uboot = $(objtree)/tools/fdtgrep $(fdtgrep_props) -RT $< \
+		-n /chosen -n /config -O dtb | \
+	$(objtree)/tools/fdtgrep -r -O dtb - -o $@ \
+		$(addprefix -P ,$(subst $\",,$(CONFIG_OF_U_BOOT_REMOVE_PROPS)))
+
+fdtgrep_tpl_props := -b u-boot,dm-pre-reloc -b u-boot,dm-tpl
+quiet_cmd_fdtgrep_tpl = FDTGREP $@
+      cmd_fdtgrep_tpl = $(objtree)/tools/fdtgrep $(fdtgrep_tpl_props) -RT $< \
+                -n /chosen -n config -O dtb | \
+        $(objtree)/tools/fdtgrep -r -O dtb - -o $@ \
+                $(addprefix -P ,$(subst $\",,$(CONFIG_OF_SPL_REMOVE_PROPS)))
+
+fdtgrep_spl_minimum_props := -b u-boot,dm-spl
+quiet_cmd_fdtgrep_spl_minimum = FDTGREP $@
+      cmd_fdtgrep_spl_minimum = $(objtree)/tools/fdtgrep $(fdtgrep_spl_minimum_props) -RT $< \
+                -n /chosen -n config -O dtb | \
+        $(objtree)/tools/fdtgrep -r -O dtb - -o $@ \
+                $(addprefix -P ,$(subst $\",,$(CONFIG_OF_SPL_REMOVE_PROPS)))
+
+$(obj)/dt-tpl.dtb: $(DTB) $(objtree)/tools/fdtgrep FORCE
+	$(call if_changed,fdtgrep_tpl)
+
+ifeq ($(CONFIG_SPL_DTB_MINIMUM),y)
+$(obj)/dt-spl.dtb: $(DTB) $(objtree)/tools/fdtgrep FORCE
+	$(call if_changed,fdtgrep_spl_minimum)
+else
+$(obj)/dt-spl.dtb: $(DTB) $(objtree)/tools/fdtgrep FORCE
+	$(call if_changed,fdtgrep)
+endif
+
+# Normally, usbplug is enabled with kernel dtb disabled
+ifneq ($(CONFIG_USING_KERNEL_DTB)$(CONFIG_SUPPORT_USBPLUG),)
+$(obj)/dt.dtb: $(DTB) $(objtree)/tools/fdtgrep FORCE
+ifneq ($(CONFIG_OF_U_BOOT_REMOVE_PROPS), "")
+	$(call if_changed,fdtgrep_uboot)
+else
+	$(call if_changed,fdtgrep)
+endif
+else
 $(obj)/dt.dtb: $(DTB) FORCE
 	$(call if_changed,shipped)
+endif
 
-targets += dt.dtb
+targets += dt.dtb dt-spl.dtb dt-tpl.dtb
 
 $(DTB): $(dtb_depends)
 ifeq ($(EXT_DTB),)
@@ -42,14 +100,25 @@ endif
 arch-dtbs:
 	$(Q)$(MAKE) $(build)=$(ARCH_PATH) dtbs
 
-.SECONDARY: $(obj)/dt.dtb.S
+.SECONDARY: $(obj)/dt.dtb.S $(obj)/dt-spl.dtb.S $(obj)/dt-tpl.dtb.S
 
+
+ifeq ($(CONFIG_SPL_BUILD),y)
+obj-$(CONFIG_OF_EMBED) := dt-spl.dtb.o
+# support "out-of-tree" build for dtb-spl
+$(obj)/dt-tpl.dtb.o: $(obj)/dt-tpl.dtb.S FORCE
+	$(call if_changed_dep,as_o_S)
+
+$(obj)/dt-spl.dtb.o: $(obj)/dt-spl.dtb.S FORCE
+	$(call if_changed_dep,as_o_S)
+else
 obj-$(CONFIG_OF_EMBED) := dt.dtb.o
+endif
 
-dtbs: $(obj)/dt.dtb
+dtbs: $(obj)/dt.dtb $(obj)/dt-spl.dtb $(obj)/dt-tpl.dtb
 	@:
 
-clean-files := dt.dtb.S
+clean-files := dt.dtb.S dt-spl.dtb.S dt-tpl.dtb.S
 
 # Let clean descend into dts directories
 subdir- += ../arch/arm/dts ../arch/microblaze/dts ../arch/mips/dts ../arch/sandbox/dts ../arch/x86/dts
diff --git a/env/Kconfig b/env/Kconfig
index 024d4d79bd..dae0c38d0e 100644
--- a/env/Kconfig
+++ b/env/Kconfig
@@ -40,20 +40,30 @@ config ENV_IS_NOWHERE
 	  stored. U-Boot will therefore always start up with a default
 	  environment.
 
-config ENV_IS_IN_DATAFLASH
-	bool "Environment in dataflash"
-	depends on !CHAIN_OF_TRUST
+config ENVF
+	bool "Environment fragment is store in envf partition"
+	depends on ENV_IS_NOWHERE
+	select ENV_PARTITION
 	help
-	  Define this if you have a DataFlash memory device which you
-	  want to use for the environment.
-
-	  - CONFIG_ENV_OFFSET:
-	  - CONFIG_ENV_ADDR:
-	  - CONFIG_ENV_SIZE:
-
-	  These three #defines specify the offset and size of the
-	  environment area within the total memory of your DataFlash placed
-	  at the specified address.
+	  Use this if you want to add a env fragment partition to overlay/store
+	  some specific environments.
+
+config SPL_ENVF
+	bool "Environment fragment is store in envf partition in SPL"
+	depends on ENVF && SPL
+	default y
+	select SPL_ENV_PARTITION
+	help
+	  Use this if you want to add a env fragment partition to overlay/store
+	  some specific environments in SPL. But now only parse env partition
+	  table.
+
+config ENVF_LIST
+	string "Specific environments white list of env fragment"
+	depends on ENVF
+	default "blkdevparts mtdparts sys_bootargs app reserved"
+	help
+	  The environment white list.
 
 config ENV_IS_IN_EEPROM
 	bool "Environment in EEPROM"
@@ -373,6 +383,40 @@ config ENV_IS_IN_UBI
 	  You will probably want to define these to avoid a really noisy system
 	  when storing the env in UBI.
 
+config ENV_IS_IN_BLK_DEV
+	bool "Environment in a block device"
+	depends on !CHAIN_OF_TRUST && BLK
+	help
+	  Define this if you have an Block device which you want to use for the
+	  environment.
+
+	  - CONFIG_ENV_OFFSET:
+	  - CONFIG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the environment
+	  area within the specified Block device. These two values are in units
+	  of bytes, but must be aligned to an Block sector boundary.
+
+	  - CONFIG_ENV_OFFSET_REDUND (optional):
+
+	  Specifies a second storage area, of CONFIG_ENV_SIZE size, used to
+	  hold a redundant copy of the environment data. This provides a
+	  valid backup copy in case the other copy is corrupted, e.g. due
+	  to a power failure during a "saveenv" operation. This is handled
+	  in the same way as CONFIG_ENV_OFFSET.
+
+	  - CONFIG_ENV_SIZE_REDUND (optional):
+
+	  This value need not be set, even when CONFIG_ENV_OFFSET_REDUND is
+	  set. If this value is set, it must be set to the same value as
+	  CONFIG_ENV_SIZE.
+
+	  - CONFIG_SYS_MMC_ENV_PART (optional):
+
+	  Specifies which MMC partition the environment is stored in. If not
+	  set, defaults to partition 0, the user area. Common values might be
+	  1 (first MMC boot partition), 2 (second MMC boot partition).
+
 endchoice
 
 config ENV_AES
@@ -450,4 +494,60 @@ config ENV_UBI_VOLUME
 
 endif
 
+if ARCH_ROCKCHIP
+
+config ENV_OFFSET
+	hex "Environment offset"
+	depends on !ENV_IS_IN_UBI
+	depends on !ENV_IS_NOWHERE || ENVF
+	default 0x0 if ENVF
+	default 0x3f8000
+	help
+	  Offset from the start of the device (or partition)
+
+config ENV_SIZE
+	hex "Environment size"
+	default 0x8000
+	help
+	  Size of the environment storage area
+
+if ENVF
+config ENV_OFFSET_REDUND
+	hex "Environment redundant(backup) offset"
+	default ENV_OFFSET
+	help
+	  Redundant(backup) offset from the start of the device (or partition),
+	  this size must be ENV_SIZE.
+
+if CMD_NAND || MTD_SPI_NAND
+config ENV_NAND_OFFSET
+	hex "Environment offset in Nand"
+	default 0x0
+
+config ENV_NAND_OFFSET_REDUND
+	hex "Environment redundant(backup) offset in Nand"
+	default ENV_NAND_OFFSET
+
+config ENV_NAND_SIZE
+	hex "Environment size in Nand"
+	default 0x40000
+endif
+
+if SPI_FLASH
+config ENV_NOR_OFFSET
+	hex "Environment offset in Nor"
+	default 0x0
+
+config ENV_NOR_OFFSET_REDUND
+	hex "Environment redundant(backup) offset in Nor"
+	default ENV_NOR_OFFSET
+
+config ENV_NOR_SIZE
+	hex "Environment size in Nor"
+	default 0x10000
+endif
+
+endif
+endif
+
 endmenu
diff --git a/env/Makefile b/env/Makefile
index 8df5b9d4c9..630dae1d09 100644
--- a/env/Makefile
+++ b/env/Makefile
@@ -6,12 +6,12 @@
 #
 
 obj-y += common.o env.o
+obj-$(CONFIG_$(SPL_)ENVF) += envf.o
 
 ifndef CONFIG_SPL_BUILD
 obj-y += attr.o
 obj-y += callback.o
 obj-y += flags.o
-obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += dataflash.o
 obj-$(CONFIG_ENV_IS_IN_EEPROM) += eeprom.o
 extra-$(CONFIG_ENV_IS_EMBEDDED) += embedded.o
 obj-$(CONFIG_ENV_IS_IN_EEPROM) += embedded.o
@@ -28,8 +28,11 @@ obj-$(CONFIG_ENV_IS_IN_SATA) += sata.o
 obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += sf.o
 obj-$(CONFIG_ENV_IS_IN_REMOTE) += remote.o
 obj-$(CONFIG_ENV_IS_IN_UBI) += ubi.o
+obj-$(CONFIG_ENV_IS_IN_BLK_DEV) += env_blk.o
+ifndef CONFIG_ENVF
 obj-$(CONFIG_ENV_IS_NOWHERE) += nowhere.o
 endif
+endif
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_ENV_IS_IN_FLASH) += flash.o
@@ -44,7 +47,11 @@ obj-$(CONFIG_SPL_ENV_SUPPORT) += flags.o
 obj-$(CONFIG_SPL_ENV_SUPPORT) += callback.o
 endif
 ifneq ($(CONFIG_TPL_ENV_SUPPORT)$(CONFIG_SPL_ENV_SUPPORT),)
+ifdef CONFIG_ENVF
+obj-y += envf.o
+else
 obj-$(CONFIG_ENV_IS_NOWHERE) += nowhere.o
+endif
 obj-$(CONFIG_ENV_IS_IN_MMC) += mmc.o
 obj-$(CONFIG_ENV_IS_IN_FAT) += fat.o
 obj-$(CONFIG_ENV_IS_IN_EXT4) += ext4.o
diff --git a/env/common.c b/env/common.c
index b403bd5f6c..d477e4e664 100644
--- a/env/common.c
+++ b/env/common.c
@@ -41,6 +41,8 @@ int env_get_yesno(const char *var)
 		1 : 0;
 }
 
+__weak void board_env_fixup(void) {}
+
 /*
  * Look up the variable from the default environment
  */
@@ -84,10 +86,12 @@ void set_default_env(const char *s)
 	if (himport_r(&env_htab, (char *)default_environment,
 			sizeof(default_environment), '\0', flags, 0,
 			0, NULL) == 0)
-		error("Environment import failed: errno = %d\n", errno);
+		pr_err("Environment import failed: errno = %d\n", errno);
 
 	gd->flags |= GD_FLG_ENV_READY;
 	gd->flags |= GD_FLG_ENV_DEFAULT;
+
+	board_env_fixup();
 }
 
 
@@ -103,6 +107,22 @@ int set_default_vars(int nvars, char * const vars[])
 				H_NOCLEAR | H_INTERACTIVE, 0, nvars, vars);
 }
 
+int set_board_env(const char *vars, int size, int flags, bool ready)
+{
+	if (himport_r(&env_htab, (char *)vars, size, '\0',
+		      flags, 0, 0, NULL) == 0) {
+		pr_err("Environment import failed\n");
+		return -1;
+	}
+
+	if (ready) {
+		gd->flags |= GD_FLG_ENV_READY;
+		gd->flags |= GD_FLG_ENV_DEFAULT;
+	}
+
+	return 0;
+}
+
 #ifdef CONFIG_ENV_AES
 #include <uboot_aes.h>
 /**
@@ -172,7 +192,7 @@ int env_import(const char *buf, int check)
 	/* Decrypt the env if desired. */
 	ret = env_aes_cbc_crypt(ep, 0);
 	if (ret) {
-		error("Failed to decrypt env!\n");
+		pr_err("Failed to decrypt env!\n");
 		set_default_env("!import failed");
 		return ret;
 	}
@@ -183,7 +203,7 @@ int env_import(const char *buf, int check)
 		return 1;
 	}
 
-	error("Cannot import environment: errno = %d\n", errno);
+	pr_err("Cannot import environment: errno = %d\n", errno);
 
 	set_default_env("!import failed");
 
@@ -247,7 +267,7 @@ int env_export(env_t *env_out)
 	res = (char *)env_out->data;
 	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
 	if (len < 0) {
-		error("Cannot export environment: errno = %d\n", errno);
+		pr_err("Cannot export environment: errno = %d\n", errno);
 		return 1;
 	}
 
diff --git a/env/env.c b/env/env.c
index 43290d0832..73c00545df 100644
--- a/env/env.c
+++ b/env/env.c
@@ -28,9 +28,7 @@ static struct env_driver *env_driver_lookup(enum env_location loc)
 
 static enum env_location env_get_default_location(void)
 {
-	if IS_ENABLED(CONFIG_ENV_IS_IN_DATAFLASH)
-		return ENVL_DATAFLASH;
-	else if IS_ENABLED(CONFIG_ENV_IS_IN_EEPROM)
+	if IS_ENABLED(CONFIG_ENV_IS_IN_EEPROM)
 		return ENVL_EEPROM;
 	else if IS_ENABLED(CONFIG_ENV_IS_IN_FAT)
 		return ENVL_FAT;
@@ -48,6 +46,8 @@ static enum env_location env_get_default_location(void)
 		return ENVL_SPI_FLASH;
 	else if IS_ENABLED(CONFIG_ENV_IS_IN_UBI)
 		return ENVL_UBI;
+	else if IS_ENABLED(CONFIG_ENV_IS_IN_BLK_DEV)
+		return ENVL_BLK;
 	else if IS_ENABLED(CONFIG_ENV_IS_NOWHERE)
 		return ENVL_NOWHERE;
 	else
diff --git a/env/mmc.c b/env/mmc.c
index 3f3092d975..ed7bcf16ae 100644
--- a/env/mmc.c
+++ b/env/mmc.c
@@ -15,9 +15,13 @@
 #include <malloc.h>
 #include <memalign.h>
 #include <mmc.h>
+#include <part.h>
 #include <search.h>
 #include <errno.h>
 
+#define __STR(X) #X
+#define STR(X) __STR(X)
+
 #if defined(CONFIG_ENV_SIZE_REDUND) &&  \
 	(CONFIG_ENV_SIZE_REDUND != CONFIG_ENV_SIZE)
 #error CONFIG_ENV_SIZE_REDUND should be the same as CONFIG_ENV_SIZE
@@ -30,18 +34,68 @@ DECLARE_GLOBAL_DATA_PTR;
 #endif
 
 #if CONFIG_IS_ENABLED(OF_CONTROL)
+static inline int mmc_offset_try_partition(const char *str, s64 *val)
+{
+	disk_partition_t info;
+	struct blk_desc *desc;
+	int len, i, ret;
+
+	ret = blk_get_device_by_str("mmc", STR(CONFIG_SYS_MMC_ENV_DEV), &desc);
+	if (ret < 0)
+		return (ret);
+
+	for (i = 1;;i++) {
+		ret = part_get_info(desc, i, &info);
+		if (ret < 0)
+			return ret;
+
+		if (!strncmp((const char *)info.name, str, sizeof(str)))
+			break;
+	}
+
+	/* round up to info.blksz */
+	len = (CONFIG_ENV_SIZE + info.blksz - 1) & ~(info.blksz - 1);
+
+	/* use the top of the partion for the environment */
+	*val = (info.start + info.size - 1) - len / info.blksz;
+
+	return 0;
+}
+
 static inline s64 mmc_offset(int copy)
 {
-	const char *propname = "u-boot,mmc-env-offset";
-	s64 defvalue = CONFIG_ENV_OFFSET;
+	const struct {
+		const char *offset_redund;
+		const char *partition;
+		const char *offset;
+	} dt_prop = {
+		.offset_redund = "u-boot,mmc-env-offset-redundant",
+		.partition = "u-boot,mmc-env-partition",
+		.offset = "u-boot,mmc-env-offset",
+	};
+	s64 val = 0, defvalue;
+	const char *propname;
+	const char *str;
+	int err;
+
+	/* look for the partition in mmc CONFIG_SYS_MMC_ENV_DEV */
+	str = fdtdec_get_config_string(gd->fdt_blob, dt_prop.partition);
+	if (str) {
+		/* try to place the environment at end of the partition */
+		err = mmc_offset_try_partition(str, &val);
+		if (!err)
+			return val;
+	}
+
+	defvalue = CONFIG_ENV_OFFSET;
+	propname = dt_prop.offset;
 
 #if defined(CONFIG_ENV_OFFSET_REDUND)
 	if (copy) {
-		propname = "u-boot,mmc-env-offset-redundant";
 		defvalue = CONFIG_ENV_OFFSET_REDUND;
+		propname = dt_prop.offset_redund;
 	}
 #endif
-
 	return fdtdec_get_config_int(gd->fdt_blob, propname, defvalue);
 }
 #else
diff --git a/env/sf.c b/env/sf.c
index 6f74371c09..e51b1ae189 100644
--- a/env/sf.c
+++ b/env/sf.c
@@ -236,7 +236,7 @@ static int env_sf_load(void)
 
 	ret = env_import((char *)ep, 0);
 	if (!ret) {
-		error("Cannot import environment: errno = %d\n", errno);
+		pr_err("Cannot import environment: errno = %d\n", errno);
 		set_default_env("!env_import failed");
 	}
 
diff --git a/examples/Makefile b/examples/Makefile
index 8e329d7cd5..3b75f41fb9 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -8,6 +8,10 @@ ifdef FTRACE
 subdir-ccflags-y += -finstrument-functions -DFTRACE
 endif
 
+# Here is an compile issue: "undefined reference to `__aeabi_unwind_cpp_pr0'..."
+# when -funwind-tables is enabled, so make it compile depends on -funwind-tables.
+ifeq (,$(findstring -funwind-tables,$(PLATFORM_CPPFLAGS)))
 subdir-y += standalone
 subdir-$(CONFIG_API) += api
 endif
+endif
diff --git a/examples/api/Makefile b/examples/api/Makefile
index dab6398bab..1c8d55cb9e 100644
--- a/examples/api/Makefile
+++ b/examples/api/Makefile
@@ -31,9 +31,12 @@ OBJ-y += libgenwrap.o
 EXT_COBJ-y += lib/crc32.o
 EXT_COBJ-y += lib/ctype.o
 EXT_COBJ-y += lib/div64.o
+EXT_COBJ-y += lib/hexdump.o
 EXT_COBJ-y += lib/string.o
 EXT_COBJ-y += lib/time.o
 EXT_COBJ-y += lib/vsprintf.o
+EXT_COBJ-y += lib/charset.o
+EXT_COBJ-$(CONFIG_LIB_UUID) += lib/uuid.o
 EXT_SOBJ-$(CONFIG_PPC) += arch/powerpc/lib/ppcstring.o
 ifeq ($(ARCH),arm)
 EXT_SOBJ-$(CONFIG_USE_ARCH_MEMSET) += arch/arm/lib/memset.o
diff --git a/examples/api/glue.c b/examples/api/glue.c
index 8aabf32c89..575c1e55f3 100644
--- a/examples/api/glue.c
+++ b/examples/api/glue.c
@@ -416,3 +416,15 @@ void ub_display_clear(void)
 {
 	syscall(API_DISPLAY_CLEAR, NULL);
 }
+
+__weak void *memcpy(void *dest, const void *src, size_t size)
+{
+	unsigned char *dptr = dest;
+	const unsigned char *ptr = src;
+	const unsigned char *end = src + size;
+
+	while (ptr < end)
+		*dptr++ = *ptr++;
+
+	return dest;
+}
diff --git a/fs/Makefile b/fs/Makefile
index 5770f41c0b..b53c9d7cca 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -23,3 +23,4 @@ obj-$(CONFIG_CMD_UBIFS) += ubifs/
 obj-$(CONFIG_YAFFS2) += yaffs2/
 obj-$(CONFIG_CMD_ZFS) += zfs/
 endif
+obj-y += fs_internal.o
diff --git a/fs/ext4/Makefile b/fs/ext4/Makefile
index 8d15bdad67..f8f9bc29a8 100644
--- a/fs/ext4/Makefile
+++ b/fs/ext4/Makefile
@@ -11,3 +11,4 @@
 
 obj-y := ext4fs.o ext4_common.o dev.o
 obj-$(CONFIG_EXT4_WRITE) += ext4_write.o ext4_journal.o crc16.o
+obj-$(CONFIG_CMD_EXT4_SPARSE_WRITE) += ext4_sparse.o
diff --git a/fs/ext4/dev.c b/fs/ext4/dev.c
index ae2ba6a901..f04fa08f64 100644
--- a/fs/ext4/dev.c
+++ b/fs/ext4/dev.c
@@ -26,7 +26,7 @@
 #include <common.h>
 #include <blk.h>
 #include <config.h>
-#include <memalign.h>
+#include <fs_internal.h>
 #include <ext4fs.h>
 #include <ext_common.h>
 #include "ext4_common.h"
@@ -47,85 +47,11 @@ void ext4fs_set_blk_dev(struct blk_desc *rbdd, disk_partition_t *info)
 		get_fs()->dev_desc->log2blksz;
 }
 
-int ext4fs_devread(lbaint_t sector, int byte_offset, int byte_len, char *buf)
+int ext4fs_devread(lbaint_t sector, int byte_offset, int byte_len,
+		   char *buffer)
 {
-	unsigned block_len;
-	int log2blksz = ext4fs_blk_desc->log2blksz;
-	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, (ext4fs_blk_desc ?
-						 ext4fs_blk_desc->blksz :
-						 0));
-	if (ext4fs_blk_desc == NULL) {
-		printf("** Invalid Block Device Descriptor (NULL)\n");
-		return 0;
-	}
-
-	/* Check partition boundaries */
-	if ((sector + ((byte_offset + byte_len - 1) >> log2blksz))
-	    >= part_info->size) {
-		printf("%s read outside partition " LBAFU "\n", __func__,
-		       sector);
-		return 0;
-	}
-
-	/* Get the read to the beginning of a partition */
-	sector += byte_offset >> log2blksz;
-	byte_offset &= ext4fs_blk_desc->blksz - 1;
-
-	debug(" <" LBAFU ", %d, %d>\n", sector, byte_offset, byte_len);
-
-	if (byte_offset != 0) {
-		int readlen;
-		/* read first part which isn't aligned with start of sector */
-		if (blk_dread(ext4fs_blk_desc, part_info->start + sector, 1,
-			      (void *)sec_buf) != 1) {
-			printf(" ** ext2fs_devread() read error **\n");
-			return 0;
-		}
-		readlen = min((int)ext4fs_blk_desc->blksz - byte_offset,
-			      byte_len);
-		memcpy(buf, sec_buf + byte_offset, readlen);
-		buf += readlen;
-		byte_len -= readlen;
-		sector++;
-	}
-
-	if (byte_len == 0)
-		return 1;
-
-	/* read sector aligned part */
-	block_len = byte_len & ~(ext4fs_blk_desc->blksz - 1);
-
-	if (block_len == 0) {
-		ALLOC_CACHE_ALIGN_BUFFER(u8, p, ext4fs_blk_desc->blksz);
-
-		block_len = ext4fs_blk_desc->blksz;
-		blk_dread(ext4fs_blk_desc, part_info->start + sector, 1,
-			  (void *)p);
-		memcpy(buf, p, byte_len);
-		return 1;
-	}
-
-	if (blk_dread(ext4fs_blk_desc, part_info->start + sector,
-		      block_len >> log2blksz, (void *)buf) !=
-			block_len >> log2blksz) {
-		printf(" ** %s read error - block\n", __func__);
-		return 0;
-	}
-	block_len = byte_len & ~(ext4fs_blk_desc->blksz - 1);
-	buf += block_len;
-	byte_len -= block_len;
-	sector += block_len / ext4fs_blk_desc->blksz;
-
-	if (byte_len != 0) {
-		/* read rest of data which are not in whole sector */
-		if (blk_dread(ext4fs_blk_desc, part_info->start + sector, 1,
-			      (void *)sec_buf) != 1) {
-			printf("* %s read error - last part\n", __func__);
-			return 0;
-		}
-		memcpy(buf, sec_buf, byte_len);
-	}
-	return 1;
+	return fs_devread(get_fs()->dev_desc, part_info, sector, byte_offset,
+			  byte_len, buffer);
 }
 
 int ext4_read_superblock(char *buffer)
diff --git a/fs/ext4/ext4_common.c b/fs/ext4/ext4_common.c
index 621c61e5c7..ec3a73a748 100644
--- a/fs/ext4/ext4_common.c
+++ b/fs/ext4/ext4_common.c
@@ -15,14 +15,11 @@
  * Copyright (C) 2003, 2004  Free Software Foundation, Inc.
  *
  * ext4write : Based on generic ext4 protocol.
- *
- * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
 #include <ext_common.h>
 #include <ext4fs.h>
-#include <inttypes.h>
 #include <malloc.h>
 #include <memalign.h>
 #include <stddef.h>
@@ -192,7 +189,7 @@ uint32_t ext4fs_div_roundup(uint32_t size, uint32_t n)
 	return res;
 }
 
-void put_ext4(uint64_t off, void *buf, uint32_t size)
+void put_ext4(uint64_t off, const void *buf, uint32_t size)
 {
 	uint64_t startblock;
 	uint64_t remainder;
@@ -211,7 +208,7 @@ void put_ext4(uint64_t off, void *buf, uint32_t size)
 	if ((startblock + (size >> log2blksz)) >
 	    (part_offset + fs->total_sect)) {
 		printf("part_offset is " LBAFU "\n", part_offset);
-		printf("total_sector is %" PRIu64 "\n", fs->total_sect);
+		printf("total_sector is %llu\n", fs->total_sect);
 		printf("error: overflow occurs\n");
 		return;
 	}
@@ -432,6 +429,10 @@ uint16_t ext4fs_checksum_update(uint32_t i)
 		crc = ext2fs_crc16(crc, desc, offset);
 		offset += sizeof(desc->bg_checksum);	/* skip checksum */
 		assert(offset == sizeof(*desc));
+		if (offset < fs->gdsize) {
+			crc = ext2fs_crc16(crc, (__u8 *)desc + offset,
+					   fs->gdsize - offset);
+		}
 	}
 
 	return crc;
@@ -508,7 +509,8 @@ restart:
 
 restart_read:
 	/* read the block no allocated to a file */
-	first_block_no_of_root = read_allocated_block(g_parent_inode, blk_idx);
+	first_block_no_of_root = read_allocated_block(g_parent_inode, blk_idx,
+						      NULL);
 	if (first_block_no_of_root <= 0)
 		goto fail;
 
@@ -567,7 +569,7 @@ restart_read:
 				g_parent_inode->size = cpu_to_le32(new_size);
 
 				new_blockcnt = le32_to_cpu(g_parent_inode->blockcnt);
-				new_blockcnt += fs->sect_perblk;
+				new_blockcnt += fs->blksz >> LOG2_SECTOR_SIZE;
 				g_parent_inode->blockcnt = cpu_to_le32(new_blockcnt);
 
 				if (ext4fs_put_metadata
@@ -605,7 +607,7 @@ restart_read:
 		dir->direntlen = cpu_to_le16(fs->blksz - totalbytes);
 
 	dir->namelen = strlen(filename);
-	dir->filetype = FILETYPE_REG;	/* regular file */
+	dir->filetype = file_type;
 	temp_dir = (char *)dir;
 	temp_dir = temp_dir + sizeof(struct ext2_dirent);
 	memcpy(temp_dir, filename, strlen(filename));
@@ -644,7 +646,7 @@ static int search_dir(struct ext2_inode *parent_inode, char *dirname)
 
 	/* get the block no allocated to a file */
 	for (blk_idx = 0; blk_idx < directory_blocks; blk_idx++) {
-		blknr = read_allocated_block(parent_inode, blk_idx);
+		blknr = read_allocated_block(parent_inode, blk_idx, NULL);
 		if (blknr <= 0)
 			goto fail;
 
@@ -656,6 +658,11 @@ static int search_dir(struct ext2_inode *parent_inode, char *dirname)
 
 		offset = 0;
 		do {
+			if (offset & 3) {
+				printf("Badly aligned ext2_dirent\n");
+				break;
+			}
+
 			dir = (struct ext2_dirent *)(block_buffer + offset);
 			direntname = (char*)(dir) + sizeof(struct ext2_dirent);
 
@@ -876,6 +883,11 @@ static int unlink_filename(char *filename, unsigned int blknr)
 
 	offset = 0;
 	do {
+		if (offset & 3) {
+			printf("Badly aligned ext2_dirent\n");
+			break;
+		}
+
 		previous_dir = dir;
 		dir = (struct ext2_dirent *)(block_buffer + offset);
 		direntname = (char *)(dir) + sizeof(struct ext2_dirent);
@@ -931,7 +943,7 @@ int ext4fs_filename_unlink(char *filename)
 
 	/* read the block no allocated to a file */
 	for (blk_idx = 0; blk_idx < directory_blocks; blk_idx++) {
-		blknr = read_allocated_block(g_parent_inode, blk_idx);
+		blknr = read_allocated_block(g_parent_inode, blk_idx, NULL);
 		if (blknr <= 0)
 			break;
 		inodeno = unlink_filename(filename, blknr);
@@ -1510,7 +1522,7 @@ void ext4fs_allocate_blocks(struct ext2_inode *file_inode,
 #endif
 
 static struct ext4_extent_header *ext4fs_get_extent_block
-	(struct ext2_data *data, char *buf,
+	(struct ext2_data *data, struct ext_block_cache *cache,
 		struct ext4_extent_header *ext_block,
 		uint32_t fileblock, int log2_blksz)
 {
@@ -1534,17 +1546,19 @@ static struct ext4_extent_header *ext4fs_get_extent_block
 				break;
 		} while (fileblock >= le32_to_cpu(index[i].ei_block));
 
-		if (--i < 0)
-			return NULL;
+		/*
+		 * If first logical block number is higher than requested fileblock,
+		 * it is a sparse file. This is handled on upper layer.
+		 */
+		if (i > 0)
+			i--;
 
 		block = le16_to_cpu(index[i].ei_leaf_hi);
 		block = (block << 32) + le32_to_cpu(index[i].ei_leaf_lo);
-
-		if (ext4fs_devread((lbaint_t)block << log2_blksz, 0, blksz,
-				   buf))
-			ext_block = (struct ext4_extent_header *)buf;
-		else
+		block <<= log2_blksz;
+		if (!ext_cache_read(cache, (lbaint_t)block, blksz))
 			return NULL;
+		ext_block = (struct ext4_extent_header *)cache->buf;
 	}
 }
 
@@ -1556,8 +1570,12 @@ static int ext4fs_blockgroup
 	int log2blksz = get_fs()->dev_desc->log2blksz;
 	int desc_size = get_fs()->gdsize;
 
+	if (desc_size == 0)
+		return 0;
 	desc_per_blk = EXT2_BLOCK_SIZE(data) / desc_size;
 
+	if (desc_per_blk == 0)
+		return 0;
 	blkno = le32_to_cpu(data->sblock.first_data_block) + 1 +
 			group / desc_per_blk;
 	blkoff = (group % desc_per_blk) * desc_size;
@@ -1572,7 +1590,7 @@ static int ext4fs_blockgroup
 
 int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
 {
-	struct ext2_block_group blkgrp;
+	struct ext2_block_group *blkgrp;
 	struct ext2_sblock *sblock = &data->sblock;
 	struct ext_filesystem *fs = get_fs();
 	int log2blksz = get_fs()->dev_desc->log2blksz;
@@ -1580,17 +1598,36 @@ int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
 	long int blkno;
 	unsigned int blkoff;
 
+	/* Allocate blkgrp based on gdsize (for 64-bit support). */
+	blkgrp = zalloc(get_fs()->gdsize);
+	if (!blkgrp)
+		return 0;
+
 	/* It is easier to calculate if the first inode is 0. */
 	ino--;
+	if ( le32_to_cpu(sblock->inodes_per_group) == 0 || fs->inodesz == 0) {
+		free(blkgrp);
+		return 0;
+	}
 	status = ext4fs_blockgroup(data, ino / le32_to_cpu
-				   (sblock->inodes_per_group), &blkgrp);
-	if (status == 0)
+				   (sblock->inodes_per_group), blkgrp);
+	if (status == 0) {
+		free(blkgrp);
 		return 0;
+	}
 
 	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
-	blkno = ext4fs_bg_get_inode_table_id(&blkgrp, fs) +
+	if ( inodes_per_block == 0 ) {
+		free(blkgrp);
+		return 0;
+	}
+	blkno = ext4fs_bg_get_inode_table_id(blkgrp, fs) +
 	    (ino % le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
 	blkoff = (ino % inodes_per_block) * fs->inodesz;
+
+	/* Free blkgrp as it is no longer required. */
+	free(blkgrp);
+
 	/* Read the inode. */
 	status = ext4fs_devread((lbaint_t)blkno << (LOG2_BLOCK_SIZE(data) -
 				log2blksz), blkoff,
@@ -1601,7 +1638,8 @@ int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
 	return 1;
 }
 
-long int read_allocated_block(struct ext2_inode *inode, int fileblock)
+long int read_allocated_block(struct ext2_inode *inode, int fileblock,
+			      struct ext_block_cache *cache)
 {
 	long int blknr;
 	int blksz;
@@ -1618,20 +1656,26 @@ long int read_allocated_block(struct ext2_inode *inode, int fileblock)
 
 	if (le32_to_cpu(inode->flags) & EXT4_EXTENTS_FL) {
 		long int startblock, endblock;
-		char *buf = zalloc(blksz);
-		if (!buf)
-			return -ENOMEM;
+		struct ext_block_cache *c, cd;
 		struct ext4_extent_header *ext_block;
 		struct ext4_extent *extent;
 		int i;
+
+		if (cache) {
+			c = cache;
+		} else {
+			c = &cd;
+			ext_cache_init(c);
+		}
 		ext_block =
-			ext4fs_get_extent_block(ext4fs_root, buf,
+			ext4fs_get_extent_block(ext4fs_root, c,
 						(struct ext4_extent_header *)
 						inode->b.blocks.dir_blocks,
 						fileblock, log2_blksz);
 		if (!ext_block) {
 			printf("invalid extent block\n");
-			free(buf);
+			if (!cache)
+				ext_cache_fini(c);
 			return -EINVAL;
 		}
 
@@ -1643,19 +1687,22 @@ long int read_allocated_block(struct ext2_inode *inode, int fileblock)
 
 			if (startblock > fileblock) {
 				/* Sparse file */
-				free(buf);
+				if (!cache)
+					ext_cache_fini(c);
 				return 0;
 
 			} else if (fileblock < endblock) {
 				start = le16_to_cpu(extent[i].ee_start_hi);
 				start = (start << 32) +
 					le32_to_cpu(extent[i].ee_start_lo);
-				free(buf);
+				if (!cache)
+					ext_cache_fini(c);
 				return (fileblock - startblock) + start;
 			}
 		}
 
-		free(buf);
+		if (!cache)
+			ext_cache_fini(c);
 		return 0;
 	}
 
@@ -2329,7 +2376,7 @@ int ext4fs_mount(unsigned part_length)
 
 	/* Make sure this is an ext2 filesystem. */
 	if (le16_to_cpu(data->sblock.magic) != EXT2_MAGIC)
-		goto fail;
+		goto fail_noerr;
 
 
 	if (le32_to_cpu(data->sblock.revision_level) == 0) {
@@ -2365,6 +2412,7 @@ int ext4fs_mount(unsigned part_length)
 	return 1;
 fail:
 	printf("Failed to mount ext2 filesystem...\n");
+fail_noerr:
 	free(data);
 	ext4fs_root = NULL;
 
diff --git a/fs/ext4/ext4_common.h b/fs/ext4/ext4_common.h
index 04d56028a0..c423cb06e8 100644
--- a/fs/ext4/ext4_common.h
+++ b/fs/ext4/ext4_common.h
@@ -73,7 +73,7 @@ int ext4fs_iget(int inode_no, struct ext2_inode *inode);
 void ext4fs_allocate_blocks(struct ext2_inode *file_inode,
 				unsigned int total_remaining_blocks,
 				unsigned int *total_no_of_block);
-void put_ext4(uint64_t off, void *buf, uint32_t size);
+void put_ext4(uint64_t off, const void *buf, uint32_t size);
 struct ext2_block_group *ext4fs_get_group_descriptor
 	(const struct ext_filesystem *fs, uint32_t bg_idx);
 uint64_t ext4fs_bg_get_block_id(const struct ext2_block_group *bg,
diff --git a/fs/ext4/ext4_journal.c b/fs/ext4/ext4_journal.c
index fed6287eac..3559daf11d 100644
--- a/fs/ext4/ext4_journal.c
+++ b/fs/ext4/ext4_journal.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * (C) Copyright 2011 - 2012 Samsung Electronics
  * EXT4 filesystem implementation in Uboot by
@@ -10,7 +11,6 @@
  * Written by Stephen C. Tweedie <sct@redhat.com>
  *
  * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved
- * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <common.h>
@@ -347,7 +347,7 @@ void recover_transaction(int prev_desc_logical_no)
 	ext4fs_read_inode(ext4fs_root, EXT2_JOURNAL_INO,
 			  (struct ext2_inode *)&inode_journal);
 	blknr = read_allocated_block((struct ext2_inode *)
-				     &inode_journal, i);
+				     &inode_journal, i, NULL);
 	ext4fs_devread((lbaint_t)blknr * fs->sect_perblk, 0, fs->blksz,
 		       temp_buff);
 	p_jdb = (char *)temp_buff;
@@ -372,7 +372,7 @@ void recover_transaction(int prev_desc_logical_no)
 				be32_to_cpu(jdb->h_sequence)) == 0)
 				continue;
 		}
-		blknr = read_allocated_block(&inode_journal, i);
+		blknr = read_allocated_block(&inode_journal, i, NULL);
 		ext4fs_devread((lbaint_t)blknr * fs->sect_perblk, 0,
 			       fs->blksz, metadata_buff);
 		put_ext4((uint64_t)((uint64_t)be32_to_cpu(tag->block) * (uint64_t)fs->blksz),
@@ -419,7 +419,8 @@ int ext4fs_check_journal_state(int recovery_flag)
 	}
 
 	ext4fs_read_inode(ext4fs_root, EXT2_JOURNAL_INO, &inode_journal);
-	blknr = read_allocated_block(&inode_journal, EXT2_JOURNAL_SUPERBLOCK);
+	blknr = read_allocated_block(&inode_journal, EXT2_JOURNAL_SUPERBLOCK,
+				     NULL);
 	ext4fs_devread((lbaint_t)blknr * fs->sect_perblk, 0, fs->blksz,
 		       temp_buff);
 	jsb = (struct journal_superblock_t *) temp_buff;
@@ -443,7 +444,7 @@ int ext4fs_check_journal_state(int recovery_flag)
 
 	i = be32_to_cpu(jsb->s_first);
 	while (1) {
-		blknr = read_allocated_block(&inode_journal, i);
+		blknr = read_allocated_block(&inode_journal, i, NULL);
 		memset(temp_buff1, '\0', fs->blksz);
 		ext4fs_devread((lbaint_t)blknr * fs->sect_perblk,
 			       0, fs->blksz, temp_buff1);
@@ -537,7 +538,7 @@ end:
 		ext4_read_superblock((char *)fs->sb);
 
 		blknr = read_allocated_block(&inode_journal,
-					 EXT2_JOURNAL_SUPERBLOCK);
+					 EXT2_JOURNAL_SUPERBLOCK, NULL);
 		put_ext4((uint64_t) ((uint64_t)blknr * (uint64_t)fs->blksz),
 			 (struct journal_superblock_t *)temp_buff,
 			 (uint32_t) fs->blksz);
@@ -566,7 +567,7 @@ static void update_descriptor_block(long int blknr)
 
 	ext4fs_read_inode(ext4fs_root, EXT2_JOURNAL_INO, &inode_journal);
 	jsb_blknr = read_allocated_block(&inode_journal,
-					 EXT2_JOURNAL_SUPERBLOCK);
+					 EXT2_JOURNAL_SUPERBLOCK, NULL);
 	ext4fs_devread((lbaint_t)jsb_blknr * fs->sect_perblk, 0, fs->blksz,
 		       temp_buff);
 	jsb = (struct journal_superblock_t *) temp_buff;
@@ -618,7 +619,7 @@ static void update_commit_block(long int blknr)
 	ext4fs_read_inode(ext4fs_root, EXT2_JOURNAL_INO,
 			  &inode_journal);
 	jsb_blknr = read_allocated_block(&inode_journal,
-					 EXT2_JOURNAL_SUPERBLOCK);
+					 EXT2_JOURNAL_SUPERBLOCK, NULL);
 	ext4fs_devread((lbaint_t)jsb_blknr * fs->sect_perblk, 0, fs->blksz,
 		       temp_buff);
 	jsb = (struct journal_superblock_t *) temp_buff;
@@ -644,17 +645,22 @@ void ext4fs_update_journal(void)
 	struct ext_filesystem *fs = get_fs();
 	long int blknr;
 	int i;
+
+	if (!(fs->sb->feature_compatibility & EXT4_FEATURE_COMPAT_HAS_JOURNAL))
+		return;
+
 	ext4fs_read_inode(ext4fs_root, EXT2_JOURNAL_INO, &inode_journal);
-	blknr = read_allocated_block(&inode_journal, jrnl_blk_idx++);
+	blknr = read_allocated_block(&inode_journal, jrnl_blk_idx++, NULL);
 	update_descriptor_block(blknr);
 	for (i = 0; i < MAX_JOURNAL_ENTRIES; i++) {
 		if (journal_ptr[i]->blknr == -1)
 			break;
-		blknr = read_allocated_block(&inode_journal, jrnl_blk_idx++);
+		blknr = read_allocated_block(&inode_journal, jrnl_blk_idx++,
+					     NULL);
 		put_ext4((uint64_t) ((uint64_t)blknr * (uint64_t)fs->blksz),
 			 journal_ptr[i]->buf, fs->blksz);
 	}
-	blknr = read_allocated_block(&inode_journal, jrnl_blk_idx++);
+	blknr = read_allocated_block(&inode_journal, jrnl_blk_idx++, NULL);
 	update_commit_block(blknr);
 	printf("update journal finished\n");
 }
diff --git a/fs/ext4/ext4_journal.h b/fs/ext4/ext4_journal.h
index 3d05ad5315..43fb8e7664 100644
--- a/fs/ext4/ext4_journal.h
+++ b/fs/ext4/ext4_journal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * (C) Copyright 2011 - 2012 Samsung Electronics
  * EXT4 filesystem implementation in Uboot by
@@ -11,12 +12,13 @@
  * Written by Stephen C. Tweedie <sct@redhat.com>
  *
  * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved
- * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef __EXT4_JRNL__
 #define __EXT4_JRNL__
 
+#define EXT4_FEATURE_COMPAT_HAS_JOURNAL		0x0004
+
 #define EXT2_JOURNAL_INO		8	/* Journal inode */
 #define EXT2_JOURNAL_SUPERBLOCK	0	/* Journal  Superblock number */
 
diff --git a/fs/ext4/ext4_write.c b/fs/ext4/ext4_write.c
index d710a86d59..67aeba1339 100644
--- a/fs/ext4/ext4_write.c
+++ b/fs/ext4/ext4_write.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * (C) Copyright 2011 - 2012 Samsung Electronics
  * EXT4 filesystem implementation in Uboot by
@@ -17,12 +18,11 @@
  * Copyright (C) 2003, 2004  Free Software Foundation, Inc.
  *
  * ext4write : Based on generic ext4 protocol.
- *
- * SPDX-License-Identifier:	GPL-2.0+
  */
 
 
 #include <common.h>
+#include <malloc.h>
 #include <memalign.h>
 #include <linux/stat.h>
 #include <div64.h>
@@ -466,6 +466,15 @@ static int ext4fs_delete_file(int inodeno)
 	if (le32_to_cpu(inode.size) % fs->blksz)
 		no_blocks++;
 
+	/*
+	 * special case for symlinks whose target are small enough that
+	 *it fits in struct ext2_inode.b.symlink: no block had been allocated
+	 */
+	if ((le16_to_cpu(inode.mode) & S_IFLNK) &&
+	    le32_to_cpu(inode.size) <= sizeof(inode.b.symlink)) {
+		no_blocks = 0;
+	}
+
 	if (le32_to_cpu(inode.flags) & EXT4_EXTENTS_FL) {
 		/* FIXME delete extent index blocks, i.e. eh_depth >= 1 */
 		struct ext4_extent_header *eh =
@@ -480,7 +489,7 @@ static int ext4fs_delete_file(int inodeno)
 
 	/* release data blocks */
 	for (i = 0; i < no_blocks; i++) {
-		blknr = read_allocated_block(&inode, i);
+		blknr = read_allocated_block(&inode, i, NULL);
 		if (blknr == 0)
 			continue;
 		if (blknr < 0)
@@ -696,7 +705,7 @@ void ext4fs_deinit(void)
 		ext4fs_read_inode(ext4fs_root, EXT2_JOURNAL_INO,
 				  &inode_journal);
 		blknr = read_allocated_block(&inode_journal,
-					EXT2_JOURNAL_SUPERBLOCK);
+					EXT2_JOURNAL_SUPERBLOCK, NULL);
 		ext4fs_devread((lbaint_t)blknr * fs->sect_perblk, 0, fs->blksz,
 			       temp_buff);
 		jsb = (struct journal_superblock_t *)temp_buff;
@@ -753,7 +762,7 @@ void ext4fs_deinit(void)
  * contigous sectors as ext4fs_read_file
  */
 static int ext4fs_write_file(struct ext2_inode *file_inode,
-			     int pos, unsigned int len, char *buf)
+			     int pos, unsigned int len, const char *buf)
 {
 	int i;
 	int blockcnt;
@@ -765,7 +774,7 @@ static int ext4fs_write_file(struct ext2_inode *file_inode,
 	int delayed_start = 0;
 	int delayed_extent = 0;
 	int delayed_next = 0;
-	char *delayed_buf = NULL;
+	const char *delayed_buf = NULL;
 
 	/* Adjust len so it we can't read past the end of the file. */
 	if (len > filesize)
@@ -777,7 +786,7 @@ static int ext4fs_write_file(struct ext2_inode *file_inode,
 		long int blknr;
 		int blockend = fs->blksz;
 		int skipfirst = 0;
-		blknr = read_allocated_block(file_inode, i);
+		blknr = read_allocated_block(file_inode, i, NULL);
 		if (blknr <= 0)
 			return -1;
 
@@ -817,7 +826,6 @@ static int ext4fs_write_file(struct ext2_inode *file_inode,
 					 (uint32_t) delayed_extent);
 				previous_block_number = -1;
 			}
-			memset(buf, 0, fs->blksz - skipfirst);
 		}
 		buf += fs->blksz - skipfirst;
 	}
@@ -831,8 +839,8 @@ static int ext4fs_write_file(struct ext2_inode *file_inode,
 	return len;
 }
 
-int ext4fs_write(const char *fname, unsigned char *buffer,
-					unsigned long sizebytes)
+int ext4fs_write(const char *fname, const char *buffer,
+		 unsigned long sizebytes, int type)
 {
 	int ret = 0;
 	struct ext2_inode *file_inode = NULL;
@@ -855,8 +863,12 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 	struct ext2_block_group *bgd = NULL;
 	struct ext_filesystem *fs = get_fs();
 	ALLOC_CACHE_ALIGN_BUFFER(char, filename, 256);
+	bool store_link_in_inode = false;
 	memset(filename, 0x00, 256);
 
+	if (type != FILETYPE_REG && type != FILETYPE_SYMLINK)
+		return -1;
+
 	g_parent_inode = zalloc(fs->inodesz);
 	if (!g_parent_inode)
 		goto fail;
@@ -865,6 +877,12 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 		printf("error in File System init\n");
 		return -1;
 	}
+
+	if (le32_to_cpu(fs->sb->feature_ro_compat) & EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) {
+		printf("Unsupported feature metadata_csum found, not writing.\n");
+		return -1;
+	}
+
 	inodes_per_block = fs->blksz / fs->inodesz;
 	parent_inodeno = ext4fs_get_parent_inode_num(fname, filename, F_FILE);
 	if (parent_inodeno == -1)
@@ -888,8 +906,16 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 		if (ret)
 			goto fail;
 	}
-	/* calucalate how many blocks required */
-	bytes_reqd_for_file = sizebytes;
+
+	/* calculate how many blocks required */
+	if (type == FILETYPE_SYMLINK &&
+	    sizebytes <= sizeof(file_inode->b.symlink)) {
+		store_link_in_inode = true;
+		bytes_reqd_for_file = 0;
+	} else {
+		bytes_reqd_for_file = sizebytes;
+	}
+
 	blks_reqd_for_file = lldiv(bytes_reqd_for_file, fs->blksz);
 	if (do_div(bytes_reqd_for_file, fs->blksz) != 0) {
 		blks_reqd_for_file++;
@@ -902,7 +928,7 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 		goto fail;
 	}
 
-	inodeno = ext4fs_update_parent_dentry(filename, FILETYPE_REG);
+	inodeno = ext4fs_update_parent_dentry(filename, type);
 	if (inodeno == -1)
 		goto fail;
 	/* prepare file inode */
@@ -910,20 +936,29 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 	if (!inode_buffer)
 		goto fail;
 	file_inode = (struct ext2_inode *)inode_buffer;
-	file_inode->mode = cpu_to_le16(S_IFREG | S_IRWXU |
-	    S_IRGRP | S_IROTH | S_IXGRP | S_IXOTH);
+	file_inode->size = cpu_to_le32(sizebytes);
+	if (type == FILETYPE_SYMLINK) {
+		file_inode->mode = cpu_to_le16(S_IFLNK | S_IRWXU | S_IRWXG |
+					       S_IRWXO);
+		if (store_link_in_inode) {
+			strncpy(file_inode->b.symlink, buffer, sizebytes);
+			sizebytes = 0;
+		}
+	} else {
+		file_inode->mode = cpu_to_le16(S_IFREG | S_IRWXU | S_IRGRP |
+					       S_IROTH | S_IXGRP | S_IXOTH);
+	}
 	/* ToDo: Update correct time */
 	file_inode->mtime = cpu_to_le32(timestamp);
 	file_inode->atime = cpu_to_le32(timestamp);
 	file_inode->ctime = cpu_to_le32(timestamp);
 	file_inode->nlinks = cpu_to_le16(1);
-	file_inode->size = cpu_to_le32(sizebytes);
 
 	/* Allocate data blocks */
 	ext4fs_allocate_blocks(file_inode, blocks_remaining,
 			       &blks_reqd_for_file);
 	file_inode->blockcnt = cpu_to_le32((blks_reqd_for_file * fs->blksz) >>
-		fs->dev_desc->log2blksz);
+					   LOG2_SECTOR_SIZE);
 
 	temp_ptr = zalloc(fs->blksz);
 	if (!temp_ptr)
@@ -944,7 +979,7 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 	if (ext4fs_put_metadata(temp_ptr, itable_blkno))
 		goto fail;
 	/* copy the file content into data blocks */
-	if (ext4fs_write_file(file_inode, 0, sizebytes, (char *)buffer) == -1) {
+	if (ext4fs_write_file(file_inode, 0, sizebytes, buffer) == -1) {
 		printf("Error in copying content\n");
 		/* FIXME: Deallocate data blocks */
 		goto fail;
@@ -1009,7 +1044,7 @@ int ext4_write_file(const char *filename, void *buf, loff_t offset,
 		return -1;
 	}
 
-	ret = ext4fs_write(filename, buf, len);
+	ret = ext4fs_write(filename, buf, len, FILETYPE_REG);
 	if (ret) {
 		printf("** Error ext4fs_write() **\n");
 		goto fail;
@@ -1024,3 +1059,8 @@ fail:
 
 	return -1;
 }
+
+int ext4fs_create_link(const char *target, const char *fname)
+{
+	return ext4fs_write(fname, target, strlen(target), FILETYPE_SYMLINK);
+}
diff --git a/fs/ext4/ext4fs.c b/fs/ext4/ext4fs.c
index 081509dbb4..2734e5a0f4 100644
--- a/fs/ext4/ext4fs.c
+++ b/fs/ext4/ext4fs.c
@@ -26,6 +26,8 @@
 #include <ext4fs.h>
 #include "ext4_common.h"
 #include <div64.h>
+#include <memalign.h>
+#include <malloc.h>
 
 int ext4fs_symlinknest;
 struct ext_filesystem ext_fs;
@@ -62,12 +64,21 @@ int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
 	lbaint_t delayed_skipfirst = 0;
 	lbaint_t delayed_next = 0;
 	char *delayed_buf = NULL;
+	char *start_buf = buf;
 	short status;
+	struct ext_block_cache cache;
+
+	ext_cache_init(&cache);
 
 	/* Adjust len so it we can't read past the end of the file. */
 	if (len + pos > filesize)
 		len = (filesize - pos);
 
+	if (blocksize <= 0 || len <= 0) {
+		ext_cache_fini(&cache);
+		return -1;
+	}
+
 	blockcnt = lldiv(((len + pos) + blocksize - 1), blocksize);
 
 	for (i = lldiv(pos, blocksize); i < blockcnt; i++) {
@@ -75,9 +86,11 @@ int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
 		int blockoff = pos - (blocksize * i);
 		int blockend = blocksize;
 		int skipfirst = 0;
-		blknr = read_allocated_block(&(node->inode), i);
-		if (blknr < 0)
+		blknr = read_allocated_block(&node->inode, i, &cache);
+		if (blknr < 0) {
+			ext_cache_fini(&cache);
 			return -1;
+		}
 
 		blknr = blknr << log2_fs_blocksize;
 
@@ -107,8 +120,10 @@ int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
 							delayed_skipfirst,
 							delayed_extent,
 							delayed_buf);
-					if (status == 0)
+					if (status == 0) {
+						ext_cache_fini(&cache);
 						return -1;
+					}
 					previous_block_number = blknr;
 					delayed_start = blknr;
 					delayed_extent = blockend;
@@ -127,17 +142,26 @@ int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
 					(blockend >> log2blksz);
 			}
 		} else {
+			int n;
+			int n_left;
 			if (previous_block_number != -1) {
 				/* spill */
 				status = ext4fs_devread(delayed_start,
 							delayed_skipfirst,
 							delayed_extent,
 							delayed_buf);
-				if (status == 0)
+				if (status == 0) {
+					ext_cache_fini(&cache);
 					return -1;
+				}
 				previous_block_number = -1;
 			}
-			memset(buf, 0, blocksize - skipfirst);
+			/* Zero no more than `len' bytes. */
+			n = blocksize - skipfirst;
+			n_left = len - ( buf - start_buf );
+			if (n > n_left)
+				n = n_left;
+			memset(buf, 0, n);
 		}
 		buf += blocksize - skipfirst;
 	}
@@ -146,18 +170,167 @@ int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
 		status = ext4fs_devread(delayed_start,
 					delayed_skipfirst, delayed_extent,
 					delayed_buf);
-		if (status == 0)
+		if (status == 0) {
+			ext_cache_fini(&cache);
 			return -1;
+		}
 		previous_block_number = -1;
 	}
 
 	*actread  = len;
+	ext_cache_fini(&cache);
 	return 0;
 }
 
+#define MAX_SIZE_PER  (1024*1024*10)
+static int ext4fs_dd_file_to(struct ext2fs_node *node, void *dst_desc, 
+		void (*callback)(void *, void *, loff_t))
+{
+	struct ext_filesystem *fs = get_fs();
+	int i;
+	lbaint_t blockcnt;
+	int log2blksz = fs->dev_desc->log2blksz;
+	int log2_fs_blocksize = LOG2_BLOCK_SIZE(node->data) - log2blksz;
+	int blocksize = (1 << (log2_fs_blocksize + log2blksz));
+	unsigned int filesize = le32_to_cpu(node->inode.size);
+	lbaint_t previous_block_number = -1;
+	lbaint_t delayed_start = 0;
+	lbaint_t delayed_extent = 0;
+	lbaint_t delayed_skipfirst = 0;
+	lbaint_t delayed_next = 0;
+	char *delayed_buf = NULL;
+	short status;
+	struct ext_block_cache cache;
+
+	ext_cache_init(&cache);
+	loff_t len;
+	ALLOC_CACHE_ALIGN_BUFFER(char, buf, MAX_SIZE_PER);
+	//ALLOC_CACHE_ALIGN_BUFFER(char, buf, blocksize);
+
+	len = filesize;
+
+	printf("blocksize %d\n", blocksize);
+	if (blocksize <= 0 || len <= 0) {
+		ext_cache_fini(&cache);
+		return -1;
+	}
+
+	blockcnt = lldiv((filesize + blocksize - 1), blocksize);
+
+	for (i = 0; i < blockcnt; i++) {
+		long int blknr;
+		int blockend = blocksize;
+		int skipfirst = 0;
+		blknr = read_allocated_block(&node->inode, i, &cache);
+		if (blknr < 0) {
+			ext_cache_fini(&cache);
+			return -1;
+		}
+
+		blknr = blknr << log2_fs_blocksize;
+
+		/* Last block.  */
+		if (i == blockcnt - 1) {
+			blockend = filesize - (blocksize * i);
+
+			/* The last portion is exactly blocksize. */
+			if (!blockend)
+				blockend = blocksize;
+		}
+
+		if (blknr) {
+			int status;
+
+			if (previous_block_number == -1) {
+				previous_block_number = blknr;
+				delayed_start = blknr;
+				delayed_extent = blockend;
+				delayed_skipfirst = skipfirst;
+				delayed_buf = buf;
+				delayed_next = blknr +
+					(blockend >> log2blksz);
+			} else {
+				if ((delayed_next == blknr) && ( delayed_extent < MAX_SIZE_PER)) {
+					delayed_extent += blockend;
+					delayed_next += blockend >> log2blksz;
+				} else {	/* spill */
+					//printf(" aaaa delayed_start %lu  delayed_extent %lu \n", delayed_start, delayed_extent);
+					status = ext4fs_devread(delayed_start,
+							delayed_skipfirst,
+							delayed_extent,
+							delayed_buf);
+					if (status == 0) {
+						ext_cache_fini(&cache);
+						return -1;
+					}
+					
+					if (callback) {
+						callback(dst_desc, (void *)delayed_buf, delayed_extent);
+					}
+					previous_block_number = blknr;
+					delayed_start = blknr;
+					delayed_extent = blockend;
+					delayed_skipfirst = skipfirst;
+					delayed_buf = buf;
+					delayed_next = blknr +
+						(blockend >> log2blksz);
+				}
+			}
+		} else {
+			//int n;
+			//int n_left;
+			if (previous_block_number != -1) {
+				/* spill */
+				//printf(" bbbb delayed_start %lu  delayed_extent %lu \n", delayed_start, delayed_extent);
+				status = ext4fs_devread(delayed_start,
+							delayed_skipfirst,
+							delayed_extent,
+							delayed_buf);
+				if (status == 0) {
+					ext_cache_fini(&cache);
+					return -1;
+				}
+				previous_block_number = -1;
+				if (callback) {
+					callback(dst_desc, (void *)delayed_buf, delayed_extent);
+				}
+			}
+			/* Zero no more than `len' bytes. */
+			/*
+			n = blocksize - skipfirst;
+			n_left = len - ( buf - start_buf );
+			if (n > n_left)
+				n = n_left;
+			memset(buf, 0, n);
+			*/
+		}
+		//buf += blocksize;
+	}
+
+
+	if (previous_block_number != -1) {
+		/* spill */
+		printf(" ccccc delayed_start %lu  delayed_extent %lu \n", delayed_start, delayed_extent);
+		status = ext4fs_devread(delayed_start,
+					delayed_skipfirst, delayed_extent,
+					delayed_buf);
+		if (status == 0) {
+			ext_cache_fini(&cache);
+			return -1;
+		}
+		previous_block_number = -1;
+		if (callback) {
+			callback(dst_desc, (void *)delayed_buf, delayed_extent);
+		}
+	}
+	ext_cache_fini(&cache);
+	return 0;
+}
+
+
 int ext4fs_ls(const char *dirname)
 {
-	struct ext2fs_node *dirnode;
+	struct ext2fs_node *dirnode = NULL;
 	int status;
 
 	if (dirname == NULL)
@@ -167,6 +340,8 @@ int ext4fs_ls(const char *dirname)
 				  FILETYPE_DIRECTORY);
 	if (status != 1) {
 		printf("** Can not find directory. **\n");
+		if (dirnode)
+			ext4fs_free_node(dirnode, &ext4fs_root->diropen);
 		return 1;
 	}
 
@@ -211,6 +386,23 @@ int ext4fs_probe(struct blk_desc *fs_dev_desc,
 	return 0;
 }
 
+int ext4_dd_file(const char *filename, void *dst_desc, void (*callback)(void *, void *, loff_t))
+{
+	loff_t file_len;
+	int ret;
+
+	ret = ext4fs_open(filename, &file_len);
+	if (ret < 0) {
+		printf("** File not found %s **\n", filename);
+		return -1;
+	}
+
+	if (ext4fs_root == NULL || ext4fs_file == NULL)
+		return -1;
+
+	return ext4fs_dd_file_to(ext4fs_file, dst_desc, callback);
+}
+
 int ext4_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 		   loff_t *len_read)
 {
@@ -226,6 +418,7 @@ int ext4_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 	if (len == 0)
 		len = file_len;
 
+	printf("=================begin===================\n");
 	return ext4fs_read(buf, offset, len, len_read);
 }
 
@@ -243,3 +436,32 @@ int ext4fs_uuid(char *uuid_str)
 	return -ENOSYS;
 #endif
 }
+
+void ext_cache_init(struct ext_block_cache *cache)
+{
+	memset(cache, 0, sizeof(*cache));
+}
+
+void ext_cache_fini(struct ext_block_cache *cache)
+{
+	free(cache->buf);
+	ext_cache_init(cache);
+}
+
+int ext_cache_read(struct ext_block_cache *cache, lbaint_t block, int size)
+{
+	/* This could be more lenient, but this is simple and enough for now */
+	if (cache->buf && cache->block == block && cache->size == size)
+		return 1;
+	ext_cache_fini(cache);
+	cache->buf = memalign(ARCH_DMA_MINALIGN, size);
+	if (!cache->buf)
+		return 0;
+	if (!ext4fs_devread(block, 0, size, cache->buf)) {
+		ext_cache_fini(cache);
+		return 0;
+	}
+	cache->block = block;
+	cache->size = size;
+	return 1;
+}
diff --git a/fs/fat/Makefile b/fs/fat/Makefile
index b60e8486c4..3e2a6b01a8 100644
--- a/fs/fat/Makefile
+++ b/fs/fat/Makefile
@@ -5,7 +5,3 @@
 
 obj-$(CONFIG_FS_FAT)	:= fat.o
 obj-$(CONFIG_FAT_WRITE):= fat_write.o
-
-ifndef CONFIG_SPL_BUILD
-obj-$(CONFIG_FS_FAT)	+= file.o
-endif
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
index 465a6875ed..3b5650adb6 100644
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -14,6 +14,7 @@
 #include <config.h>
 #include <exports.h>
 #include <fat.h>
+#include <fs.h>
 #include <asm/byteorder.h>
 #include <part.h>
 #include <malloc.h>
@@ -28,11 +29,13 @@ static const int vfat_enabled = 0;
 #endif
 
 /*
- * Convert a string to lowercase.
+ * Convert a string to lowercase.  Converts at most 'len' characters,
+ * 'len' may be larger than the length of 'str' if 'str' is NULL
+ * terminated.
  */
-static void downcase(char *str)
+static void downcase(char *str, size_t len)
 {
-	while (*str != '\0') {
+	while (*str != '\0' && len--) {
 		*str = tolower(*str);
 		str++;
 	}
@@ -118,22 +121,6 @@ int fat_register_device(struct blk_desc *dev_desc, int part_no)
 	return fat_set_blk_dev(dev_desc, &info);
 }
 
-/*
- * Get the first occurence of a directory delimiter ('/' or '\') in a string.
- * Return index into string if found, -1 otherwise.
- */
-static int dirdelim(char *str)
-{
-	char *start = str;
-
-	while (*str != '\0') {
-		if (ISDIRDELIM(*str))
-			return str - start;
-		str++;
-	}
-	return -1;
-}
-
 /*
  * Extract zero terminated short name from a directory entry.
  */
@@ -146,10 +133,13 @@ static void get_name(dir_entry *dirent, char *s_name)
 	ptr = s_name;
 	while (*ptr && *ptr != ' ')
 		ptr++;
+	if (dirent->lcase & CASE_LOWER_BASE)
+		downcase(s_name, (unsigned)(ptr - s_name));
 	if (dirent->ext[0] && dirent->ext[0] != ' ') {
-		*ptr = '.';
-		ptr++;
+		*ptr++ = '.';
 		memcpy(ptr, dirent->ext, 3);
+		if (dirent->lcase & CASE_LOWER_EXT)
+			downcase(ptr, 3);
 		ptr[3] = '\0';
 		while (*ptr && *ptr != ' ')
 			ptr++;
@@ -159,7 +149,6 @@ static void get_name(dir_entry *dirent, char *s_name)
 		*s_name = '\0';
 	else if (*s_name == aRING)
 		*s_name = DELETED_FLAG;
-	downcase(s_name);
 }
 
 static int flush_dirty_fat_buffer(fsdata *mydata);
@@ -268,8 +257,7 @@ get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
 	int ret;
 
 	if (clustnum > 0) {
-		startsect = mydata->data_begin +
-				clustnum * mydata->clust_size;
+		startsect = clust_to_sect(mydata, clustnum);
 	} else {
 		startsect = mydata->rootdir_sect;
 	}
@@ -468,95 +456,6 @@ static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
 	return 0;
 }
 
-/*
- * Extract the full long filename starting at 'retdent' (which is really
- * a slot) into 'l_name'. If successful also copy the real directory entry
- * into 'retdent'
- * Return 0 on success, -1 otherwise.
- */
-static int
-get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
-	     dir_entry *retdent, char *l_name)
-{
-	dir_entry *realdent;
-	dir_slot *slotptr = (dir_slot *)retdent;
-	__u8 *buflimit = cluster + mydata->sect_size * ((curclust == 0) ?
-							PREFETCH_BLOCKS :
-							mydata->clust_size);
-	__u8 counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
-	int idx = 0;
-
-	if (counter > VFAT_MAXSEQ) {
-		debug("Error: VFAT name is too long\n");
-		return -1;
-	}
-
-	while ((__u8 *)slotptr < buflimit) {
-		if (counter == 0)
-			break;
-		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
-			return -1;
-		slotptr++;
-		counter--;
-	}
-
-	if ((__u8 *)slotptr >= buflimit) {
-		dir_slot *slotptr2;
-
-		if (curclust == 0)
-			return -1;
-		curclust = get_fatent(mydata, curclust);
-		if (CHECK_CLUST(curclust, mydata->fatsize)) {
-			debug("curclust: 0x%x\n", curclust);
-			printf("Invalid FAT entry\n");
-			return -1;
-		}
-
-		if (get_cluster(mydata, curclust, get_contents_vfatname_block,
-				mydata->clust_size * mydata->sect_size) != 0) {
-			debug("Error: reading directory block\n");
-			return -1;
-		}
-
-		slotptr2 = (dir_slot *)get_contents_vfatname_block;
-		while (counter > 0) {
-			if (((slotptr2->id & ~LAST_LONG_ENTRY_MASK)
-			    & 0xff) != counter)
-				return -1;
-			slotptr2++;
-			counter--;
-		}
-
-		/* Save the real directory entry */
-		realdent = (dir_entry *)slotptr2;
-		while ((__u8 *)slotptr2 > get_contents_vfatname_block) {
-			slotptr2--;
-			slot2str(slotptr2, l_name, &idx);
-		}
-	} else {
-		/* Save the real directory entry */
-		realdent = (dir_entry *)slotptr;
-	}
-
-	do {
-		slotptr--;
-		if (slot2str(slotptr, l_name, &idx))
-			break;
-	} while (!(slotptr->id & LAST_LONG_ENTRY_MASK));
-
-	l_name[idx] = '\0';
-	if (*l_name == DELETED_FLAG)
-		*l_name = '\0';
-	else if (*l_name == aRING)
-		*l_name = DELETED_FLAG;
-	downcase(l_name);
-
-	/* Return the real directory entry */
-	memcpy(retdent, realdent, sizeof(dir_entry));
-
-	return 0;
-}
-
 /* Calculate short name checksum */
 static __u8 mkcksum(const char name[8], const char ext[3])
 {
@@ -573,169 +472,13 @@ static __u8 mkcksum(const char name[8], const char ext[3])
 }
 
 /*
- * Get the directory entry associated with 'filename' from the directory
- * starting at 'startsect'
+ * TODO these should go away once fat_write is reworked to use the
+ * directory iterator
  */
 __u8 get_dentfromdir_block[MAX_CLUSTSIZE]
 	__aligned(ARCH_DMA_MINALIGN);
-
-static dir_entry *get_dentfromdir(fsdata *mydata, int startsect,
-				  char *filename, dir_entry *retdent,
-				  int dols)
-{
-	__u16 prevcksum = 0xffff;
-	__u32 curclust = START(retdent);
-	int files = 0, dirs = 0;
-
-	debug("get_dentfromdir: %s\n", filename);
-
-	while (1) {
-		dir_entry *dentptr;
-
-		int i;
-
-		if (get_cluster(mydata, curclust, get_dentfromdir_block,
-				mydata->clust_size * mydata->sect_size) != 0) {
-			debug("Error: reading directory block\n");
-			return NULL;
-		}
-
-		dentptr = (dir_entry *)get_dentfromdir_block;
-
-		for (i = 0; i < DIRENTSPERCLUST; i++) {
-			char s_name[14], l_name[VFAT_MAXLEN_BYTES];
-
-			l_name[0] = '\0';
-			if (dentptr->name[0] == DELETED_FLAG) {
-				dentptr++;
-				continue;
-			}
-			if ((dentptr->attr & ATTR_VOLUME)) {
-				if (vfat_enabled &&
-				    (dentptr->attr & ATTR_VFAT) == ATTR_VFAT &&
-				    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
-					prevcksum = ((dir_slot *)dentptr)->alias_checksum;
-					get_vfatname(mydata, curclust,
-						     get_dentfromdir_block,
-						     dentptr, l_name);
-					if (dols) {
-						int isdir;
-						char dirc;
-						int doit = 0;
-
-						isdir = (dentptr->attr & ATTR_DIR);
-
-						if (isdir) {
-							dirs++;
-							dirc = '/';
-							doit = 1;
-						} else {
-							dirc = ' ';
-							if (l_name[0] != 0) {
-								files++;
-								doit = 1;
-							}
-						}
-						if (doit) {
-							if (dirc == ' ') {
-								printf(" %8u   %s%c\n",
-								       FAT2CPU32(dentptr->size),
-									l_name,
-									dirc);
-							} else {
-								printf("            %s%c\n",
-									l_name,
-									dirc);
-							}
-						}
-						dentptr++;
-						continue;
-					}
-					debug("vfatname: |%s|\n", l_name);
-				} else {
-					/* Volume label or VFAT entry */
-					dentptr++;
-					continue;
-				}
-			}
-			if (dentptr->name[0] == 0) {
-				if (dols) {
-					printf("\n%d file(s), %d dir(s)\n\n",
-						files, dirs);
-				}
-				debug("Dentname == NULL - %d\n", i);
-				return NULL;
-			}
-			if (vfat_enabled) {
-				__u8 csum = mkcksum(dentptr->name, dentptr->ext);
-				if (dols && csum == prevcksum) {
-					prevcksum = 0xffff;
-					dentptr++;
-					continue;
-				}
-			}
-
-			get_name(dentptr, s_name);
-			if (dols) {
-				int isdir = (dentptr->attr & ATTR_DIR);
-				char dirc;
-				int doit = 0;
-
-				if (isdir) {
-					dirs++;
-					dirc = '/';
-					doit = 1;
-				} else {
-					dirc = ' ';
-					if (s_name[0] != 0) {
-						files++;
-						doit = 1;
-					}
-				}
-
-				if (doit) {
-					if (dirc == ' ') {
-						printf(" %8u   %s%c\n",
-						       FAT2CPU32(dentptr->size),
-							s_name, dirc);
-					} else {
-						printf("            %s%c\n",
-							s_name, dirc);
-					}
-				}
-
-				dentptr++;
-				continue;
-			}
-
-			if (strcmp(filename, s_name)
-			    && strcmp(filename, l_name)) {
-				debug("Mismatch: |%s|%s|\n", s_name, l_name);
-				dentptr++;
-				continue;
-			}
-
-			memcpy(retdent, dentptr, sizeof(dir_entry));
-
-			debug("DentName: %s", s_name);
-			debug(", start: 0x%x", START(dentptr));
-			debug(", size:  0x%x %s\n",
-			      FAT2CPU32(dentptr->size),
-			      (dentptr->attr & ATTR_DIR) ? "(DIR)" : "");
-
-			return retdent;
-		}
-
-		curclust = get_fatent(mydata, curclust);
-		if (CHECK_CLUST(curclust, mydata->fatsize)) {
-			debug("curclust: 0x%x\n", curclust);
-			printf("Invalid FAT entry\n");
-			return NULL;
-		}
-	}
-
-	return NULL;
-}
+__u8 do_fat_read_at_block[MAX_CLUSTSIZE]
+	__aligned(ARCH_DMA_MINALIGN);
 
 /*
  * Read boot sector and volume info from a FAT filesystem
@@ -752,7 +495,7 @@ read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
 		return -1;
 	}
 
-	block = memalign(ARCH_DMA_MINALIGN, cur_dev->blksz);
+	block = malloc_cache_aligned(cur_dev->blksz);
 	if (block == NULL) {
 		debug("Error: allocating block\n");
 		return -1;
@@ -808,39 +551,19 @@ exit:
 	return ret;
 }
 
-__u8 do_fat_read_at_block[MAX_CLUSTSIZE]
-	__aligned(ARCH_DMA_MINALIGN);
-
-int do_fat_read_at(const char *filename, loff_t pos, void *buffer,
-		   loff_t maxsize, int dols, int dogetsize, loff_t *size)
+static int get_fs_info(fsdata *mydata)
 {
-	char fnamecopy[2048];
 	boot_sector bs;
 	volume_info volinfo;
-	fsdata datablock;
-	fsdata *mydata = &datablock;
-	dir_entry *dentptr = NULL;
-	__u16 prevcksum = 0xffff;
-	char *subname = "";
-	__u32 cursect;
-	int idx, isdir = 0;
-	int files = 0, dirs = 0;
-	int ret = -1;
-	int firsttime;
-	__u32 root_cluster = 0;
-	__u32 read_blk;
-	int rootdir_size = 0;
-	int buffer_blk_cnt;
-	int do_read;
-	__u8 *dir_ptr;
-
-	if (read_bootsectandvi(&bs, &volinfo, &mydata->fatsize)) {
+	int ret;
+
+	ret = read_bootsectandvi(&bs, &volinfo, &mydata->fatsize);
+	if (ret) {
 		debug("Error: reading boot sector\n");
-		return -1;
+		return ret;
 	}
 
 	if (mydata->fatsize == 32) {
-		root_cluster = bs.root_cluster;
 		mydata->fatlength = bs.fat32_length;
 	} else {
 		mydata->fatlength = bs.fat_length;
@@ -848,8 +571,7 @@ int do_fat_read_at(const char *filename, loff_t pos, void *buffer,
 
 	mydata->fat_sect = bs.reserved;
 
-	cursect = mydata->rootdir_sect
-		= mydata->fat_sect + mydata->fatlength * bs.fats;
+	mydata->rootdir_sect = mydata->fat_sect + mydata->fatlength * bs.fats;
 
 	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
 	mydata->clust_size = bs.cluster_size;
@@ -862,19 +584,22 @@ int do_fat_read_at(const char *filename, loff_t pos, void *buffer,
 	if (mydata->fatsize == 32) {
 		mydata->data_begin = mydata->rootdir_sect -
 					(mydata->clust_size * 2);
+		mydata->root_cluster = bs.root_cluster;
 	} else {
-		rootdir_size = ((bs.dir_entries[1]  * (int)256 +
-				 bs.dir_entries[0]) *
-				 sizeof(dir_entry)) /
-				 mydata->sect_size;
+		mydata->rootdir_size = ((bs.dir_entries[1]  * (int)256 +
+					 bs.dir_entries[0]) *
+					 sizeof(dir_entry)) /
+					 mydata->sect_size;
 		mydata->data_begin = mydata->rootdir_sect +
-					rootdir_size -
+					mydata->rootdir_size -
 					(mydata->clust_size * 2);
+		mydata->root_cluster =
+			sect_to_clust(mydata, mydata->rootdir_sect);
 	}
 
 	mydata->fatbufnum = -1;
 	mydata->fat_dirty = 0;
-	mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
+	mydata->fatbuf = malloc_cache_aligned(FATBUFSIZE);
 	if (mydata->fatbuf == NULL) {
 		debug("Error: allocating memory\n");
 		return -1;
@@ -887,355 +612,361 @@ int do_fat_read_at(const char *filename, loff_t pos, void *buffer,
 	       mydata->fatsize, mydata->fat_sect, mydata->fatlength);
 	debug("Rootdir begins at cluster: %d, sector: %d, offset: %x\n"
 	       "Data begins at: %d\n",
-	       root_cluster,
+	       mydata->root_cluster,
 	       mydata->rootdir_sect,
 	       mydata->rootdir_sect * mydata->sect_size, mydata->data_begin);
 	debug("Sector size: %d, cluster size: %d\n", mydata->sect_size,
 	      mydata->clust_size);
 
-	/* "cwd" is always the root... */
-	while (ISDIRDELIM(*filename))
-		filename++;
+	return 0;
+}
 
-	/* Make a copy of the filename and convert it to lowercase */
-	strcpy(fnamecopy, filename);
-	downcase(fnamecopy);
 
-root_reparse:
-	if (*fnamecopy == '\0') {
-		if (!dols)
-			goto exit;
+/*
+ * Directory iterator, to simplify filesystem traversal
+ *
+ * Implements an iterator pattern to traverse directory tables,
+ * transparently handling directory tables split across multiple
+ * clusters, and the difference between FAT12/FAT16 root directory
+ * (contiguous) and subdirectories + FAT32 root (chained).
+ *
+ * Rough usage:
+ *
+ *   for (fat_itr_root(&itr, fsdata); fat_itr_next(&itr); ) {
+ *      // to traverse down to a subdirectory pointed to by
+ *      // current iterator position:
+ *      fat_itr_child(&itr, &itr);
+ *   }
+ *
+ * For more complete example, see fat_itr_resolve()
+ */
 
-		dols = LS_ROOT;
-	} else if ((idx = dirdelim(fnamecopy)) >= 0) {
-		isdir = 1;
-		fnamecopy[idx] = '\0';
-		subname = fnamecopy + idx + 1;
-
-		/* Handle multiple delimiters */
-		while (ISDIRDELIM(*subname))
-			subname++;
-	} else if (dols) {
-		isdir = 1;
-	}
+typedef struct {
+	fsdata    *fsdata;        /* filesystem parameters */
+	unsigned   clust;         /* current cluster */
+	int        last_cluster;  /* set once we've read last cluster */
+	int        is_root;       /* is iterator at root directory */
+	int        remaining;     /* remaining dent's in current cluster */
 
-	buffer_blk_cnt = 0;
-	firsttime = 1;
-	while (1) {
-		int i;
+	/* current iterator position values: */
+	dir_entry *dent;          /* current directory entry */
+	char       l_name[VFAT_MAXLEN_BYTES];    /* long (vfat) name */
+	char       s_name[14];    /* short 8.3 name */
+	char      *name;          /* l_name if there is one, else s_name */
 
-		if (mydata->fatsize == 32 || firsttime) {
-			dir_ptr = do_fat_read_at_block;
-			firsttime = 0;
-		} else {
-			/**
-			 * FAT16 sector buffer modification:
-			 * Each loop, the second buffered block is moved to
-			 * the buffer begin, and two next sectors are read
-			 * next to the previously moved one. So the sector
-			 * buffer keeps always 3 sectors for fat16.
-			 * And the current sector is the buffer second sector
-			 * beside the "firsttime" read, when it is the first one.
-			 *
-			 * PREFETCH_BLOCKS is 2 for FAT16 == loop[0:1]
-			 * n = computed root dir sector
-			 * loop |  cursect-1  | cursect    | cursect+1  |
-			 *   0  |  sector n+0 | sector n+1 | none       |
-			 *   1  |  none       | sector n+0 | sector n+1 |
-			 *   0  |  sector n+1 | sector n+2 | sector n+3 |
-			 *   1  |  sector n+3 | ...
-			*/
-			dir_ptr = (do_fat_read_at_block + mydata->sect_size);
-			memcpy(do_fat_read_at_block, dir_ptr, mydata->sect_size);
-		}
+	/* storage for current cluster in memory: */
+	u8         block[MAX_CLUSTSIZE] __aligned(ARCH_DMA_MINALIGN);
+} fat_itr;
 
-		do_read = 1;
+static int fat_itr_isdir(fat_itr *itr);
 
-		if (mydata->fatsize == 32 && buffer_blk_cnt)
-			do_read = 0;
+/**
+ * fat_itr_root() - initialize an iterator to start at the root
+ * directory
+ *
+ * @itr: iterator to initialize
+ * @fsdata: filesystem data for the partition
+ * @return 0 on success, else -errno
+ */
+static int fat_itr_root(fat_itr *itr, fsdata *fsdata)
+{
+	if (get_fs_info(fsdata))
+		return -ENXIO;
 
-		if (do_read) {
-			read_blk = (mydata->fatsize == 32) ?
-				    mydata->clust_size : PREFETCH_BLOCKS;
+	itr->fsdata = fsdata;
+	itr->clust = fsdata->root_cluster;
+	itr->dent = NULL;
+	itr->remaining = 0;
+	itr->last_cluster = 0;
+	itr->is_root = 1;
 
-			debug("FAT read(sect=%d, cnt:%d), clust_size=%d, DIRENTSPERBLOCK=%zd\n",
-				cursect, read_blk, mydata->clust_size, DIRENTSPERBLOCK);
+	return 0;
+}
 
-			if (disk_read(cursect, read_blk, dir_ptr) < 0) {
-				debug("Error: reading rootdir block\n");
-				goto exit;
-			}
+/**
+ * fat_itr_child() - initialize an iterator to descend into a sub-
+ * directory
+ *
+ * Initializes 'itr' to iterate the contents of the directory at
+ * the current cursor position of 'parent'.  It is an error to
+ * call this if the current cursor of 'parent' is pointing at a
+ * regular file.
+ *
+ * Note that 'itr' and 'parent' can be the same pointer if you do
+ * not need to preserve 'parent' after this call, which is useful
+ * for traversing directory structure to resolve a file/directory.
+ *
+ * @itr: iterator to initialize
+ * @parent: the iterator pointing at a directory entry in the
+ *    parent directory of the directory to iterate
+ */
+static void fat_itr_child(fat_itr *itr, fat_itr *parent)
+{
+	fsdata *mydata = parent->fsdata;  /* for silly macros */
+	unsigned clustnum = START(parent->dent);
 
-			dentptr = (dir_entry *)dir_ptr;
-		}
+	assert(fat_itr_isdir(parent));
 
-		for (i = 0; i < DIRENTSPERBLOCK; i++) {
-			char s_name[14], l_name[VFAT_MAXLEN_BYTES];
-			__u8 csum;
+	itr->fsdata = parent->fsdata;
+	if (clustnum > 0) {
+		itr->clust = clustnum;
+	} else {
+		itr->clust = parent->fsdata->root_cluster;
+	}
+	itr->dent = NULL;
+	itr->remaining = 0;
+	itr->last_cluster = 0;
+	itr->is_root = 0;
+}
 
-			l_name[0] = '\0';
-			if (dentptr->name[0] == DELETED_FLAG) {
-				dentptr++;
-				continue;
-			}
+static void *next_cluster(fat_itr *itr)
+{
+	fsdata *mydata = itr->fsdata;  /* for silly macros */
+	int ret;
+	u32 sect;
+
+	/* have we reached the end? */
+	if (itr->last_cluster)
+		return NULL;
+
+	sect = clust_to_sect(itr->fsdata, itr->clust);
+
+	debug("FAT read(sect=%d), clust_size=%d, DIRENTSPERBLOCK=%zd\n",
+	      sect, itr->fsdata->clust_size, DIRENTSPERBLOCK);
+
+	/*
+	 * NOTE: do_fat_read_at() had complicated logic to deal w/
+	 * vfat names that span multiple clusters in the fat16 case,
+	 * which get_dentfromdir() probably also needed (and was
+	 * missing).  And not entirely sure what fat32 didn't have
+	 * the same issue..  We solve that by only caring about one
+	 * dent at a time and iteratively constructing the vfat long
+	 * name.
+	 */
+	ret = disk_read(sect, itr->fsdata->clust_size,
+			itr->block);
+	if (ret < 0) {
+		debug("Error: reading block\n");
+		return NULL;
+	}
 
-			if (vfat_enabled)
-				csum = mkcksum(dentptr->name, dentptr->ext);
-
-			if (dentptr->attr & ATTR_VOLUME) {
-				if (vfat_enabled &&
-				    (dentptr->attr & ATTR_VFAT) == ATTR_VFAT &&
-				    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
-					prevcksum =
-						((dir_slot *)dentptr)->alias_checksum;
-
-					get_vfatname(mydata,
-						     root_cluster,
-						     dir_ptr,
-						     dentptr, l_name);
-
-					if (dols == LS_ROOT) {
-						char dirc;
-						int doit = 0;
-						int isdir =
-							(dentptr->attr & ATTR_DIR);
-
-						if (isdir) {
-							dirs++;
-							dirc = '/';
-							doit = 1;
-						} else {
-							dirc = ' ';
-							if (l_name[0] != 0) {
-								files++;
-								doit = 1;
-							}
-						}
-						if (doit) {
-							if (dirc == ' ') {
-								printf(" %8u   %s%c\n",
-								       FAT2CPU32(dentptr->size),
-									l_name,
-									dirc);
-							} else {
-								printf("            %s%c\n",
-									l_name,
-									dirc);
-							}
-						}
-						dentptr++;
-						continue;
-					}
-					debug("Rootvfatname: |%s|\n",
-					       l_name);
-				} else {
-					/* Volume label or VFAT entry */
-					dentptr++;
-					continue;
-				}
-			} else if (dentptr->name[0] == 0) {
-				debug("RootDentname == NULL - %d\n", i);
-				if (dols == LS_ROOT) {
-					printf("\n%d file(s), %d dir(s)\n\n",
-						files, dirs);
-					ret = 0;
-				}
-				goto exit;
-			}
-			else if (vfat_enabled &&
-				 dols == LS_ROOT && csum == prevcksum) {
-				prevcksum = 0xffff;
-				dentptr++;
-				continue;
-			}
+	if (itr->is_root && itr->fsdata->fatsize != 32) {
+		itr->clust++;
+		sect = clust_to_sect(itr->fsdata, itr->clust);
+		if (sect - itr->fsdata->rootdir_sect >=
+		    itr->fsdata->rootdir_size) {
+			debug("cursect: 0x%x\n", itr->clust);
+			itr->last_cluster = 1;
+		}
+	} else {
+		itr->clust = get_fatent(itr->fsdata, itr->clust);
+		if (CHECK_CLUST(itr->clust, itr->fsdata->fatsize)) {
+			debug("cursect: 0x%x\n", itr->clust);
+			itr->last_cluster = 1;
+		}
+	}
 
-			get_name(dentptr, s_name);
-
-			if (dols == LS_ROOT) {
-				int isdir = (dentptr->attr & ATTR_DIR);
-				char dirc;
-				int doit = 0;
-
-				if (isdir) {
-					dirc = '/';
-					if (s_name[0] != 0) {
-						dirs++;
-						doit = 1;
-					}
-				} else {
-					dirc = ' ';
-					if (s_name[0] != 0) {
-						files++;
-						doit = 1;
-					}
-				}
-				if (doit) {
-					if (dirc == ' ') {
-						printf(" %8u   %s%c\n",
-						       FAT2CPU32(dentptr->size),
-							s_name, dirc);
-					} else {
-						printf("            %s%c\n",
-							s_name, dirc);
-					}
-				}
-				dentptr++;
-				continue;
-			}
+	return itr->block;
+}
 
-			if (strcmp(fnamecopy, s_name)
-			    && strcmp(fnamecopy, l_name)) {
-				debug("RootMismatch: |%s|%s|\n", s_name,
-				       l_name);
-				dentptr++;
-				continue;
-			}
+static dir_entry *next_dent(fat_itr *itr)
+{
+	if (itr->remaining == 0) {
+		struct dir_entry *dent = next_cluster(itr);
+		unsigned nbytes = itr->fsdata->sect_size *
+			itr->fsdata->clust_size;
 
-			if (isdir && !(dentptr->attr & ATTR_DIR))
-				goto exit;
+		/* have we reached the last cluster? */
+		if (!dent)
+			return NULL;
 
-			debug("RootName: %s", s_name);
-			debug(", start: 0x%x", START(dentptr));
-			debug(", size:  0x%x %s\n",
-			       FAT2CPU32(dentptr->size),
-			       isdir ? "(DIR)" : "");
+		itr->remaining = nbytes / sizeof(dir_entry) - 1;
+		itr->dent = dent;
+	} else {
+		itr->remaining--;
+		itr->dent++;
+	}
 
-			goto rootdir_done;	/* We got a match */
-		}
-		debug("END LOOP: buffer_blk_cnt=%d   clust_size=%d\n", buffer_blk_cnt,
-		       mydata->clust_size);
+	/* have we reached the last valid entry? */
+	if (itr->dent->name[0] == 0)
+		return NULL;
 
-		/*
-		 * On FAT32 we must fetch the FAT entries for the next
-		 * root directory clusters when a cluster has been
-		 * completely processed.
-		 */
-		++buffer_blk_cnt;
-		int rootdir_end = 0;
-		if (mydata->fatsize == 32) {
-			if (buffer_blk_cnt == mydata->clust_size) {
-				int nxtsect = 0;
-				int nxt_clust = 0;
+	return itr->dent;
+}
 
-				nxt_clust = get_fatent(mydata, root_cluster);
-				rootdir_end = CHECK_CLUST(nxt_clust, 32);
+static dir_entry *extract_vfat_name(fat_itr *itr)
+{
+	struct dir_entry *dent = itr->dent;
+	int seqn = itr->dent->name[0] & ~LAST_LONG_ENTRY_MASK;
+	u8 chksum, alias_checksum = ((dir_slot *)dent)->alias_checksum;
+	int n = 0;
 
-				nxtsect = mydata->data_begin +
-					(nxt_clust * mydata->clust_size);
+	while (seqn--) {
+		char buf[13];
+		int idx = 0;
 
-				root_cluster = nxt_clust;
+		slot2str((dir_slot *)dent, buf, &idx);
 
-				cursect = nxtsect;
-				buffer_blk_cnt = 0;
-			}
-		} else {
-			if (buffer_blk_cnt == PREFETCH_BLOCKS)
-				buffer_blk_cnt = 0;
+		/* shift accumulated long-name up and copy new part in: */
+		memmove(itr->l_name + idx, itr->l_name, n);
+		memcpy(itr->l_name, buf, idx);
+		n += idx;
 
-			rootdir_end = (++cursect - mydata->rootdir_sect >=
-				       rootdir_size);
-		}
+		dent = next_dent(itr);
+		if (!dent)
+			return NULL;
+	}
 
-		/* If end of rootdir reached */
-		if (rootdir_end) {
-			if (dols == LS_ROOT) {
-				printf("\n%d file(s), %d dir(s)\n\n",
-				       files, dirs);
-				*size = 0;
-			}
-			goto exit;
-		}
+	itr->l_name[n] = '\0';
+
+	chksum = mkcksum(dent->name, dent->ext);
+
+	/* checksum mismatch could mean deleted file, etc.. skip it: */
+	if (chksum != alias_checksum) {
+		debug("** chksum=%x, alias_checksum=%x, l_name=%s, s_name=%8s.%3s\n",
+		      chksum, alias_checksum, itr->l_name, dent->name, dent->ext);
+		return NULL;
 	}
-rootdir_done:
 
-	firsttime = 1;
+	return dent;
+}
 
-	while (isdir) {
-		int startsect = mydata->data_begin
-			+ START(dentptr) * mydata->clust_size;
-		dir_entry dent;
-		char *nextname = NULL;
+/**
+ * fat_itr_next() - step to the next entry in a directory
+ *
+ * Must be called once on a new iterator before the cursor is valid.
+ *
+ * @itr: the iterator to iterate
+ * @return boolean, 1 if success or 0 if no more entries in the
+ *    current directory
+ */
+static int fat_itr_next(fat_itr *itr)
+{
+	dir_entry *dent;
 
-		dent = *dentptr;
-		dentptr = &dent;
+	itr->name = NULL;
 
-		idx = dirdelim(subname);
+	while (1) {
+		dent = next_dent(itr);
+		if (!dent)
+			return 0;
 
-		if (idx >= 0) {
-			subname[idx] = '\0';
-			nextname = subname + idx + 1;
-			/* Handle multiple delimiters */
-			while (ISDIRDELIM(*nextname))
-				nextname++;
-			if (dols && *nextname == '\0')
-				firsttime = 0;
-		} else {
-			if (dols && firsttime) {
-				firsttime = 0;
+		if (dent->name[0] == DELETED_FLAG ||
+		    dent->name[0] == aRING)
+			continue;
+
+		if (dent->attr & ATTR_VOLUME) {
+			if (vfat_enabled &&
+			    (dent->attr & ATTR_VFAT) == ATTR_VFAT &&
+			    (dent->name[0] & LAST_LONG_ENTRY_MASK)) {
+				dent = extract_vfat_name(itr);
+				if (!dent)
+					continue;
+				itr->name = itr->l_name;
+				break;
 			} else {
-				isdir = 0;
+				/* Volume label or VFAT entry, skip */
+				continue;
 			}
 		}
 
-		if (get_dentfromdir(mydata, startsect, subname, dentptr,
-				     isdir ? 0 : dols) == NULL) {
-			if (dols && !isdir)
-				*size = 0;
-			goto exit;
-		}
+		break;
+	}
 
-		if (isdir && !(dentptr->attr & ATTR_DIR))
-			goto exit;
+	get_name(dent, itr->s_name);
+	if (!itr->name)
+		itr->name = itr->s_name;
 
-		/*
-		 * If we are looking for a directory, and found a directory
-		 * type entry, and the entry is for the root directory (as
-		 * denoted by a cluster number of 0), jump back to the start
-		 * of the function, since at least on FAT12/16, the root dir
-		 * lives in a hard-coded location and needs special handling
-		 * to parse, rather than simply following the cluster linked
-		 * list in the FAT, like other directories.
-		 */
-		if (isdir && (dentptr->attr & ATTR_DIR) && !START(dentptr)) {
-			/*
-			 * Modify the filename to remove the prefix that gets
-			 * back to the root directory, so the initial root dir
-			 * parsing code can continue from where we are without
-			 * confusion.
-			 */
-			strcpy(fnamecopy, nextname ?: "");
-			/*
-			 * Set up state the same way as the function does when
-			 * first started. This is required for the root dir
-			 * parsing code operates in its expected environment.
-			 */
-			subname = "";
-			cursect = mydata->rootdir_sect;
-			isdir = 0;
-			goto root_reparse;
-		}
+	return 1;
+}
 
-		if (idx >= 0)
-			subname = nextname;
-	}
+/**
+ * fat_itr_isdir() - is current cursor position pointing to a directory
+ *
+ * @itr: the iterator
+ * @return true if cursor is at a directory
+ */
+static int fat_itr_isdir(fat_itr *itr)
+{
+	return !!(itr->dent->attr & ATTR_DIR);
+}
 
-	if (dogetsize) {
-		*size = FAT2CPU32(dentptr->size);
-		ret = 0;
-	} else {
-		ret = get_contents(mydata, dentptr, pos, buffer, maxsize, size);
-	}
-	debug("Size: %u, got: %llu\n", FAT2CPU32(dentptr->size), *size);
+/*
+ * Helpers:
+ */
 
-exit:
-	free(mydata->fatbuf);
-	return ret;
-}
+#define TYPE_FILE 0x1
+#define TYPE_DIR  0x2
+#define TYPE_ANY  (TYPE_FILE | TYPE_DIR)
 
-int do_fat_read(const char *filename, void *buffer, loff_t maxsize, int dols,
-		loff_t *actread)
+/**
+ * fat_itr_resolve() - traverse directory structure to resolve the
+ * requested path.
+ *
+ * Traverse directory structure to the requested path.  If the specified
+ * path is to a directory, this will descend into the directory and
+ * leave it iterator at the start of the directory.  If the path is to a
+ * file, it will leave the iterator in the parent directory with current
+ * cursor at file's entry in the directory.
+ *
+ * @itr: iterator initialized to root
+ * @path: the requested path
+ * @type: bitmask of allowable file types
+ * @return 0 on success or -errno
+ */
+static int fat_itr_resolve(fat_itr *itr, const char *path, unsigned type)
 {
-	return do_fat_read_at(filename, 0, buffer, maxsize, dols, 0, actread);
+	const char *next;
+
+	/* chomp any extra leading slashes: */
+	while (path[0] && ISDIRDELIM(path[0]))
+		path++;
+
+	/* are we at the end? */
+	if (strlen(path) == 0) {
+		if (!(type & TYPE_DIR))
+			return -ENOENT;
+		return 0;
+	}
+
+	/* find length of next path entry: */
+	next = path;
+	while (next[0] && !ISDIRDELIM(next[0]))
+		next++;
+
+	while (fat_itr_next(itr)) {
+		int match = 0;
+		unsigned n = max(strlen(itr->name), (size_t)(next - path));
+
+		/* check both long and short name: */
+		if (!strncasecmp(path, itr->name, n))
+			match = 1;
+		else if (itr->name != itr->s_name &&
+			 !strncasecmp(path, itr->s_name, n))
+			match = 1;
+
+		if (!match)
+			continue;
+
+		if (fat_itr_isdir(itr)) {
+			/* recurse into directory: */
+			fat_itr_child(itr, itr);
+			return fat_itr_resolve(itr, next, type);
+		} else if (next[0]) {
+			/*
+			 * If next is not empty then we have a case
+			 * like: /path/to/realfile/nonsense
+			 */
+			debug("bad trailing path: %s\n", next);
+			return -ENOENT;
+		} else if (!(type & TYPE_FILE)) {
+			return -ENOTDIR;
+		} else {
+			return 0;
+		}
+	}
+
+	return -ENOENT;
 }
 
 int file_fat_detectfs(void)
@@ -1300,33 +1031,88 @@ int file_fat_detectfs(void)
 	return 0;
 }
 
-int file_fat_ls(const char *dir)
-{
-	loff_t size;
-
-	return do_fat_read(dir, NULL, 0, LS_YES, &size);
-}
-
 int fat_exists(const char *filename)
 {
+	fsdata fsdata;
+	fat_itr *itr;
 	int ret;
-	loff_t size;
 
-	ret = do_fat_read_at(filename, 0, NULL, 0, LS_NO, 1, &size);
+	itr = malloc_cache_aligned(sizeof(fat_itr));
+	if (!itr)
+		return 0;
+	ret = fat_itr_root(itr, &fsdata);
+	if (ret)
+		goto out;
+
+	ret = fat_itr_resolve(itr, filename, TYPE_ANY);
+	free(fsdata.fatbuf);
+out:
+	free(itr);
 	return ret == 0;
 }
 
 int fat_size(const char *filename, loff_t *size)
 {
-	return do_fat_read_at(filename, 0, NULL, 0, LS_NO, 1, size);
+	fsdata fsdata;
+	fat_itr *itr;
+	int ret;
+
+	itr = malloc_cache_aligned(sizeof(fat_itr));
+	if (!itr)
+		return -ENOMEM;
+	ret = fat_itr_root(itr, &fsdata);
+	if (ret)
+		goto out_free_itr;
+
+	ret = fat_itr_resolve(itr, filename, TYPE_FILE);
+	if (ret) {
+		/*
+		 * Directories don't have size, but fs_size() is not
+		 * expected to fail if passed a directory path:
+		 */
+		free(fsdata.fatbuf);
+		fat_itr_root(itr, &fsdata);
+		if (!fat_itr_resolve(itr, filename, TYPE_DIR)) {
+			*size = 0;
+			ret = 0;
+		}
+		goto out_free_both;
+	}
+
+	*size = FAT2CPU32(itr->dent->size);
+out_free_both:
+	free(fsdata.fatbuf);
+out_free_itr:
+	free(itr);
+	return ret;
 }
 
 int file_fat_read_at(const char *filename, loff_t pos, void *buffer,
 		     loff_t maxsize, loff_t *actread)
 {
+	fsdata fsdata;
+	fat_itr *itr;
+	int ret;
+
+	itr = malloc_cache_aligned(sizeof(fat_itr));
+	if (!itr)
+		return -ENOMEM;
+	ret = fat_itr_root(itr, &fsdata);
+	if (ret)
+		goto out_free_itr;
+
+	ret = fat_itr_resolve(itr, filename, TYPE_FILE);
+	if (ret)
+		goto out_free_both;
+
 	printf("reading %s\n", filename);
-	return do_fat_read_at(filename, pos, buffer, maxsize, LS_NO, 0,
-			      actread);
+	ret = get_contents(&fsdata, itr->dent, pos, buffer, maxsize, actread);
+
+out_free_both:
+	free(fsdata.fatbuf);
+out_free_itr:
+	free(itr);
+	return ret;
 }
 
 int file_fat_read(const char *filename, void *buffer, int maxsize)
@@ -1353,6 +1139,69 @@ int fat_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 	return ret;
 }
 
+typedef struct {
+	struct fs_dir_stream parent;
+	struct fs_dirent dirent;
+	fsdata fsdata;
+	fat_itr itr;
+} fat_dir;
+
+int fat_opendir(const char *filename, struct fs_dir_stream **dirsp)
+{
+	fat_dir *dir = calloc(1, sizeof(*dir));
+	int ret;
+
+	if (!dir)
+		return -ENOMEM;
+
+	ret = fat_itr_root(&dir->itr, &dir->fsdata);
+	if (ret)
+		goto fail_free_dir;
+
+	ret = fat_itr_resolve(&dir->itr, filename, TYPE_DIR);
+	if (ret)
+		goto fail_free_both;
+
+	*dirsp = (struct fs_dir_stream *)dir;
+	return 0;
+
+fail_free_both:
+	free(dir->fsdata.fatbuf);
+fail_free_dir:
+	free(dir);
+	return ret;
+}
+
+int fat_readdir(struct fs_dir_stream *dirs, struct fs_dirent **dentp)
+{
+	fat_dir *dir = (fat_dir *)dirs;
+	struct fs_dirent *dent = &dir->dirent;
+
+	if (!fat_itr_next(&dir->itr))
+		return -ENOENT;
+
+	memset(dent, 0, sizeof(*dent));
+	strcpy(dent->name, dir->itr.name);
+
+	if (fat_itr_isdir(&dir->itr)) {
+		dent->type = FS_DT_DIR;
+	} else {
+		dent->type = FS_DT_REG;
+		dent->size = FAT2CPU32(dir->itr.dent->size);
+	}
+
+	*dentp = dent;
+
+	return 0;
+}
+
+void fat_closedir(struct fs_dir_stream *dirs)
+{
+	fat_dir *dir = (fat_dir *)dirs;
+	free(dir->fsdata.fatbuf);
+	free(dir);
+}
+
 void fat_close(void)
 {
 }
diff --git a/fs/fat/fat_write.c b/fs/fat/fat_write.c
index 4ca024c208..9d2e0ed74c 100644
--- a/fs/fat/fat_write.c
+++ b/fs/fat/fat_write.c
@@ -345,7 +345,7 @@ get_long_file_name(fsdata *mydata, int curclust, __u8 *cluster,
 		*l_name = '\0';
 	else if (*l_name == aRING)
 		*l_name = DELETED_FLAG;
-	downcase(l_name);
+	downcase(l_name, INT_MAX);
 
 	/* Return the real directory entry */
 	*retdent = realdent;
@@ -502,8 +502,7 @@ set_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer,
 	int ret;
 
 	if (clustnum > 0)
-		startsect = mydata->data_begin +
-				clustnum * mydata->clust_size;
+		startsect = clust_to_sect(mydata, clustnum);
 	else
 		startsect = mydata->rootdir_sect;
 
@@ -751,8 +750,7 @@ static int check_overflow(fsdata *mydata, __u32 clustnum, loff_t size)
 	__u32 startsect, sect_num, offset;
 
 	if (clustnum > 0) {
-		startsect = mydata->data_begin +
-				clustnum * mydata->clust_size;
+		startsect = clust_to_sect(mydata, clustnum);
 	} else {
 		startsect = mydata->rootdir_sect;
 	}
@@ -791,7 +789,7 @@ static dir_entry *empty_dentptr;
 static dir_entry *find_directory_entry(fsdata *mydata, int startsect,
 	char *filename, dir_entry *retdent, __u32 start)
 {
-	__u32 curclust = (startsect - mydata->data_begin) / mydata->clust_size;
+	__u32 curclust = sect_to_clust(mydata, startsect);
 
 	debug("get_dentfromdir: %s\n", filename);
 
@@ -981,7 +979,7 @@ static int do_fat_write(const char *filename, void *buffer, loff_t size,
 
 	memcpy(l_filename, filename, name_len);
 	l_filename[name_len] = 0; /* terminate the string */
-	downcase(l_filename);
+	downcase(l_filename, INT_MAX);
 
 	startsect = mydata->rootdir_sect;
 	retdent = find_directory_entry(mydata, startsect,
diff --git a/fs/fs.c b/fs/fs.c
index 13cd3626c6..60aca0f767 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -21,6 +21,7 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 static struct blk_desc *fs_dev_desc;
+static int fs_dev_part;
 static disk_partition_t fs_partition;
 static int fs_type = FS_TYPE_ANY;
 
@@ -36,6 +37,35 @@ static inline int fs_ls_unsupported(const char *dirname)
 	return -1;
 }
 
+/* generic implementation of ls in terms of opendir/readdir/closedir */
+__maybe_unused
+static int fs_ls_generic(const char *dirname)
+{
+	struct fs_dir_stream *dirs;
+	struct fs_dirent *dent;
+	int nfiles = 0, ndirs = 0;
+
+	dirs = fs_opendir(dirname);
+	if (!dirs)
+		return -errno;
+
+	while ((dent = fs_readdir(dirs))) {
+		if (dent->type == FS_DT_DIR) {
+			printf("            %s/\n", dent->name);
+			ndirs++;
+		} else {
+			printf(" %8lld   %s\n", dent->size, dent->name);
+			nfiles++;
+		}
+	}
+
+	fs_closedir(dirs);
+
+	printf("\n%d file(s), %d dir(s)\n\n", nfiles, ndirs);
+
+	return 0;
+}
+
 static inline int fs_exists_unsupported(const char *filename)
 {
 	return 0;
@@ -69,6 +99,12 @@ static inline int fs_uuid_unsupported(char *uuid_str)
 	return -1;
 }
 
+static inline int fs_opendir_unsupported(const char *filename,
+					 struct fs_dir_stream **dirs)
+{
+	return -EACCES;
+}
+
 struct fstype_info {
 	int fstype;
 	char *name;
@@ -92,6 +128,20 @@ struct fstype_info {
 		     loff_t len, loff_t *actwrite);
 	void (*close)(void);
 	int (*uuid)(char *uuid_str);
+	/*
+	 * Open a directory stream.  On success return 0 and directory
+	 * stream pointer via 'dirsp'.  On error, return -errno.  See
+	 * fs_opendir().
+	 */
+	int (*opendir)(const char *filename, struct fs_dir_stream **dirsp);
+	/*
+	 * Read next entry from directory stream.  On success return 0
+	 * and directory entry pointer via 'dentp'.  On error return
+	 * -errno.  See fs_readdir().
+	 */
+	int (*readdir)(struct fs_dir_stream *dirs, struct fs_dirent **dentp);
+	/* see fs_closedir() */
+	void (*closedir)(struct fs_dir_stream *dirs);
 };
 
 static struct fstype_info fstypes[] = {
@@ -102,7 +152,7 @@ static struct fstype_info fstypes[] = {
 		.null_dev_desc_ok = false,
 		.probe = fat_set_blk_dev,
 		.close = fat_close,
-		.ls = file_fat_ls,
+		.ls = fs_ls_generic,
 		.exists = fat_exists,
 		.size = fat_size,
 		.read = fat_read_file,
@@ -112,6 +162,9 @@ static struct fstype_info fstypes[] = {
 		.write = fs_write_unsupported,
 #endif
 		.uuid = fs_uuid_unsupported,
+		.opendir = fat_opendir,
+		.readdir = fat_readdir,
+		.closedir = fat_closedir,
 	},
 #endif
 #ifdef CONFIG_FS_EXT4
@@ -131,6 +184,7 @@ static struct fstype_info fstypes[] = {
 		.write = fs_write_unsupported,
 #endif
 		.uuid = ext4fs_uuid,
+		.opendir = fs_opendir_unsupported,
 	},
 #endif
 #ifdef CONFIG_SANDBOX
@@ -146,6 +200,7 @@ static struct fstype_info fstypes[] = {
 		.read = fs_read_sandbox,
 		.write = fs_write_sandbox,
 		.uuid = fs_uuid_unsupported,
+		.opendir = fs_opendir_unsupported,
 	},
 #endif
 #ifdef CONFIG_CMD_UBIFS
@@ -161,6 +216,7 @@ static struct fstype_info fstypes[] = {
 		.read = ubifs_read,
 		.write = fs_write_unsupported,
 		.uuid = fs_uuid_unsupported,
+		.opendir = fs_opendir_unsupported,
 	},
 #endif
 	{
@@ -175,6 +231,7 @@ static struct fstype_info fstypes[] = {
 		.read = fs_read_unsupported,
 		.write = fs_write_unsupported,
 		.uuid = fs_uuid_unsupported,
+		.opendir = fs_opendir_unsupported,
 	},
 };
 
@@ -226,6 +283,31 @@ int fs_set_blk_dev(const char *ifname, const char *dev_part_str, int fstype)
 		if (!fs_dev_desc && !info->null_dev_desc_ok)
 			continue;
 
+		if (!info->probe(fs_dev_desc, &fs_partition)) {
+			fs_type = info->fstype;
+			fs_dev_part = part;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+/* set current blk device w/ blk_desc + partition # */
+int fs_set_blk_dev_with_part(struct blk_desc *desc, int part)
+{
+	struct fstype_info *info;
+	int ret, i;
+
+	if (part >= 1)
+		ret = part_get_info(desc, part, &fs_partition);
+	else
+		ret = part_get_info_whole_disk(desc, &fs_partition);
+	if (ret)
+		return ret;
+	fs_dev_desc = desc;
+
+	for (i = 0, info = fstypes; i < ARRAY_SIZE(fstypes); i++, info++) {
 		if (!info->probe(fs_dev_desc, &fs_partition)) {
 			fs_type = info->fstype;
 			return 0;
@@ -235,6 +317,25 @@ int fs_set_blk_dev(const char *ifname, const char *dev_part_str, int fstype)
 	return -1;
 }
 
+int fs_get_fstype(const char **fstype_name)
+{
+	struct fstype_info *info;
+
+	if (fstype_name == NULL) {
+		printf("** parameter error **\n");
+		return -1;
+	}
+
+	info = fs_get_info(fs_type);
+	if (info->fstype == FS_TYPE_ANY) {
+		printf("** not match any filesystem type **\n");
+		return -1;
+	}
+
+	*fstype_name = info->name;
+	return 0;
+}
+
 static void fs_close(void)
 {
 	struct fstype_info *info = fs_get_info(fs_type);
@@ -334,6 +435,59 @@ int fs_write(const char *filename, ulong addr, loff_t offset, loff_t len,
 	return ret;
 }
 
+struct fs_dir_stream *fs_opendir(const char *filename)
+{
+	struct fstype_info *info = fs_get_info(fs_type);
+	struct fs_dir_stream *dirs = NULL;
+	int ret;
+
+	ret = info->opendir(filename, &dirs);
+	fs_close();
+	if (ret) {
+		errno = -ret;
+		return NULL;
+	}
+
+	dirs->desc = fs_dev_desc;
+	dirs->part = fs_dev_part;
+
+	return dirs;
+}
+
+struct fs_dirent *fs_readdir(struct fs_dir_stream *dirs)
+{
+	struct fstype_info *info;
+	struct fs_dirent *dirent;
+	int ret;
+
+	fs_set_blk_dev_with_part(dirs->desc, dirs->part);
+	info = fs_get_info(fs_type);
+
+	ret = info->readdir(dirs, &dirent);
+	fs_close();
+	if (ret) {
+		errno = -ret;
+		return NULL;
+	}
+
+	return dirent;
+}
+
+void fs_closedir(struct fs_dir_stream *dirs)
+{
+	struct fstype_info *info;
+
+	if (!dirs)
+		return;
+
+	fs_set_blk_dev_with_part(dirs->desc, dirs->part);
+	info = fs_get_info(fs_type);
+
+	info->closedir(dirs);
+	fs_close();
+}
+
+
 int do_size(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 		int fstype)
 {
diff --git a/fs/jffs2/jffs2_nand_1pass.c b/fs/jffs2/jffs2_nand_1pass.c
index 1d63fc9434..b16005e604 100644
--- a/fs/jffs2/jffs2_nand_1pass.c
+++ b/fs/jffs2/jffs2_nand_1pass.c
@@ -798,7 +798,7 @@ jffs2_1pass_build_lists(struct part_info * part)
 	struct mtdids *id = part->dev->id;
 	mtd = get_nand_dev_by_index(id->num);
 	if (!mtd) {
-		error("\nno NAND devices available\n");
+		pr_err("\nno NAND devices available\n");
 		return 0;
 	}
 
diff --git a/fs/reiserfs/dev.c b/fs/reiserfs/dev.c
index 5a1ab0a364..7b786e4ed3 100644
--- a/fs/reiserfs/dev.c
+++ b/fs/reiserfs/dev.c
@@ -9,7 +9,7 @@
 #include <common.h>
 #include <config.h>
 #include <reiserfs.h>
-
+#include <fs_internal.h>
 #include "reiserfs_private.h"
 
 static struct blk_desc *reiserfs_blk_desc;
@@ -22,78 +22,8 @@ void reiserfs_set_blk_dev(struct blk_desc *rbdd, disk_partition_t *info)
 	part_info = info;
 }
 
-
-int reiserfs_devread (int sector, int byte_offset, int byte_len, char *buf)
+int reiserfs_devread(int sector, int byte_offset, int byte_len, char *buf)
 {
-	char sec_buf[SECTOR_SIZE];
-	unsigned block_len;
-/*
-	unsigned len = byte_len;
-	u8 *start = buf;
-*/
-	/*
-	*  Check partition boundaries
-	*/
-	if (sector < 0
-	    || ((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS))
-	    >= part_info->size)) {
-/*		errnum = ERR_OUTSIDE_PART; */
-		printf (" ** reiserfs_devread() read outside partition\n");
-		return 0;
-	}
-
-	/*
-	 *  Get the read to the beginning of a partition.
-	 */
-	sector += byte_offset >> SECTOR_BITS;
-	byte_offset &= SECTOR_SIZE - 1;
-
-#if defined(DEBUG)
-	printf (" <%d, %d, %d> ", sector, byte_offset, byte_len);
-#endif
-
-
-	if (reiserfs_blk_desc == NULL)
-		return 0;
-
-
-	if (byte_offset != 0) {
-		/* read first part which isn't aligned with start of sector */
-		if (reiserfs_blk_desc->block_read(reiserfs_blk_desc,
-						  part_info->start + sector,
-						  1, (void *)sec_buf) != 1) {
-			printf (" ** reiserfs_devread() read error\n");
-			return 0;
-		}
-		memcpy(buf, sec_buf+byte_offset, min(SECTOR_SIZE-byte_offset, byte_len));
-		buf+=min(SECTOR_SIZE-byte_offset, byte_len);
-		byte_len-=min(SECTOR_SIZE-byte_offset, byte_len);
-		sector++;
-	}
-
-	/* read sector aligned part */
-	block_len = byte_len & ~(SECTOR_SIZE-1);
-	if (reiserfs_blk_desc->block_read(reiserfs_blk_desc,
-					  part_info->start + sector,
-					  block_len / SECTOR_SIZE, (void *)buf)
-			!= block_len/SECTOR_SIZE) {
-		printf (" ** reiserfs_devread() read error - block\n");
-		return 0;
-	}
-	buf+=block_len;
-	byte_len-=block_len;
-	sector+= block_len/SECTOR_SIZE;
-
-	if ( byte_len != 0 ) {
-		/* read rest of data which are not in whole sector */
-		if (reiserfs_blk_desc->block_read(reiserfs_blk_desc,
-						  part_info->start + sector,
-						  1, (void *)sec_buf) != 1) {
-			printf (" ** reiserfs_devread() read error - last part\n");
-			return 0;
-		}
-		memcpy(buf, sec_buf, byte_len);
-	}
-
-	return 1;
+	return fs_devread(reiserfs_blk_desc, part_info, sector, byte_offset,
+			  byte_len, buf);
 }
diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
index 38c91d0734..ae3d4cb306 100644
--- a/fs/ubifs/debug.c
+++ b/fs/ubifs/debug.c
@@ -16,6 +16,8 @@
  * various local functions of those subsystems.
  */
 
+#include <hexdump.h>
+
 #ifndef __UBOOT__
 #include <linux/module.h>
 #include <linux/debugfs.h>
@@ -308,7 +310,7 @@ void ubifs_dump_node(const struct ubifs_info *c, const void *node)
 	/* If the magic is incorrect, just hexdump the first bytes */
 	if (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC) {
 		pr_err("Not a node, first %zu bytes:", UBIFS_CH_SZ);
-		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_OFFSET, 32, 1,
+		print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 1,
 			       (void *)node, UBIFS_CH_SZ, 1);
 		return;
 	}
@@ -483,7 +485,7 @@ void ubifs_dump_node(const struct ubifs_info *c, const void *node)
 		       (int)le16_to_cpu(dn->compr_type));
 		pr_err("\tdata size      %d\n", dlen);
 		pr_err("\tdata:\n");
-		print_hex_dump(KERN_ERR, "\t", DUMP_PREFIX_OFFSET, 32, 1,
+		print_hex_dump("\t", DUMP_PREFIX_OFFSET, 32, 1,
 			       (void *)&dn->data, dlen, 0);
 		break;
 	}
diff --git a/fs/ubifs/debug.h b/fs/ubifs/debug.h
index 807ce1b733..0d8ed57cbd 100644
--- a/fs/ubifs/debug.h
+++ b/fs/ubifs/debug.h
@@ -168,7 +168,7 @@ struct ubifs_global_debug_info {
 #else
 #define ubifs_assert(expr) do {                                                \
 	if (unlikely(!(expr))) {                                               \
-		pr_crit("UBIFS assert failed in %s at %u\n",                   \
+		pr_debug("UBIFS assert failed in %s at %u\n",                  \
 		       __func__, __LINE__);                                    \
 		dump_stack();                                                  \
 	}                                                                      \
@@ -177,7 +177,7 @@ struct ubifs_global_debug_info {
 #define ubifs_assert_cmt_locked(c) do {                                        \
 	if (unlikely(down_write_trylock(&(c)->commit_sem))) {                  \
 		up_write(&(c)->commit_sem);                                    \
-		pr_crit("commit lock is not locked!\n");                       \
+		pr_debug("commit lock is not locked!\n");                      \
 		ubifs_assert(0);                                               \
 	}                                                                      \
 } while (0)
diff --git a/fs/ubifs/scan.c b/fs/ubifs/scan.c
index 12a3597468..9b2fbe970e 100644
--- a/fs/ubifs/scan.c
+++ b/fs/ubifs/scan.c
@@ -17,6 +17,7 @@
  */
 
 #ifdef __UBOOT__
+#include <hexdump.h>
 #include <linux/err.h>
 #endif
 #include "ubifs.h"
@@ -237,7 +238,7 @@ void ubifs_scanned_corruption(const struct ubifs_info *c, int lnum, int offs,
 	if (len > 8192)
 		len = 8192;
 	ubifs_err(c, "first %d bytes from LEB %d:%d", len, lnum, offs);
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 4, buf, len, 1);
+	print_hex_dump("", DUMP_PREFIX_OFFSET, 32, 4, buf, len, 1);
 }
 
 /**
diff --git a/fs/ubifs/ubifs.c b/fs/ubifs/ubifs.c
index 8f1c9d167d..739df5d301 100644
--- a/fs/ubifs/ubifs.c
+++ b/fs/ubifs/ubifs.c
@@ -350,7 +350,9 @@ static int ubifs_printdir(struct file *file, void *dirent)
 		dbg_gen("feed '%s', ino %llu, new f_pos %#x",
 			dent->name, (unsigned long long)le64_to_cpu(dent->inum),
 			key_hash_flash(c, &dent->key));
+#ifndef __UBOOT__
 		ubifs_assert(le64_to_cpu(dent->ch.sqnum) > ubifs_inode(dir)->creat_sqnum);
+#endif
 
 		nm.len = le16_to_cpu(dent->nlen);
 		over = filldir(c, (char *)dent->name, nm.len,
@@ -432,7 +434,9 @@ static int ubifs_finddir(struct super_block *sb, char *dirname,
 		dbg_gen("feed '%s', ino %llu, new f_pos %#x",
 			dent->name, (unsigned long long)le64_to_cpu(dent->inum),
 			key_hash_flash(c, &dent->key));
+#ifndef __UBOOT__
 		ubifs_assert(le64_to_cpu(dent->ch.sqnum) > ubifs_inode(dir)->creat_sqnum);
+#endif
 
 		nm.len = le16_to_cpu(dent->nlen);
 		if ((strncmp(dirname, (char *)dent->name, nm.len) == 0) &&
diff --git a/fs/yaffs2/yaffs_mtdif.c b/fs/yaffs2/yaffs_mtdif.c
index 636c7770e2..d338f9aa91 100644
--- a/fs/yaffs2/yaffs_mtdif.c
+++ b/fs/yaffs2/yaffs_mtdif.c
@@ -22,7 +22,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/types.h>
 #include <linux/time.h>
-#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
 
 
 static inline void translate_spare2oob(const struct yaffs_spare *spare, u8 *oob)
diff --git a/fs/yaffs2/yaffs_uboot_glue.c b/fs/yaffs2/yaffs_uboot_glue.c
index bd66d31697..2a70e4a543 100644
--- a/fs/yaffs2/yaffs_uboot_glue.c
+++ b/fs/yaffs2/yaffs_uboot_glue.c
@@ -168,7 +168,7 @@ void cmd_yaffs_devconfig(char *_mp, int flash_dev,
 
 	mtd = get_nand_dev_by_index(flash_dev);
 	if (!mtd) {
-		error("\nno NAND devices available\n");
+		pr_err("\nno NAND devices available\n");
 		return;
 	}
 
diff --git a/fs/zfs/dev.c b/fs/zfs/dev.c
index 2f409e66cd..7dda42b48b 100644
--- a/fs/zfs/dev.c
+++ b/fs/zfs/dev.c
@@ -11,6 +11,7 @@
 
 #include <common.h>
 #include <config.h>
+#include <fs_internal.h>
 #include <zfs_common.h>
 
 static struct blk_desc *zfs_blk_desc;
@@ -25,87 +26,6 @@ void zfs_set_blk_dev(struct blk_desc *rbdd, disk_partition_t *info)
 /* err */
 int zfs_devread(int sector, int byte_offset, int byte_len, char *buf)
 {
-	short sec_buffer[SECTOR_SIZE/sizeof(short)];
-	char *sec_buf = (char *)sec_buffer;
-	unsigned block_len;
-
-	/*
-	 *	Check partition boundaries
-	 */
-	if ((sector < 0) ||
-		((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS)) >=
-		 part_info->size)) {
-		/*		errnum = ERR_OUTSIDE_PART; */
-		printf(" ** zfs_devread() read outside partition sector %d\n", sector);
-		return 1;
-	}
-
-	/*
-	 *	Get the read to the beginning of a partition.
-	 */
-	sector += byte_offset >> SECTOR_BITS;
-	byte_offset &= SECTOR_SIZE - 1;
-
-	debug(" <%d, %d, %d>\n", sector, byte_offset, byte_len);
-
-	if (zfs_blk_desc == NULL) {
-		printf("** Invalid Block Device Descriptor (NULL)\n");
-		return 1;
-	}
-
-	if (byte_offset != 0) {
-		/* read first part which isn't aligned with start of sector */
-		if (zfs_blk_desc->block_read(zfs_blk_desc,
-					     part_info->start + sector, 1,
-					     (void *)sec_buf) != 1) {
-			printf(" ** zfs_devread() read error **\n");
-			return 1;
-		}
-		memcpy(buf, sec_buf + byte_offset,
-			   min(SECTOR_SIZE - byte_offset, byte_len));
-		buf += min(SECTOR_SIZE - byte_offset, byte_len);
-		byte_len -= min(SECTOR_SIZE - byte_offset, byte_len);
-		sector++;
-	}
-
-	if (byte_len == 0)
-		return 0;
-
-	/*	read sector aligned part */
-	block_len = byte_len & ~(SECTOR_SIZE - 1);
-
-	if (block_len == 0) {
-		u8 p[SECTOR_SIZE];
-
-		block_len = SECTOR_SIZE;
-		zfs_blk_desc->block_read(zfs_blk_desc,
-					 part_info->start + sector,
-					 1, (void *)p);
-		memcpy(buf, p, byte_len);
-		return 0;
-	}
-
-	if (zfs_blk_desc->block_read(zfs_blk_desc, part_info->start + sector,
-				     block_len / SECTOR_SIZE,
-				     (void *)buf) != block_len / SECTOR_SIZE) {
-		printf(" ** zfs_devread() read error - block\n");
-		return 1;
-	}
-
-	block_len = byte_len & ~(SECTOR_SIZE - 1);
-	buf += block_len;
-	byte_len -= block_len;
-	sector += block_len / SECTOR_SIZE;
-
-	if (byte_len != 0) {
-		/* read rest of data which are not in whole sector */
-		if (zfs_blk_desc->block_read(zfs_blk_desc,
-					     part_info->start + sector,
-					     1, (void *)sec_buf) != 1) {
-			printf(" ** zfs_devread() read error - last part\n");
-			return 1;
-		}
-		memcpy(buf, sec_buf, byte_len);
-	}
-	return 0;
+	return fs_devread(zfs_blk_desc, part_info, sector, byte_offset,
+			  byte_len, buf);
 }
diff --git a/include/android_image.h b/include/android_image.h
index dfd4d9d72c..8af09984b8 100644
--- a/include/android_image.h
+++ b/include/android_image.h
@@ -1,60 +1,297 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
 /*
  * This is from the Android Project,
- * Repository: https://android.googlesource.com/platform/system/core/
- * File: mkbootimg/bootimg.h
- * Commit: d162828814b08ada310846a33205befb69ef5799
+ * Repository: https://android.googlesource.com/platform/system/tools/mkbootimg
+ * File: include/bootimg/bootimg.h
+ * Commit: e55998a0f2b61b685d5eb4a486ca3a0c680b1a2f
  *
- * Copyright (C) 2008 The Android Open Source Project
- *
- * SPDX-License-Identifier: BSD-2-Clause
+ * Copyright (C) 2007 The Android Open Source Project
  */
 
 #ifndef _ANDROID_IMAGE_H_
 #define _ANDROID_IMAGE_H_
 
-typedef struct andr_img_hdr andr_img_hdr;
+#define ANDROID_PARTITION_BOOT "boot"
+#define ANDROID_PARTITION_VENDOR_BOOT "vendor_boot"
+#define ANDROID_PARTITION_MISC "misc"
+#define ANDROID_PARTITION_OEM  "oem"
+#define ANDROID_PARTITION_RECOVERY  "recovery"
+#define ANDROID_PARTITION_SYSTEM "system"
+#define ANDROID_PARTITION_VBMETA "vbmeta"
+#define ANDROID_PARTITION_SUPER "super"
+
+#define ANDROID_ARG_SLOT_SUFFIX "androidboot.slot_suffix="
+#define ANDROID_ARG_ROOT "root="
+#define ANDROID_ARG_SERIALNO "androidboot.serialno="
+#define ANDROID_VERIFY_STATE "androidboot.verifiedbootstate="
+#ifdef CONFIG_ROCKCHIP_RESOURCE_IMAGE
+#define ANDROID_ARG_FDT_FILENAME "rk-kernel.dtb"
+#else
+#define ANDROID_ARG_FDT_FILENAME "kernel.dtb"
+#endif
+#define OEM_UNLOCK_ARG_SIZE 30
+#define UUID_SIZE 37
 
 #define ANDR_BOOT_MAGIC "ANDROID!"
+#define VENDOR_BOOT_MAGIC "VNDRBOOT"
 #define ANDR_BOOT_MAGIC_SIZE 8
+#define VENDOR_BOOT_MAGIC_SIZE 8
 #define ANDR_BOOT_NAME_SIZE 16
+#define VENDOR_BOOT_NAME_SIZE 16
 #define ANDR_BOOT_ARGS_SIZE 512
 #define ANDR_BOOT_EXTRA_ARGS_SIZE 1024
+#define VENDOR_BOOT_ARGS_SIZE 2048
+#define ANDR_BOOT_IMG_PAGE_SIZE 4096
+#define ANDR_BOOT_IMG_HDR_SIZE (ANDR_BOOT_IMG_PAGE_SIZE)
+#define TOTAL_BOOT_ARGS_SIZE (ANDR_BOOT_ARGS_SIZE + ANDR_BOOT_EXTRA_ARGS_SIZE + \
+                              VENDOR_BOOT_ARGS_SIZE + 1)
+#define VENDOR_BOOT_HDRv3_SIZE	2112
+#define VENDOR_BOOT_HDRv4_SIZE	2124
+
+#define VENDOR_RAMDISK_TYPE_NONE 0
+#define VENDOR_RAMDISK_TYPE_PLATFORM 1
+#define VENDOR_RAMDISK_TYPE_RECOVERY 2
+#define VENDOR_RAMDISK_TYPE_DLKM 3
+#define VENDOR_RAMDISK_NAME_SIZE 32
+#define VENDOR_RAMDISK_TABLE_ENTRY_BOARD_ID_SIZE 16
+
+/* defined by rockchip but not google, it's adjustable */
+#define ANDROID_ADDITION_BOOTCONFIG_PARAMS_MAX_SIZE SZ_8K
+
+/*
+ * It is expected that callers would explicitly specify which version of the
+ * boot image header they need to use.
+ */
+typedef struct andr_img_hdr andr_img_hdr;
 
+/* The bootloader expects the structure of andr_img_hdr with header
+ * version 0 to be as follows: */
 struct andr_img_hdr {
-	char magic[ANDR_BOOT_MAGIC_SIZE];
+    /* Must be ANDR_BOOT_MAGIC. */
+    char magic[ANDR_BOOT_MAGIC_SIZE];
 
-	u32 kernel_size;	/* size in bytes */
-	u32 kernel_addr;	/* physical load addr */
+    u32 kernel_size; /* size in bytes */
+    u32 kernel_addr; /* physical load addr */
 
-	u32 ramdisk_size;	/* size in bytes */
-	u32 ramdisk_addr;	/* physical load addr */
+    u32 ramdisk_size; /* size in bytes */
+    u32 ramdisk_addr; /* physical load addr */
 
-	u32 second_size;	/* size in bytes */
-	u32 second_addr;	/* physical load addr */
+    u32 second_size; /* size in bytes */
+    u32 second_addr; /* physical load addr */
 
-	u32 tags_addr;		/* physical addr for kernel tags */
-	u32 page_size;		/* flash page size we assume */
-	u32 unused;		/* reserved for future expansion: MUST be 0 */
+    u32 tags_addr; /* physical addr for kernel tags */
+    u32 page_size; /* flash page size we assume */
 
-	/* operating system version and security patch level; for
-	 * version "A.B.C" and patch level "Y-M-D":
-	 * ver = A << 14 | B << 7 | C         (7 bits for each of A, B, C)
-	 * lvl = ((Y - 2000) & 127) << 4 | M  (7 bits for Y, 4 bits for M)
-	 * os_version = ver << 11 | lvl */
-	u32 os_version;
+    /* Version of the boot image header. */
+    u32 header_version;
 
-	char name[ANDR_BOOT_NAME_SIZE]; /* asciiz product name */
+    /* Operating system version and security patch level.
+     * For version "A.B.C" and patch level "Y-M-D":
+     *   (7 bits for each of A, B, C; 7 bits for (Y-2000), 4 bits for M)
+     *   os_version = A[31:25] B[24:18] C[17:11] (Y-2000)[10:4] M[3:0] */
+    u32 os_version;
 
-	char cmdline[ANDR_BOOT_ARGS_SIZE];
+    char name[ANDR_BOOT_NAME_SIZE]; /* asciiz product name */
 
-	u32 id[8]; /* timestamp / checksum / sha1 / etc */
+    char cmdline[ANDR_BOOT_ARGS_SIZE];
 
-	/* Supplemental command line data; kept here to maintain
-	 * binary compatibility with older versions of mkbootimg */
-	char extra_cmdline[ANDR_BOOT_EXTRA_ARGS_SIZE];
+    u32 id[8]; /* timestamp / checksum / sha1 / etc */
+
+    /* Supplemental command line data; kept here to maintain
+     * binary compatibility with older versions of mkbootimg. */
+    char extra_cmdline[ANDR_BOOT_EXTRA_ARGS_SIZE];
+
+    /* Fields in boot_img_hdr_v1(Android-9) and newer. */
+    u32 recovery_dtbo_size;   /* size in bytes for recovery DTBO/ACPIO image */
+    u64 recovery_dtbo_offset; /* offset to recovery dtbo/acpio in boot image */
+    u32 header_size;
+
+    /* Fields in boot_img_hdr_v2(Android-10) and newer. */
+    u32 dtb_size; /* size in bytes for DTB image */
+    u64 dtb_addr; /* physical load address for DTB image */
+
+    /*
+     * [Rockchip compatibility Android v3]
+     *
+     * boot_img_hdr_v3(Android-11) is not compatible with boot_img_hdr_v012,
+     * we have to partly merge fields from boot_img_hdr_v34 and vendor_boot_img_hdr_v34
+     * into this structure to compatible with boot_img_hdr_v012.
+     */
+    u32 boot_ramdisk_size;   /* size in bytes */
+    u32 vendor_ramdisk_size; /* size in bytes */
+    u32 vendor_page_size;
+    u32 vendor_header_version;
+    u32 vendor_header_size;
+
+    /*
+     * [Rockchip compatibility Android v4]
+     *
+     * boot_img_hdr_v4(Android-12) is not compatible with boot_img_hdr_v012,
+     * we have to partly merge fields from boot_img_hdr_v34 and vendor_boot_img_hdr_v34
+     * into this structure to compatible with boot_img_hdr_v012.
+     */
+    u32 vendor_ramdisk_table_size;
+    u32 vendor_ramdisk_table_entry_num;
+    u32 vendor_ramdisk_table_entry_size;
+    u32 vendor_bootconfig_size; /* size in bytes for bootconfig image */
+
+    /*
+     * Don't define 'char total_cmdline[TOTAL_BOOT_ARGS_SIZE]' to avoid
+     * this structrue is over size than page_size.
+     */
+    char *total_cmdline;
 } __attribute__((packed));
 
-/*
+struct boot_img_hdr_v34 {
+    /* Must be ANDR_BOOT_MAGIC. */
+    uint8_t magic[ANDR_BOOT_MAGIC_SIZE];
+
+    uint32_t kernel_size; /* size in bytes */
+    uint32_t ramdisk_size; /* size in bytes */
+
+    /* Operating system version and security patch level.
+     * For version "A.B.C" and patch level "Y-M-D":
+     *   (7 bits for each of A, B, C; 7 bits for (Y-2000), 4 bits for M)
+     *   os_version = A[31:25] B[24:18] C[17:11] (Y-2000)[10:4] M[3:0] */
+    uint32_t os_version;
+
+    uint32_t header_size;
+
+    uint32_t reserved[4];
+
+    uint32_t header_version;
+
+    uint8_t cmdline[ANDR_BOOT_ARGS_SIZE + ANDR_BOOT_EXTRA_ARGS_SIZE];
+} __attribute__((packed));
+
+struct vendor_boot_img_hdr_v34 {
+    /* Must be VENDOR_BOOT_MAGIC. */
+    uint8_t magic[VENDOR_BOOT_MAGIC_SIZE];
+
+    /* Version of the vendor boot image header. */
+    uint32_t header_version;
+
+    uint32_t page_size; /* flash page size we assume */
+
+    uint32_t kernel_addr; /* physical load addr */
+    uint32_t ramdisk_addr; /* physical load addr */
+
+    uint32_t vendor_ramdisk_size; /* size in bytes */
+
+    uint8_t cmdline[VENDOR_BOOT_ARGS_SIZE];
+
+    uint32_t tags_addr; /* physical addr for kernel tags (if required) */
+    uint8_t name[VENDOR_BOOT_NAME_SIZE]; /* asciiz product name */
+
+    uint32_t header_size;
+
+    uint32_t dtb_size; /* size in bytes for DTB image */
+    uint64_t dtb_addr; /* physical load address for DTB image */
+
+    /* new for v4 */
+    uint32_t vendor_ramdisk_table_size; /* size in bytes for the vendor ramdisk table */
+    uint32_t vendor_ramdisk_table_entry_num; /* number of entries in the vendor ramdisk table */
+    uint32_t vendor_ramdisk_table_entry_size;
+    uint32_t vendor_bootconfig_size; /* size in bytes for bootconfig image */
+} __attribute__((packed));
+
+struct vendor_ramdisk_table_entry_v4 {
+    uint32_t ramdisk_size; /* size in bytes for the ramdisk image */
+    uint32_t ramdisk_offset; /* offset to the ramdisk image in vendor ramdisk section */
+    uint32_t ramdisk_type; /* type of the ramdisk */
+    uint8_t ramdisk_name[VENDOR_RAMDISK_NAME_SIZE]; /* asciiz ramdisk name */
+
+    // Hardware identifiers describing the board, soc or platform which this
+    // ramdisk is intended to be loaded on.
+    uint32_t board_id[VENDOR_RAMDISK_TABLE_ENTRY_BOARD_ID_SIZE];
+} __attribute__((packed));
+
+/* When the boot image header has a version of 4, the structure of the boot
+ * image is the same as version 3:
+ *
+ * +---------------------+
+ * | boot header         | 4096 bytes
+ * +---------------------+
+ * | kernel              | m pages
+ * +---------------------+
+ * | ramdisk             | n pages
+ * +---------------------+
+ *
+ * m = (kernel_size + 4096 - 1) / 4096
+ * n = (ramdisk_size + 4096 - 1) / 4096
+ *
+ * Note that in version 4 of the boot image header, page size is fixed at 4096
+ * bytes.
+ *
+ * The structure of the vendor boot image version 4, which is required to be
+ * present when a version 4 boot image is used, is as follows:
+ *
+ * +------------------------+
+ * | vendor boot header     | o pages
+ * +------------------------+
+ * | vendor ramdisk section | p pages
+ * +------------------------+
+ * | dtb                    | q pages
+ * +------------------------+
+ * | vendor ramdisk table   | r pages
+ * +------------------------+
+ * | bootconfig             | s pages
+ * +------------------------+
+ *
+ * o = (2124 + page_size - 1) / page_size
+ * p = (vendor_ramdisk_size + page_size - 1) / page_size
+ * q = (dtb_size + page_size - 1) / page_size
+ * r = (vendor_ramdisk_table_size + page_size - 1) / page_size
+ * s = (vendor_bootconfig_size + page_size - 1) / page_size
+ *
+ * Note that in version 4 of the vendor boot image, multiple vendor ramdisks can
+ * be included in the vendor boot image. The bootloader can select a subset of
+ * ramdisks to load at runtime. To help the bootloader select the ramdisks, each
+ * ramdisk is tagged with a type tag and a set of hardware identifiers
+ * describing the board, soc or platform that this ramdisk is intended for.
+ *
+ * The vendor ramdisk section is consist of multiple ramdisk images concatenated
+ * one after another, and vendor_ramdisk_size is the size of the section, which
+ * is the total size of all the ramdisks included in the vendor boot image.
+ *
+ * The vendor ramdisk table holds the size, offset, type, name and hardware
+ * identifiers of each ramdisk. The type field denotes the type of its content.
+ * The hardware identifiers are specified in the board_id field in each table
+ * entry. The board_id field is consist of a vector of unsigned integer words,
+ * and the encoding scheme is defined by the hardware vendor.
+ *
+ * For the different type of ramdisks, there are:
+ *    - VENDOR_RAMDISK_TYPE_NONE indicates the value is unspecified.
+ *    - VENDOR_RAMDISK_TYPE_PLATFORM ramdisk contains platform specific bits.
+ *    - VENDOR_RAMDISK_TYPE_RECOVERY ramdisk contains recovery resources.
+ *    - VENDOR_RAMDISK_TYPE_DLKM ramdisk contains dynamic loadable kernel
+ *      modules.
+ *
+ * Version 4 of the vendor boot image also adds a bootconfig section to the end
+ * of the image. This section contains Boot Configuration parameters known at
+ * build time. The bootloader is responsible for placing this section directly
+ * after the boot image ramdisk, followed by the bootconfig trailer, before
+ * entering the kernel.
+ *
+ * 0. all entities in the boot image are 4096-byte aligned in flash, all
+ *    entities in the vendor boot image are page_size (determined by the vendor
+ *    and specified in the vendor boot image header) aligned in flash
+ * 1. kernel, ramdisk, and DTB are required (size != 0)
+ * 2. load the kernel and DTB at the specified physical address (kernel_addr,
+ *    dtb_addr)
+ * 3. load the vendor ramdisks at ramdisk_addr
+ * 4. load the generic ramdisk immediately following the vendor ramdisk in
+ *    memory
+ * 5. load the vendor bootconfig immediately following the generic ramdisk. Add
+ *    additional bootconfig parameters followed by the bootconfig trailer.
+ * 6. set up registers for kernel entry as required by your architecture
+ * 7. if the platform has a second stage bootloader jump to it (must be
+ *    contained outside boot and vendor boot partitions), otherwise
+ *    jump to kernel_addr
+ *
+ * When a boot header is of version 0, the structure of boot image is as
+ * follows:
+ *
  * +-----------------+
  * | boot header     | 1 page
  * +-----------------+
@@ -80,4 +317,91 @@ struct andr_img_hdr {
  * 6. if second_size != 0: jump to second_addr
  *    else: jump to kernel_addr
  */
+
+/* When the boot image header has a version of 2, the structure of the boot
+ * image is as follows:
+ *
+ * +---------------------+
+ * | boot header         | 1 page
+ * +---------------------+
+ * | kernel              | n pages
+ * +---------------------+
+ * | ramdisk             | m pages
+ * +---------------------+
+ * | second stage        | o pages
+ * +---------------------+
+ * | recovery dtbo/acpio | p pages
+ * +---------------------+
+ * | dtb                 | q pages
+ * +---------------------+
+
+ * n = (kernel_size + page_size - 1) / page_size
+ * m = (ramdisk_size + page_size - 1) / page_size
+ * o = (second_size + page_size - 1) / page_size
+ * p = (recovery_dtbo_size + page_size - 1) / page_size
+ * q = (dtb_size + page_size - 1) / page_size
+ *
+ * 0. all entities are page_size aligned in flash
+ * 1. kernel, ramdisk and DTB are required (size != 0)
+ * 2. recovery_dtbo/recovery_acpio is required for recovery.img in non-A/B
+ *    devices(recovery_dtbo_size != 0)
+ * 3. second is optional (second_size == 0 -> no second)
+ * 4. load each element (kernel, ramdisk, second, dtb) at
+ *    the specified physical address (kernel_addr, etc)
+ * 5. If booting to recovery mode in a non-A/B device, extract recovery
+ *    dtbo/acpio and apply the correct set of overlays on the base device tree
+ *    depending on the hardware/product revision.
+ * 6. prepare tags at tag_addr.  kernel_args[] is
+ *    appended to the kernel commandline in the tags.
+ * 7. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr
+ * 8. if second_size != 0: jump to second_addr
+ *    else: jump to kernel_addr
+ */
+
+/* When the boot image header has a version of 3, the structure of the boot
+ * image is as follows:
+ *
+ * +---------------------+
+ * | boot header         | 4096 bytes
+ * +---------------------+
+ * | kernel              | m pages
+ * +---------------------+
+ * | ramdisk             | n pages
+ * +---------------------+
+ *
+ * m = (kernel_size + 4096 - 1) / 4096
+ * n = (ramdisk_size + 4096 - 1) / 4096
+ *
+ * Note that in version 3 of the boot image header, page size is fixed at 4096 bytes.
+ *
+ * The structure of the vendor boot image (introduced with version 3 and
+ * required to be present when a v3 boot image is used) is as follows:
+ *
+ * +---------------------+
+ * | vendor boot header  | o pages
+ * +---------------------+
+ * | vendor ramdisk      | p pages
+ * +---------------------+
+ * | dtb                 | q pages
+ * +---------------------+
+ *
+ * o = (2112 + page_size - 1) / page_size
+ * p = (vendor_ramdisk_size + page_size - 1) / page_size
+ * q = (dtb_size + page_size - 1) / page_size
+ *
+ * 0. all entities in the boot image are 4096-byte aligned in flash, all
+ *    entities in the vendor boot image are page_size (determined by the vendor
+ *    and specified in the vendor boot image header) aligned in flash
+ * 1. kernel, ramdisk, vendor ramdisk, and DTB are required (size != 0)
+ * 2. load the kernel and DTB at the specified physical address (kernel_addr,
+ *    dtb_addr)
+ * 3. load the vendor ramdisk at ramdisk_addr
+ * 4. load the generic ramdisk immediately following the vendor ramdisk in
+ *    memory
+ * 5. set up registers for kernel entry as required by your architecture
+ * 6. if the platform has a second stage bootloader jump to it (must be
+ *    contained outside boot and vendor boot partitions), otherwise
+ *    jump to kernel_addr
+ */
+
 #endif
diff --git a/include/asm-generic/global_data.h b/include/asm-generic/global_data.h
index 944f58195c..fc73aab3cc 100644
--- a/include/asm-generic/global_data.h
+++ b/include/asm-generic/global_data.h
@@ -24,6 +24,21 @@
 #include <membuff.h>
 #include <linux/list.h>
 
+/* Never change the sequence of members !!! */
+struct pm_ctx {
+	unsigned long sp;
+	phys_addr_t cpu_resume_addr;
+	unsigned long suspend_regs[15];
+};
+
+struct pre_serial {
+	u32 using_pre_serial;
+	u32 enable;
+	u32 id;
+	u32 baudrate;
+	ulong addr;
+};
+
 typedef struct global_data {
 	bd_t *bd;
 	unsigned long flags;
@@ -36,7 +51,7 @@ typedef struct global_data {
 #if defined(CONFIG_LCD) || defined(CONFIG_VIDEO)
 	unsigned long fb_base;		/* Base address of framebuffer mem */
 #endif
-#if defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)
+#if defined(CONFIG_POST)
 	unsigned long post_log_word;	/* Record POST activities */
 	unsigned long post_log_res;	/* success of POST test */
 	unsigned long post_init_f_time;	/* When post_init_f started */
@@ -52,6 +67,7 @@ typedef struct global_data {
 	unsigned long env_valid;	/* Environment valid? enum env_valid */
 
 	unsigned long ram_top;		/* Top address of RAM used by U-Boot */
+	unsigned long ram_top_ext_size;	/* Extend size of RAM top */
 	unsigned long relocaddr;	/* Start address of U-Boot in RAM */
 	phys_size_t ram_size;		/* RAM size */
 	unsigned long mon_len;		/* monitor len */
@@ -68,13 +84,15 @@ typedef struct global_data {
 #ifdef CONFIG_TIMER
 	struct udevice	*timer;		/* Timer instance for Driver Model */
 #endif
-
 	const void *fdt_blob;		/* Our device tree, NULL if none */
 	void *new_fdt;			/* Relocated FDT */
 	unsigned long fdt_size;		/* Space reserved for relocated FDT */
 #ifdef CONFIG_OF_LIVE
 	struct device_node *of_root;
+	struct device_node *of_root_f;  /* U-Boot of-root instance */
 #endif
+	const void *ufdt_blob;		/* Our U-Boot device tree, NULL if none */
+	const void *fdt_blob_kern;	/* Kernel dtb at the tail of u-boot.bin */
 	struct jt_funcs *jt;		/* jump table */
 	char env_buf[32];		/* buffer for env_get() before reloc. */
 #ifdef CONFIG_TRACE
@@ -113,6 +131,22 @@ typedef struct global_data {
 #ifdef CONFIG_BOOTSTAGE
 	struct bootstage_data *bootstage;	/* Bootstage information */
 	struct bootstage_data *new_bootstage;	/* Relocated bootstage info */
+#endif
+	phys_addr_t pm_ctx_phys;
+
+#ifdef CONFIG_BOOTSTAGE_PRINTF_TIMESTAMP
+	int new_line;
+#endif
+	struct pre_serial serial;
+	ulong sys_start_tick;		/* For report system start-up time */
+	int console_evt;		/* Console event, maybe some hotkey  */
+#ifdef CONFIG_LOG
+	int log_drop_count;		/* Number of dropped log messages */
+	int default_log_level;		/* For devices with no filters */
+	struct list_head log_head;	/* List of struct log_device */
+#endif
+#if CONFIG_IS_ENABLED(FIT_ROLLBACK_PROTECT)
+	u32 rollback_index;
 #endif
 } gd_t;
 #endif
@@ -141,5 +175,12 @@ typedef struct global_data {
 #define GD_FLG_RECORD		0x01000	/* Record console		   */
 #define GD_FLG_ENV_DEFAULT	0x02000 /* Default variable flag	   */
 #define GD_FLG_SPL_EARLY_INIT	0x04000 /* Early SPL init is done	   */
+#define GD_FLG_LOG_READY	0x08000 /* Log system is ready for use	   */
+#define GD_FLG_KDTB_READY	0x10000 /* Kernel dtb is ready for use	   */
+
+#ifdef CONFIG_ARCH_ROCKCHIP
+/* BL32 is enabled */
+#define GD_FLG_BL32_ENABLED	0x20000
+#endif
 
 #endif /* __ASM_GENERIC_GBL_DATA_H */
diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h
index daf021b647..1d140ac110 100644
--- a/include/asm-generic/sections.h
+++ b/include/asm-generic/sections.h
@@ -28,6 +28,10 @@ extern char __efi_hello_world_end[];
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
 
+/* .ARM.exidx is sorted, so has to go in its own output section. */
+extern char __exidx_start[], __exidx_end[];
+extern char __extab_start[], __extab_end[];
+
 /* function descriptor handling (if any).  Override
  * in asm/sections.h */
 #ifndef dereference_function_descriptor
diff --git a/include/asm-generic/u-boot.h b/include/asm-generic/u-boot.h
index d3049d81f5..17493cb8b7 100644
--- a/include/asm-generic/u-boot.h
+++ b/include/asm-generic/u-boot.h
@@ -37,7 +37,7 @@ typedef struct bd_info {
 	unsigned long	bi_dsp_freq; /* dsp core frequency */
 	unsigned long	bi_ddr_freq; /* ddr frequency */
 #endif
-#if defined(CONFIG_8xx) || defined(CONFIG_E500) || defined(CONFIG_MPC86xx)
+#if defined(CONFIG_MPC8xx) || defined(CONFIG_E500) || defined(CONFIG_MPC86xx)
 	unsigned long	bi_immr_base;	/* base of IMMR register */
 #endif
 #if defined(CONFIG_M68K)
@@ -86,10 +86,13 @@ typedef struct bd_info {
 
 	ulong	        bi_arch_number;	/* unique id for this board */
 	ulong	        bi_boot_params;	/* where this board expects params */
+
+	/* same as android image header 'os_version' */
+	unsigned int	bi_andr_version;
 #ifdef CONFIG_NR_DRAM_BANKS
 	struct {			/* RAM configuration */
-		phys_addr_t start;
-		phys_size_t size;
+		u64 start;
+		u64 size;
 	} bi_dram[CONFIG_NR_DRAM_BANKS];
 #endif /* CONFIG_NR_DRAM_BANKS */
 } bd_t;
diff --git a/include/backlight.h b/include/backlight.h
index 90e1d981e1..c3e1a9d194 100644
--- a/include/backlight.h
+++ b/include/backlight.h
@@ -16,6 +16,14 @@ struct backlight_ops {
 	 * @return 0 if OK, -ve on error
 	 */
 	int (*enable)(struct udevice *dev);
+
+	/**
+	 * disable() - Disable a backlight
+	 *
+	 * @dev:	Backlight device to disable
+	 * @return 0 if OK, -ve on error
+	 */
+	int (*disable)(struct udevice *dev);
 };
 
 #define backlight_get_ops(dev)	((struct backlight_ops *)(dev)->driver->ops)
@@ -28,4 +36,12 @@ struct backlight_ops {
  */
 int backlight_enable(struct udevice *dev);
 
+/**
+ * backlight_disable() - Disable a backlight
+ *
+ * @dev:	Backlight device to disable
+ * @return 0 if OK, -ve on error
+ */
+int backlight_disable(struct udevice *dev);
+
 #endif
diff --git a/include/blk.h b/include/blk.h
index 27abfddb94..4c7f333717 100644
--- a/include/blk.h
+++ b/include/blk.h
@@ -8,6 +8,8 @@
 #ifndef BLK_H
 #define BLK_H
 
+#include <efi.h>
+
 #ifdef CONFIG_SYS_64BIT_LBA
 typedef uint64_t lbaint_t;
 #define LBAFlength "ll"
@@ -32,14 +34,38 @@ enum if_type {
 	IF_TYPE_HOST,
 	IF_TYPE_SYSTEMACE,
 	IF_TYPE_NVME,
-
+	IF_TYPE_RKNAND,
+	IF_TYPE_SPINAND,
+	IF_TYPE_SPINOR,
+	IF_TYPE_RAMDISK,
+	IF_TYPE_MTD,
 	IF_TYPE_COUNT,			/* Number of interface types */
 };
 
+/* define mtd device devnum */
+#define BLK_MTD_NAND		0
+#define BLK_MTD_SPI_NAND	1
+#define BLK_MTD_SPI_NOR		2
+
 #define BLK_VEN_SIZE		40
 #define BLK_PRD_SIZE		20
 #define BLK_REV_SIZE		8
 
+/* define block device operation flags */
+#define BLK_PRE_RW		BIT(0)	/* Block prepare read & write*/
+#define BLK_MTD_CONT_WRITE	BIT(1)	/* Special for Nand device P/E */
+
+/*
+ * Identifies the partition table type (ie. MBR vs GPT GUID) signature
+ */
+enum sig_type {
+	SIG_TYPE_NONE,
+	SIG_TYPE_MBR,
+	SIG_TYPE_GUID,
+
+	SIG_TYPE_COUNT			/* Number of signature types */
+};
+
 /*
  * With driver model (CONFIG_BLK) this is uclass platform data, accessible
  * with dev_get_uclass_platdata(dev)
@@ -57,6 +83,7 @@ struct blk_desc {
 	unsigned char	hwpart;		/* HW partition, e.g. for eMMC */
 	unsigned char	type;		/* device type */
 	unsigned char	removable;	/* removable device */
+	unsigned char	op_flag;	/* Some special operation flags */
 #ifdef CONFIG_LBA48
 	/* device can use 48bit addr (ATA/ATAPI v7) */
 	unsigned char	lba48;
@@ -67,6 +94,11 @@ struct blk_desc {
 	char		vendor[BLK_VEN_SIZE + 1]; /* device vendor string */
 	char		product[BLK_PRD_SIZE + 1]; /* device product number */
 	char		revision[BLK_REV_SIZE + 1]; /* firmware revision */
+	enum sig_type	sig_type;	/* Partition table signature type */
+	union {
+		uint32_t mbr_sig;	/* MBR integer signature */
+		efi_guid_t guid_sig;	/* GPT GUID Signature */
+	};
 #if CONFIG_IS_ENABLED(BLK)
 	/*
 	 * For now we have a few functions which take struct blk_desc as a
@@ -615,6 +647,16 @@ ulong blk_read_devnum(enum if_type if_type, int devnum, lbaint_t start,
 ulong blk_write_devnum(enum if_type if_type, int devnum, lbaint_t start,
 		       lbaint_t blkcnt, const void *buffer);
 
+/**
+ * blk_erase_devnum() - erase blocks to a device
+ *
+ * @if_type:	Block device type
+ * @devnum:	Device number
+ * @blkcnt:	Number of blocks to erase
+ * @return number of blocks erased, or -ve error number on error
+ */
+ulong blk_erase_devnum(enum if_type if_type, int devnum, lbaint_t start,
+		       lbaint_t blkcnt);
 /**
  * blk_select_hwpart_devnum() - select a hardware partition
  *
@@ -648,4 +690,12 @@ const char *blk_get_if_type_name(enum if_type if_type);
 int blk_common_cmd(int argc, char * const argv[], enum if_type if_type,
 		   int *cur_devnump);
 
+/**
+ * if_typename_to_iftype() - get iftype according to iftype name
+ *
+ * @if_typename: iftype name
+ * @return iftype index
+ */
+enum if_type if_typename_to_iftype(const char *if_typename);
+
 #endif
diff --git a/include/boot_fit.h b/include/boot_fit.h
index b7d2462dd9..e16ae5bafa 100644
--- a/include/boot_fit.h
+++ b/include/boot_fit.h
@@ -5,5 +5,10 @@
  * SPDX-License-Identifier:     GPL-2.0+
  */
 
-int fdt_offset(void *fit);
-void *locate_dtb_in_fit(void *fit);
+/**
+ * locate_dtb_in_fit - Find a DTB matching the board in a FIT image
+ * @fit:	pointer to the FIT image
+ *
+ * @return a pointer to a matching DTB blob if found, NULL otherwise
+ */
+void *locate_dtb_in_fit(const void *fit);
diff --git a/include/bootm.h b/include/bootm.h
index 49813772ce..40f2998a41 100644
--- a/include/bootm.h
+++ b/include/bootm.h
@@ -41,7 +41,7 @@ void lynxkdi_boot(image_header_t *hdr);
 
 boot_os_fn *bootm_os_get_boot_func(int os);
 
-int bootm_host_load_images(const void *fit, int cfg_noffset);
+int bootm_host_load_images(const void *fit, int cfg_noffset, int is_spl);
 
 int boot_selected_os(int argc, char * const argv[], int state,
 		     bootm_headers_t *images, boot_os_fn *boot_fn);
@@ -54,7 +54,9 @@ int bootm_find_images(int flag, int argc, char * const argv[]);
 int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
 		    int states, bootm_headers_t *images, int boot_progress);
 
-void arch_preboot_os(void);
+void arch_preboot_os(uint32_t bootm_state, bootm_headers_t *images);
+
+int board_do_bootm(int argc, char * const argv[]);
 
 /**
  * bootm_decomp_image() - decompress the operating system
diff --git a/include/clk-uclass.h b/include/clk-uclass.h
index e7ea334c60..be784c8c9f 100644
--- a/include/clk-uclass.h
+++ b/include/clk-uclass.h
@@ -77,6 +77,31 @@ struct clk_ops {
 	 * @return new rate, or -ve error code.
 	 */
 	ulong (*set_rate)(struct clk *clk, ulong rate);
+	/**
+	 * clk_get_phase() - Get the phase shift of a clock signal.
+	 *
+	 * @clk:	The clock to manipulate.
+	 * @return the phase shift of a clock node in degrees,
+	 *		otherwise returns -ve error code.
+	 */
+	int (*get_phase)(struct clk *clk);
+
+	/**
+	 * clk_set_rate() - Adjust the phase shift of a clock signal.
+	 *
+	 * @clk:	The clock to manipulate.
+	 * @degrees:	Numberof degrees the signal is shifted.
+	 * @return 0 on success, or -ve error code.
+	 */
+	int (*set_phase)(struct clk *clk, int degrees);
+	/**
+	 * set_parent() - Set current clock parent
+	 *
+	 * @clk:        The clock to manipulate.
+	 * @parent:     New clock parent.
+	 * @return zero on success, or -ve error code.
+	 */
+	int (*set_parent)(struct clk *clk, struct clk *parent);
 	/**
 	 * enable() - Enable a clock.
 	 *
diff --git a/include/clk.h b/include/clk.h
index c5988f78a8..16cbf6db81 100644
--- a/include/clk.h
+++ b/include/clk.h
@@ -60,10 +60,27 @@ struct clk {
 	unsigned long id;
 };
 
+/**
+ * struct clk_bulk - A handle to (allowing control of) a bulk of clocks.
+ *
+ * Clients provide storage for the clock bulk. The content of the structure is
+ * managed solely by the clock API. A clock bulk struct is
+ * initialized by "get"ing the clock bulk struct.
+ * The clock bulk struct is passed to all other bulk clock APIs to apply
+ * the API to all the clock in the bulk struct.
+ *
+ * @clks: An array of clock handles.
+ * @count: The number of clock handles in the clks array.
+ */
+struct clk_bulk {
+	struct clk *clks;
+	unsigned int count;
+};
+
 #if CONFIG_IS_ENABLED(OF_CONTROL) && CONFIG_IS_ENABLED(CLK)
-struct phandle_2_cell;
+struct phandle_1_arg;
 int clk_get_by_index_platdata(struct udevice *dev, int index,
-			      struct phandle_2_cell *cells, struct clk *clk);
+			      struct phandle_1_arg *cells, struct clk *clk);
 
 /**
  * clock_get_by_index - Get/request a clock by integer index.
@@ -82,6 +99,21 @@ int clk_get_by_index_platdata(struct udevice *dev, int index,
  */
 int clk_get_by_index(struct udevice *dev, int index, struct clk *clk);
 
+/**
+ * clock_get_bulk - Get/request all clocks of a device.
+ *
+ * This looks up and requests all clocks of the client device; each device is
+ * assumed to have n clocks associated with it somehow, and this function finds
+ * and requests all of them in a separate structure. The mapping of client
+ * device clock indices to provider clocks may be via device-tree properties,
+ * board-provided mapping tables, or some other mechanism.
+ *
+ * @dev:	The client device.
+ * @bulk	A pointer to a clock bulk struct to initialize.
+ * @return 0 if OK, or a negative error code.
+ */
+int clk_get_bulk(struct udevice *dev, struct clk_bulk *bulk);
+
 /**
  * clock_get_by_name - Get/request a clock by name.
  *
@@ -120,6 +152,11 @@ static inline int clk_get_by_index(struct udevice *dev, int index,
 	return -ENOSYS;
 }
 
+static inline int clk_get_bulk(struct udevice *dev, struct clk_bulk *bulk)
+{
+	return -ENOSYS;
+}
+
 static inline int clk_get_by_name(struct udevice *dev, const char *name,
 			   struct clk *clk)
 {
@@ -130,9 +167,41 @@ static inline int clk_release_all(struct clk *clk, int count)
 {
 	return -ENOSYS;
 }
+#endif
 
+#if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) && \
+	CONFIG_IS_ENABLED(CLK)
+/**
+ * clk_set_defaults - Process 'assigned-{clocks/clock-parents/clock-rates}'
+ *                    properties to configure clocks
+ *
+ * @dev:        A device to process (the ofnode associated with this device
+ *              will be processed).
+ */
+int clk_set_defaults(struct udevice *dev);
+#else
+static inline int clk_set_defaults(struct udevice *dev)
+{
+	return 0;
+}
 #endif
 
+/**
+ * clk_release_bulk() - Disable (turn off)/Free an array of previously
+ * requested clocks in a clock bulk struct.
+ *
+ * For each clock contained in the clock bulk struct, this function will check
+ * if clock has been previously requested and then will disable and free it.
+ *
+ * @clk:	A clock bulk struct that was previously successfully
+ *		requested by clk_get_bulk().
+ * @return zero on success, or -ve error code.
+ */
+static inline int clk_release_bulk(struct clk_bulk *bulk)
+{
+	return clk_release_all(bulk->clks, bulk->count);
+}
+
 /**
  * clk_request - Request a clock by provider-specific ID.
  *
@@ -177,6 +246,37 @@ ulong clk_get_rate(struct clk *clk);
  */
 ulong clk_set_rate(struct clk *clk, ulong rate);
 
+/**
+ * clk_get_phase() - Get the phase shift of a clock signal.
+ *
+ * @clk:	A clock struct that was previously successfully requested by
+ *		clk_request/get_by_*().
+ * @return the phase shift of a clock node in degrees, otherwise returns
+ *		-ve error code.
+ */
+int clk_get_phase(struct clk *clk);
+
+/**
+ * clk_set_rate() - Adjust the phase shift of a clock signal.
+ *
+ * @clk:	A clock struct that was previously successfully requested by
+ *		clk_request/get_by_*().
+ * @degrees:	Numberof degrees the signal is shifted.
+ * @return 0 on success, or -ve error code.
+ */
+int clk_set_phase(struct clk *clk, int degrees);
+
+/**
+ * clk_set_parent() - Set current clock parent.
+ *
+ * @clk:	A clock struct that was previously successfully requested by
+ *		clk_request/get_by_*().
+ * @parent:	A clock struct that was previously successfully requested by
+ *		clk_request/get_by_*().
+ * @return new rate, or -ve error code.
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent);
+
 /**
  * clk_enable() - Enable (turn on) a clock.
  *
@@ -186,6 +286,15 @@ ulong clk_set_rate(struct clk *clk, ulong rate);
  */
 int clk_enable(struct clk *clk);
 
+/**
+ * clk_enable_bulk() - Enable (turn on) all clocks in a clock bulk struct.
+ *
+ * @bulk:	A clock bulk struct that was previously successfully requested
+ *		by clk_get_bulk().
+ * @return zero on success, or -ve error code.
+ */
+int clk_enable_bulk(struct clk_bulk *bulk);
+
 /**
  * clk_disable() - Disable (turn off) a clock.
  *
@@ -195,6 +304,27 @@ int clk_enable(struct clk *clk);
  */
 int clk_disable(struct clk *clk);
 
+/**
+ * clk_disable_bulk() - Disable (turn off) all clocks in a clock bulk struct.
+ *
+ * @bulk:	A clock bulk struct that was previously successfully requested
+ *		by clk_get_bulk().
+ * @return zero on success, or -ve error code.
+ */
+int clk_disable_bulk(struct clk_bulk *bulk);
+
 int soc_clk_dump(void);
 
+int clks_probe(void);
+
+/**
+ * clk_valid() - check if clk is valid
+ *
+ * @clk:	the clock to check
+ * @return true if valid, or false
+ */
+static inline bool clk_valid(struct clk *clk)
+{
+	return !!clk->dev;
+}
 #endif
diff --git a/include/command.h b/include/command.h
index 767cabb3df..681084b9ea 100644
--- a/include/command.h
+++ b/include/command.h
@@ -221,4 +221,14 @@ int board_run_command(const char *cmdline);
 	U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\
 					_usage, _help, NULL)
 
+#ifdef CONFIG_U_BOOT_CMD_ALWAYS
+#define U_BOOT_CMD_ALWAYS(_name, _maxargs, _rep, _cmd, _usage, _help)	\
+	ll_entry_declare(cmd_tbl_t, _name, cmd) =			\
+			{ #_name, _maxargs, _rep, _cmd, _usage,		\
+				_CMD_HELP(_help) _CMD_COMPLETE(NULL) }
+#else
+#define U_BOOT_CMD_ALWAYS(_name, _maxargs, _rep, _cmd, _usage, _help)	\
+		U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)
+#endif
+
 #endif	/* __COMMAND_H */
diff --git a/include/common.h b/include/common.h
index aaed131671..4cbc7b7ae8 100644
--- a/include/common.h
+++ b/include/common.h
@@ -23,17 +23,21 @@ typedef volatile unsigned char	vu_char;
 #include <time.h>
 #include <asm-offsets.h>
 #include <linux/bitops.h>
+#include <linux/bug.h>
 #include <linux/delay.h>
 #include <linux/types.h>
+#include <linux/printk.h>
 #include <linux/string.h>
 #include <linux/stringify.h>
 #include <asm/ptrace.h>
 #include <stdarg.h>
+#include <stdio.h>
 #include <linux/kernel.h>
 
 #include <part.h>
 #include <flash.h>
 #include <image.h>
+#include <stacktrace.h>
 
 /* Bring in printf format macros if inttypes.h is included */
 #define __STDC_FORMAT_MACROS
@@ -42,71 +46,18 @@ typedef volatile unsigned char	vu_char;
 #define CONFIG_SYS_SUPPORT_64BIT_DATA
 #endif
 
-#ifdef DEBUG
-#define _DEBUG	1
-#else
-#define _DEBUG	0
-#endif
+#include <log.h>
 
-#ifdef CONFIG_SPL_BUILD
-#define _SPL_BUILD	1
-#else
-#define _SPL_BUILD	0
+#if (__STDC_VERSION__ >= 201112L) || defined(__cplusplus)
+# undef static_assert
+# define static_assert _Static_assert
 #endif
 
-/* Define this at the top of a file to add a prefix to debug messages */
-#ifndef pr_fmt
-#define pr_fmt(fmt) fmt
-#endif
-
-/*
- * Output a debug text when condition "cond" is met. The "cond" should be
- * computed by a preprocessor in the best case, allowing for the best
- * optimization.
- */
-#define debug_cond(cond, fmt, args...)			\
-	do {						\
-		if (cond)				\
-			printf(pr_fmt(fmt), ##args);	\
-	} while (0)
-
-/* Show a message if DEBUG is defined in a file */
-#define debug(fmt, args...)			\
-	debug_cond(_DEBUG, fmt, ##args)
-
-/* Show a message if not in SPL */
-#define warn_non_spl(fmt, args...)			\
-	debug_cond(!_SPL_BUILD, fmt, ##args)
-
-/*
- * An assertion is run-time check done in debug mode only. If DEBUG is not
- * defined then it is skipped. If DEBUG is defined and the assertion fails,
- * then it calls panic*( which may or may not reset/halt U-Boot (see
- * CONFIG_PANIC_HANG), It is hoped that all failing assertions are found
- * before release, and after release it is hoped that they don't matter. But
- * in any case these failing assertions cannot be fixed with a reset (which
- * may just do the same assertion again).
- */
-void __assert_fail(const char *assertion, const char *file, unsigned line,
-		   const char *function);
-#define assert(x) \
-	({ if (!(x) && _DEBUG) \
-		__assert_fail(#x, __FILE__, __LINE__, __func__); })
-
-#define error(fmt, args...) do {					\
-		printf("ERROR: " pr_fmt(fmt) "\nat %s:%d/%s()\n",	\
-			##args, __FILE__, __LINE__, __func__);		\
-} while (0)
-
-#ifndef BUG
-#define BUG() do { \
-	printf("BUG: failure at %s:%d/%s()!\n", __FILE__, __LINE__, __FUNCTION__); \
-	panic("BUG!"); \
-} while (0)
-#define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)
-#endif /* BUG */
-
+#if !CONFIG_IS_ENABLED(IRQ)
 typedef void (interrupt_handler_t)(void *);
+#else
+typedef void (interrupt_handler_t)(int, void *);
+#endif
 
 #include <asm/u-boot.h> /* boot information for Linux kernel */
 #include <asm/global_data.h>	/* global data used for startup functions */
@@ -152,6 +103,7 @@ int	cpu_init(void);
 
 /* common/main.c */
 void	main_loop	(void);
+void autoboot_command_fail_handle(void);
 int run_command(const char *cmd, int flag);
 int run_command_repeatable(const char *cmd, int flag);
 
@@ -194,6 +146,11 @@ ulong board_init_f_alloc_reserve(ulong top);
  */
 void board_init_f_init_reserve(ulong base);
 
+/*
+ * Board-specific Platform code can init serial earlier if needed
+ */
+__weak int board_init_f_boot_flags(void);
+
 /**
  * arch_setup_gd() - Set up the global_data pointer
  *
@@ -216,6 +173,7 @@ int last_stage_init(void);
 extern ulong monitor_flash_len;
 int mac_read_from_eeprom(void);
 extern u8 __dtb_dt_begin[];	/* embedded device tree blob */
+extern u8 __dtb_dt_spl_begin[];	/* embedded device tree blob for SPL/TPL */
 int set_cpu_clk_info(void);
 int mdm_init(void);
 int print_cpuinfo(void);
@@ -378,6 +336,63 @@ int env_get_yesno(const char *var);
  */
 int env_set(const char *varname, const char *value);
 
+/**
+ * env_update() - update sub value of an environment variable
+ *
+ * This add/append/replace the sub value of an environment variable.
+ *
+ * @varname: Variable to adjust
+ * @valude: Value to append/replace
+ * @ignore: Value to be ignore if in varvalue
+ * @return 0 if OK, 1 on error
+ */
+int env_update_filter(const char *varname, const char *varvalue,
+		      const char *ignore);
+
+/**
+ * env_update_extract_subset() - extract subset value from an environment variable
+ *
+ * This extract subset value from an environment variable
+ *
+ * @varname: Parent Variable where to extract subset value, the subset value
+ *	     will be removed from it.
+ * @subset_varname: Variable to save subset value
+ * @subset_key: Key value to find out subset value
+ * @return 0 if OK, 1 on error
+ */
+int env_update_extract_subset(const char *varname,
+			      const char *subset_varname,
+			      const char *subset_key);
+/**
+ * env_update() - update sub value of an environment variable
+ *
+ * This add/append/replace the sub value of an environment variable.
+ *
+ * @varname: Variable to adjust
+ * @valude: Value to append/replace
+ * @return 0 if OK, 1 on error
+ */
+int env_update(const char *varname, const char *varvalue);
+
+/**
+ * env_exist() - check sub value of an environment variable is exist or not
+ *
+ * @varname: Variable to look up
+ * @value: Value to check
+ * @return posItion of varvalue if exist, otherwise NULL
+ */
+char *env_exist(const char *varname, const char *varvalue);
+
+/**
+ * env_delete() - delete sub value of an environment variable
+ *
+ * @varname: Variable to look up
+ * @value: Item head of value to delete
+ * @complete_match: complete match whole words
+ * @return 0 if ok, 1 on error
+ */
+int env_delete(const char *varname, const char *varvalue, int complete_match);
+
 /**
  * env_set_ulong() - set an environment variable to an integer
  *
@@ -452,19 +467,11 @@ int  eeprom_write (unsigned dev_addr, unsigned offset, uchar *buffer, unsigned c
 #define eeprom_write(dev_addr, offset, buffer, cnt) ((void)-ENOSYS)
 #endif
 
-/*
- * Set this up regardless of board
- * type, to prevent errors.
- */
-#if defined(CONFIG_SPI) || !defined(CONFIG_SYS_I2C_EEPROM_ADDR)
-# define CONFIG_SYS_DEF_EEPROM_ADDR 0
-#else
-#if !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
+#if !defined(CONFIG_ENV_EEPROM_IS_ON_I2C) && defined(CONFIG_SYS_I2C_EEPROM_ADDR)
 # define CONFIG_SYS_DEF_EEPROM_ADDR CONFIG_SYS_I2C_EEPROM_ADDR
 #endif
-#endif /* CONFIG_SPI || !defined(CONFIG_SYS_I2C_EEPROM_ADDR) */
 
-#if defined(CONFIG_SPI)
+#if defined(CONFIG_MPC8XX_SPI)
 extern void spi_init_f (void);
 extern void spi_init_r (void);
 extern ssize_t spi_read	 (uchar *, int, uchar *, int);
@@ -478,6 +485,7 @@ int board_late_init (void);
 int board_postclk_init (void); /* after clocks/timebase, before env/serial */
 int board_early_init_r (void);
 void board_poweroff (void);
+void board_env_fixup(void);
 
 #if defined(CONFIG_SYS_DRAM_TEST)
 int testdram(void);
@@ -529,6 +537,10 @@ int	is_core_valid (unsigned int);
  */
 int arch_cpu_init(void);
 
+int arch_fpga_init(void);
+
+void s_init(void);
+
 int	checkcpu      (void);
 int	checkicache   (void);
 int	checkdcache   (void);
@@ -546,6 +558,7 @@ void smp_kick_all_cpus(void);
 int	serial_init   (void);
 void	serial_setbrg (void);
 void	serial_putc   (const char);
+void	serial_clear  (void);
 void	serial_putc_raw(const char);
 void	serial_puts   (const char *);
 int	serial_getc   (void);
@@ -624,6 +637,7 @@ ulong	usec2ticks    (unsigned long usec);
 ulong	ticks2usec    (unsigned long ticks);
 
 /* lib/gunzip.c */
+int gzip_parse_header(const unsigned char *src, unsigned long len);
 int gunzip(void *, int, unsigned char *, unsigned long *);
 int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
 						int stoponerr, int offset);
@@ -667,8 +681,7 @@ int gzwrite(unsigned char *src, int len,
 	    u64 startoffs,
 	    u64 szexpected);
 
-/* lib/lz4_wrapper.c */
-int ulz4fn(const void *src, size_t srcn, void *dst, size_t *dstn);
+#include <u-boot/lz4.h>
 
 /* lib/qsort.c */
 void qsort(void *base, size_t nmemb, size_t size,
@@ -699,46 +712,6 @@ unsigned int rand_r(unsigned int *seedp);
 /* serial stuff */
 int	serial_printf (const char *fmt, ...)
 		__attribute__ ((format (__printf__, 1, 2)));
-/* stdin */
-int	getc(void);
-int	tstc(void);
-
-/* stdout */
-#if !defined(CONFIG_SPL_BUILD) || \
-	(defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_SERIAL_SUPPORT)) || \
-	(defined(CONFIG_SPL_BUILD) && !defined(CONFIG_TPL_BUILD) && \
-		defined(CONFIG_SPL_SERIAL_SUPPORT))
-void	putc(const char c);
-void	puts(const char *s);
-int	printf(const char *fmt, ...)
-		__attribute__ ((format (__printf__, 1, 2)));
-int	vprintf(const char *fmt, va_list args);
-#else
-#define	putc(...) do { } while (0)
-#define puts(...) do { } while (0)
-#define printf(...) do { } while (0)
-#define vprintf(...) do { } while (0)
-#endif
-
-/* stderr */
-#define eputc(c)		fputc(stderr, c)
-#define eputs(s)		fputs(stderr, s)
-#define eprintf(fmt,args...)	fprintf(stderr,fmt ,##args)
-
-/*
- * FILE based functions (can only be used AFTER relocation!)
- */
-#define stdin		0
-#define stdout		1
-#define stderr		2
-#define MAX_FILES	3
-
-int	fprintf(int file, const char *fmt, ...)
-		__attribute__ ((format (__printf__, 2, 3)));
-void	fputs(int file, const char *s);
-void	fputc(int file, const char c);
-int	ftstc(int file);
-int	fgetc(int file);
 
 /* lib/gzip.c */
 int gzip(void *dst, unsigned long *lenp,
diff --git a/include/config_fallbacks.h b/include/config_fallbacks.h
index 46b7a2a6f2..fffc95adbd 100644
--- a/include/config_fallbacks.h
+++ b/include/config_fallbacks.h
@@ -50,14 +50,17 @@
 	defined(CONFIG_CMD_PART) || \
 	defined(CONFIG_CMD_GPT) || \
 	defined(CONFIG_MMC) || \
+	defined(CONFIG_MTD_BLK) || \
 	defined(CONFIG_NVME) || \
 	defined(CONFIG_SYSTEMACE) || \
-	defined(CONFIG_SANDBOX)
+	defined(CONFIG_SANDBOX)   || \
+	defined(CONFIG_RKFLASH)
 #define HAVE_BLOCK_DEVICE
 #endif
 
 #if (CONFIG_IS_ENABLED(PARTITION_UUIDS) || \
 	CONFIG_IS_ENABLED(EFI_PARTITION) || \
+	CONFIG_IS_ENABLED(EFI_LOADER) || \
 	defined(CONFIG_RANDOM_UUID) || \
 	defined(CONFIG_CMD_UUID) || \
 	defined(CONFIG_BOOTP_PXE)) && \
diff --git a/include/configs/rockchip-common.h b/include/configs/rockchip-common.h
index b3986c28af..fbd629ee4c 100644
--- a/include/configs/rockchip-common.h
+++ b/include/configs/rockchip-common.h
@@ -8,26 +8,107 @@
 #define _ROCKCHIP_COMMON_H_
 #include <linux/sizes.h>
 
+#define COUNTER_FREQUENCY               24000000
+
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK) && !defined(CONFIG_ARM64)
+#undef CONFIG_SYS_ARCH_TIMER
+#else
+#define CONFIG_SYS_ARCH_TIMER
+#endif
+
+#define CONFIG_SYS_HZ_CLOCK	24000000
+
+#define CONFIG_SYS_NS16550_MEM32
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_NR_DRAM_BANKS		2
+#else
+#define CONFIG_NR_DRAM_BANKS		12
+#endif
+
+#define CONFIG_SPL_PAD_TO		8355840
+
 #ifndef CONFIG_SPL_BUILD
 #include <config_distro_defaults.h>
 
-/* First try to boot from SD (index 0), then eMMC (index 1 */
-#ifdef CONFIG_CMD_USB
-#define BOOT_TARGET_DEVICES(func) \
-	func(MMC, mmc, 0) \
-	func(MMC, mmc, 1) \
-	func(USB, usb, 0) \
-	func(PXE, pxe, na) \
-	func(DHCP, dchp, na)
+#ifdef CONFIG_CMD_RKNAND
+#define BOOTENV_SHARED_RKNAND	BOOTENV_SHARED_BLKDEV(rknand)
+#define BOOTENV_DEV_RKNAND		BOOTENV_DEV_BLKDEV
+#define BOOTENV_DEV_NAME_RKNAND	BOOTENV_DEV_NAME_BLKDEV
 #else
-#define BOOT_TARGET_DEVICES(func) \
-	func(MMC, mmc, 0) \
-	func(MMC, mmc, 1) \
-	func(PXE, pxe, na) \
-	func(DHCP, dchp, na)
+#define BOOTENV_SHARED_RKNAND
+#define BOOTENV_DEV_RKNAND \
+	BOOT_TARGET_DEVICES_references_RKNAND_without_CONFIG_CMD_RKNAND
+#define BOOTENV_DEV_NAME_RKNAND \
+	BOOT_TARGET_DEVICES_references_RKNAND_without_CONFIG_CMD_RKNAND
+#endif
+
+#ifdef CONFIG_CMD_MTD_BLK
+#define BOOTENV_SHARED_MTD				\
+	"mtd_boot="					\
+		"if mtd_blk dev ${devnum}; then "	\
+			"setenv devtype mtd; "		\
+			"run scan_dev_for_boot_part; "	\
+		"fi\0"
+#define BOOTENV_DEV_MTD		BOOTENV_DEV_BLKDEV
+#define BOOTENV_DEV_NAME_MTD	BOOTENV_DEV_NAME_BLKDEV
+#else
+#define BOOTENV_SHARED_MTD
+#define BOOTENV_DEV_MTD		\
+	BOOT_TARGET_DEVICES_references_MTD_without_CONFIG_CMD_MTD_BLK
+#define BOOTENV_DEV_NAME_MTD	\
+	BOOT_TARGET_DEVICES_references_MTD_without_CONFIG_CMD_MTD_BLK
+#endif
+
+/* First try to boot from SD (index 1), then eMMC (index 0) */
+#if CONFIG_IS_ENABLED(CMD_MMC)
+	#define BOOT_TARGET_MMC(func) \
+		func(MMC, mmc, 1) \
+		func(MMC, mmc, 0)
+#else
+	#define BOOT_TARGET_MMC(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_MTD_BLK)
+	#define BOOT_TARGET_MTD(func)	\
+		func(MTD, mtd, 2)	\
+		func(MTD, mtd, 1)	\
+		func(MTD, mtd, 0)
+#else
+	#define BOOT_TARGET_MTD(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_RKNAND)
+	#define BOOT_TARGET_RKNAND(func) func(RKNAND, rknand, 0)
+#else
+	#define BOOT_TARGET_RKNAND(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_USB)
+	#define BOOT_TARGET_USB(func) func(USB, usb, 0)
+#else
+	#define BOOT_TARGET_USB(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_PXE)
+	#define BOOT_TARGET_PXE(func) func(PXE, pxe, na)
+#else
+	#define BOOT_TARGET_PXE(func)
 #endif
 
-#define CONFIG_RANDOM_UUID
+#if CONFIG_IS_ENABLED(CMD_DHCP)
+	#define BOOT_TARGET_DHCP(func) func(DHCP, dhcp, na)
+#else
+	#define BOOT_TARGET_DHCP(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func) \
+	BOOT_TARGET_MMC(func) \
+	BOOT_TARGET_MTD(func) \
+	BOOT_TARGET_RKNAND(func) \
+	BOOT_TARGET_USB(func) \
+	BOOT_TARGET_PXE(func) \
+	BOOT_TARGET_DHCP(func)
 
 #ifdef CONFIG_ARM64
 #define ROOT_UUID "B921B045-1DF0-41C3-AF44-4C6F280D3FAE;\0"
@@ -37,29 +118,72 @@
 #define PARTS_DEFAULT \
 	"uuid_disk=${uuid_gpt_disk};" \
 	"name=loader1,start=32K,size=4000K,uuid=${uuid_gpt_loader1};" \
-	"name=reserved1,size=64K,uuid=${uuid_gpt_reserved1};" \
-	"name=reserved2,size=4M,uuid=${uuid_gpt_reserved2};" \
-	"name=loader2,size=4MB,uuid=${uuid_gpt_loader2};" \
-	"name=atf,size=4M,uuid=${uuid_gpt_atf};" \
+	"name=loader2,start=8MB,size=4MB,uuid=${uuid_gpt_loader2};" \
+	"name=trust,size=4M,uuid=${uuid_gpt_atf};" \
 	"name=boot,size=112M,bootable,uuid=${uuid_gpt_boot};" \
 	"name=rootfs,size=-,uuid="ROOT_UUID
 
-#endif
+#define PARTS_RKIMG \
+	"uuid_disk=${uuid_gpt_disk};" \
+	"name=uboot,start=8MB,size=4MB,uuid=${uuid_gpt_loader2};" \
+	"name=trust,size=4M,uuid=${uuid_gpt_atf};" \
+	"name=misc,size=4MB,uuid=${uuid_gpt_misc};" \
+	"name=resource,size=16MB,uuid=${uuid_gpt_resource};" \
+	"name=kernel,size=32M,uuid=${uuid_gpt_kernel};" \
+	"name=boot,size=32M,bootable,uuid=${uuid_gpt_boot};" \
+	"name=recovery,size=32M,uuid=${uuid_gpt_recovery};" \
+	"name=backup,size=112M,uuid=${uuid_gpt_backup};" \
+	"name=cache,size=512M,uuid=${uuid_gpt_cache};" \
+	"name=system,size=2048M,uuid=${uuid_gpt_system};" \
+	"name=metadata,size=16M,uuid=${uuid_gpt_metadata};" \
+	"name=vendor,size=32M,uuid=${uuid_gpt_vendor};" \
+	"name=oem,size=32M,uuid=${uuid_gpt_oem};" \
+	"name=frp,size=512K,uuid=${uuid_gpt_frp};" \
+	"name=security,size=2M,uuid=${uuid_gpt_security};" \
+	"name=userdata,size=-,uuid=${uuid_gpt_userdata};\0"
 
-#if CONFIG_IS_ENABLED(ROCKCHIP_BACK_TO_BROM)
-/* SPL @ 32k for 34k
- * u-boot directly after @ 68k for 400k or so
- * ENV @ 992k
- */
-#define CONFIG_ENV_OFFSET ((1024-32) * 1024)
+#define RKIMG_DET_BOOTDEV \
+	"rkimg_bootdev=" \
+	"if mmc dev 1 && rkimgtest mmc 1; then " \
+		"setenv devtype mmc; setenv devnum 1; echo Boot from SDcard;" \
+	"elif mmc dev 0; then " \
+		"setenv devtype mmc; setenv devnum 0;" \
+	"elif mtd_blk dev 0; then " \
+		"setenv devtype mtd; setenv devnum 0;" \
+	"elif mtd_blk dev 1; then " \
+		"setenv devtype mtd; setenv devnum 1;" \
+	"elif mtd_blk dev 2; then " \
+		"setenv devtype mtd; setenv devnum 2;" \
+	"elif rknand dev 0; then " \
+		"setenv devtype rknand; setenv devnum 0;" \
+	"elif rksfc dev 0; then " \
+		"setenv devtype spinand; setenv devnum 0;" \
+	"elif rksfc dev 1; then " \
+		"setenv devtype spinor; setenv devnum 1;" \
+	"else" \
+		"setenv devtype ramdisk; setenv devnum 0;" \
+	"fi; \0"
+
+#if defined(CONFIG_AVB_VBMETA_PUBLIC_KEY_VALIDATE)
+#define RKIMG_BOOTCOMMAND			\
+	"boot_android ${devtype} ${devnum};"
+#elif defined(CONFIG_FIT_SIGNATURE)
+#define RKIMG_BOOTCOMMAND			\
+	"boot_fit;"
+#elif defined(CONFIG_CMD_BOOT_ANDROID)
+#define RKIMG_BOOTCOMMAND			\
+	"boot_android ${devtype} ${devnum};"	\
+	"boot_fit;"				\
+	"bootrkp;"				\
+	"run distro_bootcmd;"
 #else
-/* SPL @ 32k for ~36k
- * ENV @ 96k
- * u-boot @ 128K
- */
-#define CONFIG_ENV_OFFSET (96 * 1024)
+#define RKIMG_BOOTCOMMAND			\
+	"run distro_bootcmd;"
 #endif
 
+#endif /* CONFIG_SPL_BUILD */
+
 #define CONFIG_DISPLAY_BOARDINFO_LATE
+#define CONFIG_SYS_AUTOLOAD	"no"
 
 #endif /* _ROCKCHIP_COMMON_H_ */
diff --git a/include/console.h b/include/console.h
index cea29ed6dc..61cba6bcfd 100644
--- a/include/console.h
+++ b/include/console.h
@@ -42,6 +42,11 @@ void console_record_reset(void);
  */
 void console_record_reset_enable(void);
 
+/**
+ * console_record_print_purge() - print record data and remove data from buffers
+ */
+void console_record_print_purge(void);
+
 /**
  * console_announce_r() - print a U-Boot console on non-serial consoles
  *
diff --git a/include/debug_uart.h b/include/debug_uart.h
index 6f0b0c5e15..578d000baf 100644
--- a/include/debug_uart.h
+++ b/include/debug_uart.h
@@ -76,6 +76,10 @@ static inline void board_debug_uart_init(void)
  * @ch:		Character to output
  */
 void printch(int ch);
+int debug_uart_getc(void);
+int debug_uart_tstc(void);
+int debug_uart_clrc(void);
+int debug_uart_setbrg(void);
 
 /**
  * printascii() - Output an ASCII string to the debug UART
@@ -105,6 +109,13 @@ void printhex4(uint value);
  */
 void printhex8(uint value);
 
+/**
+ * printdec() - Output a decimalism value
+ *
+ * @value:	Value to output
+ */
+void printdec(uint value);
+
 #ifdef CONFIG_DEBUG_UART_ANNOUNCE
 #define _DEBUG_UART_ANNOUNCE	printascii("<debug_uart> ");
 #else
@@ -138,6 +149,26 @@ void printhex8(uint value);
 	{ \
 		_printch(ch); \
 	} \
+\
+	int debug_uart_getc(void)\
+	{ \
+		return _debug_uart_getc(); \
+	} \
+\
+	int debug_uart_tstc(void)\
+	{ \
+		return _debug_uart_tstc(true); \
+	} \
+\
+	int debug_uart_clrc(void)\
+	{ \
+		return _debug_uart_clrc(); \
+	} \
+\
+	int debug_uart_setbrg(void)\
+	{ \
+		return _debug_uart_setbrg(); \
+	} \
 \
 	void printascii(const char *str) \
 	{ \
@@ -171,6 +202,18 @@ void printhex8(uint value);
 	{ \
 		printhex(value, 8); \
 	} \
+\
+	void printdec(uint value) \
+	{ \
+		if (value > 10) { \
+			printdec(value / 10); \
+			value %= 10; \
+		} else if (value == 10) { \
+			_debug_uart_putc('1'); \
+			value = 0; \
+		} \
+		_debug_uart_putc('0' + value); \
+	} \
 \
 	void debug_uart_init(void) \
 	{ \
diff --git a/include/dfu.h b/include/dfu.h
index 7e322d9d27..506291a49e 100644
--- a/include/dfu.h
+++ b/include/dfu.h
@@ -23,6 +23,7 @@ enum dfu_device_type {
 	DFU_DEV_NAND,
 	DFU_DEV_RAM,
 	DFU_DEV_SF,
+	DFU_DEV_MTD,
 };
 
 enum dfu_layout {
@@ -67,6 +68,17 @@ struct nand_internal_data {
 	unsigned int ubi;
 };
 
+struct mtd_internal_data {
+	/* RAW programming */
+	u64 start;
+	u64 size;
+
+	unsigned int dev;
+	unsigned int part;
+	/* for nand/ubi use */
+	unsigned int ubi;
+};
+
 struct ram_internal_data {
 	void		*start;
 	unsigned int	size;
@@ -108,6 +120,7 @@ struct dfu_entity {
 		struct nand_internal_data nand;
 		struct ram_internal_data ram;
 		struct sf_internal_data sf;
+		struct mtd_internal_data mtd;
 	} data;
 
 	int (*get_medium_size)(struct dfu_entity *dfu, u64 *size);
@@ -214,6 +227,17 @@ static inline int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr,
 }
 #endif
 
+#ifdef CONFIG_DFU_MTD
+extern int dfu_fill_entity_mtd(struct dfu_entity *dfu, char *devstr, char *s);
+#else
+static inline int dfu_fill_entity_mtd(struct dfu_entity *dfu, char *devstr,
+				      char *s)
+{
+	puts("MTD support not available!\n");
+	return -1;
+}
+#endif
+
 #ifdef CONFIG_DFU_NAND
 extern int dfu_fill_entity_nand(struct dfu_entity *dfu, char *devstr, char *s);
 #else
diff --git a/include/dm/device.h b/include/dm/device.h
index 4866f7c002..4d7b2da0de 100644
--- a/include/dm/device.h
+++ b/include/dm/device.h
@@ -18,6 +18,7 @@
 #include <linux/compat.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
+#include <linux/printk.h>
 
 struct driver_info;
 
@@ -61,6 +62,9 @@ struct driver_info;
  */
 #define DM_FLAG_OS_PREPARE		(1 << 10)
 
+/* Device is from kernel dtb */
+#define DM_FLAG_KNRL_DTB		(1 << 31)
+
 /*
  * One or multiple of these flags are passed to device_remove() so that
  * a selective device removal as specified by the remove-stage and the
@@ -879,4 +883,75 @@ static inline void devm_kfree(struct udevice *dev, void *ptr)
 
 #endif /* ! CONFIG_DEVRES */
 
+/*
+ * REVISIT:
+ * remove the following after resolving conflicts with <linux/compat.h>
+ */
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+#ifdef dev_vdbg
+#undef dev_vdbg
+#endif
+#ifdef dev_info
+#undef dev_info
+#endif
+#ifdef dev_err
+#undef dev_err
+#endif
+#ifdef dev_warn
+#undef dev_warn
+#endif
+
+/*
+ * REVISIT:
+ * print device name like Linux
+ */
+#define dev_printk(dev, fmt, ...)				\
+({								\
+	printk(fmt, ##__VA_ARGS__);				\
+})
+
+#define __dev_printk(level, dev, fmt, ...)			\
+({								\
+	if (level < CONFIG_VAL(LOGLEVEL))			\
+		dev_printk(dev, fmt, ##__VA_ARGS__);		\
+})
+
+#define dev_emerg(dev, fmt, ...) \
+	__dev_printk(0, dev, fmt, ##__VA_ARGS__)
+#define dev_alert(dev, fmt, ...) \
+	__dev_printk(1, dev, fmt, ##__VA_ARGS__)
+#define dev_crit(dev, fmt, ...) \
+	__dev_printk(2, dev, fmt, ##__VA_ARGS__)
+#define dev_err(dev, fmt, ...) \
+	__dev_printk(3, dev, fmt, ##__VA_ARGS__)
+#define dev_warn(dev, fmt, ...) \
+	__dev_printk(4, dev, fmt, ##__VA_ARGS__)
+#define dev_notice(dev, fmt, ...) \
+	__dev_printk(5, dev, fmt, ##__VA_ARGS__)
+#define dev_info(dev, fmt, ...) \
+	__dev_printk(6, dev, fmt, ##__VA_ARGS__)
+
+#ifdef DEBUG
+#define dev_dbg(dev, fmt, ...) \
+	__dev_printk(7, dev, fmt, ##__VA_ARGS__)
+#else
+#define dev_dbg(dev, fmt, ...)					\
+({								\
+	if (0)							\
+		__dev_printk(7, dev, fmt, ##__VA_ARGS__);	\
+})
+#endif
+
+#ifdef VERBOSE_DEBUG
+#define dev_vdbg	dev_dbg
+#else
+#define dev_vdbg(dev, fmt, ...)					\
+({								\
+	if (0)							\
+		__dev_printk(7, dev, fmt, ##__VA_ARGS__);	\
+})
+#endif
+
 #endif
diff --git a/include/dm/of_access.h b/include/dm/of_access.h
index c49d287dd6..48baad5ef9 100644
--- a/include/dm/of_access.h
+++ b/include/dm/of_access.h
@@ -219,6 +219,22 @@ struct device_node *of_find_node_by_phandle(phandle handle);
  */
 int of_read_u32(const struct device_node *np, const char *propname, u32 *outp);
 
+/**
+ * of_property_read_u64 - Find and read a 64 bit integer from a property
+ * @np:         device node from which the property value is to be read.
+ * @propname:   name of the property to be searched.
+ * @out_value:  pointer to return value, modified only if return value is 0.
+ *
+ * Search for a property in a device node and read a 64-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64(const struct device_node *np, const char *propname,
+                         u64 *out_value);
+
 /**
  * of_read_u32_array() - Find and read an array of 32 bit integers
  *
@@ -235,6 +251,22 @@ int of_read_u32(const struct device_node *np, const char *propname, u32 *outp);
 int of_read_u32_array(const struct device_node *np, const char *propname,
 		      u32 *out_values, size_t sz);
 
+/**
+ * of_write_u32_array() - Find and write an array of 32 bit integers
+ *
+ * Search for a property in a device node and write 32-bit value(s) to
+ * it.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @values:	pointer to update value, modified only if return value is 0.
+ * @sz:		number of array elements to read
+ * @return 0 on success, -EINVAL if the property does not exist, -ENODATA
+ * if property does not have a value, and -EOVERFLOW is longer than sz.
+ */
+int of_write_u32_array(const struct device_node *np, const char *propname,
+		       u32 *values, size_t sz);
+
 /**
  * of_property_match_string() - Find string in a list and return index
  *
@@ -393,6 +425,22 @@ int of_alias_scan(void);
  */
 int of_alias_get_id(const struct device_node *np, const char *stem);
 
+/**
+ * of_alias_get_dev - Get device_node by given stem and alias id
+ *
+ * Travels the lookup table to get the device_node by given stem and alias id.
+ *
+ * @stem:	Alias stem of the given device_node
+ * @id:         Alias id of the given device_node
+ * @return device_node, if found, else NULL
+ */
+struct device_node *of_alias_get_dev(const char *stem, int id);
+
+/**
+ * of_alias_dump - Dump of alias nodes added in aliases_lookup.
+ */
+struct device_node *of_alias_dump(void);
+
 /**
  * of_get_stdout() - Get node to use for stdout
  *
diff --git a/include/dm/ofnode.h b/include/dm/ofnode.h
index de2769ed53..e3e1d1399c 100644
--- a/include/dm/ofnode.h
+++ b/include/dm/ofnode.h
@@ -45,7 +45,7 @@ struct resource;
  * the DT.
  *
  * @np: Pointer to device node, used for live tree
- * @flat_ptr: Pointer into flat device tree, used for flat tree. Note that this
+ * @of_offset: Pointer into flat device tree, used for flat tree. Note that this
  *	is not a really a pointer to a node: it is an offset value. See above.
  */
 typedef union ofnode_union {
@@ -227,6 +227,16 @@ static inline int ofnode_read_s32(ofnode node, const char *propname,
  */
 int ofnode_read_u32_default(ofnode ref, const char *propname, u32 def);
 
+/**
+ * ofnode_read_u64() - Read a 64-bit integer from a property
+ *
+ * @ref:	valid node reference to read property from
+ * @propname:	name of the property to read from
+ * @outp:	place to put value (if found)
+ * @return 0 if OK, -ve on error
+ */
+int ofnode_read_u64(ofnode node, const char *propname, u64 *outp);
+
 /**
  * ofnode_read_s32_default() - Read a 32-bit integer from a property
  *
@@ -264,6 +274,19 @@ const char *ofnode_read_string(ofnode node, const char *propname);
 int ofnode_read_u32_array(ofnode node, const char *propname,
 			  u32 *out_values, size_t sz);
 
+/**
+ * ofnode_write_u32_array() - Find and write an array of 32 bit integers
+ *
+ * @node:	valid node reference to read property from
+ * @propname:	name of the property to read
+ * @values:	pointer to update value, modified only if return value is 0
+ * @sz:		number of array elements to read
+ * @return 0 on success, -EINVAL if the property does not exist, -ENODATA
+ * if property does not have a value, and -EOVERFLOW is longer than sz.
+ */
+int ofnode_write_u32_array(ofnode node, const char *propname,
+			   u32 *values, size_t sz);
+
 /**
  * ofnode_read_bool() - read a boolean value from a property
  *
@@ -301,6 +324,14 @@ ofnode ofnode_first_subnode(ofnode node);
  */
 ofnode ofnode_next_subnode(ofnode node);
 
+/**
+ * ofnode_get_parent() - get the ofnode's parent (enclosing ofnode)
+ *
+ * @node: valid node to look up
+ * @return ofnode reference of the parent node
+ */
+ofnode ofnode_get_parent(ofnode node);
+
 /**
  * ofnode_get_name() - get the name of a node
  *
@@ -309,6 +340,14 @@ ofnode ofnode_next_subnode(ofnode node);
  */
 const char *ofnode_get_name(ofnode node);
 
+/**
+ * ofnode_get_by_phandle() - get ofnode from phandle
+ *
+ * @phandle:	phandle to look up
+ * @return ofnode reference to the phandle
+ */
+ofnode ofnode_get_by_phandle(uint phandle);
+
 /**
  * ofnode_read_size() - read the size of a property
  *
@@ -628,4 +667,41 @@ int ofnode_read_resource(ofnode node, uint index, struct resource *res);
 int ofnode_read_resource_byname(ofnode node, const char *name,
 				struct resource *res);
 
+/**
+ * ofnode_for_each_subnode() - iterate over all subnodes of a parent
+ *
+ * @node:       child node (ofnode, lvalue)
+ * @parent:     parent node (ofnode)
+ *
+ * This is a wrapper around a for loop and is used like so:
+ *
+ *	ofnode node;
+ *
+ *	ofnode_for_each_subnode(node, parent) {
+ *		Use node
+ *		...
+ *	}
+ *
+ * Note that this is implemented as a macro and @node is used as
+ * iterator in the loop. The parent variable can be a constant or even a
+ * literal.
+ */
+#define ofnode_for_each_subnode(node, parent) \
+	for (node = ofnode_first_subnode(parent); \
+	     ofnode_valid(node); \
+	     node = ofnode_next_subnode(node))
+
+/**
+ * ofnode_translate_address() - Tranlate a device-tree address
+ *
+ * Translate an address from the device-tree into a CPU physical address. This
+ * function walks up the tree and applies the various bus mappings along the
+ * way.
+ *
+ * @ofnode: Device tree node giving the context in which to translate the
+ *          address
+ * @in_addr: pointer to the address to translate
+ * @return the translated address; OF_BAD_ADDR on error
+ */
+u64 ofnode_translate_address(ofnode node, const fdt32_t *in_addr);
 #endif
diff --git a/include/dm/pinctrl.h b/include/dm/pinctrl.h
index 0eb4b924d4..0bcf30d6e6 100644
--- a/include/dm/pinctrl.h
+++ b/include/dm/pinctrl.h
@@ -258,13 +258,6 @@ static inline int pinctrl_generic_set_state(struct udevice *pctldev,
  * @return: 0 on success, or negative error code on failure
  */
 int pinctrl_select_state(struct udevice *dev, const char *statename);
-#else
-static inline int pinctrl_select_state(struct udevice *dev,
-				       const char *statename)
-{
-	return -EINVAL;
-}
-#endif
 
 /**
  * pinctrl_request() - Request a particular pinctrl function
@@ -329,4 +322,51 @@ int pinctrl_decode_pin_config(const void *blob, int node);
 */
 int pinctrl_get_gpio_mux(struct udevice *dev, int banknum, int index);
 
+/**
+ * pinctrl_get_pins_count() - get the total pins count for all GPIOs
+ *
+ * This allows the total pins count for all GPIO to be obtained.
+ *
+ * @dev:	Pinctrl device to use
+ * @return pins count
+*/
+int pinctrl_get_pins_count(struct udevice *dev);
+#else
+static inline int pinctrl_select_state(struct udevice *dev,
+				       const char *statename)
+{
+	return -EINVAL;
+}
+
+static inline int pinctrl_request(struct udevice *dev, int func, int flags)
+{
+	return -EINVAL;
+}
+
+static inline int pinctrl_request_noflags(struct udevice *dev, int func)
+{
+	return -EINVAL;
+}
+
+static inline int pinctrl_get_periph_id(struct udevice *dev, struct udevice *periph)
+{
+	return -EINVAL;
+}
+
+static inline int pinctrl_decode_pin_config(const void *blob, int node)
+{
+	return -EINVAL;
+}
+
+static inline int pinctrl_get_gpio_mux(struct udevice *dev, int banknum, int index)
+{
+	return -EINVAL;
+}
+
+static inline int pinctrl_get_pins_count(struct udevice *dev)
+{
+	return -EINVAL;
+}
+#endif
+
 #endif /* __PINCTRL_H */
diff --git a/include/dm/platdata.h b/include/dm/platdata.h
index 488b2ab0ae..b73aa33093 100644
--- a/include/dm/platdata.h
+++ b/include/dm/platdata.h
@@ -23,7 +23,6 @@
  * @name:	Driver name
  * @platdata:	Driver-specific platform data
  * @platdata_size: Size of platform data structure
- * @flags:	Platform data flags (DM_FLAG_...)
  */
 struct driver_info {
 	const char *name;
diff --git a/include/dm/read.h b/include/dm/read.h
index 49d69c990f..90f086568d 100644
--- a/include/dm/read.h
+++ b/include/dm/read.h
@@ -55,6 +55,16 @@ static inline bool dev_of_valid(struct udevice *dev)
  */
 int dev_read_u32_default(struct udevice *dev, const char *propname, int def);
 
+/**
+ * dev_read_s32_default() - read a signed 32-bit integer from a device's DT property
+ *
+ * @dev:	device to read DT property from
+ * @propname:	name of the property to read from
+ * @def:	default value to return if the property has no value
+ * @return property value, or @def if not found
+ */
+int dev_read_s32_default(struct udevice *dev, const char *propname, int def);
+
 /**
  * dev_read_string() - Read a string from a device's DT property
  *
@@ -112,6 +122,16 @@ fdt_addr_t dev_read_addr_index(struct udevice *dev, int index);
  */
 fdt_addr_t dev_read_addr(struct udevice *dev);
 
+/**
+ * dev_read_addr_ptr() - Get the reg property of a device
+ *                       as a pointer
+ *
+ * @dev: Device to read from
+ *
+ * @return pointer or NULL if not found
+ */
+void *dev_read_addr_ptr(struct udevice *dev);
+
 /**
  * dev_read_addr_size() - get address and size from a device property
  *
@@ -155,6 +175,29 @@ const char *dev_read_name(struct udevice *dev);
 int dev_read_stringlist_search(struct udevice *dev, const char *property,
 			  const char *string);
 
+/**
+ * dev_read_string_index() - obtain an indexed string from a string list
+ *
+ * @dev: device to examine
+ * @propname: name of the property containing the string list
+ * @index: index of the string to return
+ * @out: return location for the string
+ *
+ * @return:
+ *   length of string, if found or -ve error value if not found
+ */
+int dev_read_string_index(struct udevice *dev, const char *propname, int index,
+			  const char **outp);
+
+/**
+ * dev_read_string_count() - find the number of strings in a string list
+ *
+ * @dev: device to examine
+ * @propname: name of the property containing the string list
+ * @return:
+ *   number of strings in the list, or -ve error value if not found
+ */
+int dev_read_string_count(struct udevice *dev, const char *propname);
 /**
  * dev_read_phandle_with_args() - Find a node pointed by phandle in a list
  *
@@ -308,6 +351,25 @@ int dev_read_alias_seq(struct udevice *dev, int *devnump);
 int dev_read_u32_array(struct udevice *dev, const char *propname,
 		       u32 *out_values, size_t sz);
 
+/**
+ * dev_write_u32_array() - Find and write an array of 32 bit integers
+ *
+ * Search for a property in a device node and write 32-bit value(s) to
+ * it.
+ *
+ * The out_values is modified only if a valid u32 value can be decoded.
+ *
+ * @dev: device to look up
+ * @propname:	name of the property to read
+ * @values:	pointer to update value, modified only if return value is 0
+ * @sz:		number of array elements to read
+ * @return 0 on success, -EINVAL if the property does not exist, -ENODATA if
+ * property does not have a value, and -EOVERFLOW if the property data isn't
+ * large enough.
+ */
+int dev_write_u32_array(struct udevice *dev, const char *propname,
+			u32 *values, size_t sz);
+
 /**
  * dev_read_first_subnode() - find the first subnode of a device's node
  *
@@ -377,6 +439,18 @@ int dev_read_resource(struct udevice *dev, uint index, struct resource *res);
 int dev_read_resource_byname(struct udevice *dev, const char *name,
 			     struct resource *res);
 
+/**
+ * dev_translate_address() - Tranlate a device-tree address
+ *
+ * Translate an address from the device-tree into a CPU physical address.  This
+ * function walks up the tree and applies the various bus mappings along the
+ * way.
+ *
+ * @dev: device giving the context in which to translate the address
+ * @in_addr: pointer to the address to translate
+ * @return the translated address; OF_BAD_ADDR on error
+ */
+u64 dev_translate_address(struct udevice *dev, const fdt32_t *in_addr);
 #else /* CONFIG_DM_DEV_READ_INLINE is enabled */
 
 static inline int dev_read_u32_default(struct udevice *dev,
@@ -417,6 +491,11 @@ static inline fdt_addr_t dev_read_addr(struct udevice *dev)
 	return devfdt_get_addr(dev);
 }
 
+static inline void *dev_read_addr_ptr(struct udevice *dev)
+{
+	return devfdt_get_addr_ptr(dev);
+}
+
 static inline fdt_addr_t dev_read_addr_size(struct udevice *dev,
 					    const char *propname,
 					    fdt_size_t *sizep)
@@ -426,6 +505,8 @@ static inline fdt_addr_t dev_read_addr_size(struct udevice *dev,
 
 static inline const char *dev_read_name(struct udevice *dev)
 {
+	if (!dev_of_valid(dev))
+		return NULL;
 	return ofnode_get_name(dev_ofnode(dev));
 }
 
@@ -436,6 +517,19 @@ static inline int dev_read_stringlist_search(struct udevice *dev,
 	return ofnode_stringlist_search(dev_ofnode(dev), propname, string);
 }
 
+static inline int dev_read_string_index(struct udevice *dev,
+					const char *propname, int index,
+					const char **outp)
+{
+	return ofnode_read_string_index(dev_ofnode(dev), propname, index, outp);
+}
+
+static inline int dev_read_string_count(struct udevice *dev,
+					const char *propname)
+{
+	return ofnode_read_string_count(dev_ofnode(dev), propname);
+}
+
 static inline int dev_read_phandle_with_args(struct udevice *dev,
 		const char *list_name, const char *cells_name, int cell_count,
 		int index, struct ofnode_phandle_args *out_args)
@@ -494,6 +588,8 @@ static inline int dev_read_alias_seq(struct udevice *dev, int *devnump)
 static inline int dev_read_u32_array(struct udevice *dev, const char *propname,
 				     u32 *out_values, size_t sz)
 {
+	if (!dev_of_valid(dev))
+		return -EINVAL;
 	return ofnode_read_u32_array(dev_ofnode(dev), propname, out_values, sz);
 }
 
@@ -531,6 +627,11 @@ static inline int dev_read_resource_byname(struct udevice *dev,
 	return ofnode_read_resource_byname(dev_ofnode(dev), name, res);
 }
 
+static inline u64 dev_translate_address(struct udevice *dev, const fdt32_t *in_addr)
+{
+	return ofnode_translate_address(dev_ofnode(dev), in_addr);
+}
+
 #endif /* CONFIG_DM_DEV_READ_INLINE */
 
 /**
diff --git a/include/dm/root.h b/include/dm/root.h
index 50a6011644..b075eef2c1 100644
--- a/include/dm/root.h
+++ b/include/dm/root.h
@@ -55,6 +55,20 @@ int dm_scan_platdata(bool pre_reloc_only);
  */
 int dm_scan_fdt(const void *blob, bool pre_reloc_only);
 
+/**
+ * dm_extended_scan_fdt() - Scan the device tree and bind drivers
+ *
+ * This calls dm_scna_dft() which scans the device tree and creates a driver
+ * for each node. the top-level subnodes are examined and also all sub-nodes
+ * of "clocks" node.
+ *
+ * @blob: Pointer to device tree blob
+ * @pre_reloc_only: If true, bind only drivers with the DM_FLAG_PRE_RELOC
+ * flag. If false bind all drivers.
+ * @return 0 if OK, -ve on error
+ */
+int dm_extended_scan_fdt(const void *blob, bool pre_reloc_only);
+
 /**
  * dm_scan_other() - Scan for other devices
  *
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index 3fc20834ae..b4c0c645c8 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -31,6 +31,8 @@ enum uclass_id {
 	UCLASS_BLK,		/* Block device */
 	UCLASS_CLK,		/* Clock source, e.g. used by peripherals */
 	UCLASS_CPU,		/* CPU, typically part of an SoC */
+	UCLASS_AMP,		/* Asymmetric Multi-Processing */
+	UCLASS_CODEC,		/* audio codec */
 	UCLASS_CROS_EC,		/* Chrome OS EC */
 	UCLASS_DISPLAY,		/* Display (e.g. DisplayPort, HDMI) */
 	UCLASS_DMA,		/* Direct Memory Access */
@@ -41,6 +43,7 @@ enum uclass_id {
 	UCLASS_I2C_EEPROM,	/* I2C EEPROM device */
 	UCLASS_I2C_GENERIC,	/* Generic I2C device */
 	UCLASS_I2C_MUX,		/* I2C multiplexer */
+	UCLASS_I2S,		/* I2S bus */
 	UCLASS_IDE,		/* IDE device */
 	UCLASS_IRQ,		/* Interrupt controller */
 	UCLASS_KEYBOARD,	/* Keyboard input device */
@@ -52,6 +55,7 @@ enum uclass_id {
 	UCLASS_MMC,		/* SD / MMC card or chip */
 	UCLASS_MOD_EXP,		/* RSA Mod Exp device */
 	UCLASS_MTD,		/* Memory Technology Device (MTD) device */
+	UCLASS_NOP,		/* No-op devices */
 	UCLASS_NORTHBRIDGE,	/* Intel Northbridge / SDRAM controller */
 	UCLASS_NVME,		/* NVM Express device */
 	UCLASS_PANEL,		/* Display panel, such as an LCD */
@@ -70,7 +74,10 @@ enum uclass_id {
 	UCLASS_REGULATOR,	/* Regulator device */
 	UCLASS_REMOTEPROC,	/* Remote Processor device */
 	UCLASS_RESET,		/* Reset controller device */
+	UCLASS_RKNAND,		/* Rockchip nand device with ftl */
+	UCLASS_RAMDISK,		/* Virtual ram disk */
 	UCLASS_RTC,		/* Real time clock device */
+	UCLASS_SCMI_AGENT,	/* Interface with an SCMI server */
 	UCLASS_SCSI,		/* SCSI device */
 	UCLASS_SERIAL,		/* Serial UART */
 	UCLASS_SPI,		/* SPI bus */
@@ -85,11 +92,27 @@ enum uclass_id {
 	UCLASS_USB,		/* USB bus */
 	UCLASS_USB_DEV_GENERIC,	/* USB generic device */
 	UCLASS_USB_HUB,		/* USB hub */
+	UCLASS_USB_GADGET_GENERIC,	/* USB generic device */
 	UCLASS_VIDEO,		/* Video or LCD device */
 	UCLASS_VIDEO_BRIDGE,	/* Video bridge, e.g. DisplayPort to LVDS */
 	UCLASS_VIDEO_CONSOLE,	/* Text console driver for video device */
+	UCLASS_VIDEO_CRTC,	/* Display Controller */
 	UCLASS_WDT,		/* Watchdot Timer driver */
 
+	UCLASS_FG,		/* Fuel gauge */
+	UCLASS_KEY,		/* Key */
+	UCLASS_RC,		/* Remote Controller */
+	UCLASS_CHARGE_DISPLAY,	/* Charge display */
+	UCLASS_DVFS,		/* DVFS policy */
+	UCLASS_IO_DOMAIN,	/* IO domain */
+	UCLASS_CRYPTO,		/* Crypto */
+	UCLASS_ETH_PHY,		/* Ethernet PHY device */
+	UCLASS_MDIO,		/* MDIO bus */
+	UCLASS_EBC,		/* EBC Controller for eink screen */
+	UCLASS_EINK_DISPLAY,	/* EINK screen display driver */
+	UCLASS_RNG,		/* Random Number Generator */
+	UCLASS_DMC,		/* Dynamic Memory Interface */
+	UCLASS_PD,		/* power delivery */
 	UCLASS_COUNT,
 	UCLASS_INVALID = -1,
 };
diff --git a/include/dm/uclass-internal.h b/include/dm/uclass-internal.h
index c086004318..5774fbb6fb 100644
--- a/include/dm/uclass-internal.h
+++ b/include/dm/uclass-internal.h
@@ -140,7 +140,7 @@ int uclass_find_device_by_ofnode(enum uclass_id id, ofnode node,
  * @dev:	Pointer to the device
  * #return 0 on success, -ve on error
  */
-int uclass_bind_device(struct udevice *dev);
+int uclass_bind_device(struct udevice *dev, bool after_u_boot_dev);
 
 /**
  * uclass_unbind_device() - Deassociate device with a uclass
diff --git a/include/dm/uclass.h b/include/dm/uclass.h
index 18188497c2..aafeb80c2c 100644
--- a/include/dm/uclass.h
+++ b/include/dm/uclass.h
@@ -37,6 +37,9 @@ struct uclass {
 	struct uclass_driver *uc_drv;
 	struct list_head dev_head;
 	struct list_head sibling_node;
+#ifdef CONFIG_USING_KERNEL_DTB_V2
+	struct list_head *u_boot_dev_head;
+#endif
 };
 
 struct driver;
@@ -127,6 +130,14 @@ int uclass_get(enum uclass_id key, struct uclass **ucp);
  */
 const char *uclass_get_name(enum uclass_id id);
 
+/**
+ * uclass_get_by_name() - Look up a uclass by its driver name
+ *
+ * @name: Name to look up
+ * @returns the associated uclass ID, or UCLASS_INVALID if not found
+ */
+enum uclass_id uclass_get_by_name(const char *name);
+
 /**
  * uclass_get_device() - Get a uclass device based on an ID and index
  *
@@ -202,6 +213,22 @@ int uclass_get_device_by_of_offset(enum uclass_id id, int node,
 int uclass_get_device_by_ofnode(enum uclass_id id, ofnode node,
 				struct udevice **devp);
 
+/**
+ * uclass_get_device_by_phandle_id() - Get a uclass device by phandle id
+ *
+ * This searches the devices in the uclass for one with the given phandle id.
+ *
+ * The device is probed to activate it ready for use.
+ *
+ * @id: uclass ID to look up
+ * @phandle_id: the phandle id to look up
+ * @devp: Returns pointer to device (there is only one for each node)
+ * @return 0 if OK, -ENODEV if there is no device match the phandle, other
+ *	-ve on error
+ */
+int uclass_get_device_by_phandle_id(enum uclass_id id, uint phandle_id,
+				    struct udevice **devp);
+
 /**
  * uclass_get_device_by_phandle() - Get a uclass device by phandle
  *
diff --git a/include/dm/util.h b/include/dm/util.h
index 45529ce0e6..0d4ce8f4e6 100644
--- a/include/dm/util.h
+++ b/include/dm/util.h
@@ -15,14 +15,6 @@ static inline void dm_warn(const char *fmt, ...)
 }
 #endif
 
-#ifdef DEBUG
-void dm_dbg(const char *fmt, ...);
-#else
-static inline void dm_dbg(const char *fmt, ...)
-{
-}
-#endif
-
 struct list_head;
 
 /**
diff --git a/include/dt-bindings/clock/rk3036-cru.h b/include/dt-bindings/clock/rk3036-cru.h
index 87acf4af7f..7ac691e09d 100644
--- a/include/dt-bindings/clock/rk3036-cru.h
+++ b/include/dt-bindings/clock/rk3036-cru.h
@@ -82,6 +82,7 @@
 #define HCLK_OTG0		449
 #define HCLK_OTG1		450
 #define HCLK_NANDC		453
+#define HCLK_SFC		454
 #define HCLK_SDMMC		456
 #define HCLK_SDIO		457
 #define HCLK_EMMC		459
diff --git a/include/dt-bindings/clock/rk3228-cru.h b/include/dt-bindings/clock/rk3228-cru.h
index 13f9c864ca..9e5e7273e5 100644
--- a/include/dt-bindings/clock/rk3228-cru.h
+++ b/include/dt-bindings/clock/rk3228-cru.h
@@ -40,6 +40,7 @@
 #define SCLK_EMMC_DRV		117
 #define SCLK_SDMMC_SAMPLE	118
 #define SCLK_SDIO_SAMPLE	119
+#define SCLK_SDIO_SRC		120
 #define SCLK_EMMC_SAMPLE	121
 #define SCLK_VOP		122
 #define SCLK_HDMI_HDCP		123
@@ -52,22 +53,52 @@
 #define SCLK_MAC_TX		130
 #define SCLK_MAC_PHY		131
 #define SCLK_MAC_OUT		132
+#define SCLK_VDEC_CABAC		133
+#define SCLK_VDEC_CORE		134
+#define SCLK_RGA		135
+#define SCLK_HDCP		136
+#define SCLK_HDMI_CEC		137
+#define SCLK_CRYPTO		138
+#define SCLK_TSP		139
+#define SCLK_HSADC		140
+#define SCLK_WIFI		141
+#define SCLK_OTGPHY0		142
+#define SCLK_OTGPHY1		143
+#define SCLK_DDRC		144
 
 /* dclk gates */
 #define DCLK_VOP		190
 #define DCLK_HDMI_PHY		191
+#define HDMIPHY			192
 
 /* aclk gates */
 #define ACLK_DMAC		194
+#define ACLK_CPU		195
+#define ACLK_VPU_PRE		196
+#define ACLK_RKVDEC_PRE		197
+#define ACLK_RGA_PRE		198
+#define ACLK_IEP_PRE		199
+#define ACLK_HDCP_PRE		200
+#define ACLK_VOP_PRE		201
+#define ACLK_VPU		202
+#define ACLK_RKVDEC		203
+#define ACLK_IEP		204
+#define ACLK_RGA		205
+#define ACLK_HDCP		206
 #define ACLK_PERI		210
 #define ACLK_VOP		211
 #define ACLK_GMAC		212
+#define ACLK_GPU		213
 
 /* pclk gates */
 #define PCLK_GPIO0		320
 #define PCLK_GPIO1		321
 #define PCLK_GPIO2		322
 #define PCLK_GPIO3		323
+#define PCLK_VIO_H2P		324
+#define PCLK_HDCP		325
+#define PCLK_EFUSE_1024		326
+#define PCLK_EFUSE_256		327
 #define PCLK_GRF		329
 #define PCLK_I2C0		332
 #define PCLK_I2C1		333
@@ -80,10 +111,12 @@
 #define PCLK_TSADC		344
 #define PCLK_PWM		350
 #define PCLK_TIMER		353
+#define PCLK_CPU		354
 #define PCLK_PERI		363
 #define PCLK_HDMI_CTRL		364
 #define PCLK_HDMI_PHY		365
 #define PCLK_GMAC		367
+#define PCLK_ACODECPHY		368
 
 /* hclk gates */
 #define HCLK_I2S0_8CH		442
@@ -95,6 +128,24 @@
 #define HCLK_SDMMC		456
 #define HCLK_SDIO		457
 #define HCLK_EMMC		459
+#define HCLK_CPU		460
+#define HCLK_VPU_PRE		461
+#define HCLK_RKVDEC_PRE		462
+#define HCLK_VIO_PRE		463
+#define HCLK_VPU		464
+#define HCLK_RKVDEC		465
+#define HCLK_VIO		466
+#define HCLK_RGA		467
+#define HCLK_IEP		468
+#define HCLK_VIO_H2P		469
+#define HCLK_HDCP_MMU		470
+#define HCLK_HOST0		471
+#define HCLK_HOST1		472
+#define HCLK_HOST2		473
+#define HCLK_OTG		474
+#define HCLK_TSP		475
+#define HCLK_M_CRYPTO		476
+#define HCLK_S_CRYPTO		477
 #define HCLK_PERI		478
 
 #define CLK_NR_CLKS		(HCLK_PERI + 1)
diff --git a/include/dt-bindings/clock/rk3288-cru.h b/include/dt-bindings/clock/rk3288-cru.h
index 216eee5b59..f7a5e2eb5a 100644
--- a/include/dt-bindings/clock/rk3288-cru.h
+++ b/include/dt-bindings/clock/rk3288-cru.h
@@ -75,9 +75,22 @@
 #define SCLK_USBPHY480M_SRC	122
 #define SCLK_PVTM_CORE		123
 #define SCLK_PVTM_GPU		124
+#define SCLK_CRYPTO		125
+#define SCLK_MIPIDSI_24M	126
+#define SCLK_VIP_OUT		127
+#define SCLK_DDRCLK		128
+#define SCLK_I2S_SRC		129
+#define SCLK_TSPOUT		130
+#define SCLK_TSP		131
+#define SCLK_HSADC0_TSP		132
+#define SCLK_HSADC1_TSP		133
+#define SCLK_27M_TSP		134
 
+#define SCLK_MAC_PLL		150
 #define SCLK_MAC		151
 #define SCLK_MACREF_OUT		152
+#define SCLK_TESTOUT_SRC	153
+#define SCLK_TESTOUT		154
 
 #define DCLK_VOP0		190
 #define DCLK_VOP1		191
@@ -102,6 +115,8 @@
 #define ACLK_VCODEC		208
 #define ACLK_CPU		209
 #define ACLK_PERI		210
+#define ACLK_VIO0		211
+#define ACLK_VIO1		212
 
 /* pclk gates */
 #define PCLK_GPIO0		320
@@ -153,6 +168,13 @@
 #define PCLK_DDRUPCTL1		366
 #define PCLK_PUBL1		367
 #define PCLK_WDT		368
+#define PCLK_EFUSE256		369
+#define PCLK_EFUSE1024		370
+#define PCLK_ISP_IN		371
+#define PCLK_VIP		372
+#define PCLK_VIP_IN		373
+#define PCLK_PD_ALIVE		374
+#define PCLK_PD_PMU		375
 
 /* hclk gates */
 #define HCLK_GPS		448
@@ -186,8 +208,10 @@
 #define HCLK_VCODEC		476
 #define HCLK_CPU		477
 #define HCLK_PERI		478
+#define HCLK_USB_PERI		479
+#define HCLK_VIO		480
 
-#define CLK_NR_CLKS		(HCLK_PERI + 1)
+#define CLK_NR_CLKS		(HCLK_VIO + 1)
 
 /* soft-reset indices */
 #define SRST_CORE0		0
diff --git a/include/dt-bindings/clock/rk3328-cru.h b/include/dt-bindings/clock/rk3328-cru.h
index 6d8bf1330b..9d56d93e32 100644
--- a/include/dt-bindings/clock/rk3328-cru.h
+++ b/include/dt-bindings/clock/rk3328-cru.h
@@ -86,124 +86,123 @@
 #define SCLK_USB3OTG_SUSPEND	97
 #define SCLK_REF_USB3OTG_SRC	98
 #define SCLK_MAC2IO_SRC		99
+#define SCLK_MAC2IO		100
+#define SCLK_MAC2PHY		101
+#define SCLK_MAC2IO_EXT		102
 
 /* dclk gates */
-#define DCLK_LCDC		180
-#define DCLK_HDMIPHY		181
-#define HDMIPHY			182
-#define USB480M			183
-#define DCLK_LCDC_SRC		184
+#define DCLK_LCDC		120
+#define DCLK_HDMIPHY		121
+#define HDMIPHY			122
+#define USB480M			123
+#define DCLK_LCDC_SRC		124
 
 /* aclk gates */
-#define ACLK_AXISRAM		190
-#define ACLK_VOP_PRE		191
-#define ACLK_USB3OTG		192
-#define ACLK_RGA_PRE		193
-#define ACLK_DMAC		194
-#define ACLK_GPU		195
-#define ACLK_BUS_PRE		196
-#define ACLK_PERI_PRE		197
-#define ACLK_RKVDEC_PRE		198
-#define ACLK_RKVDEC		199
-#define ACLK_RKVENC		200
-#define ACLK_VPU_PRE		201
-#define ACLK_VIO_PRE		202
-#define ACLK_VPU		203
-#define ACLK_VIO		204
-#define ACLK_VOP		205
-#define ACLK_GMAC		206
-#define ACLK_H265		207
-#define ACLK_H264		208
-#define ACLK_MAC2PHY		209
-#define ACLK_MAC2IO		210
-#define ACLK_DCF		211
-#define ACLK_TSP		212
-#define ACLK_PERI		213
-#define ACLK_RGA		214
-#define ACLK_IEP		215
-#define ACLK_CIF		216
-#define ACLK_HDCP		217
+#define ACLK_AXISRAM		130
+#define ACLK_VOP_PRE		131
+#define ACLK_USB3OTG		132
+#define ACLK_RGA_PRE		133
+#define ACLK_DMAC		134
+#define ACLK_GPU		135
+#define ACLK_BUS_PRE		136
+#define ACLK_PERI_PRE		137
+#define ACLK_RKVDEC_PRE		138
+#define ACLK_RKVDEC		139
+#define ACLK_RKVENC		140
+#define ACLK_VPU_PRE		141
+#define ACLK_VIO_PRE		142
+#define ACLK_VPU		143
+#define ACLK_VIO		144
+#define ACLK_VOP		145
+#define ACLK_GMAC		146
+#define ACLK_H265		147
+#define ACLK_H264		148
+#define ACLK_MAC2PHY		149
+#define ACLK_MAC2IO		150
+#define ACLK_DCF		151
+#define ACLK_TSP		152
+#define ACLK_PERI		153
+#define ACLK_RGA		154
+#define ACLK_IEP		155
+#define ACLK_CIF		156
+#define ACLK_HDCP		157
 
 /* pclk gates */
-#define PCLK_GPIO0		300
-#define PCLK_GPIO1		301
-#define PCLK_GPIO2		302
-#define PCLK_GPIO3		303
-#define PCLK_GRF		304
-#define PCLK_I2C0		305
-#define PCLK_I2C1		306
-#define PCLK_I2C2		307
-#define PCLK_I2C3		308
-#define PCLK_SPI		309
-#define PCLK_UART0		310
-#define PCLK_UART1		311
-#define PCLK_UART2		312
-#define PCLK_TSADC		313
-#define PCLK_PWM		314
-#define PCLK_TIMER		315
-#define PCLK_BUS_PRE		316
-#define PCLK_PERI_PRE		317
-#define PCLK_HDMI_CTRL		318
-#define PCLK_HDMI_PHY		319
-#define PCLK_GMAC		320
-#define PCLK_H265		321
-#define PCLK_MAC2PHY		322
-#define PCLK_MAC2IO		323
-#define PCLK_USB3PHY_OTG	324
-#define PCLK_USB3PHY_PIPE	325
-#define PCLK_USB3_GRF		326
-#define PCLK_USB2_GRF		327
-#define PCLK_HDMIPHY		328
-#define PCLK_DDR		329
-#define PCLK_PERI		330
-#define PCLK_HDMI		331
-#define PCLK_HDCP		332
-#define PCLK_DCF		333
-#define PCLK_SARADC		334
+#define PCLK_GPIO0		200
+#define PCLK_GPIO1		201
+#define PCLK_GPIO2		202
+#define PCLK_GPIO3		203
+#define PCLK_GRF		204
+#define PCLK_I2C0		205
+#define PCLK_I2C1		206
+#define PCLK_I2C2		207
+#define PCLK_I2C3		208
+#define PCLK_SPI		209
+#define PCLK_UART0		210
+#define PCLK_UART1		211
+#define PCLK_UART2		212
+#define PCLK_TSADC		213
+#define PCLK_PWM		214
+#define PCLK_TIMER		215
+#define PCLK_BUS_PRE		216
+#define PCLK_PERI_PRE		217
+#define PCLK_HDMI_CTRL		218
+#define PCLK_HDMI_PHY		219
+#define PCLK_GMAC		220
+#define PCLK_H265		221
+#define PCLK_MAC2PHY		222
+#define PCLK_MAC2IO		223
+#define PCLK_USB3PHY_OTG	224
+#define PCLK_USB3PHY_PIPE	225
+#define PCLK_USB3_GRF		226
+#define PCLK_USB2_GRF		227
+#define PCLK_HDMIPHY		228
+#define PCLK_DDR		229
+#define PCLK_PERI		230
+#define PCLK_HDMI		231
+#define PCLK_HDCP		232
+#define PCLK_DCF		233
+#define PCLK_SARADC		234
+#define PCLK_ACODEC		235
 
 /* hclk gates */
-#define HCLK_PERI		408
-#define HCLK_TSP		409
-#define HCLK_GMAC		410
-#define HCLK_I2S0_8CH		411
-#define HCLK_I2S1_8CH		413
-#define HCLK_I2S2_2CH		413
-#define HCLK_SPDIF_8CH		414
-#define HCLK_VOP		415
-#define HCLK_NANDC		416
-#define HCLK_SDMMC		417
-#define HCLK_SDIO		418
-#define HCLK_EMMC		419
-#define HCLK_SDMMC_EXT		420
-#define HCLK_RKVDEC_PRE		421
-#define HCLK_RKVDEC		422
-#define HCLK_RKVENC		423
-#define HCLK_VPU_PRE		424
-#define HCLK_VIO_PRE		425
-#define HCLK_VPU		426
-#define HCLK_VIO		427
-#define HCLK_BUS_PRE		428
-#define HCLK_PERI_PRE		429
-#define HCLK_H264		430
-#define HCLK_CIF		431
-#define HCLK_OTG_PMU		432
-#define HCLK_OTG		433
-#define HCLK_HOST0		434
-#define HCLK_HOST0_ARB		435
-#define HCLK_CRYPTO_MST		436
-#define HCLK_CRYPTO_SLV		437
-#define HCLK_PDM		438
-#define HCLK_IEP		439
-#define HCLK_RGA		440
-#define HCLK_HDCP		441
+#define HCLK_PERI		308
+#define HCLK_TSP		309
+#define HCLK_GMAC		310
+#define HCLK_I2S0_8CH		311
+#define HCLK_I2S1_8CH		312
+#define HCLK_I2S2_2CH		313
+#define HCLK_SPDIF_8CH		314
+#define HCLK_VOP		315
+#define HCLK_NANDC		316
+#define HCLK_SDMMC		317
+#define HCLK_SDIO		318
+#define HCLK_EMMC		319
+#define HCLK_SDMMC_EXT		320
+#define HCLK_RKVDEC_PRE		321
+#define HCLK_RKVDEC		322
+#define HCLK_RKVENC		323
+#define HCLK_VPU_PRE		324
+#define HCLK_VIO_PRE		325
+#define HCLK_VPU		326
+#define HCLK_VIO		327
+#define HCLK_BUS_PRE		328
+#define HCLK_PERI_PRE		329
+#define HCLK_H264		330
+#define HCLK_CIF		331
+#define HCLK_OTG_PMU		332
+#define HCLK_OTG		333
+#define HCLK_HOST0		334
+#define HCLK_HOST0_ARB		335
+#define HCLK_CRYPTO_MST		336
+#define HCLK_CRYPTO_SLV		337
+#define HCLK_PDM		338
+#define HCLK_IEP		339
+#define HCLK_RGA		340
+#define HCLK_HDCP		341
 
 #define CLK_NR_CLKS		(HCLK_HDCP + 1)
 
-#define SCLK_MAC2IO		0
-#define SCLK_MAC2PHY		1
-
-#define CLKGRF_NR_CLKS		(SCLK_MAC2PHY + 1)
-
 /* soft-reset indices */
 #define SRST_CORE0_PO		0
 #define SRST_CORE1_PO		1
diff --git a/include/dt-bindings/clock/rk3368-cru.h b/include/dt-bindings/clock/rk3368-cru.h
index 9c5dd9ba2f..5d35316867 100644
--- a/include/dt-bindings/clock/rk3368-cru.h
+++ b/include/dt-bindings/clock/rk3368-cru.h
@@ -44,13 +44,12 @@
 #define SCLK_I2S_8CH		82
 #define SCLK_SPDIF_8CH		83
 #define SCLK_I2S_2CH		84
-#define SCLK_TIMER0		85
-#define SCLK_TIMER1		86
-#define SCLK_TIMER2		87
-#define SCLK_TIMER3		88
-#define SCLK_TIMER4		89
-#define SCLK_TIMER5		90
-#define SCLK_TIMER6		91
+#define SCLK_TIMER00		85
+#define SCLK_TIMER01		86
+#define SCLK_TIMER02		87
+#define SCLK_TIMER03		88
+#define SCLK_TIMER04		89
+#define SCLK_TIMER05		90
 #define SCLK_OTGPHY0		93
 #define SCLK_OTG_ADP		96
 #define SCLK_HSICPHY480M	97
@@ -82,6 +81,19 @@
 #define SCLK_SFC		126
 #define SCLK_MAC		127
 #define SCLK_MACREF_OUT		128
+#define SCLK_MIPIDSI_24M	129
+#define SCLK_CRYPTO		130
+#define SCLK_VIP_SRC		131
+#define SCLK_VIP_OUT		132
+#define SCLK_TIMER10		133
+#define SCLK_TIMER11		134
+#define SCLK_TIMER12		135
+#define SCLK_TIMER13		136
+#define SCLK_TIMER14		137
+#define SCLK_TIMER15		138
+#define SCLK_DDRCLK		139
+#define SCLK_TSP		140
+#define SCLK_HSADC_TSP		141
 
 #define DCLK_VOP		190
 #define MCLK_CRYPTO		191
@@ -105,6 +117,7 @@
 #define ACLK_VIDEO		208
 #define ACLK_BUS		209
 #define ACLK_PERI		210
+#define ACLK_CCI_PRE		211
 
 /* pclk gates */
 #define PCLK_GPIO0		320
@@ -151,8 +164,13 @@
 #define PCLK_ISP		366
 #define PCLK_VIP		367
 #define PCLK_WDT		368
+#define PCLK_DPHYRX		369
+#define PCLK_DPHYTX0		370
+#define PCLK_EFUSE256		371
+#define PCLK_EFUSE1024		372
 
 /* hclk gates */
+#define HCLK_USB_PERI		447
 #define HCLK_SFC		448
 #define HCLK_OTG0		449
 #define HCLK_HOST0		450
diff --git a/include/dt-bindings/clock/rk3399-cru.h b/include/dt-bindings/clock/rk3399-cru.h
index d4bdcc663f..e479e0f47a 100644
--- a/include/dt-bindings/clock/rk3399-cru.h
+++ b/include/dt-bindings/clock/rk3399-cru.h
@@ -7,6 +7,8 @@
 #ifndef _DT_BINDINGS_CLK_ROCKCHIP_RK3399_H
 #define _DT_BINDINGS_CLK_ROCKCHIP_RK3399_H
 
+#define RK3399_TWO_PLL_FOR_VOP
+
 /* core clocks */
 #define PLL_APLLL			1
 #define PLL_APLLB			2
diff --git a/include/dt-bindings/clock/rv1108-cru.h b/include/dt-bindings/clock/rv1108-cru.h
index d2ad3bb52d..ff3688e827 100644
--- a/include/dt-bindings/clock/rv1108-cru.h
+++ b/include/dt-bindings/clock/rv1108-cru.h
@@ -14,7 +14,6 @@
 #define ARMCLK				3
 
 /* sclk gates (special clocks) */
-#define SCLK_MAC			64
 #define SCLK_SPI0			65
 #define SCLK_NANDC			67
 #define SCLK_SDMMC			68
@@ -35,19 +34,75 @@
 #define SCLK_SDMMC_SAMPLE		84
 #define SCLK_SDIO_SAMPLE		85
 #define SCLK_EMMC_SAMPLE		86
-#define SCLK_MAC_RX			87
-#define SCLK_MAC_TX			88
-#define SCLK_MACREF			89
-#define SCLK_MACREF_OUT			90
+#define SCLK_VENC_CORE			87
+#define SCLK_HEVC_CORE			88
+#define SCLK_HEVC_CABAC			89
+#define SCLK_PWM0_PMU			90
+#define SCLK_I2C0_PMU			91
+#define SCLK_WIFI			92
+#define SCLK_CIFOUT			93
+#define SCLK_MIPI_CSI_OUT		94
+#define SCLK_CIF0			95
+#define SCLK_CIF1			96
+#define SCLK_CIF2			97
+#define SCLK_CIF3			98
+#define SCLK_DSP			99
+#define SCLK_DSP_IOP			100
+#define SCLK_DSP_EPP			101
+#define SCLK_DSP_EDP			102
+#define SCLK_DSP_EDAP			103
+#define SCLK_CVBS_HOST			104
+#define SCLK_HDMI_SFR			105
+#define SCLK_HDMI_CEC			106
+#define SCLK_CRYPTO			107
+#define SCLK_SPI			108
+#define SCLK_SARADC			109
+#define SCLK_TSADC			110
+#define SCLK_MAC_PRE			111
+#define SCLK_MAC			112
+#define SCLK_MAC_RX			113
+#define SCLK_MAC_REF			114
+#define SCLK_MAC_REFOUT			115
+#define SCLK_DSP_PFM			116
+#define SCLK_RGA			117
+#define SCLK_I2C1			118
+#define SCLK_I2C2			119
+#define SCLK_I2C3			120
+#define SCLK_PWM			121
+#define SCLK_ISP			122
+#define SCLK_USBPHY			123
+#define SCLK_I2S0_SRC			124
+#define SCLK_I2S1_SRC			125
+#define SCLK_I2S2_SRC			126
+#define SCLK_UART0_SRC			127
+#define SCLK_UART1_SRC			128
+#define SCLK_UART2_SRC			129
+#define SCLK_MAC_TX			130
 
+#define DCLK_VOP_SRC			185
+#define DCLK_HDMIPHY			186
+#define DCLK_VOP			187
 
 /* aclk gates */
 #define ACLK_DMAC			192
 #define ACLK_PRE			193
 #define ACLK_CORE			194
 #define ACLK_ENMCORE			195
-#define ACLK_GMAC			196
-
+#define ACLK_RKVENC			196
+#define ACLK_RKVDEC			197
+#define ACLK_VPU			198
+#define ACLK_CIF0			199
+#define ACLK_VIO0			200
+#define ACLK_VIO1			201
+#define ACLK_VOP			202
+#define ACLK_IEP			203
+#define ACLK_RGA			204
+#define ACLK_ISP			205
+#define ACLK_CIF1			206
+#define ACLK_CIF2			207
+#define ACLK_CIF3			208
+#define ACLK_PERI			209
+#define ACLK_GMAC			210
 
 /* pclk gates */
 #define PCLK_GPIO1			256
@@ -66,11 +121,24 @@
 #define PCLK_PWM			269
 #define PCLK_TIMER			270
 #define PCLK_PERI			271
-#define PCLK_GMAC			272
+#define PCLK_GPIO0_PMU			272
+#define PCLK_I2C0_PMU			273
+#define PCLK_PWM0_PMU			274
+#define PCLK_ISP			275
+#define PCLK_VIO			276
+#define PCLK_MIPI_DSI			277
+#define PCLK_HDMI_CTRL			278
+#define PCLK_SARADC			279
+#define PCLK_DSP_CFG			280
+#define PCLK_BUS			281
+#define PCLK_EFUSE0			282
+#define PCLK_EFUSE1			283
+#define PCLK_WDT			284
+#define PCLK_GMAC			285
 
 /* hclk gates */
 #define HCLK_I2S0_8CH			320
-#define HCLK_I2S1_8CH			321
+#define HCLK_I2S1_2CH			321
 #define HCLK_I2S2_2CH			322
 #define HCLK_NANDC			323
 #define HCLK_SDMMC			324
@@ -78,8 +146,25 @@
 #define HCLK_EMMC			326
 #define HCLK_PERI			327
 #define HCLK_SFC			328
+#define HCLK_RKVENC			329
+#define HCLK_RKVDEC			330
+#define HCLK_CIF0			331
+#define HCLK_VIO			332
+#define HCLK_VOP			333
+#define HCLK_IEP			334
+#define HCLK_RGA			335
+#define HCLK_ISP			336
+#define HCLK_CRYPTO_MST			337
+#define HCLK_CRYPTO_SLV			338
+#define HCLK_HOST0			339
+#define HCLK_OTG			340
+#define HCLK_CIF1			341
+#define HCLK_CIF2			342
+#define HCLK_CIF3			343
+#define HCLK_BUS			344
+#define HCLK_VPU			345
 
-#define CLK_NR_CLKS			(HCLK_SFC + 1)
+#define CLK_NR_CLKS			(HCLK_VPU + 1)
 
 /* reset id */
 #define SRST_CORE_PO_AD		0
diff --git a/include/dt-bindings/phy/phy.h b/include/dt-bindings/phy/phy.h
index 6c901930eb..d3714edd4b 100644
--- a/include/dt-bindings/phy/phy.h
+++ b/include/dt-bindings/phy/phy.h
@@ -15,5 +15,10 @@
 #define PHY_TYPE_PCIE		2
 #define PHY_TYPE_USB2		3
 #define PHY_TYPE_USB3		4
+#define PHY_TYPE_UFS		5
+#define PHY_TYPE_DP		6
+#define PHY_TYPE_XPCS		7
+#define PHY_TYPE_SGMII		8
+#define PHY_TYPE_QSGMII		9
 
 #endif /* _DT_BINDINGS_PHY */
diff --git a/include/dt-bindings/pinctrl/rockchip.h b/include/dt-bindings/pinctrl/rockchip.h
index 0798287e6f..0d19b78c8b 100644
--- a/include/dt-bindings/pinctrl/rockchip.h
+++ b/include/dt-bindings/pinctrl/rockchip.h
@@ -51,11 +51,21 @@
 #define RK_PD7		31
 
 #define RK_FUNC_GPIO	0
+#define RK_FUNC_0	0
 #define RK_FUNC_1	1
 #define RK_FUNC_2	2
 #define RK_FUNC_3	3
 #define RK_FUNC_4	4
 #define RK_FUNC_5	5
 #define RK_FUNC_6	6
+#define RK_FUNC_7	7
+#define RK_FUNC_8	8
+#define RK_FUNC_9	9
+#define RK_FUNC_10	10
+#define RK_FUNC_11	11
+#define RK_FUNC_12	12
+#define RK_FUNC_13	13
+#define RK_FUNC_14	14
+#define RK_FUNC_15	15
 
 #endif
diff --git a/include/dt-structs.h b/include/dt-structs.h
index 0732c442ff..c0f56951b5 100644
--- a/include/dt-structs.h
+++ b/include/dt-structs.h
@@ -9,11 +9,21 @@
 
 /* These structures may only be used in SPL */
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
-struct phandle_2_cell {
+struct phandle_0_arg {
 	const void *node;
-	int id;
+	int arg[0];
 };
-#include <generated/dt-structs.h>
+
+struct phandle_1_arg {
+	const void *node;
+	int arg[1];
+};
+
+struct phandle_2_arg {
+	const void *node;
+	int arg[2];
+};
+#include <generated/dt-structs-gen.h>
 #endif
 
 #endif
diff --git a/include/dwc3-uboot.h b/include/dwc3-uboot.h
index 7af2ad11e4..14c9b5afdb 100644
--- a/include/dwc3-uboot.h
+++ b/include/dwc3-uboot.h
@@ -11,10 +11,12 @@
 #define __DWC3_UBOOT_H_
 
 #include <linux/usb/otg.h>
+#include <linux/usb/phy.h>
 
 struct dwc3_device {
 	unsigned long base;
 	enum usb_dr_mode dr_mode;
+	enum usb_phy_interface hsphy_mode;
 	u32 maximum_speed;
 	unsigned tx_fifo_resize:1;
 	unsigned has_lpm_erratum;
@@ -31,12 +33,33 @@ struct dwc3_device {
 	unsigned rx_detect_poll_quirk;
 	unsigned dis_u3_susphy_quirk;
 	unsigned dis_u2_susphy_quirk;
+	unsigned dis_u1u2_quirk;
 	unsigned tx_de_emphasis_quirk;
 	unsigned tx_de_emphasis;
+	unsigned usb2_phyif_utmi_width;
 	int index;
 };
 
 int dwc3_uboot_init(struct dwc3_device *dev);
 void dwc3_uboot_exit(int index);
 void dwc3_uboot_handle_interrupt(int index);
+
+struct phy;
+#if CONFIG_IS_ENABLED(PHY) && CONFIG_IS_ENABLED(DM_USB)
+int dwc3_setup_phy(struct udevice *dev, struct phy **array, int *num_phys);
+int dwc3_shutdown_phy(struct udevice *dev, struct phy *usb_phys, int num_phys);
+#else
+static inline int dwc3_setup_phy(struct udevice *dev, struct phy **array,
+				 int *num_phys)
+{
+	return -ENOTSUPP;
+}
+
+static inline int dwc3_shutdown_phy(struct udevice *dev, struct phy *usb_phys,
+				    int num_phys)
+{
+	return -ENOTSUPP;
+}
+#endif
+
 #endif /* __DWC3_UBOOT_H_ */
diff --git a/include/dwmmc.h b/include/dwmmc.h
index a9058824e0..ddae2ec639 100644
--- a/include/dwmmc.h
+++ b/include/dwmmc.h
@@ -48,6 +48,7 @@
 #define DWMCI_IDINTEN		0x090
 #define DWMCI_DSCADDR		0x094
 #define DWMCI_BUFADDR		0x098
+#define DWMCI_CARDTHRCTL	0x100
 #define DWMCI_DATA		0x200
 
 /* Interrupt Mask register */
@@ -115,6 +116,10 @@
 #define RX_WMARK_SHIFT		16
 #define RX_WMARK_MASK		(0xfff << RX_WMARK_SHIFT)
 
+/* HCON Register */
+#define DMA_INTERFACE_IDMA		(0x0)
+#define SDMMC_GET_TRANS_MODE(x)		(((x)>>16) & 0x3)
+
 #define DWMCI_IDMAC_OWN		(1 << 31)
 #define DWMCI_IDMAC_CH		(1 << 4)
 #define DWMCI_IDMAC_FS		(1 << 3)
@@ -131,6 +136,18 @@
 /* quirks */
 #define DWMCI_QUIRK_DISABLE_SMU		(1 << 0)
 
+/*
+ * DWMCI_MSIZE is uses to set burst size of multiple transaction.
+ * The burst size is set to 128 if DWMCI_MSIZE is set to 0x6.
+ */
+#define DWMCI_MSIZE    0x6
+
+/* The DW MMC Controller Version */
+#define DW_MMC_240A		0x240a
+
+/* sdmmc cardthrctl set */
+#define DWMCI_CDTHRCTRL_CONFIG (1 + (0x200 << 16))
+
 /**
  * struct dwmci_host - Information about a designware MMC host
  *
@@ -146,6 +163,7 @@
  * @fifoth_val:	Value for FIFOTH register (or 0 to leave unset)
  * @mmc:	Pointer to generic MMC structure for this device
  * @priv:	Private pointer for use by controller
+ * @stride_pio: Provide the ability of accessing fifo with burst mode
  */
 struct dwmci_host {
 	const char *name;
@@ -162,6 +180,7 @@ struct dwmci_host {
 	u32 fifoth_val;
 	struct mmc *mmc;
 	void *priv;
+	bool stride_pio;
 
 	void (*clksel)(struct dwmci_host *host);
 	void (*board_init)(struct dwmci_host *host);
@@ -180,6 +199,7 @@ struct dwmci_host {
 	 * @freq:	Frequency the host is trying to achieve
 	 */
 	unsigned int (*get_mmc_clk)(struct dwmci_host *host, uint freq);
+	int (*execute_tuning)(struct dwmci_host *host, u32 opcode);
 #ifndef CONFIG_BLK
 	struct mmc_config cfg;
 #endif
diff --git a/include/edid.h b/include/edid.h
index a9f2f3d3ab..72af0322b7 100644
--- a/include/edid.h
+++ b/include/edid.h
@@ -8,24 +8,72 @@
  *
  * Contains stolen code from ddcprobe project which is:
  * Copyright (C) Nalin Dahyabhai <bigfun@pobox.com>
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
  */
 
 #ifndef __EDID_H_
 #define __EDID_H_
 
+#include <div64.h>
 #include <linux/types.h>
+#include <drm_modes.h>
+#include <i2c.h>
 
 /* Size of the EDID data */
 #define EDID_SIZE	128
 #define EDID_EXT_SIZE	256
+#define MODE_LEN	240
+
+#define CEA_EXT	    0x02
+#define VTB_EXT	    0x10
+#define DI_EXT	    0x40
+#define LS_EXT	    0x50
+#define MI_EXT	    0x60
+#define DISPLAYID_EXT 0x70
+
+#define EDID_TIMING_ASPECT_SHIFT 6
+#define EDID_TIMING_ASPECT_MASK  (0x3 << EDID_TIMING_ASPECT_SHIFT)
+
+/* need to add 60 */
+#define EDID_TIMING_VFREQ_SHIFT  0
+#define EDID_TIMING_VFREQ_MASK   (0x3f << EDID_TIMING_VFREQ_SHIFT)
 
 /* OUI of HDMI vendor specific data block */
 #define HDMI_IEEE_OUI 0x000c03
 
+/* drm mode 4k and 3d */
+#define DRM_MODE_FLAG_420_MASK			(0x03 << 23)
+#define  DRM_MODE_FLAG_420			BIT(23)
+#define  DRM_MODE_FLAG_420_ONLY			BIT(24)
+
+#define DRM_MODE_FLAG_3D_MASK                  (0x1f << 14)
+#define  DRM_MODE_FLAG_3D_NONE                 (0 << 14)
+#define  DRM_MODE_FLAG_3D_FRAME_PACKING                BIT(14)
+#define  DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE    (2 << 14)
+#define  DRM_MODE_FLAG_3D_LINE_ALTERNATIVE     (3 << 14)
+#define  DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL    (4 << 14)
+#define  DRM_MODE_FLAG_3D_L_DEPTH              (5 << 14)
+#define  DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH        (6 << 14)
+#define  DRM_MODE_FLAG_3D_TOP_AND_BOTTOM       (7 << 14)
+#define  DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF    (8 << 14)
+
+#define BITS_PER_BYTE         8
+#define BITS_TO_LONGS(nr)     DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
 #define GET_BIT(_x, _pos) \
 	(((_x) >> (_pos)) & 1)
 #define GET_BITS(_x, _pos_msb, _pos_lsb) \
 	(((_x) >> (_pos_lsb)) & ((1 << ((_pos_msb) - (_pos_lsb) + 1)) - 1))
+#define DRM_MODE(t, c, hd, hss, hse, ht, vd, vss, vse, vt, vs, f) \
+	.clock = (c), .type = (t),\
+	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
+	.htotal = (ht), .vdisplay = (vd), \
+	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
+	.vscan = (vs), .flags = (f)
+
+#define DDC_SEGMENT_ADDR 0x30
+#define DDC_ADDR 0x50
+#define HDMI_EDID_BLOCK_SIZE 128
+#define SCDC_I2C_SLAVE_ADDRESS 0x54
 
 /* Aspect ratios used in EDID info. */
 enum edid_aspect {
@@ -35,6 +83,129 @@ enum edid_aspect {
 	ASPECT_5625,
 };
 
+struct est_timings {
+	u8 t1;
+	u8 t2;
+	u8 mfg_rsvd;
+} __packed;
+
+/* 00=16:10, 01=4:3, 10=5:4, 11=16:9 */
+#define EDID_TIMING_ASPECT_SHIFT 6
+#define EDID_TIMING_ASPECT_MASK  (0x3 << EDID_TIMING_ASPECT_SHIFT)
+
+/* need to add 60 */
+#define EDID_TIMING_VFREQ_SHIFT  0
+#define EDID_TIMING_VFREQ_MASK   (0x3f << EDID_TIMING_VFREQ_SHIFT)
+
+struct std_timing {
+	u8 hsize; /* need to multiply by 8 then add 248 */
+	u8 vfreq_aspect;
+} __packed;
+
+struct detailed_pixel_timing {
+	u8 hactive_lo;
+	u8 hblank_lo;
+	u8 hactive_hblank_hi;
+	u8 vactive_lo;
+	u8 vblank_lo;
+	u8 vactive_vblank_hi;
+	u8 hsync_offset_lo;
+	u8 hsync_pulse_width_lo;
+	u8 vsync_offset_pulse_width_lo;
+	u8 hsync_vsync_offset_pulse_width_hi;
+	u8 width_mm_lo;
+	u8 height_mm_lo;
+	u8 width_height_mm_hi;
+	u8 hborder;
+	u8 vborder;
+	u8 misc;
+} __packed;
+
+/* If it's not pixel timing, it'll be one of the below */
+struct detailed_data_string {
+	u8 str[13];
+} __packed;
+
+struct detailed_data_monitor_range {
+	u8 min_vfreq;
+	u8 max_vfreq;
+	u8 min_hfreq_khz;
+	u8 max_hfreq_khz;
+	u8 pixel_clock_mhz; /* need to multiply by 10 */
+	u8 flags;
+	union {
+		struct {
+			u8 reserved;
+			u8 hfreq_start_khz; /* need to multiply by 2 */
+			u8 c; /* need to divide by 2 */
+			__le16 m;
+			u8 k;
+			u8 j; /* need to divide by 2 */
+		} __packed gtf2;
+		struct {
+			u8 version;
+			u8 data1; /* high 6 bits: extra clock resolution */
+			u8 data2; /* plus low 2 of above: max hactive */
+			u8 supported_aspects;
+			u8 flags; /* preferred aspect and blanking support */
+			u8 supported_scalings;
+			u8 preferred_refresh;
+		} __packed cvt;
+	} formula;
+} __packed;
+
+struct detailed_data_wpindex {
+	u8 white_yx_lo; /* Lower 2 bits each */
+	u8 white_x_hi;
+	u8 white_y_hi;
+	u8 gamma; /* need to divide by 100 then add 1 */
+} __packed;
+
+struct detailed_data_color_point {
+	u8 windex1;
+	u8 wpindex1[3];
+	u8 windex2;
+	u8 wpindex2[3];
+} __packed;
+
+struct cvt_timing {
+	u8 code[3];
+} __packed;
+
+struct detailed_non_pixel {
+	u8 pad1;
+	u8 type; /* ff=serial, fe=string, fd=monitor range, fc=monitor name
+		  * fb=color point data, fa=standard timing data,
+		  * f9=undefined, f8=mfg. reserved
+		  */
+	u8 pad2;
+	union {
+		struct detailed_data_string str;
+		struct detailed_data_monitor_range range;
+		struct detailed_data_wpindex color;
+		struct std_timing timings[6];
+		struct cvt_timing cvt[4];
+	} data;
+} __packed;
+
+#define EDID_DETAIL_EST_TIMINGS 0xf7
+#define EDID_DETAIL_CVT_3BYTE 0xf8
+#define EDID_DETAIL_COLOR_MGMT_DATA 0xf9
+#define EDID_DETAIL_STD_MODES 0xfa
+#define EDID_DETAIL_MONITOR_CPDATA 0xfb
+#define EDID_DETAIL_MONITOR_NAME 0xfc
+#define EDID_DETAIL_MONITOR_RANGE 0xfd
+#define EDID_DETAIL_MONITOR_STRING 0xfe
+#define EDID_DETAIL_MONITOR_SERIAL 0xff
+
+struct detailed_timing {
+	__le16 pixel_clock; /* need to multiply by 10 KHz */
+	union {
+		struct detailed_pixel_timing pixel_data;
+		struct detailed_non_pixel other_data;
+	} data;
+} __packed;
+
 /* Detailed timing information used in EDID v1.x */
 struct edid_detailed_timing {
 	unsigned char pixel_clock[2];
@@ -126,6 +297,90 @@ struct edid_monitor_descriptor {
 	} data;
 } __attribute__ ((__packed__));
 
+#define DRM_EDID_INPUT_SERRATION_VSYNC (1 << 0)
+#define DRM_EDID_INPUT_SYNC_ON_GREEN   (1 << 1)
+#define DRM_EDID_INPUT_COMPOSITE_SYNC  (1 << 2)
+#define DRM_EDID_INPUT_SEPARATE_SYNCS  (1 << 3)
+#define DRM_EDID_INPUT_BLANK_TO_BLACK  (1 << 4)
+#define DRM_EDID_INPUT_VIDEO_LEVEL     (3 << 5)
+#define DRM_EDID_INPUT_DIGITAL         (1 << 7)
+#define DRM_EDID_DIGITAL_DEPTH_MASK    (7 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_UNDEF   (0 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_6       (1 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_8       (2 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_10      (3 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_12      (4 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_14      (5 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_16      (6 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_RSVD    (7 << 4)
+#define DRM_EDID_DIGITAL_TYPE_UNDEF    (0)
+#define DRM_EDID_DIGITAL_TYPE_DVI      (1)
+#define DRM_EDID_DIGITAL_TYPE_HDMI_A   (2)
+#define DRM_EDID_DIGITAL_TYPE_HDMI_B   (3)
+#define DRM_EDID_DIGITAL_TYPE_MDDI     (4)
+#define DRM_EDID_DIGITAL_TYPE_DP       (5)
+
+#define DRM_EDID_FEATURE_DEFAULT_GTF      (1 << 0)
+#define DRM_EDID_FEATURE_PREFERRED_TIMING (1 << 1)
+#define DRM_EDID_FEATURE_STANDARD_COLOR   (1 << 2)
+/* If analog */
+/* 00=mono, 01=rgb, 10=non-rgb, 11=unknown */
+#define DRM_EDID_FEATURE_DISPLAY_TYPE     (3 << 3)
+/* If digital */
+#define DRM_EDID_FEATURE_COLOR_MASK	  (3 << 3)
+#define DRM_EDID_FEATURE_RGB		  (0 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB444	  (1 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB422	  (2 << 3)
+/* both 4:4:4 and 4:2:2 */
+#define DRM_EDID_FEATURE_RGB_YCRCB	  (3 << 3)
+
+#define DRM_EDID_FEATURE_PM_ACTIVE_OFF    (1 << 5)
+#define DRM_EDID_FEATURE_PM_SUSPEND       (1 << 6)
+#define DRM_EDID_FEATURE_PM_STANDBY       (1 << 7)
+
+#define DRM_EDID_HDMI_DC_48               (1 << 6)
+#define DRM_EDID_HDMI_DC_36               (1 << 5)
+#define DRM_EDID_HDMI_DC_30               (1 << 4)
+#define DRM_EDID_HDMI_DC_Y444             (1 << 3)
+
+/* YCBCR 420 deep color modes */
+#define DRM_EDID_YCBCR420_DC_48		  (1 << 2)
+#define DRM_EDID_YCBCR420_DC_36		  (1 << 1)
+#define DRM_EDID_YCBCR420_DC_30		  (1 << 0)
+#define DRM_EDID_YCBCR420_DC_MASK (DRM_EDID_YCBCR420_DC_48 | \
+				    DRM_EDID_YCBCR420_DC_36 | \
+				    DRM_EDID_YCBCR420_DC_30)
+
+/* HDMI 2.1 additional fields */
+#define DRM_EDID_MAX_FRL_RATE_MASK		0xf0
+#define DRM_EDID_FAPA_START_LOCATION		BIT(0)
+#define DRM_EDID_ALLM				BIT(1)
+#define DRM_EDID_FVA				BIT(2)
+
+/* Deep Color specific */
+#define DRM_EDID_DC_30BIT_420			BIT(0)
+#define DRM_EDID_DC_36BIT_420			BIT(1)
+#define DRM_EDID_DC_48BIT_420			BIT(2)
+
+/* VRR specific */
+#define DRM_EDID_CNMVRR				BIT(3)
+#define DRM_EDID_CINEMA_VRR			BIT(4)
+#define DRM_EDID_MDELTA				BIT(5)
+#define DRM_EDID_VRR_MAX_UPPER_MASK		0xc0
+#define DRM_EDID_VRR_MAX_LOWER_MASK		0xff
+#define DRM_EDID_VRR_MIN_MASK			0x3f
+
+/* DSC specific */
+#define DRM_EDID_DSC_10BPC			BIT(0)
+#define DRM_EDID_DSC_12BPC			BIT(1)
+#define DRM_EDID_DSC_16BPC			BIT(2)
+#define DRM_EDID_DSC_ALL_BPP			BIT(3)
+#define DRM_EDID_DSC_NATIVE_420			BIT(6)
+#define DRM_EDID_DSC_1P2			BIT(7)
+#define DRM_EDID_DSC_MAX_FRL_RATE_MASK		0xf0
+#define DRM_EDID_DSC_MAX_SLICES			0xf
+#define DRM_EDID_DSC_TOTAL_CHUNK_KBYTES		0x3f
+
 struct edid1_info {
 	unsigned char header[8];
 	unsigned char manufacturer_name[2];
@@ -242,8 +497,19 @@ enum edid_cea861_db_types {
 	EDID_CEA861_DB_VIDEO = 0x02,
 	EDID_CEA861_DB_VENDOR = 0x03,
 	EDID_CEA861_DB_SPEAKER = 0x04,
+	EDID_CEA861_DB_USE_EXTENDED = 0x07,
 };
 
+#define EXT_VIDEO_CAPABILITY_BLOCK 0x00
+#define EXT_VIDEO_DATA_BLOCK_420        0x0E
+#define EXT_VIDEO_CAP_BLOCK_Y420CMDB 0x0F
+#define EDID_BASIC_AUDIO        BIT(6)
+#define EDID_CEA_YCRCB444       BIT(5)
+#define EDID_CEA_YCRCB422       BIT(4)
+#define EDID_CEA_VCDB_QS        BIT(6)
+
+#define EXT_VIDEO_DATA_BLOCK_420 0x0E
+
 struct edid_cea861_info {
 	unsigned char extension_tag;
 #define EDID_CEA861_EXTENSION_TAG	0x02
@@ -267,6 +533,389 @@ struct edid_cea861_info {
 	GET_BITS((_x).data[offset], 4, 0)
 } __attribute__ ((__packed__));
 
+#define DATA_BLOCK_PRODUCT_ID 0x00
+#define DATA_BLOCK_DISPLAY_PARAMETERS 0x01
+#define DATA_BLOCK_COLOR_CHARACTERISTICS 0x02
+#define DATA_BLOCK_TYPE_1_DETAILED_TIMING 0x03
+#define DATA_BLOCK_TYPE_2_DETAILED_TIMING 0x04
+#define DATA_BLOCK_TYPE_3_SHORT_TIMING 0x05
+#define DATA_BLOCK_TYPE_4_DMT_TIMING 0x06
+#define DATA_BLOCK_VESA_TIMING 0x07
+#define DATA_BLOCK_CEA_TIMING 0x08
+#define DATA_BLOCK_VIDEO_TIMING_RANGE 0x09
+#define DATA_BLOCK_PRODUCT_SERIAL_NUMBER 0x0a
+#define DATA_BLOCK_GP_ASCII_STRING 0x0b
+#define DATA_BLOCK_DISPLAY_DEVICE_DATA 0x0c
+#define DATA_BLOCK_INTERFACE_POWER_SEQUENCING 0x0d
+#define DATA_BLOCK_TRANSFER_CHARACTERISTICS 0x0e
+#define DATA_BLOCK_DISPLAY_INTERFACE 0x0f
+#define DATA_BLOCK_STEREO_DISPLAY_INTERFACE 0x10
+#define DATA_BLOCK_TILED_DISPLAY 0x12
+
+struct displayid_hdr {
+	u8 rev;
+	u8 bytes;
+	u8 prod_id;
+	u8 ext_count;
+} __packed;
+
+struct displayid_block {
+	u8 tag;
+	u8 rev;
+	u8 num_bytes;
+} __packed;
+
+struct displayid_detailed_timings_1 {
+	u8 pixel_clock[3];
+	u8 flags;
+	u8 hactive[2];
+	u8 hblank[2];
+	u8 hsync[2];
+	u8 hsw[2];
+	u8 vactive[2];
+	u8 vblank[2];
+	u8 vsync[2];
+	u8 vsw[2];
+} __packed;
+
+struct displayid_detailed_timing_block {
+	struct displayid_block base;
+	struct displayid_detailed_timings_1 timings[0];
+};
+
+/**
+ * struct drm_scrambling: sink's scrambling support.
+ */
+struct drm_scrambling {
+	/**
+	 * @supported: scrambling supported for rates > 340 Mhz.
+	 */
+	bool supported;
+	/**
+	 * @low_rates: scrambling supported for rates <= 340 Mhz.
+	 */
+	bool low_rates;
+};
+
+/**
+ * struct drm_scdc - Information about scdc capabilities of a HDMI 2.0 sink
+ *
+ * Provides SCDC register support and capabilities related information on a
+ * HDMI 2.0 sink. In case of a HDMI 1.4 sink, all parameter must be 0.
+ */
+
+struct drm_scdc {
+	/**
+	 * @supported: status control & data channel present.
+	 */
+	bool supported;
+	/**
+	 * @read_request: sink is capable of generating scdc read request.
+	 */
+	bool read_request;
+	/**
+	 * @scrambling: sink's scrambling capabilities
+	 */
+	struct drm_scrambling scrambling;
+};
+
+/**
+ * struct drm_hdmi_dsc_cap - DSC capabilities of HDMI sink
+ *
+ * Describes the DSC support provided by HDMI 2.1 sink.
+ * The information is fetched fom additional HFVSDB blocks defined
+ * for HDMI 2.1.
+ */
+struct drm_hdmi_dsc_cap {
+	/** @v_1p2: flag for dsc1.2 version support by sink */
+	bool v_1p2;
+
+	/** @native_420: Does sink support DSC with 4:2:0 compression */
+	bool native_420;
+
+	/**
+	 * @all_bpp: Does sink support all bpp with 4:4:4: or 4:2:2
+	 * compressed formats
+	 */
+	bool all_bpp;
+
+	/**
+	 * @bpc_supported: compressed bpc supported by sink : 10, 12 or 16 bpc
+	 */
+	u8 bpc_supported;
+
+	/** @max_slices: maximum number of Horizontal slices supported by */
+	u8 max_slices;
+
+	/** @clk_per_slice : max pixel clock in MHz supported per slice */
+	int clk_per_slice;
+
+	/** @max_lanes : dsc max lanes supported for Fixed rate Link training */
+	u8 max_lanes;
+
+	/** @max_frl_rate_per_lane : maximum frl rate with DSC per lane */
+	u8 max_frl_rate_per_lane;
+
+	/** @total_chunk_kbytes: max size of chunks in KBs supported per line*/
+	u8 total_chunk_kbytes;
+};
+
+/**
+ * struct drm_hdmi_info - runtime information about the connected HDMI sink
+ *
+ * Describes if a given display supports advanced HDMI 2.0 features.
+ * This information is available in CEA-861-F extension blocks (like HF-VSDB).
+ */
+struct drm_hdmi_info {
+	struct drm_scdc scdc;
+
+	/**
+	 * @y420_vdb_modes: bitmap of modes which can support ycbcr420
+	 * output only (not normal RGB/YCBCR444/422 outputs). There are total
+	 * 107 VICs defined by CEA-861-F spec, so the size is 128 bits to map
+	 * upto 128 VICs;
+	 */
+	unsigned long y420_vdb_modes[BITS_TO_LONGS(128)];
+
+	/**
+	 * @y420_cmdb_modes: bitmap of modes which can support ycbcr420
+	 * output also, along with normal HDMI outputs. There are total 107
+	 * VICs defined by CEA-861-F spec, so the size is 128 bits to map upto
+	 * 128 VICs;
+	 */
+	unsigned long y420_cmdb_modes[BITS_TO_LONGS(128)];
+
+	/** @y420_cmdb_map: bitmap of SVD index, to extraxt vcb modes */
+	u64 y420_cmdb_map;
+
+	/** @y420_dc_modes: bitmap of deep color support index */
+	u8 y420_dc_modes;
+
+	/** @max_frl_rate_per_lane: support fixed rate link */
+	u8 max_frl_rate_per_lane;
+
+	/** @max_lanes: supported by sink */
+	u8 max_lanes;
+
+	/** @dsc_cap: DSC capabilities of the sink */
+	struct drm_hdmi_dsc_cap dsc_cap;
+};
+
+enum subpixel_order {
+	subpixelunknown = 0,
+	subpixelhorizontalrgb,
+	subpixelhorizontalbgr,
+	subpixelverticalrgb,
+	subpixelverticalbgr,
+	subpixelnone,
+};
+
+#define DRM_COLOR_FORMAT_RGB444         BIT(0)
+#define DRM_COLOR_FORMAT_YCRCB444       BIT(1)
+#define DRM_COLOR_FORMAT_YCRCB422       BIT(2)
+#define DRM_COLOR_FORMAT_YCRCB420       BIT(3)
+
+/*
+ * Describes a given display (e.g. CRT or flat panel) and its limitations.
+ */
+struct drm_display_info {
+	char name[32];
+
+	/* Physical size */
+	unsigned int width_mm;
+	unsigned int height_mm;
+
+	/* Clock limits FIXME: storage format */
+	unsigned int min_vfreq, max_vfreq;
+	unsigned int min_hfreq, max_hfreq;
+	unsigned int pixel_clock;
+	unsigned int bpc;
+
+	enum subpixel_order subpixel_order;
+	u32 color_formats;
+
+	const u32 *bus_formats;
+	unsigned int num_bus_formats;
+
+	/**
+	 * @max_tmds_clock: Maximum TMDS clock rate supported by the
+	 * sink in kHz. 0 means undefined.
+	 */
+	int max_tmds_clock;
+
+	/**
+	 * @dvi_dual: Dual-link DVI sink?
+	 */
+	bool dvi_dual;
+
+	/* Mask of supported hdmi deep color modes */
+	u8 edid_hdmi_dc_modes;
+
+	u8 cea_rev;
+
+	/**
+	 * @hdmi: advance features of a HDMI sink.
+	 */
+	struct drm_hdmi_info hdmi;
+};
+
+struct edid {
+	u8 header[8];
+	/* Vendor & product info */
+	u8 mfg_id[2];
+	u8 prod_code[2];
+	u32 serial; /* FIXME: byte order */
+	u8 mfg_week;
+	u8 mfg_year;
+	/* EDID version */
+	u8 version;
+	u8 revision;
+	/* Display info: */
+	u8 input;
+	u8 width_cm;
+	u8 height_cm;
+	u8 gamma;
+	u8 features;
+	/* Color characteristics */
+	u8 red_green_lo;
+	u8 black_white_lo;
+	u8 red_x;
+	u8 red_y;
+	u8 green_x;
+	u8 green_y;
+	u8 blue_x;
+	u8 blue_y;
+	u8 white_x;
+	u8 white_y;
+	/* Est. timings and mfg rsvd timings*/
+	struct est_timings established_timings;
+	/* Standard timings 1-8*/
+	struct std_timing standard_timings[8];
+	/* Detailing timings 1-4 */
+	struct detailed_timing detailed_timings[4];
+	/* Number of 128 byte ext. blocks */
+	u8 extensions;
+	/* Checksum */
+	u8 checksum;
+} __packed;
+
+enum base_output_format {
+	DRM_HDMI_OUTPUT_DEFAULT_RGB, /* default RGB */
+	DRM_HDMI_OUTPUT_YCBCR444, /* YCBCR 444 */
+	DRM_HDMI_OUTPUT_YCBCR422, /* YCBCR 422 */
+	DRM_HDMI_OUTPUT_YCBCR420, /* YCBCR 420 */
+	/* (YCbCr444 > YCbCr422 > YCbCr420 > RGB) */
+	DRM_HDMI_OUTPUT_YCBCR_HQ,
+	/* (YCbCr420 > YCbCr422 > YCbCr444 > RGB) */
+	DRM_HDMI_OUTPUT_YCBCR_LQ,
+	DRM_HDMI_OUTPUT_INVALID, /* Guess what ? */
+};
+
+enum  base_output_depth {
+	AUTOMATIC = 0,
+	DEPTH_24BIT = 8,
+	DEPTH_30BIT = 10,
+};
+
+struct base_bcsh_info {
+	unsigned short brightness;
+	unsigned short contrast;
+	unsigned short saturation;
+	unsigned short hue;
+};
+
+struct base_overscan {
+	unsigned int maxvalue;
+	unsigned short leftscale;
+	unsigned short rightscale;
+	unsigned short topscale;
+	unsigned short bottomscale;
+};
+
+struct base_drm_display_mode {
+	int clock;		/* in kHz */
+	int hdisplay;
+	int hsync_start;
+	int hsync_end;
+	int htotal;
+	int vdisplay;
+	int vsync_start;
+	int vsync_end;
+	int vtotal;
+	int vrefresh;
+	int vscan;
+	unsigned int flags;
+	int picture_aspect_ratio;
+};
+
+struct base_screen_info {
+	int type;
+	struct base_drm_display_mode mode;	/* 52 bytes */
+	enum base_output_format  format;	/* 4 bytes */
+	enum base_output_depth depth;		/* 4 bytes */
+	unsigned int feature;			/* 4 bytes */
+};
+
+struct base_disp_info {
+	struct base_screen_info screen_list[5];
+	struct base_overscan scan;		/* 12 bytes */
+};
+
+struct base2_cubic_lut_data {
+	u16 size;
+	u16 lred[4913];
+	u16 lgreen[4913];
+	u16 lblue[4913];
+};
+
+struct base2_screen_info {
+	u32 type;
+	u32 id;
+	struct base_drm_display_mode resolution;
+	enum base_output_format  format;
+	enum base_output_depth depthc;
+	u32 feature;
+};
+
+struct base2_gamma_lut_data {
+	u16 size;
+	u16 lred[1024];
+	u16 lgreen[1024];
+	u16 lblue[1024];
+};
+
+struct framebuffer_info {
+	u32 framebuffer_width;
+	u32 framebuffer_height;
+	u32 fps;
+};
+
+struct base2_disp_info {
+	char disp_head_flag[6];
+	struct base2_screen_info screen_info[4];
+	struct base_bcsh_info bcsh_info;
+	struct base_overscan overscan_info;
+	struct base2_gamma_lut_data gamma_lut_data;
+	struct base2_cubic_lut_data cubic_lut_data;
+	struct framebuffer_info framebuffer_info;
+	u32 reserved[244];
+	u32 crc;
+};
+
+struct base2_disp_header {
+	u32 connector_type;
+	u32 connector_id;
+	u32 offset;
+};
+
+struct base2_info {
+	char head_flag[4];
+	u16 major_version;
+	u16 minor_version;
+	struct base2_disp_header disp_header[8];
+	struct base2_disp_info disp_info[8];
+};
+
 /**
  * Print the EDID info.
  *
@@ -296,17 +945,32 @@ int edid_check_checksum(u8 *edid_block);
  *
  * @param edid	The EDID info
  * @param hmin	Returns the minimum horizontal rate
- * @param hmax	Returns the maxium horizontal rate
+ * @param hmax	Returns the maximum horizontal rate
  * @param vmin	Returns the minimum vertical rate
- * @param vmax	Returns the maxium vertical rate
+ * @param vmax	Returns the maximum vertical rate
  * @return 0 on success, or -1 on error
  */
 int edid_get_ranges(struct edid1_info *edid, unsigned int *hmin,
 		    unsigned int *hmax, unsigned int *vmin,
 		    unsigned int *vmax);
 
+struct drm_display_mode;
 struct display_timing;
 
+struct hdmi_edid_data {
+	struct drm_display_mode *preferred_mode;
+	int modes;
+	struct drm_display_mode *mode_buf;
+	struct drm_display_info display_info;
+};
+
+struct ddc_adapter {
+	int (*ddc_xfer)(struct ddc_adapter *adap, struct i2c_msg *msgs,
+			int num);
+	struct udevice *i2c_bus;
+	struct dm_i2c_ops *ops;
+};
+
 /**
  * edid_get_timing() - Get basic digital display parameters
  *
@@ -320,5 +984,23 @@ struct display_timing;
  */
 int edid_get_timing(u8 *buf, int buf_size, struct display_timing *timing,
 		    int *panel_bits_per_colourp);
+int edid_get_drm_mode(u8 *buf, int buf_size, struct drm_display_mode *mode,
+		      int *panel_bits_per_colourp);
+int drm_add_edid_modes(struct hdmi_edid_data *data, u8 *edid);
+bool drm_detect_hdmi_monitor(struct edid *edid);
+bool drm_detect_monitor_audio(struct edid *edid);
+int do_cea_modes(struct hdmi_edid_data *data, const u8 *db, u8 len);
+int drm_do_get_edid(struct ddc_adapter *adap, u8 *edid);
+enum hdmi_quantization_range
+drm_default_rgb_quant_range(struct drm_display_mode *mode);
+u8 drm_scdc_readb(struct ddc_adapter *adap, u8 offset,
+		  u8 *value);
+u8 drm_scdc_writeb(struct ddc_adapter *adap, u8 offset,
+		   u8 value);
+void drm_mode_sort(struct hdmi_edid_data *edid_data);
+int drm_mode_prune_invalid(struct hdmi_edid_data *edid_data);
+void drm_rk_filter_whitelist(struct hdmi_edid_data *edid_data);
+void drm_rk_select_mode(struct hdmi_edid_data *edid_data,
+			struct base_screen_info *screen_info);
 
 #endif /* __EDID_H_ */
diff --git a/include/efi.h b/include/efi.h
index 02b78b31b1..87b0b43f20 100644
--- a/include/efi.h
+++ b/include/efi.h
@@ -28,6 +28,10 @@
 
 struct efi_device_path;
 
+typedef struct {
+	u8 b[16];
+} efi_guid_t;
+
 #define EFI_BITS_PER_LONG	BITS_PER_LONG
 
 /*
diff --git a/include/efi_api.h b/include/efi_api.h
index ec1b321e8e..a9ddfe0f4b 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -290,8 +290,39 @@ struct efi_mac_addr {
 	u8 addr[32];
 };
 
+#define DEVICE_PATH_TYPE_HARDWARE_DEVICE	0x01
+#  define DEVICE_PATH_SUB_TYPE_VENDOR		0x04
+
+struct efi_device_path_vendor {
+	struct efi_device_path dp;
+	efi_guid_t guid;
+	u8 vendor_data[];
+} __packed;
+
+#define DEVICE_PATH_TYPE_ACPI_DEVICE		0x02
+#  define DEVICE_PATH_SUB_TYPE_ACPI_DEVICE	0x01
+
+#define EFI_PNP_ID(ID)				(u32)(((ID) << 16) | 0x41D0)
+#define EISA_PNP_ID(ID)				EFI_PNP_ID(ID)
+
+struct efi_device_path_acpi_path {
+	struct efi_device_path dp;
+	u32 hid;
+	u32 uid;
+} __packed;
+
 #define DEVICE_PATH_TYPE_MESSAGING_DEVICE	0x03
+#  define DEVICE_PATH_SUB_TYPE_MSG_USB		0x05
 #  define DEVICE_PATH_SUB_TYPE_MSG_MAC_ADDR	0x0b
+#  define DEVICE_PATH_SUB_TYPE_MSG_USB_CLASS	0x0f
+#  define DEVICE_PATH_SUB_TYPE_MSG_SD		0x1a
+#  define DEVICE_PATH_SUB_TYPE_MSG_MMC		0x1d
+
+struct efi_device_path_usb {
+	struct efi_device_path dp;
+	u8 parent_port_number;
+	u8 usb_interface;
+} __packed;
 
 struct efi_device_path_mac_addr {
 	struct efi_device_path dp;
@@ -299,9 +330,42 @@ struct efi_device_path_mac_addr {
 	u8 if_type;
 };
 
+struct efi_device_path_usb_class {
+	struct efi_device_path dp;
+	u16 vendor_id;
+	u16 product_id;
+	u8 device_class;
+	u8 device_subclass;
+	u8 device_protocol;
+} __packed;
+
+struct efi_device_path_sd_mmc_path {
+	struct efi_device_path dp;
+	u8 slot_number;
+} __packed;
+
 #define DEVICE_PATH_TYPE_MEDIA_DEVICE		0x04
+#  define DEVICE_PATH_SUB_TYPE_HARD_DRIVE_PATH	0x01
+#  define DEVICE_PATH_SUB_TYPE_CDROM_PATH	0x02
 #  define DEVICE_PATH_SUB_TYPE_FILE_PATH	0x04
 
+struct efi_device_path_hard_drive_path {
+	struct efi_device_path dp;
+	u32 partition_number;
+	u64 partition_start;
+	u64 partition_end;
+	u8 partition_signature[16];
+	u8 partmap_type;
+	u8 signature_type;
+} __packed;
+
+struct efi_device_path_cdrom_path {
+	struct efi_device_path dp;
+	u32 boot_entry;
+	u64 partition_start;
+	u64 partition_end;
+} __packed;
+
 struct efi_device_path_file_path {
 	struct efi_device_path dp;
 	u16 str[32];
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 1179234f68..27cce2d10a 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -134,7 +134,7 @@ int efi_disk_register(void);
 /* Called by bootefi to make GOP (graphical) interface available */
 int efi_gop_register(void);
 /* Called by bootefi to make the network interface available */
-int efi_net_register(void **handle);
+int efi_net_register(void);
 /* Called by bootefi to make SMBIOS tables available */
 void efi_smbios_register(void);
 
@@ -191,12 +191,41 @@ uint64_t efi_add_memory_map(uint64_t start, uint64_t pages, int memory_type,
 int efi_memory_init(void);
 /* Adds new or overrides configuration table entry to the system table */
 efi_status_t efi_install_configuration_table(const efi_guid_t *guid, void *table);
+void efi_setup_loaded_image(struct efi_loaded_image *info, struct efi_object *obj,
+			    struct efi_device_path *device_path,
+			    struct efi_device_path *file_path);
 
 #ifdef CONFIG_EFI_LOADER_BOUNCE_BUFFER
 extern void *efi_bounce_buffer;
 #define EFI_LOADER_BOUNCE_BUFFER_SIZE (64 * 1024 * 1024)
 #endif
 
+
+struct efi_device_path *efi_dp_next(const struct efi_device_path *dp);
+int efi_dp_match(struct efi_device_path *a, struct efi_device_path *b);
+struct efi_object *efi_dp_find_obj(struct efi_device_path *dp,
+				   struct efi_device_path **rem);
+unsigned efi_dp_size(const struct efi_device_path *dp);
+struct efi_device_path *efi_dp_dup(const struct efi_device_path *dp);
+struct efi_device_path *efi_dp_append(const struct efi_device_path *dp1,
+				      const struct efi_device_path *dp2);
+struct efi_device_path *efi_dp_append_node(const struct efi_device_path *dp,
+					   const struct efi_device_path *node);
+
+
+struct efi_device_path *efi_dp_from_dev(struct udevice *dev);
+struct efi_device_path *efi_dp_from_part(struct blk_desc *desc, int part);
+struct efi_device_path *efi_dp_from_file(struct blk_desc *desc, int part,
+					 const char *path);
+struct efi_device_path *efi_dp_from_eth(void);
+void efi_dp_split_file_path(struct efi_device_path *full_path,
+			    struct efi_device_path **device_path,
+			    struct efi_device_path **file_path);
+
+#define EFI_DP_TYPE(_dp, _type, _subtype) \
+	(((_dp)->type == DEVICE_PATH_TYPE_##_type) && \
+	 ((_dp)->sub_type == DEVICE_PATH_SUB_TYPE_##_subtype))
+
 /* Convert strings from normal C strings to uEFI strings */
 static inline void ascii2unicode(u16 *unicode, const char *ascii)
 {
diff --git a/include/elf.h b/include/elf.h
index aaecac799e..fe2128f378 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -613,6 +613,11 @@ unsigned long elf_hash(const unsigned char *name);
 #define R_AARCH64_NONE		0	/* No relocation.  */
 #define R_AARCH64_RELATIVE	1027	/* Adjust by program base.  */
 
+/* RISC-V relocations */
+#define R_RISCV_32		1
+#define R_RISCV_64		2
+#define R_RISCV_RELATIVE	3
+
 #ifndef __ASSEMBLER__
 int valid_elf_image(unsigned long addr);
 #endif
diff --git a/include/env_default.h b/include/env_default.h
index b574345af2..853c290042 100644
--- a/include/env_default.h
+++ b/include/env_default.h
@@ -103,6 +103,9 @@ const uchar default_environment[] = {
 #ifdef CONFIG_SYS_SOC
 	"soc="		CONFIG_SYS_SOC			"\0"
 #endif
+#ifdef CONFIG_SILENT_CONSOLE
+	"silent=enable\0"
+#endif
 #endif
 #ifdef	CONFIG_EXTRA_ENV_SETTINGS
 	CONFIG_EXTRA_ENV_SETTINGS
diff --git a/include/environment.h b/include/environment.h
index 03b41e0c51..bd83107401 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -8,6 +8,7 @@
 #ifndef _ENVIRONMENT_H_
 #define _ENVIRONMENT_H_
 
+#include <stdbool.h>
 #include <linux/kconfig.h>
 
 /**************************************************************************
@@ -143,11 +144,22 @@ extern unsigned long nand_env_oob_offset;
 # define ENV_HEADER_SIZE	(sizeof(uint32_t))
 #endif
 
+/* Select the MAX from CONFIG_ENV_{,NAND,NOR}_SIZE */
+#if defined(CONFIG_ENV_NAND_SIZE) && (CONFIG_ENV_SIZE < CONFIG_ENV_NAND_SIZE)
+#define ENV_SIZE_VAL	CONFIG_ENV_NAND_SIZE
+#else
+#define ENV_SIZE_VAL	CONFIG_ENV_SIZE
+#endif
+#if defined(CONFIG_ENV_NOR_SIZE) && (ENV_SIZE_VAL < CONFIG_ENV_NOR_SIZE)
+#undef ENV_SIZE_VAL
+#define ENV_SIZE_VAL	CONFIG_ENV_NOR_SIZE
+#endif
+
 #ifdef CONFIG_ENV_AES
 /* Make sure the payload is multiple of AES block size */
-#define ENV_SIZE ((CONFIG_ENV_SIZE - ENV_HEADER_SIZE) & ~(16 - 1))
+#define ENV_SIZE ((ENV_SIZE_VAL - ENV_HEADER_SIZE) & ~(16 - 1))
 #else
-#define ENV_SIZE (CONFIG_ENV_SIZE - ENV_HEADER_SIZE)
+#define ENV_SIZE (ENV_SIZE_VAL - ENV_HEADER_SIZE)
 #endif
 
 typedef struct environment_s {
@@ -198,7 +210,6 @@ enum env_valid {
 };
 
 enum env_location {
-	ENVL_DATAFLASH,
 	ENVL_EEPROM,
 	ENVL_EXT4,
 	ENVL_FAT,
@@ -211,6 +222,7 @@ enum env_location {
 	ENVL_SPI_FLASH,
 	ENVL_UBI,
 	ENVL_NOWHERE,
+	ENVL_BLK,
 
 	ENVL_COUNT,
 	ENVL_UNKNOWN,
@@ -289,6 +301,9 @@ char *env_get_default(const char *name);
 /* [re]set to the default environment */
 void set_default_env(const char *s);
 
+/* [re]set to the board environment */
+int set_board_env(const char *vars, int size, int flags, bool ready);
+
 /* [re]set individual variables to their value in the default environment */
 int set_default_vars(int nvars, char * const vars[]);
 
diff --git a/include/exports.h b/include/exports.h
index ebe81d914c..a4b862f191 100644
--- a/include/exports.h
+++ b/include/exports.h
@@ -3,8 +3,7 @@
 
 #ifndef __ASSEMBLY__
 #ifdef CONFIG_PHY_AQUANTIA
-#include <miiphy.h>
-#include <phy.h>
+#include <phy_interface.h>
 #endif
 
 struct spi_slave;
diff --git a/include/ext4fs.h b/include/ext4fs.h
index bb55639107..07b9393e0d 100644
--- a/include/ext4fs.h
+++ b/include/ext4fs.h
@@ -32,6 +32,7 @@
 #define EXT4_EXTENTS_FL		0x00080000 /* Inode uses extents */
 #define EXT4_EXT_MAGIC			0xf30a
 #define EXT4_FEATURE_RO_COMPAT_GDT_CSUM	0x0010
+#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM 0x0400
 #define EXT4_FEATURE_INCOMPAT_EXTENTS	0x0040
 #define EXT4_FEATURE_INCOMPAT_64BIT	0x0080
 #define EXT4_INDIRECT_BLOCKS		12
@@ -116,6 +117,12 @@ struct ext_filesystem {
 	struct blk_desc *dev_desc;
 };
 
+struct ext_block_cache {
+	char *buf;
+	lbaint_t block;
+	int size;
+};
+
 extern struct ext2_data *ext4fs_root;
 extern struct ext2fs_node *ext4fs_file;
 
@@ -127,12 +134,15 @@ extern int gindex;
 int ext4fs_init(void);
 void ext4fs_deinit(void);
 int ext4fs_filename_unlink(char *filename);
-int ext4fs_write(const char *fname, unsigned char *buffer,
-		 unsigned long sizebytes);
+int ext4fs_write(const char *fname, const char *buffer,
+				 unsigned long sizebytes, int type);
 int ext4_write_file(const char *filename, void *buf, loff_t offset, loff_t len,
 		    loff_t *actwrite);
+int ext4fs_create_link(const char *target, const char *fname);
+#endif
+#if defined(CONFIG_CMD_EXT4_SPARSE_WRITE)
+int ext4_unsparse(struct blk_desc *desc, const u8 *buf, ulong start);
 #endif
-
 struct ext_filesystem *get_fs(void);
 int ext4fs_open(const char *filename, loff_t *len);
 int ext4fs_read(char *buf, loff_t offset, loff_t len, loff_t *actread);
@@ -145,11 +155,16 @@ int ext4fs_size(const char *filename, loff_t *size);
 void ext4fs_free_node(struct ext2fs_node *node, struct ext2fs_node *currroot);
 int ext4fs_devread(lbaint_t sector, int byte_offset, int byte_len, char *buf);
 void ext4fs_set_blk_dev(struct blk_desc *rbdd, disk_partition_t *info);
-long int read_allocated_block(struct ext2_inode *inode, int fileblock);
+long int read_allocated_block(struct ext2_inode *inode, int fileblock,
+			      struct ext_block_cache *cache);
 int ext4fs_probe(struct blk_desc *fs_dev_desc,
 		 disk_partition_t *fs_partition);
 int ext4_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 		   loff_t *actread);
 int ext4_read_superblock(char *buffer);
 int ext4fs_uuid(char *uuid_str);
+void ext_cache_init(struct ext_block_cache *cache);
+void ext_cache_fini(struct ext_block_cache *cache);
+int ext_cache_read(struct ext_block_cache *cache, lbaint_t block, int size);
+int ext4_dd_file(const char *filename, void *dst_desc, void (*callback)(void *, void *, loff_t));
 #endif
diff --git a/include/fastboot.h b/include/fastboot.h
index 616631e9aa..5fec137059 100644
--- a/include/fastboot.h
+++ b/include/fastboot.h
@@ -14,9 +14,58 @@
 #define _FASTBOOT_H_
 
 /* The 64 defined bytes plus \0 */
-#define FASTBOOT_RESPONSE_LEN	(64 + 1)
+#define FASTBOOT_RESPONSE_LEN (64 + 1)
 
-void fastboot_fail(const char *reason);
-void fastboot_okay(const char *reason);
+/* Fastboot getvar variables */
+typedef enum {
+	FB_VERSION,
+	FB_BOOTLOADER_VERSION,
+	FB_BASEBAND_VERSION,
+	FB_PRODUCT,
+	FB_SERIAL_NO,
+	FB_SECURE,
+	FB_DWNLD_SIZE,
+	FB_BLK_SIZE,
+	FB_ERASE_SIZE,
+	FB_PART_TYPE,
+	FB_PART_SIZE,
+	FB_UNLOCKED,
+	FB_VARIANT,
+	FB_OFF_MODE_CHARGE,
+	FB_BATT_VOLTAGE,
+	FB_BATT_SOC_OK,
+	FB_IS_USERSPACE,
+#ifdef CONFIG_RK_AVB_LIBAVB_USER
+	FB_HAS_COUNT,
+	FB_HAS_SLOT,
+	FB_CURR_SLOT,
+	FB_SLOT_SUFFIXES,
+	FB_SLOT_SUCCESSFUL,
+	FB_SLOT_UNBOOTABLE,
+	FB_SLOT_RETRY_COUNT,
+	FB_AT_VBST,
+	FB_SNAPSHOT_STATUS,
+#endif
+#ifdef CONFIG_OPTEE_CLIENT
+	FB_AT_DH,
+	FB_AT_UUID,
+#endif
+} fb_getvar_t;
+
+void fastboot_fail(const char *reason, char *response);
+void fastboot_okay(const char *reason, char *response);
+
+/**
+ * Send an INFO packet during long commands based on timer. If
+ * CONFIG_UDP_FUNCTION_FASTBOOT is defined, an INFO packet is sent
+ * if the time is 30 seconds after start. Else, noop.
+ *
+ * TODO: Handle the situation where both UDP and USB fastboot are
+ *       enabled.
+ *
+ * @param start:  Time since last INFO packet was sent.
+ * @param msg:    String describing the reason for waiting
+ */
+void timed_send_info(ulong *start, const char *msg);
 
 #endif /* _FASTBOOT_H_ */
diff --git a/include/fat.h b/include/fat.h
index 71879f01ca..bdeda95e6d 100644
--- a/include/fat.h
+++ b/include/fat.h
@@ -11,6 +11,7 @@
 #define _FAT_H_
 
 #include <asm/byteorder.h>
+#include <fs.h>
 
 #define CONFIG_SUPPORT_VFAT
 /* Maximum Long File Name length supported here is 128 UTF-16 code units */
@@ -58,12 +59,6 @@
  */
 #define LAST_LONG_ENTRY_MASK	0x40
 
-/* Flags telling whether we should read a file or list a directory */
-#define LS_NO		0
-#define LS_YES		1
-#define LS_DIR		1
-#define LS_ROOT		2
-
 #define ISDIRDELIM(c)	((c) == '/' || (c) == '\\')
 
 #define FSTYPE_NONE	(-1)
@@ -133,10 +128,14 @@ typedef struct volume_info
 	/* Boot sign comes last, 2 bytes */
 } volume_info;
 
+/* see dir_entry::lcase: */
+#define CASE_LOWER_BASE	8	/* base (name) is lower case */
+#define CASE_LOWER_EXT	16	/* extension is lower case */
+
 typedef struct dir_entry {
 	char	name[8],ext[3];	/* Name and extension */
 	__u8	attr;		/* Attribute bits */
-	__u8	lcase;		/* Case for base and extension */
+	__u8	lcase;		/* Case for name and ext (CASE_LOWER_x) */
 	__u8	ctime_ms;	/* Creation time, milliseconds */
 	__u16	ctime;		/* Creation time */
 	__u16	cdate;		/* Creation date */
@@ -174,35 +173,26 @@ typedef struct {
 	__u16	clust_size;	/* Size of clusters in sectors */
 	int	data_begin;	/* The sector of the first cluster, can be negative */
 	int	fatbufnum;	/* Used by get_fatent, init to -1 */
+	int	rootdir_size;	/* Size of root dir for non-FAT32 */
+	__u32	root_cluster;	/* First cluster of root dir for FAT32 */
 } fsdata;
 
-typedef int	(file_detectfs_func)(void);
-typedef int	(file_ls_func)(const char *dir);
-typedef int	(file_read_func)(const char *filename, void *buffer,
-				 int maxsize);
-
-struct filesystem {
-	file_detectfs_func	*detect;
-	file_ls_func		*ls;
-	file_read_func		*read;
-	const char		name[12];
-};
-
-/* FAT tables */
-file_detectfs_func	file_fat_detectfs;
-file_ls_func		file_fat_ls;
-file_read_func		file_fat_read;
-
-/* Currently this doesn't check if the dir exists or is valid... */
-int file_cd(const char *path);
+static inline u32 clust_to_sect(fsdata *fsdata, u32 clust)
+{
+	return fsdata->data_begin + clust * fsdata->clust_size;
+}
+
+static inline u32 sect_to_clust(fsdata *fsdata, u32 sect)
+{
+	return (sect - fsdata->data_begin) / fsdata->clust_size;
+}
+
 int file_fat_detectfs(void);
-int file_fat_ls(const char *dir);
 int fat_exists(const char *filename);
 int fat_size(const char *filename, loff_t *size);
 int file_fat_read_at(const char *filename, loff_t pos, void *buffer,
 		     loff_t maxsize, loff_t *actread);
 int file_fat_read(const char *filename, void *buffer, int maxsize);
-const char *file_getfsname(int idx);
 int fat_set_blk_dev(struct blk_desc *rbdd, disk_partition_t *info);
 int fat_register_device(struct blk_desc *dev_desc, int part_no);
 
@@ -210,5 +200,8 @@ int file_fat_write(const char *filename, void *buf, loff_t offset, loff_t len,
 		   loff_t *actwrite);
 int fat_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 		  loff_t *actread);
+int fat_opendir(const char *filename, struct fs_dir_stream **dirsp);
+int fat_readdir(struct fs_dir_stream *dirs, struct fs_dirent **dentp);
+void fat_closedir(struct fs_dir_stream *dirs);
 void fat_close(void);
 #endif /* _FAT_H_ */
diff --git a/include/fb_mmc.h b/include/fb_mmc.h
index 12b99cb5ee..8df6593686 100644
--- a/include/fb_mmc.h
+++ b/include/fb_mmc.h
@@ -4,6 +4,12 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
+#ifndef _FB_MMC_H_
+#define _FB_MMC_H_
 void fb_mmc_flash_write(const char *cmd, void *download_buffer,
-			unsigned int download_bytes);
-void fb_mmc_erase(const char *cmd);
+			unsigned int download_bytes, char *response);
+void fb_mmc_erase(const char *cmd, char *response);
+
+lbaint_t fb_mmc_get_erase_grp_size(void);
+
+#endif
diff --git a/include/fb_nand.h b/include/fb_nand.h
index aaf7cf7ae8..88bdf3690d 100644
--- a/include/fb_nand.h
+++ b/include/fb_nand.h
@@ -6,5 +6,5 @@
  */
 
 void fb_nand_flash_write(const char *cmd, void *download_buffer,
-			 unsigned int download_bytes);
-void fb_nand_erase(const char *cmd);
+			 unsigned int download_bytes, char *response);
+void fb_nand_erase(const char *cmd, char *response);
diff --git a/include/fdt.h b/include/fdt.h
index 7ead62e777..b97b3f2bcc 100644
--- a/include/fdt.h
+++ b/include/fdt.h
@@ -1 +1 @@
-#include <../lib/libfdt/fdt.h>
+#include "../scripts/dtc/libfdt/fdt.h"
diff --git a/include/fdt_support.h b/include/fdt_support.h
index 5ef78cce6e..0f4ceda2a3 100644
--- a/include/fdt_support.h
+++ b/include/fdt_support.h
@@ -10,13 +10,14 @@
 
 #ifdef CONFIG_OF_LIBFDT
 
-#include <libfdt.h>
+#include <linux/libfdt.h>
 
 u32 fdt_getprop_u32_default_node(const void *fdt, int off, int cell,
 				const char *prop, const u32 dflt);
 u32 fdt_getprop_u32_default(const void *fdt, const char *path,
 				const char *prop, const u32 dflt);
-
+int fdt_setprop_uxx(void *fdt, int nodeoffset, const char *name,
+		    uint64_t val, int is_u64);
 /**
  * Add data to the root of the FDT before booting the OS.
  *
@@ -27,6 +28,24 @@ u32 fdt_getprop_u32_default(const void *fdt, const char *path,
  */
 int fdt_root(void *fdt);
 
+/**
+ * Append info to bootargs
+ *
+ * @param fdt           FDT address in memory
+ * @param data          string info
+ * @return 0 if ok, else error
+ */
+int fdt_bootargs_append(void *fdt, char *data);
+
+/**
+ * Append ab info to bootargs
+ *
+ * @param fdt		FDT address in memory
+ * @param slot		slot info
+ * @return 0 if ok, else error
+ */
+int fdt_bootargs_append_ab(void *fdt, char *slot);
+
 /**
  * Add chosen data the FDT before booting the OS.
  *
@@ -93,15 +112,9 @@ int fdt_fixup_memory(void *blob, u64 start, u64 size);
  *			property will be left untouched.
  * @return 0 if ok, or -1 or -FDT_ERR_... on error
  */
-#ifdef CONFIG_ARCH_FIXUP_FDT_MEMORY
 int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks);
-#else
-static inline int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[],
-					 int banks)
-{
-	return 0;
-}
-#endif
+
+int fdt_update_reserved_memory(void *blob, char *name, u64 start, u64 size);
 
 void fdt_fixup_ethernet(void *fdt);
 int fdt_find_and_setprop(void *fdt, const char *node, const char *prop,
@@ -133,6 +146,24 @@ void fdt_fixup_crypto_node(void *blob, int sec_rev);
 static inline void fdt_fixup_crypto_node(void *blob, int sec_rev) {}
 #endif
 
+/**
+ * Record information about a processed loadable in /fit-images (creating
+ * /fit-images if necessary).
+ *
+ * @param blob		FDT blob to update
+ * @param index	        index of this loadable
+ * @param name          name of the loadable
+ * @param load_addr     address the loadable was loaded to
+ * @param size          number of bytes loaded
+ * @param entry_point   entry point (if specified, otherwise pass -1)
+ * @param type          type (if specified, otherwise pass NULL)
+ * @param os            os-type (if specified, otherwise pass NULL)
+ * @return 0 if ok, or -1 or -FDT_ERR_... on error
+ */
+int fdt_record_loadable(void *blob, u32 index, const char *name,
+			uintptr_t load_addr, u32 size, uintptr_t entry_point,
+			const char *type, const char *os);
+
 #ifdef CONFIG_PCI
 #include <pci.h>
 int fdt_pci_dma_ranges(void *blob, int phb_off, struct pci_controller *hose);
@@ -152,6 +183,17 @@ int fdt_find_or_add_subnode(void *fdt, int parentoffset, const char *name);
  */
 int ft_board_setup(void *blob, bd_t *bd);
 
+/**
+ * board_fdt_chosen_bootargs() - Arbitrarily amend fdt kernel command line
+ *
+ * This is used for late modification of kernel command line arguments just
+ * before they are added into the /chosen node in flat device tree.
+ *
+ * @fdt: fdt blob
+ * @return: pointer to kernel command line arguments in memory
+ */
+char *board_fdt_chosen_bootargs(void *fdt);
+
 /*
  * The keystone2 SOC requires all 32 bit aliased addresses to be converted
  * to their 36 physical format. This has to happen after all fdt nodes
@@ -264,10 +306,15 @@ int arch_fixup_memory_node(void *blob);
 int fdt_setup_simplefb_node(void *fdt, int node, u64 base_address, u32 width,
 			    u32 height, u32 stride, const char *format);
 
+int fdt_overlay_apply_verbose(void *fdt, void *fdto);
+
 #endif /* ifdef CONFIG_OF_LIBFDT */
 
 #ifdef USE_HOSTCC
 int fdtdec_get_int(const void *blob, int node, const char *prop_name,
 		int default_val);
 #endif
+#ifdef CONFIG_FMAN_ENET
+int fdt_update_ethernet_dt(void *blob);
+#endif
 #endif /* ifndef __FDT_SUPPORT_H */
diff --git a/include/fdtdec.h b/include/fdtdec.h
index 4a0947c626..46dfcb2053 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -14,7 +14,7 @@
  * changes to support FDT are minimized.
  */
 
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <pci.h>
 
 /*
@@ -27,10 +27,12 @@ typedef phys_size_t fdt_size_t;
 #define FDT_ADDR_T_NONE (-1ULL)
 #define fdt_addr_to_cpu(reg) be64_to_cpu(reg)
 #define fdt_size_to_cpu(reg) be64_to_cpu(reg)
+typedef fdt64_t fdt_val_t;
 #else
 #define FDT_ADDR_T_NONE (-1U)
 #define fdt_addr_to_cpu(reg) be32_to_cpu(reg)
 #define fdt_size_to_cpu(reg) be32_to_cpu(reg)
+typedef fdt32_t fdt_val_t;
 #endif
 
 /* Information obtained about memory from the FDT */
@@ -45,6 +47,10 @@ struct fdt_memory {
 #define SPL_BUILD	0
 #endif
 
+#if CONFIG_IS_ENABLED(OF_PRIOR_STAGE)
+extern phys_addr_t prior_stage_fdt_address;
+#endif
+
 /*
  * Information about a resource. start is the first address of the resource
  * and end is the last address (inclusive). The length of the resource will
@@ -157,6 +163,7 @@ enum fdt_compat_id {
 	COMPAT_ALTERA_SOCFPGA_F2SDR0,           /* SoCFPGA fpga2SDRAM0 bridge */
 	COMPAT_ALTERA_SOCFPGA_F2SDR1,           /* SoCFPGA fpga2SDRAM1 bridge */
 	COMPAT_ALTERA_SOCFPGA_F2SDR2,           /* SoCFPGA fpga2SDRAM2 bridge */
+	COMPAT_ROCKCHIP_NANDC,			/* Rockchip NAND controller */
 
 	COMPAT_COUNT,
 };
diff --git a/include/flash.h b/include/flash.h
index f53fe91349..1a4e879009 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -42,11 +42,16 @@ typedef struct {
 	ushort	cfi_offset;		/* offset for cfi query			*/
 	ulong   addr_unlock1;		/* unlock address 1 for AMD flash roms  */
 	ulong   addr_unlock2;		/* unlock address 2 for AMD flash roms  */
+	uchar   sr_supported;		/* status register supported            */
 	const char *name;		/* human-readable name	                */
 #endif
 #ifdef CONFIG_MTD
 	struct mtd_info *mtd;
 #endif
+#ifdef CONFIG_CFI_FLASH			/* DM-specific parts */
+	struct udevice *dev;
+	phys_addr_t base;
+#endif
 } flash_info_t;
 
 extern flash_info_t flash_info[]; /* info for FLASH chips	*/
@@ -117,7 +122,7 @@ extern int jedec_flash_match(flash_info_t *info, ulong base);
  * return codes from flash_write():
  */
 #define ERR_OK				0
-#define ERR_TIMOUT			1
+#define ERR_TIMEOUT			1
 #define ERR_NOT_ERASED			2
 #define ERR_PROTECTED			4
 #define ERR_INVAL			8
diff --git a/include/fs.h b/include/fs.h
index 2f2aca8378..972be04115 100644
--- a/include/fs.h
+++ b/include/fs.h
@@ -26,6 +26,26 @@
  */
 int fs_set_blk_dev(const char *ifname, const char *dev_part_str, int fstype);
 
+/*
+ * fs_get_fstype - Get filesystem type on the partition previously
+ * set by fs_set_blk_dev()
+ *
+ * @fstype_name: The return the name of filesystem type
+ * @return 0 if ok with valid *fstype_name, -1 on error conditions
+ */
+int fs_get_fstype(const char **fstype_name);
+
+/*
+ * fs_set_blk_dev_with_part - Set current block device + partition
+ *
+ * Similar to fs_set_blk_dev(), but useful for cases where you already
+ * know the blk_desc and part number.
+ *
+ * Returns 0 on success.
+ * Returns non-zero if invalid partition or error accessing the disk.
+ */
+int fs_set_blk_dev_with_part(struct blk_desc *desc, int part);
+
 /*
  * Print the list of files on the partition previously set by fs_set_blk_dev(),
  * in directory "dirname".
@@ -78,6 +98,62 @@ int fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
 int fs_write(const char *filename, ulong addr, loff_t offset, loff_t len,
 	     loff_t *actwrite);
 
+/*
+ * Directory entry types, matches the subset of DT_x in posix readdir()
+ * which apply to u-boot.
+ */
+#define FS_DT_DIR  4         /* directory */
+#define FS_DT_REG  8         /* regular file */
+#define FS_DT_LNK  10        /* symbolic link */
+
+/*
+ * A directory entry, returned by fs_readdir().  Returns information
+ * about the file/directory at the current directory entry position.
+ */
+struct fs_dirent {
+	unsigned type;       /* one of FS_DT_x (not a mask) */
+	loff_t size;         /* size in bytes */
+	char name[256];
+};
+
+/* Note: fs_dir_stream should be treated as opaque to the user of fs layer */
+struct fs_dir_stream {
+	/* private to fs. layer: */
+	struct blk_desc *desc;
+	int part;
+};
+
+/*
+ * fs_opendir - Open a directory
+ *
+ * @filename: the path to directory to open
+ * @return a pointer to the directory stream or NULL on error and errno
+ *    set appropriately
+ */
+struct fs_dir_stream *fs_opendir(const char *filename);
+
+/*
+ * fs_readdir - Read the next directory entry in the directory stream.
+ *
+ * Works in an analogous way to posix readdir().  The previously returned
+ * directory entry is no longer valid after calling fs_readdir() again.
+ * After fs_closedir() is called, the returned directory entry is no
+ * longer valid.
+ *
+ * @dirs: the directory stream
+ * @return the next directory entry (only valid until next fs_readdir() or
+ *    fs_closedir() call, do not attempt to free()) or NULL if the end of
+ *    the directory is reached.
+ */
+struct fs_dirent *fs_readdir(struct fs_dir_stream *dirs);
+
+/*
+ * fs_closedir - close a directory stream
+ *
+ * @dirs: the directory stream
+ */
+void fs_closedir(struct fs_dir_stream *dirs);
+
 /*
  * Common implementation for various filesystem commands, optionally limited
  * to a specific filesystem type via the fstype parameter.
diff --git a/include/fsl_ifc.h b/include/fsl_ifc.h
index 29aa687507..4bff019177 100644
--- a/include/fsl_ifc.h
+++ b/include/fsl_ifc.h
@@ -892,8 +892,8 @@ struct fsl_ifc_nand {
 	u32 nand_erattr1;
 	u32 res19[0x10];
 	u32 nand_fsr;
-	u32 res20[0x3];
-	u32 nand_eccstat[6];
+	u32 res20[0x1];
+	u32 nand_eccstat[8];
 	u32 res21[0x1c];
 	u32 nanndcr;
 	u32 res22[0x2];
diff --git a/include/generic-phy.h b/include/generic-phy.h
index eac5adc893..ac70cf50aa 100644
--- a/include/generic-phy.h
+++ b/include/generic-phy.h
@@ -8,6 +8,40 @@
 #ifndef __GENERIC_PHY_H
 #define __GENERIC_PHY_H
 
+#include <generic-phy-dp.h>
+#include <generic-phy-mipi-dphy.h>
+#include <generic-phy-pcie.h>
+
+enum phy_mode {
+	PHY_MODE_INVALID,
+	PHY_MODE_DP,
+};
+
+/**
+ * union phy_configure_opts - Opaque generic phy configuration
+ *
+ * @mipi_dphy: Configuration set applicable for phys supporting
+ *	       the MIPI_DPHY phy mode.
+ * @dp:	       Configuration set applicable for phys supporting
+ *	       the DisplayPort protocol.
+ */
+union phy_configure_opts {
+	struct phy_configure_opts_mipi_dphy     mipi_dphy;
+	struct phy_configure_opts_dp		dp;
+	struct phy_configure_opts_pcie		pcie;
+};
+
+/**
+ * struct phy_attrs - represents phy attributes
+ * @bus_width: Data path width implemented by PHY
+ * @max_link_rate: Maximum link rate supported by PHY (in Mbps)
+ * @mode: PHY mode
+ */
+struct phy_attrs {
+	u32			bus_width;
+	u32			max_link_rate;
+	enum phy_mode		mode;
+};
 
 /**
  * struct phy - A handle to (allowing control of) a single phy port.
@@ -24,6 +58,7 @@
 struct phy {
 	struct udevice *dev;
 	unsigned long id;
+	struct phy_attrs attrs;
 };
 
 /*
@@ -33,6 +68,7 @@ struct phy {
  * @reset: reset the phy (optional).
  * @power_on: powering on the phy (optional)
  * @power_off: powering off the phy (optional)
+ * @set_mode: set the mode of the phy
  */
 struct phy_ops {
 	/**
@@ -93,6 +129,37 @@ struct phy_ops {
 	*/
 	int	(*reset)(struct phy *phy);
 
+	/**
+	 * @configure:
+	 *
+	 * Optional.
+	 *
+	 * Used to change the PHY parameters. phy_init() must have
+	 * been called on the phy.
+	 *
+	 * Returns: 0 if successful, an negative error code otherwise
+	 */
+	int	(*configure)(struct phy *phy, union phy_configure_opts *opts);
+
+	/**
+	 * @validate:
+	 *
+	 * Optional.
+	 *
+	 * Used to check that the current set of parameters can be
+	 * handled by the phy. Implementations are free to tune the
+	 * parameters passed as arguments if needed by some
+	 * implementation detail or constraints. It must not change
+	 * any actual configuration of the PHY, so calling it as many
+	 * times as deemed fit by the consumer must have no side
+	 * effect.
+	 *
+	 * Returns: 0 if the configuration can be applied, an negative
+	 * error code otherwise
+	 */
+	int	(*validate)(struct phy *phy, enum phy_mode mode, int submode,
+			    union phy_configure_opts *opts);
+
 	/**
 	* power_on - power on a PHY device
 	*
@@ -120,6 +187,8 @@ struct phy_ops {
 	* @return 0 if OK, or a negative error code
 	*/
 	int	(*power_off)(struct phy *phy);
+
+	int     (*set_mode)(struct phy *phy, enum phy_mode mode, int submode);
 };
 
 #ifdef CONFIG_PHY
@@ -148,6 +217,23 @@ int generic_phy_exit(struct phy *phy);
  */
 int generic_phy_reset(struct phy *phy);
 
+/**
+ * generic_phy_configure() - change the PHY parameters
+ *
+ * @phy:        PHY port to be configure
+ * @return 0 if OK, or a negative error code
+ */
+int generic_phy_configure(struct phy *phy, union phy_configure_opts *opts);
+
+/**
+ * generic_phy_validate() - validate the PHY parameters
+ *
+ * @phy:        PHY port to be validate
+ * @return 0 if OK, or a negative error code
+ */
+int generic_phy_validate(struct phy *phy, enum phy_mode mode, int submode,
+			 union phy_configure_opts *opts);
+
 /**
  * generic_phy_power_on() - power on a PHY device
  *
@@ -164,6 +250,14 @@ int generic_phy_power_on(struct phy *phy);
  */
 int generic_phy_power_off(struct phy *phy);
 
+int generic_phy_set_mode_ext(struct phy *phy, enum phy_mode mode, int submode);
+#define generic_phy_set_mode(phy, mode) \
+	generic_phy_set_mode_ext(phy, mode, 0)
+
+static inline enum phy_mode generic_phy_get_mode(struct phy *phy)
+{
+	return phy->attrs.mode;
+}
 
 /**
  * generic_phy_get_by_index() - Get a PHY device by integer index.
@@ -238,6 +332,19 @@ static inline int generic_phy_reset(struct phy *phy)
 	return 0;
 }
 
+static inline int generic_phy_configure(struct phy *phy,
+					union phy_configure_opts *opts)
+{
+	return 0;
+}
+
+static inline int generic_phy_validate(struct phy *phy, enum phy_mode mode,
+				       int submode,
+				       union phy_configure_opts *opts)
+{
+	return 0;
+}
+
 static inline int generic_phy_power_on(struct phy *phy)
 {
 	return 0;
@@ -260,6 +367,15 @@ static inline int generic_phy_get_by_name(struct udevice *user, const char *phy_
 	return 0;
 }
 
+static inline int generic_phy_set_mode_ext(struct phy *phy, enum phy_mode mode,
+					   int submode)
+{
+	return 0;
+}
+
+#define generic_phy_set_mode(phy, mode) \
+	generic_phy_set_mode_ext(phy, mode, 0)
+
 #endif /* CONFIG_PHY */
 
 /**
@@ -270,7 +386,7 @@ static inline int generic_phy_get_by_name(struct udevice *user, const char *phy_
  */
 static inline bool generic_phy_valid(struct phy *phy)
 {
-	return phy->dev != NULL;
+	return phy && phy->dev;
 }
 
 #endif /*__GENERIC_PHY_H */
diff --git a/include/image-sparse.h b/include/image-sparse.h
index b0cc5007f7..967bb6a897 100644
--- a/include/image-sparse.h
+++ b/include/image-sparse.h
@@ -37,4 +37,4 @@ static inline int is_sparse_image(void *buf)
 }
 
 void write_sparse_image(struct sparse_storage *info, const char *part_name,
-			void *data, unsigned sz);
+			void *data, unsigned sz, char *response);
diff --git a/include/image.h b/include/image.h
index 1f4bfda2f3..449bd36f0f 100644
--- a/include/image.h
+++ b/include/image.h
@@ -17,6 +17,7 @@
 #define __IMAGE_H__
 
 #include "compiler.h"
+#include <stdbool.h>
 #include <asm/byteorder.h>
 
 /* Define this to avoid #ifdefs later on */
@@ -29,6 +30,7 @@ struct lmb;
 #define IMAGE_ENABLE_FIT	1
 #define IMAGE_ENABLE_OF_LIBFDT	1
 #define CONFIG_FIT_VERBOSE	1 /* enable fit_format_{error,warning}() */
+#define CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT 1
 #define CONFIG_FIT_ENABLE_SHA256_SUPPORT
 #define CONFIG_SHA1
 #define CONFIG_SHA256
@@ -53,7 +55,7 @@ struct lmb;
 
 #if IMAGE_ENABLE_FIT
 #include <hash.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdt_support.h>
 # ifdef CONFIG_SPL_BUILD
 #  ifdef CONFIG_SPL_CRC32_SUPPORT
@@ -152,6 +154,8 @@ enum {
 	IH_OS_OSE,			/* OSE		*/
 	IH_OS_PLAN9,			/* Plan 9	*/
 	IH_OS_OPENRTOS,		/* OpenRTOS	*/
+	IH_OS_ARM_TRUSTED_FIRMWARE,     /* ARM Trusted Firmware */
+	IH_OS_OP_TEE,			/* OP-TEE	*/
 
 	IH_OS_COUNT,
 };
@@ -189,6 +193,7 @@ enum {
 	IH_ARCH_ARC,			/* Synopsys DesignWare ARC */
 	IH_ARCH_X86_64,			/* AMD x86_64, Intel and Via */
 	IH_ARCH_XTENSA,			/* Xtensa	*/
+	IH_ARCH_RISCV,			/* RISC-V */
 
 	IH_ARCH_COUNT,
 };
@@ -269,6 +274,8 @@ enum {
 	IH_TYPE_VYBRIDIMAGE,	/* VYBRID .vyb Image */
 	IH_TYPE_TEE,            /* Trusted Execution Environment OS Image */
 	IH_TYPE_FIRMWARE_IVT,		/* Firmware Image with HABv4 IVT */
+	IH_TYPE_PMMC,            /* TI Power Management Micro-Controller Firmware */
+	IH_TYPE_RKNAND,			/* Rockchip NAND Boot Image	*/
 
 	IH_TYPE_COUNT,			/* Number of image types */
 };
@@ -286,6 +293,7 @@ enum {
 	IH_COMP_LZMA,			/* lzma  Compression Used	*/
 	IH_COMP_LZO,			/* lzo   Compression Used	*/
 	IH_COMP_LZ4,			/* lz4   Compression Used	*/
+	IH_COMP_ZIMAGE,			/* zImage Decompressed itself   */
 
 	IH_COMP_COUNT,
 };
@@ -391,6 +399,10 @@ typedef struct bootm_headers {
 #ifdef CONFIG_LMB
 	struct lmb	lmb;		/* for memory mgmt */
 #endif
+
+#ifdef CONFIG_FIT_ROLLBACK_PROTECT
+	u32 rollback_index;
+#endif
 } bootm_headers_t;
 
 extern bootm_headers_t images;
@@ -557,7 +569,6 @@ ulong genimg_get_kernel_addr_fit(char * const img_addr,
 ulong genimg_get_kernel_addr(char * const img_addr);
 int genimg_get_format(const void *img_addr);
 int genimg_has_config(bootm_headers_t *images);
-ulong genimg_get_image(ulong img_addr);
 
 int boot_get_fpga(int argc, char * const argv[], bootm_headers_t *images,
 		uint8_t arch, const ulong *ld_start, ulong * const ld_len);
@@ -592,6 +603,31 @@ int boot_get_loadable(int argc, char * const argv[], bootm_headers_t *images,
 int boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,
 		       ulong *setup_start, ulong *setup_len);
 
+/**
+ * boot_get_fdt_fit() - load a DTB from a FIT file (applying overlays)
+ *
+ * This deals with all aspects of loading an DTB from a FIT.
+ * The correct base image based on configuration will be selected, and
+ * then any overlays specified will be applied (as present in fit_uname_configp).
+ *
+ * @param images	Boot images structure
+ * @param addr		Address of FIT in memory
+ * @param fit_unamep	On entry this is the requested image name
+ *			(e.g. "kernel@1") or NULL to use the default. On exit
+ *			points to the selected image name
+ * @param fit_uname_configp	On entry this is the requested configuration
+ *			name (e.g. "conf@1") or NULL to use the default. On
+ *			exit points to the selected configuration name.
+ * @param arch		Expected architecture (IH_ARCH_...)
+ * @param datap		Returns address of loaded image
+ * @param lenp		Returns length of loaded image
+ *
+ * @return node offset of base image, or -ve error code on error
+ */
+int boot_get_fdt_fit(bootm_headers_t *images, ulong addr,
+		   const char **fit_unamep, const char **fit_uname_configp,
+		   int arch, ulong *datap, ulong *lenp);
+
 /**
  * fit_image_load() - load an image from a FIT
  *
@@ -627,6 +663,11 @@ int fit_image_load(bootm_headers_t *images, ulong addr,
 		   int arch, int image_type, int bootstage_id,
 		   enum fit_load_op load_op, ulong *datap, ulong *lenp);
 
+int fit_image_load_index(bootm_headers_t *images, ulong addr,
+		   const char **fit_unamep, const char **fit_uname_configp,
+		   int arch, int image_type, int image_index, int bootstage_id,
+		   enum fit_load_op load_op, ulong *datap, ulong *lenp);
+
 #ifndef USE_HOSTCC
 /**
  * fit_get_node_from_config() - Look up an image a FIT by type
@@ -662,6 +703,11 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 		 bootm_headers_t *images,
 		 char **of_flat_tree, ulong *of_size);
 void boot_fdt_add_mem_rsv_regions(struct lmb *lmb, void *fdt_blob);
+#ifdef CONFIG_SYSMEM
+int boot_fdt_add_sysmem_rsv_regions(void *fdt_blob);
+#else
+static inline int boot_fdt_add_sysmem_rsv_regions(void *fdt_blob) { return 0; }
+#endif
 int boot_relocate_fdt(struct lmb *lmb, char **of_flat_tree, ulong *of_size);
 
 int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
@@ -675,6 +721,8 @@ int boot_get_kbd(struct lmb *lmb, bd_t **kbd);
 /*******************************************************************/
 /* Legacy format specific code (prefixed with image_) */
 /*******************************************************************/
+#define IMAGE_PARAM_INVAL	0xffffffff
+
 static inline uint32_t image_get_header_size(void)
 {
 	return (sizeof(image_header_t));
@@ -689,9 +737,17 @@ image_get_hdr_l(magic)		/* image_get_magic */
 image_get_hdr_l(hcrc)		/* image_get_hcrc */
 image_get_hdr_l(time)		/* image_get_time */
 image_get_hdr_l(size)		/* image_get_size */
+image_get_hdr_l(dcrc)		/* image_get_dcrc */
+#ifdef USE_HOSTCC
 image_get_hdr_l(load)		/* image_get_load */
 image_get_hdr_l(ep)		/* image_get_ep */
-image_get_hdr_l(dcrc)		/* image_get_dcrc */
+#elif defined(CONFIG_SPL_BUILD)
+image_get_hdr_l(load)		/* image_get_load */
+image_get_hdr_l(ep)		/* image_get_ep */
+#else
+uint32_t image_get_load(const image_header_t *hdr);
+uint32_t image_get_ep(const image_header_t *hdr);
+#endif
 
 #define image_get_hdr_b(f) \
 	static inline uint8_t image_get_##f(const image_header_t *hdr) \
@@ -861,29 +917,49 @@ int bootz_setup(ulong image, ulong *start, ulong *end);
 
 /* image node */
 #define FIT_DATA_PROP		"data"
+#define FIT_DATA_POSITION_PROP	"data-position"
 #define FIT_DATA_OFFSET_PROP	"data-offset"
 #define FIT_DATA_SIZE_PROP	"data-size"
 #define FIT_TIMESTAMP_PROP	"timestamp"
+#define FIT_TOTALSIZE_PROP	"totalsize"
+#define FIT_VERSION_PROP	"version"
 #define FIT_DESC_PROP		"description"
 #define FIT_ARCH_PROP		"arch"
 #define FIT_TYPE_PROP		"type"
 #define FIT_OS_PROP		"os"
 #define FIT_COMP_PROP		"compression"
+#define FIT_COMP_ADDR_PROP	"comp"
 #define FIT_ENTRY_PROP		"entry"
 #define FIT_LOAD_PROP		"load"
+#define FIT_PRE_LOAD_PROP	"preload"
+#define FIT_ROLLBACK_PROP	"rollback-index"
 
 /* configuration node */
 #define FIT_KERNEL_PROP		"kernel"
 #define FIT_RAMDISK_PROP	"ramdisk"
 #define FIT_FDT_PROP		"fdt"
+#define FIT_MULTI_PROP		"multi"
 #define FIT_LOADABLE_PROP	"loadables"
 #define FIT_DEFAULT_PROP	"default"
 #define FIT_SETUP_PROP		"setup"
 #define FIT_FPGA_PROP		"fpga"
+#define FIT_FIRMWARE_PROP	"firmware"
+#define FIT_STANDALONE_PROP	"standalone"
 
 #define FIT_MAX_HASH_LEN	HASH_MAX_DIGEST_SIZE
+#define FIT_MAX_SPL_IMAGE_SZ	SZ_2M
 
 #if IMAGE_ENABLE_FIT
+
+#ifndef IMAGE_ALIGN_SIZE
+#define IMAGE_ALIGN_SIZE	512
+#endif
+#define FIT_ALIGN(x)		(((x)+IMAGE_ALIGN_SIZE-1)&~(IMAGE_ALIGN_SIZE-1))
+
+/* fit rollback index file description magic */
+#define FIT_ROLLBACK_INDEX	0xf1de0001
+#define FIT_ROLLBACK_INDEX_SPL	0xf1de8002
+
 /* cmdline argument format parsing */
 int fit_parse_conf(const char *spec, ulong addr_curr,
 		ulong *addr, const char **conf_name);
@@ -931,24 +1007,36 @@ static inline const char *fit_get_name(const void *fit_hdr,
 
 int fit_get_desc(const void *fit, int noffset, char **desc);
 int fit_get_timestamp(const void *fit, int noffset, time_t *timestamp);
+int fit_get_totalsize(const void *fit, int *totalsize);
 
 int fit_image_get_node(const void *fit, const char *image_uname);
 int fit_image_get_os(const void *fit, int noffset, uint8_t *os);
 int fit_image_get_arch(const void *fit, int noffset, uint8_t *arch);
 int fit_image_get_type(const void *fit, int noffset, uint8_t *type);
 int fit_image_get_comp(const void *fit, int noffset, uint8_t *comp);
+bool fit_image_is_preload(const void *fit, int noffset);
 int fit_image_get_load(const void *fit, int noffset, ulong *load);
 int fit_image_get_entry(const void *fit, int noffset, ulong *entry);
+int fit_image_get_comp_addr(const void *fit, int noffset, ulong *comp);
+int fit_image_set_load(const void *fit, int noffset, ulong load);
+int fit_image_set_entry(const void *fit, int noffset, ulong entry);
 int fit_image_get_data(const void *fit, int noffset,
 				const void **data, size_t *size);
 int fit_image_get_data_offset(const void *fit, int noffset, int *data_offset);
+int fit_image_get_data_position(const void *fit, int noffset,
+				int *data_position);
 int fit_image_get_data_size(const void *fit, int noffset, int *data_size);
+int fit_image_get_rollback_index(const void *fit, int noffset, uint32_t *index);
 
 int fit_image_hash_get_algo(const void *fit, int noffset, char **algo);
 int fit_image_hash_get_value(const void *fit, int noffset, uint8_t **value,
 				int *value_len);
+int fit_image_check_hash(const void *fit, int noffset, const void *data,
+			 size_t size, char **err_msgp);
 
 int fit_set_timestamp(void *fit, int noffset, time_t timestamp);
+int fit_set_totalsize(void *fit, int noffset, int totalsize);
+int fit_set_version(void *fit, int noffset, int version);
 
 /**
  * fit_add_verification_data() - add verification data to FIT image nodes
@@ -974,9 +1062,13 @@ int fit_add_verification_data(const char *keydir, void *keydest, void *fit,
 			      const char *comment, int require_keys,
 			      const char *engine_id);
 
+int fit_image_verify_with_data(const void *fit, int image_noffset,
+			       const void *data, size_t size);
 int fit_image_verify(const void *fit, int noffset);
 int fit_config_verify(const void *fit, int conf_noffset);
 int fit_all_image_verify(const void *fit);
+int fit_board_verify_required_sigs(void);
+
 int fit_image_check_os(const void *fit, int noffset, uint8_t os);
 int fit_image_check_arch(const void *fit, int noffset, uint8_t arch);
 int fit_image_check_type(const void *fit, int noffset, uint8_t type);
@@ -986,6 +1078,11 @@ int fit_check_format(const void *fit);
 int fit_conf_find_compat(const void *fit, const void *fdt);
 int fit_conf_get_node(const void *fit, const char *conf_uname);
 
+/* __weak function */
+int fit_rollback_index_verify(const void *fit, uint32_t rollback_fd,
+			      uint32_t *fit_index, uint32_t *otp_index);
+int fit_read_otp_rollback_index(uint32_t fit_index, uint32_t *otp_index);
+
 /**
  * fit_conf_get_prop_node() - Get node refered to by a configuration
  * @fit:	FIT to check
@@ -1000,6 +1097,9 @@ int fit_conf_get_node(const void *fit, const char *conf_uname);
 int fit_conf_get_prop_node(const void *fit, int noffset,
 		const char *prop_name);
 
+int fit_conf_get_prop_node_index(const void *fit, int noffset,
+		const char *prop_name, int index);
+
 void fit_conf_print(const void *fit, int noffset, const char *p);
 
 int fit_check_ramdisk(const void *fit, int os_noffset,
@@ -1031,8 +1131,12 @@ void *image_get_host_blob(void);
 void image_set_host_blob(void *host_blob);
 # define gd_fdt_blob()		image_get_host_blob()
 #else
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_USING_KERNEL_DTB)
+# define gd_fdt_blob()		(gd->ufdt_blob)
+#else
 # define gd_fdt_blob()		(gd->fdt_blob)
 #endif
+#endif
 
 #ifdef CONFIG_FIT_BEST_MATCH
 #define IMAGE_ENABLE_BEST_MATCH	1
@@ -1048,6 +1152,7 @@ struct image_sign_info {
 	int node_offset;		/* Offset of signature node */
 	const char *name;		/* Algorithm name */
 	struct checksum_algo *checksum;	/* Checksum algorithm information */
+	struct padding_algo *padding;	/* Padding algorithm information */
 	struct crypto_algo *crypto;	/* Crypto algorithm information */
 	const void *fdt_blob;		/* FDT containing public keys */
 	int required_keynode;		/* Node offset of key to use: -1=any */
@@ -1133,6 +1238,13 @@ struct crypto_algo {
 		      uint8_t *sig, uint sig_len);
 };
 
+struct padding_algo {
+	const char *name;
+	int (*verify)(struct image_sign_info *info,
+		      uint8_t *pad, int pad_len,
+		      const uint8_t *hash, int hash_len);
+};
+
 /**
  * image_get_checksum_algo() - Look up a checksum algorithm
  *
@@ -1149,6 +1261,14 @@ struct checksum_algo *image_get_checksum_algo(const char *full_name);
  */
 struct crypto_algo *image_get_crypto_algo(const char *full_name);
 
+/**
+ * image_get_padding_algo() - Look up a padding algorithm
+ *
+ * @param name		Name of padding algorithm
+ * @return pointer to algorithm information, or NULL if not found
+ */
+struct padding_algo *image_get_padding_algo(const char *name);
+
 /**
  * fit_image_verify_required_sigs() - Verify signatures marked as 'required'
  *
@@ -1228,17 +1348,54 @@ static inline int fit_image_check_target_arch(const void *fdt, int node)
 
 #if defined(CONFIG_ANDROID_BOOT_IMAGE)
 struct andr_img_hdr;
+u32 android_bcb_msg_sector_offset(void);
+u32 android_image_major_version(void);
 int android_image_check_header(const struct andr_img_hdr *hdr);
 int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 			     ulong *os_data, ulong *os_len);
 int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
 			      ulong *rd_data, ulong *rd_len);
+int android_image_get_fdt(const struct andr_img_hdr *hdr,
+			      ulong *rd_data);
+u32 android_image_get_comp(const struct andr_img_hdr *hdr);
 ulong android_image_get_end(const struct andr_img_hdr *hdr);
 ulong android_image_get_kload(const struct andr_img_hdr *hdr);
 void android_print_contents(const struct andr_img_hdr *hdr);
 
+void android_image_set_decomp(struct andr_img_hdr *hdr, int comp);
+int android_image_parse_comp(struct andr_img_hdr *hdr, ulong *load_addr);
+int android_image_memcpy_separate(struct andr_img_hdr *hdr, ulong *load_address);
+
+struct andr_img_hdr *populate_andr_img_hdr(struct blk_desc *dev_desc,
+					   disk_partition_t *part_boot);
+
+/** android_image_load - Load an Android Image from storage.
+ *
+ * Load an Android Image based on the header size in the storage.
+ * Return the final load address, which could be a different address
+ * of argument load_address, if the Kernel Image is compressed. In case
+ * of error reading the image or if the image size needed to be read
+ * from disk is bigger than the passed |max_size| a negative number
+ * is returned.
+ *
+ * @dev_desc:		The device where to read the image from
+ * @part_info:		The partition in |dev_desc| where to read the image from
+ * @load_address:	The address where the image will be loaded
+ * @max_size:		The maximum loaded size, in bytes
+ * @return the final load address or a negative number in case of error.
+ */
+long android_image_load(struct blk_desc *dev_desc,
+			const disk_partition_t *part_info,
+			unsigned long load_address,
+			unsigned long max_size);
+
+int android_image_load_by_partname(struct blk_desc *dev_desc,
+				   const char *boot_partname,
+				   unsigned long *load_address);
 #endif /* CONFIG_ANDROID_BOOT_IMAGE */
 
+int bootm_parse_comp(const unsigned char *hdr);
+
 /**
  * board_fit_config_name_match() - Check for a matching board name
  *
@@ -1263,16 +1420,36 @@ int board_fit_config_name_match(const char *name);
  * into the FIT creation (i.e. the binary blobs would have been pre-processed
  * before being added to the FIT image).
  *
+ * @fit: fit blob
  * @image: pointer to the image start pointer
+ * @load_addr: load address pointer to image(Uncompressed)
+ * @src_addr: source address pointer to image(Compressed maybe)
  * @size: pointer to the image size
+ * @spec: special data. SPL: struct spl_load_info info, U-Boot: NULL.
+ *
  * @return no return value (failure should be handled internally)
  */
-void board_fit_image_post_process(void **p_image, size_t *p_size);
+void board_fit_image_post_process(void *fit, int node, ulong *load_addr,
+				  ulong **src_addr, size_t *size, void *spec);
+
 #endif /* CONFIG_SPL_FIT_IMAGE_POST_PROCESS */
 
 #define FDT_ERROR	((ulong)(-1))
 
 ulong fdt_getprop_u32(const void *fdt, int node, const char *prop);
+
+/**
+ * fit_find_config_node() - Find the node for the best DTB in a FIT image
+ *
+ * A FIT image contains one or more DTBs. This function parses the
+ * configurations described in the FIT images and returns the node of
+ * the first matching DTB. To check if a DTB matches a board, this function
+ * calls board_fit_config_name_match(). If no matching DTB is found, it returns
+ * the node described by the default configuration if it exists.
+ *
+ * @fdt: pointer to flat device tree
+ * @return the node if found, -ve otherwise
+ */
 int fit_find_config_node(const void *fdt);
 
 /**
diff --git a/include/jffs2/load_kernel.h b/include/jffs2/load_kernel.h
index dd0d23fa52..aad19b632f 100644
--- a/include/jffs2/load_kernel.h
+++ b/include/jffs2/load_kernel.h
@@ -17,9 +17,12 @@
 #define MTD_DEV_TYPE_NOR	0x0001
 #define MTD_DEV_TYPE_NAND	0x0002
 #define MTD_DEV_TYPE_ONENAND	0x0004
+#define MTD_DEV_TYPE_SPINAND	0x0008
 
-#define MTD_DEV_TYPE(type) ((type == MTD_DEV_TYPE_NAND) ? "nand" :	\
-			(type == MTD_DEV_TYPE_ONENAND) ? "onenand" : "nor")
+#define MTD_DEV_TYPE(type) (type == MTD_DEV_TYPE_NAND ? "nand" :	\
+			    (type == MTD_DEV_TYPE_NOR ? "nor" :		\
+			     (type == MTD_DEV_TYPE_ONENAND ? "onenand" : \
+			      "spi-nand")))				\
 
 struct mtd_device {
 	struct list_head link;
diff --git a/include/keyboard.h b/include/keyboard.h
index 9b51e20322..b00e33a59a 100644
--- a/include/keyboard.h
+++ b/include/keyboard.h
@@ -103,4 +103,15 @@ extern void pckbd_leds(unsigned char leds);
 int ps2ser_check(void);
 #endif
 
+#ifdef CONFIG_USB_KEYBOARD
+/**
+ * Check if usb keyboard receive F1~F12.
+ *
+ * @key_fn: KEY_F1, KEY_F2, KEY_F3, .... KEY_F12. (defined in input.h)
+ *
+ * return 1 if received, otherwise 0.
+ */
+extern int usb_kbd_recv_fn(int key_fn);
+#endif
+
 #endif /* __KEYBOARD_H */
diff --git a/include/linux/bitops.h b/include/linux/bitops.h
index 576b15dc53..a47f6d17bb 100644
--- a/include/linux/bitops.h
+++ b/include/linux/bitops.h
@@ -5,9 +5,16 @@
 #include <asm-generic/bitsperlong.h>
 #include <linux/compiler.h>
 
+#ifdef	__KERNEL__
 #define BIT(nr)			(1UL << (nr))
+#define BIT_ULL(nr)		(1ULL << (nr))
 #define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
 #define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
+#define BIT_ULL_MASK(nr)	(1ULL << ((nr) % BITS_PER_LONG_LONG))
+#define BIT_ULL_WORD(nr)	((nr) / BITS_PER_LONG_LONG)
+#define BITS_PER_BYTE		8
+#define BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+#endif
 
 /*
  * Create a contiguous bitmask starting at bit position @l and ending at
diff --git a/include/linux/bug.h b/include/linux/bug.h
index 920e3796c3..29f84168a3 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -1,55 +1,52 @@
 #ifndef _LINUX_BUG_H
 #define _LINUX_BUG_H
 
+#include <vsprintf.h> /* for panic() */
+#include <linux/build_bug.h>
 #include <linux/compiler.h>
-
-#ifdef __CHECKER__
-#define BUILD_BUG_ON_NOT_POWER_OF_2(n) (0)
-#define BUILD_BUG_ON_ZERO(e) (0)
-#define BUILD_BUG_ON_NULL(e) ((void*)0)
-#define BUILD_BUG_ON_INVALID(e) (0)
-#define BUILD_BUG_ON(condition) (0)
-#define BUILD_BUG() (0)
-#else /* __CHECKER__ */
-
-/* Force a compilation error if a constant expression is not a power of 2 */
-#define BUILD_BUG_ON_NOT_POWER_OF_2(n)			\
-	BUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))
-
-/* Force a compilation error if condition is true, but also produce a
-   result (of value 0 and type size_t), so the expression can be used
-   e.g. in a structure initializer (or where-ever else comma expressions
-   aren't permitted). */
-#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
-#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
-
-/*
- * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the
- * expression but avoids the generation of any code, even if that expression
- * has side-effects.
- */
-#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))
-
-/**
- * BUILD_BUG_ON - break compile if a condition is true.
- * @condition: the condition which the compiler should know is false.
- *
- * If you have some code which relies on certain constants being equal, or
- * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to
- * detect if someone changes it.
- *
- * The implementation uses gcc's reluctance to create a negative array, but gcc
- * (as of 4.4) only emits that error for obvious cases (e.g. not arguments to
- * inline functions).  Luckily, in 4.3 they added the "error" function
- * attribute just for this type of case.  Thus, we use a negative sized array
- * (should always create an error on gcc versions older than 4.4) and then call
- * an undefined function with the error attribute (should always create an
- * error on gcc 4.3 and later).  If for some reason, neither creates a
- * compile-time error, we'll still have a link-time error, which is harder to
- * track down.
- */
-#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
-
-#endif	/* __CHECKER__ */
+#include <linux/printk.h>
+
+#define BUG() do { \
+	printk("BUG at %s:%d/%s()!\n", __FILE__, __LINE__, __func__); \
+	panic("BUG!"); \
+} while (0)
+
+#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)
+
+#define WARN_ON(condition) ({						\
+	int __ret_warn_on = !!(condition);				\
+	if (unlikely(__ret_warn_on))					\
+		printk("WARNING at %s:%d/%s()!\n", __FILE__, __LINE__, __func__); \
+	unlikely(__ret_warn_on);					\
+})
+
+#define WARN(condition, format...) ({                   \
+	int __ret_warn_on = !!(condition);              \
+	if (unlikely(__ret_warn_on))                    \
+		printf(format);                  \
+	unlikely(__ret_warn_on);                    \
+})
+
+#define WARN_ON_ONCE(condition)	({				\
+	static bool __warned;					\
+	int __ret_warn_once = !!(condition);			\
+								\
+	if (unlikely(__ret_warn_once && !__warned)) {		\
+		__warned = true;				\
+		WARN_ON(1);					\
+	}							\
+	unlikely(__ret_warn_once);				\
+})
+
+#define WARN_ONCE(condition, format...) ({          \
+	static bool __warned;     \
+	int __ret_warn_once = !!(condition);            \
+								\
+	if (unlikely(__ret_warn_once && !__warned)) {       \
+		__warned = true;                \
+		WARN(1, format);                \
+	}                           \
+	unlikely(__ret_warn_once);              \
+})
 
 #endif	/* _LINUX_BUG_H */
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 2336b56cf5..96d2551277 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -5,6 +5,7 @@
 #include <linux/types.h>
 #include <linux/err.h>
 #include <linux/kernel.h>
+#include <stacktrace.h>
 
 struct unused {};
 typedef struct unused unused_t;
@@ -15,6 +16,23 @@ struct p_current{
 
 extern struct p_current *current;
 
+/* avoid conflict with <dm/device.h> */
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+#ifdef dev_vdbg
+#undef dev_vdbg
+#endif
+#ifdef dev_info
+#undef dev_info
+#endif
+#ifdef dev_err
+#undef dev_err
+#endif
+#ifdef dev_warn
+#undef dev_warn
+#endif
+
 #define dev_dbg(dev, fmt, args...)		\
 	debug(fmt, ##args)
 #define dev_vdbg(dev, fmt, args...)		\
@@ -25,17 +43,6 @@ extern struct p_current *current;
 	printf(fmt, ##args)
 #define dev_warn(dev, fmt, args...)		\
 	printf(fmt, ##args)
-#define printk	printf
-#define printk_once	printf
-
-#define KERN_EMERG
-#define KERN_ALERT
-#define KERN_CRIT
-#define KERN_ERR
-#define KERN_WARNING
-#define KERN_NOTICE
-#define KERN_INFO
-#define KERN_DEBUG
 
 #define GFP_ATOMIC ((gfp_t) 0)
 #define GFP_KERNEL ((gfp_t) 0)
@@ -98,21 +105,6 @@ static inline void kmem_cache_destroy(struct kmem_cache *cachep)
 
 #define KERNEL_VERSION(a,b,c)	(((a) << 16) + ((b) << 8) + (c))
 
-#ifndef BUG
-#define BUG() do { \
-	printf("U-Boot BUG at %s:%d!\n", __FILE__, __LINE__); \
-} while (0)
-
-#define BUG_ON(condition) do { if (condition) BUG(); } while(0)
-#endif /* BUG */
-
-#define WARN_ON(condition) ({						\
-	int __ret_warn_on = !!(condition);				\
-	if (unlikely(__ret_warn_on))					\
-		printf("WARNING in %s line %d\n", __FILE__, __LINE__);	\
-	unlikely(__ret_warn_on);					\
-})
-
 #define PAGE_SIZE	4096
 
 /* drivers/char/random.c */
@@ -202,8 +194,6 @@ typedef unsigned long blkcnt_t;
 #define init_waitqueue_head(...)	do { } while (0)
 #define wait_event_interruptible(...)	0
 #define wake_up_interruptible(...)	do { } while (0)
-#define print_hex_dump(...)		do { } while (0)
-#define dump_stack(...)			do { } while (0)
 
 #define task_pid_nr(x)			0
 #define set_freezable(...)		do { } while (0)
diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 22ab246fee..810dbeb503 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -87,6 +87,7 @@
 #define __packed	__attribute__((packed))
 #define __weak		__attribute__((weak))
 #define __alias(symbol)	__attribute__((alias(#symbol)))
+#define __cacheline_aligned __attribute__((__aligned__(CONFIG_SYS_CACHELINE_SIZE)))
 
 /*
  * it doesn't make sense on ARM (currently the only user of __naked)
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 020ad16a04..0ea6c8fcca 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -476,7 +476,8 @@ static __always_inline void __write_once_size(volatile void *p, void *res, int s
 # define __compiletime_error_fallback(condition) do { } while (0)
 #endif
 
-#define __compiletime_assert(condition, msg, prefix, suffix)		\
+#ifdef __OPTIMIZE__
+# define __compiletime_assert(condition, msg, prefix, suffix)		\
 	do {								\
 		bool __cond = !(condition);				\
 		extern void prefix ## suffix(void) __compiletime_error(msg); \
@@ -484,6 +485,9 @@ static __always_inline void __write_once_size(volatile void *p, void *res, int s
 			prefix ## suffix();				\
 		__compiletime_error_fallback(__cond);			\
 	} while (0)
+#else
+# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)
+#endif
 
 #define _compiletime_assert(condition, msg, prefix, suffix) \
 	__compiletime_assert(condition, msg, prefix, suffix)
diff --git a/include/linux/input.h b/include/linux/input.h
index 3662c9f0a7..804d5f0971 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -149,5 +149,6 @@
 #define KEY_RIGHTMETA		126
 #define KEY_COMPOSE		127
 #define KEY_FN			0x1d0
+#define KEY_REPLY               232     /* AC Reply */
 
 #endif
diff --git a/include/linux/io.h b/include/linux/io.h
index a104b7e69f..bf1ddbbaa6 100644
--- a/include/linux/io.h
+++ b/include/linux/io.h
@@ -9,6 +9,50 @@
 #include <linux/types.h>
 #include <asm/io.h>
 
+static inline u8 ioread8(const volatile void __iomem *addr)
+{
+	return readb(addr);
+}
+
+static inline u16 ioread16(const volatile void __iomem *addr)
+{
+	return readw(addr);
+}
+
+static inline u32 ioread32(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+#ifdef CONFIG_64BIT
+static inline u64 ioread64(const volatile void __iomem *addr)
+{
+	return readq(addr);
+}
+#endif /* CONFIG_64BIT */
+
+static inline void iowrite8(u8 value, volatile void __iomem *addr)
+{
+	writeb(value, addr);
+}
+
+static inline void iowrite16(u16 value, volatile void __iomem *addr)
+{
+	writew(value, addr);
+}
+
+static inline void iowrite32(u32 value, volatile void __iomem *addr)
+{
+	writel(value, addr);
+}
+
+#ifdef CONFIG_64BIT
+static inline void iowrite64(u64 value, volatile void __iomem *addr)
+{
+	writeq(value, addr);
+}
+#endif /* CONFIG_64BIT */
+
 #ifndef CONFIG_HAVE_ARCH_IOREMAP
 static inline void __iomem *ioremap(resource_size_t offset,
 				    resource_size_t size)
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 0b616713cc..87d2d9554d 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -57,6 +57,11 @@
 #define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))
 #define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
 
+#define DIV_ROUND_DOWN_ULL(ll, d) \
+	({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })
+
+#define DIV_ROUND_UP_ULL(ll, d)		DIV_ROUND_DOWN_ULL((ll) + (d) - 1, (d))
+
 #if BITS_PER_LONG == 32
 # define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)
 #else
diff --git a/include/linux/log2.h b/include/linux/log2.h
index aa1de63090..d4e32ecfc6 100644
--- a/include/linux/log2.h
+++ b/include/linux/log2.h
@@ -1,9 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /* Integer base 2 logarithm calculation
  *
  * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
  */
 
 #ifndef _LINUX_LOG2_H
@@ -12,12 +16,6 @@
 #include <linux/types.h>
 #include <linux/bitops.h>
 
-/*
- * deal with unrepresentable constant logarithms
- */
-extern __attribute__((const, noreturn))
-int ____ilog2_NaN(void);
-
 /*
  * non-constant log of base 2 calculators
  * - the arch may override these in asm/bitops.h if they can be implemented
@@ -40,19 +38,23 @@ int __ilog2_u64(u64 n)
 }
 #endif
 
-/*
- *  Determine whether some value is a power of two, where zero is
+/**
+ * is_power_of_2() - check if a value is a power of two
+ * @n: the value to check
+ *
+ * Determine whether some value is a power of two, where zero is
  * *not* considered a power of two.
+ * Return: true if @n is a power of 2, otherwise false.
  */
-
 static inline __attribute__((const))
 bool is_power_of_2(unsigned long n)
 {
 	return (n != 0 && ((n & (n - 1)) == 0));
 }
 
-/*
- * round up to nearest power of two
+/**
+ * __roundup_pow_of_two() - round up to nearest power of two
+ * @n: value to round up
  */
 static inline __attribute__((const))
 unsigned long __roundup_pow_of_two(unsigned long n)
@@ -60,8 +62,9 @@ unsigned long __roundup_pow_of_two(unsigned long n)
 	return 1UL << fls_long(n - 1);
 }
 
-/*
- * round down to nearest power of two
+/**
+ * __rounddown_pow_of_two() - round down to nearest power of two
+ * @n: value to round down
  */
 static inline __attribute__((const))
 unsigned long __rounddown_pow_of_two(unsigned long n)
@@ -70,19 +73,19 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
 }
 
 /**
- * ilog2 - log of base 2 of 32-bit or a 64-bit unsigned value
- * @n - parameter
+ * ilog2 - log base 2 of 32-bit or a 64-bit unsigned value
+ * @n: parameter
  *
  * constant-capable log of base 2 calculation
  * - this can be used to initialise global variables from constant data, hence
- *   the massive ternary operator construction
+ * the massive ternary operator construction
  *
  * selects the appropriately-sized optimised version depending on sizeof(n)
  */
 #define ilog2(n)				\
 (						\
 	__builtin_constant_p(n) ? (		\
-		(n) < 1 ? ____ilog2_NaN() :	\
+		(n) < 2 ? 0 :			\
 		(n) & (1ULL << 63) ? 63 :	\
 		(n) & (1ULL << 62) ? 62 :	\
 		(n) & (1ULL << 61) ? 61 :	\
@@ -145,10 +148,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
 		(n) & (1ULL <<  4) ?  4 :	\
 		(n) & (1ULL <<  3) ?  3 :	\
 		(n) & (1ULL <<  2) ?  2 :	\
-		(n) & (1ULL <<  1) ?  1 :	\
-		(n) & (1ULL <<  0) ?  0 :	\
-		____ilog2_NaN()			\
-				   ) :		\
+		1) :				\
 	(sizeof(n) <= 4) ?			\
 	__ilog2_u32(n) :			\
 	__ilog2_u64(n)				\
@@ -156,7 +156,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
 
 /**
  * roundup_pow_of_two - round the given value up to nearest power of two
- * @n - parameter
+ * @n: parameter
  *
  * round the given value up to the nearest power of two
  * - the result is undefined when n == 0
@@ -173,7 +173,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
 
 /**
  * rounddown_pow_of_two - round the given value down to nearest power of two
- * @n - parameter
+ * @n: parameter
  *
  * round the given value down to the nearest power of two
  * - the result is undefined when n == 0
@@ -186,6 +186,12 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
 	__rounddown_pow_of_two(n)		\
  )
 
+static inline __attribute_const__
+int __order_base_2(unsigned long n)
+{
+	return n > 1 ? ilog2(n - 1) + 1 : 0;
+}
+
 /**
  * order_base_2 - calculate the (rounded up) base 2 order of the argument
  * @n: parameter
@@ -199,7 +205,11 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
  *  ob2(5) = 3
  *  ... and so on.
  */
-
-#define order_base_2(n) ilog2(roundup_pow_of_two(n))
-
+#define order_base_2(n)				\
+(						\
+	__builtin_constant_p(n) ? (		\
+		((n) == 0 || (n) == 1) ? 0 :	\
+		ilog2((n) - 1) + 1) :		\
+	__order_base_2(n)			\
+)
 #endif /* _LINUX_LOG2_H */
diff --git a/include/linux/lzo.h b/include/linux/lzo.h
index 88687faba1..8981d04f96 100644
--- a/include/linux/lzo.h
+++ b/include/linux/lzo.h
@@ -31,6 +31,9 @@ int lzo1x_decompress_safe(const unsigned char *src, size_t src_len,
 int lzop_decompress(const unsigned char *src, size_t src_len,
 		    unsigned char *dst, size_t *dst_len);
 
+/* check if the header is valid (based on magic numbers) */
+bool lzop_is_valid_header(const unsigned char *src);
+
 /*
  * Return values (< 0 = Error)
  */
diff --git a/include/linux/mii.h b/include/linux/mii.h
index 19afb746cd..21db032340 100644
--- a/include/linux/mii.h
+++ b/include/linux/mii.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 /*
  * linux/mii.h: definitions for MII-compatible transceivers
  * Originally drivers/net/sunhme.h.
@@ -9,53 +10,55 @@
 #define __LINUX_MII_H__
 
 /* Generic MII registers. */
-
-#define MII_BMCR	    0x00	/* Basic mode control register */
-#define MII_BMSR	    0x01	/* Basic mode status register  */
-#define MII_PHYSID1	    0x02	/* PHYS ID 1		       */
-#define MII_PHYSID2	    0x03	/* PHYS ID 2		       */
-#define MII_ADVERTISE	    0x04	/* Advertisement control reg   */
-#define MII_LPA		    0x05	/* Link partner ability reg    */
-#define MII_EXPANSION	    0x06	/* Expansion register	       */
-#define MII_CTRL1000	    0x09	/* 1000BASE-T control	       */
-#define MII_STAT1000	    0x0a	/* 1000BASE-T status	       */
-#define MII_ESTATUS	    0x0f	/* Extended Status */
-#define MII_DCOUNTER	    0x12	/* Disconnect counter	       */
-#define MII_FCSCOUNTER	    0x13	/* False carrier counter       */
-#define MII_NWAYTEST	    0x14	/* N-way auto-neg test reg     */
-#define MII_RERRCOUNTER     0x15	/* Receive error counter       */
-#define MII_SREVISION	    0x16	/* Silicon revision	       */
-#define MII_RESV1	    0x17	/* Reserved...		       */
-#define MII_LBRERROR	    0x18	/* Lpback, rx, bypass error    */
-#define MII_PHYADDR	    0x19	/* PHY address		       */
-#define MII_RESV2	    0x1a	/* Reserved...		       */
-#define MII_TPISTATUS	    0x1b	/* TPI status for 10mbps       */
-#define MII_NCONFIG	    0x1c	/* Network interface config    */
+#define MII_BMCR		0x00	/* Basic mode control register */
+#define MII_BMSR		0x01	/* Basic mode status register  */
+#define MII_PHYSID1		0x02	/* PHYS ID 1                   */
+#define MII_PHYSID2		0x03	/* PHYS ID 2                   */
+#define MII_ADVERTISE		0x04	/* Advertisement control reg   */
+#define MII_LPA			0x05	/* Link partner ability reg    */
+#define MII_EXPANSION		0x06	/* Expansion register          */
+#define MII_CTRL1000		0x09	/* 1000BASE-T control          */
+#define MII_STAT1000		0x0a	/* 1000BASE-T status           */
+#define MII_MMD_CTRL		0x0d	/* MMD Access Control Register */
+#define MII_MMD_DATA		0x0e	/* MMD Access Data Register */
+#define MII_ESTATUS		0x0f	/* Extended Status             */
+#define MII_DCOUNTER		0x12	/* Disconnect counter          */
+#define MII_FCSCOUNTER		0x13	/* False carrier counter       */
+#define MII_NWAYTEST		0x14	/* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER		0x15	/* Receive error counter       */
+#define MII_SREVISION		0x16	/* Silicon revision            */
+#define MII_RESV1		0x17	/* Reserved...                 */
+#define MII_LBRERROR		0x18	/* Lpback, rx, bypass error    */
+#define MII_PHYADDR		0x19	/* PHY address                 */
+#define MII_RESV2		0x1a	/* Reserved...                 */
+#define MII_TPISTATUS		0x1b	/* TPI status for 10mbps       */
+#define MII_NCONFIG		0x1c	/* Network interface config    */
 
 /* Basic mode control register. */
-#define BMCR_RESV		0x003f	/* Unused...		       */
-#define BMCR_SPEED1000		0x0040	/* MSB of Speed (1000)	       */
-#define BMCR_CTST		0x0080	/* Collision test	       */
-#define BMCR_FULLDPLX		0x0100	/* Full duplex		       */
+#define BMCR_RESV		0x003f	/* Unused...                   */
+#define BMCR_SPEED1000		0x0040	/* MSB of Speed (1000)         */
+#define BMCR_CTST		0x0080	/* Collision test              */
+#define BMCR_FULLDPLX		0x0100	/* Full duplex                 */
 #define BMCR_ANRESTART		0x0200	/* Auto negotiation restart    */
-#define BMCR_ISOLATE		0x0400	/* Disconnect DP83840 from MII */
-#define BMCR_PDOWN		0x0800	/* Powerdown the DP83840       */
+#define BMCR_ISOLATE		0x0400	/* Isolate data paths from MII */
+#define BMCR_PDOWN		0x0800	/* Enable low power state      */
 #define BMCR_ANENABLE		0x1000	/* Enable auto negotiation     */
-#define BMCR_SPEED100		0x2000	/* Select 100Mbps	       */
-#define BMCR_LOOPBACK		0x4000	/* TXD loopback bits	       */
-#define BMCR_RESET		0x8000	/* Reset the DP83840	       */
+#define BMCR_SPEED100		0x2000	/* Select 100Mbps              */
+#define BMCR_LOOPBACK		0x4000	/* TXD loopback bits           */
+#define BMCR_RESET		0x8000	/* Reset to default state      */
+#define BMCR_SPEED10		0x0000	/* Select 10Mbps               */
 
 /* Basic mode status register. */
-#define BMSR_ERCAP		0x0001	/* Ext-reg capability	       */
-#define BMSR_JCD		0x0002	/* Jabber detected	       */
-#define BMSR_LSTATUS		0x0004	/* Link status		       */
+#define BMSR_ERCAP		0x0001	/* Ext-reg capability          */
+#define BMSR_JCD		0x0002	/* Jabber detected             */
+#define BMSR_LSTATUS		0x0004	/* Link status                 */
 #define BMSR_ANEGCAPABLE	0x0008	/* Able to do auto-negotiation */
 #define BMSR_RFAULT		0x0010	/* Remote fault detected       */
 #define BMSR_ANEGCOMPLETE	0x0020	/* Auto-negotiation complete   */
-#define BMSR_RESV		0x00c0	/* Unused...		       */
-#define BMSR_ESTATEN		0x0100	/* Extended Status in R15 */
-#define BMSR_100HALF2		0x0200	/* Can do 100BASE-T2 HDX */
-#define BMSR_100FULL2		0x0400	/* Can do 100BASE-T2 FDX */
+#define BMSR_RESV		0x00c0	/* Unused...                   */
+#define BMSR_ESTATEN		0x0100	/* Extended Status in R15      */
+#define BMSR_100HALF2		0x0200	/* Can do 100BASE-T2 HDX       */
+#define BMSR_100FULL2		0x0400	/* Can do 100BASE-T2 FDX       */
 #define BMSR_10HALF		0x0800	/* Can do 10mbps, half-duplex  */
 #define BMSR_10FULL		0x1000	/* Can do 10mbps, full-duplex  */
 #define BMSR_100HALF		0x2000	/* Can do 100mbps, half-duplex */
@@ -63,7 +66,7 @@
 #define BMSR_100BASE4		0x8000	/* Can do 100mbps, 4k packets  */
 
 /* Advertisement control register. */
-#define ADVERTISE_SLCT		0x001f	/* Selector bits	       */
+#define ADVERTISE_SLCT		0x001f	/* Selector bits               */
 #define ADVERTISE_CSMA		0x0001	/* Only selector supported     */
 #define ADVERTISE_10HALF	0x0020	/* Try for 10mbps half-duplex  */
 #define ADVERTISE_1000XFULL	0x0020	/* Try for 1000BASE-X full-duplex */
@@ -72,19 +75,19 @@
 #define ADVERTISE_100HALF	0x0080	/* Try for 100mbps half-duplex */
 #define ADVERTISE_1000XPAUSE	0x0080	/* Try for 1000BASE-X pause    */
 #define ADVERTISE_100FULL	0x0100	/* Try for 100mbps full-duplex */
-#define ADVERTISE_1000XPSE_ASYM 0x0100	/* Try for 1000BASE-X asym pause */
+#define ADVERTISE_1000XPSE_ASYM	0x0100	/* Try for 1000BASE-X asym pause */
 #define ADVERTISE_100BASE4	0x0200	/* Try for 100mbps 4k packets  */
-#define ADVERTISE_PAUSE_CAP	0x0400	/* Try for pause	       */
+#define ADVERTISE_PAUSE_CAP	0x0400	/* Try for pause               */
 #define ADVERTISE_PAUSE_ASYM	0x0800	/* Try for asymetric pause     */
-#define ADVERTISE_RESV		0x1000	/* Unused...		       */
+#define ADVERTISE_RESV		0x1000	/* Unused...                   */
 #define ADVERTISE_RFAULT	0x2000	/* Say we can detect faults    */
 #define ADVERTISE_LPACK		0x4000	/* Ack link partners response  */
-#define ADVERTISE_NPAGE		0x8000	/* Next page bit	       */
+#define ADVERTISE_NPAGE		0x8000	/* Next page bit               */
 
-#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
-			ADVERTISE_CSMA)
-#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
-		       ADVERTISE_100HALF | ADVERTISE_100FULL)
+#define ADVERTISE_FULL		(ADVERTISE_100FULL | ADVERTISE_10FULL | \
+				 ADVERTISE_CSMA)
+#define ADVERTISE_ALL		(ADVERTISE_10HALF | ADVERTISE_10FULL | \
+				 ADVERTISE_100HALF | ADVERTISE_100FULL)
 
 /* Link partner ability register. */
 #define LPA_SLCT		0x001f	/* Same as advertise selector  */
@@ -97,12 +100,12 @@
 #define LPA_100FULL		0x0100	/* Can do 100mbps full-duplex  */
 #define LPA_1000XPAUSE_ASYM	0x0100	/* Can do 1000BASE-X pause asym*/
 #define LPA_100BASE4		0x0200	/* Can do 100mbps 4k packets   */
-#define LPA_PAUSE_CAP		0x0400	/* Can pause		       */
+#define LPA_PAUSE_CAP		0x0400	/* Can pause                   */
 #define LPA_PAUSE_ASYM		0x0800	/* Can pause asymetrically     */
-#define LPA_RESV		0x1000	/* Unused...		       */
+#define LPA_RESV		0x1000	/* Unused...                   */
 #define LPA_RFAULT		0x2000	/* Link partner faulted        */
 #define LPA_LPACK		0x4000	/* Link partner acked us       */
-#define LPA_NPAGE		0x8000	/* Next page bit	       */
+#define LPA_NPAGE		0x8000	/* Next page bit               */
 
 #define LPA_DUPLEX		(LPA_10FULL | LPA_100FULL)
 #define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
@@ -113,21 +116,23 @@
 #define EXPANSION_ENABLENPAGE	0x0004	/* This enables npage words    */
 #define EXPANSION_NPCAPABLE	0x0008	/* Link partner supports npage */
 #define EXPANSION_MFAULTS	0x0010	/* Multiple faults detected    */
-#define EXPANSION_RESV		0xffe0	/* Unused...		       */
+#define EXPANSION_RESV		0xffe0	/* Unused...                   */
 
 #define ESTATUS_1000_XFULL	0x8000	/* Can do 1000BX Full */
 #define ESTATUS_1000_XHALF	0x4000	/* Can do 1000BX Half */
-#define ESTATUS_1000_TFULL	0x2000	/* Can do 1000BT Full */
-#define ESTATUS_1000_THALF	0x1000	/* Can do 1000BT Half */
+#define ESTATUS_1000_TFULL	0x2000	/* Can do 1000BT Full          */
+#define ESTATUS_1000_THALF	0x1000	/* Can do 1000BT Half          */
 
 /* N-way test register. */
-#define NWAYTEST_RESV1		0x00ff	/* Unused...		       */
+#define NWAYTEST_RESV1		0x00ff	/* Unused...                   */
 #define NWAYTEST_LOOPBACK	0x0100	/* Enable loopback for N-way   */
-#define NWAYTEST_RESV2		0xfe00	/* Unused...		       */
+#define NWAYTEST_RESV2		0xfe00	/* Unused...                   */
 
 /* 1000BASE-T Control register */
-#define ADVERTISE_1000FULL	0x0200	/* Advertise 1000BASE-T full duplex */
-#define ADVERTISE_1000HALF	0x0100	/* Advertise 1000BASE-T half duplex */
+#define ADVERTISE_1000FULL	0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF	0x0100  /* Advertise 1000BASE-T half duplex */
+#define CTL1000_AS_MASTER	0x0800
+#define CTL1000_ENABLE_MASTER	0x1000
 
 /* 1000BASE-T Status register */
 #define LPA_1000LOCALRXOK	0x2000	/* Link partner local receiver status */
@@ -139,6 +144,13 @@
 #define FLOW_CTRL_TX		0x01
 #define FLOW_CTRL_RX		0x02
 
+/* MMD Access Control register fields */
+#define MII_MMD_CTRL_DEVAD_MASK	0x1f	/* Mask MMD DEVAD*/
+#define MII_MMD_CTRL_ADDR	0x0000	/* Address */
+#define MII_MMD_CTRL_NOINCR	0x4000	/* no post increment */
+#define MII_MMD_CTRL_INCR_RDWT	0x8000	/* post increment on reads & writes */
+#define MII_MMD_CTRL_INCR_ON_WT	0xC000	/* post increment on writes only */
+
 /**
  * mii_nway_result
  * @negotiated: value of MII ANAR and'd with ANLPAR
diff --git a/include/linux/mtd/fsl_upm.h b/include/linux/mtd/fsl_upm.h
index 0a949bca0d..a023860e7b 100644
--- a/include/linux/mtd/fsl_upm.h
+++ b/include/linux/mtd/fsl_upm.h
@@ -10,7 +10,7 @@
 #ifndef __LINUX_MTD_NAND_FSL_UPM
 #define __LINUX_MTD_NAND_FSL_UPM
 
-#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
 
 #define FSL_UPM_WAIT_RUN_PATTERN  0x1
 #define FSL_UPM_WAIT_WRITE_BYTE   0x2
diff --git a/include/linux/mtd/fsmc_nand.h b/include/linux/mtd/fsmc_nand.h
index f0f77270af..bc3db030d0 100644
--- a/include/linux/mtd/fsmc_nand.h
+++ b/include/linux/mtd/fsmc_nand.h
@@ -8,7 +8,7 @@
 #ifndef __FSMC_NAND_H__
 #define __FSMC_NAND_H__
 
-#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
 
 struct fsmc_regs {
 	u32 ctrl;			/* 0x00 */
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 1fd17c303a..b848c0da3d 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -21,7 +21,11 @@
 #include <linux/compat.h>
 #include <mtd/mtd-abi.h>
 #include <linux/errno.h>
+#include <linux/list.h>
 #include <div64.h>
+#if IS_ENABLED(CONFIG_DM)
+#include <dm/device.h>
+#endif
 
 #define MAX_MTD_DEVICES 32
 #endif
@@ -103,6 +107,36 @@ struct mtd_oob_ops {
 #else
 #define MTD_MAX_ECCPOS_ENTRIES_LARGE	680
 #endif
+/**
+ * struct mtd_oob_region - oob region definition
+ * @offset: region offset
+ * @length: region length
+ *
+ * This structure describes a region of the OOB area, and is used
+ * to retrieve ECC or free bytes sections.
+ * Each section is defined by an offset within the OOB area and a
+ * length.
+ */
+struct mtd_oob_region {
+	u32 offset;
+	u32 length;
+};
+
+/*
+ * struct mtd_ooblayout_ops - NAND OOB layout operations
+ * @ecc: function returning an ECC region in the OOB area.
+ *	 Should return -ERANGE if %section exceeds the total number of
+ *	 ECC sections.
+ * @free: function returning a free region in the OOB area.
+ *	  Should return -ERANGE if %section exceeds the total number of
+ *	  free sections.
+ */
+struct mtd_ooblayout_ops {
+	int (*ecc)(struct mtd_info *mtd, int section,
+		   struct mtd_oob_region *oobecc);
+	int (*rfree)(struct mtd_info *mtd, int section,
+		     struct mtd_oob_region *oobfree);
+};
 
 /*
  * Internal ECC layout control structure. For historical reasons, there is a
@@ -179,6 +213,9 @@ struct mtd_info {
 #endif
 	int index;
 
+	/* OOB layout description */
+	const struct mtd_ooblayout_ops *ooblayout;
+
 	/* ECC layout structure pointer - read only! */
 	struct nand_ecclayout *ecclayout;
 
@@ -276,8 +313,90 @@ struct mtd_info {
 	struct udevice *dev;
 #endif
 	int usecount;
+
+	/* MTD devices do not have any parent. MTD partitions do. */
+	struct mtd_info *parent;
+
+	/*
+	 * Offset of the partition relatively to the parent offset.
+	 * Is 0 for real MTD devices (ie. not partitions).
+	 */
+	u64 offset;
+
+	/*
+	 * List node used to add an MTD partition to the parent
+	 * partition list.
+	 */
+	struct list_head node;
+
+	/*
+	 * List of partitions attached to this MTD device (the parent
+	 * MTD device can itself be a partition).
+	 */
+	struct list_head partitions;
 };
 
+#if IS_ENABLED(CONFIG_DM)
+static inline void mtd_set_of_node(struct mtd_info *mtd,
+				   const struct device_node *np)
+{
+	mtd->dev->node.np = np;
+}
+
+static inline const struct device_node *mtd_get_of_node(struct mtd_info *mtd)
+{
+	return mtd->dev->node.np;
+}
+#else
+struct device_node;
+
+static inline void mtd_set_of_node(struct mtd_info *mtd,
+				   const struct device_node *np)
+{
+}
+
+static inline const struct device_node *mtd_get_of_node(struct mtd_info *mtd)
+{
+	return NULL;
+}
+#endif
+
+static inline bool mtd_is_partition(const struct mtd_info *mtd)
+{
+	return mtd->parent;
+}
+
+static inline bool mtd_has_partitions(const struct mtd_info *mtd)
+{
+	return !list_empty(&mtd->partitions);
+}
+
+bool mtd_partitions_used(struct mtd_info *master);
+
+int mtd_ooblayout_ecc(struct mtd_info *mtd, int section,
+		      struct mtd_oob_region *oobecc);
+int mtd_ooblayout_find_eccregion(struct mtd_info *mtd, int eccbyte,
+				 int *section,
+				 struct mtd_oob_region *oobregion);
+int mtd_ooblayout_get_eccbytes(struct mtd_info *mtd, u8 *eccbuf,
+			       const u8 *oobbuf, int start, int nbytes);
+int mtd_ooblayout_set_eccbytes(struct mtd_info *mtd, const u8 *eccbuf,
+			       u8 *oobbuf, int start, int nbytes);
+int mtd_ooblayout_free(struct mtd_info *mtd, int section,
+		       struct mtd_oob_region *oobfree);
+int mtd_ooblayout_get_databytes(struct mtd_info *mtd, u8 *databuf,
+				const u8 *oobbuf, int start, int nbytes);
+int mtd_ooblayout_set_databytes(struct mtd_info *mtd, const u8 *databuf,
+				u8 *oobbuf, int start, int nbytes);
+int mtd_ooblayout_count_freebytes(struct mtd_info *mtd);
+int mtd_ooblayout_count_eccbytes(struct mtd_info *mtd);
+
+static inline void mtd_set_ooblayout(struct mtd_info *mtd,
+				     const struct mtd_ooblayout_ops *ooblayout)
+{
+	mtd->ooblayout = ooblayout;
+}
+
 static inline int mtd_oobavail(struct mtd_info *mtd, struct mtd_oob_ops *ops)
 {
 	return ops->mode == MTD_OPS_AUTO_OOB ? mtd->oobavail : mtd->oobsize;
@@ -299,17 +418,7 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		    const u_char *buf);
 
 int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops);
-
-static inline int mtd_write_oob(struct mtd_info *mtd, loff_t to,
-				struct mtd_oob_ops *ops)
-{
-	ops->retlen = ops->oobretlen = 0;
-	if (!mtd->_write_oob)
-		return -EOPNOTSUPP;
-	if (!(mtd->flags & MTD_WRITEABLE))
-		return -EROFS;
-	return mtd->_write_oob(mtd, to, ops);
-}
+int mtd_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops);
 
 int mtd_get_fact_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,
 			   struct otp_info *buf);
@@ -452,28 +561,20 @@ static inline void mtd_erase_callback(struct erase_info *instr)
 #define MTD_DEBUG_LEVEL3	(3)	/* Noisy   */
 
 #ifdef CONFIG_MTD_DEBUG
-#define pr_debug(args...)	MTDDEBUG(MTD_DEBUG_LEVEL0, args)
 #define MTDDEBUG(n, args...)				\
 	do {						\
 		if (n <= CONFIG_MTD_DEBUG_VERBOSE)	\
 			printk(KERN_INFO args);		\
 	} while(0)
 #else /* CONFIG_MTD_DEBUG */
-#define pr_debug(args...)
 #define MTDDEBUG(n, args...)				\
 	do {						\
 		if (0)					\
 			printk(KERN_INFO args);		\
 	} while(0)
 #endif /* CONFIG_MTD_DEBUG */
-#define pr_info(args...)	MTDDEBUG(MTD_DEBUG_LEVEL0, args)
-#define pr_warn(args...)	MTDDEBUG(MTD_DEBUG_LEVEL0, args)
-#define pr_err(args...)		MTDDEBUG(MTD_DEBUG_LEVEL0, args)
-#define pr_crit(args...)	MTDDEBUG(MTD_DEBUG_LEVEL0, args)
-#define pr_cont(args...)	MTDDEBUG(MTD_DEBUG_LEVEL0, args)
-#define pr_notice(args...)	MTDDEBUG(MTD_DEBUG_LEVEL0, args)
 #endif
- 
+
 static inline int mtd_is_bitflip(int err) {
 	return err == -EUCLEAN;
 }
@@ -492,8 +593,29 @@ unsigned mtd_mmap_capabilities(struct mtd_info *mtd);
 /* drivers/mtd/mtdcore.h */
 int add_mtd_device(struct mtd_info *mtd);
 int del_mtd_device(struct mtd_info *mtd);
+
+#ifdef CONFIG_MTD_PARTITIONS
 int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
 int del_mtd_partitions(struct mtd_info *);
+#else
+static inline int add_mtd_partitions(struct mtd_info *mtd,
+				     const struct mtd_partition *parts,
+				     int nparts)
+{
+	return 0;
+}
+
+static inline int del_mtd_partitions(struct mtd_info *mtd)
+{
+	return 0;
+}
+#endif
+
+struct mtd_info *__mtd_next_device(int i);
+#define mtd_for_each_device(mtd)			\
+	for ((mtd) = __mtd_next_device(0);		\
+	     (mtd) != NULL;				\
+	     (mtd) = __mtd_next_device(mtd->index + 1))
 
 int mtd_arg_off(const char *arg, int *idx, loff_t *off, loff_t *size,
 		loff_t *maxsize, int devtype, uint64_t chipsize);
@@ -505,5 +627,11 @@ int mtd_arg_off_size(int argc, char *const argv[], int *idx, loff_t *off,
 void mtd_get_len_incl_bad(struct mtd_info *mtd, uint64_t offset,
 			  const uint64_t length, uint64_t *len_incl_bad,
 			  int *truncated);
+bool mtd_dev_list_updated(void);
+
+/* drivers/mtd/mtd_uboot.c */
+int mtd_search_alternate_name(const char *mtdname, char *altname,
+			      unsigned int max_len);
+
 #endif
 #endif /* __MTD_MTD_H__ */
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d55807b2e2..e37ea54278 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1,1104 +1,744 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- *  linux/include/linux/mtd/nand.h
+ *  Copyright 2017 - Free Electrons
  *
- *  Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org>
- *                        Steven J. Hill <sjhill@realitydiluted.com>
- *		          Thomas Gleixner <tglx@linutronix.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Info:
- *	Contains standard defines and IDs for NAND flash devices
- *
- * Changelog:
- *	See git changelog.
+ *  Authors:
+ *	Boris Brezillon <boris.brezillon@free-electrons.com>
+ *	Peter Pan <peterpandong@micron.com>
  */
+
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
 
-#include <config.h>
-
-#include <linux/compat.h>
 #include <linux/mtd/mtd.h>
-#include <linux/mtd/flashchip.h>
-#include <linux/mtd/bbm.h>
-
-struct mtd_info;
-struct nand_flash_dev;
-struct device_node;
 
-/* Scan and identify a NAND device */
-extern int nand_scan(struct mtd_info *mtd, int max_chips);
-/*
- * Separate phases of nand_scan(), allowing board driver to intervene
- * and override command or ECC setup according to flash type.
+/**
+ * struct nand_memory_organization - Memory organization structure
+ * @bits_per_cell: number of bits per NAND cell
+ * @pagesize: page size
+ * @oobsize: OOB area size
+ * @pages_per_eraseblock: number of pages per eraseblock
+ * @eraseblocks_per_lun: number of eraseblocks per LUN (Logical Unit Number)
+ * @planes_per_lun: number of planes per LUN
+ * @luns_per_target: number of LUN per target (target is a synonym for die)
+ * @ntargets: total number of targets exposed by the NAND device
  */
-extern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
-			   struct nand_flash_dev *table);
-extern int nand_scan_tail(struct mtd_info *mtd);
-
-/* Free resources held by the NAND device */
-extern void nand_release(struct mtd_info *mtd);
+struct nand_memory_organization {
+	unsigned int bits_per_cell;
+	unsigned int pagesize;
+	unsigned int oobsize;
+	unsigned int pages_per_eraseblock;
+	unsigned int eraseblocks_per_lun;
+	unsigned int planes_per_lun;
+	unsigned int luns_per_target;
+	unsigned int ntargets;
+};
 
-/* Internal helper for board drivers which need to override command function */
-extern void nand_wait_ready(struct mtd_info *mtd);
+#define NAND_MEMORG(bpc, ps, os, ppe, epl, ppl, lpt, nt)	\
+	{							\
+		.bits_per_cell = (bpc),				\
+		.pagesize = (ps),				\
+		.oobsize = (os),				\
+		.pages_per_eraseblock = (ppe),			\
+		.eraseblocks_per_lun = (epl),			\
+		.planes_per_lun = (ppl),			\
+		.luns_per_target = (lpt),			\
+		.ntargets = (nt),				\
+	}
 
-/*
- * This constant declares the max. oobsize / page, which
- * is supported now. If you add a chip with bigger oobsize/page
- * adjust this accordingly.
+/**
+ * struct nand_row_converter - Information needed to convert an absolute offset
+ *			       into a row address
+ * @lun_addr_shift: position of the LUN identifier in the row address
+ * @eraseblock_addr_shift: position of the eraseblock identifier in the row
+ *			   address
  */
-#define NAND_MAX_OOBSIZE       1664
-#define NAND_MAX_PAGESIZE      16384
+struct nand_row_converter {
+	unsigned int lun_addr_shift;
+	unsigned int eraseblock_addr_shift;
+};
 
-/*
- * Constants for hardware specific CLE/ALE/NCE function
+/**
+ * struct nand_pos - NAND position object
+ * @target: the NAND target/die
+ * @lun: the LUN identifier
+ * @plane: the plane within the LUN
+ * @eraseblock: the eraseblock within the LUN
+ * @page: the page within the LUN
  *
- * These are bits which can be or'ed to set/clear multiple
- * bits in one go.
- */
-/* Select the chip by setting nCE to low */
-#define NAND_NCE		0x01
-/* Select the command latch by setting CLE to high */
-#define NAND_CLE		0x02
-/* Select the address latch by setting ALE to high */
-#define NAND_ALE		0x04
-
-#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)
-#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)
-#define NAND_CTRL_CHANGE	0x80
-
-/*
- * Standard NAND flash commands
- */
-#define NAND_CMD_READ0		0
-#define NAND_CMD_READ1		1
-#define NAND_CMD_RNDOUT		5
-#define NAND_CMD_PAGEPROG	0x10
-#define NAND_CMD_READOOB	0x50
-#define NAND_CMD_ERASE1		0x60
-#define NAND_CMD_STATUS		0x70
-#define NAND_CMD_SEQIN		0x80
-#define NAND_CMD_RNDIN		0x85
-#define NAND_CMD_READID		0x90
-#define NAND_CMD_ERASE2		0xd0
-#define NAND_CMD_PARAM		0xec
-#define NAND_CMD_GET_FEATURES	0xee
-#define NAND_CMD_SET_FEATURES	0xef
-#define NAND_CMD_RESET		0xff
-
-#define NAND_CMD_LOCK		0x2a
-#define NAND_CMD_UNLOCK1	0x23
-#define NAND_CMD_UNLOCK2	0x24
-
-/* Extended commands for large page devices */
-#define NAND_CMD_READSTART	0x30
-#define NAND_CMD_RNDOUTSTART	0xE0
-#define NAND_CMD_CACHEDPROG	0x15
-
-/* Extended commands for AG-AND device */
-/*
- * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
- *       there is no way to distinguish that from NAND_CMD_READ0
- *       until the remaining sequence of commands has been completed
- *       so add a high order bit and mask it off in the command.
+ * These information are usually used by specific sub-layers to select the
+ * appropriate target/die and generate a row address to pass to the device.
  */
-#define NAND_CMD_DEPLETE1	0x100
-#define NAND_CMD_DEPLETE2	0x38
-#define NAND_CMD_STATUS_MULTI	0x71
-#define NAND_CMD_STATUS_ERROR	0x72
-/* multi-bank error status (banks 0-3) */
-#define NAND_CMD_STATUS_ERROR0	0x73
-#define NAND_CMD_STATUS_ERROR1	0x74
-#define NAND_CMD_STATUS_ERROR2	0x75
-#define NAND_CMD_STATUS_ERROR3	0x76
-#define NAND_CMD_STATUS_RESET	0x7f
-#define NAND_CMD_STATUS_CLEAR	0xff
-
-#define NAND_CMD_NONE		-1
-
-/* Status bits */
-#define NAND_STATUS_FAIL	0x01
-#define NAND_STATUS_FAIL_N1	0x02
-#define NAND_STATUS_TRUE_READY	0x20
-#define NAND_STATUS_READY	0x40
-#define NAND_STATUS_WP		0x80
+struct nand_pos {
+	unsigned int target;
+	unsigned int lun;
+	unsigned int plane;
+	unsigned int eraseblock;
+	unsigned int page;
+};
 
-/*
- * Constants for ECC_MODES
+/**
+ * struct nand_page_io_req - NAND I/O request object
+ * @pos: the position this I/O request is targeting
+ * @dataoffs: the offset within the page
+ * @datalen: number of data bytes to read from/write to this page
+ * @databuf: buffer to store data in or get data from
+ * @ooboffs: the OOB offset within the page
+ * @ooblen: the number of OOB bytes to read from/write to this page
+ * @oobbuf: buffer to store OOB data in or get OOB data from
+ * @mode: one of the %MTD_OPS_XXX mode
+ *
+ * This object is used to pass per-page I/O requests to NAND sub-layers. This
+ * way all useful information are already formatted in a useful way and
+ * specific NAND layers can focus on translating these information into
+ * specific commands/operations.
  */
-typedef enum {
-	NAND_ECC_NONE,
-	NAND_ECC_SOFT,
-	NAND_ECC_HW,
-	NAND_ECC_HW_SYNDROME,
-	NAND_ECC_HW_OOB_FIRST,
-	NAND_ECC_SOFT_BCH,
-} nand_ecc_modes_t;
+struct nand_page_io_req {
+	struct nand_pos pos;
+	unsigned int dataoffs;
+	unsigned int datalen;
+	union {
+		const void *out;
+		void *in;
+	} databuf;
+	unsigned int ooboffs;
+	unsigned int ooblen;
+	union {
+		const void *out;
+		void *in;
+	} oobbuf;
+	int mode;
+};
 
-/*
- * Constants for Hardware ECC
+/**
+ * struct nand_ecc_req - NAND ECC requirements
+ * @strength: ECC strength
+ * @step_size: ECC step/block size
  */
-/* Reset Hardware ECC for read */
-#define NAND_ECC_READ		0
-/* Reset Hardware ECC for write */
-#define NAND_ECC_WRITE		1
-/* Enable Hardware ECC before syndrome is read back from flash */
-#define NAND_ECC_READSYN	2
+struct nand_ecc_req {
+	unsigned int strength;
+	unsigned int step_size;
+};
 
-/*
- * Enable generic NAND 'page erased' check. This check is only done when
- * ecc.correct() returns -EBADMSG.
- * Set this flag if your implementation does not fix bitflips in erased
- * pages and you want to rely on the default implementation.
- */
-#define NAND_ECC_GENERIC_ERASED_CHECK	BIT(0)
+#define NAND_ECCREQ(str, stp) { .strength = (str), .step_size = (stp) }
 
-/* Bit mask for flags passed to do_nand_read_ecc */
-#define NAND_GET_DEVICE		0x80
+/* nand_bbt option */
+#define NANDDEV_BBT_USE_FLASH		BIT(0)
+#define NANDDEV_BBT_SCANNED		BIT(1)
 
+/* The maximum number of blocks to scan for a bbt */
+#define NANDDEV_BBT_SCAN_MAXBLOCKS	4
 
-/*
- * Option constants for bizarre disfunctionality and real
- * features.
- */
-/* Buswidth is 16 bit */
-#define NAND_BUSWIDTH_16	0x00000002
-/* Device supports partial programming without padding */
-#define NAND_NO_PADDING		0x00000004
-/* Chip has cache program function */
-#define NAND_CACHEPRG		0x00000008
-/* Chip has copy back function */
-#define NAND_COPYBACK		0x00000010
-/*
- * Chip requires ready check on read (for auto-incremented sequential read).
- * True only for small page devices; large page devices do not support
- * autoincrement.
+/**
+ * struct nand_bbt - bad block table object
+ * @cache: in memory BBT cache
+ * @option: the option of BBT
+ * @version: current memory BBT cache version
  */
-#define NAND_NEED_READRDY	0x00000100
-
-/* Chip does not allow subpage writes */
-#define NAND_NO_SUBPAGE_WRITE	0x00000200
-
-/* Device is one of 'new' xD cards that expose fake nand command set */
-#define NAND_BROKEN_XD		0x00000400
+struct nand_bbt {
+	unsigned long *cache;
+	unsigned int option;
+	unsigned int version;
+};
 
-/* Device behaves just like nand, but is readonly */
-#define NAND_ROM		0x00000800
+struct nand_device;
 
-/* Device supports subpage reads */
-#define NAND_SUBPAGE_READ	0x00001000
+/**
+ * struct nand_ops - NAND operations
+ * @erase: erase a specific block. No need to check if the block is bad before
+ *	   erasing, this has been taken care of by the generic NAND layer
+ * @markbad: mark a specific block bad. No need to check if the block is
+ *	     already marked bad, this has been taken care of by the generic
+ *	     NAND layer. This method should just write the BBM (Bad Block
+ *	     Marker) so that future call to struct_nand_ops->isbad() return
+ *	     true
+ * @isbad: check whether a block is bad or not. This method should just read
+ *	   the BBM and return whether the block is bad or not based on what it
+ *	   reads
+ *
+ * These are all low level operations that should be implemented by specialized
+ * NAND layers (SPI NAND, raw NAND, ...).
+ */
+struct nand_ops {
+	int (*erase)(struct nand_device *nand, const struct nand_pos *pos);
+	int (*markbad)(struct nand_device *nand, const struct nand_pos *pos);
+	bool (*isbad)(struct nand_device *nand, const struct nand_pos *pos);
+};
 
-/*
- * Some MLC NANDs need data scrambling to limit bitflips caused by repeated
- * patterns.
+/**
+ * struct nand_device - NAND device
+ * @mtd: MTD instance attached to the NAND device
+ * @memorg: memory layout
+ * @eccreq: ECC requirements
+ * @rowconv: position to row address converter
+ * @bbt: bad block table info
+ * @ops: NAND operations attached to the NAND device
+ *
+ * Generic NAND object. Specialized NAND layers (raw NAND, SPI NAND, OneNAND)
+ * should declare their own NAND object embedding a nand_device struct (that's
+ * how inheritance is done).
+ * struct_nand_device->memorg and struct_nand_device->eccreq should be filled
+ * at device detection time to reflect the NAND device
+ * capabilities/requirements. Once this is done nanddev_init() can be called.
+ * It will take care of converting NAND information into MTD ones, which means
+ * the specialized NAND layers should never manually tweak
+ * struct_nand_device->mtd except for the ->_read/write() hooks.
  */
-#define NAND_NEED_SCRAMBLING	0x00002000
+struct nand_device {
+	struct mtd_info *mtd;
+	struct nand_memory_organization memorg;
+	struct nand_ecc_req eccreq;
+	struct nand_row_converter rowconv;
+	struct nand_bbt bbt;
+	const struct nand_ops *ops;
+};
 
-/* Options valid for Samsung large page devices */
-#define NAND_SAMSUNG_LP_OPTIONS NAND_CACHEPRG
+/**
+ * struct nand_io_iter - NAND I/O iterator
+ * @req: current I/O request
+ * @oobbytes_per_page: maximum number of OOB bytes per page
+ * @dataleft: remaining number of data bytes to read/write
+ * @oobleft: remaining number of OOB bytes to read/write
+ *
+ * Can be used by specialized NAND layers to iterate over all pages covered
+ * by an MTD I/O request, which should greatly simplifies the boiler-plate
+ * code needed to read/write data from/to a NAND device.
+ */
+struct nand_io_iter {
+	struct nand_page_io_req req;
+	unsigned int oobbytes_per_page;
+	unsigned int dataleft;
+	unsigned int oobleft;
+};
 
-/* Macros to identify the above */
-#define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
-#define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
+/**
+ * mtd_to_nanddev() - Get the NAND device attached to the MTD instance
+ * @mtd: MTD instance
+ *
+ * Return: the NAND device embedding @mtd.
+ */
+static inline struct nand_device *mtd_to_nanddev(struct mtd_info *mtd)
+{
+	return mtd->priv;
+}
 
-/* Non chip related options */
-/* This option skips the bbt scan during initialization. */
-#define NAND_SKIP_BBTSCAN	0x00010000
-/*
- * This option is defined if the board driver allocates its own buffers
- * (e.g. because it needs them DMA-coherent).
+/**
+ * nanddev_to_mtd() - Get the MTD device attached to a NAND device
+ * @nand: NAND device
+ *
+ * Return: the MTD device embedded in @nand.
  */
-#define NAND_OWN_BUFFERS	0x00020000
-/* Chip may not exist, so silence any errors in scan */
-#define NAND_SCAN_SILENT_NODEV	0x00040000
+static inline struct mtd_info *nanddev_to_mtd(struct nand_device *nand)
+{
+	return nand->mtd;
+}
+
 /*
- * Autodetect nand buswidth with readid/onfi.
- * This suppose the driver will configure the hardware in 8 bits mode
- * when calling nand_scan_ident, and update its configuration
- * before calling nand_scan_tail.
+ * nanddev_bits_per_cell() - Get the number of bits per cell
+ * @nand: NAND device
+ *
+ * Return: the number of bits per cell.
  */
-#define NAND_BUSWIDTH_AUTO      0x00080000
-/*
- * This option could be defined by controller drivers to protect against
- * kmap'ed, vmalloc'ed highmem buffers being passed from upper layers
+static inline unsigned int nanddev_bits_per_cell(const struct nand_device *nand)
+{
+	return nand->memorg.bits_per_cell;
+}
+
+/**
+ * nanddev_page_size() - Get NAND page size
+ * @nand: NAND device
+ *
+ * Return: the page size.
  */
-#define NAND_USE_BOUNCE_BUFFER	0x00100000
-
-/* Options set by nand scan */
-/* bbt has already been read */
-#define NAND_BBT_SCANNED	0x40000000
-/* Nand scan has allocated controller struct */
-#define NAND_CONTROLLER_ALLOC	0x80000000
-
-/* Cell info constants */
-#define NAND_CI_CHIPNR_MSK	0x03
-#define NAND_CI_CELLTYPE_MSK	0x0C
-#define NAND_CI_CELLTYPE_SHIFT	2
-
-/* Keep gcc happy */
-struct nand_chip;
-
-/* ONFI features */
-#define ONFI_FEATURE_16_BIT_BUS		(1 << 0)
-#define ONFI_FEATURE_EXT_PARAM_PAGE	(1 << 7)
-
-/* ONFI timing mode, used in both asynchronous and synchronous mode */
-#define ONFI_TIMING_MODE_0		(1 << 0)
-#define ONFI_TIMING_MODE_1		(1 << 1)
-#define ONFI_TIMING_MODE_2		(1 << 2)
-#define ONFI_TIMING_MODE_3		(1 << 3)
-#define ONFI_TIMING_MODE_4		(1 << 4)
-#define ONFI_TIMING_MODE_5		(1 << 5)
-#define ONFI_TIMING_MODE_UNKNOWN	(1 << 6)
-
-/* ONFI feature address */
-#define ONFI_FEATURE_ADDR_TIMING_MODE	0x1
-
-/* Vendor-specific feature address (Micron) */
-#define ONFI_FEATURE_ADDR_READ_RETRY	0x89
-
-/* ONFI subfeature parameters length */
-#define ONFI_SUBFEATURE_PARAM_LEN	4
-
-/* ONFI optional commands SET/GET FEATURES supported? */
-#define ONFI_OPT_CMD_SET_GET_FEATURES	(1 << 2)
-
-struct nand_onfi_params {
-	/* rev info and features block */
-	/* 'O' 'N' 'F' 'I'  */
-	u8 sig[4];
-	__le16 revision;
-	__le16 features;
-	__le16 opt_cmd;
-	u8 reserved0[2];
-	__le16 ext_param_page_length; /* since ONFI 2.1 */
-	u8 num_of_param_pages;        /* since ONFI 2.1 */
-	u8 reserved1[17];
-
-	/* manufacturer information block */
-	char manufacturer[12];
-	char model[20];
-	u8 jedec_id;
-	__le16 date_code;
-	u8 reserved2[13];
-
-	/* memory organization block */
-	__le32 byte_per_page;
-	__le16 spare_bytes_per_page;
-	__le32 data_bytes_per_ppage;
-	__le16 spare_bytes_per_ppage;
-	__le32 pages_per_block;
-	__le32 blocks_per_lun;
-	u8 lun_count;
-	u8 addr_cycles;
-	u8 bits_per_cell;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 guaranteed_good_blocks;
-	__le16 guaranteed_block_endurance;
-	u8 programs_per_page;
-	u8 ppage_attr;
-	u8 ecc_bits;
-	u8 interleaved_bits;
-	u8 interleaved_ops;
-	u8 reserved3[13];
-
-	/* electrical parameter block */
-	u8 io_pin_capacitance_max;
-	__le16 async_timing_mode;
-	__le16 program_cache_timing_mode;
-	__le16 t_prog;
-	__le16 t_bers;
-	__le16 t_r;
-	__le16 t_ccs;
-	__le16 src_sync_timing_mode;
-	u8 src_ssync_features;
-	__le16 clk_pin_capacitance_typ;
-	__le16 io_pin_capacitance_typ;
-	__le16 input_pin_capacitance_typ;
-	u8 input_pin_capacitance_max;
-	u8 driver_strength_support;
-	__le16 t_int_r;
-	__le16 t_adl;
-	u8 reserved4[8];
-
-	/* vendor */
-	__le16 vendor_revision;
-	u8 vendor[88];
-
-	__le16 crc;
-} __packed;
-
-#define ONFI_CRC_BASE	0x4F4E
-
-/* Extended ECC information Block Definition (since ONFI 2.1) */
-struct onfi_ext_ecc_info {
-	u8 ecc_bits;
-	u8 codeword_size;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 reserved[2];
-} __packed;
-
-#define ONFI_SECTION_TYPE_0	0	/* Unused section. */
-#define ONFI_SECTION_TYPE_1	1	/* for additional sections. */
-#define ONFI_SECTION_TYPE_2	2	/* for ECC information. */
-struct onfi_ext_section {
-	u8 type;
-	u8 length;
-} __packed;
-
-#define ONFI_EXT_SECTION_MAX 8
-
-/* Extended Parameter Page Definition (since ONFI 2.1) */
-struct onfi_ext_param_page {
-	__le16 crc;
-	u8 sig[4];             /* 'E' 'P' 'P' 'S' */
-	u8 reserved0[10];
-	struct onfi_ext_section sections[ONFI_EXT_SECTION_MAX];
-
-	/*
-	 * The actual size of the Extended Parameter Page is in
-	 * @ext_param_page_length of nand_onfi_params{}.
-	 * The following are the variable length sections.
-	 * So we do not add any fields below. Please see the ONFI spec.
-	 */
-} __packed;
-
-struct nand_onfi_vendor_micron {
-	u8 two_plane_read;
-	u8 read_cache;
-	u8 read_unique_id;
-	u8 dq_imped;
-	u8 dq_imped_num_settings;
-	u8 dq_imped_feat_addr;
-	u8 rb_pulldown_strength;
-	u8 rb_pulldown_strength_feat_addr;
-	u8 rb_pulldown_strength_num_settings;
-	u8 otp_mode;
-	u8 otp_page_start;
-	u8 otp_data_prot_addr;
-	u8 otp_num_pages;
-	u8 otp_feat_addr;
-	u8 read_retry_options;
-	u8 reserved[72];
-	u8 param_revision;
-} __packed;
-
-struct jedec_ecc_info {
-	u8 ecc_bits;
-	u8 codeword_size;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 reserved[2];
-} __packed;
-
-/* JEDEC features */
-#define JEDEC_FEATURE_16_BIT_BUS	(1 << 0)
-
-struct nand_jedec_params {
-	/* rev info and features block */
-	/* 'J' 'E' 'S' 'D'  */
-	u8 sig[4];
-	__le16 revision;
-	__le16 features;
-	u8 opt_cmd[3];
-	__le16 sec_cmd;
-	u8 num_of_param_pages;
-	u8 reserved0[18];
-
-	/* manufacturer information block */
-	char manufacturer[12];
-	char model[20];
-	u8 jedec_id[6];
-	u8 reserved1[10];
-
-	/* memory organization block */
-	__le32 byte_per_page;
-	__le16 spare_bytes_per_page;
-	u8 reserved2[6];
-	__le32 pages_per_block;
-	__le32 blocks_per_lun;
-	u8 lun_count;
-	u8 addr_cycles;
-	u8 bits_per_cell;
-	u8 programs_per_page;
-	u8 multi_plane_addr;
-	u8 multi_plane_op_attr;
-	u8 reserved3[38];
-
-	/* electrical parameter block */
-	__le16 async_sdr_speed_grade;
-	__le16 toggle_ddr_speed_grade;
-	__le16 sync_ddr_speed_grade;
-	u8 async_sdr_features;
-	u8 toggle_ddr_features;
-	u8 sync_ddr_features;
-	__le16 t_prog;
-	__le16 t_bers;
-	__le16 t_r;
-	__le16 t_r_multi_plane;
-	__le16 t_ccs;
-	__le16 io_pin_capacitance_typ;
-	__le16 input_pin_capacitance_typ;
-	__le16 clk_pin_capacitance_typ;
-	u8 driver_strength_support;
-	__le16 t_adl;
-	u8 reserved4[36];
-
-	/* ECC and endurance block */
-	u8 guaranteed_good_blocks;
-	__le16 guaranteed_block_endurance;
-	struct jedec_ecc_info ecc_info[4];
-	u8 reserved5[29];
-
-	/* reserved */
-	u8 reserved6[148];
-
-	/* vendor */
-	__le16 vendor_rev_num;
-	u8 reserved7[88];
-
-	/* CRC for Parameter Page */
-	__le16 crc;
-} __packed;
+static inline size_t nanddev_page_size(const struct nand_device *nand)
+{
+	return nand->memorg.pagesize;
+}
 
 /**
- * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
- * @lock:               protection lock
- * @active:		the mtd device which holds the controller currently
- * @wq:			wait queue to sleep on if a NAND operation is in
- *			progress used instead of the per chip wait queue
- *			when a hw controller is available.
+ * nanddev_per_page_oobsize() - Get NAND OOB size
+ * @nand: NAND device
+ *
+ * Return: the OOB size.
  */
-struct nand_hw_control {
-	spinlock_t lock;
-	struct nand_chip *active;
-};
+static inline unsigned int
+nanddev_per_page_oobsize(const struct nand_device *nand)
+{
+	return nand->memorg.oobsize;
+}
 
 /**
- * struct nand_ecc_ctrl - Control structure for ECC
- * @mode:	ECC mode
- * @steps:	number of ECC steps per page
- * @size:	data bytes per ECC step
- * @bytes:	ECC bytes per step
- * @strength:	max number of correctible bits per ECC step
- * @total:	total number of ECC bytes per page
- * @prepad:	padding information for syndrome based ECC generators
- * @postpad:	padding information for syndrome based ECC generators
- * @options:	ECC specific options (see NAND_ECC_XXX flags defined above)
- * @layout:	ECC layout control struct pointer
- * @priv:	pointer to private ECC control data
- * @hwctl:	function to control hardware ECC generator. Must only
- *		be provided if an hardware ECC is available
- * @calculate:	function for ECC calculation or readback from ECC hardware
- * @correct:	function for ECC correction, matching to ECC generator (sw/hw).
- *		Should return a positive number representing the number of
- *		corrected bitflips, -EBADMSG if the number of bitflips exceed
- *		ECC strength, or any other error code if the error is not
- *		directly related to correction.
- *		If -EBADMSG is returned the input buffers should be left
- *		untouched.
- * @read_page_raw:	function to read a raw page without ECC. This function
- *			should hide the specific layout used by the ECC
- *			controller and always return contiguous in-band and
- *			out-of-band data even if they're not stored
- *			contiguously on the NAND chip (e.g.
- *			NAND_ECC_HW_SYNDROME interleaves in-band and
- *			out-of-band data).
- * @write_page_raw:	function to write a raw page without ECC. This function
- *			should hide the specific layout used by the ECC
- *			controller and consider the passed data as contiguous
- *			in-band and out-of-band data. ECC controller is
- *			responsible for doing the appropriate transformations
- *			to adapt to its specific layout (e.g.
- *			NAND_ECC_HW_SYNDROME interleaves in-band and
- *			out-of-band data).
- * @read_page:	function to read a page according to the ECC generator
- *		requirements; returns maximum number of bitflips corrected in
- *		any single ECC step, 0 if bitflips uncorrectable, -EIO hw error
- * @read_subpage:	function to read parts of the page covered by ECC;
- *			returns same as read_page()
- * @write_subpage:	function to write parts of the page covered by ECC.
- * @write_page:	function to write a page according to the ECC generator
- *		requirements.
- * @write_oob_raw:	function to write chip OOB data without ECC
- * @read_oob_raw:	function to read chip OOB data without ECC
- * @read_oob:	function to read chip OOB data
- * @write_oob:	function to write chip OOB data
+ * nanddev_pages_per_eraseblock() - Get the number of pages per eraseblock
+ * @nand: NAND device
+ *
+ * Return: the number of pages per eraseblock.
  */
-struct nand_ecc_ctrl {
-	nand_ecc_modes_t mode;
-	int steps;
-	int size;
-	int bytes;
-	int total;
-	int strength;
-	int prepad;
-	int postpad;
-	unsigned int options;
-	struct nand_ecclayout	*layout;
-	void *priv;
-	void (*hwctl)(struct mtd_info *mtd, int mode);
-	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,
-			uint8_t *ecc_code);
-	int (*correct)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
-			uint8_t *calc_ecc);
-	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buf, int oob_required, int page);
-	int (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required, int page);
-	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buf, int oob_required, int page);
-	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offs, uint32_t len, uint8_t *buf, int page);
-	int (*write_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offset, uint32_t data_len,
-			const uint8_t *data_buf, int oob_required, int page);
-	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required, int page);
-	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page);
-	int (*read_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page);
-	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page);
-	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page);
-};
+static inline unsigned int
+nanddev_pages_per_eraseblock(const struct nand_device *nand)
+{
+	return nand->memorg.pages_per_eraseblock;
+}
 
 /**
- * struct nand_buffers - buffer structure for read/write
- * @ecccalc:	buffer pointer for calculated ECC, size is oobsize.
- * @ecccode:	buffer pointer for ECC read from flash, size is oobsize.
- * @databuf:	buffer pointer for data, size is (page size + oobsize).
+ * nanddev_per_page_oobsize() - Get NAND erase block size
+ * @nand: NAND device
  *
- * Do not change the order of buffers. databuf and oobrbuf must be in
- * consecutive order.
+ * Return: the eraseblock size.
  */
-struct nand_buffers {
-	uint8_t	ecccalc[ALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)];
-	uint8_t	ecccode[ALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)];
-	uint8_t databuf[ALIGN(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE,
-			      ARCH_DMA_MINALIGN)];
-};
+static inline size_t nanddev_eraseblock_size(const struct nand_device *nand)
+{
+	return nand->memorg.pagesize * nand->memorg.pages_per_eraseblock;
+}
 
 /**
- * struct nand_chip - NAND Private Flash Chip Data
- * @mtd:		MTD device registered to the MTD framework
- * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
- *			flash device
- * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
- *			flash device.
- * @flash_node:		[BOARDSPECIFIC] device node describing this instance
- * @read_byte:		[REPLACEABLE] read one byte from the chip
- * @read_word:		[REPLACEABLE] read one word from the chip
- * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
- *			low 8 I/O lines
- * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
- * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
- * @select_chip:	[REPLACEABLE] select chip nr
- * @block_bad:		[REPLACEABLE] check if a block is bad, using OOB markers
- * @block_markbad:	[REPLACEABLE] mark a block bad
- * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
- *			ALE/CLE/nCE. Also used to write command and address
- * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accessing
- *			device ready/busy line. If set to NULL no access to
- *			ready/busy is available and the ready/busy information
- *			is read from the chip status register.
- * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing
- *			commands to the chip.
- * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
- *			ready.
- * @setup_read_retry:	[FLASHSPECIFIC] flash (vendor) specific function for
- *			setting the read-retry mode. Mostly needed for MLC NAND.
- * @ecc:		[BOARDSPECIFIC] ECC control structure
- * @buffers:		buffer structure for read/write
- * @hwcontrol:		platform-specific hardware control structure
- * @erase:		[REPLACEABLE] erase function
- * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
- *			data from array to read regs (tR).
- * @state:		[INTERN] the current state of the NAND device
- * @oob_poi:		"poison value buffer," used for laying out OOB data
- *			before writing
- * @page_shift:		[INTERN] number of address bits in a page (column
- *			address bits).
- * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
- * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
- * @chip_shift:		[INTERN] number of address bits in one chip
- * @options:		[BOARDSPECIFIC] various chip options. They can partly
- *			be set to inform nand_scan about special functionality.
- *			See the defines for further explanation.
- * @bbt_options:	[INTERN] bad block specific options. All options used
- *			here must come from bbm.h. By default, these options
- *			will be copied to the appropriate nand_bbt_descr's.
- * @badblockpos:	[INTERN] position of the bad block marker in the oob
- *			area.
- * @badblockbits:	[INTERN] minimum number of set bits in a good block's
- *			bad block marker position; i.e., BBM == 11110111b is
- *			not bad when badblockbits == 7
- * @bits_per_cell:	[INTERN] number of bits per cell. i.e., 1 means SLC.
- * @ecc_strength_ds:	[INTERN] ECC correctability from the datasheet.
- *			Minimum amount of bit errors per @ecc_step_ds guaranteed
- *			to be correctable. If unknown, set to zero.
- * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
- *                      also from the datasheet. It is the recommended ECC step
- *			size, if known; if unknown, set to zero.
- * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
- *			      either deduced from the datasheet if the NAND
- *			      chip is not ONFI compliant or set to 0 if it is
- *			      (an ONFI chip is always configured in mode 0
- *			      after a NAND reset)
- * @numchips:		[INTERN] number of physical chips
- * @chipsize:		[INTERN] the size of one chip for multichip arrays
- * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
- * @pagebuf:		[INTERN] holds the pagenumber which is currently in
- *			data_buf.
- * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is
- *			currently in data_buf.
- * @subpagesize:	[INTERN] holds the subpagesize
- * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
- *			non 0 if ONFI supported.
- * @jedec_version:	[INTERN] holds the chip JEDEC version (BCD encoded),
- *			non 0 if JEDEC supported.
- * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
- *			supported, 0 otherwise.
- * @jedec_params:	[INTERN] holds the JEDEC parameter page when JEDEC is
- *			supported, 0 otherwise.
- * @read_retries:	[INTERN] the number of read retry modes supported
- * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
- * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
- * @bbt:		[INTERN] bad block table pointer
- * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
- *			lookup.
- * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
- * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
- *			bad block scan.
- * @controller:		[REPLACEABLE] a pointer to a hardware controller
- *			structure which is shared among multiple independent
- *			devices.
- * @priv:		[OPTIONAL] pointer to private chip data
- * @errstat:		[OPTIONAL] hardware specific function to perform
- *			additional error status checks (determine if errors are
- *			correctable).
- * @write_page:		[REPLACEABLE] High-level page write function
+ * nanddev_eraseblocks_per_lun() - Get the number of eraseblocks per LUN
+ * @nand: NAND device
+ *
+ * Return: the number of eraseblocks per LUN.
  */
+static inline unsigned int
+nanddev_eraseblocks_per_lun(const struct nand_device *nand)
+{
+	return nand->memorg.eraseblocks_per_lun;
+}
 
-struct nand_chip {
-	struct mtd_info mtd;
-	void __iomem *IO_ADDR_R;
-	void __iomem *IO_ADDR_W;
-
-	int flash_node;
-
-	uint8_t (*read_byte)(struct mtd_info *mtd);
-	u16 (*read_word)(struct mtd_info *mtd);
-	void (*write_byte)(struct mtd_info *mtd, uint8_t byte);
-	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
-	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
-	void (*select_chip)(struct mtd_info *mtd, int chip);
-	int (*block_bad)(struct mtd_info *mtd, loff_t ofs);
-	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
-	int (*dev_ready)(struct mtd_info *mtd);
-	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
-			int page_addr);
-	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
-	int (*erase)(struct mtd_info *mtd, int page);
-	int (*scan_bbt)(struct mtd_info *mtd);
-	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
-			int status, int page);
-	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offset, int data_len, const uint8_t *buf,
-			int oob_required, int page, int cached, int raw);
-	int (*onfi_set_features)(struct mtd_info *mtd, struct nand_chip *chip,
-			int feature_addr, uint8_t *subfeature_para);
-	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,
-			int feature_addr, uint8_t *subfeature_para);
-	int (*setup_read_retry)(struct mtd_info *mtd, int retry_mode);
-
-	int chip_delay;
-	unsigned int options;
-	unsigned int bbt_options;
-
-	int page_shift;
-	int phys_erase_shift;
-	int bbt_erase_shift;
-	int chip_shift;
-	int numchips;
-	uint64_t chipsize;
-	int pagemask;
-	int pagebuf;
-	unsigned int pagebuf_bitflips;
-	int subpagesize;
-	uint8_t bits_per_cell;
-	uint16_t ecc_strength_ds;
-	uint16_t ecc_step_ds;
-	int onfi_timing_mode_default;
-	int badblockpos;
-	int badblockbits;
-
-	int onfi_version;
-	int jedec_version;
-#ifdef CONFIG_SYS_NAND_ONFI_DETECTION
-	struct nand_onfi_params	onfi_params;
-#endif
-	struct nand_jedec_params jedec_params;
- 
-	int read_retries;
-
-	flstate_t state;
-
-	uint8_t *oob_poi;
-	struct nand_hw_control *controller;
-	struct nand_ecclayout *ecclayout;
-
-	struct nand_ecc_ctrl ecc;
-	struct nand_buffers *buffers;
-	struct nand_hw_control hwcontrol;
-
-	uint8_t *bbt;
-	struct nand_bbt_descr *bbt_td;
-	struct nand_bbt_descr *bbt_md;
-
-	struct nand_bbt_descr *badblock_pattern;
-
-	void *priv;
-};
+/**
+ * nanddev_target_size() - Get the total size provided by a single target/die
+ * @nand: NAND device
+ *
+ * Return: the total size exposed by a single target/die in bytes.
+ */
+static inline u64 nanddev_target_size(const struct nand_device *nand)
+{
+	return (u64)nand->memorg.luns_per_target *
+	       nand->memorg.eraseblocks_per_lun *
+	       nand->memorg.pages_per_eraseblock *
+	       nand->memorg.pagesize;
+}
 
-static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)
+/**
+ * nanddev_ntarget() - Get the total of targets
+ * @nand: NAND device
+ *
+ * Return: the number of targets/dies exposed by @nand.
+ */
+static inline unsigned int nanddev_ntargets(const struct nand_device *nand)
 {
-	return container_of(mtd, struct nand_chip, mtd);
+	return nand->memorg.ntargets;
 }
 
-static inline struct mtd_info *nand_to_mtd(struct nand_chip *chip)
+/**
+ * nanddev_neraseblocks() - Get the total number of erasablocks
+ * @nand: NAND device
+ *
+ * Return: the total number of eraseblocks exposed by @nand.
+ */
+static inline unsigned int nanddev_neraseblocks(const struct nand_device *nand)
 {
-	return &chip->mtd;
+	return nand->memorg.ntargets * nand->memorg.luns_per_target *
+	       nand->memorg.eraseblocks_per_lun;
 }
 
-static inline void *nand_get_controller_data(struct nand_chip *chip)
+/**
+ * nanddev_size() - Get NAND size
+ * @nand: NAND device
+ *
+ * Return: the total size (in bytes) exposed by @nand.
+ */
+static inline u64 nanddev_size(const struct nand_device *nand)
 {
-	return chip->priv;
+	return nanddev_target_size(nand) * nanddev_ntargets(nand);
 }
 
-static inline void nand_set_controller_data(struct nand_chip *chip, void *priv)
+/**
+ * nanddev_get_memorg() - Extract memory organization info from a NAND device
+ * @nand: NAND device
+ *
+ * This can be used by the upper layer to fill the memorg info before calling
+ * nanddev_init().
+ *
+ * Return: the memorg object embedded in the NAND device.
+ */
+static inline struct nand_memory_organization *
+nanddev_get_memorg(struct nand_device *nand)
 {
-	chip->priv = priv;
+	return &nand->memorg;
 }
 
-/*
- * NAND Flash Manufacturer ID Codes
+int nanddev_init(struct nand_device *nand, const struct nand_ops *ops,
+		 struct module *owner);
+void nanddev_cleanup(struct nand_device *nand);
+
+/**
+ * nanddev_register() - Register a NAND device
+ * @nand: NAND device
+ *
+ * Register a NAND device.
+ * This function is just a wrapper around mtd_device_register()
+ * registering the MTD device embedded in @nand.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
  */
-#define NAND_MFR_TOSHIBA	0x98
-#define NAND_MFR_SAMSUNG	0xec
-#define NAND_MFR_FUJITSU	0x04
-#define NAND_MFR_NATIONAL	0x8f
-#define NAND_MFR_RENESAS	0x07
-#define NAND_MFR_STMICRO	0x20
-#define NAND_MFR_HYNIX		0xad
-#define NAND_MFR_MICRON		0x2c
-#define NAND_MFR_AMD		0x01
-#define NAND_MFR_MACRONIX	0xc2
-#define NAND_MFR_EON		0x92
-#define NAND_MFR_SANDISK	0x45
-#define NAND_MFR_INTEL		0x89
-#define NAND_MFR_ATO		0x9b
-
-/* The maximum expected count of bytes in the NAND ID sequence */
-#define NAND_MAX_ID_LEN 8
+static inline int nanddev_register(struct nand_device *nand)
+{
+	return mtd_device_register(nand->mtd, NULL, 0);
+}
 
-/*
- * A helper for defining older NAND chips where the second ID byte fully
- * defined the chip, including the geometry (chip size, eraseblock size, page
- * size). All these chips have 512 bytes NAND page size.
+/**
+ * nanddev_unregister() - Unregister a NAND device
+ * @nand: NAND device
+ *
+ * Unregister a NAND device.
+ * This function is just a wrapper around mtd_device_unregister()
+ * unregistering the MTD device embedded in @nand.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
  */
-#define LEGACY_ID_NAND(nm, devid, chipsz, erasesz, opts)          \
-	{ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = 512, \
-	  .chipsize = (chipsz), .erasesize = (erasesz), .options = (opts) }
+static inline int nanddev_unregister(struct nand_device *nand)
+{
+	return mtd_device_unregister(nand->mtd);
+}
 
-/*
- * A helper for defining newer chips which report their page size and
- * eraseblock size via the extended ID bytes.
+/**
+ * nanddev_set_of_node() - Attach a DT node to a NAND device
+ * @nand: NAND device
+ * @np: DT node
  *
- * The real difference between LEGACY_ID_NAND and EXTENDED_ID_NAND is that with
- * EXTENDED_ID_NAND, manufacturers overloaded the same device ID so that the
- * device ID now only represented a particular total chip size (and voltage,
- * buswidth), and the page size, eraseblock size, and OOB size could vary while
- * using the same device ID.
+ * Attach a DT node to a NAND device.
  */
-#define EXTENDED_ID_NAND(nm, devid, chipsz, opts)                      \
-	{ .name = (nm), {{ .dev_id = (devid) }}, .chipsize = (chipsz), \
-	  .options = (opts) }
+static inline void nanddev_set_of_node(struct nand_device *nand,
+				       const struct device_node *np)
+{
+	mtd_set_of_node(nand->mtd, np);
+}
 
-#define NAND_ECC_INFO(_strength, _step)	\
-			{ .strength_ds = (_strength), .step_ds = (_step) }
-#define NAND_ECC_STRENGTH(type)		((type)->ecc.strength_ds)
-#define NAND_ECC_STEP(type)		((type)->ecc.step_ds)
+/**
+ * nanddev_get_of_node() - Retrieve the DT node attached to a NAND device
+ * @nand: NAND device
+ *
+ * Return: the DT node attached to @nand.
+ */
+static inline const struct device_node *nanddev_get_of_node(struct nand_device *nand)
+{
+	return mtd_get_of_node(nand->mtd);
+}
 
 /**
- * struct nand_flash_dev - NAND Flash Device ID Structure
- * @name: a human-readable name of the NAND chip
- * @dev_id: the device ID (the second byte of the full chip ID array)
- * @mfr_id: manufecturer ID part of the full chip ID array (refers the same
- *          memory address as @id[0])
- * @dev_id: device ID part of the full chip ID array (refers the same memory
- *          address as @id[1])
- * @id: full device ID array
- * @pagesize: size of the NAND page in bytes; if 0, then the real page size (as
- *            well as the eraseblock size) is determined from the extended NAND
- *            chip ID array)
- * @chipsize: total chip size in MiB
- * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
- * @options: stores various chip bit options
- * @id_len: The valid length of the @id.
- * @oobsize: OOB size
- * @ecc: ECC correctability and step information from the datasheet.
- * @ecc.strength_ds: The ECC correctability from the datasheet, same as the
- *                   @ecc_strength_ds in nand_chip{}.
- * @ecc.step_ds: The ECC step required by the @ecc.strength_ds, same as the
- *               @ecc_step_ds in nand_chip{}, also from the datasheet.
- *               For example, the "4bit ECC for each 512Byte" can be set with
- *               NAND_ECC_INFO(4, 512).
- * @onfi_timing_mode_default: the default ONFI timing mode entered after a NAND
- *			      reset. Should be deduced from timings described
- *			      in the datasheet.
+ * nanddev_offs_to_pos() - Convert an absolute NAND offset into a NAND position
+ * @nand: NAND device
+ * @offs: absolute NAND offset (usually passed by the MTD layer)
+ * @pos: a NAND position object to fill in
+ *
+ * Converts @offs into a nand_pos representation.
  *
+ * Return: the offset within the NAND page pointed by @pos.
  */
-struct nand_flash_dev {
-	char *name;
-	union {
-		struct {
-			uint8_t mfr_id;
-			uint8_t dev_id;
-		};
-		uint8_t id[NAND_MAX_ID_LEN];
-	};
-	unsigned int pagesize;
-	unsigned int chipsize;
-	unsigned int erasesize;
-	unsigned int options;
-	uint16_t id_len;
-	uint16_t oobsize;
-	struct {
-		uint16_t strength_ds;
-		uint16_t step_ds;
-	} ecc;
-	int onfi_timing_mode_default;
-};
+static inline unsigned int nanddev_offs_to_pos(struct nand_device *nand,
+					       loff_t offs,
+					       struct nand_pos *pos)
+{
+	unsigned int pageoffs;
+	u64 tmp = offs;
+
+	pageoffs = do_div(tmp, nand->memorg.pagesize);
+	pos->page = do_div(tmp, nand->memorg.pages_per_eraseblock);
+	pos->eraseblock = do_div(tmp, nand->memorg.eraseblocks_per_lun);
+	pos->plane = pos->eraseblock % nand->memorg.planes_per_lun;
+	pos->lun = do_div(tmp, nand->memorg.luns_per_target);
+	pos->target = tmp;
+
+	return pageoffs;
+}
 
 /**
- * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
- * @name:	Manufacturer name
- * @id:		manufacturer ID code of device.
-*/
-struct nand_manufacturers {
-	int id;
-	char *name;
-};
+ * nanddev_pos_cmp() - Compare two NAND positions
+ * @a: First NAND position
+ * @b: Second NAND position
+ *
+ * Compares two NAND positions.
+ *
+ * Return: -1 if @a < @b, 0 if @a == @b and 1 if @a > @b.
+ */
+static inline int nanddev_pos_cmp(const struct nand_pos *a,
+				  const struct nand_pos *b)
+{
+	if (a->target != b->target)
+		return a->target < b->target ? -1 : 1;
 
-extern struct nand_flash_dev nand_flash_ids[];
-extern struct nand_manufacturers nand_manuf_ids[];
+	if (a->lun != b->lun)
+		return a->lun < b->lun ? -1 : 1;
 
-extern int nand_default_bbt(struct mtd_info *mtd);
-extern int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
-extern int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);
-extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
-extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
-			   int allowbbt);
-extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
-			size_t *retlen, uint8_t *buf);
+	if (a->eraseblock != b->eraseblock)
+		return a->eraseblock < b->eraseblock ? -1 : 1;
 
-/*
-* Constants for oob configuration
-*/
-#define NAND_SMALL_BADBLOCK_POS		5
-#define NAND_LARGE_BADBLOCK_POS		0
+	if (a->page != b->page)
+		return a->page < b->page ? -1 : 1;
+
+	return 0;
+}
 
 /**
- * struct platform_nand_chip - chip level device structure
- * @nr_chips:		max. number of chips to scan for
- * @chip_offset:	chip number offset
- * @nr_partitions:	number of partitions pointed to by partitions (or zero)
- * @partitions:		mtd partition list
- * @chip_delay:		R/B delay value in us
- * @options:		Option flags, e.g. 16bit buswidth
- * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
- * @part_probe_types:	NULL-terminated array of probe types
+ * nanddev_pos_to_offs() - Convert a NAND position into an absolute offset
+ * @nand: NAND device
+ * @pos: the NAND position to convert
+ *
+ * Converts @pos NAND position into an absolute offset.
+ *
+ * Return: the absolute offset. Note that @pos points to the beginning of a
+ *	   page, if one wants to point to a specific offset within this page
+ *	   the returned offset has to be adjusted manually.
  */
-struct platform_nand_chip {
-	int nr_chips;
-	int chip_offset;
-	int nr_partitions;
-	struct mtd_partition *partitions;
-	int chip_delay;
-	unsigned int options;
-	unsigned int bbt_options;
-	const char **part_probe_types;
-};
+static inline loff_t nanddev_pos_to_offs(struct nand_device *nand,
+					 const struct nand_pos *pos)
+{
+	unsigned int npages;
+
+	npages = pos->page +
+		 ((pos->eraseblock +
+		   (pos->lun +
+		    (pos->target * nand->memorg.luns_per_target)) *
+		   nand->memorg.eraseblocks_per_lun) *
+		  nand->memorg.pages_per_eraseblock);
 
-/* Keep gcc happy */
-struct platform_device;
+	return (loff_t)npages * nand->memorg.pagesize;
+}
 
 /**
- * struct platform_nand_ctrl - controller level device structure
- * @probe:		platform specific function to probe/setup hardware
- * @remove:		platform specific function to remove/teardown hardware
- * @hwcontrol:		platform specific hardware control structure
- * @dev_ready:		platform specific function to read ready/busy pin
- * @select_chip:	platform specific chip select function
- * @cmd_ctrl:		platform specific function for controlling
- *			ALE/CLE/nCE. Also used to write command and address
- * @write_buf:		platform specific function for write buffer
- * @read_buf:		platform specific function for read buffer
- * @read_byte:		platform specific function to read one byte from chip
- * @priv:		private data to transport driver specific settings
+ * nanddev_pos_to_row() - Extract a row address from a NAND position
+ * @nand: NAND device
+ * @pos: the position to convert
+ *
+ * Converts a NAND position into a row address that can then be passed to the
+ * device.
  *
- * All fields are optional and depend on the hardware driver requirements
+ * Return: the row address extracted from @pos.
  */
-struct platform_nand_ctrl {
-	int (*probe)(struct platform_device *pdev);
-	void (*remove)(struct platform_device *pdev);
-	void (*hwcontrol)(struct mtd_info *mtd, int cmd);
-	int (*dev_ready)(struct mtd_info *mtd);
-	void (*select_chip)(struct mtd_info *mtd, int chip);
-	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
-	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
-	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
-	unsigned char (*read_byte)(struct mtd_info *mtd);
-	void *priv;
-};
+static inline unsigned int nanddev_pos_to_row(struct nand_device *nand,
+					      const struct nand_pos *pos)
+{
+	return (pos->lun << nand->rowconv.lun_addr_shift) |
+	       (pos->eraseblock << nand->rowconv.eraseblock_addr_shift) |
+	       pos->page;
+}
 
 /**
- * struct platform_nand_data - container structure for platform-specific data
- * @chip:		chip level chip structure
- * @ctrl:		controller level device structure
+ * nanddev_pos_next_target() - Move a position to the next target/die
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next target/die. Useful when you
+ * want to iterate over all targets/dies of a NAND device.
  */
-struct platform_nand_data {
-	struct platform_nand_chip chip;
-	struct platform_nand_ctrl ctrl;
-};
+static inline void nanddev_pos_next_target(struct nand_device *nand,
+					   struct nand_pos *pos)
+{
+	pos->page = 0;
+	pos->plane = 0;
+	pos->eraseblock = 0;
+	pos->lun = 0;
+	pos->target++;
+}
 
-#ifdef CONFIG_SYS_NAND_ONFI_DETECTION
-/* return the supported features. */
-static inline int onfi_feature(struct nand_chip *chip)
+/**
+ * nanddev_pos_next_lun() - Move a position to the next LUN
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next LUN. Useful when you want to
+ * iterate over all LUNs of a NAND device.
+ */
+static inline void nanddev_pos_next_lun(struct nand_device *nand,
+					struct nand_pos *pos)
 {
-	return chip->onfi_version ? le16_to_cpu(chip->onfi_params.features) : 0;
+	if (pos->lun >= nand->memorg.luns_per_target - 1)
+		return nanddev_pos_next_target(nand, pos);
+
+	pos->lun++;
+	pos->page = 0;
+	pos->plane = 0;
+	pos->eraseblock = 0;
 }
 
-/* return the supported asynchronous timing mode. */
-static inline int onfi_get_async_timing_mode(struct nand_chip *chip)
+/**
+ * nanddev_pos_next_eraseblock() - Move a position to the next eraseblock
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next eraseblock. Useful when you
+ * want to iterate over all eraseblocks of a NAND device.
+ */
+static inline void nanddev_pos_next_eraseblock(struct nand_device *nand,
+					       struct nand_pos *pos)
 {
-	if (!chip->onfi_version)
-		return ONFI_TIMING_MODE_UNKNOWN;
-	return le16_to_cpu(chip->onfi_params.async_timing_mode);
+	if (pos->eraseblock >= nand->memorg.eraseblocks_per_lun - 1)
+		return nanddev_pos_next_lun(nand, pos);
+
+	pos->eraseblock++;
+	pos->page = 0;
+	pos->plane = pos->eraseblock % nand->memorg.planes_per_lun;
 }
 
-/* return the supported synchronous timing mode. */
-static inline int onfi_get_sync_timing_mode(struct nand_chip *chip)
+/**
+ * nanddev_pos_next_eraseblock() - Move a position to the next page
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next page. Useful when you want to
+ * iterate over all pages of a NAND device.
+ */
+static inline void nanddev_pos_next_page(struct nand_device *nand,
+					 struct nand_pos *pos)
 {
-	if (!chip->onfi_version)
-		return ONFI_TIMING_MODE_UNKNOWN;
-	return le16_to_cpu(chip->onfi_params.src_sync_timing_mode);
+	if (pos->page >= nand->memorg.pages_per_eraseblock - 1)
+		return nanddev_pos_next_eraseblock(nand, pos);
+
+	pos->page++;
 }
-#endif
 
-/*
- * Check if it is a SLC nand.
- * The !nand_is_slc() can be used to check the MLC/TLC nand chips.
- * We do not distinguish the MLC and TLC now.
+/**
+ * nand_io_iter_init - Initialize a NAND I/O iterator
+ * @nand: NAND device
+ * @offs: absolute offset
+ * @req: MTD request
+ * @iter: NAND I/O iterator
+ *
+ * Initializes a NAND iterator based on the information passed by the MTD
+ * layer.
  */
-static inline bool nand_is_slc(struct nand_chip *chip)
+static inline void nanddev_io_iter_init(struct nand_device *nand,
+					loff_t offs, struct mtd_oob_ops *req,
+					struct nand_io_iter *iter)
 {
-	return chip->bits_per_cell == 1;
+	struct mtd_info *mtd = nanddev_to_mtd(nand);
+
+	iter->req.mode = req->mode;
+	iter->req.dataoffs = nanddev_offs_to_pos(nand, offs, &iter->req.pos);
+	iter->req.ooboffs = req->ooboffs;
+	iter->oobbytes_per_page = mtd_oobavail(mtd, req);
+	iter->dataleft = req->len;
+	iter->oobleft = req->ooblen;
+	iter->req.databuf.in = req->datbuf;
+	iter->req.datalen = min_t(unsigned int,
+				  nand->memorg.pagesize - iter->req.dataoffs,
+				  iter->dataleft);
+	iter->req.oobbuf.in = req->oobbuf;
+	iter->req.ooblen = min_t(unsigned int,
+				 iter->oobbytes_per_page - iter->req.ooboffs,
+				 iter->oobleft);
 }
 
 /**
- * Check if the opcode's address should be sent only on the lower 8 bits
- * @command: opcode to check
+ * nand_io_iter_next_page - Move to the next page
+ * @nand: NAND device
+ * @iter: NAND I/O iterator
+ *
+ * Updates the @iter to point to the next page.
  */
-static inline int nand_opcode_8bits(unsigned int command)
+static inline void nanddev_io_iter_next_page(struct nand_device *nand,
+					     struct nand_io_iter *iter)
 {
-	switch (command) {
-	case NAND_CMD_READID:
-	case NAND_CMD_PARAM:
-	case NAND_CMD_GET_FEATURES:
-	case NAND_CMD_SET_FEATURES:
-		return 1;
-	default:
-		break;
-	}
-	return 0;
+	nanddev_pos_next_page(nand, &iter->req.pos);
+	iter->dataleft -= iter->req.datalen;
+	iter->req.databuf.in += iter->req.datalen;
+	iter->oobleft -= iter->req.ooblen;
+	iter->req.oobbuf.in += iter->req.ooblen;
+	iter->req.dataoffs = 0;
+	iter->req.ooboffs = 0;
+	iter->req.datalen = min_t(unsigned int, nand->memorg.pagesize,
+				  iter->dataleft);
+	iter->req.ooblen = min_t(unsigned int, iter->oobbytes_per_page,
+				 iter->oobleft);
 }
 
-/* return the supported JEDEC features. */
-static inline int jedec_feature(struct nand_chip *chip)
+/**
+ * nand_io_iter_end - Should end iteration or not
+ * @nand: NAND device
+ * @iter: NAND I/O iterator
+ *
+ * Check whether @iter has reached the end of the NAND portion it was asked to
+ * iterate on or not.
+ *
+ * Return: true if @iter has reached the end of the iteration request, false
+ *	   otherwise.
+ */
+static inline bool nanddev_io_iter_end(struct nand_device *nand,
+				       const struct nand_io_iter *iter)
 {
-	return chip->jedec_version ? le16_to_cpu(chip->jedec_params.features)
-		: 0;
+	if (iter->dataleft || iter->oobleft)
+		return false;
+
+	return true;
 }
 
-/* Standard NAND functions from nand_base.c */
-void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len);
-void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len);
-void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len);
-void nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len);
-uint8_t nand_read_byte(struct mtd_info *mtd);
+/**
+ * nand_io_for_each_page - Iterate over all NAND pages contained in an MTD I/O
+ *			   request
+ * @nand: NAND device
+ * @start: start address to read/write from
+ * @req: MTD I/O request
+ * @iter: NAND I/O iterator
+ *
+ * Should be used for iterate over pages that are contained in an MTD request.
+ */
+#define nanddev_io_for_each_page(nand, start, req, iter)		\
+	for (nanddev_io_iter_init(nand, start, req, iter);		\
+	     !nanddev_io_iter_end(nand, iter);				\
+	     nanddev_io_iter_next_page(nand, iter))
+
+bool nanddev_isbad(struct nand_device *nand, const struct nand_pos *pos);
+bool nanddev_isreserved(struct nand_device *nand, const struct nand_pos *pos);
+int nanddev_erase(struct nand_device *nand, const struct nand_pos *pos);
+int nanddev_markbad(struct nand_device *nand, const struct nand_pos *pos);
+
+/* BBT related functions */
+enum nand_bbt_block_status {
+	NAND_BBT_BLOCK_STATUS_UNKNOWN,
+	NAND_BBT_BLOCK_GOOD,
+	NAND_BBT_BLOCK_WORN,
+	NAND_BBT_BLOCK_RESERVED,
+	NAND_BBT_BLOCK_FACTORY_BAD,
+	NAND_BBT_BLOCK_NUM_STATUS,
+};
+
+int nanddev_bbt_init(struct nand_device *nand);
+void nanddev_bbt_cleanup(struct nand_device *nand);
+int nanddev_bbt_update(struct nand_device *nand);
+int nanddev_bbt_get_block_status(const struct nand_device *nand,
+				 unsigned int entry);
+int nanddev_bbt_set_block_status(struct nand_device *nand, unsigned int entry,
+				 enum nand_bbt_block_status status);
+int nanddev_bbt_markbad(struct nand_device *nand, unsigned int block);
 
-/*
- * struct nand_sdr_timings - SDR NAND chip timings
+/**
+ * nanddev_bbt_pos_to_entry() - Convert a NAND position into a BBT entry
+ * @nand: NAND device
+ * @pos: the NAND position we want to get BBT entry for
  *
- * This struct defines the timing requirements of a SDR NAND chip.
- * These informations can be found in every NAND datasheets and the timings
- * meaning are described in the ONFI specifications:
- * www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
- * Parameters)
+ * Return the BBT entry used to store information about the eraseblock pointed
+ * by @pos.
  *
- * All these timings are expressed in picoseconds.
+ * Return: the BBT entry storing information about eraseblock pointed by @pos.
  */
+static inline unsigned int nanddev_bbt_pos_to_entry(struct nand_device *nand,
+						    const struct nand_pos *pos)
+{
+	return pos->eraseblock +
+	       ((pos->lun + (pos->target * nand->memorg.luns_per_target)) *
+		nand->memorg.eraseblocks_per_lun);
+}
 
-struct nand_sdr_timings {
-	u32 tALH_min;
-	u32 tADL_min;
-	u32 tALS_min;
-	u32 tAR_min;
-	u32 tCEA_max;
-	u32 tCEH_min;
-	u32 tCH_min;
-	u32 tCHZ_max;
-	u32 tCLH_min;
-	u32 tCLR_min;
-	u32 tCLS_min;
-	u32 tCOH_min;
-	u32 tCS_min;
-	u32 tDH_min;
-	u32 tDS_min;
-	u32 tFEAT_max;
-	u32 tIR_min;
-	u32 tITC_max;
-	u32 tRC_min;
-	u32 tREA_max;
-	u32 tREH_min;
-	u32 tRHOH_min;
-	u32 tRHW_min;
-	u32 tRHZ_max;
-	u32 tRLOH_min;
-	u32 tRP_min;
-	u32 tRR_min;
-	u64 tRST_max;
-	u32 tWB_max;
-	u32 tWC_min;
-	u32 tWH_min;
-	u32 tWHR_min;
-	u32 tWP_min;
-	u32 tWW_min;
-};
+/**
+ * nanddev_bbt_is_initialized() - Check if the BBT has been initialized
+ * @nand: NAND device
+ *
+ * Return: true if the BBT has been initialized, false otherwise.
+ */
+static inline bool nanddev_bbt_is_initialized(struct nand_device *nand)
+{
+	return !!nand->bbt.cache;
+}
 
-/* get timing characteristics from ONFI timing mode. */
-const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
+/* MTD -> NAND helper functions. */
+int nanddev_mtd_erase(struct mtd_info *mtd, struct erase_info *einfo);
 
-int nand_check_erased_ecc_chunk(void *data, int datalen,
-				void *ecc, int ecclen,
-				void *extraoob, int extraooblen,
-				int threshold);
 #endif /* __LINUX_MTD_NAND_H */
diff --git a/include/linux/mtd/partitions.h b/include/linux/mtd/partitions.h
index ce0e8dbee4..3822237f2a 100644
--- a/include/linux/mtd/partitions.h
+++ b/include/linux/mtd/partitions.h
@@ -81,10 +81,30 @@ extern void register_mtd_parser(struct mtd_part_parser *parser);
 extern void deregister_mtd_parser(struct mtd_part_parser *parser);
 #endif
 
-int mtd_is_partition(const struct mtd_info *mtd);
 int mtd_add_partition(struct mtd_info *master, const char *name,
 		      long long offset, long long length);
 int mtd_del_partition(struct mtd_info *master, int partno);
 uint64_t mtd_get_device_size(const struct mtd_info *mtd);
 
+#if defined(CONFIG_MTD_PARTITIONS)
+int mtd_parse_partitions(struct mtd_info *parent, const char **_mtdparts,
+			 struct mtd_partition **_parts, int *_nparts);
+void mtd_free_parsed_partitions(struct mtd_partition *parts,
+				unsigned int nparts);
+#else
+static inline int
+mtd_parse_partitions(struct mtd_info *parent, const char **_mtdparts,
+		     struct mtd_partition **_parts, int *_nparts)
+{
+	*_nparts = 0;
+
+	return 0;
+}
+static inline void
+mtd_free_parsed_partitions(struct mtd_partition *parts, unsigned int nparts)
+{
+	return;
+}
+#endif /* defined(MTD_PARTITIONS) */
+
 #endif
diff --git a/include/linux/sizes.h b/include/linux/sizes.h
index ce3e8150c1..d3671d6cf2 100644
--- a/include/linux/sizes.h
+++ b/include/linux/sizes.h
@@ -40,8 +40,11 @@
 #define SZ_128M				0x08000000
 #define SZ_256M				0x10000000
 #define SZ_512M				0x20000000
+#define SZ_768M				0x30000000
 
 #define SZ_1G				0x40000000
 #define SZ_2G				0x80000000
+#define SZ_3G				0xc0000000
+#define SZ_4G				0x100000000ULL
 
 #endif /* __LINUX_SIZES_H__ */
diff --git a/include/linux/time.h b/include/linux/time.h
index bf12b99d37..b8d298eb4d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -93,11 +93,6 @@ _DEFUN (localtime_r, (tim_p, res),
 	rem += SECSPERDAY;
 	--days;
     }
-    while (rem >= SECSPERDAY)
-    {
-	rem -= SECSPERDAY;
-	++days;
-    }
 
     /* compute hour, min, and sec */
     res->tm_hour = (int) (rem / SECSPERHOUR);
diff --git a/include/linux/types.h b/include/linux/types.h
index 416fa66284..11c492a741 100644
--- a/include/linux/types.h
+++ b/include/linux/types.h
@@ -24,6 +24,8 @@ typedef __kernel_gid32_t	gid_t;
 typedef __kernel_uid16_t        uid16_t;
 typedef __kernel_gid16_t        gid16_t;
 
+typedef unsigned long		uintptr_t;
+
 #ifdef CONFIG_UID16
 /* This is defined by include/asm-{arch}/posix_types.h */
 typedef __kernel_old_uid_t	old_uid_t;
@@ -163,4 +165,7 @@ struct ustat {
 	char			f_fpack[6];
 };
 
+#define DECLARE_BITMAP(name, bits) \
+	unsigned long name[BITS_TO_LONGS(bits)]
+
 #endif /* _LINUX_TYPES_H */
diff --git a/include/linux/usb/ch9.h b/include/linux/usb/ch9.h
index 0ad4782a36..264c9712a3 100644
--- a/include/linux/usb/ch9.h
+++ b/include/linux/usb/ch9.h
@@ -418,6 +418,12 @@ struct __packed usb_class_report_descriptor {
 #define USB_ENDPOINT_XFER_INT		3
 #define USB_ENDPOINT_MAX_ADJUSTABLE	0x80
 
+#define USB_ENDPOINT_MAXP_MASK		0x07ff
+#define USB_EP_MAXP_MULT_SHIFT		11
+#define USB_EP_MAXP_MULT_MASK		(3 << USB_EP_MAXP_MULT_SHIFT)
+#define USB_EP_MAXP_MULT(m)		\
+	(((m) & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)
+
 /* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. */
 #define USB_ENDPOINT_INTRTYPE		0x30
 #define USB_ENDPOINT_INTR_PERIODIC	(0 << 4)
@@ -625,6 +631,20 @@ static inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)
 	return __le16_to_cpu(get_unaligned(&epd->wMaxPacketSize));
 }
 
+/**
+ * usb_endpoint_maxp_mult - get endpoint's transactional opportunities
+ * @epd: endpoint to be checked
+ *
+ * Return @epd's wMaxPacketSize[12:11] + 1
+ */
+static inline int
+usb_endpoint_maxp_mult(const struct usb_endpoint_descriptor *epd)
+{
+	int maxp = __le16_to_cpu(epd->wMaxPacketSize);
+
+	return USB_EP_MAXP_MULT(maxp) + 1;
+}
+
 static inline int usb_endpoint_interrupt_type(
 		const struct usb_endpoint_descriptor *epd)
 {
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index 86e1ceac3c..98c147456f 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -25,7 +25,7 @@
 #include <common.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
-#include <usb/lin_gadget_compat.h>
+#include <linux/bitmap.h>
 
 /*
  * USB function drivers should return USB_GADGET_DELAYED_STATUS if they
@@ -49,6 +49,9 @@ struct usb_configuration;
  * @hs_descriptors: Table of high speed descriptors, using interface and
  *	string identifiers assigned during @bind().  If this pointer is null,
  *	the function will not be available at high speed.
+ * @ss_descriptors: Table of super speed descriptors, using interface and
+ *	string identifiers assigned during @bind(). If this pointer is null,
+ *	the function will not be available at super speed.
  * @config: assigned when @usb_add_function() is called; this is the
  *	configuration with which this function is associated.
  * @bind: Before the gadget can register, all of its functions bind() to the
@@ -96,6 +99,7 @@ struct usb_function {
 	struct usb_gadget_strings	**strings;
 	struct usb_descriptor_header	**descriptors;
 	struct usb_descriptor_header	**hs_descriptors;
+	struct usb_descriptor_header	**ss_descriptors;
 
 	struct usb_configuration	*config;
 
@@ -224,6 +228,7 @@ struct usb_configuration {
 	struct list_head	list;
 	struct list_head	functions;
 	u8			next_interface_id;
+	unsigned		superspeed:1;
 	unsigned		highspeed:1;
 	unsigned		fullspeed:1;
 	struct usb_function	*interface[MAX_CONFIG_INTERFACES];
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index b824f13477..705ed14976 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -19,6 +19,7 @@
 #define __LINUX_USB_GADGET_H
 
 #include <errno.h>
+#include <usb.h>
 #include <linux/compat.h>
 #include <linux/list.h>
 
@@ -128,11 +129,30 @@ struct usb_ep_ops {
 	void (*fifo_flush) (struct usb_ep *ep);
 };
 
+/**
+ * struct usb_ep_caps - endpoint capabilities description
+ * @type_control:Endpoint supports control type (reserved for ep0).
+ * @type_iso:Endpoint supports isochronous transfers.
+ * @type_bulk:Endpoint supports bulk transfers.
+ * @type_int:Endpoint supports interrupt transfers.
+ * @dir_in:Endpoint supports IN direction.
+ * @dir_out:Endpoint supports OUT direction.
+ */
+struct usb_ep_caps {
+	unsigned type_control:1;
+	unsigned type_iso:1;
+	unsigned type_bulk:1;
+	unsigned type_int:1;
+	unsigned dir_in:1;
+	unsigned dir_out:1;
+};
+
 /**
  * struct usb_ep - device side representation of USB endpoint
  * @name:identifier for the endpoint, such as "ep-a" or "ep9in-bulk"
  * @ops: Function pointers used to access hardware-specific operations.
  * @ep_list:the gadget's ep_list holds all of its endpoints
+ * @caps:The structure describing types and directions supported by endoint.
  * @maxpacket:The maximum packet size used on this endpoint.  The initial
  *	value can sometimes be reduced (hardware allowing), according to
  *      the endpoint descriptor used to configure the endpoint.
@@ -158,6 +178,7 @@ struct usb_ep {
 	const char		*name;
 	const struct usb_ep_ops	*ops;
 	struct list_head	ep_list;
+	struct usb_ep_caps	caps;
 	unsigned		maxpacket:16;
 	unsigned		maxpacket_limit:16;
 	unsigned		max_streams:16;
@@ -427,6 +448,8 @@ static inline void usb_ep_fifo_flush(struct usb_ep *ep)
 
 
 /*-------------------------------------------------------------------------*/
+#define USB_DEFAULT_U1_DEV_EXIT_LAT	0x01	/* Less then 1 microsec */
+#define USB_DEFAULT_U2_DEV_EXIT_LAT	0x1F4	/* Less then 500 microsec */
 
 struct usb_gadget;
 struct usb_gadget_driver;
@@ -446,6 +469,11 @@ struct usb_gadget_ops {
 	int	(*udc_start)(struct usb_gadget *,
 			     struct usb_gadget_driver *);
 	int	(*udc_stop)(struct usb_gadget *);
+	struct usb_ep *(*match_ep)(struct usb_gadget *,
+			struct usb_endpoint_descriptor *,
+			struct usb_ss_ep_comp_descriptor *);
+	void	(*udc_set_speed)(struct usb_gadget *gadget,
+				 enum usb_device_speed);
 };
 
 /**
@@ -549,6 +577,15 @@ static inline int gadget_is_dualspeed(struct usb_gadget *g)
 #endif
 }
 
+/**
+ * gadget_is_superspeed() - return true if the hardware handles superspeed
+ * @g: controller that might support superspeed
+ */
+static inline int gadget_is_superspeed(struct usb_gadget *g)
+{
+	return g->max_speed >= USB_SPEED_SUPER;
+}
+
 /**
  * gadget_is_otg - return true iff the hardware is OTG-ready
  * @g: controller that might have a Mini-AB connector
@@ -926,4 +963,21 @@ extern void usb_ep_autoconfig_reset(struct usb_gadget *);
 
 extern int usb_gadget_handle_interrupts(int index);
 
+#if CONFIG_IS_ENABLED(DM_USB_GADGET)
+int usb_gadget_initialize(int index);
+int usb_gadget_release(int index);
+int dm_usb_gadget_handle_interrupts(struct udevice *dev);
+#else
+#include <usb.h>
+static inline int usb_gadget_initialize(int index)
+{
+	return board_usb_init(index, USB_INIT_DEVICE);
+}
+
+static inline int usb_gadget_release(int index)
+{
+	return board_usb_cleanup(index, USB_INIT_DEVICE);
+}
+#endif
+
 #endif	/* __LINUX_USB_GADGET_H */
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 8f8ac6aeef..333900b804 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -10,6 +10,8 @@
 #ifndef __LINUX_USB_OTG_H
 #define __LINUX_USB_OTG_H
 
+#include <dm/ofnode.h>
+
 enum usb_dr_mode {
 	USB_DR_MODE_UNKNOWN,
 	USB_DR_MODE_HOST,
@@ -19,11 +21,20 @@ enum usb_dr_mode {
 
 /**
  * usb_get_dr_mode() - Get dual role mode for given device
- * @node: Node offset to the given device
+ * @node: ofnode of the given device
  *
  * The function gets phy interface string from property 'dr_mode',
  * and returns the correspondig enum usb_dr_mode
  */
-enum usb_dr_mode usb_get_dr_mode(int node);
+enum usb_dr_mode usb_get_dr_mode(ofnode node);
+
+/**
+ * usb_get_maximum_speed() - Get maximum speed for given device
+ * @node: ofnode of the given device
+ *
+ * The function gets phy interface string from property 'maximum-speed',
+ * and returns the correspondig enum usb_device_speed
+ */
+enum usb_device_speed usb_get_maximum_speed(ofnode node);
 
 #endif /* __LINUX_USB_OTG_H */
diff --git a/include/lmb.h b/include/lmb.h
index 6b6959fd86..ece2a54e5b 100644
--- a/include/lmb.h
+++ b/include/lmb.h
@@ -11,7 +11,7 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
-#define MAX_LMB_REGIONS 8
+#define MAX_LMB_REGIONS 16
 
 struct lmb_property {
 	phys_addr_t base;
diff --git a/include/miiphy.h b/include/miiphy.h
index fe8928a3a9..89ad6760ab 100644
--- a/include/miiphy.h
+++ b/include/miiphy.h
@@ -118,4 +118,53 @@ int bb_miiphy_write(struct mii_dev *miidev, int addr, int devad, int reg,
 #define ESTATUS_1000XF		0x8000
 #define ESTATUS_1000XH		0x4000
 
+#ifdef CONFIG_DM_MDIO
+
+/**
+ * struct mdio_perdev_priv - Per-device class data for MDIO DM
+ *
+ * @mii_bus: Supporting MII legacy bus
+ */
+struct mdio_perdev_priv {
+	struct mii_dev *mii_bus;
+};
+
+/**
+ * struct mdio_ops - MDIO bus operations
+ *
+ * @read: Read from a PHY register
+ * @write: Write to a PHY register
+ * @reset: Reset the MDIO bus, NULL if not supported
+ */
+struct mdio_ops {
+	int (*read)(struct udevice *mdio_dev, int addr, int devad, int reg);
+	int (*write)(struct udevice *mdio_dev, int addr, int devad, int reg,
+		     u16 val);
+	int (*reset)(struct udevice *mdio_dev);
+};
+
+#define mdio_get_ops(dev) ((struct mdio_ops *)(dev)->driver->ops)
+
+/**
+ * dm_mdio_probe_devices - Call probe on all MII devices, currently used for
+ * MDIO console commands.
+ */
+void dm_mdio_probe_devices(void);
+
+/**
+ * dm_mdio_phy_connect - Wrapper over phy_connect for DM MDIO
+ *
+ * @dev: mdio dev
+ * @addr: PHY address on MDIO bus
+ * @ethdev: ethernet device to connect to the PHY
+ * @interface: MAC-PHY protocol
+ *
+ * @return pointer to phy_device, or 0 on error
+ */
+struct phy_device *dm_mdio_phy_connect(struct udevice *dev, int addr,
+				       struct udevice *ethdev,
+				       phy_interface_t interface);
+
+#endif
+
 #endif
diff --git a/include/mipi_display.h b/include/mipi_display.h
index ddcc8ca731..c86be58bb2 100644
--- a/include/mipi_display.h
+++ b/include/mipi_display.h
@@ -115,6 +115,14 @@ enum {
 	MIPI_DCS_READ_MEMORY_CONTINUE	= 0x3E,
 	MIPI_DCS_SET_TEAR_SCANLINE	= 0x44,
 	MIPI_DCS_GET_SCANLINE		= 0x45,
+	MIPI_DCS_SET_DISPLAY_BRIGHTNESS	= 0x51,		/* MIPI DCS 1.3 */
+	MIPI_DCS_GET_DISPLAY_BRIGHTNESS	= 0x52,		/* MIPI DCS 1.3 */
+	MIPI_DCS_WRITE_CONTROL_DISPLAY	= 0x53,		/* MIPI DCS 1.3 */
+	MIPI_DCS_GET_CONTROL_DISPLAY	= 0x54,		/* MIPI DCS 1.3 */
+	MIPI_DCS_WRITE_POWER_SAVE	= 0x55,		/* MIPI DCS 1.3 */
+	MIPI_DCS_GET_POWER_SAVE		= 0x56,		/* MIPI DCS 1.3 */
+	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 0x5E,	/* MIPI DCS 1.3 */
+	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 0x5F,	/* MIPI DCS 1.3 */
 	MIPI_DCS_READ_DDB_START		= 0xA1,
 	MIPI_DCS_READ_DDB_CONTINUE	= 0xA8,
 };
diff --git a/include/misc.h b/include/misc.h
index 03ef55cdc8..5586883eb1 100644
--- a/include/misc.h
+++ b/include/misc.h
@@ -7,6 +7,25 @@
 #ifndef _MISC_H_
 #define _MISC_H_
 
+#include <asm-generic/ioctl.h>
+
+/*
+ * Request command to be sent for misc_ioctl().
+ */
+#define IOCTL_REQ_START		_IO('m', 0x01)
+#define IOCTL_REQ_STOP		_IO('m', 0x02)
+#define IOCTL_REQ_POLL		_IO('m', 0x03)
+#define IOCTL_REQ_CAPABILITY	_IO('m', 0x04)
+#define IOCTL_REQ_DATA_SIZE	_IO('m', 0x05)
+
+enum misc_mode {
+	DECOM_LZ4	= BIT(0),
+	DECOM_GZIP	= BIT(1),
+	DECOM_ZLIB	= BIT(2),
+	OTP_S		= BIT(3),
+	OTP_NS		= BIT(4),
+};
+
 /*
  * Read the device to buffer, optional.
  *
@@ -58,6 +77,17 @@ int misc_ioctl(struct udevice *dev, unsigned long request, void *buf);
 int misc_call(struct udevice *dev, int msgid, void *tx_msg, int tx_size,
 	      void *rx_msg, int rx_size);
 
+/*
+ * Get a misc device by capability
+ *
+ * The caller can get a misc device according to capability request, the driver
+ * must implement the IOCTL_REQ_CAPABILITY callback.
+ *
+ * @capability: the value of enum misc_mode.
+ * @return the require device if OK, NULL on error
+ */
+struct udevice *misc_get_device_by_capability(u32 capability);
+
 /*
  * struct misc_ops - Driver model Misc operations
  *
@@ -111,4 +141,28 @@ struct misc_ops {
 		    void *rx_msg, int rx_size);
 };
 
+/* generic layer for otp */
+struct udevice *misc_otp_get_device(u32 capability);
+int misc_otp_read(struct udevice *dev, int offset, void *buf, int size);
+int misc_otp_write(struct udevice *dev, int offset, const void *buf, int size);
+
+/* generic layer for decompress */
+struct decom_param {
+	unsigned long addr_src;
+	unsigned long addr_dst;
+	u64 size_src;	/* compressed */
+	u64 size_dst;	/* decompressed, to be filled for output */
+	enum misc_mode mode;
+	u32 flags;
+};
+
+/* function flags for decompress */
+#define DCOMP_FLG_IRQ_ONESHOT	BIT(0)
+
+void misc_decompress_async(u8 comp);
+void misc_decompress_sync(u8 comp);
+int misc_decompress_cleanup(void);
+int misc_decompress_process(unsigned long dst, unsigned long src,
+			    unsigned long src_len, u32 cap, bool sync,
+			    u64 *size, u32 flags);
 #endif	/* _MISC_H_ */
diff --git a/include/mmc.h b/include/mmc.h
index 010ebe048c..0d23e40dd5 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -58,6 +58,9 @@
 #define MMC_MODE_8BIT		(1 << 3)
 #define MMC_MODE_SPI		(1 << 4)
 #define MMC_MODE_DDR_52MHz	(1 << 5)
+#define MMC_MODE_HS200		(1 << 6)
+#define MMC_MODE_HS400		(1 << 7)
+#define MMC_MODE_HS400ES	(1 << 8)
 
 #define SD_DATA_4BIT	0x00040000
 
@@ -82,6 +85,8 @@
 #define MMC_CMD_SET_BLOCKLEN		16
 #define MMC_CMD_READ_SINGLE_BLOCK	17
 #define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_SEND_TUNING_BLOCK		19
+#define MMC_SEND_TUNING_BLOCK_HS200	21
 #define MMC_CMD_SET_BLOCK_COUNT         23
 #define MMC_CMD_WRITE_SINGLE_BLOCK	24
 #define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
@@ -133,6 +138,7 @@
 
 #define MMC_STATE_PRG		(7 << 9)
 
+#define MMC_VDD_165_195_SHIFT	7
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
 #define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
@@ -182,6 +188,7 @@
 #define EXT_CSD_BOOT_BUS_WIDTH		177
 #define EXT_CSD_PART_CONF		179	/* R/W */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
+#define EXT_CSD_STROBE_SUPPORT		184	/* RO */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
@@ -189,6 +196,7 @@
 #define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
 #define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
 #define EXT_CSD_BOOT_MULT		226	/* RO */
+#define EXT_CSD_SEC_FEATURE_SUPPORT     231     /* RO */
 #define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
 
 /*
@@ -201,6 +209,18 @@
 
 #define EXT_CSD_CARD_TYPE_26	(1 << 0)	/* Card can run at 26MHz */
 #define EXT_CSD_CARD_TYPE_52	(1 << 1)	/* Card can run at 52MHz */
+#define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_26 | \
+				 EXT_CSD_CARD_TYPE_52)
+#define EXT_CSD_CARD_TYPE_HS200_1_8V	BIT(4)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_2V	BIT(5)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS200_1_2V)
+#define EXT_CSD_CARD_TYPE_HS400_1_8V	BIT(6)	/* Card can run at 200MHz DDR, 1.8V */
+#define EXT_CSD_CARD_TYPE_HS400_1_2V	BIT(7)	/* Card can run at 200MHz DDR, 1.2V */
+#define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS400_1_2V)
+#define EXT_CSD_CARD_TYPE_HS400ES	BIT(8)	/* Card can run at HS400ES */
+
 #define EXT_CSD_CARD_TYPE_DDR_1_8V	(1 << 2)
 #define EXT_CSD_CARD_TYPE_DDR_1_2V	(1 << 3)
 #define EXT_CSD_CARD_TYPE_DDR_52	(EXT_CSD_CARD_TYPE_DDR_1_8V \
@@ -212,6 +232,12 @@
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
 
+#define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
+#define EXT_CSD_TIMING_HS	1	/* High speed */
+#define EXT_CSD_TIMING_HS200	2	/* HS200 */
+#define EXT_CSD_TIMING_HS400	3	/* HS400 */
+#define EXT_CSD_DRV_STR_SHIFT	4	/* Driver Strength shift */
+
 #define EXT_CSD_BOOT_ACK_ENABLE			(1 << 6)
 #define EXT_CSD_BOOT_PARTITION_ENABLE		(1 << 3)
 #define EXT_CSD_PARTITION_ACCESS_ENABLE		(1 << 0)
@@ -248,6 +274,11 @@
 #define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
 #define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */
 
+#define EXT_CSD_SEC_ER_EN      BIT(0)
+#define EXT_CSD_SEC_BD_BLK_EN  BIT(2)
+#define EXT_CSD_SEC_GB_CL_EN   BIT(4)
+#define EXT_CSD_SEC_SANITIZE   BIT(6)  /* v4.5 only */
+
 #define MMC_RSP_NONE	(0)
 #define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 #define MMC_RSP_R1b	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE| \
@@ -274,6 +305,49 @@
 #define MMC_NUM_BOOT_PARTITION	2
 #define MMC_PART_RPMB           3       /* RPMB partition number */
 
+/* Sizes of RPMB data frame */
+#define RPMB_SZ_STUFF		196
+#define RPMB_SZ_MAC		32
+#define RPMB_SZ_DATA		256
+#define RPMB_SZ_NONCE		16
+
+/* Structure of RPMB data frame. */
+struct s_rpmb {
+	unsigned char stuff[RPMB_SZ_STUFF];
+	unsigned char mac[RPMB_SZ_MAC];
+	unsigned char data[RPMB_SZ_DATA];
+	unsigned char nonce[RPMB_SZ_NONCE];
+	unsigned int write_counter;
+	unsigned short address;
+	unsigned short block_count;
+	unsigned short result;
+	unsigned short request;
+} __packed;
+
+struct s_rpmb_verify {
+	unsigned char data[RPMB_SZ_DATA];
+	unsigned char nonce[RPMB_SZ_NONCE];
+	unsigned int write_counter;
+	unsigned short address;
+	unsigned short block_count;
+	unsigned short result;
+	unsigned short request;
+} __packed;
+
+int init_rpmb(void);
+int finish_rpmb(void);
+int do_readcounter(struct s_rpmb *requestpackets);
+int do_programkey(struct s_rpmb *requestpackets);
+int do_authenticatedread(struct s_rpmb *requestpackets, uint16_t block_count);
+int do_authenticatedwrite(struct s_rpmb *requestpackets);
+struct mmc *do_returnmmc(void);
+
+int read_counter(struct mmc *mmc, struct s_rpmb *requestpackets);
+int program_key(struct mmc *mmc, struct s_rpmb *requestpackets);
+int authenticated_read
+	(struct mmc *mmc, struct s_rpmb *requestpackets, uint16_t block_count);
+int authenticated_write(struct mmc *mmc, struct s_rpmb *requestpackets);
+
 /* Driver model support */
 
 /**
@@ -283,6 +357,10 @@ struct mmc_uclass_priv {
 	struct mmc *mmc;
 };
 
+struct emmc_esr {
+	unsigned int mmc_can_trim;
+};
+
 /**
  * mmc_get_mmc_dev() - get the MMC struct pointer for a device
  *
@@ -338,6 +416,26 @@ struct dm_mmc_ops {
 	int (*send_cmd)(struct udevice *dev, struct mmc_cmd *cmd,
 			struct mmc_data *data);
 
+	/**
+	 * send_cmd_prepare() - Send a command to the MMC device
+	 *
+	 * @dev:	Device to receive the command
+	 * @cmd:	Command to send
+	 * @data:	Additional data to send/receive
+	 * @return 0 if OK, -ve on error
+	 */
+#ifdef CONFIG_SPL_BLK_READ_PREPARE
+	int (*send_cmd_prepare)(struct udevice *dev, struct mmc_cmd *cmd,
+				struct mmc_data *data);
+#endif
+	/**
+	 * card_busy() - Query the card device status
+	 *
+	 * @dev:	Device to update
+	 * @return true if card device is busy
+	 */
+	bool (*card_busy)(struct udevice *dev);
+
 	/**
 	 * set_ios() - Set the I/O speed/width for an MMC device
 	 *
@@ -361,6 +459,17 @@ struct dm_mmc_ops {
 	 * @return 0 if write-enabled, 1 if write-protected, -ve on error
 	 */
 	int (*get_wp)(struct udevice *dev);
+
+	/**
+	 * execute_tuning() - Find the optimal sampling point of a data
+	 *			input signals.
+	 *
+	 * @dev:	Device to check
+	 * @opcode:	The tuning command opcode value is different
+	 *		for SD and eMMC cards
+	 * @return 0 if write-enabled, 1 if write-protected, -ve on error
+	 */
+	int (*execute_tuning)(struct udevice *dev, u32 opcode);
 };
 
 #define mmc_get_ops(dev)        ((struct dm_mmc_ops *)(dev)->driver->ops)
@@ -372,18 +481,22 @@ int dm_mmc_get_cd(struct udevice *dev);
 int dm_mmc_get_wp(struct udevice *dev);
 
 /* Transition functions for compatibility */
+bool mmc_card_busy(struct mmc *mmc);
+bool mmc_can_card_busy(struct mmc *mmc);
 int mmc_set_ios(struct mmc *mmc);
 int mmc_getcd(struct mmc *mmc);
 int mmc_getwp(struct mmc *mmc);
 
 #else
 struct mmc_ops {
+	bool (*card_busy)(struct mmc *mmc);
 	int (*send_cmd)(struct mmc *mmc,
 			struct mmc_cmd *cmd, struct mmc_data *data);
 	int (*set_ios)(struct mmc *mmc);
 	int (*init)(struct mmc *mmc);
 	int (*getcd)(struct mmc *mmc);
 	int (*getwp)(struct mmc *mmc);
+	int (*execute_tuning)(struct udevice *dev, u32 opcode);
 };
 #endif
 
@@ -422,7 +535,33 @@ struct mmc {
 	uint has_init;
 	int high_capacity;
 	uint bus_width;
+
+#define MMC_BUS_WIDTH_1BIT	1
+#define MMC_BUS_WIDTH_4BIT	4
+#define MMC_BUS_WIDTH_8BIT	8
+
+	uint timing;
+
+#define MMC_TIMING_LEGACY	0
+#define MMC_TIMING_MMC_HS	1
+#define MMC_TIMING_SD_HS	2
+#define MMC_TIMING_UHS_SDR12	3
+#define MMC_TIMING_UHS_SDR25	4
+#define MMC_TIMING_UHS_SDR50	5
+#define MMC_TIMING_UHS_SDR104	6
+#define MMC_TIMING_UHS_DDR50	7
+#define MMC_TIMING_MMC_DDR52	8
+#define MMC_TIMING_MMC_HS200	9
+#define MMC_TIMING_MMC_HS400	10
+#define MMC_TIMING_MMC_HS400ES	11
+
 	uint clock;
+
+#define MMC_HIGH_26_MAX_DTR	26000000
+#define MMC_HIGH_52_MAX_DTR	52000000
+#define MMC_HIGH_DDR_MAX_DTR	52000000
+#define MMC_HS200_MAX_DTR	200000000
+
 	uint card_caps;
 	uint ocr;
 	uint dsr;
@@ -435,12 +574,14 @@ struct mmc {
 	u8 part_attr;
 	u8 wr_rel_set;
 	u8 part_config;
-	uint tran_speed;
 	uint read_bl_len;
 	uint write_bl_len;
 	uint erase_grp_size;	/* in 512-byte sectors */
 	uint hc_wp_grp_size;	/* in 512-byte sectors */
+	int default_phase;	/* set the default sample clock phase */
+	uint init_retry;        /* re-init mmc when error occur */
 	struct sd_ssr	ssr;	/* SD status register */
+	struct emmc_esr esr;    /* emmc status register */
 	u64 capacity;
 	u64 capacity_user;
 	u64 capacity_boot;
@@ -454,7 +595,6 @@ struct mmc {
 	char op_cond_pending;	/* 1 if we are waiting on an op_cond command */
 	char init_in_progress;	/* 1 if we have done mmc_start_init() */
 	char preinit;		/* start init as early as possible */
-	int ddr_mode;
 #if CONFIG_IS_ENABLED(DM_MMC)
 	struct udevice *dev;	/* Device for this MMC controller */
 #endif
@@ -481,6 +621,42 @@ enum mmc_hwpart_conf_mode {
 	MMC_HWPART_CONF_COMPLETE,
 };
 
+static inline bool mmc_card_hs(struct mmc *mmc)
+{
+	return (mmc->timing == MMC_TIMING_MMC_HS) ||
+		(mmc->timing == MMC_TIMING_SD_HS);
+}
+
+static inline bool mmc_card_ddr(struct mmc *mmc)
+{
+	return (mmc->timing == MMC_TIMING_UHS_DDR50) ||
+		(mmc->timing == MMC_TIMING_MMC_DDR52) ||
+		(mmc->timing == MMC_TIMING_MMC_HS400) ||
+		(mmc->timing == MMC_TIMING_MMC_HS400ES);
+}
+
+static inline bool mmc_card_hs200(struct mmc *mmc)
+{
+	return mmc->timing == MMC_TIMING_MMC_HS200;
+}
+
+static inline bool mmc_card_ddr52(struct mmc *mmc)
+{
+	return mmc->timing == MMC_TIMING_MMC_DDR52;
+}
+
+static inline bool mmc_card_hs400(struct mmc *mmc)
+{
+	return mmc->timing == MMC_TIMING_MMC_HS400;
+}
+
+static inline bool mmc_card_hs400es(struct mmc *mmc)
+{
+	return mmc->timing == MMC_TIMING_MMC_HS400ES;
+}
+
+int mmc_send_tuning(struct mmc *mmc, u32 opcode);
+
 struct mmc *mmc_create(const struct mmc_config *cfg, void *priv);
 
 /**
@@ -602,4 +778,12 @@ int mmc_get_env_dev(void);
  */
 struct blk_desc *mmc_get_blk_desc(struct mmc *mmc);
 
+
+/**
+ * mmc_gpio_init_direct()
+ *
+ */
+void mmc_gpio_init_direct(void);
+
 #endif /* _MMC_H_ */
+
diff --git a/include/mpc8xx.h b/include/mpc8xx.h
index fc081ab756..daa874ccf5 100644
--- a/include/mpc8xx.h
+++ b/include/mpc8xx.h
@@ -81,7 +81,7 @@
 #define TBSCR_TBIRQ2	0x0400		/* Time Base Interrupt Request 2	*/
 #define TBSCR_TBIRQ1	0x0200		/* Time Base Interrupt Request 1	*/
 #define TBSCR_TBIRQ0	0x0100		/* Time Base Interrupt Request 0	*/
-#if 0	/* already in asm/8xx_immap.h */
+#if 0	/* already in asm/immap_8xx.h */
 #define TBSCR_REFA	0x0080		/* Reference Interrupt Status A		*/
 #define TBSCR_REFB	0x0040		/* Reference Interrupt Status B		*/
 #define TBSCR_REFAE	0x0008		/* Second Interrupt Enable A		*/
@@ -95,7 +95,7 @@
  */
 #undef	PISCR_PIRQ			/* TBD					*/
 #define PISCR_PITF	0x0002		/* Periodic Interrupt Timer Freeze	*/
-#if 0	/* already in asm/8xx_immap.h */
+#if 0	/* already in asm/immap_8xx.h */
 #define PISCR_PS	0x0080		/* Periodic interrupt Status		*/
 #define PISCR_PIE	0x0004		/* Periodic Interrupt Enable		*/
 #define PISCR_PTE	0x0001		/* Periodic Timer Enable		*/
diff --git a/include/mtd.h b/include/mtd.h
index 3f8c293b00..97a1061e36 100644
--- a/include/mtd.h
+++ b/include/mtd.h
@@ -9,15 +9,7 @@
 
 #include <linux/mtd/mtd.h>
 
-/*
- * Get mtd_info structure of the dev, which is stored as uclass private.
- *
- * @dev: The MTD device
- * @return: pointer to mtd_info, NULL on error
- */
-static inline struct mtd_info *mtd_get_info(struct udevice *dev)
-{
-	return dev_get_uclass_priv(dev);
-}
+int mtd_probe(struct udevice *dev);
+int mtd_probe_devices(void);
 
 #endif	/* _MTD_H_ */
diff --git a/include/mtd/cfi_flash.h b/include/mtd/cfi_flash.h
index eade2b3614..095725a805 100644
--- a/include/mtd/cfi_flash.h
+++ b/include/mtd/cfi_flash.h
@@ -62,6 +62,7 @@
 
 #define FLASH_OFFSET_MANUFACTURER_ID	0x00
 #define FLASH_OFFSET_DEVICE_ID		0x01
+#define FLASH_OFFSET_LOWER_SW_BITS	0x0C
 #define FLASH_OFFSET_DEVICE_ID2		0x0E
 #define FLASH_OFFSET_DEVICE_ID3		0x0F
 #define FLASH_OFFSET_CFI		0x55
diff --git a/include/nand.h b/include/nand.h
index c1c1d8cce6..37001698bf 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -32,7 +32,7 @@ unsigned long nand_size(void);
 
 #include <linux/compat.h>
 #include <linux/mtd/mtd.h>
-#include <linux/mtd/nand.h>
+#include <linux/mtd/rawnand.h>
 
 int nand_mtd_to_devnum(struct mtd_info *mtd);
 
@@ -153,4 +153,7 @@ void sunxi_nand_init(void);
  */
 struct mtd_info *get_nand_dev_by_index(int dev);
 
+/* rockchip platform specific init functions */
+int rk_nand_init(void);
+
 #endif /* _NAND_H_ */
diff --git a/include/net.h b/include/net.h
index 455b48f6c7..109c15e283 100644
--- a/include/net.h
+++ b/include/net.h
@@ -538,7 +538,7 @@ extern int		net_restart_wrap;	/* Tried all network devices */
 
 enum proto_t {
 	BOOTP, RARP, ARP, TFTPGET, DHCP, PING, DNS, NFS, CDP, NETCONS, SNTP,
-	TFTPSRV, TFTPPUT, LINKLOCAL
+	TFTPSRV, TFTPPUT, LINKLOCAL, FASTBOOT
 };
 
 extern char	net_boot_file_name[1024];/* Boot File name */
@@ -552,6 +552,10 @@ extern char *net_dns_resolve;		/* The host to resolve  */
 extern char *net_dns_env_var;		/* the env var to put the ip into */
 #endif
 
+#if defined(CONFIG_UDP_FUNCTION_FASTBOOT)
+int do_fastboot_udp(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[]);
+#endif
+
 #if defined(CONFIG_CMD_PING)
 extern struct in_addr net_ping_ip;	/* the ip address to ping */
 #endif
diff --git a/include/netdev.h b/include/netdev.h
index b9bfebac67..426158a266 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -11,6 +11,7 @@
 
 #ifndef _NETDEV_H_
 #define _NETDEV_H_
+#include <phy_interface.h>
 
 /*
  * Board and CPU-specific initialization functions
@@ -22,6 +23,8 @@
  */
 
 int board_eth_init(bd_t *bis);
+int board_interface_eth_init(struct udevice *dev,
+			     phy_interface_t interface_type);
 int cpu_eth_init(bd_t *bis);
 
 /* Driver initialization prototypes */
diff --git a/include/nvme.h b/include/nvme.h
index 8375d61e02..7e66c37639 100644
--- a/include/nvme.h
+++ b/include/nvme.h
@@ -79,4 +79,16 @@ int nvme_scan_namespace(void);
  */
 int nvme_print_info(struct udevice *udev);
 
+/**
+ * nvme_get_namespace_id - return namespace identifier
+ *
+ * This returns the namespace identifier.
+ *
+ * @udev:	NVMe controller device
+ * @ns_id:	Place where to put the name space identifier
+ * @eui64:	Place where to put the IEEE Extended Unique Identifier
+ * @return:	0 on success, -ve on error
+ */
+int nvme_get_namespace_id(struct udevice *udev, u32 *ns_id, u8 *eui64);
+
 #endif /* __NVME_H__ */
diff --git a/include/part.h b/include/part.h
index 0d5c99836b..a00c97b329 100644
--- a/include/part.h
+++ b/include/part.h
@@ -29,12 +29,19 @@ struct block_drvr {
 #define PART_TYPE_ISO		0x03
 #define PART_TYPE_AMIGA		0x04
 #define PART_TYPE_EFI		0x05
+#define PART_TYPE_RKPARM	0x06
+#define PART_TYPE_RKRAM		0x07
+#define PART_TYPE_ENV		0x08
 
 /* maximum number of partition entries supported by search */
 #define DOS_ENTRY_NUMBERS	8
 #define ISO_ENTRY_NUMBERS	64
 #define MAC_ENTRY_NUMBERS	64
 #define AMIGA_ENTRY_NUMBERS	8
+#define RKPARM_ENTRY_NUMBERS	128
+#define RKRAM_ENTRY_NUMBERS	6
+#define ENV_ENTRY_NUMBERS	64
+
 /*
  * Type string for U-Boot bootable partitions
  */
@@ -98,6 +105,12 @@ int host_get_dev_err(int dev, struct blk_desc **blk_devp);
 
 /* disk/part.c */
 int part_get_info(struct blk_desc *dev_desc, int part, disk_partition_t *info);
+/**
+ * part_get_info_whole_disk() - get partition info for the special case of
+ * a partition occupying the entire disk.
+ */
+int part_get_info_whole_disk(struct blk_desc *dev_desc, disk_partition_t *info);
+const char *part_get_type(struct blk_desc *dev_desc);
 void part_print(struct blk_desc *dev_desc);
 void part_init(struct blk_desc *dev_desc);
 void dev_print(struct blk_desc *dev_desc);
@@ -181,6 +194,20 @@ int blk_get_device_part_str(const char *ifname, const char *dev_part_str,
 int part_get_info_by_name(struct blk_desc *dev_desc,
 			      const char *name, disk_partition_t *info);
 
+/**
+ * part_get_info_by_name_strict() - Search for a partition by name
+ *                                  among all available registered partitions
+ *				    with strict name match
+ *
+ * @param dev_desc - block device descriptor
+ * @param gpt_name - the specified table entry name to be match strictly
+ * @param info - returns the disk partition info
+ *
+ * @return - the partition number on match (starting on 1), -1 on no match,
+ * otherwise error
+ */
+int part_get_info_by_name_strict(struct blk_desc *dev_desc, const char *name,
+				 disk_partition_t *info);
 /**
  * part_set_generic_name() - create generic partition like hda1 or sdb2
  *
@@ -203,6 +230,11 @@ static inline struct blk_desc *mg_disk_get_dev(int dev) { return NULL; }
 
 static inline int part_get_info(struct blk_desc *dev_desc, int part,
 				disk_partition_t *info) { return -1; }
+static inline int part_get_info_whole_disk(struct blk_desc *dev_desc,
+					   disk_partition_t *info)
+{ return -1; }
+
+static inline const char *part_get_type(struct blk_desc *dev_desc) { return NULL; }
 static inline void part_print(struct blk_desc *dev_desc) {}
 static inline void part_init(struct blk_desc *dev_desc) {}
 static inline void dev_print(struct blk_desc *dev_desc) {}
@@ -218,22 +250,16 @@ static inline int blk_get_device_part_str(const char *ifname,
 #endif
 
 /*
- * We don't support printing partition information in SPL and only support
- * getting partition information in a few cases.
+ * We don't support printing partition information in SPL.
  */
 #ifdef CONFIG_SPL_BUILD
-# define part_print_ptr(x)	NULL
-# if defined(CONFIG_SPL_EXT_SUPPORT) || defined(CONFIG_SPL_FAT_SUPPORT) || \
-	defined(CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION)
-#  define part_get_info_ptr(x)	x
-# else
-#  define part_get_info_ptr(x)	NULL
-# endif
+#define part_print_ptr(x)	NULL
 #else
-#define part_print_ptr(x)	x
-#define part_get_info_ptr(x)	x
+#define part_print_ptr(x)       x
 #endif
 
+#define part_get_info_ptr(x)	x
+
 
 struct part_driver {
 	const char *name;
@@ -271,8 +297,9 @@ struct part_driver {
 #define U_BOOT_PART_TYPE(__name)					\
 	ll_entry_declare(struct part_driver, __name, part_driver)
 
-#if CONFIG_IS_ENABLED(EFI_PARTITION)
 #include <part_efi.h>
+
+#if CONFIG_IS_ENABLED(EFI_PARTITION)
 /* disk/part_efi.c */
 /**
  * write_gpt_table() - Write the GUID Partition Table to disk
@@ -420,5 +447,13 @@ int write_mbr_partition(struct blk_desc *dev_desc, void *buf);
 
 #endif
 
+#if CONFIG_IS_ENABLED(ENV_PARTITION)
+/**
+ * env_part_list_init() - pass partitons list to env part
+ *
+ * @param list - partitons list
+ */
+void env_part_list_init(const char *list);
+#endif
 
 #endif /* _PART_H */
diff --git a/include/part_efi.h b/include/part_efi.h
index 317c044795..4c8f6cc473 100644
--- a/include/part_efi.h
+++ b/include/part_efi.h
@@ -27,7 +27,7 @@
 #define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
 #define GPT_HEADER_REVISION_V1 0x00010000
 #define GPT_PRIMARY_PARTITION_TABLE_LBA 1ULL
-#define GPT_ENTRY_NUMBERS		128
+#define GPT_ENTRY_NUMBERS		CONFIG_EFI_PARTITION_ENTRIES_NUMBERS
 #define GPT_ENTRY_SIZE			128
 
 #define PARTITION_SYSTEM_GUID \
@@ -58,10 +58,6 @@
 /* linux/include/efi.h */
 typedef u16 efi_char16_t;
 
-typedef struct {
-	u8 b[16];
-} efi_guid_t;
-
 /* based on linux/include/genhd.h */
 struct partition {
 	u8 boot_ind;		/* 0x80 - active */
diff --git a/include/phy.h b/include/phy.h
index a0b1f12317..2a7446b5d8 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -10,10 +10,12 @@
 #ifndef _PHY_H
 #define _PHY_H
 
+#include <dm.h>
 #include <linux/list.h>
 #include <linux/mii.h>
 #include <linux/ethtool.h>
 #include <linux/mdio.h>
+#include <phy_interface.h>
 
 #define PHY_FIXED_ID		0xa5a55a5a
 
@@ -49,58 +51,6 @@
 #endif
 
 
-typedef enum {
-	PHY_INTERFACE_MODE_MII,
-	PHY_INTERFACE_MODE_GMII,
-	PHY_INTERFACE_MODE_SGMII,
-	PHY_INTERFACE_MODE_SGMII_2500,
-	PHY_INTERFACE_MODE_QSGMII,
-	PHY_INTERFACE_MODE_TBI,
-	PHY_INTERFACE_MODE_RMII,
-	PHY_INTERFACE_MODE_RGMII,
-	PHY_INTERFACE_MODE_RGMII_ID,
-	PHY_INTERFACE_MODE_RGMII_RXID,
-	PHY_INTERFACE_MODE_RGMII_TXID,
-	PHY_INTERFACE_MODE_RTBI,
-	PHY_INTERFACE_MODE_XGMII,
-	PHY_INTERFACE_MODE_XAUI,
-	PHY_INTERFACE_MODE_RXAUI,
-	PHY_INTERFACE_MODE_SFI,
-	PHY_INTERFACE_MODE_NONE,	/* Must be last */
-
-	PHY_INTERFACE_MODE_COUNT,
-} phy_interface_t;
-
-static const char *phy_interface_strings[] = {
-	[PHY_INTERFACE_MODE_MII]		= "mii",
-	[PHY_INTERFACE_MODE_GMII]		= "gmii",
-	[PHY_INTERFACE_MODE_SGMII]		= "sgmii",
-	[PHY_INTERFACE_MODE_SGMII_2500]		= "sgmii-2500",
-	[PHY_INTERFACE_MODE_QSGMII]		= "qsgmii",
-	[PHY_INTERFACE_MODE_TBI]		= "tbi",
-	[PHY_INTERFACE_MODE_RMII]		= "rmii",
-	[PHY_INTERFACE_MODE_RGMII]		= "rgmii",
-	[PHY_INTERFACE_MODE_RGMII_ID]		= "rgmii-id",
-	[PHY_INTERFACE_MODE_RGMII_RXID]		= "rgmii-rxid",
-	[PHY_INTERFACE_MODE_RGMII_TXID]		= "rgmii-txid",
-	[PHY_INTERFACE_MODE_RTBI]		= "rtbi",
-	[PHY_INTERFACE_MODE_XGMII]		= "xgmii",
-	[PHY_INTERFACE_MODE_XAUI]		= "xaui",
-	[PHY_INTERFACE_MODE_RXAUI]		= "rxaui",
-	[PHY_INTERFACE_MODE_SFI]		= "sfi",
-	[PHY_INTERFACE_MODE_NONE]		= "",
-};
-
-static inline const char *phy_string_for_interface(phy_interface_t i)
-{
-	/* Default to unknown */
-	if (i > PHY_INTERFACE_MODE_NONE)
-		i = PHY_INTERFACE_MODE_NONE;
-
-	return phy_interface_strings[i];
-}
-
-
 struct phy_device;
 
 #define MDIO_NAME_LEN 32
@@ -152,6 +102,14 @@ struct phy_driver {
 	int (*readext)(struct phy_device *phydev, int addr, int devad, int reg);
 	int (*writeext)(struct phy_device *phydev, int addr, int devad, int reg,
 			u16 val);
+
+	/* Phy specific driver override for reading a MMD register */
+	int (*read_mmd)(struct phy_device *phydev, int devad, int reg);
+
+	/* Phy specific driver override for writing a MMD register */
+	int (*write_mmd)(struct phy_device *phydev, int devad, int reg,
+			 u16 val);
+
 	struct list_head list;
 };
 
@@ -164,6 +122,7 @@ struct phy_device {
 
 #ifdef CONFIG_DM_ETH
 	struct udevice *dev;
+	ofnode node;
 #else
 	struct eth_device *dev;
 #endif
@@ -188,6 +147,7 @@ struct phy_device {
 	int pause;
 	int asym_pause;
 	u32 phy_id;
+	bool is_c45;
 	u32 flags;
 };
 
@@ -214,6 +174,68 @@ static inline int phy_write(struct phy_device *phydev, int devad, int regnum,
 	return bus->write(bus, phydev->addr, devad, regnum, val);
 }
 
+static inline void phy_mmd_start_indirect(struct phy_device *phydev, int devad,
+					  int regnum)
+{
+	/* Write the desired MMD Devad */
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_MMD_CTRL, devad);
+
+	/* Write the desired MMD register address */
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_MMD_DATA, regnum);
+
+	/* Select the Function : DATA with no post increment */
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_MMD_CTRL,
+		  (devad | MII_MMD_CTRL_NOINCR));
+}
+
+static inline int phy_read_mmd(struct phy_device *phydev, int devad,
+			       int regnum)
+{
+	struct phy_driver *drv = phydev->drv;
+
+	if (regnum > (u16)~0 || devad > 32)
+		return -EINVAL;
+
+	/* driver-specific access */
+	if (drv->read_mmd)
+		return drv->read_mmd(phydev, devad, regnum);
+
+	/* direct C45 / C22 access */
+	if ((drv->features & PHY_10G_FEATURES) == PHY_10G_FEATURES ||
+	    devad == MDIO_DEVAD_NONE || !devad)
+		return phy_read(phydev, devad, regnum);
+
+	/* indirect C22 access */
+	phy_mmd_start_indirect(phydev, devad, regnum);
+
+	/* Read the content of the MMD's selected register */
+	return phy_read(phydev, MDIO_DEVAD_NONE, MII_MMD_DATA);
+}
+
+static inline int phy_write_mmd(struct phy_device *phydev, int devad,
+				int regnum, u16 val)
+{
+	struct phy_driver *drv = phydev->drv;
+
+	if (regnum > (u16)~0 || devad > 32)
+		return -EINVAL;
+
+	/* driver-specific access */
+	if (drv->write_mmd)
+		return drv->write_mmd(phydev, devad, regnum, val);
+
+	/* direct C45 / C22 access */
+	if ((drv->features & PHY_10G_FEATURES) == PHY_10G_FEATURES ||
+	    devad == MDIO_DEVAD_NONE || !devad)
+		return phy_write(phydev, devad, regnum, val);
+
+	/* indirect C22 access */
+	phy_mmd_start_indirect(phydev, devad, regnum);
+
+	/* Write the data into MMD's selected register */
+	return phy_write(phydev, MDIO_DEVAD_NONE, MII_MMD_DATA, val);
+}
+
 #ifdef CONFIG_PHYLIB_10G
 extern struct phy_driver gen10g_driver;
 
@@ -225,20 +247,111 @@ static inline int is_10g_interface(phy_interface_t interface)
 
 #endif
 
+/**
+ * phy_init() - Initializes the PHY drivers
+ *
+ * This function registers all available PHY drivers
+ *
+ * @return 0 if OK, -ve on error
+ */
 int phy_init(void);
+
+/**
+ * phy_reset() - Resets the specified PHY
+ *
+ * Issues a reset of the PHY and waits for it to complete
+ *
+ * @phydev:	PHY to reset
+ * @return 0 if OK, -ve on error
+ */
 int phy_reset(struct phy_device *phydev);
+
+/**
+ * phy_find_by_mask() - Searches for a PHY on the specified MDIO bus
+ *
+ * The function checks the PHY addresses flagged in phy_mask and returns a
+ * phy_device pointer if it detects a PHY.
+ * This function should only be called if just one PHY is expected to be present
+ * in the set of addresses flagged in phy_mask.  If multiple PHYs are present,
+ * it is undefined which of these PHYs is returned.
+ *
+ * @bus:	MII/MDIO bus to scan
+ * @phy_mask:	bitmap of PYH addresses to scan
+ * @interface:	type of MAC-PHY interface
+ * @return pointer to phy_device if a PHY is found, or NULL otherwise
+ */
 struct phy_device *phy_find_by_mask(struct mii_dev *bus, unsigned phy_mask,
 		phy_interface_t interface);
+
 #ifdef CONFIG_DM_ETH
+
+/**
+ * phy_connect_dev() - Associates the given pair of PHY and Ethernet devices
+ * @phydev:	PHY device
+ * @dev:	Ethernet device
+ */
 void phy_connect_dev(struct phy_device *phydev, struct udevice *dev);
+
+/**
+ * phy_connect() - Creates a PHY device for the Ethernet interface
+ *
+ * Creates a PHY device for the PHY at the given address, if one doesn't exist
+ * already, and associates it with the Ethernet device.
+ * The function may be called with addr <= 0, in this case addr value is ignored
+ * and the bus is scanned to detect a PHY.  Scanning should only be used if only
+ * one PHY is expected to be present on the MDIO bus, otherwise it is undefined
+ * which PHY is returned.
+ *
+ * @bus:	MII/MDIO bus that hosts the PHY
+ * @addr:	PHY address on MDIO bus
+ * @dev:	Ethernet device to associate to the PHY
+ * @interface:	type of MAC-PHY interface
+ * @return pointer to phy_device if a PHY is found, or NULL otherwise
+ */
 struct phy_device *phy_connect(struct mii_dev *bus, int addr,
 				struct udevice *dev,
 				phy_interface_t interface);
+
+static inline ofnode phy_get_ofnode(struct phy_device *phydev)
+{
+	if (ofnode_valid(phydev->node))
+		return phydev->node;
+	else
+		return dev_ofnode(phydev->dev);
+}
 #else
+
+/**
+ * phy_connect_dev() - Associates the given pair of PHY and Ethernet devices
+ * @phydev:	PHY device
+ * @dev:	Ethernet device
+ */
 void phy_connect_dev(struct phy_device *phydev, struct eth_device *dev);
+
+/**
+ * phy_connect() - Creates a PHY device for the Ethernet interface
+ *
+ * Creates a PHY device for the PHY at the given address, if one doesn't exist
+ * already, and associates it with the Ethernet device.
+ * The function may be called with addr <= 0, in this case addr value is ignored
+ * and the bus is scanned to detect a PHY.  Scanning should only be used if only
+ * one PHY is expected to be present on the MDIO bus, otherwise it is undefined
+ * which PHY is returned.
+ *
+ * @bus:	MII/MDIO bus that hosts the PHY
+ * @addr:	PHY address on MDIO bus
+ * @dev:	Ethernet device to associate to the PHY
+ * @interface:	type of MAC-PHY interface
+ * @return pointer to phy_device if a PHY is found, or NULL otherwise
+ */
 struct phy_device *phy_connect(struct mii_dev *bus, int addr,
 				struct eth_device *dev,
 				phy_interface_t interface);
+
+static inline ofnode phy_get_ofnode(struct phy_device *phydev)
+{
+	return ofnode_null();
+}
 #endif
 int phy_startup(struct phy_device *phydev);
 int phy_config(struct phy_device *phydev);
@@ -270,6 +383,7 @@ int phy_micrel_ksz8xxx_init(void);
 int phy_micrel_ksz90x1_init(void);
 int phy_natsemi_init(void);
 int phy_realtek_init(void);
+int phy_rk630_init(void);
 int phy_smsc_init(void);
 int phy_teranetics_init(void);
 int phy_ti_init(void);
@@ -312,7 +426,9 @@ static inline bool phy_interface_is_sgmii(struct phy_device *phydev)
 }
 
 /* PHY UIDs for various PHYs that are referenced in external code */
-#define PHY_UID_CS4340  0x13e51002
-#define PHY_UID_TN2020	0x00a19410
+#define PHY_UID_CS4340  	0x13e51002
+#define PHY_UID_CS4223  	0x03e57003
+#define PHY_UID_TN2020		0x00a19410
+#define PHY_UID_IN112525_S03	0x02107440
 
 #endif
diff --git a/include/post.h b/include/post.h
index d5278111e8..b41a6c8127 100644
--- a/include/post.h
+++ b/include/post.h
@@ -15,7 +15,7 @@
 #include <common.h>
 #include <asm/io.h>
 
-#if defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)
+#if defined(CONFIG_POST)
 
 #ifndef CONFIG_POST_EXTERNAL_WORD_FUNCS
 #ifdef CONFIG_SYS_POST_WORD_ADDR
@@ -58,7 +58,7 @@ extern ulong post_word_load(void);
 extern void post_word_store(ulong value);
 
 #endif /* CONFIG_POST_EXTERNAL_WORD_FUNCS */
-#endif /* defined (CONFIG_POST) || defined(CONFIG_LOGBUFFER) */
+#endif /* defined (CONFIG_POST) */
 #endif /* __ASSEMBLY__ */
 
 #ifdef CONFIG_POST
diff --git a/include/power/pmic.h b/include/power/pmic.h
index 4b34316427..68ad5e571a 100644
--- a/include/power/pmic.h
+++ b/include/power/pmic.h
@@ -11,6 +11,7 @@
 #ifndef __CORE_PMIC_H_
 #define __CORE_PMIC_H_
 
+#include <dm/ofnode.h>
 #include <i2c.h>
 #include <linux/list.h>
 #include <power/power_chrg.h>
@@ -164,6 +165,9 @@ struct dm_pmic_ops {
 	int (*read)(struct udevice *dev, uint reg, uint8_t *buffer, int len);
 	int (*write)(struct udevice *dev, uint reg, const uint8_t *buffer,
 		     int len);
+	int (*suspend)(struct udevice *dev);
+	int (*resume)(struct udevice *dev);
+	int (*shutdown)(struct udevice *dev);
 };
 
 /**
@@ -187,6 +191,7 @@ enum pmic_op_type {
  * @driver - driver name for the sub-node with prefix
  */
 struct pmic_child_info {
+	const char *addr;
 	const char *prefix;
 	const char *driver;
 };
@@ -297,6 +302,30 @@ int pmic_reg_write(struct udevice *dev, uint reg, uint value);
  */
 int pmic_clrsetbits(struct udevice *dev, uint reg, uint clr, uint set);
 
+/**
+ * pmic_suspend() - suspend of PMIC
+ *
+ * @dev:	PMIC device
+ * @return 0 on success or negative value of errno.
+ */
+int pmic_suspend(struct udevice *dev);
+
+/**
+ * pmic_resume() - resume of PMIC
+ *
+ * @dev:	PMIC device
+ * @return 0 on success or negative value of errno.
+ */
+int pmic_resume(struct udevice *dev);
+
+/**
+ * pmic_shutdown() - power off supplies of PMIC
+ *
+ * @dev:	PMIC device to update
+ * @return 0 on success or negative value of errno.
+ */
+int pmic_shutdown(struct udevice *dev);
+
 #endif /* CONFIG_DM_PMIC */
 
 #ifdef CONFIG_POWER
diff --git a/include/power/regulator.h b/include/power/regulator.h
index 2bbc1e51b3..8f45d7203a 100644
--- a/include/power/regulator.h
+++ b/include/power/regulator.h
@@ -168,6 +168,7 @@ struct dm_regulator_uclass_platdata {
 	int mode_count;
 	int min_uV;
 	int max_uV;
+	int init_uV;
 	int min_uA;
 	int max_uA;
 	bool always_on;
@@ -176,6 +177,10 @@ struct dm_regulator_uclass_platdata {
 	int flags;
 	u8 ctrl_reg;
 	u8 volt_reg;
+	bool suspend_on;
+	bool ignore;
+	u32 suspend_uV;
+	u32 ramp_delay;
 };
 
 /* Regulator device operations */
@@ -191,6 +196,8 @@ struct dm_regulator_ops {
 	 */
 	int (*get_value)(struct udevice *dev);
 	int (*set_value)(struct udevice *dev, int uV);
+	int (*set_suspend_value)(struct udevice *dev, int uV);
+	int (*get_suspend_value)(struct udevice *dev);
 
 	/**
 	 * The regulator output current function calls operates on a micro Amps.
@@ -215,6 +222,8 @@ struct dm_regulator_ops {
 	 */
 	int (*get_enable)(struct udevice *dev);
 	int (*set_enable)(struct udevice *dev, bool enable);
+	int (*set_suspend_enable)(struct udevice *dev, bool enable);
+	int (*get_suspend_enable)(struct udevice *dev);
 
 	/**
 	 * The 'get/set_mode()' function calls should operate on a driver-
@@ -232,6 +241,15 @@ struct dm_regulator_ops {
 	 */
 	int (*get_mode)(struct udevice *dev);
 	int (*set_mode)(struct udevice *dev, int mode_id);
+
+	/**
+	 * The regulator voltage set ramp delay
+	 *
+	 * @dev            - regulator device
+	 * @ramp_delay     - ramp delay [uV/uS]
+	 * @return zero on success and other failed.
+	 */
+	int (*set_ramp_delay)(struct udevice *dev, u32 ramp_delay);
 };
 
 /**
@@ -260,6 +278,23 @@ int regulator_get_value(struct udevice *dev);
  */
 int regulator_set_value(struct udevice *dev, int uV);
 
+/**
+ * regulator_set_suspend_value: set the suspend microvoltage value of a given regulator.
+ *
+ * @dev    - pointer to the regulator device
+ * @uV     - the output suspend value to set [micro Volts]
+ * @return - 0 on success or -errno val if fails
+ */
+int regulator_set_suspend_value(struct udevice *dev, int uV);
+
+/**
+ * regulator_get_suspend_value: get the suspend microvoltage value of a given regulator.
+ *
+ * @dev    - pointer to the regulator device
+ * @return - positive output value [uV] on success or negative errno if fail.
+ */
+int regulator_get_suspend_value(struct udevice *dev);
+
 /**
  * regulator_set_value_force: set the microvoltage value of a given regulator
  *			      without any min-,max condition check
@@ -304,6 +339,23 @@ int regulator_get_enable(struct udevice *dev);
  */
 int regulator_set_enable(struct udevice *dev, bool enable);
 
+/**
+ * regulator_set_suspend_enable: set regulator suspend enable state
+ *
+ * @dev    - pointer to the regulator device
+ * @enable - set true or false
+ * @return - 0 on success or -errno val if fails
+ */
+int regulator_set_suspend_enable(struct udevice *dev, bool enable);
+
+/**
+ * regulator_get_suspend_enable: get regulator suspend enable state
+ *
+ * @dev    - pointer to the regulator device
+ * @return - 0 on success or -errno val if fails
+ */
+int regulator_get_suspend_enable(struct udevice *dev);
+
 /**
  * regulator_get_mode: get active operation mode id of a given regulator
  *
@@ -343,23 +395,11 @@ int regulator_set_mode(struct udevice *dev, int mode_id);
 int regulators_enable_boot_on(bool verbose);
 
 /**
- * regulator_autoset: setup the voltage/current on a regulator
+ * regulators_enable_state_mem() - enable regulators state mem configure
  *
- * The setup depends on constraints found in device's uclass's platform data
- * (struct dm_regulator_uclass_platdata):
- *
- * - Enable - will set - if any of: 'always_on' or 'boot_on' is set to true,
- *   or if both are unset, then the function returns
- * - Voltage value - will set - if '.min_uV' and '.max_uV' values are equal
- * - Current limit - will set - if '.min_uA' and '.max_uA' values are equal
- *
- * The function returns on the first-encountered error.
- *
- * @platname - expected string for dm_regulator_uclass_platdata .name field
- * @devp     - returned pointer to the regulator device - if non-NULL passed
- * @return: 0 on success or negative value of errno.
+ * This sets regulator-state-mem state for all regulators ;
  */
-int regulator_autoset(struct udevice *dev);
+int regulators_enable_state_mem(bool verbose);
 
 /**
  * regulator_autoset_by_name: setup the regulator given by its uclass's
diff --git a/include/power/rk8xx_pmic.h b/include/power/rk8xx_pmic.h
index 47a6b36e7e..aa51e887e4 100644
--- a/include/power/rk8xx_pmic.h
+++ b/include/power/rk8xx_pmic.h
@@ -170,14 +170,107 @@ enum {
 	RK808_NUM_OF_REGS,
 };
 
+enum {
+	RK817_REG_SYS_CFG3 = 0xf4,
+};
+
+enum {
+	RK816_REG_DCDC_EN1 = 0x23,
+	RK816_REG_DCDC_EN2,
+	RK816_REG_DCDC_SLP_EN,
+	RK816_REG_LDO_SLP_EN,
+	RK816_REG_LDO_EN1 = 0x27,
+	RK816_REG_LDO_EN2,
+};
+
 enum {
 	RK805_ID = 0x8050,
+	RK806_ID = 0x8060,
 	RK808_ID = 0x0000,
+	RK809_ID = 0x8090,
+	RK816_ID = 0x8160,
+	RK817_ID = 0x8170,
 	RK818_ID = 0x8180,
 };
 
+enum {
+	RK817_POWER_EN0 = 0xb1,
+	RK817_POWER_EN1,
+	RK817_POWER_EN2,
+	RK817_POWER_EN3,
+};
+#define RK817_POWER_EN_SAVE0	0x99
+#define RK817_POWER_EN_SAVE1	0xa4
+
+#define RK817_ID_MSB	0xed
+#define RK817_ID_LSB	0xee
 #define RK8XX_ID_MSK	0xfff0
 
+#define RK817_PMIC_SYS_CFG1	0xf1
+#define RK817_PMIC_SYS_CFG3	0xf4
+#define RK817_GPIO_INT_CFG	0xfe
+
+#define RK8XX_ON_SOURCE		0xae
+#define RK8XX_OFF_SOURCE	0xaf
+#define RK817_BUCK4_CMIN	0xc6
+#define RK817_ON_SOURCE		0xf5
+#define RK817_OFF_SOURCE	0xf6
+#define RK817_NUM_OF_REGS	0xff
+
+#define RK8XX_DEVCTRL_REG	0x4b
+#define RK817_PWRON_KEY		0xf7
+#define RK8XX_LP_ACTION_MSK	BIT(6)
+#define RK8XX_LP_OFF		(0 << 6)
+#define RK8XX_LP_RESTART	(1 << 6)
+#define RK8XX_LP_OFF_MSK	BIT(4) | BIT(5)
+#define RK8XX_LP_TIME_6S	(0 << 4)
+#define RK8XX_LP_TIME_8S	(1 << 4)
+#define RK8XX_LP_TIME_10S	(2 << 4)
+#define RK8XX_LP_TIME_12S	(3 << 4)
+
+/* IRQ definitions */
+#define RK8XX_IRQ_PWRON_FALL		0
+#define RK8XX_IRQ_PWRON_RISE		1
+#define RK8XX_IRQ_PLUG_OUT		2
+#define RK8XX_IRQ_PLUG_IN		3
+#define RK8XX_IRQ_CHG_OK		4
+
+#define RK808_INT_STS_REG1		0x4c
+#define RK808_INT_MSK_REG1		0x4d
+#define RK808_IRQ_PLUG_OUT_MSK		BIT(1)
+
+#define RK805_INT_STS_REG		0x4c
+#define RK805_INT_MSK_REG		0x4d
+#define RK805_IRQ_PWRON_FALL_MSK	BIT(7)
+#define RK805_IRQ_PWRON_RISE_MSK	BIT(0)
+
+#define RK816_INT_STS_REG1		0x49
+#define RK816_INT_MSK_REG1		0x4a
+#define RK816_INT_STS_REG3		0x4e
+#define RK816_INT_STS_MSK_REG3		0x4f
+#define RK816_IRQ_PWRON_RISE_MSK	BIT(6)
+#define RK816_IRQ_PWRON_FALL_MSK	BIT(5)
+#define RK816_IRQ_PLUG_OUT_MSK		BIT(1)
+#define RK816_IRQ_CHR_OK_MSK		BIT(2)
+
+#define RK818_INT_STS_REG1		0x4c
+#define RK818_INT_MSK_REG1		0x4d
+#define RK818_IRQ_PLUG_OUT_MSK		BIT(1)
+#define RK818_IRQ_CHR_OK_MSK		BIT(2)
+
+#define	RK817_INT_STS_REG0		0xf8
+#define	RK817_INT_MSK_REG0		0xf9
+#define RK817_IRQ_PWRON_FALL_MSK	BIT(0)
+#define RK817_IRQ_PWRON_RISE_MSK	BIT(1)
+#define RK817_IRQ_PLUG_OUT_MSK		BIT(1)
+#define RK817_IRQ_PLUG_IN_MSK		BIT(0)
+
+struct reg_data {
+	u8 reg;
+	u8 val;
+	u8 mask;
+};
+
 struct rk8xx_reg_table {
 	char *name;
 	u8 reg_ctl;
@@ -185,7 +278,15 @@ struct rk8xx_reg_table {
 };
 
 struct rk8xx_priv {
+	struct virq_chip *irq_chip;
+	struct spi_slave *slave;
 	int variant;
+	int irq;
+	int lp_off_time;
+	int lp_action;
+	uint8_t sleep_pin;
+	uint8_t rst_fun;
+	int not_save_power_en;
 };
 
 int rk8xx_spl_configure_buck(struct udevice *pmic, int buck, int uvolt);
diff --git a/include/power/sandbox_pmic.h b/include/power/sandbox_pmic.h
index 7fdbfb9fc6..c5e6fda2ea 100644
--- a/include/power/sandbox_pmic.h
+++ b/include/power/sandbox_pmic.h
@@ -13,7 +13,7 @@
 #define SANDBOX_BUCK_DRIVER		"sandbox_buck"
 #define SANDBOX_OF_BUCK_PREFIX		"buck"
 
-#define SANDBOX_BUCK_COUNT	2
+#define SANDBOX_BUCK_COUNT	3
 #define SANDBOX_LDO_COUNT	2
 /*
  * Sandbox PMIC registers:
@@ -109,6 +109,9 @@ enum {
 #define SANDBOX_BUCK1_PLATNAME	"SUPPLY_1.2V"
 #define SANDBOX_BUCK2_DEVNAME	"buck2"
 #define SANDBOX_BUCK2_PLATNAME	"SUPPLY_3.3V"
+/* BUCK3: for testing fallback regulator prefix matching during bind */
+#define SANDBOX_BUCK3_DEVNAME	"no_match_by_nodename"
+#define SANDBOX_BUCK3_PLATNAME	"buck_SUPPLY_1.5V"
 /* LDO names */
 #define SANDBOX_LDO1_DEVNAME	"ldo1"
 #define SANDBOX_LDO1_PLATNAME	"VDD_EMMC_1.8V"
diff --git a/include/ppc_asm.tmpl b/include/ppc_asm.tmpl
index 18783340d9..4947c77b8d 100644
--- a/include/ppc_asm.tmpl
+++ b/include/ppc_asm.tmpl
@@ -81,7 +81,7 @@
 #define	r30	30
 #define	r31	31
 
-#if defined(CONFIG_8xx)
+#if defined(CONFIG_MPC8xx)
 
 /* Some special registers */
 
@@ -93,10 +93,10 @@
 #define LCTRL2	157	/* Load/Store Support	    (37-41) */
 #define ICTRL	158
 
-#endif	/* CONFIG_8xx */
+#endif	/* CONFIG_MPC8xx */
 
 
-#if defined(CONFIG_8xx)
+#if defined(CONFIG_MPC8xx)
 
 /* Registers in the processor's internal memory map that we use.
 */
diff --git a/include/regmap.h b/include/regmap.h
index 1eed94e47a..f515f27e03 100644
--- a/include/regmap.h
+++ b/include/regmap.h
@@ -46,6 +46,54 @@ int regmap_read(struct regmap *map, uint offset, uint *valp);
 #define regmap_read32(map, ptr, member, valp) \
 	regmap_read(map, (uint32_t *)(ptr)->member - (uint32_t *)(ptr), valp)
 
+/**
+ * regmap_read_poll_timeout - Poll until a condition is met or a timeout occurs
+ *
+ * @map:	Regmap to read from
+ * @addr:	Offset to poll
+ * @val:	Unsigned integer variable to read the value into
+ * @cond:	Break condition (usually involving @val)
+ * @sleep_us:	Maximum time to sleep between reads in us (0 tight-loops).
+ * @timeout_ms:	Timeout in ms, 0 means never timeout
+ *
+ * Returns 0 on success and -ETIMEDOUT upon a timeout or the regmap_read
+ * error return value in case of a error read. In the two former cases,
+ * the last read value at @addr is stored in @val. Must not be called
+ * from atomic context if sleep_us or timeout_us are used.
+ *
+ * This is modelled after the regmap_read_poll_timeout macros in linux but
+ * with millisecond timeout.
+ */
+#define regmap_read_poll_timeout(map, addr, val, cond, sleep_us, timeout_ms) \
+({ \
+	unsigned long __start = get_timer(0); \
+	int __ret; \
+	for (;;) { \
+		__ret = regmap_read((map), (addr), &(val)); \
+		if (__ret) \
+			break; \
+		if (cond) \
+			break; \
+		if ((timeout_ms) && get_timer(__start) > (timeout_ms)) { \
+			__ret = regmap_read((map), (addr), &(val)); \
+			break; \
+		} \
+		if ((sleep_us)) \
+			udelay((sleep_us)); \
+	} \
+	__ret ?: ((cond) ? 0 : -ETIMEDOUT); \
+})
+
+/**
+ * regmap_update_bits() - Perform a read/modify/write using a mask
+ *
+ * @map:	The map returned by regmap_init_mem*()
+ * @offset:	Offset of the memory
+ * @mask:	Mask to apply to the read value
+ * @val:	Value to apply to the value to write
+ */
+int regmap_update_bits(struct regmap *map, uint offset, uint mask, uint val);
+
 /**
  * regmap_init_mem() - Set up a new register map that uses memory access
  *
@@ -69,7 +117,7 @@ int regmap_init_mem(struct udevice *dev, struct regmap **mapp);
  * @count:	Number of pairs (e.g. 1 if the regmap has a single entry)
  * @mapp:	Returns allocated map
  */
-int regmap_init_mem_platdata(struct udevice *dev, u32 *reg, int count,
+int regmap_init_mem_platdata(struct udevice *dev, fdt_val_t *reg, int count,
 			     struct regmap **mapp);
 
 /**
diff --git a/include/reset.h b/include/reset.h
index 7185ade7ac..ae247ceb4f 100644
--- a/include/reset.h
+++ b/include/reset.h
@@ -60,6 +60,24 @@ struct reset_ctl {
 	unsigned long id;
 };
 
+/**
+ * struct reset_ctl_bulk - A handle to (allowing control of) a bulk of reset
+ * signals.
+ *
+ * Clients provide storage for the reset control bulk. The content of the
+ * structure is managed solely by the reset API. A reset control bulk struct is
+ * initialized by "get"ing the reset control bulk struct.
+ * The reset control bulk struct is passed to all other bulk reset APIs to apply
+ * the API to all the reset signals in the bulk struct.
+ *
+ * @resets: An array of reset signal handles handles.
+ * @count: The number of reset signal handles in the reset array.
+ */
+struct reset_ctl_bulk {
+	struct reset_ctl *resets;
+	unsigned int count;
+};
+
 #ifdef CONFIG_DM_RESET
 /**
  * reset_get_by_index - Get/request a reset signal by integer index.
@@ -80,6 +98,22 @@ struct reset_ctl {
 int reset_get_by_index(struct udevice *dev, int index,
 		       struct reset_ctl *reset_ctl);
 
+/**
+ * reset_get_bulk - Get/request all reset signals of a device.
+ *
+ * This looks up and requests all reset signals of the client device; each
+ * device is assumed to have n reset signals associated with it somehow,
+ * and this function finds and requests all of them in a separate structure.
+ * The mapping of client device reset signals indices to provider reset signals
+ * may be via device-tree properties, board-provided mapping tables, or some
+ * other mechanism.
+ *
+ * @dev:	The client device.
+ * @bulk	A pointer to a reset control bulk struct to initialize.
+ * @return 0 if OK, or a negative error code.
+ */
+int reset_get_bulk(struct udevice *dev, struct reset_ctl_bulk *bulk);
+
 /**
  * reset_get_by_name - Get/request a reset signal by name.
  *
@@ -131,6 +165,21 @@ int reset_free(struct reset_ctl *reset_ctl);
  */
 int reset_assert(struct reset_ctl *reset_ctl);
 
+/**
+ * reset_assert_bulk - Assert all reset signals in a reset control bulk struct.
+ *
+ * This function will assert the specified reset signals in a reset control
+ * bulk struct, thus resetting the affected HW module(s). Depending on the
+ * reset controller hardware, the reset signals will either stay asserted
+ * until reset_deassert_bulk() is called, or the hardware may autonomously
+ * clear the reset signals itself.
+ *
+ * @bulk:	A reset control bulk struct that was previously successfully
+ *		requested by reset_get_bulk().
+ * @return 0 if OK, or a negative error code.
+ */
+int reset_assert_bulk(struct reset_ctl_bulk *bulk);
+
 /**
  * reset_deassert - Deassert a reset signal.
  *
@@ -144,6 +193,20 @@ int reset_assert(struct reset_ctl *reset_ctl);
  */
 int reset_deassert(struct reset_ctl *reset_ctl);
 
+/**
+ * reset_deassert_bulk - Deassert all reset signals in a reset control bulk
+ * struct.
+ *
+ * This function will deassert the specified reset signals in a reset control
+ * bulk struct, thus releasing the affected HW modules() from reset, and
+ * allowing them to continue normal operation.
+ *
+ * @bulk:	A reset control bulk struct that was previously successfully
+ *		requested by reset_get_bulk().
+ * @return 0 if OK, or a negative error code.
+ */
+int reset_deassert_bulk(struct reset_ctl_bulk *bulk);
+
 /**
  * reset_release_all - Assert/Free an array of previously requested resets.
  *
@@ -156,6 +219,23 @@ int reset_deassert(struct reset_ctl *reset_ctl);
  * @return 0 if OK, or a negative error code.
  */
 int reset_release_all(struct reset_ctl *reset_ctl, int count);
+
+/**
+ * reset_release_bulk - Assert/Free an array of previously requested reset
+ * signals in a reset control bulk struct.
+ *
+ * For each reset contained in the reset control bulk struct, this function
+ * will check if reset has been previously requested and then will assert
+ * and free it.
+ *
+ * @bulk:	A reset control bulk struct that was previously successfully
+ *		requested by reset_get_bulk().
+ * @return 0 if OK, or a negative error code.
+ */
+static inline int reset_release_bulk(struct reset_ctl_bulk *bulk)
+{
+	return reset_release_all(bulk->resets, bulk->count);
+}
 #else
 static inline int reset_get_by_index(struct udevice *dev, int index,
 				     struct reset_ctl *reset_ctl)
@@ -163,6 +243,12 @@ static inline int reset_get_by_index(struct udevice *dev, int index,
 	return -ENOTSUPP;
 }
 
+static inline int reset_get_bulk(struct udevice *dev,
+				 struct reset_ctl_bulk *bulk)
+{
+	return -ENOTSUPP;
+}
+
 static inline int reset_get_by_name(struct udevice *dev, const char *name,
 				    struct reset_ctl *reset_ctl)
 {
@@ -179,16 +265,30 @@ static inline int reset_assert(struct reset_ctl *reset_ctl)
 	return 0;
 }
 
+static inline int reset_assert_bulk(struct reset_ctl_bulk *bulk)
+{
+	return 0;
+}
+
 static inline int reset_deassert(struct reset_ctl *reset_ctl)
 {
 	return 0;
 }
 
+static inline int reset_deassert_bulk(struct reset_ctl_bulk *bulk)
+{
+	return 0;
+}
+
 static inline int reset_release_all(struct reset_ctl *reset_ctl, int count)
 {
 	return 0;
 }
 
+static inline int reset_release_bulk(struct reset_ctl_bulk *bulk)
+{
+	return 0;
+}
 #endif
 
 #endif
diff --git a/include/rtc.h b/include/rtc.h
index 49142b6e18..e429c7899f 100644
--- a/include/rtc.h
+++ b/include/rtc.h
@@ -72,6 +72,13 @@ struct rtc_ops {
 	* @return 0 if OK, -ve on error
 	*/
 	int (*write8)(struct udevice *dev, unsigned int reg, int val);
+
+	/**
+	 * alarm_trigger()
+	 * @dev:		Device to write to
+	 * @return 1 if rtc alarm trigger boot on
+	 */
+	int (*alarm_trigger)(struct udevice *dev);
 };
 
 /* Access the operations for an RTC device */
@@ -167,6 +174,13 @@ int rtc_read32(struct udevice *dev, unsigned int reg, u32 *valuep);
  */
 int rtc_write32(struct udevice *dev, unsigned int reg, u32 value);
 
+/**
+ * rtc_alarm_trigger()
+ *
+ * @dev:	Device to write to
+ * @return 1 if rtc alarm trigger boot on
+ */
+int rtc_alarm_trigger(struct udevice *dev);
 #else
 int rtc_get (struct rtc_time *);
 int rtc_set (struct rtc_time *);
diff --git a/include/sdhci.h b/include/sdhci.h
index 7e84012f60..354f1e7099 100644
--- a/include/sdhci.h
+++ b/include/sdhci.h
@@ -64,6 +64,7 @@
 #define  SDHCI_CARD_STATE_STABLE	BIT(17)
 #define  SDHCI_CARD_DETECT_PIN_LEVEL	BIT(18)
 #define  SDHCI_WRITE_PROTECT	BIT(19)
+#define SDHCI_DATA_0_LVL	BIT(20)
 
 #define SDHCI_HOST_CONTROL	0x28
 #define  SDHCI_CTRL_LED		BIT(0)
@@ -146,6 +147,23 @@
 #define SDHCI_ACMD12_ERR	0x3C
 
 /* 3E-3F reserved */
+#define SDHCI_HOST_CONTROL2		0x3E
+#define SDHCI_CTRL_UHS_MASK		0x0007
+#define SDHCI_CTRL_UHS_SDR12		0x0000
+#define SDHCI_CTRL_UHS_SDR25		0x0001
+#define SDHCI_CTRL_UHS_SDR50		0x0002
+#define SDHCI_CTRL_UHS_SDR104		0x0003
+#define SDHCI_CTRL_UHS_DDR50		0x0004
+#define SDHCI_CTRL_HS400		0x0005
+#define SDHCI_CTRL_VDD_180		0x0008
+#define SDHCI_CTRL_DRV_TYPE_MASK	0x0030
+#define SDHCI_CTRL_DRV_TYPE_B		0x0000
+#define SDHCI_CTRL_DRV_TYPE_A		0x0010
+#define SDHCI_CTRL_DRV_TYPE_C		0x0020
+#define SDHCI_CTRL_DRV_TYPE_D		0x0030
+#define SDHCI_CTRL_EXEC_TUNING		0x0040
+#define SDHCI_CTRL_TUNED_CLK		0x0080
+#define SDHCI_CTRL_PRESET_VAL_ENABLE	0x8000
 
 #define SDHCI_CAPABILITIES	0x40
 #define  SDHCI_TIMEOUT_CLK_MASK	0x0000003F
@@ -236,7 +254,8 @@ struct sdhci_ops {
 	int	(*get_cd)(struct sdhci_host *host);
 	void	(*set_control_reg)(struct sdhci_host *host);
 	void	(*set_ios_post)(struct sdhci_host *host);
-	void	(*set_clock)(struct sdhci_host *host, u32 div);
+	int	(*set_clock)(struct sdhci_host *host, unsigned int clock);
+	void	(*set_clock_ext)(struct sdhci_host *host, u32 div);
 };
 
 struct sdhci_host {
@@ -261,6 +280,8 @@ struct sdhci_host {
 	struct mmc_config cfg;
 };
 
+int sdhci_set_clock(struct sdhci_host *host, unsigned int clock);
+
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
 
 static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
diff --git a/include/sdp.h b/include/sdp.h
index f476bab8f1..c64908b69d 100644
--- a/include/sdp.h
+++ b/include/sdp.h
@@ -11,6 +11,13 @@
 #define __SDP_H_
 
 int sdp_init(int controller_index);
-void sdp_handle(int controller_index);
+
+#ifdef CONFIG_SPL_BUILD
+#include <spl.h>
+
+int spl_sdp_handle(int controller_index, struct spl_image_info *spl_image);
+#else
+int sdp_handle(int controller_index);
+#endif
 
 #endif /* __SDP_H_ */
diff --git a/include/serial.h b/include/serial.h
index d87f01082a..e418b02f30 100644
--- a/include/serial.h
+++ b/include/serial.h
@@ -207,4 +207,12 @@ void sh_serial_initialize(void);
 void uartlite_serial_initialize(void);
 void zynq_serial_initialize(void);
 
+/* serial device */
+int serial_dev_getc(struct udevice *dev);
+int serial_dev_tstc(struct udevice *dev);
+void serial_dev_putc(struct udevice *dev, char ch);
+void serial_dev_puts(struct udevice *dev, const char *str);
+void serial_dev_setbrg(struct udevice *dev, int baudrate);
+void serial_dev_clear(struct udevice *dev);
+
 #endif
diff --git a/include/sound.h b/include/sound.h
index 155e1b40e2..73c1daaf3e 100644
--- a/include/sound.h
+++ b/include/sound.h
@@ -53,4 +53,14 @@ int sound_init(const void *blob);
  */
 int sound_play(uint32_t msec, uint32_t frequency);
 
+struct snd_soc_dai_ops {
+	int (*hw_params)(struct udevice *dev, unsigned int samplerate,
+			 unsigned int fmt, unsigned int channels);
+	int (*startup)(struct udevice *dev);
+	int (*shutdown)(struct udevice *dev);
+	int (*transfer)(struct udevice *dev, unsigned int *data,
+			unsigned long data_size);
+	int (*set_sysclk)(struct udevice *dev, unsigned int freq);
+};
+
 #endif  /* __SOUND__H__ */
diff --git a/include/spi.h b/include/spi.h
index 8c4b882c54..2442559aa3 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -10,6 +10,8 @@
 #ifndef _SPI_H_
 #define _SPI_H_
 
+#include <common.h>
+
 /* SPI mode flags */
 #define SPI_CPHA	BIT(0)			/* clock phase */
 #define SPI_CPOL	BIT(1)			/* clock polarity */
@@ -29,16 +31,31 @@
 #define SPI_RX_SLOW	BIT(11)			/* receive with 1 wire slow */
 #define SPI_RX_DUAL	BIT(12)			/* receive with 2 wires */
 #define SPI_RX_QUAD	BIT(13)			/* receive with 4 wires */
+#define SPI_TX_OCTAL	BIT(14)			/* transmit with 8 wires */
+#define SPI_RX_OCTAL	BIT(15)			/* receive with 8 wires */
+#define SPI_DMA_PREPARE	BIT(24)			/* dma transfer skip waiting idle */
 
 /* Header byte that marks the start of the message */
 #define SPI_PREAMBLE_END_BYTE	0xec
 
 #define SPI_DEFAULT_WORDLEN	8
 
-#ifdef CONFIG_DM_SPI
-/* TODO(sjg@chromium.org): Remove this and use max_hz from struct spi_slave */
+/**
+ * struct dm_spi_bus - SPI bus info
+ *
+ * This contains information about a SPI bus. To obtain this structure, use
+ * dev_get_uclass_priv(bus) where bus is the SPI bus udevice.
+ *
+ * @max_hz:	Maximum speed that the bus can tolerate.
+ * @speed:	Current bus speed. This is 0 until the bus is first claimed.
+ * @mode:	Current bus mode. This is 0 until the bus is first claimed.
+ *
+ * TODO(sjg@chromium.org): Remove this and use max_hz from struct spi_slave.
+ */
 struct dm_spi_bus {
 	uint max_hz;
+	uint speed;
+	uint mode;
 };
 
 /**
@@ -61,8 +78,6 @@ struct dm_spi_slave_platdata {
 	uint mode;
 };
 
-#endif /* CONFIG_DM_SPI */
-
 /**
  * struct spi_slave - Representation of a SPI slave
  *
@@ -78,16 +93,16 @@ struct dm_spi_slave_platdata {
  *
  * @dev:		SPI slave device
  * @max_hz:		Maximum speed for this slave
- * @speed:		Current bus speed. This is 0 until the bus is first
- *			claimed.
  * @bus:		ID of the bus that the slave is attached to. For
  *			driver model this is the sequence number of the SPI
  *			bus (bus->seq) so does not need to be stored
  * @cs:			ID of the chip select connected to the slave.
  * @mode:		SPI mode to use for this slave (see SPI mode flags)
  * @wordlen:		Size of SPI word in number of bits
+ * @max_read_size:	If non-zero, the maximum number of bytes which can
+ *			be read at once.
  * @max_write_size:	If non-zero, the maximum number of bytes which can
- *			be written at once, excluding command bytes.
+ *			be written at once.
  * @memory_map:		Address of read-only SPI flash access.
  * @flags:		Indication of SPI flags.
  */
@@ -95,13 +110,13 @@ struct spi_slave {
 #ifdef CONFIG_DM_SPI
 	struct udevice *dev;	/* struct spi_slave is dev->parentdata */
 	uint max_hz;
-	uint speed;
 #else
 	unsigned int bus;
 	unsigned int cs;
 #endif
 	uint mode;
 	unsigned int wordlen;
+	unsigned int max_read_size;
 	unsigned int max_write_size;
 	void *memory_map;
 	u8 option;
@@ -112,6 +127,7 @@ struct spi_slave {
 #define SPI_XFER_ONCE		(SPI_XFER_BEGIN | SPI_XFER_END)
 #define SPI_XFER_MMAP		BIT(2)	/* Memory Mapped start */
 #define SPI_XFER_MMAP_END	BIT(3)	/* Memory Mapped End */
+#define SPI_XFER_PREPARE	BIT(7)	/* Transfer skip waiting idle */
 };
 
 /**
@@ -228,7 +244,7 @@ void spi_release_bus(struct spi_slave *slave);
 int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen);
 
 /**
- * SPI transfer
+ * SPI transfer (optional if mem_ops is used)
  *
  * This writes "bitlen" bits out the SPI MOSI port and simultaneously clocks
  * "bitlen" bits in the SPI MISO port.  That's just the way SPI works.
@@ -252,6 +268,26 @@ int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen);
 int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		void *din, unsigned long flags);
 
+/**
+ * spi_write_then_read - SPI synchronous write followed by read
+ *
+ * This performs a half duplex transaction in which the first transaction
+ * is to send the opcode and if the length of buf is non-zero then it start
+ * the second transaction as tx or rx based on the need from respective slave.
+ *
+ * @slave:	The SPI slave device with which opcode/data will be exchanged
+ * @opcode:	opcode used for specific transfer
+ * @n_opcode:	size of opcode, in bytes
+ * @txbuf:	buffer into which data to be written
+ * @rxbuf:	buffer into which data will be read
+ * @n_buf:	size of buf (whether it's [tx|rx]buf), in bytes
+ *
+ * Returns: 0 on success, not 0 on failure
+ */
+int spi_write_then_read(struct spi_slave *slave, const u8 *opcode,
+			size_t n_opcode, const u8 *txbuf, u8 *rxbuf,
+			size_t n_buf);
+
 /* Copy memory mapped data */
 void spi_flash_copy_mmap(void *data, void *offset, size_t len);
 
@@ -315,33 +351,6 @@ static inline int spi_w8r8(struct spi_slave *slave, unsigned char byte)
 	return ret < 0 ? ret : din[1];
 }
 
-/**
- * Set up a SPI slave for a particular device tree node
- *
- * This calls spi_setup_slave() with the correct bus number. Call
- * spi_free_slave() to free it later.
- *
- * @param blob:		Device tree blob
- * @param slave_node:	Slave node to use
- * @param spi_node:	SPI peripheral node to use
- * @return pointer to new spi_slave structure
- */
-struct spi_slave *spi_setup_slave_fdt(const void *blob, int slave_node,
-				      int spi_node);
-
-/**
- * spi_base_setup_slave_fdt() - helper function to set up a SPI slace
- *
- * This decodes SPI properties from the slave node to determine the
- * chip select and SPI parameters.
- *
- * @blob:	Device tree blob
- * @busnum:	Bus number to use
- * @node:	Device tree node for the SPI bus
- */
-struct spi_slave *spi_base_setup_slave_fdt(const void *blob, int busnum,
-					   int node);
-
 #ifdef CONFIG_DM_SPI
 
 /**
@@ -428,6 +437,15 @@ struct dm_spi_ops {
 	int (*xfer)(struct udevice *dev, unsigned int bitlen, const void *dout,
 		    void *din, unsigned long flags);
 
+	/**
+	 * Optimized handlers for SPI memory-like operations.
+	 *
+	 * Optimized/dedicated operations for interactions with SPI memory. This
+	 * field is optional and should only be implemented if the controller
+	 * has native support for memory like operations.
+	 */
+	const struct spi_controller_mem_ops *mem_ops;
+
 	/**
 	 * Set transfer speed.
 	 * This sets a new speed to be applied for next spi_xfer().
@@ -464,6 +482,19 @@ struct dm_spi_ops {
 	 *	   is invalid, other -ve value on error
 	 */
 	int (*cs_info)(struct udevice *bus, uint cs, struct spi_cs_info *info);
+
+	/**
+	 * get_mmap() - Get memory-mapped SPI
+	 *
+	 * @dev:	The SPI flash slave device
+	 * @map_basep:	Returns base memory address for mapped SPI
+	 * @map_sizep:	Returns size of mapped SPI
+	 * @offsetp:	Returns start offset of SPI flash where the map works
+	 *	correctly (offsets before this are not visible)
+	 * @return 0 if OK, -EFAULT if memory mapping is not available
+	 */
+	int (*get_mmap)(struct udevice *dev, ulong *map_basep,
+			uint *map_sizep, uint *offsetp);
 };
 
 struct dm_spi_emul_ops {
@@ -518,14 +549,15 @@ int spi_find_bus_and_cs(int busnum, int cs, struct udevice **busp,
  * device and slave device.
  *
  * If no such slave exists, and drv_name is not NULL, then a new slave device
- * is automatically bound on this chip select.
+ * is automatically bound on this chip select with requested speed and mode.
  *
- * Ths new slave device is probed ready for use with the given speed and mode.
+ * Ths new slave device is probed ready for use with the speed and mode
+ * from platdata when available or the requested values.
  *
  * @busnum:	SPI bus number
  * @cs:		Chip select to look for
- * @speed:	SPI speed to use for this slave
- * @mode:	SPI mode to use for this slave
+ * @speed:	SPI speed to use for this slave when not available in platdata
+ * @mode:	SPI mode to use for this slave when not available in platdata
  * @drv_name:	Name of driver to attach to this chip select
  * @dev_name:	Name of the new device thus created
  * @busp:	Returns bus device
@@ -549,7 +581,8 @@ int spi_chip_select(struct udevice *slave);
  * @bus:	SPI bus to search
  * @cs:		Chip select to look for
  * @devp:	Returns the slave device if found
- * @return 0 if found, -ENODEV on error
+ * @return 0 if found, -EINVAL if cs is invalid, -ENODEV if no device attached,
+ *	   other -ve value on error
  */
 int spi_find_chip_select(struct udevice *bus, int cs, struct udevice **devp);
 
@@ -651,6 +684,20 @@ void dm_spi_release_bus(struct udevice *dev);
 int dm_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		const void *dout, void *din, unsigned long flags);
 
+/**
+ * spi_get_mmap() - Get memory-mapped SPI
+ *
+ * @dev:	SPI slave device to check
+ * @map_basep:	Returns base memory address for mapped SPI
+ * @map_sizep:	Returns size of mapped SPI
+ * @offsetp:	Returns start offset of SPI flash where the map works
+ *	correctly (offsets before this are not visible)
+ * @return 0 if OK, -ENOSYS if no operation, -EFAULT if memory mapping is not
+ *	available
+ */
+int dm_spi_get_mmap(struct udevice *dev, ulong *map_basep, uint *map_sizep,
+		    uint *offsetp);
+
 /* Access the operations for a SPI device */
 #define spi_get_ops(dev)	((struct dm_spi_ops *)(dev)->driver->ops)
 #define spi_emul_get_ops(dev)	((struct dm_spi_emul_ops *)(dev)->driver->ops)
diff --git a/include/spi_flash.h b/include/spi_flash.h
index be2fe3f84c..825f4f54b4 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -12,6 +12,7 @@
 
 #include <dm.h>	/* Because we dereference struct udevice here */
 #include <linux/types.h>
+#include <linux/mtd/spi-nor.h>
 
 #ifndef CONFIG_SF_DEFAULT_SPEED
 # define CONFIG_SF_DEFAULT_SPEED	1000000
@@ -28,91 +29,24 @@
 
 struct spi_slave;
 
-/**
- * struct spi_flash - SPI flash structure
- *
- * @spi:		SPI slave
- * @dev:		SPI flash device
- * @name:		Name of SPI flash
- * @dual_flash:		Indicates dual flash memories - dual stacked, parallel
- * @shift:		Flash shift useful in dual parallel
- * @flags:		Indication of spi flash flags
- * @size:		Total flash size
- * @page_size:		Write (page) size
- * @sector_size:	Sector size
- * @erase_size:		Erase size
- * @bank_read_cmd:	Bank read cmd
- * @bank_write_cmd:	Bank write cmd
- * @bank_curr:		Current flash bank
- * @erase_cmd:		Erase cmd 4K, 32K, 64K
- * @read_cmd:		Read cmd - Array Fast, Extn read and quad read.
- * @write_cmd:		Write cmd - page and quad program.
- * @dummy_byte:		Dummy cycles for read operation.
- * @memory_map:		Address of read-only SPI flash access
- * @flash_lock:		lock a region of the SPI Flash
- * @flash_unlock:	unlock a region of the SPI Flash
- * @flash_is_locked:	check if a region of the SPI Flash is completely locked
- * @read:		Flash read ops: Read len bytes at offset into buf
- *			Supported cmds: Fast Array Read
- * @write:		Flash write ops: Write len bytes from buf into offset
- *			Supported cmds: Page Program
- * @erase:		Flash erase ops: Erase len bytes from offset
- *			Supported cmds: Sector erase 4K, 32K, 64K
- * return 0 - Success, 1 - Failure
- */
-struct spi_flash {
-	struct spi_slave *spi;
-#ifdef CONFIG_DM_SPI_FLASH
-	struct udevice *dev;
-#endif
-	const char *name;
-	u8 dual_flash;
-	u8 shift;
-	u16 flags;
-
-	u32 size;
-	u32 page_size;
-	u32 sector_size;
-	u32 erase_size;
-#ifdef CONFIG_SPI_FLASH_BAR
-	u8 bank_read_cmd;
-	u8 bank_write_cmd;
-	u8 bank_curr;
-#endif
-	u8 erase_cmd;
-	u8 read_cmd;
-	u8 write_cmd;
-	u8 dummy_byte;
-
-	void *memory_map;
-
-	int (*flash_lock)(struct spi_flash *flash, u32 ofs, size_t len);
-	int (*flash_unlock)(struct spi_flash *flash, u32 ofs, size_t len);
-	int (*flash_is_locked)(struct spi_flash *flash, u32 ofs, size_t len);
-#ifndef CONFIG_DM_SPI_FLASH
-	/*
-	 * These are not strictly needed for driver model, but keep them here
-	 * while the transition is in progress.
-	 *
-	 * Normally each driver would provide its own operations, but for
-	 * SPI flash most chips use the same algorithms. One approach is
-	 * to create a 'common' SPI flash device which knows how to talk
-	 * to most devices, and then allow other drivers to be used instead
-	 * if required, perhaps with a way of scanning through the list to
-	 * find the driver that matches the device.
-	 */
-	int (*read)(struct spi_flash *flash, u32 offset, size_t len, void *buf);
-	int (*write)(struct spi_flash *flash, u32 offset, size_t len,
-			const void *buf);
-	int (*erase)(struct spi_flash *flash, u32 offset, size_t len);
-#endif
-};
-
 struct dm_spi_flash_ops {
 	int (*read)(struct udevice *dev, u32 offset, size_t len, void *buf);
 	int (*write)(struct udevice *dev, u32 offset, size_t len,
 		     const void *buf);
 	int (*erase)(struct udevice *dev, u32 offset, size_t len);
+	/**
+	 * get_sw_write_prot() - Check state of software write-protect feature
+	 *
+	 * SPI flash chips can lock a region of the flash defined by a
+	 * 'protected area'. This function checks if this protected area is
+	 * defined.
+	 *
+	 * @dev:	SPI flash device
+	 * @return 0 if no region is write-protected, 1 if a region is
+	 *	write-protected, -ENOSYS if the driver does not implement this,
+	 *	other -ve value on error
+	 */
+	int (*get_sw_write_prot)(struct udevice *dev);
 };
 
 /* Access the serial operations for a device */
@@ -154,6 +88,20 @@ int spi_flash_write_dm(struct udevice *dev, u32 offset, size_t len,
  */
 int spi_flash_erase_dm(struct udevice *dev, u32 offset, size_t len);
 
+/**
+ * spl_flash_get_sw_write_prot() - Check state of software write-protect feature
+ *
+ * SPI flash chips can lock a region of the flash defined by a
+ * 'protected area'. This function checks if this protected area is
+ * defined.
+ *
+ * @dev:	SPI flash device
+ * @return 0 if no region is write-protected, 1 if a region is
+ *	write-protected, -ENOSYS if the driver does not implement this,
+ *	other -ve value on error
+ */
+int spl_flash_get_sw_write_prot(struct udevice *dev);
+
 int spi_flash_probe_bus_cs(unsigned int busnum, unsigned int cs,
 			   unsigned int max_hz, unsigned int spi_mode,
 			   struct udevice **devp);
@@ -186,7 +134,7 @@ static inline int spi_flash_erase(struct spi_flash *flash, u32 offset,
 struct sandbox_state;
 
 int sandbox_sf_bind_emul(struct sandbox_state *state, int busnum, int cs,
-			 struct udevice *bus, int of_offset, const char *spec);
+			 struct udevice *bus, ofnode node, const char *spec);
 
 void sandbox_sf_unbind_emul(struct sandbox_state *state, int busnum, int cs);
 
@@ -194,36 +142,42 @@ void sandbox_sf_unbind_emul(struct sandbox_state *state, int busnum, int cs);
 struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		unsigned int max_hz, unsigned int spi_mode);
 
-/**
- * Set up a new SPI flash from an fdt node
- *
- * @param blob		Device tree blob
- * @param slave_node	Pointer to this SPI slave node in the device tree
- * @param spi_node	Cached pointer to the SPI interface this node belongs
- *			to
- * @return 0 if ok, -1 on error
- */
-struct spi_flash *spi_flash_probe_fdt(const void *blob, int slave_node,
-				      int spi_node);
-
 void spi_flash_free(struct spi_flash *flash);
 
 static inline int spi_flash_read(struct spi_flash *flash, u32 offset,
 		size_t len, void *buf)
 {
-	return flash->read(flash, offset, len, buf);
+	struct mtd_info *mtd = &flash->mtd;
+	size_t retlen;
+
+	return mtd->_read(mtd, offset, len, &retlen, buf);
 }
 
 static inline int spi_flash_write(struct spi_flash *flash, u32 offset,
 		size_t len, const void *buf)
 {
-	return flash->write(flash, offset, len, buf);
+	struct mtd_info *mtd = &flash->mtd;
+	size_t retlen;
+
+	return mtd->_write(mtd, offset, len, &retlen, buf);
 }
 
 static inline int spi_flash_erase(struct spi_flash *flash, u32 offset,
 		size_t len)
 {
-	return flash->erase(flash, offset, len);
+	struct mtd_info *mtd = &flash->mtd;
+	struct erase_info instr;
+
+	if (offset % mtd->erasesize || len % mtd->erasesize) {
+		printf("SF: Erase offset/length not multiple of erase size\n");
+		return -EINVAL;
+	}
+
+	memset(&instr, 0, sizeof(instr));
+	instr.addr = offset;
+	instr.len = len;
+
+	return mtd->_erase(mtd, &instr);
 }
 #endif
 
diff --git a/include/spl.h b/include/spl.h
index ce4cf0abbe..78d06d1e69 100644
--- a/include/spl.h
+++ b/include/spl.h
@@ -8,6 +8,7 @@
 #define	_SPL_H_
 
 /* Platform-specific defines */
+#include <mmc.h>
 #include <linux/compiler.h>
 #include <asm/spl.h>
 
@@ -20,11 +21,25 @@
 #define MMCSD_MODE_FS		2
 #define MMCSD_MODE_EMMCBOOT	3
 
+#define SPL_NEXT_STAGE_UNDEFINED	0
+#define SPL_NEXT_STAGE_UBOOT		1
+#define SPL_NEXT_STAGE_KERNEL		2
+
 struct spl_image_info {
 	const char *name;
 	u8 os;
-	ulong load_addr;
-	ulong entry_point;
+	uintptr_t load_addr;
+	uintptr_t entry_point;		/* Next stage entry point */
+#if CONFIG_IS_ENABLED(ATF)
+	uintptr_t entry_point_bl32;
+	uintptr_t entry_point_bl33;
+#endif
+#if CONFIG_IS_ENABLED(OPTEE) || CONFIG_IS_ENABLED(KERNEL_BOOT)
+	uintptr_t entry_point_os;	/* point to uboot or kernel */
+#endif
+	void *fdt_addr;
+	u32 boot_device;
+	u32 next_stage;
 	u32 size;
 	u32 flags;
 	void *arg;
@@ -68,6 +83,8 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 void preloader_console_init(void);
 u32 spl_boot_device(void);
 u32 spl_boot_mode(const u32 boot_device);
+void spl_next_stage(struct spl_image_info *spl);
+void spl_set_bd(void);
 
 /**
  * spl_set_header_raw_uboot() - Set up a standard SPL image structure
@@ -264,10 +281,34 @@ bool spl_was_boot_source(void);
  */
 int spl_dfu_cmd(int usbctrl, char *dfu_alt_info, char *interface, char *devstr);
 
+int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device);
 int spl_mmc_load_image(struct spl_image_info *spl_image,
 		       struct spl_boot_device *bootdev);
 
-void bl31_entry(void);
+/**
+ * spl_invoke_atf - boot using an ARM trusted firmware image
+ */
+void spl_invoke_atf(struct spl_image_info *spl_image);
+
+/**
+ * bl31_entry - Fill bl31_params structure, and jump to bl31
+ */
+void bl31_entry(struct spl_image_info *spl_image,
+		uintptr_t bl31_entry, uintptr_t bl32_entry,
+		uintptr_t bl33_entry, uintptr_t fdt_addr);
+
+/**
+ * spl_optee_entry - entry function for optee
+ *
+ * args defind in op-tee project
+ * https://github.com/OP-TEE/optee_os/
+ * core/arch/arm/kernel/generic_entry_a32.S
+ * @arg0: pagestore
+ * @arg1: (ARMv7 standard bootarg #1)
+ * @arg2: device tree address, (ARMv7 standard bootarg #2)
+ * @arg3: non-secure entry address (ARMv7 bootarg #0)
+ */
+void spl_optee_entry(void *arg0, void *arg1, void *arg2, void *arg3);
 
 /**
  * board_return_to_bootrom - allow for boards to continue with the boot ROM
@@ -278,4 +319,31 @@ void bl31_entry(void);
  * can implement 'board_return_to_bootrom'.
  */
 void board_return_to_bootrom(void);
+
+/**
+ * spl_cleanup_before_jump() - cleanup cache/mmu/interrupt, etc before jump
+ *			       to next stage.
+ */
+void spl_cleanup_before_jump(struct spl_image_info *spl_image);
+
+/**
+ * spl_perform_fixups() - arch/board-specific callback before processing
+ *                        the boot-payload
+ */
+void spl_perform_fixups(struct spl_image_info *spl_image);
+
+/**
+ * spl_board_prepare_for_jump() - arch/board-specific callback exactly before
+ *				  jumping to next stage
+ */
+int spl_board_prepare_for_jump(struct spl_image_info *spl_image);
+
+/**
+ * spl_kernel_partition() - arch/board-specific callback to get kernel partition
+ */
+#ifdef CONFIG_SPL_KERNEL_BOOT
+const char *spl_kernel_partition(struct spl_image_info *spl,
+				 struct spl_load_info *info);
+#endif
+
 #endif
diff --git a/include/stdio_dev.h b/include/stdio_dev.h
index 3164fa2a55..5b13ebf2be 100644
--- a/include/stdio_dev.h
+++ b/include/stdio_dev.h
@@ -36,6 +36,9 @@ struct stdio_dev {
 	/* To put a string (accelerator) */
 	void (*puts)(struct stdio_dev *dev, const char *s);
 
+/* Clear functions */
+	void (*clear)(struct stdio_dev *dev);
+
 /* INPUT functions */
 
 	/* To test if a char is ready... */
diff --git a/include/stdlib.h b/include/stdlib.h
index 6bc7fbb3c4..5b87ea0237 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -9,4 +9,6 @@
 
 #include <malloc.h>
 
+int atoi(const char *nptr);
+
 #endif /* __STDLIB_H_ */
diff --git a/include/syscon.h b/include/syscon.h
index 34842aa470..23d257ad80 100644
--- a/include/syscon.h
+++ b/include/syscon.h
@@ -8,6 +8,8 @@
 #ifndef __SYSCON_H
 #define __SYSCON_H
 
+#include <fdtdec.h>
+
 /**
  * struct syscon_uc_info - Information stored by the syscon UCLASS_UCLASS
  *
@@ -28,9 +30,11 @@ struct syscon_ops {
  * We don't support 64-bit machines. If they are so resource-contrained that
  * they need to use OF_PLATDATA, something is horribly wrong with the
  * education of our hardware engineers.
+ *
+ * Update: 64-bit is now supported and we have an education crisis.
  */
 struct syscon_base_platdata {
-	u32 reg[2];
+	fdt_val_t reg[2];
 };
 #endif
 
@@ -69,6 +73,19 @@ int syscon_get_by_driver_data(ulong driver_data, struct udevice **devp);
  */
 struct regmap *syscon_get_regmap_by_driver_data(ulong driver_data);
 
+/**
+ * syscon_regmap_lookup_by_phandle() - Look up a controller by a phandle
+ *
+ * This operates by looking up the given name in the device (device
+ * tree property) of the device using the system controller.
+ *
+ * @dev:	Device using the system controller
+ * @name:	Name of property referring to the system controller
+ * @return	A pointer to the regmap if found, ERR_PTR(-ve) on error
+ */
+struct regmap *syscon_regmap_lookup_by_phandle(struct udevice *dev,
+					       const char *name);
+
 /**
  * syscon_get_first_range() - get the first memory range from a syscon regmap
  *
diff --git a/include/sysreset.h b/include/sysreset.h
index 393c7be3d8..36859a7796 100644
--- a/include/sysreset.h
+++ b/include/sysreset.h
@@ -29,10 +29,24 @@ struct sysreset_ops {
 	 *		(in which case this method will not actually return)
 	 */
 	int (*request)(struct udevice *dev, enum sysreset_t type);
+
+	/**
+	 * request_by_mode() - request a sysreset of the given mode
+	 *
+	 * Note that this function may return before the reset takes effect.
+	 *
+	 * @mode:	mode to request
+	 * @return -EINPROGRESS if the reset has been started and
+	 *		will complete soon, -EPROTONOSUPPORT if not supported
+	 *		by this device, 0 if the reset has already happened
+	 *		(in which case this method will not actually return)
+	 */
+	int (*request_by_mode)(struct udevice *dev, const char *mode);
 };
 
 #define sysreset_get_ops(dev)        ((struct sysreset_ops *)(dev)->driver->ops)
 
+#ifdef CONFIG_SYSRESET
 /**
  * sysreset_request() - request a sysreset
  *
@@ -68,4 +82,25 @@ void sysreset_walk_halt(enum sysreset_t type);
  */
 void reset_cpu(ulong addr);
 
+/**
+ * reboot() - calls sysreset_walk(SYSRESET_WARM)
+ *
+ * Support the command like: reboot loader/bootloader/recovery, etc.
+ */
+void reboot(const char *mode);
+
+#else
+#include <asm/io.h>
+
+inline void reset_cpu(ulong addr)
+{
+	writel(CONFIG_SYSRESET_VAL, CONFIG_SYSRESET_REG);
+	dsb();
+	isb();
+
+	while (1)
+		;
+}
+#endif
+
 #endif
diff --git a/include/u-boot/crc.h b/include/u-boot/crc.h
index 6764d58bab..6d08f5df98 100644
--- a/include/u-boot/crc.h
+++ b/include/u-boot/crc.h
@@ -28,4 +28,8 @@ uint32_t crc32_no_comp (uint32_t, const unsigned char *, uint);
 void crc32_wd_buf(const unsigned char *input, uint ilen,
 		    unsigned char *output, uint chunk_sz);
 
+/* lib/crc32c.c */
+void crc32c_init(uint32_t *, uint32_t);
+uint32_t crc32c_cal(uint32_t, const char *, int, uint32_t *);
+
 #endif /* _UBOOT_CRC_H */
diff --git a/include/u-boot/rsa-mod-exp.h b/include/u-boot/rsa-mod-exp.h
index 45a031b4b6..cb99ac6e61 100644
--- a/include/u-boot/rsa-mod-exp.h
+++ b/include/u-boot/rsa-mod-exp.h
@@ -21,7 +21,15 @@
 struct key_prop {
 	const void *rr;		/* R^2 can be treated as byte array */
 	const void *modulus;	/* modulus as byte array */
+	uint32_t burn_key;	/* The flag to burn key's hash */
 	const void *public_exponent; /* public exponent as byte array */
+	const void *public_exponent_BN; /* public exponent as byte array */
+#ifdef CONFIG_ROCKCHIP_CRYPTO_V1
+	const void *factor_c;	/* rockchip crypto v1 accelerate factor */
+#else
+	const void *factor_np;	/* rockchip crypto v2 accelerate factor */
+#endif
+	const void *hash;	/* the key hash */
 	uint32_t n0inv;		/* -1 / modulus[0] mod 2^32 */
 	int num_bits;		/* Key length in bits */
 	uint32_t exp_len;	/* Exponent length in number of uint8_t */
diff --git a/include/u-boot/rsa.h b/include/u-boot/rsa.h
index 0e96c38711..e2438ab473 100644
--- a/include/u-boot/rsa.h
+++ b/include/u-boot/rsa.h
@@ -82,7 +82,7 @@ static inline int rsa_add_verify_data(struct image_sign_info *info,
 }
 #endif
 
-#if IMAGE_ENABLE_VERIFY
+#if IMAGE_ENABLE_VERIFY || defined(CONFIG_SPL_FIT_SIGNATURE)
 /**
  * rsa_verify() - Verify a signature against some data
  *
@@ -98,6 +98,22 @@ static inline int rsa_add_verify_data(struct image_sign_info *info,
 int rsa_verify(struct image_sign_info *info,
 	       const struct image_region region[], int region_count,
 	       uint8_t *sig, uint sig_len);
+
+int padding_pkcs_15_verify(struct image_sign_info *info,
+			   uint8_t *msg, int msg_len,
+			   const uint8_t *hash, int hash_len);
+
+#if !defined(USE_HOSTCC)
+#ifdef CONFIG_SPL_FIT_HW_CRYPTO
+int rsa_burn_key_hash(struct image_sign_info *info);
+#endif
+#endif
+
+#ifdef CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT
+int padding_pss_verify(struct image_sign_info *info,
+		       uint8_t *msg, int msg_len,
+		       const uint8_t *hash, int hash_len);
+#endif /* CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT */
 #else
 static inline int rsa_verify(struct image_sign_info *info,
 		const struct image_region region[], int region_count,
@@ -105,8 +121,26 @@ static inline int rsa_verify(struct image_sign_info *info,
 {
 	return -ENXIO;
 }
+
+static inline int padding_pkcs_15_verify(struct image_sign_info *info,
+					 uint8_t *msg, int msg_len,
+					 const uint8_t *hash, int hash_len)
+{
+	return -ENXIO;
+}
+
+#ifdef CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT
+static inline int padding_pss_verify(struct image_sign_info *info,
+				     uint8_t *msg, int msg_len,
+				     const uint8_t *hash, int hash_len)
+{
+	return -ENXIO;
+}
+#endif /* CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT */
 #endif
 
+#define RSA_DEFAULT_PADDING_NAME		"pkcs-1.5"
+
 #define RSA2048_BYTES	(2048 / 8)
 #define RSA4096_BYTES	(4096 / 8)
 
diff --git a/include/u-boot/sha256.h b/include/u-boot/sha256.h
index 9aa1251789..e63f3365e9 100644
--- a/include/u-boot/sha256.h
+++ b/include/u-boot/sha256.h
@@ -21,5 +21,7 @@ void sha256_finish(sha256_context * ctx, uint8_t digest[SHA256_SUM_LEN]);
 
 void sha256_csum_wd(const unsigned char *input, unsigned int ilen,
 		unsigned char *output, unsigned int chunk_sz);
+void sha256_csum(const unsigned char *input, unsigned int ilen,
+		 unsigned char *output);
 
 #endif /* _SHA256_H */
diff --git a/include/usb.h b/include/usb.h
index fad04016a3..2775b36e11 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -141,7 +141,7 @@ struct usb_device {
 	int act_len;			/* transferred bytes */
 	int maxchild;			/* Number of ports if hub */
 	int portnr;			/* Port number, 1=first */
-#ifndef CONFIG_DM_USB
+#if !CONFIG_IS_ENABLED(DM_USB)
 	/* parent hub, or NULL if this is the root hub */
 	struct usb_device *parent;
 	struct usb_device *children[USB_MAXCHILDREN];
@@ -149,7 +149,7 @@ struct usb_device {
 #endif
 	/* slot_id - for xHCI enabled devices */
 	unsigned int slot_id;
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 	struct udevice *dev;		/* Pointer to associated device */
 	struct udevice *controller_dev;	/* Pointer to associated controller */
 #endif
@@ -174,7 +174,7 @@ enum usb_init_type {
 int usb_lowlevel_init(int index, enum usb_init_type init, void **controller);
 int usb_lowlevel_stop(int index);
 
-#if defined(CONFIG_USB_MUSB_HOST) || defined(CONFIG_DM_USB)
+#if defined(CONFIG_USB_MUSB_HOST) || CONFIG_IS_ENABLED(DM_USB)
 int usb_reset_root_port(struct usb_device *dev);
 #else
 #define usb_reset_root_port(dev)
@@ -185,10 +185,10 @@ int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
 int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 			int transfer_len, struct devrequest *setup);
 int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
-			int transfer_len, int interval);
+			int transfer_len, int interval, bool nonblock);
 
 #if defined CONFIG_USB_EHCI_HCD || defined CONFIG_USB_MUSB_HOST \
-	|| defined(CONFIG_DM_USB)
+	|| CONFIG_IS_ENABLED(DM_USB)
 struct int_queue *create_int_queue(struct usb_device *dev, unsigned long pipe,
 	int queuesize, int elementsize, void *buffer, int interval);
 int destroy_int_queue(struct usb_device *dev, struct int_queue *queue);
@@ -262,8 +262,8 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 			void *data, unsigned short size, int timeout);
 int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
 			void *data, int len, int *actual_length, int timeout);
-int usb_submit_int_msg(struct usb_device *dev, unsigned long pipe,
-			void *buffer, int transfer_len, int interval);
+int usb_int_msg(struct usb_device *dev, unsigned long pipe,
+		void *buffer, int transfer_len, int interval, bool nonblock);
 int usb_disable_asynch(int disable);
 int usb_maxpacket(struct usb_device *dev, unsigned long pipe);
 int usb_get_configuration_no(struct usb_device *dev, int cfgno,
@@ -589,7 +589,7 @@ struct usb_hub_device {
 	struct usb_tt tt;		/* Transaction Translator */
 };
 
-#ifdef CONFIG_DM_USB
+#if CONFIG_IS_ENABLED(DM_USB)
 /**
  * struct usb_platdata - Platform data about a USB controller
  *
@@ -652,6 +652,18 @@ struct usb_bus_priv {
 	bool companion;
 };
 
+/**
+ * struct usb_emul_platdata - platform data about the USB emulator
+ *
+ * Given a USB emulator (UCLASS_USB_EMUL) 'dev', this is
+ * dev_get_uclass_platdata(dev).
+ *
+ * @port1:	USB emulator device port number on the parent hub
+ */
+struct usb_emul_platdata {
+	int port1;	/* Port number (numbered from 1) */
+};
+
 /**
  * struct dm_usb_ops - USB controller operations
  *
@@ -697,7 +709,7 @@ struct dm_usb_ops {
 	 */
 	int (*interrupt)(struct udevice *bus, struct usb_device *udev,
 			 unsigned long pipe, void *buffer, int length,
-			 int interval);
+			 int interval, bool nonblock);
 
 	/**
 	 * create_int_queue() - Create and queue interrupt packets
@@ -766,6 +778,14 @@ struct dm_usb_ops {
 	 * representation of this hub can be updated (xHCI)
 	 */
 	int (*update_hub_device)(struct udevice *bus, struct usb_device *udev);
+
+	/**
+	 * get_max_xfer_size() - Get HCD's maximum transfer bytes
+	 *
+	 * The HCD may have limitation on the maximum bytes to be transferred
+	 * in a USB transfer. USB class driver needs to be aware of this.
+	 */
+	int (*get_max_xfer_size)(struct udevice *bus, size_t *size);
 };
 
 #define usb_get_ops(dev)	((struct dm_usb_ops *)(dev)->driver->ops)
@@ -893,7 +913,7 @@ int usb_setup_ehci_gadget(struct ehci_ctrl **ctlrp);
  */
 void usb_stor_reset(void);
 
-#else /* !CONFIG_DM_USB */
+#else /* !CONFIG_IS_ENABLED(DM_USB) */
 
 struct usb_device *usb_get_dev_index(int index);
 
@@ -939,7 +959,7 @@ int usb_new_device(struct usb_device *dev);
 int usb_alloc_device(struct usb_device *dev);
 
 /**
- * update_hub_device() - Update HCD's internal representation of hub
+ * usb_update_hub_device() - Update HCD's internal representation of hub
  *
  * After a hub descriptor is fetched, notify HCD so that its internal
  * representation of this hub can be updated.
@@ -949,6 +969,18 @@ int usb_alloc_device(struct usb_device *dev);
  */
 int usb_update_hub_device(struct usb_device *dev);
 
+/**
+ * usb_get_max_xfer_size() - Get HCD's maximum transfer bytes
+ *
+ * The HCD may have limitation on the maximum bytes to be transferred
+ * in a USB transfer. USB class driver needs to be aware of this.
+ *
+ * @dev:		USB device
+ * @size:		maximum transfer bytes
+ * @return 0 if OK, -ve on error
+ */
+int usb_get_max_xfer_size(struct usb_device *dev, size_t *size);
+
 /**
  * usb_emul_setup_device() - Set up a new USB device emulation
  *
@@ -956,7 +988,6 @@ int usb_update_hub_device(struct usb_device *dev);
  * the USB emulation uclass about the features of the emulator.
  *
  * @dev:		Emulation device
- * @maxpacketsize:	Maximum packet size (e.g. PACKET_SIZE_64)
  * @strings:		List of USB string descriptors, terminated by a NULL
  *			entry
  * @desc_list:		List of points or USB descriptors, terminated by NULL.
@@ -964,8 +995,8 @@ int usb_update_hub_device(struct usb_device *dev);
  *			and others follow on after that.
  * @return 0 if OK, -ENOSYS if not implemented, other -ve on error
  */
-int usb_emul_setup_device(struct udevice *dev, int maxpacketsize,
-			  struct usb_string *strings, void **desc_list);
+int usb_emul_setup_device(struct udevice *dev, struct usb_string *strings,
+			  void **desc_list);
 
 /**
  * usb_emul_control() - Send a control packet to an emulator
@@ -999,19 +1030,22 @@ int usb_emul_bulk(struct udevice *emul, struct usb_device *udev,
  * @return 0 if OK, -ve on error
  */
 int usb_emul_int(struct udevice *emul, struct usb_device *udev,
-		  unsigned long pipe, void *buffer, int length, int interval);
+		  unsigned long pipe, void *buffer, int length, int interval,
+		  bool nonblock);
 
 /**
  * usb_emul_find() - Find an emulator for a particular device
  *
- * Check @pipe to find a device number on bus @bus and return it.
+ * Check @pipe and @port1 to find a device number on bus @bus and return it.
  *
  * @bus:	USB bus (controller)
  * @pipe:	Describes pipe being used, and includes the device number
+ * @port1:	Describes port number on the parent hub
  * @emulp:	Returns pointer to emulator, or NULL if not found
  * @return 0 if found, -ve on error
  */
-int usb_emul_find(struct udevice *bus, ulong pipe, struct udevice **emulp);
+int usb_emul_find(struct udevice *bus, ulong pipe, int port1,
+		  struct udevice **emulp);
 
 /**
  * usb_emul_find_for_dev() - Find an emulator for a particular device
@@ -1024,12 +1058,15 @@ int usb_emul_find(struct udevice *bus, ulong pipe, struct udevice **emulp);
 int usb_emul_find_for_dev(struct udevice *dev, struct udevice **emulp);
 
 /**
- * usb_emul_reset() - Reset all emulators ready for use
+ * usb_emul_find_descriptor() - Find a USB descriptor of a particular device
  *
- * Clear out any address information in the emulators and make then ready for
- * a new USB scan
+ * @ptr:	a pointer to a list of USB descriptor pointers
+ * @type:	type of USB descriptor to find
+ * @index:	if @type is USB_DT_CONFIG, this is the configuration value
+ * @return a pointer to the USB descriptor found, NULL if not found
  */
-void usb_emul_reset(struct udevice *dev);
+struct usb_generic_descriptor **usb_emul_find_descriptor(
+		struct usb_generic_descriptor **ptr, int type, int index);
 
 /**
  * usb_show_tree() - show the USB device tree
diff --git a/include/usb/dwc2_udc.h b/include/usb/dwc2_udc.h
index 1a370e0e86..7eb2b1f4e2 100644
--- a/include/usb/dwc2_udc.h
+++ b/include/usb/dwc2_udc.h
@@ -10,6 +10,7 @@
 #define __DWC2_USB_GADGET
 
 #define PHY0_SLEEP              (1 << 5)
+#define DWC2_MAX_HW_ENDPOINTS	16
 
 struct dwc2_plat_otg_data {
 	void		*priv;
@@ -23,8 +24,14 @@ struct dwc2_plat_otg_data {
 	unsigned int	rx_fifo_sz;
 	unsigned int	np_tx_fifo_sz;
 	unsigned int	tx_fifo_sz;
+	unsigned int	tx_fifo_sz_array[DWC2_MAX_HW_ENDPOINTS];
+	unsigned char   tx_fifo_sz_nb;
+	bool		force_b_session_valid;
+	bool		activate_stm_id_vb_detection;
 };
 
 int dwc2_udc_probe(struct dwc2_plat_otg_data *pdata);
 
+int dwc2_udc_B_session_valid(struct udevice *dev);
+
 #endif	/* __DWC2_USB_GADGET */
diff --git a/include/usb/lin_gadget_compat.h b/include/usb/lin_gadget_compat.h
index 4a01585f80..d0d71f7c32 100644
--- a/include/usb/lin_gadget_compat.h
+++ b/include/usb/lin_gadget_compat.h
@@ -10,12 +10,10 @@
 #ifndef __LIN_COMPAT_H__
 #define __LIN_COMPAT_H__
 
+#include <linux/bitops.h>
 #include <linux/compat.h>
 
 /* common */
-#define BITS_PER_BYTE				8
-#define BITS_TO_LONGS(nr) \
-	DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
 #define DECLARE_BITMAP(name, bits) \
 	unsigned long name[BITS_TO_LONGS(bits)]
 
diff --git a/include/usb_mass_storage.h b/include/usb_mass_storage.h
index 8229f62b97..dc2b85e029 100644
--- a/include/usb_mass_storage.h
+++ b/include/usb_mass_storage.h
@@ -20,6 +20,9 @@ struct ums {
 			   ulong start, lbaint_t blkcnt, void *buf);
 	int (*write_sector)(struct ums *ums_dev,
 			    ulong start, lbaint_t blkcnt, const void *buf);
+#ifdef CONFIG_CMD_ROCKUSB
+	int (*erase_sector)(struct ums *ums_dev, ulong start, lbaint_t blkcnt);
+#endif
 	unsigned int start_sector;
 	unsigned int num_sectors;
 	const char *name;
diff --git a/include/video_bridge.h b/include/video_bridge.h
index c7b8681849..7c86c5997c 100644
--- a/include/video_bridge.h
+++ b/include/video_bridge.h
@@ -53,6 +53,24 @@ struct video_bridge_ops {
 	 * @return 0 if OK, -ve on error
 	 */
 	int (*set_backlight)(struct udevice *dev, int percent);
+
+	/**
+	 * read_edid() - Read information from EDID
+	 *
+	 * @dev:	Device to read from
+	 * @buf:	Buffer to read into
+	 * @buf_size:	Buffer size
+	 * @return number of bytes read, <=0 for error
+	 */
+	int (*read_edid)(struct udevice *dev, u8 *buf, int buf_size);
+
+	/**
+	 * get_timing() - Get timing from bridge
+	 *
+	 * @dev:	Device to get timing
+	 * @return 0 if OK, -ve on error
+	 */
+	int (*get_timing)(struct udevice *dev);
 };
 
 #define video_bridge_get_ops(dev) \
@@ -89,4 +107,21 @@ int video_bridge_set_active(struct udevice *dev, bool active);
  */
 int video_bridge_check_attached(struct udevice *dev);
 
+/**
+ * video_bridge_read_edid() - Read information from EDID
+ *
+ * @dev:	Device to read from
+ * @buf:	Buffer to read into
+ * @buf_size:	Buffer size
+ * @return number of bytes read, <=0 for error
+ */
+int video_bridge_read_edid(struct udevice *dev, u8 *buf, int buf_size);
+
+/**
+ * video_bridge_get_timing() - Get timing from bridge
+ *
+ * @dev:	Device to get timing
+ * @return 0 if OK, -ve on error
+ */
+int video_bridge_get_timing(struct udevice *dev);
 #endif
diff --git a/include/vsprintf.h b/include/vsprintf.h
index 490c96ca6d..33d05aa0c6 100644
--- a/include/vsprintf.h
+++ b/include/vsprintf.h
@@ -9,6 +9,7 @@
 #define __VSPRINTF_H
 
 #include <stdarg.h>
+#include <linux/types.h>
 
 ulong simple_strtoul(const char *cp, char **endp, unsigned int base);
 
diff --git a/include/wait_bit.h b/include/wait_bit.h
index 06ad43a122..bd021baa48 100644
--- a/include/wait_bit.h
+++ b/include/wait_bit.h
@@ -16,7 +16,7 @@
 #include <asm/io.h>
 
 /**
- * wait_for_bit()	waits for bit set/cleared in register
+ * wait_for_bit_x()	waits for bit set/cleared in register
  *
  * Function polls register waiting for specific bit(s) change
  * (either 0->1 or 1->0). It can fail under two conditions:
@@ -25,49 +25,60 @@
  * Function succeeds only if all bits of masked register are set/cleared
  * (depending on set option).
  *
- * @param prefix	Prefix added to timeout messagge (message visible only
- *			with debug enabled)
- * @param reg		Register that will be read (using readl())
+ * @param reg		Register that will be read (using read_x())
  * @param mask		Bit(s) of register that must be active
  * @param set		Selects wait condition (bit set or clear)
- * @param timeout_ms	Timeout (in miliseconds)
+ * @param timeout_ms	Timeout (in milliseconds)
  * @param breakable	Enables CTRL-C interruption
  * @return		0 on success, -ETIMEDOUT or -EINTR on failure
  */
-static inline int wait_for_bit(const char *prefix, const u32 *reg,
-			       const u32 mask, const bool set,
-			       const unsigned int timeout_ms,
-			       const bool breakable)
-{
-	u32 val;
-	unsigned long start = get_timer(0);
 
-	while (1) {
-		val = readl(reg);
-
-		if (!set)
-			val = ~val;
-
-		if ((val & mask) == mask)
-			return 0;
-
-		if (get_timer(start) > timeout_ms)
-			break;
-
-		if (breakable && ctrlc()) {
-			puts("Abort\n");
-			return -EINTR;
-		}
-
-		udelay(1);
-		WATCHDOG_RESET();
-	}
-
-	debug("%s: Timeout (reg=%p mask=%08x wait_set=%i)\n", prefix, reg, mask,
-	      set);
-
-	return -ETIMEDOUT;
+#define BUILD_WAIT_FOR_BIT(sfx, type, read)				\
+									\
+static inline int wait_for_bit_##sfx(const void *reg,			\
+				     const type mask,			\
+				     const bool set,			\
+				     const unsigned int timeout_ms,	\
+				     const bool breakable)		\
+{									\
+	type val;							\
+	unsigned long start = get_timer(0);				\
+									\
+	while (1) {							\
+		val = read(reg);					\
+									\
+		if (!set)						\
+			val = ~val;					\
+									\
+		if ((val & mask) == mask)				\
+			return 0;					\
+									\
+		if (get_timer(start) > timeout_ms)			\
+			break;						\
+									\
+		if (breakable && ctrlc()) {				\
+			puts("Abort\n");				\
+			return -EINTR;					\
+		}							\
+									\
+		udelay(1);						\
+		WATCHDOG_RESET();					\
+	}								\
+									\
+	debug("%s: Timeout (reg=%p mask=%x wait_set=%i)\n", __func__,	\
+	      reg, mask, set);						\
+									\
+	return -ETIMEDOUT;						\
 }
 
+BUILD_WAIT_FOR_BIT(8, u8, readb)
+BUILD_WAIT_FOR_BIT(le16, u16, readw)
+#ifdef readw_be
+BUILD_WAIT_FOR_BIT(be16, u16, readw_be)
+#endif
+BUILD_WAIT_FOR_BIT(le32, u32, readl)
+#ifdef readl_be
+BUILD_WAIT_FOR_BIT(be32, u32, readl_be)
+#endif
 
 #endif
diff --git a/include/watchdog.h b/include/watchdog.h
index 64b59f107a..d420ab127b 100644
--- a/include/watchdog.h
+++ b/include/watchdog.h
@@ -73,7 +73,7 @@ int init_func_watchdog_reset(void);
  */
 
 /* MPC 8xx */
-#if defined(CONFIG_8xx) && !defined(__ASSEMBLY__)
+#if defined(CONFIG_MPC8xx) && !defined(__ASSEMBLY__)
 	void reset_8xx_watchdog(immap_t __iomem *immr);
 #endif
 
diff --git a/lib/Kconfig b/lib/Kconfig
index fe337acaeb..b951beda8d 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -35,6 +35,12 @@ config SYS_HZ
 	  get_timer() must operate in milliseconds and this option must be
 	  set to 1000.
 
+config SYS_STACK_SIZE
+	hex
+	default 0x200000
+	help
+	 The system stack size.
+
 config USE_TINY_PRINTF
 	bool "Enable tiny printf() version"
 	help
@@ -45,6 +51,16 @@ config USE_TINY_PRINTF
 
 	  The supported format specifiers are %c, %s, %u/%d and %x.
 
+config PANIC_HANG
+	bool "Do not reset the system on fatal error"
+	help
+	  Define this option to stop the system in case of a fatal error,
+	  so that you have to reset it manually. This is probably NOT a good
+	  idea for an embedded system where you want the system to reboot
+	  automatically as fast as possible, but it may be useful during
+	  development since you can try to debug the conditions that lead to
+	  the situation.
+
 config REGEX
 	bool "Enable regular expression support"
 	default y if NET
@@ -61,6 +77,7 @@ config LIB_RAND
 
 config SPL_TINY_MEMSET
 	bool "Use a very small memset() in SPL"
+	depends on SPL
 	help
 	  The faster memset() is the arch-specific one (if available) enabled
 	  by CONFIG_USE_ARCH_MEMSET. If that is not enabled, we can still get
@@ -80,6 +97,21 @@ config TPL_TINY_MEMSET
 config RBTREE
 	bool
 
+config BITREVERSE
+	bool
+
+config SYSMEM
+	bool "System memory management"
+	default y
+	help
+	  This enables support for system permanent memory management.
+
+config BIDRAM
+	bool "GD board bi_dram[] memory management"
+	default y
+	help
+	  This enables support for GD board bi_dram[] memory management.
+
 source lib/dhry/Kconfig
 
 menu "Security support"
@@ -108,6 +140,20 @@ config TPM
 
 endmenu
 
+menu "Boot Configuration"
+
+config XBC
+	bool "Boot Configuration support"
+	depends on ANDROID_BOOT_IMAGE
+	default n
+	help
+	  This enables support of Boot Configuration which can be used
+	  to pass boot configuration parameters to user space. These
+	  parameters will show up in /proc/bootconfig similar to the kernel
+	  parameters that show up in /proc/cmdline
+
+endmenu
+
 menu "Hashing Support"
 
 config SHA1
@@ -126,6 +172,14 @@ config SHA256
 	  The SHA256 algorithm produces a 256-bit (32-byte) hash value
 	  (digest).
 
+config SHA512
+	bool "Enable SHA512 support"
+	help
+	  This option enables support of hashing using SHA512 algorithm.
+	  The hash is calculated in software.
+	  The SHA512 algorithm produces a 512-bit (64-byte) hash value
+	  (digest).
+
 config SHA_HW_ACCEL
 	bool "Enable hashing using hardware"
 	help
@@ -146,6 +200,9 @@ config SHA_PROG_HW_ACCEL
 config MD5
 	bool
 
+config CRC32C
+	bool
+
 endmenu
 
 menu "Compression Support"
@@ -172,10 +229,35 @@ config LZMA
 	  ratio and fairly fast decompression speed. See also
 	  CONFIG_CMD_LZMADEC which provides a decode command.
 
+config SPL_LZMA
+	bool "Enable LZMA decompression support in SPL"
+	depends on SPL
+	help
+	  This enables support for LZMA (Lempel-Ziv-Markov chain algorithm),
+	  a dictionary compression algorithm that provides a high compression
+	  ratio and fairly fast decompression speed. See also
+
 config LZO
 	bool "Enable LZO decompression support"
 	help
 	  This enables support for LZO compression algorithm.r
+
+config SPL_LZO
+	bool "Enable LZO decompression support in SPL"
+	help
+	  This enables support for LZO compression algorithm in the SPL.
+
+config SPL_GZIP
+	bool "Enable gzip decompression support for SPL build"
+	select SPL_ZLIB
+	help
+	  This enables support for GZIP compression altorithm for SPL boot.
+
+config SPL_ZLIB
+	bool
+	help
+	  This enables compression lib for SPL boot.
+
 endmenu
 
 config ERRNO_STR
@@ -186,6 +268,11 @@ config ERRNO_STR
 	  - if errno is null or positive number - a pointer to "Success" message
 	  - if errno is negative - a pointer to errno related message
 
+config HEXDUMP
+	bool "Enable hexdump"
+	help
+	  This enables functions for printing dumps of binary data.
+
 config OF_LIBFDT
 	bool "Enable the FDT library"
 	default y if OF_CONTROL
@@ -211,6 +298,16 @@ config SPL_OF_LIBFDT
 	  particular compatible nodes. The library operates on a flattened
 	  version of the device tree.
 
+config TPL_OF_LIBFDT
+	bool "Enable the FDT library for TPL"
+	default y if TPL_OF_CONTROL
+	help
+	  This enables the FDT library (libfdt). It provides functions for
+	  accessing binary device tree images in memory, such as adding and
+	  removing nodes and properties, scanning through the tree and finding
+	  particular compatible nodes. The library operates on a flattened
+	  version of the device tree.
+
 config FDT_FIXUP_PARTITIONS
 	bool "overwrite MTD partitions in DTS through defined in 'mtdparts'"
 	depends on OF_LIBFDT
@@ -251,9 +348,21 @@ config SMBIOS_PRODUCT_NAME
 	  The product name to store in SMBIOS structures.
 	  Change this to override the default one (CONFIG_SYS_BOARD).
 
+config LIB_RATIONAL
+	bool "enable continued fraction calculation routines"
+
+config SPL_LIB_RATIONAL
+	bool "enable continued fraction calculation routines for SPL"
+	depends on SPL
+
 endmenu
 
 source lib/efi/Kconfig
 source lib/efi_loader/Kconfig
-
+source lib/avb/libavb/Kconfig
+source lib/avb/libavb_ab/Kconfig
+source lib/avb/libavb_atx/Kconfig
+source lib/avb/libavb_user/Kconfig
+source lib/avb/rk_avb_user/Kconfig
+source lib/optee_clientApi/Kconfig
 endmenu
diff --git a/lib/Makefile b/lib/Makefile
index 2eef1eb80e..0b7a01a034 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -9,9 +9,6 @@ ifndef CONFIG_SPL_BUILD
 
 obj-$(CONFIG_EFI) += efi/
 obj-$(CONFIG_EFI_LOADER) += efi_loader/
-obj-$(CONFIG_LZMA) += lzma/
-obj-$(CONFIG_LZO) += lzo/
-obj-$(CONFIG_ZLIB) += zlib/
 obj-$(CONFIG_BZIP2) += bzip2/
 obj-$(CONFIG_TIZEN) += tizen/
 obj-$(CONFIG_FIT) += libfdt/
@@ -19,6 +16,7 @@ obj-$(CONFIG_OF_LIVE) += of_live.o
 obj-$(CONFIG_CMD_DHRYSTONE) += dhry/
 
 obj-$(CONFIG_AES) += aes.o
+obj-y += charset.o
 obj-$(CONFIG_USB_TTY) += circbuf.o
 obj-y += crc7.o
 obj-y += crc8.o
@@ -26,11 +24,14 @@ obj-y += crc16.o
 obj-$(CONFIG_ERRNO_STR) += errno_str.o
 obj-$(CONFIG_FIT) += fdtdec_common.o
 obj-$(CONFIG_TEST_FDTDEC) += fdtdec_test.o
-obj-$(CONFIG_GZIP) += gunzip.o
 obj-$(CONFIG_GZIP_COMPRESSED) += gzip.o
 obj-$(CONFIG_GENERATE_SMBIOS_TABLE) += smbios.o
 obj-y += initcall.o
 obj-$(CONFIG_LMB) += lmb.o
+ifdef CONFIG_LMB
+obj-$(CONFIG_SYSMEM) += sysmem.o
+obj-$(CONFIG_BIDRAM) += bidram.o
+endif
 obj-y += ldiv.o
 obj-$(CONFIG_LZ4) += lz4_wrapper.o
 obj-$(CONFIG_MD5) += md5.o
@@ -43,11 +44,26 @@ obj-$(CONFIG_TPM) += tpm.o
 obj-$(CONFIG_RBTREE)	+= rbtree.o
 obj-$(CONFIG_BITREVERSE) += bitrev.o
 obj-y += list_sort.o
+obj-$(CONFIG_OPTEE_CLIENT) += optee_clientApi/
 endif
 
-obj-$(CONFIG_RSA) += rsa/
+obj-$(CONFIG_XBC) += libxbc/
+obj-$(CONFIG_$(SPL_TPL_)AVB_LIBAVB) += avb/libavb/
+obj-$(CONFIG_$(SPL_TPL_)AVB_LIBAVB_ATX) += avb/libavb_atx/
+obj-$(CONFIG_$(SPL_TPL_)AVB_LIBAVB_USER) += avb/libavb_user/
+obj-y += avb/rk_avb_user/
+
+obj-$(CONFIG_$(SPL_TPL_)RSA) += rsa/
 obj-$(CONFIG_SHA1) += sha1.o
 obj-$(CONFIG_SHA256) += sha256.o
+obj-$(CONFIG_SHA512) += sha512.o
+
+obj-$(CONFIG_$(SPL_)LZMA) += lzma/
+obj-$(CONFIG_$(SPL_)ZLIB) += zlib/
+obj-$(CONFIG_$(SPL_)GZIP) += gunzip.o
+obj-$(CONFIG_$(SPL_)LZO) += lzo/
+
+obj-$(CONFIG_$(SPL_)LIB_RATIONAL) += rational.o
 
 obj-$(CONFIG_$(SPL_TPL_)SAVEENV) += qsort.o
 obj-$(CONFIG_$(SPL_TPL_)OF_LIBFDT) += libfdt/
@@ -67,6 +83,7 @@ obj-y += display_options.o
 CFLAGS_display_options.o := $(if $(BUILD_TAG),-DBUILD_TAG='"$(BUILD_TAG)"')
 obj-$(CONFIG_BCH) += bch.o
 obj-y += crc32.o
+obj-$(CONFIG_CRC32C) += crc32c.o
 obj-y += ctype.o
 obj-y += div64.o
 obj-y += hang.o
@@ -75,11 +92,16 @@ obj-y += linux_string.o
 obj-y += membuff.o
 obj-$(CONFIG_REGEX) += slre.o
 obj-y += string.o
+obj-y += stdlib.o
 obj-y += tables_csum.o
 obj-y += time.o
+obj-y += hexdump.o
 obj-$(CONFIG_TRACE) += trace.o
 obj-$(CONFIG_LIB_UUID) += uuid.o
+
+ifneq ($(CONFIG_LIB_HW_RAND)$(CONFIG_RNG_ROCKCHIP),yy)
 obj-$(CONFIG_LIB_RAND) += rand.o
+endif
 
 ifdef CONFIG_SPL_BUILD
 ifdef CONFIG_TPL_BUILD
diff --git a/lib/asm-offsets.c b/lib/asm-offsets.c
index b04f7c6297..b33d3680a8 100644
--- a/lib/asm-offsets.c
+++ b/lib/asm-offsets.c
@@ -38,5 +38,10 @@ int main(void)
 
 	DEFINE(GD_START_ADDR_SP, offsetof(struct global_data, start_addr_sp));
 
+	DEFINE(PM_CTX_SIZE, sizeof(struct pm_ctx));
+	DEFINE(PM_CTX_PHYS, offsetof(struct global_data, pm_ctx_phys));
+
+	DEFINE(GD_NEW_GD, offsetof(struct global_data, new_gd));
+
 	return 0;
 }
diff --git a/lib/efi_loader/Makefile b/lib/efi_loader/Makefile
index 30bf343a36..f35e5ce8a8 100644
--- a/lib/efi_loader/Makefile
+++ b/lib/efi_loader/Makefile
@@ -15,7 +15,7 @@ always := $(efiprogs-y)
 
 obj-$(CONFIG_CMD_BOOTEFI_HELLO) += helloworld_efi.o
 obj-y += efi_image_loader.o efi_boottime.o efi_runtime.o efi_console.o
-obj-y += efi_memory.o efi_device_path_to_text.o
+obj-y += efi_memory.o efi_device_path_to_text.o efi_device_path.o
 obj-$(CONFIG_LCD) += efi_gop.o
 obj-$(CONFIG_DM_VIDEO) += efi_gop.o
 obj-$(CONFIG_PARTITIONS) += efi_disk.o
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 43f32385fa..cdee10956e 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -10,7 +10,7 @@
 #include <efi_loader.h>
 #include <malloc.h>
 #include <asm/global_data.h>
-#include <libfdt_env.h>
+#include <linux/libfdt_env.h>
 #include <u-boot/crc.h>
 #include <bootm.h>
 #include <inttypes.h>
@@ -665,8 +665,17 @@ static efi_status_t EFIAPI efi_locate_device_path(efi_guid_t *protocol,
 			struct efi_device_path **device_path,
 			efi_handle_t *device)
 {
-	EFI_ENTRY("%p, %p, %p", protocol, device_path, device);
-	return EFI_EXIT(EFI_NOT_FOUND);
+	struct efi_object *efiobj;
+
+	EFI_ENTRY("%pUl, %p, %p", protocol, device_path, device);
+
+	efiobj = efi_dp_find_obj(*device_path, device_path);
+	if (!efiobj)
+		return EFI_EXIT(EFI_NOT_FOUND);
+
+	*device = efiobj->handle;
+
+	return EFI_EXIT(EFI_SUCCESS);
 }
 
 /* Collapses configuration table entries, removing index i */
@@ -717,6 +726,42 @@ static efi_status_t EFIAPI efi_install_configuration_table_ext(efi_guid_t *guid,
 	return EFI_EXIT(efi_install_configuration_table(guid, table));
 }
 
+/* Initialize a loaded_image_info + loaded_image_info object with correct
+ * protocols, boot-device, etc.
+ */
+void efi_setup_loaded_image(struct efi_loaded_image *info, struct efi_object *obj,
+			    struct efi_device_path *device_path,
+			    struct efi_device_path *file_path)
+{
+	obj->handle = info;
+
+	/*
+	 * When asking for the device path interface, return
+	 * bootefi_device_path
+	 */
+	obj->protocols[0].guid = &efi_guid_device_path;
+	obj->protocols[0].protocol_interface = device_path;
+
+	/*
+	 * When asking for the loaded_image interface, just
+	 * return handle which points to loaded_image_info
+	 */
+	obj->protocols[1].guid = &efi_guid_loaded_image;
+	obj->protocols[1].protocol_interface = info;
+
+	obj->protocols[2].guid = &efi_guid_console_control;
+	obj->protocols[2].protocol_interface = (void *)&efi_console_control;
+
+	obj->protocols[3].guid = &efi_guid_device_path_to_text_protocol;
+	obj->protocols[3].protocol_interface =
+		(void *)&efi_device_path_to_text;
+
+	info->file_path = file_path;
+	info->device_handle = efi_dp_find_obj(device_path, NULL);
+
+	list_add_tail(&obj->link, &efi_obj_list);
+}
+
 static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 					  efi_handle_t parent_image,
 					  struct efi_device_path *file_path,
@@ -842,7 +887,7 @@ static efi_status_t EFIAPI efi_exit_boot_services(void *image_handle,
 {
 	EFI_ENTRY("%p, %ld", image_handle, map_key);
 
-	board_quiesce_devices();
+	board_quiesce_devices(NULL);
 
 	/* Fix up caches for EFI payloads if necessary */
 	efi_exit_caches();
diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index 5ebce4b544..3fc82b8726 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -7,6 +7,7 @@
  */
 
 #include <common.h>
+#include <charset.h>
 #include <efi_loader.h>
 
 static bool console_size_queried;
@@ -138,20 +139,8 @@ static efi_status_t EFIAPI efi_cout_reset(
 
 static void print_unicode_in_utf8(u16 c)
 {
-	char utf8[4] = { 0 };
-	char *b = utf8;
-
-	if (c < 0x80) {
-		*(b++) = c;
-	} else if (c < 0x800) {
-		*(b++) = 192 + c / 64;
-		*(b++) = 128 + c % 64;
-	} else {
-		*(b++) = 224 + c / 4096;
-		*(b++) = 128 + c / 64 % 64;
-		*(b++) = 128 + c % 64;
-	}
-
+	char utf8[MAX_UTF8_PER_UTF16] = { 0 };
+	utf16_to_utf8((u8 *)utf8, &c, 1);
 	puts(utf8);
 }
 
diff --git a/lib/efi_loader/efi_disk.c b/lib/efi_loader/efi_disk.c
index ed06485e33..4e3de020a0 100644
--- a/lib/efi_loader/efi_disk.c
+++ b/lib/efi_loader/efi_disk.c
@@ -28,11 +28,13 @@ struct efi_disk_obj {
 	/* EFI Interface Media descriptor struct, referenced by ops */
 	struct efi_block_io_media media;
 	/* EFI device path to this block device */
-	struct efi_device_path_file_path *dp;
+	struct efi_device_path *dp;
+	/* partition # */
+	unsigned int part;
 	/* Offset into disk for simple partitions */
 	lbaint_t offset;
 	/* Internal block device */
-	const struct blk_desc *desc;
+	struct blk_desc *desc;
 };
 
 static efi_status_t EFIAPI efi_disk_reset(struct efi_block_io *this,
@@ -172,26 +174,26 @@ static const struct efi_block_io block_io_disk_template = {
 
 static void efi_disk_add_dev(const char *name,
 			     const char *if_typename,
-			     const struct blk_desc *desc,
+			     struct blk_desc *desc,
 			     int dev_index,
-			     lbaint_t offset)
+			     lbaint_t offset,
+			     unsigned int part)
 {
 	struct efi_disk_obj *diskobj;
-	struct efi_device_path_file_path *dp;
-	int objlen = sizeof(*diskobj) + (sizeof(*dp) * 2);
 
 	/* Don't add empty devices */
 	if (!desc->lba)
 		return;
 
-	diskobj = calloc(1, objlen);
+	diskobj = calloc(1, sizeof(*diskobj));
 
 	/* Fill in object data */
-	dp = (void *)&diskobj[1];
+	diskobj->dp = efi_dp_from_part(desc, part);
+	diskobj->part = part;
 	diskobj->parent.protocols[0].guid = &efi_block_io_guid;
 	diskobj->parent.protocols[0].protocol_interface = &diskobj->ops;
 	diskobj->parent.protocols[1].guid = &efi_guid_device_path;
-	diskobj->parent.protocols[1].protocol_interface = dp;
+	diskobj->parent.protocols[1].protocol_interface = diskobj->dp;
 	diskobj->parent.handle = diskobj;
 	diskobj->ops = block_io_disk_template;
 	diskobj->ifname = if_typename;
@@ -207,17 +209,6 @@ static void efi_disk_add_dev(const char *name,
 	diskobj->media.last_block = desc->lba - offset;
 	diskobj->ops.media = &diskobj->media;
 
-	/* Fill in device path */
-	diskobj->dp = dp;
-	dp[0].dp.type = DEVICE_PATH_TYPE_MEDIA_DEVICE;
-	dp[0].dp.sub_type = DEVICE_PATH_SUB_TYPE_FILE_PATH;
-	dp[0].dp.length = sizeof(*dp);
-	ascii2unicode(dp[0].str, name);
-
-	dp[1].dp.type = DEVICE_PATH_TYPE_END;
-	dp[1].dp.sub_type = DEVICE_PATH_SUB_TYPE_END;
-	dp[1].dp.length = sizeof(*dp);
-
 	/* Hook up to the device list */
 	list_add_tail(&diskobj->parent.link, &efi_obj_list);
 }
@@ -236,14 +227,18 @@ static int efi_disk_create_eltorito(struct blk_desc *desc,
 	if (desc->part_type != PART_TYPE_ISO)
 		return 0;
 
+	/* and devices for each partition: */
 	while (!part_get_info(desc, part, &info)) {
 		snprintf(devname, sizeof(devname), "%s:%d", pdevname,
 			 part);
 		efi_disk_add_dev(devname, if_typename, desc, diskid,
-				 info.start);
+				 info.start, part);
 		part++;
 		disks++;
 	}
+
+	/* ... and add block device: */
+	efi_disk_add_dev(devname, if_typename, desc, diskid, 0, 0);
 #endif
 
 	return disks;
@@ -271,9 +266,22 @@ int efi_disk_register(void)
 	     uclass_next_device_check(&dev)) {
 		struct blk_desc *desc = dev_get_uclass_platdata(dev);
 		const char *if_typename = dev->driver->name;
+		disk_partition_t info;
+		int part = 1;
 
 		printf("Scanning disk %s...\n", dev->name);
-		efi_disk_add_dev(dev->name, if_typename, desc, desc->devnum, 0);
+
+		/* add devices for each partition: */
+		while (!part_get_info(desc, part, &info)) {
+			efi_disk_add_dev(dev->name, if_typename, desc,
+					 desc->devnum, 0, part);
+			part++;
+		}
+
+		/* ... and add block device: */
+		efi_disk_add_dev(dev->name, if_typename, desc,
+				 desc->devnum, 0, 0);
+
 		disks++;
 
 		/*
@@ -309,7 +317,7 @@ int efi_disk_register(void)
 
 			snprintf(devname, sizeof(devname), "%s%d",
 				 if_typename, i);
-			efi_disk_add_dev(devname, if_typename, desc, i, 0);
+			efi_disk_add_dev(devname, if_typename, desc, i, 0, 0);
 			disks++;
 
 			/*
diff --git a/lib/efi_loader/efi_memory.c b/lib/efi_loader/efi_memory.c
index 9e079f1fa3..402ab7fd56 100644
--- a/lib/efi_loader/efi_memory.c
+++ b/lib/efi_loader/efi_memory.c
@@ -10,7 +10,7 @@
 #include <efi_loader.h>
 #include <malloc.h>
 #include <asm/global_data.h>
-#include <libfdt_env.h>
+#include <linux/libfdt_env.h>
 #include <linux/list_sort.h>
 #include <inttypes.h>
 #include <watchdog.h>
diff --git a/lib/efi_loader/efi_net.c b/lib/efi_loader/efi_net.c
index 0b949d86e8..0e135bab21 100644
--- a/lib/efi_loader/efi_net.c
+++ b/lib/efi_loader/efi_net.c
@@ -210,7 +210,7 @@ void efi_net_set_dhcp_ack(void *pkt, int len)
 }
 
 /* This gets called from do_bootefi_exec(). */
-int efi_net_register(void **handle)
+int efi_net_register(void)
 {
 	struct efi_net_obj *netobj;
 	struct efi_device_path_mac_addr dp_net = {
@@ -268,8 +268,5 @@ int efi_net_register(void **handle)
 	/* Hook net up to the device list */
 	list_add_tail(&netobj->parent.link, &efi_obj_list);
 
-	if (handle)
-		*handle = &netobj->net;
-
 	return 0;
 }
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 107a892e79..8bd3d1ad37 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -4,17 +4,18 @@
  */
 
 #ifndef USE_HOSTCC
-#include <boot_fit.h>
 #include <common.h>
+#include <boot_fit.h>
 #include <dm.h>
+#include <dm/of_extra.h>
 #include <errno.h>
-#include <serial.h>
-#include <libfdt.h>
-#include <fdt_support.h>
 #include <fdtdec.h>
+#include <fdt_support.h>
+#include <linux/libfdt.h>
+#include <serial.h>
 #include <asm/sections.h>
-#include <dm/of_extra.h>
 #include <linux/ctype.h>
+#include <linux/lzo.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -70,6 +71,7 @@ static const char * const compat_names[COMPAT_COUNT] = {
 	COMPAT(ALTERA_SOCFPGA_F2SDR0, "altr,socfpga-fpga2sdram0-bridge"),
 	COMPAT(ALTERA_SOCFPGA_F2SDR1, "altr,socfpga-fpga2sdram1-bridge"),
 	COMPAT(ALTERA_SOCFPGA_F2SDR2, "altr,socfpga-fpga2sdram2-bridge"),
+	COMPAT(ROCKCHIP_NANDC, "rockchip,rk-nandc"),
 };
 
 const char *fdtdec_get_compatible(enum fdt_compat_id id)
@@ -90,16 +92,6 @@ fdt_addr_t fdtdec_get_addr_size_fixed(const void *blob, int node,
 
 	debug("%s: %s: ", __func__, prop_name);
 
-	if (na > (sizeof(fdt_addr_t) / sizeof(fdt32_t))) {
-		debug("(na too large for fdt_addr_t type)\n");
-		return FDT_ADDR_T_NONE;
-	}
-
-	if (ns > (sizeof(fdt_size_t) / sizeof(fdt32_t))) {
-		debug("(ns too large for fdt_size_t type)\n");
-		return FDT_ADDR_T_NONE;
-	}
-
 	prop = fdt_getprop(blob, node, prop_name, &len);
 	if (!prop) {
 		debug("(not found)\n");
@@ -194,7 +186,7 @@ fdt_addr_t fdtdec_get_addr(const void *blob, int node,
 	return fdtdec_get_addr_size(blob, node, prop_name, NULL);
 }
 
-#if defined(CONFIG_PCI) && defined(CONFIG_DM_PCI)
+#if defined(CONFIG_PCI) && CONFIG_IS_ENABLED(DM_PCI)
 int fdtdec_get_pci_addr(const void *blob, int node, enum fdt_pci_space type,
 		const char *prop_name, struct fdt_pci_addr *addr)
 {
@@ -1173,21 +1165,33 @@ int fdtdec_setup_memory_size(void)
 #if defined(CONFIG_NR_DRAM_BANKS)
 int fdtdec_setup_memory_banksize(void)
 {
-	int bank, ret, mem;
+	int bank, ret, mem, reg = 0;
 	struct fdt_resource res;
 
-	mem = fdt_path_offset(gd->fdt_blob, "/memory");
+	mem = fdt_node_offset_by_prop_value(gd->fdt_blob, -1, "device_type",
+					    "memory", 7);
 	if (mem < 0) {
 		debug("%s: Missing /memory node\n", __func__);
 		return -EINVAL;
 	}
 
 	for (bank = 0; bank < CONFIG_NR_DRAM_BANKS; bank++) {
-		ret = fdt_get_resource(gd->fdt_blob, mem, "reg", bank, &res);
-		if (ret == -FDT_ERR_NOTFOUND)
-			break;
-		if (ret != 0)
+		ret = fdt_get_resource(gd->fdt_blob, mem, "reg", reg++, &res);
+		if (ret == -FDT_ERR_NOTFOUND) {
+			reg = 0;
+			mem = fdt_node_offset_by_prop_value(gd->fdt_blob, mem,
+							    "device_type",
+							    "memory", 7);
+			if (mem == -FDT_ERR_NOTFOUND)
+				break;
+
+			ret = fdt_get_resource(gd->fdt_blob, mem, "reg", reg++, &res);
+			if (ret == -FDT_ERR_NOTFOUND)
+				break;
+		}
+		if (ret != 0) {
 			return -EINVAL;
+		}
 
 		gd->bd->bi_dram[bank].start = (phys_addr_t)res.start;
 		gd->bd->bi_dram[bank].size =
@@ -1203,12 +1207,73 @@ int fdtdec_setup_memory_banksize(void)
 }
 #endif
 
+#if CONFIG_IS_ENABLED(MULTI_DTB_FIT)
+# if CONFIG_IS_ENABLED(MULTI_DTB_FIT_GZIP) ||\
+	CONFIG_IS_ENABLED(MULTI_DTB_FIT_LZO)
+static int uncompress_blob(const void *src, ulong sz_src, void **dstp)
+{
+	size_t sz_out = CONFIG_SPL_MULTI_DTB_FIT_UNCOMPRESS_SZ;
+	ulong sz_in = sz_src;
+	void *dst;
+	int rc;
+
+	if (CONFIG_IS_ENABLED(GZIP))
+		if (gzip_parse_header(src, sz_in) < 0)
+			return -1;
+	if (CONFIG_IS_ENABLED(LZO))
+		if (!lzop_is_valid_header(src))
+			return -EBADMSG;
+
+	if (CONFIG_IS_ENABLED(MULTI_DTB_FIT_DYN_ALLOC)) {
+		dst = malloc(sz_out);
+		if (!dst) {
+			puts("uncompress_blob: Unable to allocate memory\n");
+			return -ENOMEM;
+		}
+	} else  {
+#  if CONFIG_IS_ENABLED(MULTI_DTB_FIT_USER_DEFINED_AREA)
+		dst = (void *)CONFIG_VAL(MULTI_DTB_FIT_USER_DEF_ADDR);
+#  else
+		return -ENOTSUPP;
+#  endif
+	}
+
+	if (CONFIG_IS_ENABLED(GZIP))
+		rc = gunzip(dst, sz_out, (u8 *)src, &sz_in);
+	else if (CONFIG_IS_ENABLED(LZO))
+		rc = lzop_decompress(src, sz_in, dst, &sz_out);
+
+	if (rc < 0) {
+		/* not a valid compressed blob */
+		puts("uncompress_blob: Unable to uncompress\n");
+		if (CONFIG_IS_ENABLED(MULTI_DTB_FIT_DYN_ALLOC))
+			free(dst);
+		return -EBADMSG;
+	}
+	*dstp = dst;
+	return 0;
+}
+# else
+static int uncompress_blob(const void *src, ulong sz_src, void **dstp)
+{
+	return -ENOTSUPP;
+}
+# endif
+#endif
+
 int fdtdec_setup(void)
 {
 #if CONFIG_IS_ENABLED(OF_CONTROL)
+# if CONFIG_IS_ENABLED(MULTI_DTB_FIT)
+	void *fdt_blob;
+# endif
 # ifdef CONFIG_OF_EMBED
 	/* Get a pointer to the FDT */
+#  ifdef CONFIG_SPL_BUILD
+	gd->fdt_blob = __dtb_dt_spl_begin;
+#  else
 	gd->fdt_blob = __dtb_dt_begin;
+#  endif
 # elif defined CONFIG_OF_SEPARATE
 #  ifdef CONFIG_SPL_BUILD
 	/* FDT is at end of BSS unless it is in a different memory region */
@@ -1216,18 +1281,16 @@ int fdtdec_setup(void)
 		gd->fdt_blob = (ulong *)&_image_binary_end;
 	else
 		gd->fdt_blob = (ulong *)&__bss_end;
-
-#  elif defined CONFIG_FIT_EMBED
-	gd->fdt_blob = locate_dtb_in_fit(&_end);
-
-	if (gd->fdt_blob == NULL || gd->fdt_blob <= ((void *)&_end)) {
-		puts("Failed to find proper dtb in embedded FIT Image\n");
-		return -1;
-	}
-
 #  else
 	/* FDT is at end of image */
 	gd->fdt_blob = (ulong *)&_end;
+
+#    ifdef CONFIG_USING_KERNEL_DTB
+	gd->fdt_blob_kern = (ulong *)ALIGN((ulong)gd->fdt_blob +
+				fdt_totalsize(gd->fdt_blob), 8);
+	if (fdt_check_header(gd->fdt_blob_kern))
+		gd->fdt_blob_kern = NULL;
+#    endif
 #  endif
 # elif defined(CONFIG_OF_BOARD)
 	/* Allow the board to override the fdt address. */
@@ -1240,10 +1303,34 @@ int fdtdec_setup(void)
 # endif
 # ifndef CONFIG_SPL_BUILD
 	/* Allow the early environment to override the fdt address */
+#  if CONFIG_IS_ENABLED(OF_PRIOR_STAGE)
+	gd->fdt_blob = (void *)prior_stage_fdt_address;
+#  else
 	gd->fdt_blob = (void *)env_get_ulong("fdtcontroladdr", 16,
 						(uintptr_t)gd->fdt_blob);
+#  endif
+# endif
+
+# if CONFIG_IS_ENABLED(MULTI_DTB_FIT)
+	/*
+	 * Try and uncompress the blob.
+	 * Unfortunately there is no way to know how big the input blob really
+	 * is. So let us set the maximum input size arbitrarily high. 16MB
+	 * ought to be more than enough for packed DTBs.
+	 */
+	if (uncompress_blob(gd->fdt_blob, 0x1000000, &fdt_blob) == 0)
+		gd->fdt_blob = fdt_blob;
+
+	/*
+	 * Check if blob is a FIT images containings DTBs.
+	 * If so, pick the most relevant
+	 */
+	fdt_blob = locate_dtb_in_fit(gd->fdt_blob);
+	if (fdt_blob)
+		gd->fdt_blob = fdt_blob;
 # endif
 #endif
+
 	return fdtdec_prepare_fdt();
 }
 
diff --git a/lib/fdtdec_common.c b/lib/fdtdec_common.c
index 63b704a3d7..2d083418e0 100644
--- a/lib/fdtdec_common.c
+++ b/lib/fdtdec_common.c
@@ -10,7 +10,7 @@
 
 #ifndef USE_HOSTCC
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <fdtdec.h>
 #else
 #include "libfdt.h"
diff --git a/lib/fdtdec_test.c b/lib/fdtdec_test.c
index cc8b918f64..c51ffd7ecf 100644
--- a/lib/fdtdec_test.c
+++ b/lib/fdtdec_test.c
@@ -8,7 +8,7 @@
 
 #include <common.h>
 #include <fdtdec.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <malloc.h>
 #include <os.h>
 
diff --git a/lib/gunzip.c b/lib/gunzip.c
index 832b3064e7..a064ab907d 100644
--- a/lib/gunzip.c
+++ b/lib/gunzip.c
@@ -12,6 +12,7 @@
 #include <image.h>
 #include <malloc.h>
 #include <memalign.h>
+#include <misc.h>
 #include <u-boot/zlib.h>
 #include <div64.h>
 
@@ -42,7 +43,7 @@ void gzfree(void *x, void *addr, unsigned nb)
 	free (addr);
 }
 
-int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
+int gzip_parse_header(const unsigned char *src, unsigned long len)
 {
 	int i, flags;
 
@@ -50,7 +51,7 @@ int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
 	i = 10;
 	flags = src[3];
 	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
-		puts ("Error: Bad gzipped data\n");
+		debug("Error: Bad gzipped data\n");
 		return (-1);
 	}
 	if ((flags & EXTRA_FIELD) != 0)
@@ -63,12 +64,31 @@ int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
 			;
 	if ((flags & HEAD_CRC) != 0)
 		i += 2;
-	if (i >= *lenp) {
+	if (i >= len) {
 		puts ("Error: gunzip out of data in header\n");
 		return (-1);
 	}
+	return i;
+}
+
+int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
+{
+	int offset = gzip_parse_header(src, *lenp);
 
-	return zunzip(dst, dstlen, src, lenp, 1, i);
+	if (offset < 0)
+		return offset;
+
+#if defined(CONFIG_MISC_DECOMPRESS) && !defined(CONFIG_SPL_BUILD)
+	int ret;
+
+	ret = misc_decompress_process((ulong)dst, (ulong)src, *lenp,
+				      DECOM_GZIP, false, (u64 *)lenp, 0);
+	if (!ret)
+		return 0;
+
+	printf("hw gunzip failed(%d), fallback to soft gunzip\n", ret);
+#endif
+	return zunzip(dst, dstlen, src, lenp, 1, offset);
 }
 
 #ifdef CONFIG_CMD_UNZIP
diff --git a/lib/hang.c b/lib/hang.c
index 9246e12455..1ceafd4257 100644
--- a/lib/hang.c
+++ b/lib/hang.c
@@ -11,6 +11,9 @@
 #include <common.h>
 #include <bootstage.h>
 
+#ifdef CONFIG_SPL_BUILD
+__weak void spl_hang_reset(void) {}
+#endif
 /**
  * hang - stop processing by staying in an endless loop
  *
@@ -26,6 +29,9 @@ void hang(void)
 	puts("### ERROR ### Please RESET the board ###\n");
 #endif
 	bootstage_error(BOOTSTAGE_ID_NEED_RESET);
+#ifdef CONFIG_SPL_BUILD
+	spl_hang_reset();
+#endif
 	for (;;)
 		;
 }
diff --git a/lib/hashtable.c b/lib/hashtable.c
index f08847758a..f4b0bb6c0e 100644
--- a/lib/hashtable.c
+++ b/lib/hashtable.c
@@ -780,7 +780,6 @@ int himport_r(struct hsearch_data *htab,
 {
 	char *data, *sp, *dp, *name, *value;
 	char *localvars[nvars];
-	int i;
 
 	/* Test for correct arguments.  */
 	if (htab == NULL) {
@@ -934,6 +933,13 @@ int himport_r(struct hsearch_data *htab,
 	debug("INSERT: free(data = %p)\n", data);
 	free(data);
 
+	/*
+	 * CONFIG_ENVF=y: don't delete the default variables when they are
+	 * not present in env.img
+	 */
+#ifndef CONFIG_ENVF
+	int i;
+
 	/* process variables which were not considered */
 	for (i = 0; i < nvars; i++) {
 		if (localvars[i] == NULL)
@@ -951,7 +957,7 @@ int himport_r(struct hsearch_data *htab,
 		else
 			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
 	}
-
+#endif
 	debug("INSERT: done\n");
 	return 1;		/* everything OK */
 }
diff --git a/lib/initcall.c b/lib/initcall.c
index db7c558bde..6a625ad24e 100644
--- a/lib/initcall.c
+++ b/lib/initcall.c
@@ -10,9 +10,23 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define TICKS_TO_US(ticks)	((ticks) / (COUNTER_FREQUENCY / 1000000))
+#define US_TO_MS(ticks)		((ticks) / 1000)
+#define US_TO_US(ticks)		((ticks) % 1000)
+
+#ifdef DEBUG
+static inline void call_get_ticks(ulong *ticks) { *ticks = get_ticks(); }
+#else
+static inline void call_get_ticks(ulong *ticks) { }
+#endif
+
 int initcall_run_list(const init_fnc_t init_sequence[])
 {
 	const init_fnc_t *init_fnc_ptr;
+	ulong start = 0, end = 0, sum = 0;
+
+	if (!gd->sys_start_tick)
+		gd->sys_start_tick = get_ticks();
 
 	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
 		unsigned long reloc_ofs = 0;
@@ -28,7 +42,15 @@ int initcall_run_list(const init_fnc_t init_sequence[])
 			debug(" (relocated to %p)\n", (char *)*init_fnc_ptr);
 		else
 			debug("\n");
+		call_get_ticks(&start);
 		ret = (*init_fnc_ptr)();
+		call_get_ticks(&end);
+
+		if (start != end) {
+			sum = TICKS_TO_US(end - gd->sys_start_tick);
+			debug("\t\t\t\t\t\t\t\t#%8ld us #%4ld.%3ld ms\n",
+			      TICKS_TO_US(end - start), US_TO_MS(sum), US_TO_US(sum));
+		}
 		if (ret) {
 			printf("initcall sequence %p failed at call %p (err=%d)\n",
 			       init_sequence,
diff --git a/lib/libfdt/Makefile b/lib/libfdt/Makefile
index 6ef8290f4e..edd8e64ce0 100644
--- a/lib/libfdt/Makefile
+++ b/lib/libfdt/Makefile
@@ -5,15 +5,23 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+# Use upstream code.
 obj-y += \
 	fdt.o \
-	fdt_ro.o \
-	fdt_rw.o \
+	fdt_wip.o \
 	fdt_strerror.o \
 	fdt_sw.o \
-	fdt_wip.o \
+	fdt_rw.o \
 	fdt_empty_tree.o \
-	fdt_addresses.o \
-	fdt_region.o
+	fdt_addresses.o
 
 obj-$(CONFIG_OF_LIBFDT_OVERLAY) += fdt_overlay.o
+
+# Locally modified for U-Boot.
+# TODO: split out the local modifiction.
+obj-y += fdt_ro.o
+
+# U-Boot own file
+obj-y += fdt_region.o
+
+ccflags-y := -I$(srctree)/scripts/dtc/libfdt
diff --git a/lib/libfdt/fdt.c b/lib/libfdt/fdt.c
index 2055734012..0958e6ba57 100644
--- a/lib/libfdt/fdt.c
+++ b/lib/libfdt/fdt.c
@@ -1,210 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-
-#ifndef USE_HOSTCC
-#include <fdt.h>
-#include <libfdt.h>
-#else
-#include "fdt_host.h"
-#endif
-
-#include "libfdt_internal.h"
-
-int fdt_check_header(const void *fdt)
-{
-	if (fdt_magic(fdt) == FDT_MAGIC) {
-		/* Complete tree */
-		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
-			return -FDT_ERR_BADVERSION;
-		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
-			return -FDT_ERR_BADVERSION;
-	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
-		/* Unfinished sequential-write blob */
-		if (fdt_size_dt_struct(fdt) == 0)
-			return -FDT_ERR_BADSTATE;
-	} else {
-		return -FDT_ERR_BADMAGIC;
-	}
-
-	return 0;
-}
-
-const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int len)
-{
-	unsigned absoffset = offset + fdt_off_dt_struct(fdt);
-
-	if ((absoffset < offset)
-	    || ((absoffset + len) < absoffset)
-	    || (absoffset + len) > fdt_totalsize(fdt))
-		return NULL;
-
-	if (fdt_version(fdt) >= 0x11)
-		if (((offset + len) < offset)
-		    || ((offset + len) > fdt_size_dt_struct(fdt)))
-			return NULL;
-
-	return _fdt_offset_ptr(fdt, offset);
-}
-
-uint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)
-{
-	const fdt32_t *tagp, *lenp;
-	uint32_t tag;
-	int offset = startoffset;
-	const char *p;
-
-	*nextoffset = -FDT_ERR_TRUNCATED;
-	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
-	if (!tagp)
-		return FDT_END; /* premature end */
-	tag = fdt32_to_cpu(*tagp);
-	offset += FDT_TAGSIZE;
-
-	*nextoffset = -FDT_ERR_BADSTRUCTURE;
-	switch (tag) {
-	case FDT_BEGIN_NODE:
-		/* skip name */
-		do {
-			p = fdt_offset_ptr(fdt, offset++, 1);
-		} while (p && (*p != '\0'));
-		if (!p)
-			return FDT_END; /* premature end */
-		break;
-
-	case FDT_PROP:
-		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
-		if (!lenp)
-			return FDT_END; /* premature end */
-		/* skip-name offset, length and value */
-		offset += sizeof(struct fdt_property) - FDT_TAGSIZE
-			+ fdt32_to_cpu(*lenp);
-		break;
-
-	case FDT_END:
-	case FDT_END_NODE:
-	case FDT_NOP:
-		break;
-
-	default:
-		return FDT_END;
-	}
-
-	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
-		return FDT_END; /* premature end */
-
-	*nextoffset = FDT_TAGALIGN(offset);
-	return tag;
-}
-
-int _fdt_check_node_offset(const void *fdt, int offset)
-{
-	if ((offset < 0) || (offset % FDT_TAGSIZE)
-	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
-		return -FDT_ERR_BADOFFSET;
-
-	return offset;
-}
-
-int _fdt_check_prop_offset(const void *fdt, int offset)
-{
-	if ((offset < 0) || (offset % FDT_TAGSIZE)
-	    || (fdt_next_tag(fdt, offset, &offset) != FDT_PROP))
-		return -FDT_ERR_BADOFFSET;
-
-	return offset;
-}
-
-int fdt_next_node(const void *fdt, int offset, int *depth)
-{
-	int nextoffset = 0;
-	uint32_t tag;
-
-	if (offset >= 0)
-		if ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)
-			return nextoffset;
-
-	do {
-		offset = nextoffset;
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-
-		switch (tag) {
-		case FDT_PROP:
-		case FDT_NOP:
-			break;
-
-		case FDT_BEGIN_NODE:
-			if (depth)
-				(*depth)++;
-			break;
-
-		case FDT_END_NODE:
-			if (depth && ((--(*depth)) < 0))
-				return nextoffset;
-			break;
-
-		case FDT_END:
-			if ((nextoffset >= 0)
-			    || ((nextoffset == -FDT_ERR_TRUNCATED) && !depth))
-				return -FDT_ERR_NOTFOUND;
-			else
-				return nextoffset;
-		}
-	} while (tag != FDT_BEGIN_NODE);
-
-	return offset;
-}
-
-int fdt_first_subnode(const void *fdt, int offset)
-{
-	int depth = 0;
-
-	offset = fdt_next_node(fdt, offset, &depth);
-	if (offset < 0 || depth != 1)
-		return -FDT_ERR_NOTFOUND;
-
-	return offset;
-}
-
-int fdt_next_subnode(const void *fdt, int offset)
-{
-	int depth = 1;
-
-	/*
-	 * With respect to the parent, the depth of the next subnode will be
-	 * the same as the last.
-	 */
-	do {
-		offset = fdt_next_node(fdt, offset, &depth);
-		if (offset < 0 || depth < 1)
-			return -FDT_ERR_NOTFOUND;
-	} while (depth > 1);
-
-	return offset;
-}
-
-const char *_fdt_find_string(const char *strtab, int tabsize, const char *s)
-{
-	int len = strlen(s) + 1;
-	const char *last = strtab + tabsize - len;
-	const char *p;
-
-	for (p = strtab; p <= last; p++)
-		if (memcmp(p, s, len) == 0)
-			return p;
-	return NULL;
-}
-
-int fdt_move(const void *fdt, void *buf, int bufsize)
-{
-	FDT_CHECK_HEADER(fdt);
-
-	if (fdt_totalsize(fdt) > bufsize)
-		return -FDT_ERR_NOSPACE;
-
-	memmove(buf, fdt, fdt_totalsize(fdt));
-	return 0;
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt.c"
diff --git a/lib/libfdt/fdt_addresses.c b/lib/libfdt/fdt_addresses.c
index b6bc66ea32..b82a02936c 100644
--- a/lib/libfdt/fdt_addresses.c
+++ b/lib/libfdt/fdt_addresses.c
@@ -1,55 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2014 David Gibson <david@gibson.dropbear.id.au>
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-
-#ifndef USE_HOSTCC
-#include <fdt.h>
-#include <libfdt.h>
-#else
-#include "fdt_host.h"
-#endif
-
-#include "libfdt_internal.h"
-
-int fdt_address_cells(const void *fdt, int nodeoffset)
-{
-	const fdt32_t *ac;
-	int val;
-	int len;
-
-	ac = fdt_getprop(fdt, nodeoffset, "#address-cells", &len);
-	if (!ac)
-		return 2;
-
-	if (len != sizeof(*ac))
-		return -FDT_ERR_BADNCELLS;
-
-	val = fdt32_to_cpu(*ac);
-	if ((val <= 0) || (val > FDT_MAX_NCELLS))
-		return -FDT_ERR_BADNCELLS;
-
-	return val;
-}
-
-int fdt_size_cells(const void *fdt, int nodeoffset)
-{
-	const fdt32_t *sc;
-	int val;
-	int len;
-
-	sc = fdt_getprop(fdt, nodeoffset, "#size-cells", &len);
-	if (!sc)
-		return 2;
-
-	if (len != sizeof(*sc))
-		return -FDT_ERR_BADNCELLS;
-
-	val = fdt32_to_cpu(*sc);
-	if ((val < 0) || (val > FDT_MAX_NCELLS))
-		return -FDT_ERR_BADNCELLS;
-
-	return val;
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_addresses.c"
diff --git a/lib/libfdt/fdt_empty_tree.c b/lib/libfdt/fdt_empty_tree.c
index 6fde1eb9ed..2b4ae1062b 100644
--- a/lib/libfdt/fdt_empty_tree.c
+++ b/lib/libfdt/fdt_empty_tree.c
@@ -1,37 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2012 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-int fdt_create_empty_tree(void *buf, int bufsize)
-{
-	int err;
-
-	err = fdt_create(buf, bufsize);
-	if (err)
-		return err;
-
-	err = fdt_finish_reservemap(buf);
-	if (err)
-		return err;
-
-	err = fdt_begin_node(buf, "");
-	if (err)
-		return err;
-
-	err =  fdt_end_node(buf);
-	if (err)
-		return err;
-
-	err = fdt_finish(buf);
-	if (err)
-		return err;
-
-	return fdt_open_into(buf, buf, bufsize);
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_empty_tree.c"
diff --git a/lib/libfdt/fdt_overlay.c b/lib/libfdt/fdt_overlay.c
index ceb968786e..575c827673 100644
--- a/lib/libfdt/fdt_overlay.c
+++ b/lib/libfdt/fdt_overlay.c
@@ -1,677 +1,2 @@
-#include "libfdt_env.h"
-
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-/**
- * overlay_get_target_phandle - retrieves the target phandle of a fragment
- * @fdto: pointer to the device tree overlay blob
- * @fragment: node offset of the fragment in the overlay
- *
- * overlay_get_target_phandle() retrieves the target phandle of an
- * overlay fragment when that fragment uses a phandle (target
- * property) instead of a path (target-path property).
- *
- * returns:
- *      the phandle pointed by the target property
- *      0, if the phandle was not found
- *	-1, if the phandle was malformed
- */
-static uint32_t overlay_get_target_phandle(const void *fdto, int fragment)
-{
-	const fdt32_t *val;
-	int len;
-
-	val = fdt_getprop(fdto, fragment, "target", &len);
-	if (!val)
-		return 0;
-
-	if ((len != sizeof(*val)) || (fdt32_to_cpu(*val) == (uint32_t)-1))
-		return (uint32_t)-1;
-
-	return fdt32_to_cpu(*val);
-}
-
-/**
- * overlay_get_target - retrieves the offset of a fragment's target
- * @fdt: Base device tree blob
- * @fdto: Device tree overlay blob
- * @fragment: node offset of the fragment in the overlay
- *
- * overlay_get_target() retrieves the target offset in the base
- * device tree of a fragment, no matter how the actual targetting is
- * done (through a phandle or a path)
- *
- * returns:
- *      the targetted node offset in the base device tree
- *      Negative error code on error
- */
-static int overlay_get_target(const void *fdt, const void *fdto,
-			      int fragment)
-{
-	uint32_t phandle;
-	const char *path;
-	int path_len;
-
-	/* Try first to do a phandle based lookup */
-	phandle = overlay_get_target_phandle(fdto, fragment);
-	if (phandle == (uint32_t)-1)
-		return -FDT_ERR_BADPHANDLE;
-
-	if (phandle)
-		return fdt_node_offset_by_phandle(fdt, phandle);
-
-	/* And then a path based lookup */
-	path = fdt_getprop(fdto, fragment, "target-path", &path_len);
-	if (!path) {
-		/*
-		 * If we haven't found either a target or a
-		 * target-path property in a node that contains a
-		 * __overlay__ subnode (we wouldn't be called
-		 * otherwise), consider it a improperly written
-		 * overlay
-		 */
-		if (path_len == -FDT_ERR_NOTFOUND)
-			return -FDT_ERR_BADOVERLAY;
-
-		return path_len;
-	}
-
-	return fdt_path_offset(fdt, path);
-}
-
-/**
- * overlay_phandle_add_offset - Increases a phandle by an offset
- * @fdt: Base device tree blob
- * @node: Device tree overlay blob
- * @name: Name of the property to modify (phandle or linux,phandle)
- * @delta: offset to apply
- *
- * overlay_phandle_add_offset() increments a node phandle by a given
- * offset.
- *
- * returns:
- *      0 on success.
- *      Negative error code on error
- */
-static int overlay_phandle_add_offset(void *fdt, int node,
-				      const char *name, uint32_t delta)
-{
-	const fdt32_t *val;
-	uint32_t adj_val;
-	int len;
-
-	val = fdt_getprop(fdt, node, name, &len);
-	if (!val)
-		return len;
-
-	if (len != sizeof(*val))
-		return -FDT_ERR_BADPHANDLE;
-
-	adj_val = fdt32_to_cpu(*val);
-	if ((adj_val + delta) < adj_val)
-		return -FDT_ERR_NOPHANDLES;
-
-	adj_val += delta;
-	if (adj_val == (uint32_t)-1)
-		return -FDT_ERR_NOPHANDLES;
-
-	return fdt_setprop_inplace_u32(fdt, node, name, adj_val);
-}
-
-/**
- * overlay_adjust_node_phandles - Offsets the phandles of a node
- * @fdto: Device tree overlay blob
- * @node: Offset of the node we want to adjust
- * @delta: Offset to shift the phandles of
- *
- * overlay_adjust_node_phandles() adds a constant to all the phandles
- * of a given node. This is mainly use as part of the overlay
- * application process, when we want to update all the overlay
- * phandles to not conflict with the overlays of the base device tree.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_adjust_node_phandles(void *fdto, int node,
-					uint32_t delta)
-{
-	int child;
-	int ret;
-
-	ret = overlay_phandle_add_offset(fdto, node, "phandle", delta);
-	if (ret && ret != -FDT_ERR_NOTFOUND)
-		return ret;
-
-	ret = overlay_phandle_add_offset(fdto, node, "linux,phandle", delta);
-	if (ret && ret != -FDT_ERR_NOTFOUND)
-		return ret;
-
-	fdt_for_each_subnode(child, fdto, node) {
-		ret = overlay_adjust_node_phandles(fdto, child, delta);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_adjust_local_phandles - Adjust the phandles of a whole overlay
- * @fdto: Device tree overlay blob
- * @delta: Offset to shift the phandles of
- *
- * overlay_adjust_local_phandles() adds a constant to all the
- * phandles of an overlay. This is mainly use as part of the overlay
- * application process, when we want to update all the overlay
- * phandles to not conflict with the overlays of the base device tree.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_adjust_local_phandles(void *fdto, uint32_t delta)
-{
-	/*
-	 * Start adjusting the phandles from the overlay root
-	 */
-	return overlay_adjust_node_phandles(fdto, 0, delta);
-}
-
-/**
- * overlay_update_local_node_references - Adjust the overlay references
- * @fdto: Device tree overlay blob
- * @tree_node: Node offset of the node to operate on
- * @fixup_node: Node offset of the matching local fixups node
- * @delta: Offset to shift the phandles of
- *
- * overlay_update_local_nodes_references() update the phandles
- * pointing to a node within the device tree overlay by adding a
- * constant delta.
- *
- * This is mainly used as part of a device tree application process,
- * where you want the device tree overlays phandles to not conflict
- * with the ones from the base device tree before merging them.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_update_local_node_references(void *fdto,
-						int tree_node,
-						int fixup_node,
-						uint32_t delta)
-{
-	int fixup_prop;
-	int fixup_child;
-	int ret;
-
-	fdt_for_each_property_offset(fixup_prop, fdto, fixup_node) {
-		const fdt32_t *fixup_val;
-		const char *tree_val;
-		const char *name;
-		int fixup_len;
-		int tree_len;
-		int i;
-
-		fixup_val = fdt_getprop_by_offset(fdto, fixup_prop,
-						  &name, &fixup_len);
-		if (!fixup_val)
-			return fixup_len;
-
-		if (fixup_len % sizeof(uint32_t))
-			return -FDT_ERR_BADOVERLAY;
-
-		tree_val = fdt_getprop(fdto, tree_node, name, &tree_len);
-		if (!tree_val) {
-			if (tree_len == -FDT_ERR_NOTFOUND)
-				return -FDT_ERR_BADOVERLAY;
-
-			return tree_len;
-		}
-
-		for (i = 0; i < (fixup_len / sizeof(uint32_t)); i++) {
-			fdt32_t adj_val;
-			uint32_t poffset;
-
-			poffset = fdt32_to_cpu(fixup_val[i]);
-
-			/*
-			 * phandles to fixup can be unaligned.
-			 *
-			 * Use a memcpy for the architectures that do
-			 * not support unaligned accesses.
-			 */
-			memcpy(&adj_val, tree_val + poffset, sizeof(adj_val));
-
-			adj_val = cpu_to_fdt32(fdt32_to_cpu(adj_val) + delta);
-
-			ret = fdt_setprop_inplace_namelen_partial(fdto,
-								  tree_node,
-								  name,
-								  strlen(name),
-								  poffset,
-								  &adj_val,
-								  sizeof(adj_val));
-			if (ret == -FDT_ERR_NOSPACE)
-				return -FDT_ERR_BADOVERLAY;
-
-			if (ret)
-				return ret;
-		}
-	}
-
-	fdt_for_each_subnode(fixup_child, fdto, fixup_node) {
-		const char *fixup_child_name = fdt_get_name(fdto, fixup_child,
-							    NULL);
-		int tree_child;
-
-		tree_child = fdt_subnode_offset(fdto, tree_node,
-						fixup_child_name);
-		if (tree_child == -FDT_ERR_NOTFOUND)
-			return -FDT_ERR_BADOVERLAY;
-		if (tree_child < 0)
-			return tree_child;
-
-		ret = overlay_update_local_node_references(fdto,
-							   tree_child,
-							   fixup_child,
-							   delta);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_update_local_references - Adjust the overlay references
- * @fdto: Device tree overlay blob
- * @delta: Offset to shift the phandles of
- *
- * overlay_update_local_references() update all the phandles pointing
- * to a node within the device tree overlay by adding a constant
- * delta to not conflict with the base overlay.
- *
- * This is mainly used as part of a device tree application process,
- * where you want the device tree overlays phandles to not conflict
- * with the ones from the base device tree before merging them.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_update_local_references(void *fdto, uint32_t delta)
-{
-	int fixups;
-
-	fixups = fdt_path_offset(fdto, "/__local_fixups__");
-	if (fixups < 0) {
-		/* There's no local phandles to adjust, bail out */
-		if (fixups == -FDT_ERR_NOTFOUND)
-			return 0;
-
-		return fixups;
-	}
-
-	/*
-	 * Update our local references from the root of the tree
-	 */
-	return overlay_update_local_node_references(fdto, 0, fixups,
-						    delta);
-}
-
-/**
- * overlay_fixup_one_phandle - Set an overlay phandle to the base one
- * @fdt: Base Device Tree blob
- * @fdto: Device tree overlay blob
- * @symbols_off: Node offset of the symbols node in the base device tree
- * @path: Path to a node holding a phandle in the overlay
- * @path_len: number of path characters to consider
- * @name: Name of the property holding the phandle reference in the overlay
- * @name_len: number of name characters to consider
- * @poffset: Offset within the overlay property where the phandle is stored
- * @label: Label of the node referenced by the phandle
- *
- * overlay_fixup_one_phandle() resolves an overlay phandle pointing to
- * a node in the base device tree.
- *
- * This is part of the device tree overlay application process, when
- * you want all the phandles in the overlay to point to the actual
- * base dt nodes.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_fixup_one_phandle(void *fdt, void *fdto,
-				     int symbols_off,
-				     const char *path, uint32_t path_len,
-				     const char *name, uint32_t name_len,
-				     int poffset, const char *label)
-{
-	const char *symbol_path;
-	uint32_t phandle;
-	fdt32_t phandle_prop;
-	int symbol_off, fixup_off;
-	int prop_len;
-
-	if (symbols_off < 0)
-		return symbols_off;
-
-	symbol_path = fdt_getprop(fdt, symbols_off, label,
-				  &prop_len);
-	if (!symbol_path)
-		return prop_len;
-
-	symbol_off = fdt_path_offset(fdt, symbol_path);
-	if (symbol_off < 0)
-		return symbol_off;
-
-	phandle = fdt_get_phandle(fdt, symbol_off);
-	if (!phandle)
-		return -FDT_ERR_NOTFOUND;
-
-	fixup_off = fdt_path_offset_namelen(fdto, path, path_len);
-	if (fixup_off == -FDT_ERR_NOTFOUND)
-		return -FDT_ERR_BADOVERLAY;
-	if (fixup_off < 0)
-		return fixup_off;
-
-	phandle_prop = cpu_to_fdt32(phandle);
-	return fdt_setprop_inplace_namelen_partial(fdto, fixup_off,
-						   name, name_len, poffset,
-						   &phandle_prop,
-						   sizeof(phandle_prop));
-};
-
-/**
- * overlay_fixup_phandle - Set an overlay phandle to the base one
- * @fdt: Base Device Tree blob
- * @fdto: Device tree overlay blob
- * @symbols_off: Node offset of the symbols node in the base device tree
- * @property: Property offset in the overlay holding the list of fixups
- *
- * overlay_fixup_phandle() resolves all the overlay phandles pointed
- * to in a __fixups__ property, and updates them to match the phandles
- * in use in the base device tree.
- *
- * This is part of the device tree overlay application process, when
- * you want all the phandles in the overlay to point to the actual
- * base dt nodes.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
-				 int property)
-{
-	const char *value;
-	const char *label;
-	int len;
-
-	value = fdt_getprop_by_offset(fdto, property,
-				      &label, &len);
-	if (!value) {
-		if (len == -FDT_ERR_NOTFOUND)
-			return -FDT_ERR_INTERNAL;
-
-		return len;
-	}
-
-	do {
-		const char *path, *name, *fixup_end;
-		const char *fixup_str = value;
-		uint32_t path_len, name_len;
-		uint32_t fixup_len;
-		char *sep, *endptr;
-		int poffset, ret;
-
-		fixup_end = memchr(value, '\0', len);
-		if (!fixup_end)
-			return -FDT_ERR_BADOVERLAY;
-		fixup_len = fixup_end - fixup_str;
-
-		len -= fixup_len + 1;
-		value += fixup_len + 1;
-
-		path = fixup_str;
-		sep = memchr(fixup_str, ':', fixup_len);
-		if (!sep || *sep != ':')
-			return -FDT_ERR_BADOVERLAY;
-
-		path_len = sep - path;
-		if (path_len == (fixup_len - 1))
-			return -FDT_ERR_BADOVERLAY;
-
-		fixup_len -= path_len + 1;
-		name = sep + 1;
-		sep = memchr(name, ':', fixup_len);
-		if (!sep || *sep != ':')
-			return -FDT_ERR_BADOVERLAY;
-
-		name_len = sep - name;
-		if (!name_len)
-			return -FDT_ERR_BADOVERLAY;
-
-		poffset = strtoul(sep + 1, &endptr, 10);
-		if ((*endptr != '\0') || (endptr <= (sep + 1)))
-			return -FDT_ERR_BADOVERLAY;
-
-		ret = overlay_fixup_one_phandle(fdt, fdto, symbols_off,
-						path, path_len, name, name_len,
-						poffset, label);
-		if (ret)
-			return ret;
-	} while (len > 0);
-
-	return 0;
-}
-
-/**
- * overlay_fixup_phandles - Resolve the overlay phandles to the base
- *                          device tree
- * @fdt: Base Device Tree blob
- * @fdto: Device tree overlay blob
- *
- * overlay_fixup_phandles() resolves all the overlay phandles pointing
- * to nodes in the base device tree.
- *
- * This is one of the steps of the device tree overlay application
- * process, when you want all the phandles in the overlay to point to
- * the actual base dt nodes.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_fixup_phandles(void *fdt, void *fdto)
-{
-	int fixups_off, symbols_off;
-	int property;
-
-	/* We can have overlays without any fixups */
-	fixups_off = fdt_path_offset(fdto, "/__fixups__");
-	if (fixups_off == -FDT_ERR_NOTFOUND)
-		return 0; /* nothing to do */
-	if (fixups_off < 0)
-		return fixups_off;
-
-	/* And base DTs without symbols */
-	symbols_off = fdt_path_offset(fdt, "/__symbols__");
-	if ((symbols_off < 0 && (symbols_off != -FDT_ERR_NOTFOUND)))
-		return symbols_off;
-
-	fdt_for_each_property_offset(property, fdto, fixups_off) {
-		int ret;
-
-		ret = overlay_fixup_phandle(fdt, fdto, symbols_off, property);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_apply_node - Merges a node into the base device tree
- * @fdt: Base Device Tree blob
- * @target: Node offset in the base device tree to apply the fragment to
- * @fdto: Device tree overlay blob
- * @node: Node offset in the overlay holding the changes to merge
- *
- * overlay_apply_node() merges a node into a target base device tree
- * node pointed.
- *
- * This is part of the final step in the device tree overlay
- * application process, when all the phandles have been adjusted and
- * resolved and you just have to merge overlay into the base device
- * tree.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_apply_node(void *fdt, int target,
-			      void *fdto, int node)
-{
-	int property;
-	int subnode;
-
-	fdt_for_each_property_offset(property, fdto, node) {
-		const char *name;
-		const void *prop;
-		int prop_len;
-		int ret;
-
-		prop = fdt_getprop_by_offset(fdto, property, &name,
-					     &prop_len);
-		if (prop_len == -FDT_ERR_NOTFOUND)
-			return -FDT_ERR_INTERNAL;
-		if (prop_len < 0)
-			return prop_len;
-
-		ret = fdt_setprop(fdt, target, name, prop, prop_len);
-		if (ret)
-			return ret;
-	}
-
-	fdt_for_each_subnode(subnode, fdto, node) {
-		const char *name = fdt_get_name(fdto, subnode, NULL);
-		int nnode;
-		int ret;
-
-		nnode = fdt_add_subnode(fdt, target, name);
-		if (nnode == -FDT_ERR_EXISTS) {
-			nnode = fdt_subnode_offset(fdt, target, name);
-			if (nnode == -FDT_ERR_NOTFOUND)
-				return -FDT_ERR_INTERNAL;
-		}
-
-		if (nnode < 0)
-			return nnode;
-
-		ret = overlay_apply_node(fdt, nnode, fdto, subnode);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_merge - Merge an overlay into its base device tree
- * @fdt: Base Device Tree blob
- * @fdto: Device tree overlay blob
- *
- * overlay_merge() merges an overlay into its base device tree.
- *
- * This is the final step in the device tree overlay application
- * process, when all the phandles have been adjusted and resolved and
- * you just have to merge overlay into the base device tree.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_merge(void *fdt, void *fdto)
-{
-	int fragment;
-
-	fdt_for_each_subnode(fragment, fdto, 0) {
-		int overlay;
-		int target;
-		int ret;
-
-		/*
-		 * Each fragments will have an __overlay__ node. If
-		 * they don't, it's not supposed to be merged
-		 */
-		overlay = fdt_subnode_offset(fdto, fragment, "__overlay__");
-		if (overlay == -FDT_ERR_NOTFOUND)
-			continue;
-
-		if (overlay < 0)
-			return overlay;
-
-		target = overlay_get_target(fdt, fdto, fragment);
-		if (target < 0)
-			return target;
-
-		ret = overlay_apply_node(fdt, target, fdto, overlay);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-int fdt_overlay_apply(void *fdt, void *fdto)
-{
-	uint32_t delta = fdt_get_max_phandle(fdt);
-	int ret;
-
-	FDT_CHECK_HEADER(fdt);
-	FDT_CHECK_HEADER(fdto);
-
-	ret = overlay_adjust_local_phandles(fdto, delta);
-	if (ret)
-		goto err;
-
-	ret = overlay_update_local_references(fdto, delta);
-	if (ret)
-		goto err;
-
-	ret = overlay_fixup_phandles(fdt, fdto);
-	if (ret)
-		goto err;
-
-	ret = overlay_merge(fdt, fdto);
-	if (ret)
-		goto err;
-
-	/*
-	 * The overlay has been damaged, erase its magic.
-	 */
-	fdt_set_magic(fdto, ~0);
-
-	return 0;
-
-err:
-	/*
-	 * The overlay might have been damaged, erase its magic.
-	 */
-	fdt_set_magic(fdto, ~0);
-
-	/*
-	 * The base device tree might have been damaged, erase its
-	 * magic.
-	 */
-	fdt_set_magic(fdt, ~0);
-
-	return ret;
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_overlay.c"
diff --git a/lib/libfdt/fdt_region.c b/lib/libfdt/fdt_region.c
index 63099f1d96..70914a4e9b 100644
--- a/lib/libfdt/fdt_region.c
+++ b/lib/libfdt/fdt_region.c
@@ -5,17 +5,146 @@
  * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
  */
 
-#include <libfdt_env.h>
+#include <linux/libfdt_env.h>
 
 #ifndef USE_HOSTCC
 #include <fdt.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #else
 #include "fdt_host.h"
 #endif
 
 #include "libfdt_internal.h"
 
+#define FDT_MAX_DEPTH	32
+
+static int str_in_list(const char *str, char * const list[], int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++)
+		if (!strcmp(list[i], str))
+			return 1;
+
+	return 0;
+}
+
+int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,
+		     char * const exc_prop[], int exc_prop_count,
+		     struct fdt_region region[], int max_regions,
+		     char *path, int path_len, int add_string_tab)
+{
+	int stack[FDT_MAX_DEPTH] = { 0 };
+	char *end;
+	int nextoffset = 0;
+	uint32_t tag;
+	int count = 0;
+	int start = -1;
+	int depth = -1;
+	int want = 0;
+	int base = fdt_off_dt_struct(fdt);
+
+	end = path;
+	*end = '\0';
+	do {
+		const struct fdt_property *prop;
+		const char *name;
+		const char *str;
+		int include = 0;
+		int stop_at = 0;
+		int offset;
+		int len;
+
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+		stop_at = nextoffset;
+
+		switch (tag) {
+		case FDT_PROP:
+			include = want >= 2;
+			stop_at = offset;
+			prop = fdt_get_property_by_offset(fdt, offset, NULL);
+			str = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
+			if (str_in_list(str, exc_prop, exc_prop_count))
+				include = 0;
+			break;
+
+		case FDT_NOP:
+			include = want >= 2;
+			stop_at = offset;
+			break;
+
+		case FDT_BEGIN_NODE:
+			depth++;
+			if (depth == FDT_MAX_DEPTH)
+				return -FDT_ERR_BADSTRUCTURE;
+			name = fdt_get_name(fdt, offset, &len);
+			if (end - path + 2 + len >= path_len)
+				return -FDT_ERR_NOSPACE;
+			if (end != path + 1)
+				*end++ = '/';
+			strcpy(end, name);
+			end += len;
+			stack[depth] = want;
+			if (want == 1)
+				stop_at = offset;
+			if (str_in_list(path, inc, inc_count))
+				want = 2;
+			else if (want)
+				want--;
+			else
+				stop_at = offset;
+			include = want;
+			break;
+
+		case FDT_END_NODE:
+			include = want;
+			want = stack[depth--];
+			while (end > path && *--end != '/')
+				;
+			*end = '\0';
+			break;
+
+		case FDT_END:
+			include = 1;
+			break;
+		}
+
+		if (include && start == -1) {
+			/* Should we merge with previous? */
+			if (count && count <= max_regions &&
+			    offset == region[count - 1].offset +
+					region[count - 1].size - base)
+				start = region[--count].offset - base;
+			else
+				start = offset;
+		}
+
+		if (!include && start != -1) {
+			if (count < max_regions) {
+				region[count].offset = base + start;
+				region[count].size = stop_at - start;
+			}
+			count++;
+			start = -1;
+		}
+	} while (tag != FDT_END);
+
+	if (nextoffset != fdt_size_dt_struct(fdt))
+		return -FDT_ERR_BADLAYOUT;
+
+	/* Add a region for the END tag and the string table */
+	if (count < max_regions) {
+		region[count].offset = base + start;
+		region[count].size = nextoffset - start;
+		if (add_string_tab)
+			region[count].size += fdt_size_dt_strings(fdt);
+	}
+	count++;
+
+	return count;
+}
+
 /**
  * fdt_add_region() - Add a new region to our list
  * @info:	State information
diff --git a/lib/libfdt/fdt_ro.c b/lib/libfdt/fdt_ro.c
old mode 100644
new mode 100755
index 1be9538fd2..7bd7897fcb
--- a/lib/libfdt/fdt_ro.c
+++ b/lib/libfdt/fdt_ro.c
@@ -3,11 +3,11 @@
  * Copyright (C) 2006 David Gibson, IBM Corporation.
  * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
  */
-#include <libfdt_env.h>
+#include <linux/libfdt_env.h>
 
 #ifndef USE_HOSTCC
 #include <fdt.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #else
 #include "fdt_host.h"
 #endif
@@ -526,6 +526,29 @@ int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
 	return offset; /* error from fdt_next_node() */
 }
 
+int fdt_node_offset_by_phandle_node(const void *fdt, int node, uint32_t phandle)
+{
+	int offset;
+
+	if ((phandle == 0) || (phandle == -1) || (node < 0))
+		return -FDT_ERR_BADPHANDLE;
+
+	FDT_CHECK_HEADER(fdt);
+
+	offset = node;
+	if (fdt_get_phandle(fdt, offset) == phandle)
+		return offset;
+
+	for (offset = fdt_next_node(fdt, offset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		if (fdt_get_phandle(fdt, offset) == phandle)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
 int fdt_stringlist_contains(const char *strlist, int listlen, const char *str)
 {
 	int len = strlen(str);
diff --git a/lib/libfdt/fdt_rw.c b/lib/libfdt/fdt_rw.c
index 80a3212141..aafded07a1 100644
--- a/lib/libfdt/fdt_rw.c
+++ b/lib/libfdt/fdt_rw.c
@@ -1,482 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-
-#ifndef USE_HOSTCC
-#include <fdt.h>
-#include <libfdt.h>
-#else
-#include "fdt_host.h"
-#endif
-
-#include "libfdt_internal.h"
-
-static int _fdt_blocks_misordered(const void *fdt,
-			      int mem_rsv_size, int struct_size)
-{
-	return (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))
-		|| (fdt_off_dt_struct(fdt) <
-		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
-		|| (fdt_off_dt_strings(fdt) <
-		    (fdt_off_dt_struct(fdt) + struct_size))
-		|| (fdt_totalsize(fdt) <
-		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
-}
-
-static int _fdt_rw_check_header(void *fdt)
-{
-	FDT_CHECK_HEADER(fdt);
-
-	if (fdt_version(fdt) < 17)
-		return -FDT_ERR_BADVERSION;
-	if (_fdt_blocks_misordered(fdt, sizeof(struct fdt_reserve_entry),
-				   fdt_size_dt_struct(fdt)))
-		return -FDT_ERR_BADLAYOUT;
-	if (fdt_version(fdt) > 17)
-		fdt_set_version(fdt, 17);
-
-	return 0;
-}
-
-#define FDT_RW_CHECK_HEADER(fdt) \
-	{ \
-		int __err; \
-		if ((__err = _fdt_rw_check_header(fdt)) != 0) \
-			return __err; \
-	}
-
-static inline int _fdt_data_size(void *fdt)
-{
-	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
-}
-
-static int _fdt_splice(void *fdt, void *splicepoint, int oldlen, int newlen)
-{
-	char *p = splicepoint;
-	char *end = (char *)fdt + _fdt_data_size(fdt);
-
-	if (((p + oldlen) < p) || ((p + oldlen) > end))
-		return -FDT_ERR_BADOFFSET;
-	if ((p < (char *)fdt) || ((end - oldlen + newlen) < (char *)fdt))
-		return -FDT_ERR_BADOFFSET;
-	if ((end - oldlen + newlen) > ((char *)fdt + fdt_totalsize(fdt)))
-		return -FDT_ERR_NOSPACE;
-	memmove(p + newlen, p + oldlen, end - p - oldlen);
-	return 0;
-}
-
-static int _fdt_splice_mem_rsv(void *fdt, struct fdt_reserve_entry *p,
-			       int oldn, int newn)
-{
-	int delta = (newn - oldn) * sizeof(*p);
-	int err;
-	err = _fdt_splice(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));
-	if (err)
-		return err;
-	fdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);
-	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
-	return 0;
-}
-
-static int _fdt_splice_struct(void *fdt, void *p,
-			      int oldlen, int newlen)
-{
-	int delta = newlen - oldlen;
-	int err;
-
-	if ((err = _fdt_splice(fdt, p, oldlen, newlen)))
-		return err;
-
-	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
-	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
-	return 0;
-}
-
-static int _fdt_splice_string(void *fdt, int newlen)
-{
-	void *p = (char *)fdt
-		+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
-	int err;
-
-	if ((err = _fdt_splice(fdt, p, 0, newlen)))
-		return err;
-
-	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
-	return 0;
-}
-
-static int _fdt_find_add_string(void *fdt, const char *s)
-{
-	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
-	const char *p;
-	char *new;
-	int len = strlen(s) + 1;
-	int err;
-
-	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
-	if (p)
-		/* found it */
-		return (p - strtab);
-
-	new = strtab + fdt_size_dt_strings(fdt);
-	err = _fdt_splice_string(fdt, len);
-	if (err)
-		return err;
-
-	memcpy(new, s, len);
-	return (new - strtab);
-}
-
-int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)
-{
-	struct fdt_reserve_entry *re;
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	re = _fdt_mem_rsv_w(fdt, fdt_num_mem_rsv(fdt));
-	err = _fdt_splice_mem_rsv(fdt, re, 0, 1);
-	if (err)
-		return err;
-
-	re->address = cpu_to_fdt64(address);
-	re->size = cpu_to_fdt64(size);
-	return 0;
-}
-
-int fdt_del_mem_rsv(void *fdt, int n)
-{
-	struct fdt_reserve_entry *re = _fdt_mem_rsv_w(fdt, n);
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	if (n >= fdt_num_mem_rsv(fdt))
-		return -FDT_ERR_NOTFOUND;
-
-	return _fdt_splice_mem_rsv(fdt, re, 1, 0);
-}
-
-static int _fdt_resize_property(void *fdt, int nodeoffset, const char *name,
-				int len, struct fdt_property **prop)
-{
-	int oldlen;
-	int err;
-
-	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
-	if (!*prop)
-		return oldlen;
-
-	if ((err = _fdt_splice_struct(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),
-				      FDT_TAGALIGN(len))))
-		return err;
-
-	(*prop)->len = cpu_to_fdt32(len);
-	return 0;
-}
-
-static int _fdt_add_property(void *fdt, int nodeoffset, const char *name,
-			     int len, struct fdt_property **prop)
-{
-	int proplen;
-	int nextoffset;
-	int namestroff;
-	int err;
-
-	if ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
-		return nextoffset;
-
-	namestroff = _fdt_find_add_string(fdt, name);
-	if (namestroff < 0)
-		return namestroff;
-
-	*prop = _fdt_offset_ptr_w(fdt, nextoffset);
-	proplen = sizeof(**prop) + FDT_TAGALIGN(len);
-
-	err = _fdt_splice_struct(fdt, *prop, 0, proplen);
-	if (err)
-		return err;
-
-	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
-	(*prop)->nameoff = cpu_to_fdt32(namestroff);
-	(*prop)->len = cpu_to_fdt32(len);
-	return 0;
-}
-
-int fdt_set_name(void *fdt, int nodeoffset, const char *name)
-{
-	char *namep;
-	int oldlen, newlen;
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	namep = (char *)(uintptr_t)fdt_get_name(fdt, nodeoffset, &oldlen);
-	if (!namep)
-		return oldlen;
-
-	newlen = strlen(name);
-
-	err = _fdt_splice_struct(fdt, namep, FDT_TAGALIGN(oldlen+1),
-				 FDT_TAGALIGN(newlen+1));
-	if (err)
-		return err;
-
-	memcpy(namep, name, newlen+1);
-	return 0;
-}
-
-int fdt_setprop(void *fdt, int nodeoffset, const char *name,
-		const void *val, int len)
-{
-	struct fdt_property *prop;
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	err = _fdt_resize_property(fdt, nodeoffset, name, len, &prop);
-	if (err == -FDT_ERR_NOTFOUND)
-		err = _fdt_add_property(fdt, nodeoffset, name, len, &prop);
-	if (err)
-		return err;
-
-	if (len)
-		memcpy(prop->data, val, len);
-	return 0;
-}
-
-int fdt_appendprop(void *fdt, int nodeoffset, const char *name,
-		   const void *val, int len)
-{
-	struct fdt_property *prop;
-	int err, oldlen, newlen;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
-	if (prop) {
-		newlen = len + oldlen;
-		err = _fdt_splice_struct(fdt, prop->data,
-					 FDT_TAGALIGN(oldlen),
-					 FDT_TAGALIGN(newlen));
-		if (err)
-			return err;
-		prop->len = cpu_to_fdt32(newlen);
-		memcpy(prop->data + oldlen, val, len);
-	} else {
-		err = _fdt_add_property(fdt, nodeoffset, name, len, &prop);
-		if (err)
-			return err;
-		memcpy(prop->data, val, len);
-	}
-	return 0;
-}
-
-int fdt_delprop(void *fdt, int nodeoffset, const char *name)
-{
-	struct fdt_property *prop;
-	int len, proplen;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
-	if (!prop)
-		return len;
-
-	proplen = sizeof(*prop) + FDT_TAGALIGN(len);
-	return _fdt_splice_struct(fdt, prop, proplen, 0);
-}
-
-int fdt_add_subnode_namelen(void *fdt, int parentoffset,
-			    const char *name, int namelen)
-{
-	struct fdt_node_header *nh;
-	int offset, nextoffset;
-	int nodelen;
-	int err;
-	uint32_t tag;
-	fdt32_t *endtag;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	offset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);
-	if (offset >= 0)
-		return -FDT_ERR_EXISTS;
-	else if (offset != -FDT_ERR_NOTFOUND)
-		return offset;
-
-	/* Try to place the new node after the parent's properties */
-	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
-	do {
-		offset = nextoffset;
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-	} while ((tag == FDT_PROP) || (tag == FDT_NOP));
-
-	nh = _fdt_offset_ptr_w(fdt, offset);
-	nodelen = sizeof(*nh) + FDT_TAGALIGN(namelen+1) + FDT_TAGSIZE;
-
-	err = _fdt_splice_struct(fdt, nh, 0, nodelen);
-	if (err)
-		return err;
-
-	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
-	memset(nh->name, 0, FDT_TAGALIGN(namelen+1));
-	memcpy(nh->name, name, namelen);
-	endtag = (fdt32_t *)((char *)nh + nodelen - FDT_TAGSIZE);
-	*endtag = cpu_to_fdt32(FDT_END_NODE);
-
-	return offset;
-}
-
-int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
-{
-	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
-}
-
-int fdt_del_node(void *fdt, int nodeoffset)
-{
-	int endoffset;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
-	if (endoffset < 0)
-		return endoffset;
-
-	return _fdt_splice_struct(fdt, _fdt_offset_ptr_w(fdt, nodeoffset),
-				  endoffset - nodeoffset, 0);
-}
-
-static void _fdt_packblocks(const char *old, char *new,
-			    int mem_rsv_size, int struct_size)
-{
-	int mem_rsv_off, struct_off, strings_off;
-
-	mem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);
-	struct_off = mem_rsv_off + mem_rsv_size;
-	strings_off = struct_off + struct_size;
-
-	memmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);
-	fdt_set_off_mem_rsvmap(new, mem_rsv_off);
-
-	memmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);
-	fdt_set_off_dt_struct(new, struct_off);
-	fdt_set_size_dt_struct(new, struct_size);
-
-	memmove(new + strings_off, old + fdt_off_dt_strings(old),
-		fdt_size_dt_strings(old));
-	fdt_set_off_dt_strings(new, strings_off);
-	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
-}
-
-int fdt_open_into(const void *fdt, void *buf, int bufsize)
-{
-	int err;
-	int mem_rsv_size, struct_size;
-	int newsize;
-	const char *fdtstart = fdt;
-	const char *fdtend = fdtstart + fdt_totalsize(fdt);
-	char *tmp;
-
-	FDT_CHECK_HEADER(fdt);
-
-	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
-		* sizeof(struct fdt_reserve_entry);
-
-	if (fdt_version(fdt) >= 17) {
-		struct_size = fdt_size_dt_struct(fdt);
-	} else {
-		struct_size = 0;
-		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
-			;
-		if (struct_size < 0)
-			return struct_size;
-	}
-
-	if (!_fdt_blocks_misordered(fdt, mem_rsv_size, struct_size)) {
-		/* no further work necessary */
-		err = fdt_move(fdt, buf, bufsize);
-		if (err)
-			return err;
-		fdt_set_version(buf, 17);
-		fdt_set_size_dt_struct(buf, struct_size);
-		fdt_set_totalsize(buf, bufsize);
-		return 0;
-	}
-
-	/* Need to reorder */
-	newsize = FDT_ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size
-		+ struct_size + fdt_size_dt_strings(fdt);
-
-	if (bufsize < newsize)
-		return -FDT_ERR_NOSPACE;
-
-	/* First attempt to build converted tree at beginning of buffer */
-	tmp = buf;
-	/* But if that overlaps with the old tree... */
-	if (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {
-		/* Try right after the old tree instead */
-		tmp = (char *)(uintptr_t)fdtend;
-		if ((tmp + newsize) > ((char *)buf + bufsize))
-			return -FDT_ERR_NOSPACE;
-	}
-
-	_fdt_packblocks(fdt, tmp, mem_rsv_size, struct_size);
-	memmove(buf, tmp, newsize);
-
-	fdt_set_magic(buf, FDT_MAGIC);
-	fdt_set_totalsize(buf, bufsize);
-	fdt_set_version(buf, 17);
-	fdt_set_last_comp_version(buf, 16);
-	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
-
-	return 0;
-}
-
-int fdt_pack(void *fdt)
-{
-	int mem_rsv_size;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
-		* sizeof(struct fdt_reserve_entry);
-	_fdt_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
-	fdt_set_totalsize(fdt, _fdt_data_size(fdt));
-
-	return 0;
-}
-
-int fdt_remove_unused_strings(const void *old, void *new)
-{
-	const struct fdt_property *old_prop;
-	struct fdt_property *new_prop;
-	int size = fdt_totalsize(old);
-	int next_offset, offset;
-	const char *str;
-	int ret;
-	int tag = FDT_PROP;
-
-	/* Make a copy and remove the strings */
-	memcpy(new, old, size);
-	fdt_set_size_dt_strings(new, 0);
-
-	/* Add every property name back into the new string table */
-	for (offset = 0; tag != FDT_END; offset = next_offset) {
-		tag = fdt_next_tag(old, offset, &next_offset);
-		if (tag != FDT_PROP)
-			continue;
-		old_prop = fdt_get_property_by_offset(old, offset, NULL);
-		new_prop = (struct fdt_property *)(unsigned long)
-			fdt_get_property_by_offset(new, offset, NULL);
-		str = fdt_string(old, fdt32_to_cpu(old_prop->nameoff));
-		ret = _fdt_find_add_string(new, str);
-		if (ret < 0)
-			return ret;
-		new_prop->nameoff = cpu_to_fdt32(ret);
-	}
-
-	return 0;
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_rw.c"
diff --git a/lib/libfdt/fdt_strerror.c b/lib/libfdt/fdt_strerror.c
index f89004c609..408a88328f 100644
--- a/lib/libfdt/fdt_strerror.c
+++ b/lib/libfdt/fdt_strerror.c
@@ -1,61 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-
-#ifndef USE_HOSTCC
-#include <fdt.h>
-#include <libfdt.h>
-#else
-#include "fdt_host.h"
-#endif
-
-#include "libfdt_internal.h"
-
-struct fdt_errtabent {
-	const char *str;
-};
-
-#define FDT_ERRTABENT(val) \
-	[(val)] = { .str = #val, }
-
-static struct fdt_errtabent fdt_errtable[] = {
-	FDT_ERRTABENT(FDT_ERR_NOTFOUND),
-	FDT_ERRTABENT(FDT_ERR_EXISTS),
-	FDT_ERRTABENT(FDT_ERR_NOSPACE),
-
-	FDT_ERRTABENT(FDT_ERR_BADOFFSET),
-	FDT_ERRTABENT(FDT_ERR_BADPATH),
-	FDT_ERRTABENT(FDT_ERR_BADPHANDLE),
-	FDT_ERRTABENT(FDT_ERR_BADSTATE),
-
-	FDT_ERRTABENT(FDT_ERR_TRUNCATED),
-	FDT_ERRTABENT(FDT_ERR_BADMAGIC),
-	FDT_ERRTABENT(FDT_ERR_BADVERSION),
-	FDT_ERRTABENT(FDT_ERR_BADSTRUCTURE),
-	FDT_ERRTABENT(FDT_ERR_BADLAYOUT),
-	FDT_ERRTABENT(FDT_ERR_INTERNAL),
-	FDT_ERRTABENT(FDT_ERR_BADNCELLS),
-	FDT_ERRTABENT(FDT_ERR_BADVALUE),
-	FDT_ERRTABENT(FDT_ERR_BADOVERLAY),
-	FDT_ERRTABENT(FDT_ERR_NOPHANDLES),
-};
-#define FDT_ERRTABSIZE	(sizeof(fdt_errtable) / sizeof(fdt_errtable[0]))
-
-const char *fdt_strerror(int errval)
-{
-	if (errval > 0)
-		return "<valid offset/length>";
-	else if (errval == 0)
-		return "<no error>";
-	else if (errval > -FDT_ERRTABSIZE) {
-		const char *s = fdt_errtable[-errval].str;
-
-		if (s)
-			return s;
-	}
-
-	return "<unknown error>";
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_strerror.c"
diff --git a/lib/libfdt/fdt_sw.c b/lib/libfdt/fdt_sw.c
index 70fd026550..0da3ed92f3 100644
--- a/lib/libfdt/fdt_sw.c
+++ b/lib/libfdt/fdt_sw.c
@@ -1,254 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-static int _fdt_sw_check_header(void *fdt)
-{
-	if (fdt_magic(fdt) != FDT_SW_MAGIC)
-		return -FDT_ERR_BADMAGIC;
-	/* FIXME: should check more details about the header state */
-	return 0;
-}
-
-#define FDT_SW_CHECK_HEADER(fdt) \
-	{ \
-		int err; \
-		if ((err = _fdt_sw_check_header(fdt)) != 0) \
-			return err; \
-	}
-
-static void *_fdt_grab_space(void *fdt, size_t len)
-{
-	int offset = fdt_size_dt_struct(fdt);
-	int spaceleft;
-
-	spaceleft = fdt_totalsize(fdt) - fdt_off_dt_struct(fdt)
-		- fdt_size_dt_strings(fdt);
-
-	if ((offset + len < offset) || (offset + len > spaceleft))
-		return NULL;
-
-	fdt_set_size_dt_struct(fdt, offset + len);
-	return _fdt_offset_ptr_w(fdt, offset);
-}
-
-int fdt_create(void *buf, int bufsize)
-{
-	void *fdt = buf;
-
-	if (bufsize < sizeof(struct fdt_header))
-		return -FDT_ERR_NOSPACE;
-
-	memset(buf, 0, bufsize);
-
-	fdt_set_magic(fdt, FDT_SW_MAGIC);
-	fdt_set_version(fdt, FDT_LAST_SUPPORTED_VERSION);
-	fdt_set_last_comp_version(fdt, FDT_FIRST_SUPPORTED_VERSION);
-	fdt_set_totalsize(fdt,  bufsize);
-
-	fdt_set_off_mem_rsvmap(fdt, FDT_ALIGN(sizeof(struct fdt_header),
-					      sizeof(struct fdt_reserve_entry)));
-	fdt_set_off_dt_struct(fdt, fdt_off_mem_rsvmap(fdt));
-	fdt_set_off_dt_strings(fdt, bufsize);
-
-	return 0;
-}
-
-int fdt_resize(void *fdt, void *buf, int bufsize)
-{
-	size_t headsize, tailsize;
-	char *oldtail, *newtail;
-
-	FDT_SW_CHECK_HEADER(fdt);
-
-	headsize = fdt_off_dt_struct(fdt);
-	tailsize = fdt_size_dt_strings(fdt);
-
-	if ((headsize + tailsize) > bufsize)
-		return -FDT_ERR_NOSPACE;
-
-	oldtail = (char *)fdt + fdt_totalsize(fdt) - tailsize;
-	newtail = (char *)buf + bufsize - tailsize;
-
-	/* Two cases to avoid clobbering data if the old and new
-	 * buffers partially overlap */
-	if (buf <= fdt) {
-		memmove(buf, fdt, headsize);
-		memmove(newtail, oldtail, tailsize);
-	} else {
-		memmove(newtail, oldtail, tailsize);
-		memmove(buf, fdt, headsize);
-	}
-
-	fdt_set_off_dt_strings(buf, bufsize);
-	fdt_set_totalsize(buf, bufsize);
-
-	return 0;
-}
-
-int fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size)
-{
-	struct fdt_reserve_entry *re;
-	int offset;
-
-	FDT_SW_CHECK_HEADER(fdt);
-
-	if (fdt_size_dt_struct(fdt))
-		return -FDT_ERR_BADSTATE;
-
-	offset = fdt_off_dt_struct(fdt);
-	if ((offset + sizeof(*re)) > fdt_totalsize(fdt))
-		return -FDT_ERR_NOSPACE;
-
-	re = (struct fdt_reserve_entry *)((char *)fdt + offset);
-	re->address = cpu_to_fdt64(addr);
-	re->size = cpu_to_fdt64(size);
-
-	fdt_set_off_dt_struct(fdt, offset + sizeof(*re));
-
-	return 0;
-}
-
-int fdt_finish_reservemap(void *fdt)
-{
-	return fdt_add_reservemap_entry(fdt, 0, 0);
-}
-
-int fdt_begin_node(void *fdt, const char *name)
-{
-	struct fdt_node_header *nh;
-	int namelen = strlen(name) + 1;
-
-	FDT_SW_CHECK_HEADER(fdt);
-
-	nh = _fdt_grab_space(fdt, sizeof(*nh) + FDT_TAGALIGN(namelen));
-	if (! nh)
-		return -FDT_ERR_NOSPACE;
-
-	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
-	memcpy(nh->name, name, namelen);
-	return 0;
-}
-
-int fdt_end_node(void *fdt)
-{
-	fdt32_t *en;
-
-	FDT_SW_CHECK_HEADER(fdt);
-
-	en = _fdt_grab_space(fdt, FDT_TAGSIZE);
-	if (! en)
-		return -FDT_ERR_NOSPACE;
-
-	*en = cpu_to_fdt32(FDT_END_NODE);
-	return 0;
-}
-
-static int _fdt_find_add_string(void *fdt, const char *s)
-{
-	char *strtab = (char *)fdt + fdt_totalsize(fdt);
-	const char *p;
-	int strtabsize = fdt_size_dt_strings(fdt);
-	int len = strlen(s) + 1;
-	int struct_top, offset;
-
-	p = _fdt_find_string(strtab - strtabsize, strtabsize, s);
-	if (p)
-		return p - strtab;
-
-	/* Add it */
-	offset = -strtabsize - len;
-	struct_top = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
-	if (fdt_totalsize(fdt) + offset < struct_top)
-		return 0; /* no more room :( */
-
-	memcpy(strtab + offset, s, len);
-	fdt_set_size_dt_strings(fdt, strtabsize + len);
-	return offset;
-}
-
-int fdt_property_placeholder(void *fdt, const char *name, int len, void **valp)
-{
-	struct fdt_property *prop;
-	int nameoff;
-
-	FDT_SW_CHECK_HEADER(fdt);
-
-	nameoff = _fdt_find_add_string(fdt, name);
-	if (nameoff == 0)
-		return -FDT_ERR_NOSPACE;
-
-	prop = _fdt_grab_space(fdt, sizeof(*prop) + FDT_TAGALIGN(len));
-	if (! prop)
-		return -FDT_ERR_NOSPACE;
-
-	prop->tag = cpu_to_fdt32(FDT_PROP);
-	prop->nameoff = cpu_to_fdt32(nameoff);
-	prop->len = cpu_to_fdt32(len);
-	*valp = prop->data;
-	return 0;
-}
-
-int fdt_property(void *fdt, const char *name, const void *val, int len)
-{
-	void *ptr;
-	int ret;
-
-	ret = fdt_property_placeholder(fdt, name, len, &ptr);
-	if (ret)
-		return ret;
-	memcpy(ptr, val, len);
-	return 0;
-}
-
-int fdt_finish(void *fdt)
-{
-	char *p = (char *)fdt;
-	fdt32_t *end;
-	int oldstroffset, newstroffset;
-	uint32_t tag;
-	int offset, nextoffset;
-
-	FDT_SW_CHECK_HEADER(fdt);
-
-	/* Add terminator */
-	end = _fdt_grab_space(fdt, sizeof(*end));
-	if (! end)
-		return -FDT_ERR_NOSPACE;
-	*end = cpu_to_fdt32(FDT_END);
-
-	/* Relocate the string table */
-	oldstroffset = fdt_totalsize(fdt) - fdt_size_dt_strings(fdt);
-	newstroffset = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
-	memmove(p + newstroffset, p + oldstroffset, fdt_size_dt_strings(fdt));
-	fdt_set_off_dt_strings(fdt, newstroffset);
-
-	/* Walk the structure, correcting string offsets */
-	offset = 0;
-	while ((tag = fdt_next_tag(fdt, offset, &nextoffset)) != FDT_END) {
-		if (tag == FDT_PROP) {
-			struct fdt_property *prop =
-				_fdt_offset_ptr_w(fdt, offset);
-			int nameoff;
-
-			nameoff = fdt32_to_cpu(prop->nameoff);
-			nameoff += fdt_size_dt_strings(fdt);
-			prop->nameoff = cpu_to_fdt32(nameoff);
-		}
-		offset = nextoffset;
-	}
-	if (nextoffset < 0)
-		return nextoffset;
-
-	/* Finally, adjust the header */
-	fdt_set_totalsize(fdt, newstroffset + fdt_size_dt_strings(fdt));
-	fdt_set_magic(fdt, FDT_MAGIC);
-	return 0;
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_sw.c"
diff --git a/lib/libfdt/fdt_wip.c b/lib/libfdt/fdt_wip.c
index 45fb964120..6a771d0660 100644
--- a/lib/libfdt/fdt_wip.c
+++ b/lib/libfdt/fdt_wip.c
@@ -1,227 +1,2 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <libfdt_env.h>
-
-#ifndef USE_HOSTCC
-#include <fdt.h>
-#include <libfdt.h>
-#else
-#include "fdt_host.h"
-#endif
-
-#include "libfdt_internal.h"
-
-int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
-					const char *name, int namelen,
-					uint32_t idx, const void *val,
-					int len)
-{
-	void *propval;
-	int proplen;
-
-	propval = fdt_getprop_namelen_w(fdt, nodeoffset, name, namelen,
-					&proplen);
-	if (!propval)
-		return proplen;
-
-	if (proplen < (len + idx))
-		return -FDT_ERR_NOSPACE;
-
-	memcpy((char *)propval + idx, val, len);
-	return 0;
-}
-
-int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
-			const void *val, int len)
-{
-	const void *propval;
-	int proplen;
-
-	propval = fdt_getprop(fdt, nodeoffset, name, &proplen);
-	if (!propval)
-		return proplen;
-
-	if (proplen != len)
-		return -FDT_ERR_NOSPACE;
-
-	return fdt_setprop_inplace_namelen_partial(fdt, nodeoffset, name,
-						   strlen(name), 0,
-						   val, len);
-}
-
-static void _fdt_nop_region(void *start, int len)
-{
-	fdt32_t *p;
-
-	for (p = start; (char *)p < ((char *)start + len); p++)
-		*p = cpu_to_fdt32(FDT_NOP);
-}
-
-int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
-{
-	struct fdt_property *prop;
-	int len;
-
-	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
-	if (!prop)
-		return len;
-
-	_fdt_nop_region(prop, len + sizeof(*prop));
-
-	return 0;
-}
-
-int _fdt_node_end_offset(void *fdt, int offset)
-{
-	int depth = 0;
-
-	while ((offset >= 0) && (depth >= 0))
-		offset = fdt_next_node(fdt, offset, &depth);
-
-	return offset;
-}
-
-int fdt_nop_node(void *fdt, int nodeoffset)
-{
-	int endoffset;
-
-	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
-	if (endoffset < 0)
-		return endoffset;
-
-	_fdt_nop_region(fdt_offset_ptr_w(fdt, nodeoffset, 0),
-			endoffset - nodeoffset);
-	return 0;
-}
-
-#define FDT_MAX_DEPTH	32
-
-static int str_in_list(const char *str, char * const list[], int count)
-{
-	int i;
-
-	for (i = 0; i < count; i++)
-		if (!strcmp(list[i], str))
-			return 1;
-
-	return 0;
-}
-
-int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,
-		     char * const exc_prop[], int exc_prop_count,
-		     struct fdt_region region[], int max_regions,
-		     char *path, int path_len, int add_string_tab)
-{
-	int stack[FDT_MAX_DEPTH];
-	char *end;
-	int nextoffset = 0;
-	uint32_t tag;
-	int count = 0;
-	int start = -1;
-	int depth = -1;
-	int want = 0;
-	int base = fdt_off_dt_struct(fdt);
-
-	end = path;
-	*end = '\0';
-	do {
-		const struct fdt_property *prop;
-		const char *name;
-		const char *str;
-		int include = 0;
-		int stop_at = 0;
-		int offset;
-		int len;
-
-		offset = nextoffset;
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-		stop_at = nextoffset;
-
-		switch (tag) {
-		case FDT_PROP:
-			include = want >= 2;
-			stop_at = offset;
-			prop = fdt_get_property_by_offset(fdt, offset, NULL);
-			str = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
-			if (str_in_list(str, exc_prop, exc_prop_count))
-				include = 0;
-			break;
-
-		case FDT_NOP:
-			include = want >= 2;
-			stop_at = offset;
-			break;
-
-		case FDT_BEGIN_NODE:
-			depth++;
-			if (depth == FDT_MAX_DEPTH)
-				return -FDT_ERR_BADSTRUCTURE;
-			name = fdt_get_name(fdt, offset, &len);
-			if (end - path + 2 + len >= path_len)
-				return -FDT_ERR_NOSPACE;
-			if (end != path + 1)
-				*end++ = '/';
-			strcpy(end, name);
-			end += len;
-			stack[depth] = want;
-			if (want == 1)
-				stop_at = offset;
-			if (str_in_list(path, inc, inc_count))
-				want = 2;
-			else if (want)
-				want--;
-			else
-				stop_at = offset;
-			include = want;
-			break;
-
-		case FDT_END_NODE:
-			include = want;
-			want = stack[depth--];
-			while (end > path && *--end != '/')
-				;
-			*end = '\0';
-			break;
-
-		case FDT_END:
-			include = 1;
-			break;
-		}
-
-		if (include && start == -1) {
-			/* Should we merge with previous? */
-			if (count && count <= max_regions &&
-			    offset == region[count - 1].offset +
-					region[count - 1].size - base)
-				start = region[--count].offset - base;
-			else
-				start = offset;
-		}
-
-		if (!include && start != -1) {
-			if (count < max_regions) {
-				region[count].offset = base + start;
-				region[count].size = stop_at - start;
-			}
-			count++;
-			start = -1;
-		}
-	} while (tag != FDT_END);
-
-	if (nextoffset != fdt_size_dt_struct(fdt))
-		return -FDT_ERR_BADLAYOUT;
-
-	/* Add a region for the END tag and the string table */
-	if (count < max_regions) {
-		region[count].offset = base + start;
-		region[count].size = nextoffset - start;
-		if (add_string_tab)
-			region[count].size += fdt_size_dt_strings(fdt);
-	}
-	count++;
-
-	return count;
-}
+#include <linux/libfdt_env.h>
+#include "../../scripts/dtc/libfdt/fdt_wip.c"
diff --git a/lib/libfdt/libfdt.h b/lib/libfdt/libfdt.h
index f3f9cad184..6af94cb3f7 100644
--- a/lib/libfdt/libfdt.h
+++ b/lib/libfdt/libfdt.h
@@ -1404,6 +1404,37 @@ int fdt_set_name(void *fdt, int nodeoffset, const char *name);
 int fdt_setprop(void *fdt, int nodeoffset, const char *name,
 		const void *val, int len);
 
+/**
+ * fdt_setprop _placeholder - allocate space for a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @len: length of the property value
+ * @prop_data: return pointer to property data
+ *
+ * fdt_setprop_placeholer() allocates the named property in the given node.
+ * If the property exists it is resized. In either case a pointer to the
+ * property data is returned.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,
+			    int len, void **prop_data);
+
 /**
  * fdt_setprop_u32 - set a property to a 32-bit integer
  * @fdt: pointer to the device tree blob
diff --git a/lib/libfdt/libfdt_internal.h b/lib/libfdt/libfdt_internal.h
index 9a79fe85dd..5197c5d698 100644
--- a/lib/libfdt/libfdt_internal.h
+++ b/lib/libfdt/libfdt_internal.h
@@ -1,50 +1 @@
-#ifndef _LIBFDT_INTERNAL_H
-#define _LIBFDT_INTERNAL_H
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- * SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
- */
-#include <fdt.h>
-
-#define FDT_ALIGN(x, a)		(((x) + (a) - 1) & ~((a) - 1))
-#define FDT_TAGALIGN(x)		(FDT_ALIGN((x), FDT_TAGSIZE))
-
-#define FDT_CHECK_HEADER(fdt) \
-	{ \
-		int __err; \
-		if ((__err = fdt_check_header(fdt)) != 0) \
-			return __err; \
-	}
-
-int _fdt_check_node_offset(const void *fdt, int offset);
-int _fdt_check_prop_offset(const void *fdt, int offset);
-const char *_fdt_find_string(const char *strtab, int tabsize, const char *s);
-int _fdt_node_end_offset(void *fdt, int nodeoffset);
-
-static inline const void *_fdt_offset_ptr(const void *fdt, int offset)
-{
-	return (const char *)fdt + fdt_off_dt_struct(fdt) + offset;
-}
-
-static inline void *_fdt_offset_ptr_w(void *fdt, int offset)
-{
-	return (void *)(uintptr_t)_fdt_offset_ptr(fdt, offset);
-}
-
-static inline const struct fdt_reserve_entry *_fdt_mem_rsv(const void *fdt, int n)
-{
-	const struct fdt_reserve_entry *rsv_table =
-		(const struct fdt_reserve_entry *)
-		((const char *)fdt + fdt_off_mem_rsvmap(fdt));
-
-	return rsv_table + n;
-}
-static inline struct fdt_reserve_entry *_fdt_mem_rsv_w(void *fdt, int n)
-{
-	return (void *)(uintptr_t)_fdt_mem_rsv(fdt, n);
-}
-
-#define FDT_SW_MAGIC		(~FDT_MAGIC)
-
-#endif /* _LIBFDT_INTERNAL_H */
+#include "../../scripts/dtc/libfdt/libfdt_internal.h"
diff --git a/lib/lz4_wrapper.c b/lib/lz4_wrapper.c
index 6dc8b764b3..77f2b004dd 100644
--- a/lib/lz4_wrapper.c
+++ b/lib/lz4_wrapper.c
@@ -6,12 +6,23 @@
 
 #include <common.h>
 #include <compiler.h>
+#include <misc.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
+#include <asm/unaligned.h>
 
-static u16 LZ4_readLE16(const void *src) { return le16_to_cpu(*(u16 *)src); }
-static void LZ4_copy4(void *dst, const void *src) { *(u32 *)dst = *(u32 *)src; }
-static void LZ4_copy8(void *dst, const void *src) { *(u64 *)dst = *(u64 *)src; }
+static u16 LZ4_readLE16(const void *src)
+{
+	return get_unaligned_le16(src);
+}
+static void LZ4_copy4(void *dst, const void *src)
+{
+	put_unaligned(get_unaligned((const u32 *)src), (u32 *)dst);
+}
+static void LZ4_copy8(void *dst, const void *src)
+{
+	put_unaligned(get_unaligned((const u64 *)src), (u64 *)dst);
+}
 
 typedef  uint8_t BYTE;
 typedef uint16_t U16;
@@ -24,44 +35,19 @@ typedef uint64_t U64;
 /* Unaltered (except removing unrelated code) from github.com/Cyan4973/lz4. */
 #include "lz4.c"	/* #include for inlining, do not link! */
 
-#define LZ4F_MAGIC 0x184D2204
-
-struct lz4_frame_header {
-	u32 magic;
-	union {
-		u8 flags;
-		struct {
-			u8 reserved0:2;
-			u8 has_content_checksum:1;
-			u8 has_content_size:1;
-			u8 has_block_checksum:1;
-			u8 independent_blocks:1;
-			u8 version:2;
-		};
-	};
-	union {
-		u8 block_descriptor;
-		struct {
-			u8 reserved1:4;
-			u8 max_block_size:3;
-			u8 reserved2:1;
-		};
-	};
-	/* + u64 content_size iff has_content_size is set */
-	/* + u8 header_checksum */
-} __packed;
-
-struct lz4_block_header {
-	union {
-		u32 raw;
-		struct {
-			u32 size:31;
-			u32 not_compressed:1;
-		};
-	};
-	/* + size bytes of data */
-	/* + u32 block_checksum iff has_block_checksum is set */
-} __packed;
+bool lz4_is_valid_header(const unsigned char *h)
+{
+	const struct lz4_frame_header *hdr  = (const struct lz4_frame_header *)h;
+	/* We assume there's always only a single, standard frame. */
+	if (le32_to_cpu(hdr->magic) != LZ4F_MAGIC || hdr->version != 1)
+		return false;        /* unknown format */
+	if (hdr->reserved0 || hdr->reserved1 || hdr->reserved2)
+		return false; /* reserved must be zero */
+	if (!hdr->independent_blocks)
+		return false; /* we can't support this yet */
+
+	return true;
+}
 
 int ulz4fn(const void *src, size_t srcn, void *dst, size_t *dstn)
 {
@@ -72,6 +58,18 @@ int ulz4fn(const void *src, size_t srcn, void *dst, size_t *dstn)
 	int ret;
 	*dstn = 0;
 
+#if defined(CONFIG_MISC_DECOMPRESS) && !defined(CONFIG_SPL_BUILD)
+	u64 len;
+
+	ret = misc_decompress_process((ulong)dst, (ulong)src, (ulong)srcn,
+				      DECOM_LZ4, false, &len, 0);
+	if (!ret) {
+		*dstn = len;
+		return 0;
+	}
+
+	printf("hw ulz4fn failed(%d), fallback to soft ulz4fn\n", ret);
+#endif
 	{ /* With in-place decompression the header may become invalid later. */
 		const struct lz4_frame_header *h = in;
 
diff --git a/lib/lzma/LzmaTools.c b/lib/lzma/LzmaTools.c
index f88629b74f..02814cee12 100644
--- a/lib/lzma/LzmaTools.c
+++ b/lib/lzma/LzmaTools.c
@@ -22,7 +22,7 @@
 #include <common.h>
 #include <watchdog.h>
 
-#ifdef CONFIG_LZMA
+#if CONFIG_IS_ENABLED(LZMA)
 
 #define LZMA_PROPERTIES_OFFSET 0
 #define LZMA_SIZE_OFFSET       LZMA_PROPS_SIZE
@@ -37,6 +37,16 @@
 static void *SzAlloc(void *p, size_t size) { return malloc(size); }
 static void SzFree(void *p, void *address) { free(address); }
 
+int lzma_is_valid(const unsigned char *buf)
+{
+	if (buf[0] != 0x5d || buf[1] || buf[2])
+		return 0;
+	if (buf[12] && buf[12] != 0xff)
+		return 0;
+
+	return 1;
+}
+
 int lzmaBuffToBuffDecompress (unsigned char *outStream, SizeT *uncompressedSize,
                   unsigned char *inStream,  SizeT  length)
 {
diff --git a/lib/lzma/LzmaTools.h b/lib/lzma/LzmaTools.h
index f8bdd1ffda..a88bfc29b5 100644
--- a/lib/lzma/LzmaTools.h
+++ b/lib/lzma/LzmaTools.h
@@ -14,6 +14,7 @@
 
 #include <lzma/LzmaTypes.h>
 
+extern int lzma_is_valid(const unsigned char *buf);
 extern int lzmaBuffToBuffDecompress (unsigned char *outStream, SizeT *uncompressedSize,
 			      unsigned char *inStream,  SizeT  length);
 #endif
diff --git a/lib/lzo/lzo1x_decompress.c b/lib/lzo/lzo1x_decompress.c
index ccc90b8ee5..65fef0b0eb 100644
--- a/lib/lzo/lzo1x_decompress.c
+++ b/lib/lzo/lzo1x_decompress.c
@@ -30,16 +30,29 @@ static const unsigned char lzop_magic[] = {
 
 #define HEADER_HAS_FILTER	0x00000800L
 
-static inline const unsigned char *parse_header(const unsigned char *src)
+
+bool lzop_is_valid_header(const unsigned char *src)
 {
-	u16 version;
 	int i;
-
 	/* read magic: 9 first bytes */
 	for (i = 0; i < ARRAY_SIZE(lzop_magic); i++) {
 		if (*src++ != lzop_magic[i])
-			return NULL;
+			return false;
 	}
+	return true;
+}
+
+static inline const unsigned char *parse_header(const unsigned char *src)
+{
+	u16 version;
+	int i;
+
+	if (!lzop_is_valid_header(src))
+		return NULL;
+
+	/* skip header */
+	src += 9;
+
 	/* get version (2bytes), skip library version (2),
 	 * 'need to be extracted' version (2) and
 	 * method (1) */
diff --git a/lib/of_live.c b/lib/of_live.c
index f351483387..148865c967 100644
--- a/lib/of_live.c
+++ b/lib/of_live.c
@@ -10,7 +10,7 @@
  */
 
 #include <common.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include <of_live.h>
 #include <malloc.h>
 #include <dm/of_access.h>
diff --git a/lib/rsa/Kconfig b/lib/rsa/Kconfig
index fde1ac108d..f0556c44df 100644
--- a/lib/rsa/Kconfig
+++ b/lib/rsa/Kconfig
@@ -34,4 +34,22 @@ config RSA_FREESCALE_EXP
 	Enables driver for RSA modular exponentiation using Freescale cryptographic
 	accelerator - CAAM.
 
+config RSA_N_SIZE
+	hex "Define the RSA N size"
+	help
+	  The value is depended on different platforms. The RV1126/RV1109 is set to 0x100.
+	  The RK3568/RK3566 is set to 0x200.
+
+config RSA_E_SIZE
+	hex "Define the RSA E size"
+	help
+	  The value is depended on different platforms. The RV1126/RV1109 is set to 0x100.
+	  The RK3568/RK3566 is set to 0x10.
+
+config RSA_C_SIZE
+	hex "Define the RSA C size"
+	help
+	  The value is depended on different platforms.The RV1126/RV1109 is set to 0x14.
+	  The RK3568/RK3566 is set to 0x20.
+
 endif
diff --git a/lib/rsa/rsa-checksum.c b/lib/rsa/rsa-checksum.c
index 2bf28e2daf..c8246ef0a1 100644
--- a/lib/rsa/rsa-checksum.c
+++ b/lib/rsa/rsa-checksum.c
@@ -6,6 +6,7 @@
 
 #ifndef USE_HOSTCC
 #include <common.h>
+#include <crypto.h>
 #include <fdtdec.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
@@ -16,9 +17,9 @@
 #endif
 #include <u-boot/rsa.h>
 
-int hash_calculate(const char *name,
-		    const struct image_region region[],
-		    int region_count, uint8_t *checksum)
+int rsa_hash_calculate(const char *name,
+		       const struct image_region region[],
+		       int region_count, uint8_t *checksum)
 {
 	struct hash_algo *algo;
 	int ret = 0;
@@ -50,3 +51,50 @@ int hash_calculate(const char *name,
 
 	return 0;
 }
+
+#if !defined(USE_HOSTCC)
+#if CONFIG_IS_ENABLED(FIT_HW_CRYPTO)
+int hw_rsa_hash_calculate(const char *name,
+			  const struct image_region region[],
+			  int region_count, uint8_t *checksum)
+
+{
+	struct udevice *dev;
+	sha_context ctx;
+
+	if (!name)
+		return -EINVAL;
+
+	if (!strcmp(name, "sha1"))
+		ctx.algo = CRYPTO_SHA1;
+	else if (!strcmp(name, "sha256"))
+		ctx.algo = CRYPTO_SHA256;
+	else
+		return -EPERM;
+
+	dev = crypto_get_device(ctx.algo);
+	if (!dev) {
+		printf("No crypto device for expected capability\n");
+		return -ENODEV;
+	}
+
+	return crypto_sha_regions_csum(dev, &ctx, region,
+				       region_count, checksum);
+}
+#endif
+#endif
+
+int hash_calculate(const char *name,
+		   const struct image_region region[],
+		   int region_count, uint8_t *checksum)
+{
+#if defined(USE_HOSTCC)
+	return rsa_hash_calculate(name, region, region_count, checksum);
+#else
+#if !CONFIG_IS_ENABLED(FIT_HW_CRYPTO)
+	return rsa_hash_calculate(name, region, region_count, checksum);
+#else
+	return hw_rsa_hash_calculate(name, region, region_count, checksum);
+#endif
+#endif
+}
diff --git a/lib/rsa/rsa-mod-exp.c b/lib/rsa/rsa-mod-exp.c
index 9d78aa1ead..14b6a399ac 100644
--- a/lib/rsa/rsa-mod-exp.c
+++ b/lib/rsa/rsa-mod-exp.c
@@ -250,6 +250,11 @@ static void rsa_convert_big_endian(uint32_t *dst, const uint32_t *src, int len)
 int rsa_mod_exp_sw(const uint8_t *sig, uint32_t sig_len,
 		struct key_prop *prop, uint8_t *out)
 {
+#ifndef USE_HOSTCC
+	__cacheline_aligned uint64_t tmp;
+#else
+	uint64_t tmp;
+#endif
 	struct rsa_public_key key;
 	int ret;
 
@@ -260,11 +265,19 @@ int rsa_mod_exp_sw(const uint8_t *sig, uint32_t sig_len,
 	key.n0inv = prop->n0inv;
 	key.len = prop->num_bits;
 
-	if (!prop->public_exponent)
+	if (!prop->public_exponent) {
 		key.exponent = RSA_DEFAULT_PUBEXP;
-	else
-		key.exponent =
-			fdt64_to_cpu(*((uint64_t *)(prop->public_exponent)));
+	} else {
+		/*
+		 * it seems fdt64_to_cpu() input param address must be 8-bytes
+		 * align, otherwise it brings a data-abort. No root cause was
+		 * found.
+		 *
+		 * workaround it this a tmp value.
+		 */
+		memcpy((void *)&tmp, prop->public_exponent, sizeof(uint64_t));
+		key.exponent = fdt64_to_cpu(tmp);
+	}
 
 	if (!key.len || !prop->modulus || !prop->rr) {
 		debug("%s: Missing RSA key info", __func__);
diff --git a/lib/rsa/rsa-sign.c b/lib/rsa/rsa-sign.c
index 1da4ef7fff..fed64d512e 100644
--- a/lib/rsa/rsa-sign.c
+++ b/lib/rsa/rsa-sign.c
@@ -9,6 +9,7 @@
 #include <string.h>
 #include <image.h>
 #include <time.h>
+#include <generated/autoconf.h>
 #include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/pem.h>
@@ -383,13 +384,42 @@ static void rsa_engine_remove(ENGINE *e)
 	}
 }
 
-static int rsa_sign_with_key(RSA *rsa, struct checksum_algo *checksum_algo,
+/*
+ * With this data2sign.bin, we can provide it to who real holds the RAS-private
+ * key to sign current fit image. Then we replace the signature in fit image
+ * with a valid one.
+ */
+static int gen_data2sign(const struct image_region region[], int region_count)
+{
+	char *file = "data2sign.bin";
+	FILE *fd;
+	int i;
+
+	fd = fopen(file, "wb");
+	if (!fd) {
+		fprintf(stderr, "Failed to create %s: %s\n",
+			file, strerror(errno));
+		return -ENOENT;
+	}
+
+	for (i = 0; i < region_count; i++)
+		fwrite(region[i].data, region[i].size, 1, fd);
+
+	fclose(fd);
+
+	return 0;
+}
+
+static int rsa_sign_with_key(RSA *rsa, struct padding_algo *padding_algo,
+			     struct checksum_algo *checksum_algo,
 		const struct image_region region[], int region_count,
 		uint8_t **sigp, uint *sig_size)
 {
 	EVP_PKEY *key;
+	EVP_PKEY_CTX *ckey;
 	EVP_MD_CTX *context;
-	int size, ret = 0;
+	int ret = 0;
+	size_t size;
 	uint8_t *sig;
 	int i;
 
@@ -405,7 +435,7 @@ static int rsa_sign_with_key(RSA *rsa, struct checksum_algo *checksum_algo,
 	size = EVP_PKEY_size(key);
 	sig = malloc(size);
 	if (!sig) {
-		fprintf(stderr, "Out of memory for signature (%d bytes)\n",
+		fprintf(stderr, "Out of memory for signature (%zu bytes)\n",
 			size);
 		ret = -ENOMEM;
 		goto err_alloc;
@@ -417,23 +447,45 @@ static int rsa_sign_with_key(RSA *rsa, struct checksum_algo *checksum_algo,
 		goto err_create;
 	}
 	EVP_MD_CTX_init(context);
-	if (!EVP_SignInit(context, checksum_algo->calculate_sign())) {
+
+	ckey = EVP_PKEY_CTX_new(key, NULL);
+	if (!ckey) {
+		ret = rsa_err("EVP key context creation failed");
+		goto err_create;
+	}
+
+	if (EVP_DigestSignInit(context, &ckey,
+			       checksum_algo->calculate_sign(),
+			       NULL, key) <= 0) {
 		ret = rsa_err("Signer setup failed");
 		goto err_sign;
 	}
 
+#ifdef CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT
+	if (padding_algo && !strcmp(padding_algo->name, "pss")) {
+		if (EVP_PKEY_CTX_set_rsa_padding(ckey,
+						 RSA_PKCS1_PSS_PADDING) <= 0) {
+			ret = rsa_err("Signer padding setup failed");
+			goto err_sign;
+		}
+	}
+#endif /* CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT */
+
 	for (i = 0; i < region_count; i++) {
-		if (!EVP_SignUpdate(context, region[i].data, region[i].size)) {
+		if (!EVP_DigestSignUpdate(context, region[i].data,
+					  region[i].size)) {
 			ret = rsa_err("Signing data failed");
 			goto err_sign;
 		}
 	}
 
-	if (!EVP_SignFinal(context, sig, sig_size, key)) {
+	if (!EVP_DigestSignFinal(context, sig, &size)) {
 		ret = rsa_err("Could not obtain signature");
 		goto err_sign;
 	}
-	#if OPENSSL_VERSION_NUMBER < 0x10100000L
+
+	#if OPENSSL_VERSION_NUMBER < 0x10100000L || \
+		(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x02070000fL)
 		EVP_MD_CTX_cleanup(context);
 	#else
 		EVP_MD_CTX_reset(context);
@@ -441,10 +493,12 @@ static int rsa_sign_with_key(RSA *rsa, struct checksum_algo *checksum_algo,
 	EVP_MD_CTX_destroy(context);
 	EVP_PKEY_free(key);
 
-	debug("Got signature: %d bytes, expected %d\n", *sig_size, size);
+	debug("Got signature: %d bytes, expected %zu\n", *sig_size, size);
 	*sigp = sig;
 	*sig_size = size;
 
+	gen_data2sign(region, region_count);
+
 	return 0;
 
 err_sign:
@@ -478,7 +532,7 @@ int rsa_sign(struct image_sign_info *info,
 	ret = rsa_get_priv_key(info->keydir, info->keyname, e, &rsa);
 	if (ret)
 		goto err_priv;
-	ret = rsa_sign_with_key(rsa, info->checksum, region,
+	ret = rsa_sign_with_key(rsa, info->padding, info->checksum, region,
 				region_count, sigp, sig_len);
 	if (ret)
 		goto err_sign;
@@ -553,11 +607,12 @@ cleanup:
  * rsa_get_params(): - Get the important parameters of an RSA public key
  */
 int rsa_get_params(RSA *key, uint64_t *exponent, uint32_t *n0_invp,
-		   BIGNUM **modulusp, BIGNUM **r_squaredp)
+		   BIGNUM **modulusp, BIGNUM **exponent_BN, BIGNUM **r_squaredp,
+		   BIGNUM **c_factorp, BIGNUM **np_factorp)
 {
-	BIGNUM *big1, *big2, *big32, *big2_32;
-	BIGNUM *n, *r, *r_squared, *tmp;
-	const BIGNUM *key_n;
+	BIGNUM *big1, *big2, *big32, *big2_32, *big4100, *big2180;
+	BIGNUM *n, *e, *r, *r_squared, *tmp, *c_factor, *np_factor;
+	const BIGNUM *key_n, *key_e;
 	BN_CTX *bn_ctx = BN_CTX_new();
 	int ret = 0;
 
@@ -565,13 +620,20 @@ int rsa_get_params(RSA *key, uint64_t *exponent, uint32_t *n0_invp,
 	big1 = BN_new();
 	big2 = BN_new();
 	big32 = BN_new();
+	big4100 = BN_new();
+	big2180 = BN_new();
+
 	r = BN_new();
 	r_squared = BN_new();
+	c_factor = BN_new();
+	np_factor = BN_new();
 	tmp = BN_new();
 	big2_32 = BN_new();
 	n = BN_new();
-	if (!big1 || !big2 || !big32 || !r || !r_squared || !tmp || !big2_32 ||
-	    !n) {
+	e = BN_new();
+	if (!big1 || !big2 || !big32 || !big4100 || !big2180 || !r ||
+	    !r_squared || !tmp || !big2_32 || !n || !e ||
+	    !c_factor || !np_factor) {
 		fprintf(stderr, "Out of memory (bignum)\n");
 		return -ENOMEM;
 	}
@@ -579,9 +641,11 @@ int rsa_get_params(RSA *key, uint64_t *exponent, uint32_t *n0_invp,
 	if (0 != rsa_get_exponent(key, exponent))
 		ret = -1;
 
-	RSA_get0_key(key, &key_n, NULL, NULL);
-	if (!BN_copy(n, key_n) || !BN_set_word(big1, 1L) ||
-	    !BN_set_word(big2, 2L) || !BN_set_word(big32, 32L))
+	RSA_get0_key(key, &key_n, &key_e, NULL);
+	if (!BN_copy(n, key_n) || !BN_copy(e, key_e) ||
+	    !BN_set_word(big1, 1L) ||
+	    !BN_set_word(big2, 2L) || !BN_set_word(big32, 32L) ||
+	    !BN_set_word(big4100, 4100L) || !BN_set_word(big2180, 2180L))
 		ret = -1;
 
 	/* big2_32 = 2^32 */
@@ -605,12 +669,27 @@ int rsa_get_params(RSA *key, uint64_t *exponent, uint32_t *n0_invp,
 	    !BN_mod(r_squared, tmp, n, bn_ctx))
 		ret = -1;
 
+	/* Calculate c_factor = 2^4100 mod n */
+	if (!BN_exp(tmp, big2, big4100, bn_ctx) ||
+	    !BN_mod(c_factor, tmp, n, bn_ctx))
+		ret = -1;
+
+	/* Calculate np_factor = 2^2180 div n */
+	if (!BN_exp(tmp, big2, big2180, bn_ctx) ||
+	    !BN_div(np_factor, NULL, tmp, n, bn_ctx))
+		ret = -1;
+
 	*modulusp = n;
+	*exponent_BN = e;
 	*r_squaredp = r_squared;
+	*c_factorp = c_factor;
+	*np_factorp = np_factor;
 
 	BN_free(big1);
 	BN_free(big2);
 	BN_free(big32);
+	BN_free(big4100);
+	BN_free(big2180);
 	BN_free(r);
 	BN_free(tmp);
 	BN_free(big2_32);
@@ -622,6 +701,88 @@ int rsa_get_params(RSA *key, uint64_t *exponent, uint32_t *n0_invp,
 	return ret;
 }
 
+static void rsa_convert_big_endian(uint32_t *dst, const uint32_t *src,
+				   int total_len, int convert_len)
+{
+	int total_wd, convert_wd, i;
+
+	if (total_len < convert_len)
+		convert_len = total_len;
+
+	total_wd = total_len / sizeof(uint32_t);
+	convert_wd = convert_len / sizeof(uint32_t);
+	for (i = 0; i < convert_wd; i++)
+		dst[i] = fdt32_to_cpu(src[total_wd - 1 - i]);
+}
+
+static int rsa_set_key_hash(void *keydest, int key_node,
+			    int key_len, const char *csum_algo)
+{
+	const void *rsa_n, *rsa_e, *rsa_c, *rsa_np;
+	void *n, *e, *c, *np;
+	uint8_t value[FIT_MAX_HASH_LEN];
+	char hash_c[] = "hash@c";
+	char hash_np[] = "hash@np";
+	char *rsa_key;
+	int hash_node;
+	int value_len;
+	int ret = -ENOSPC;
+
+	rsa_key = calloc(key_len * 3, sizeof(char));
+	if (!rsa_key)
+		return -ENOSPC;
+
+	rsa_n = fdt_getprop(keydest, key_node, "rsa,modulus", NULL);
+	rsa_e = fdt_getprop(keydest, key_node, "rsa,exponent-BN", NULL);
+	rsa_c = fdt_getprop(keydest, key_node, "rsa,c", NULL);
+	rsa_np = fdt_getprop(keydest, key_node, "rsa,np", NULL);
+	if (!rsa_c || !rsa_np || !rsa_n || !rsa_e)
+		goto err_nospc;
+
+	n = rsa_key;
+	e = rsa_key + CONFIG_RSA_N_SIZE;
+	rsa_convert_big_endian(n, rsa_n, key_len, CONFIG_RSA_N_SIZE);
+	rsa_convert_big_endian(e, rsa_e, key_len, CONFIG_RSA_E_SIZE);
+
+	/* hash@c node: n, e, c */
+	c = rsa_key + CONFIG_RSA_N_SIZE + CONFIG_RSA_E_SIZE;
+	rsa_convert_big_endian(c, rsa_c, key_len, CONFIG_RSA_C_SIZE);
+	hash_node = fdt_add_subnode(keydest, key_node, hash_c);
+	if (hash_node < 0)
+		goto err_nospc;
+	ret = calculate_hash(rsa_key, key_len * 3, csum_algo, value, &value_len);
+	if (ret)
+		goto err_nospc;
+	ret = fdt_setprop(keydest, hash_node, FIT_VALUE_PROP, value, value_len);
+	if (ret)
+		goto err_nospc;
+	ret = fdt_setprop_string(keydest, hash_node, FIT_ALGO_PROP, csum_algo);
+	if (ret < 0)
+		goto err_nospc;
+
+	/* hash@np node: n, e, np */
+	np = rsa_key + CONFIG_RSA_N_SIZE + CONFIG_RSA_E_SIZE;
+	rsa_convert_big_endian(np, rsa_np, key_len, CONFIG_RSA_C_SIZE);
+	hash_node = fdt_add_subnode(keydest, key_node, hash_np);
+	if (hash_node < 0)
+		goto err_nospc;
+
+	ret = calculate_hash(rsa_key, CONFIG_RSA_N_SIZE + CONFIG_RSA_E_SIZE + CONFIG_RSA_C_SIZE,
+			     csum_algo, value, &value_len);
+	if (ret)
+		goto err_nospc;
+	ret = fdt_setprop(keydest, hash_node, FIT_VALUE_PROP, value, value_len);
+	if (ret < 0)
+		goto err_nospc;
+	ret = fdt_setprop_string(keydest, hash_node, FIT_ALGO_PROP, csum_algo);
+
+err_nospc:
+	if (rsa_key)
+		free(rsa_key);
+
+	return ret ? -ENOSPC : 0;
+}
+
 static int fdt_add_bignum(void *blob, int noffset, const char *prop_name,
 			  BIGNUM *num, int num_bits)
 {
@@ -681,7 +842,7 @@ static int fdt_add_bignum(void *blob, int noffset, const char *prop_name,
 
 int rsa_add_verify_data(struct image_sign_info *info, void *keydest)
 {
-	BIGNUM *modulus, *r_squared;
+	BIGNUM *modulus, *exponent_BN, *r_squared, *c_factor, *np_factor;
 	uint64_t exponent;
 	uint32_t n0_inv;
 	int parent, node;
@@ -700,7 +861,8 @@ int rsa_add_verify_data(struct image_sign_info *info, void *keydest)
 	ret = rsa_get_pub_key(info->keydir, info->keyname, e, &rsa);
 	if (ret)
 		goto err_get_pub_key;
-	ret = rsa_get_params(rsa, &exponent, &n0_inv, &modulus, &r_squared);
+	ret = rsa_get_params(rsa, &exponent, &n0_inv, &modulus,
+			     &exponent_BN, &r_squared, &c_factor, &np_factor);
 	if (ret)
 		goto err_get_params;
 	bits = BN_num_bits(modulus);
@@ -747,6 +909,10 @@ int rsa_add_verify_data(struct image_sign_info *info, void *keydest)
 	if (!ret) {
 		ret = fdt_setprop_u64(keydest, node, "rsa,exponent", exponent);
 	}
+	if (!ret) {
+		ret = fdt_add_bignum(keydest, node, "rsa,exponent-BN",
+				     exponent_BN, bits);
+	}
 	if (!ret) {
 		ret = fdt_add_bignum(keydest, node, "rsa,modulus", modulus,
 				     bits);
@@ -755,6 +921,14 @@ int rsa_add_verify_data(struct image_sign_info *info, void *keydest)
 		ret = fdt_add_bignum(keydest, node, "rsa,r-squared", r_squared,
 				     bits);
 	}
+	if (!ret) {
+		ret = fdt_add_bignum(keydest, node, "rsa,c", c_factor,
+				     bits);
+	}
+	if (!ret) {
+		ret = fdt_add_bignum(keydest, node, "rsa,np", np_factor,
+				     bits);
+	}
 	if (!ret) {
 		ret = fdt_setprop_string(keydest, node, FIT_ALGO_PROP,
 					 info->name);
@@ -763,6 +937,10 @@ int rsa_add_verify_data(struct image_sign_info *info, void *keydest)
 		ret = fdt_setprop_string(keydest, node, "required",
 					 info->require_keys);
 	}
+	if (!ret) {
+		ret = rsa_set_key_hash(keydest, node, info->crypto->key_len,
+				       info->checksum->name);
+	}
 done:
 	BN_free(modulus);
 	BN_free(r_squared);
diff --git a/lib/rsa/rsa-verify.c b/lib/rsa/rsa-verify.c
index 0d548f8b8f..f088b27860 100644
--- a/lib/rsa/rsa-verify.c
+++ b/lib/rsa/rsa-verify.c
@@ -6,13 +6,16 @@
 
 #ifndef USE_HOSTCC
 #include <common.h>
+#include <crypto.h>
 #include <fdtdec.h>
+#include <misc.h>
 #include <asm/types.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
 #include <asm/types.h>
 #include <asm/unaligned.h>
 #include <dm.h>
+#include <asm/arch-rockchip/rk_atags.h>
 #else
 #include "fdt_host.h"
 #include "mkimage.h"
@@ -58,31 +61,333 @@ static int rsa_verify_padding(const uint8_t *msg, const int pad_len,
 	return ret;
 }
 
+#if !defined(USE_HOSTCC)
+#if CONFIG_IS_ENABLED(FIT_HW_CRYPTO)
+static void rsa_convert_big_endian(uint32_t *dst, const uint32_t *src,
+				   int total_len, int convert_len)
+{
+	int total_wd, convert_wd, i;
+
+	if (total_len < convert_len)
+		convert_len = total_len;
+
+	total_wd = total_len / sizeof(uint32_t);
+	convert_wd = convert_len / sizeof(uint32_t);
+	for (i = 0; i < convert_wd; i++)
+		dst[i] = fdt32_to_cpu(src[total_wd - 1 - i]);
+}
+
+static int rsa_mod_exp_hw(struct key_prop *prop, const uint8_t *sig,
+			  const uint32_t sig_len, const uint32_t key_len,
+			  uint8_t *output)
+{
+	struct udevice *dev;
+	uint8_t sig_reverse[sig_len];
+	uint8_t buf[sig_len];
+	rsa_key rsa_key;
+	int i, ret;
+
+	if (key_len != RSA2048_BYTES)
+		return -EINVAL;
+
+	rsa_key.algo = CRYPTO_RSA2048;
+	rsa_key.n = malloc(key_len);
+	rsa_key.e = malloc(key_len);
+	rsa_key.c = malloc(key_len);
+	if (!rsa_key.n || !rsa_key.e || !rsa_key.c)
+		return -ENOMEM;
+
+	rsa_convert_big_endian(rsa_key.n, (uint32_t *)prop->modulus,
+			       key_len, key_len);
+	rsa_convert_big_endian(rsa_key.e, (uint32_t *)prop->public_exponent_BN,
+			       key_len, key_len);
+#ifdef CONFIG_ROCKCHIP_CRYPTO_V1
+	rsa_convert_big_endian(rsa_key.c, (uint32_t *)prop->factor_c,
+			       key_len, key_len);
+#else
+	rsa_convert_big_endian(rsa_key.c, (uint32_t *)prop->factor_np,
+			       key_len, key_len);
+#endif
+#if defined(CONFIG_ROCKCHIP_PRELOADER_ATAGS) && defined(CONFIG_SPL_BUILD)
+	char *rsa_key_data = malloc(3 * key_len);
+	int flag = 0;
+
+	if (rsa_key_data) {
+		memcpy(rsa_key_data, rsa_key.n, key_len);
+		memcpy(rsa_key_data + key_len, rsa_key.e, key_len);
+		memcpy(rsa_key_data + 2 * key_len, rsa_key.c, key_len);
+		if (fit_board_verify_required_sigs())
+			flag = PUBKEY_FUSE_PROGRAMMED;
+
+		if (atags_set_pub_key(rsa_key_data, 3 * key_len, flag))
+			printf("Send public key through atags fail.");
+	}
+#endif
+	for (i = 0; i < sig_len; i++)
+		sig_reverse[sig_len-1-i] = sig[i];
+
+	dev = crypto_get_device(rsa_key.algo);
+	if (!dev) {
+		printf("No crypto device for expected RSA\n");
+		return -ENODEV;
+	}
+
+	ret = crypto_rsa_verify(dev, &rsa_key, (u8 *)sig_reverse, buf);
+	if (ret)
+		goto out;
+
+	for (i = 0; i < sig_len; i++)
+		sig_reverse[sig_len-1-i] = buf[i];
+
+	memcpy(output, sig_reverse, sig_len);
+out:
+	free(rsa_key.n);
+	free(rsa_key.e);
+	free(rsa_key.c);
+
+	return ret;
+}
+#endif
+#endif
+
+int padding_pkcs_15_verify(struct image_sign_info *info,
+			   uint8_t *msg, int msg_len,
+			   const uint8_t *hash, int hash_len)
+{
+	struct checksum_algo *checksum = info->checksum;
+	int ret, pad_len = msg_len - checksum->checksum_len;
+
+	/* Check pkcs1.5 padding bytes. */
+	ret = rsa_verify_padding(msg, pad_len, checksum);
+	if (ret) {
+		debug("In RSAVerify(): Padding check failed!\n");
+		return -EINVAL;
+	}
+
+	/* Check hash. */
+	if (memcmp((uint8_t *)msg + pad_len, hash, msg_len - pad_len)) {
+		debug("In RSAVerify(): Hash check failed!\n");
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT
+static void u32_i2osp(uint32_t val, uint8_t *buf)
+{
+	buf[0] = (uint8_t)((val >> 24) & 0xff);
+	buf[1] = (uint8_t)((val >> 16) & 0xff);
+	buf[2] = (uint8_t)((val >>  8) & 0xff);
+	buf[3] = (uint8_t)((val >>  0) & 0xff);
+}
+
+/**
+ * mask_generation_function1() - generate an octet string
+ *
+ * Generate an octet string used to check rsa signature.
+ * It use an input octet string and a hash function.
+ *
+ * @checksum:	A Hash function
+ * @seed:	Specifies an input variable octet string
+ * @seed_len:	Size of the input octet string
+ * @output:	Specifies the output octet string
+ * @output_len:	Size of the output octet string
+ * @return 0 if the octet string was correctly generated, others on error
+ */
+static int mask_generation_function1(struct checksum_algo *checksum,
+				     uint8_t *seed, int seed_len,
+				     uint8_t *output, int output_len)
+{
+	struct image_region region[2];
+	int ret = 0, i, i_output = 0, region_count = 2;
+	uint32_t counter = 0;
+	uint8_t buf_counter[4], *tmp;
+	int hash_len = checksum->checksum_len;
+
+	memset(output, 0, output_len);
+
+	region[0].data = seed;
+	region[0].size = seed_len;
+	region[1].data = &buf_counter[0];
+	region[1].size = 4;
+
+	tmp = malloc(hash_len);
+	if (!tmp) {
+		debug("%s: can't allocate array tmp\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	while (i_output < output_len) {
+		u32_i2osp(counter, &buf_counter[0]);
+
+		ret = checksum->calculate(checksum->name,
+					  region, region_count,
+					  tmp);
+		if (ret < 0) {
+			debug("%s: Error in checksum calculation\n", __func__);
+			goto out;
+		}
+
+		i = 0;
+		while ((i_output < output_len) && (i < hash_len)) {
+			output[i_output] = tmp[i];
+			i_output++;
+			i++;
+		}
+
+		counter++;
+	}
+
+out:
+	free(tmp);
+
+	return ret;
+}
+
+static int compute_hash_prime(struct checksum_algo *checksum,
+			      uint8_t *pad, int pad_len,
+			      uint8_t *hash, int hash_len,
+			      uint8_t *salt, int salt_len,
+			      uint8_t *hprime)
+{
+	struct image_region region[3];
+	int ret, region_count = 3;
+
+	region[0].data = pad;
+	region[0].size = pad_len;
+	region[1].data = hash;
+	region[1].size = hash_len;
+	region[2].data = salt;
+	region[2].size = salt_len;
+
+	ret = checksum->calculate(checksum->name, region, region_count, hprime);
+	if (ret < 0) {
+		debug("%s: Error in checksum calculation\n", __func__);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+int padding_pss_verify(struct image_sign_info *info,
+		       uint8_t *msg, int msg_len,
+		       const uint8_t *hash, int hash_len)
+{
+	uint8_t *masked_db = NULL;
+	int masked_db_len = msg_len - hash_len - 1;
+	uint8_t *h = NULL, *hprime = NULL;
+	int h_len = hash_len;
+	uint8_t *db_mask = NULL;
+	int db_mask_len = masked_db_len;
+	uint8_t *db = NULL, *salt = NULL;
+	int db_len = masked_db_len, salt_len = msg_len - hash_len - 2;
+	uint8_t pad_zero[8] = { 0 };
+	int ret, i, leftmost_bits = 1;
+	uint8_t leftmost_mask;
+	struct checksum_algo *checksum = info->checksum;
+
+	/* first, allocate everything */
+	masked_db = malloc(masked_db_len);
+	h = malloc(h_len);
+	db_mask = malloc(db_mask_len);
+	db = malloc(db_len);
+	salt = malloc(salt_len);
+	hprime = malloc(hash_len);
+	if (!masked_db || !h || !db_mask || !db || !salt || !hprime) {
+		printf("%s: can't allocate some buffer\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* step 4: check if the last byte is 0xbc */
+	if (msg[msg_len - 1] != 0xbc) {
+		printf("%s: invalid pss padding (0xbc is missing)\n", __func__);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* step 5 */
+	memcpy(masked_db, msg, masked_db_len);
+	memcpy(h, msg + masked_db_len, h_len);
+
+	/* step 6 */
+	leftmost_mask = (0xff >> (8 - leftmost_bits)) << (8 - leftmost_bits);
+	if (masked_db[0] & leftmost_mask) {
+		printf("%s: invalid pss padding ", __func__);
+		printf("(leftmost bit of maskedDB not zero)\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* step 7 */
+	mask_generation_function1(checksum, h, h_len, db_mask, db_mask_len);
+
+	/* step 8 */
+	for (i = 0; i < db_len; i++)
+		db[i] = masked_db[i] ^ db_mask[i];
+
+	/* step 9 */
+	db[0] &= 0xff >> leftmost_bits;
+
+	/* step 10 */
+	if (db[0] != 0x01) {
+		printf("%s: invalid pss padding ", __func__);
+		printf("(leftmost byte of db isn't 0x01)\n");
+		ret = EINVAL;
+		goto out;
+	}
+
+	/* step 11 */
+	memcpy(salt, &db[1], salt_len);
+
+	/* step 12 & 13 */
+	compute_hash_prime(checksum, pad_zero, 8,
+			   (uint8_t *)hash, hash_len,
+			   salt, salt_len, hprime);
+
+	/* step 14 */
+	ret = memcmp(h, hprime, hash_len);
+
+out:
+	free(hprime);
+	free(salt);
+	free(db);
+	free(db_mask);
+	free(h);
+	free(masked_db);
+
+	return ret;
+}
+#endif
+
 /**
  * rsa_verify_key() - Verify a signature against some data using RSA Key
  *
  * Verify a RSA PKCS1.5 signature against an expected hash using
  * the RSA Key properties in prop structure.
  *
+ * @info:	Specifies key and FIT information
  * @prop:	Specifies key
  * @sig:	Signature
  * @sig_len:	Number of bytes in signature
  * @hash:	Pointer to the expected hash
  * @key_len:	Number of bytes in rsa key
- * @algo:	Checksum algo structure having information on DER encoding etc.
  * @return 0 if verified, -ve on error
  */
-static int rsa_verify_key(struct key_prop *prop, const uint8_t *sig,
+static int rsa_verify_key(struct image_sign_info *info,
+			  struct key_prop *prop, const uint8_t *sig,
 			  const uint32_t sig_len, const uint8_t *hash,
-			  const uint32_t key_len, struct checksum_algo *algo)
+			  const uint32_t key_len)
 {
-	int pad_len;
 	int ret;
-#if !defined(USE_HOSTCC)
-	struct udevice *mod_exp_dev;
-#endif
+	struct checksum_algo *checksum = info->checksum;
+	struct padding_algo *padding = info->padding;
+	int hash_len = checksum->checksum_len;
 
-	if (!prop || !sig || !hash || !algo)
+	if (!prop || !sig || !hash || !checksum)
 		return -EIO;
 
 	if (sig_len != (prop->num_bits / 8)) {
@@ -90,7 +395,7 @@ static int rsa_verify_key(struct key_prop *prop, const uint8_t *sig,
 		return -EINVAL;
 	}
 
-	debug("Checksum algorithm: %s", algo->name);
+	debug("Checksum algorithm: %s", checksum->name);
 
 	/* Sanity check for stack size */
 	if (sig_len > RSA_MAX_SIG_BITS / 8) {
@@ -102,6 +407,11 @@ static int rsa_verify_key(struct key_prop *prop, const uint8_t *sig,
 	uint8_t buf[sig_len];
 
 #if !defined(USE_HOSTCC)
+#if CONFIG_IS_ENABLED(FIT_HW_CRYPTO)
+	ret = rsa_mod_exp_hw(prop, sig, sig_len, key_len, buf);
+#else
+	struct udevice *mod_exp_dev;
+
 	ret = uclass_get_device(UCLASS_MOD_EXP, 0, &mod_exp_dev);
 	if (ret) {
 		printf("RSA: Can't find Modular Exp implementation\n");
@@ -109,6 +419,7 @@ static int rsa_verify_key(struct key_prop *prop, const uint8_t *sig,
 	}
 
 	ret = rsa_mod_exp(mod_exp_dev, sig, sig_len, prop, buf);
+#endif
 #else
 	ret = rsa_mod_exp_sw(sig, sig_len, prop, buf);
 #endif
@@ -117,21 +428,68 @@ static int rsa_verify_key(struct key_prop *prop, const uint8_t *sig,
 		return ret;
 	}
 
-	pad_len = key_len - algo->checksum_len;
-
-	/* Check pkcs1.5 padding bytes. */
-	ret = rsa_verify_padding(buf, pad_len, algo);
+	ret = padding->verify(info, buf, key_len, hash, hash_len);
 	if (ret) {
-		debug("In RSAVerify(): Padding check failed!\n");
-		return -EINVAL;
+		debug("In RSAVerify(): padding check failed!\n");
+		return ret;
 	}
 
-	/* Check hash. */
-	if (memcmp((uint8_t *)buf + pad_len, hash, sig_len - pad_len)) {
-		debug("In RSAVerify(): Hash check failed!\n");
-		return -EACCES;
+	return 0;
+}
+
+static int rsa_get_key_prop(struct key_prop *prop, struct image_sign_info *info, int node)
+{
+	const void *blob = info->fdt_blob;
+	int length;
+	int hash_node;
+
+	if (node < 0) {
+		debug("%s: Skipping invalid node", __func__);
+		return -EBADF;
+	}
+
+	if (!prop) {
+		debug("%s: The prop is NULL", __func__);
+		return -EBADF;
 	}
 
+	prop->burn_key = fdtdec_get_int(blob, node, "burn-key-hash", 0);
+
+	prop->num_bits = fdtdec_get_int(blob, node, "rsa,num-bits", 0);
+
+	prop->n0inv = fdtdec_get_int(blob, node, "rsa,n0-inverse", 0);
+
+	prop->public_exponent = fdt_getprop(blob, node, "rsa,exponent", &length);
+	if (!prop->public_exponent || length < sizeof(uint64_t))
+		prop->public_exponent = NULL;
+
+	prop->exp_len = sizeof(uint64_t);
+	prop->modulus = fdt_getprop(blob, node, "rsa,modulus", NULL);
+	prop->public_exponent_BN = fdt_getprop(blob, node, "rsa,exponent-BN", NULL);
+	prop->rr = fdt_getprop(blob, node, "rsa,r-squared", NULL);
+#ifdef CONFIG_ROCKCHIP_CRYPTO_V1
+	hash_node = fdt_subnode_offset(blob, node, "hash@c");
+#else
+	hash_node = fdt_subnode_offset(blob, node, "hash@np");
+#endif
+	if (hash_node >= 0)
+		prop->hash = fdt_getprop(blob, hash_node, "value", NULL);
+
+	if (!prop->num_bits || !prop->modulus) {
+		debug("%s: Missing RSA key info", __func__);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_ROCKCHIP_CRYPTO_V1
+	prop->factor_c = fdt_getprop(blob, node, "rsa,c", NULL);
+	if (!prop.factor_c)
+		return -EFAULT;
+#else
+	prop->factor_np = fdt_getprop(blob, node, "rsa,np", NULL);
+	if (!prop->factor_np)
+		return -EFAULT;
+#endif
+
 	return 0;
 }
 
@@ -154,39 +512,13 @@ static int rsa_verify_with_keynode(struct image_sign_info *info,
 				   const void *hash, uint8_t *sig,
 				   uint sig_len, int node)
 {
-	const void *blob = info->fdt_blob;
 	struct key_prop prop;
-	int length;
-	int ret = 0;
 
-	if (node < 0) {
-		debug("%s: Skipping invalid node", __func__);
-		return -EBADF;
-	}
-
-	prop.num_bits = fdtdec_get_int(blob, node, "rsa,num-bits", 0);
-
-	prop.n0inv = fdtdec_get_int(blob, node, "rsa,n0-inverse", 0);
-
-	prop.public_exponent = fdt_getprop(blob, node, "rsa,exponent", &length);
-	if (!prop.public_exponent || length < sizeof(uint64_t))
-		prop.public_exponent = NULL;
-
-	prop.exp_len = sizeof(uint64_t);
-
-	prop.modulus = fdt_getprop(blob, node, "rsa,modulus", NULL);
-
-	prop.rr = fdt_getprop(blob, node, "rsa,r-squared", NULL);
-
-	if (!prop.num_bits || !prop.modulus) {
-		debug("%s: Missing RSA key info", __func__);
+	if (rsa_get_key_prop(&prop, info, node))
 		return -EFAULT;
-	}
 
-	ret = rsa_verify_key(&prop, sig, sig_len, hash,
-			     info->crypto->key_len, info->checksum);
-
-	return ret;
+	return rsa_verify_key(info, &prop, sig, sig_len, hash,
+			      info->crypto->key_len);
 }
 
 int rsa_verify(struct image_sign_info *info,
@@ -255,3 +587,132 @@ int rsa_verify(struct image_sign_info *info,
 
 	return ret;
 }
+
+#if !defined(USE_HOSTCC)
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_FIT_HW_CRYPTO) && \
+    defined(CONFIG_SPL_ROCKCHIP_SECURE_OTP)
+int rsa_burn_key_hash(struct image_sign_info *info)
+{
+	char *rsa_key;
+	void *n, *e, *c;
+	uint32_t key_len;
+	struct udevice *dev;
+	struct key_prop prop;
+	char name[100] = {0};
+	u16 secure_boot_enable = 0;
+	const void *blob = info->fdt_blob;
+	uint8_t digest[FIT_MAX_HASH_LEN];
+	uint8_t digest_read[FIT_MAX_HASH_LEN];
+	int sig_node, node, digest_len, i, ret = 0;
+
+	dev = misc_otp_get_device(OTP_S);
+	if (!dev)
+		return -ENODEV;
+
+	ret = misc_otp_read(dev, OTP_SECURE_BOOT_ENABLE_ADDR,
+			    &secure_boot_enable, OTP_SECURE_BOOT_ENABLE_SIZE);
+	if (ret)
+		return ret;
+
+	if (secure_boot_enable)
+		return 0;
+
+	sig_node = fdt_subnode_offset(blob, 0, FIT_SIG_NODENAME);
+	if (sig_node < 0) {
+		debug("%s: No signature node found\n", __func__);
+		return -ENOENT;
+	}
+
+	snprintf(name, sizeof(name), "key-%s", info->keyname);
+	node = fdt_subnode_offset(blob, sig_node, name);
+
+	if (rsa_get_key_prop(&prop, info, node))
+		return -1;
+
+	if (!(prop.burn_key))
+		return -EPERM;
+
+	if (!prop.hash || !prop.modulus || !prop.public_exponent_BN)
+		return -ENOENT;
+#ifdef CONFIG_ROCKCHIP_CRYPTO_V1
+	if (!prop.factor_c)
+		return -ENOENT;
+#else
+	if (!prop.factor_np)
+		return -ENOENT;
+#endif
+	key_len = info->crypto->key_len;
+	if (info->crypto->key_len != RSA2048_BYTES)
+		return -EINVAL;
+
+	rsa_key = calloc(key_len * 3, sizeof(char));
+	if (!rsa_key)
+		return -ENOMEM;
+
+	n = rsa_key;
+	e = rsa_key + CONFIG_RSA_N_SIZE;
+	c = rsa_key + CONFIG_RSA_N_SIZE + CONFIG_RSA_E_SIZE;
+	rsa_convert_big_endian(n, (uint32_t *)prop.modulus,
+			       key_len, CONFIG_RSA_N_SIZE);
+	rsa_convert_big_endian(e, (uint32_t *)prop.public_exponent_BN,
+			       key_len, CONFIG_RSA_E_SIZE);
+#ifdef CONFIG_ROCKCHIP_CRYPTO_V1
+	rsa_convert_big_endian(c, (uint32_t *)prop.factor_c,
+			       key_len, CONFIG_RSA_C_SIZE);
+#else
+	rsa_convert_big_endian(c, (uint32_t *)prop.factor_np,
+			       key_len, CONFIG_RSA_C_SIZE);
+#endif
+
+	ret = calculate_hash(rsa_key, CONFIG_RSA_N_SIZE + CONFIG_RSA_E_SIZE + CONFIG_RSA_C_SIZE,
+			     info->checksum->name, digest, &digest_len);
+	if (ret)
+		goto error;
+
+	if (memcmp(digest, prop.hash, digest_len) != 0) {
+		printf("RSA: Compare public key hash fail.\n");
+		goto error;
+	}
+
+	/* burn key hash here */
+	ret = misc_otp_read(dev, OTP_RSA_HASH_ADDR, digest_read, OTP_RSA_HASH_SIZE);
+	if (ret)
+		goto error;
+
+	for (i = 0; i < OTP_RSA_HASH_SIZE; i++) {
+		if (digest_read[i]) {
+			printf("RSA: The secure region has been written.\n");
+			ret = -EIO;
+			goto error;
+		}
+	}
+
+	ret = misc_otp_write(dev, OTP_RSA_HASH_ADDR, digest, OTP_RSA_HASH_SIZE);
+	if (ret)
+		goto error;
+
+	memset(digest_read, 0, FIT_MAX_HASH_LEN);
+	ret = misc_otp_read(dev, OTP_RSA_HASH_ADDR, digest_read, OTP_RSA_HASH_SIZE);
+	if (ret)
+		goto error;
+
+	if (memcmp(digest, digest_read, digest_len) != 0) {
+		printf("RSA: Write public key hash fail.\n");
+		goto error;
+	}
+
+	secure_boot_enable = 0xff;
+	ret = misc_otp_write(dev, OTP_SECURE_BOOT_ENABLE_ADDR,
+			     &secure_boot_enable, OTP_SECURE_BOOT_ENABLE_SIZE);
+	if (ret)
+		goto error;
+
+	printf("RSA: Write key hash successfully\n");
+
+error:
+	free(rsa_key);
+
+	return ret;
+}
+#endif
+#endif
diff --git a/lib/sha256.c b/lib/sha256.c
index 7f5a3618d0..251825ce0f 100644
--- a/lib/sha256.c
+++ b/lib/sha256.c
@@ -257,6 +257,19 @@ void sha256_finish(sha256_context * ctx, uint8_t digest[32])
 	PUT_UINT32_BE(ctx->state[7], digest, 28);
 }
 
+/*
+ * Output = SHA-256( input buffer ).
+ */
+void sha256_csum(const unsigned char *input, unsigned int ilen,
+		 unsigned char *output)
+{
+	sha256_context ctx;
+
+	sha256_starts(&ctx);
+	sha256_update(&ctx, input, ilen);
+	sha256_finish(&ctx, output);
+}
+
 /*
  * Output = SHA-256( input buffer ). Trigger the watchdog every 'chunk_sz'
  * bytes of input processed.
diff --git a/lib/strto.c b/lib/strto.c
index e93a4f5491..7f6076909a 100644
--- a/lib/strto.c
+++ b/lib/strto.c
@@ -13,25 +13,30 @@
 #include <errno.h>
 #include <linux/ctype.h>
 
+/* from lib/kstrtox.c */
+static const char *_parse_integer_fixup_radix(const char *s, unsigned int *base)
+{
+	if (*base == 0) {
+		if (s[0] == '0') {
+			if (tolower(s[1]) == 'x' && isxdigit(s[2]))
+				*base = 16;
+			else
+				*base = 8;
+		} else
+			*base = 10;
+	}
+	if (*base == 16 && s[0] == '0' && tolower(s[1]) == 'x')
+		s += 2;
+	return s;
+}
+
 unsigned long simple_strtoul(const char *cp, char **endp,
 				unsigned int base)
 {
 	unsigned long result = 0;
 	unsigned long value;
 
-	if (*cp == '0') {
-		cp++;
-		if ((*cp == 'x') && isxdigit(cp[1])) {
-			base = 16;
-			cp++;
-		}
-
-		if (!base)
-			base = 8;
-	}
-
-	if (!base)
-		base = 10;
+	cp = _parse_integer_fixup_radix(cp, &base);
 
 	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
 	    ? toupper(*cp) : *cp)-'A'+10) < base) {
@@ -128,19 +133,7 @@ unsigned long long simple_strtoull(const char *cp, char **endp,
 {
 	unsigned long long result = 0, value;
 
-	if (*cp == '0') {
-		cp++;
-		if ((*cp == 'x') && isxdigit(cp[1])) {
-			base = 16;
-			cp++;
-		}
-
-		if (!base)
-			base = 8;
-	}
-
-	if (!base)
-		base = 10;
+	cp = _parse_integer_fixup_radix(cp, &base);
 
 	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0'
 		: (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
diff --git a/lib/tpm.c b/lib/tpm.c
index d1cf5a8a16..5659fa5e18 100644
--- a/lib/tpm.c
+++ b/lib/tpm.c
@@ -607,14 +607,24 @@ uint32_t tpm_get_permanent_flags(struct tpm_permanent_flags *pflags)
 		0x0, 0x0, 0x0, 0x4,	/* subcap size */
 		0x0, 0x0, 0x1, 0x8,	/* subcap value */
 	};
+	const size_t data_size_offset = TPM_HEADER_SIZE;
+	const size_t data_offset = TPM_HEADER_SIZE + sizeof (uint32_t);
 	uint8_t response[COMMAND_BUFFER_SIZE];
 	size_t response_length = sizeof(response);
 	uint32_t err;
+	uint32_t data_size;
 
 	err = tpm_sendrecv_command(command, response, &response_length);
 	if (err)
 		return err;
-	memcpy(pflags, response + TPM_HEADER_SIZE, sizeof(*pflags));
+	if (unpack_byte_string(response, response_length, "d",
+			       data_size_offset, &data_size))
+		return TPM_LIB_ERROR;
+	if (data_size < sizeof(*pflags))
+		return TPM_LIB_ERROR;
+	if (unpack_byte_string(response, response_length, "s",
+			       data_offset, pflags, sizeof(*pflags)))
+		return TPM_LIB_ERROR;
 
 	return 0;
 }
diff --git a/lib/uuid.c b/lib/uuid.c
index 1536c027da..3369e9b52c 100644
--- a/lib/uuid.c
+++ b/lib/uuid.c
@@ -235,23 +235,23 @@ void uuid_bin_to_str(unsigned char *uuid_bin, char *uuid_str, int str_format)
 #if defined(CONFIG_RANDOM_UUID) || defined(CONFIG_CMD_UUID)
 void gen_rand_uuid(unsigned char *uuid_bin)
 {
-	struct uuid uuid;
-	unsigned int *ptr = (unsigned int *)&uuid;
+	u32 ptr[4];
+	struct uuid *uuid = (struct uuid *)ptr;
 	int i;
 
 	/* Set all fields randomly */
-	for (i = 0; i < sizeof(struct uuid) / sizeof(*ptr); i++)
-		*(ptr + i) = cpu_to_be32(rand());
+	for (i = 0; i < 4; i++)
+		ptr[i] = rand();
 
-	clrsetbits_be16(&uuid.time_hi_and_version,
+	clrsetbits_be16(&uuid->time_hi_and_version,
 			UUID_VERSION_MASK,
 			UUID_VERSION << UUID_VERSION_SHIFT);
 
-	clrsetbits_8(&uuid.clock_seq_hi_and_reserved,
+	clrsetbits_8(&uuid->clock_seq_hi_and_reserved,
 		     UUID_VARIANT_MASK,
 		     UUID_VARIANT << UUID_VARIANT_SHIFT);
 
-	memcpy(uuid_bin, &uuid, sizeof(struct uuid));
+	memcpy(uuid_bin, uuid, 16);
 }
 
 /*
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 874a2951f7..3d2f078fc2 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -11,14 +11,17 @@
  * from hush: simple_itoa() was lifted from boa-0.93.15
  */
 
+#include <common.h>
+#include <charset.h>
+#include <efi_loader.h>
+#include <div64.h>
+#include <hexdump.h>
+#include <uuid.h>
 #include <stdarg.h>
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/ctype.h>
 
-#include <common.h>
-
-#include <div64.h>
 #define noinline __attribute__((noinline))
 
 /* we use this so that we can do without the ctype library */
@@ -270,18 +273,27 @@ static char *string(char *buf, char *end, char *s, int field_width,
 	return buf;
 }
 
-#ifdef CONFIG_CMD_NET
-static const char hex_asc[] = "0123456789abcdef";
-#define hex_asc_lo(x)	hex_asc[((x) & 0x0f)]
-#define hex_asc_hi(x)	hex_asc[((x) & 0xf0) >> 4]
-
-static inline char *pack_hex_byte(char *buf, u8 byte)
+static char *string16(char *buf, char *end, u16 *s, int field_width,
+		int precision, int flags)
 {
-	*buf++ = hex_asc_hi(byte);
-	*buf++ = hex_asc_lo(byte);
+	u16 *str = s ? s : L"<NULL>";
+	int utf16_len = utf16_strnlen(str, precision);
+	u8 utf8[utf16_len * MAX_UTF8_PER_UTF16];
+	int utf8_len, i;
+
+	utf8_len = utf16_to_utf8(utf8, str, utf16_len) - utf8;
+
+	if (!(flags & LEFT))
+		while (utf8_len < field_width--)
+			ADDCH(buf, ' ');
+	for (i = 0; i < utf8_len; ++i)
+		ADDCH(buf, utf8[i]);
+	while (utf8_len < field_width--)
+		ADDCH(buf, ' ');
 	return buf;
 }
 
+#ifdef CONFIG_CMD_NET
 static char *mac_address_string(char *buf, char *end, u8 *addr, int field_width,
 				int precision, int flags)
 {
@@ -291,7 +303,7 @@ static char *mac_address_string(char *buf, char *end, u8 *addr, int field_width,
 	int i;
 
 	for (i = 0; i < 6; i++) {
-		p = pack_hex_byte(p, addr[i]);
+		p = hex_byte_pack(p, addr[i]);
 		if (!(flags & SPECIAL) && i != 5)
 			*p++ = ':';
 	}
@@ -310,8 +322,8 @@ static char *ip6_addr_string(char *buf, char *end, u8 *addr, int field_width,
 	int i;
 
 	for (i = 0; i < 8; i++) {
-		p = pack_hex_byte(p, addr[2 * i]);
-		p = pack_hex_byte(p, addr[2 * i + 1]);
+		p = hex_byte_pack(p, addr[2 * i]);
+		p = hex_byte_pack(p, addr[2 * i + 1]);
 		if (!(flags & SPECIAL) && i != 7)
 			*p++ = ':';
 	}
@@ -345,6 +357,40 @@ static char *ip4_addr_string(char *buf, char *end, u8 *addr, int field_width,
 }
 #endif
 
+#ifdef CONFIG_LIB_UUID
+/*
+ * This works (roughly) the same way as linux's, but we currently always
+ * print lower-case (ie. we just keep %pUB and %pUL for compat with linux),
+ * mostly just because that is what uuid_bin_to_str() supports.
+ *
+ *   %pUb:   01020304-0506-0708-090a-0b0c0d0e0f10
+ *   %pUl:   04030201-0605-0807-090a-0b0c0d0e0f10
+ */
+static char *uuid_string(char *buf, char *end, u8 *addr, int field_width,
+			 int precision, int flags, const char *fmt)
+{
+	char uuid[UUID_STR_LEN + 1];
+	int str_format = UUID_STR_FORMAT_STD;
+
+	switch (*(++fmt)) {
+	case 'L':
+	case 'l':
+		str_format = UUID_STR_FORMAT_GUID;
+		break;
+	case 'B':
+	case 'b':
+		/* this is the default */
+		break;
+	default:
+		break;
+	}
+
+	uuid_bin_to_str(addr, uuid, str_format);
+
+	return string(buf, end, uuid, field_width, precision, flags);
+}
+#endif
+
 /*
  * Show a '%p' thing.  A kernel extension is that the '%p' is followed
  * by an extra set of alphanumeric characters that are extended format
@@ -378,8 +424,8 @@ static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 			      flags);
 #endif
 
-#ifdef CONFIG_CMD_NET
 	switch (*fmt) {
+#ifdef CONFIG_CMD_NET
 	case 'a':
 		flags |= SPECIAL | ZEROPAD;
 
@@ -409,8 +455,15 @@ static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 					       precision, flags);
 		flags &= ~SPECIAL;
 		break;
-	}
 #endif
+#ifdef CONFIG_LIB_UUID
+	case 'U':
+		return uuid_string(buf, end, ptr, field_width, precision,
+				   flags, fmt);
+#endif
+	default:
+		break;
+	}
 	flags |= SMALL;
 	if (field_width == -1) {
 		field_width = 2*sizeof(void *);
@@ -528,8 +581,13 @@ repeat:
 			continue;
 
 		case 's':
-			str = string(str, end, va_arg(args, char *),
-				     field_width, precision, flags);
+			if (qualifier == 'l' && !IS_ENABLED(CONFIG_SPL_BUILD)) {
+				str = string16(str, end, va_arg(args, u16 *),
+					       field_width, precision, flags);
+			} else {
+				str = string(str, end, va_arg(args, char *),
+					     field_width, precision, flags);
+			}
 			continue;
 
 		case 'p':
diff --git a/net/Kconfig b/net/Kconfig
index 414c5497c7..90d5a2fb99 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -9,7 +9,7 @@ if NET
 
 config NET_RANDOM_ETHADDR
 	bool "Random ethaddr if unset"
-	select LIB_RAND
+	imply LIB_RAND
 	help
 	  Selecting this will allow the Ethernet interface to function
 	  even when the ethaddr variable for that interface is unset.
diff --git a/net/Makefile b/net/Makefile
index ae54eee5af..718a15a376 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -13,13 +13,14 @@ obj-$(CONFIG_CMD_NET)  += bootp.o
 obj-$(CONFIG_CMD_CDP)  += cdp.o
 obj-$(CONFIG_CMD_DNS)  += dns.o
 ifdef CONFIG_DM_ETH
-obj-$(CONFIG_CMD_NET)  += eth-uclass.o
+obj-$(CONFIG_NET)      += eth-uclass.o
 else
-obj-$(CONFIG_CMD_NET)  += eth_legacy.o
+obj-$(CONFIG_NET)      += eth_legacy.o
 endif
-obj-$(CONFIG_CMD_NET)  += eth_common.o
+obj-$(CONFIG_DM_MDIO)  += mdio-uclass.o
+obj-$(CONFIG_NET)      += eth_common.o
 obj-$(CONFIG_CMD_LINK_LOCAL) += link_local.o
-obj-$(CONFIG_CMD_NET)  += net.o
+obj-$(CONFIG_NET)      += net.o
 obj-$(CONFIG_CMD_NFS)  += nfs.o
 obj-$(CONFIG_CMD_PING) += ping.o
 obj-$(CONFIG_CMD_RARP) += rarp.o
@@ -30,3 +31,4 @@ obj-$(CONFIG_CMD_NET)  += tftp.o
 # sprintf(buf, index ? "foo%d" : "foo", index)
 # and this is intentional usage.
 CFLAGS_eth_common.o += -Wno-format-extra-args
+obj-$(CONFIG_UDP_FUNCTION_FASTBOOT)  += fastboot.o
diff --git a/net/eth-uclass.c b/net/eth-uclass.c
index d30b04ba86..bd153ac13a 100644
--- a/net/eth-uclass.c
+++ b/net/eth-uclass.c
@@ -13,6 +13,7 @@
 #include <dm/device-internal.h>
 #include <dm/uclass-internal.h>
 #include "eth_internal.h"
+#include <eth_phy.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -443,6 +444,10 @@ static int eth_post_bind(struct udevice *dev)
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_DM_ETH_PHY
+	eth_phy_binds_nodes(dev);
+#endif
+
 	return 0;
 }
 
@@ -541,8 +546,8 @@ static int eth_pre_remove(struct udevice *dev)
 	return 0;
 }
 
-UCLASS_DRIVER(eth) = {
-	.name		= "eth",
+UCLASS_DRIVER(ethernet) = {
+	.name		= "ethernet",
 	.id		= UCLASS_ETH,
 	.post_bind	= eth_post_bind,
 	.pre_unbind	= eth_pre_unbind,
diff --git a/net/net.c b/net/net.c
index 4259c9e321..3469a456ea 100644
--- a/net/net.c
+++ b/net/net.c
@@ -87,6 +87,9 @@
 #include <environment.h>
 #include <errno.h>
 #include <net.h>
+#if defined(CONFIG_UDP_FUNCTION_FASTBOOT)
+#include <net/fastboot.h>
+#endif
 #include <net/tftp.h>
 #if defined(CONFIG_LED_STATUS)
 #include <miiphy.h>
@@ -453,6 +456,11 @@ restart:
 			tftp_start_server();
 			break;
 #endif
+#ifdef CONFIG_UDP_FUNCTION_FASTBOOT
+		case FASTBOOT:
+			fastboot_start_server();
+			break;
+#endif
 #if defined(CONFIG_CMD_DHCP)
 		case DHCP:
 			bootp_reset();
@@ -1324,6 +1332,7 @@ common:
 		/* Fall through */
 
 	case NETCONS:
+	case FASTBOOT:
 	case TFTPSRV:
 		if (net_ip.s_addr == 0) {
 			puts("*** ERROR: `ipaddr' not set\n");
diff --git a/net/tftp.c b/net/tftp.c
index a5ed8c5d0a..6671b1f7ca 100644
--- a/net/tftp.c
+++ b/net/tftp.c
@@ -805,7 +805,9 @@ void tftp_start(enum proto_t protocol)
 		printf("Load address: 0x%lx\n", load_addr);
 		puts("Loading: *\b");
 		tftp_state = STATE_SEND_RRQ;
+#ifdef CONFIG_CMD_BOOTEFI
 		efi_set_bootdev("Net", "", tftp_filename);
+#endif
 	}
 
 	time_start = get_timer(0);
diff --git a/post/post.c b/post/post.c
index 8fef0c3412..6c7902ad0c 100644
--- a/post/post.c
+++ b/post/post.c
@@ -15,10 +15,6 @@
 #include <asm/gpio.h>
 #endif
 
-#ifdef CONFIG_LOGBUFFER
-#include <logbuff.h>
-#endif
-
 DECLARE_GLOBAL_DATA_PTR;
 
 #define POST_MAX_NUMBER		32
@@ -407,13 +403,8 @@ int post_log(char *format, ...)
 	vsprintf(printbuffer, format, args);
 	va_end(args);
 
-#ifdef CONFIG_LOGBUFFER
-	/* Send to the logbuffer */
-	logbuff_log(printbuffer);
-#else
 	/* Send to the stdout file */
 	puts(printbuffer);
-#endif
 
 	return 0;
 }
diff --git a/post/tests.c b/post/tests.c
index bc8e398051..473c0ea1e1 100644
--- a/post/tests.c
+++ b/post/tests.c
@@ -3,10 +3,6 @@
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
  * SPDX-License-Identifier:	GPL-2.0+
- *
- * Be sure to mark tests to be run before relocation as such with the
- * CONFIG_SYS_POST_PREREL flag so that logging is done correctly if the
- * logbuffer support is enabled.
  */
 
 #include <common.h>
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index a3a5c59d0d..13ebddda65 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -7,6 +7,7 @@ quote   := "
 squote  := '
 empty   :=
 space   := $(empty) $(empty)
+pound := \#
 
 ###
 # Name of target with a '.' as filename prefix. foo/bar.o => foo/.bar.o
@@ -172,11 +173,6 @@ ld-version = $(shell $(LD) --version | $(srctree)/scripts/ld-version.sh)
 # Usage:  $(call ld-ifversion, -ge, 22252, y)
 ld-ifversion = $(shell [ $(ld-version) $(1) $(2) ] && echo $(3) || echo $(4))
 
-# dtc-option
-# Usage:  DTC_FLAGS += $(call dtc-option,-Wno-unit_address_vs_reg)
-dtc-option = $(call try-run,\
-	echo '/dts-v1/; / {};' | $(DTC) $(1),$(1),$(2))
-
 ######
 
 ###
@@ -247,11 +243,11 @@ endif
 
 # Replace >$< with >$$< to preserve $ when reloading the .cmd file
 # (needed for make)
-# Replace >#< with >\#< to avoid starting a comment in the .cmd file
+# Replace >#< with >$(pound)< to avoid starting a comment in the .cmd file
 # (needed for make)
 # Replace >'< with >'\''< to be able to enclose the whole string in '...'
 # (needed for the shell)
-make-cmd = $(call escsq,$(subst \#,\\\#,$(subst $$,$$$$,$(cmd_$(1)))))
+make-cmd = $(call escsq,$(subst $(pound),$$(pound),$(subst $$,$$$$,$(cmd_$(1)))))
 
 # Find any prerequisites that is newer than target or that does not exist.
 # PHONY targets skipped in both cases.
diff --git a/scripts/Makefile b/scripts/Makefile
index 3e10c16d59..9d55241463 100644
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -21,3 +21,4 @@ build_docproc: $(obj)/docproc
 
 # Let clean descend into subdirs
 subdir-	+= basic kconfig
+subdir-$(CONFIG_DTC)	+= dtc
diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn
index 90dc149df3..1d3a570594 100644
--- a/scripts/Makefile.extrawarn
+++ b/scripts/Makefile.extrawarn
@@ -58,8 +58,8 @@ endif
 
 KBUILD_CFLAGS += $(warning)
 
-dtc-warning-2 += $(call dtc-option,-Wnode_name_chars_strict)
-dtc-warning-2 += $(call dtc-option,-Wproperty_name_chars_strict)
+dtc-warning-2 += -Wnode_name_chars_strict
+dtc-warning-2 += -Wproperty_name_chars_strict
 
 dtc-warning := $(dtc-warning-$(findstring 1, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))
 dtc-warning += $(dtc-warning-$(findstring 2, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))
@@ -70,11 +70,11 @@ DTC_FLAGS += $(dtc-warning)
 else
 
 # Disable noisy checks by default
-DTC_FLAGS += $(call dtc-option,-Wno-unit_address_vs_reg)
-DTC_FLAGS += $(call dtc-option,-Wno-simple_bus_reg)
-DTC_FLAGS += $(call dtc-option,-Wno-unit_address_format)
-DTC_FLAGS += $(call dtc-option,-Wno-pci_bridge)
-DTC_FLAGS += $(call dtc-option,-Wno-pci_device_bus_num)
-DTC_FLAGS += $(call dtc-option,-Wno-pci_device_reg)
+DTC_FLAGS += -Wno-unit_address_vs_reg
+DTC_FLAGS += -Wno-simple_bus_reg
+DTC_FLAGS += -Wno-unit_address_format
+DTC_FLAGS += -Wno-pci_bridge
+DTC_FLAGS += -Wno-pci_device_bus_num
+DTC_FLAGS += -Wno-pci_device_reg
 
 endif
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 9ce47b4d22..eaf86593a3 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -175,7 +175,7 @@ u_boot_dtsi_options = $(wildcard $(dir $<)$(basename $(notdir $<))-u-boot.dtsi)
 # $(warning u_boot_dtsi_options: $(u_boot_dtsi_options))
 
 # We use the first match
-u_boot_dtsi = $(firstword $(u_boot_dtsi_options))
+u_boot_dtsi = $(notdir $(firstword $(u_boot_dtsi_options)))
 
 # Modified for U-Boot
 dtc_cpp_flags  = -Wp,-MD,$(depfile).pre.tmp -nostdinc                    \
@@ -308,9 +308,8 @@ quiet_cmd_dtc = DTC     $@
 # Modified for U-Boot
 # Bring in any U-Boot-specific include at the end of the file
 cmd_dtc = mkdir -p $(dir ${dtc-tmp}) ; \
-	cat $< $(if $(u_boot_dtsi),\
-		| sed "$$ a\#include \"$(u_boot_dtsi)\"") | \
-		$(CPP) $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) - ; \
+	(cat $<; $(if $(u_boot_dtsi),echo '$(pound)include "$(u_boot_dtsi)"')) > $(pre-tmp); \
+	$(CPP) $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $(pre-tmp) ; \
 	$(DTC) -O dtb -o $@ -b 0 \
 		-i $(dir $<) $(DTC_FLAGS) \
 		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
@@ -319,8 +318,26 @@ cmd_dtc = mkdir -p $(dir ${dtc-tmp}) ; \
 $(obj)/%.dtb: $(src)/%.dts FORCE
 	$(call if_changed_dep,dtc)
 
+pre-tmp = $(subst $(comma),_,$(dot-target).pre.tmp)
 dtc-tmp = $(subst $(comma),_,$(dot-target).dts.tmp)
 
+# DTCO
+# ---------------------------------------------------------------------------
+
+quiet_cmd_dtco = DTCO    $@
+# Rule for objects only; does not put specific u-boot include at the end
+# No generation of assembly file either
+# Modified for U-Boot
+cmd_dtco = mkdir -p $(dir ${dtc-tmp}) ; \
+	$(CPP) $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) - ; \
+	$(DTC) -@ -O dtb -o $@ -b 0 \
+		-i $(dir $<) $(DTC_FLAGS) \
+		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
+	cat $(depfile).pre.tmp $(depfile).dtc.tmp > $(depfile)
+
+$(obj)/%.dtbo: $(src)/%.dts FORCE
+	$(call if_changed_dep,dtco)
+
 # Fonts
 # ---------------------------------------------------------------------------
 
@@ -375,8 +392,6 @@ cmd_efi_ld = $(LD) -nostdlib -znocombreloc -T $(EFI_LDS_PATH) -shared \
 
 EFI_LDS_PATH = $(srctree)/arch/$(ARCH)/lib/$(EFI_LDS)
 
-$(obj)/helloworld.so: $(EFI_LDS_PATH)
-
 $(obj)/helloworld.so: $(obj)/helloworld.o arch/$(ARCH)/lib/$(EFI_CRT0) \
 		arch/$(ARCH)/lib/$(EFI_RELOC)
 	$(call cmd,efi_ld)
diff --git a/scripts/Makefile.spl b/scripts/Makefile.spl
index dd8065d87d..dc567b6d4b 100644
--- a/scripts/Makefile.spl
+++ b/scripts/Makefile.spl
@@ -64,7 +64,14 @@ HAVE_VENDOR_COMMON_LIB = $(if $(wildcard $(srctree)/board/$(VENDOR)/common/Makef
 libs-y += $(if $(BOARDDIR),board/$(BOARDDIR)/)
 libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
 
+ifeq ($(CONFIG_TPL_BUILD),y)
+ifndef CONFIG_TPL_TINY_FRAMEWORK
+libs-$(CONFIG_SPL_FRAMEWORK) += common/spl/
+endif
+else
 libs-$(CONFIG_SPL_FRAMEWORK) += common/spl/
+endif
+
 libs-y += common/init/
 
 # Special handling for a few options which support SPL/TPL
@@ -77,8 +84,11 @@ libs-$(CONFIG_SPL_LIBGENERIC_SUPPORT) += lib/
 endif
 
 libs-$(CONFIG_SPL_LIBDISK_SUPPORT) += disk/
+ifneq ($(CONFIG_SPL_DECOMP_HEADER),y)
 libs-y += drivers/
-libs-$(CONFIG_SPL_USB_GADGET_SUPPORT) += drivers/usb/dwc3/
+endif
+libs-$(CONFIG_SPL_USB_GADGET) += drivers/usb/dwc3/
+libs-$(CONFIG_SPL_USB_GADGET) += drivers/usb/cdns3/
 libs-y += dts/
 libs-y += fs/
 libs-$(CONFIG_SPL_POST_MEM_SUPPORT) += post/drivers/
@@ -167,7 +177,8 @@ ifdef CONFIG_ARCH_ZYNQ
 MKIMAGEFLAGS_boot.bin = -T zynqimage -R $(srctree)/$(CONFIG_BOOT_INIT_FILE)
 endif
 ifdef CONFIG_ARCH_ZYNQMP
-MKIMAGEFLAGS_boot.bin = -T zynqmpimage -R $(srctree)/$(CONFIG_BOOT_INIT_FILE)
+MKIMAGEFLAGS_boot.bin = -T zynqmpimage -R $(srctree)/$(CONFIG_BOOT_INIT_FILE) \
+	-n $(srctree)/$(CONFIG_PMUFW_INIT_FILE)
 endif
 
 spl/boot.bin: $(obj)/u-boot-spl.bin FORCE
@@ -209,10 +220,21 @@ cmd_cat = cat $(filter-out $(PHONY), $^) > $@
 quiet_cmd_copy = COPY    $@
       cmd_copy = cp $< $@
 
+ifneq ($(CONFIG_SPL_MULTI_DTB_FIT),y)
+FINAL_DTB_CONTAINER = $(obj)/$(SPL_BIN).dtb
+else ifeq ($(CONFIG_SPL_MULTI_DTB_FIT_LZO),y)
+FINAL_DTB_CONTAINER = $(obj)/$(SPL_BIN).multidtb.fit.lzo
+else ifeq ($(CONFIG_SPL_MULTI_DTB_FIT_GZIP),y)
+FINAL_DTB_CONTAINER = $(obj)/$(SPL_BIN).multidtb.fit.gz
+else
+FINAL_DTB_CONTAINER = $(obj)/$(SPL_BIN).multidtb.fit
+endif
+
+
 ifeq ($(CONFIG_$(SPL_TPL_)OF_CONTROL)$(CONFIG_OF_SEPARATE)$(CONFIG_$(SPL_TPL_)OF_PLATDATA),yy)
 $(obj)/$(SPL_BIN)-dtb.bin: $(obj)/$(SPL_BIN)-nodtb.bin \
 		$(if $(CONFIG_SPL_SEPARATE_BSS),,$(obj)/$(SPL_BIN)-pad.bin) \
-		$(obj)/$(SPL_BIN).dtb FORCE
+		$(FINAL_DTB_CONTAINER)  FORCE
 	$(call if_changed,cat)
 
 $(obj)/$(SPL_BIN).bin: $(obj)/$(SPL_BIN)-dtb.bin FORCE
@@ -227,26 +249,15 @@ $(obj)/$(SPL_BIN)-pad.bin: $(obj)/$(SPL_BIN)
 	@bss_size_str=$(shell $(NM) $< | awk 'BEGIN {size = 0} /__bss_size/ {size = $$1} END {print "ibase=16; " toupper(size)}' | bc); \
 	dd if=/dev/zero of=$@ bs=1 count=$${bss_size_str} 2>/dev/null;
 
-# Pass the original device tree file through fdtgrep twice. The first pass
-# removes any unwanted nodes (i.e. those which don't have the
-# 'u-boot,dm-pre-reloc' property and thus are not needed by SPL. The second
-# pass removes various unused properties from the remaining nodes.
-# The output is typically a much smaller device tree file.
 ifeq ($(CONFIG_TPL_BUILD),y)
-fdtgrep_props := -b u-boot,dm-pre-reloc -b u-boot,dm-tpl
+$(obj)/$(SPL_BIN).dtb: dts/dt-tpl.dtb FORCE
+	$(call if_changed,copy)
 else
-fdtgrep_props := -b u-boot,dm-pre-reloc -b u-boot,dm-spl
+$(obj)/$(SPL_BIN).dtb: dts/dt-spl.dtb FORCE
+	$(call if_changed,copy)
 endif
-quiet_cmd_fdtgrep = FDTGREP $@
-      cmd_fdtgrep = $(objtree)/tools/fdtgrep $(fdtgrep_props) -RT $< \
-		-n /chosen -n /config -O dtb | \
-	$(objtree)/tools/fdtgrep -r -O dtb - -o $@ \
-		$(addprefix -P ,$(subst $\",,$(CONFIG_OF_SPL_REMOVE_PROPS)))
-
-$(obj)/$(SPL_BIN).dtb: dts/dt.dtb $(objtree)/tools/fdtgrep FORCE
-	$(call if_changed,fdtgrep)
 
-pythonpath = PYTHONPATH=tools
+pythonpath = PYTHONPATH=scripts/dtc/pylibfdt
 
 quiet_cmd_dtocc = DTOC C  $@
 cmd_dtocc = $(pythonpath) $(srctree)/tools/dtoc/dtoc -d $(obj)/$(SPL_BIN).dtb -o $@ platdata
@@ -257,17 +268,18 @@ cmd_dtoch = $(pythonpath) $(srctree)/tools/dtoc/dtoc -d $(obj)/$(SPL_BIN).dtb -o
 quiet_cmd_plat = PLAT    $@
 cmd_plat = $(CC) $(c_flags) -c $< -o $@
 
-$(obj)/dts/dt-platdata.o: $(obj)/dts/dt-platdata.c include/generated/dt-structs.h
+$(obj)/dts/dt-platdata.o: $(obj)/dts/dt-platdata.c \
+		include/generated/dt-structs-gen.h
 	$(call if_changed,plat)
 
 PHONY += dts_dir
 dts_dir:
 	$(shell [ -d $(obj)/dts ] || mkdir -p $(obj)/dts)
 
-include/generated/dt-structs.h: $(obj)/$(SPL_BIN).dtb dts_dir checkdtoc
+include/generated/dt-structs-gen.h: $(obj)/$(SPL_BIN).dtb dts_dir FORCE
 	$(call if_changed,dtoch)
 
-$(obj)/dts/dt-platdata.c: $(obj)/$(SPL_BIN).dtb dts_dir checkdtoc
+$(obj)/dts/dt-platdata.c: $(obj)/$(SPL_BIN).dtb dts_dir FORCE
 	$(call if_changed,dtocc)
 
 ifdef CONFIG_SAMSUNG
@@ -339,7 +351,8 @@ quiet_cmd_u-boot-spl ?= LD      $@
 		       $(patsubst $(obj)/%,%,$(u-boot-spl-main))  \
 		       $(patsubst $(obj)/%,%,$(u-boot-spl-platdata)) \
 		       --end-group \
-		       $(PLATFORM_LIBS) -Map $(SPL_BIN).map -o $(SPL_BIN))
+		       $(PLATFORM_LIBS) -Map $(SPL_BIN).map -o $(SPL_BIN) && \
+		       $(OBJDUMP) -t $(SPL_BIN) > $(SPL_BIN).sym)
 
 $(obj)/$(SPL_BIN): $(u-boot-spl-platdata) $(u-boot-spl-init) \
 		$(u-boot-spl-main) $(obj)/u-boot-spl.lds FORCE
@@ -368,20 +381,31 @@ ifneq ($(cmd_files),)
   include $(cmd_files)
 endif
 
-checkdtoc: tools
-	@if ! ( echo 'import libfdt' | ( PYTHONPATH=tools $(PYTHON) )); then \
-		echo '*** dtoc needs the Python libfdt library. Either '; \
-		echo '*** install it on your system, or try:'; \
-		echo '***'; \
-		echo '*** sudo apt-get install swig libpython-dev'; \
-		echo '***'; \
-		echo '*** to have U-Boot build its own version.'; \
-		false; \
-	fi
-
 PHONY += FORCE
 FORCE:
 
+PHONY += dtbs
+dtbs:
+	$(Q)$(MAKE) $(build)=dts dtbs
+
 # Declare the contents of the .PHONY variable as phony.  We keep that
 # information in a variable so we can use it in if_changed and friends.
 .PHONY: $(PHONY)
+
+SHRUNK_ARCH_DTB = $(patsubst %,$(obj)/dts/%.dtb,$(subst ",,$(CONFIG_SPL_OF_LIST)))
+.SECONDEXPANSION:
+$(SHRUNK_ARCH_DTB): $$(patsubst $(obj)/dts/%, arch/$(ARCH)/dts/%, $$@)
+	$(call if_changed,fdtgrep)
+
+MKIMAGEFLAGS_$(SPL_BIN).multidtb.fit = -f auto -A $(ARCH) -T firmware -C none -O u-boot \
+	-n "Multi DTB fit image for $(SPL_BIN)" -E \
+	$(patsubst %,-b %,$(SHRUNK_ARCH_DTB))
+
+$(obj)/$(SPL_BIN).multidtb.fit: /dev/null $(SHRUNK_ARCH_DTB) FORCE
+	$(call if_changed,mkimage)
+
+$(obj)/$(SPL_BIN).multidtb.fit.gz: $(obj)/$(SPL_BIN).multidtb.fit
+	@gzip -kf9 $< > $@
+
+$(obj)/$(SPL_BIN).multidtb.fit.lzo: $(obj)/$(SPL_BIN).multidtb.fit
+	@lzop -f9 $< > $@
diff --git a/scripts/Makefile.uncmd_spl b/scripts/Makefile.uncmd_spl
index 15d0836b49..b3994110dc 100644
--- a/scripts/Makefile.uncmd_spl
+++ b/scripts/Makefile.uncmd_spl
@@ -9,7 +9,7 @@ ifdef CONFIG_SPL_BUILD
 ifndef CONFIG_SPL_DM
 CONFIG_DM_SERIAL=
 CONFIG_DM_GPIO=
-CONIFG_DM_I2C=
+CONFIG_DM_I2C=
 CONFIG_DM_SPI=
 CONFIG_DM_SPI_FLASH=
 endif
diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 9bd0de2490..da7fb2cd4d 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -249,10 +249,17 @@ static void parse_config_file(const char *map, size_t len)
 		if (q - p < 0)
 			continue;
 
-		/* U-Boot also handles CONFIG_IS_{ENABLED/BUILTIN/MODULE} */
+		/*
+		 * U-Boot also handles
+		 *   CONFIG_IS_ENABLED(...)
+		 *   CONFIG_IS_BUILTIN(...)
+		 *   CONFIG_IS_MODULE(...)
+		 *   CONFIG_VAL(...)
+		 */
 		if ((q - p == 10 && !memcmp(p, "IS_ENABLED(", 11)) ||
 		    (q - p == 10 && !memcmp(p, "IS_BUILTIN(", 11)) ||
-		    (q - p == 9 && !memcmp(p, "IS_MODULE(", 10))) {
+		    (q - p == 9 && !memcmp(p, "IS_MODULE(", 10)) ||
+		    (q - p == 3 && !memcmp(p, "VAL(", 4))) {
 			p = q + 1;
 			for (q = p; q < map + len; q++)
 				if (*q == ')')
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 3afc870f0f..e450826c36 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl
 # (c) 2001, Dave Jones. (the file handling bit)
 # (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)
 # (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)
@@ -6,12 +6,13 @@
 # Licensed under the terms of the GNU GPL License version 2
 
 use strict;
+use warnings;
 use POSIX;
 use File::Basename;
 use Cwd 'abs_path';
+use Term::ANSIColor qw(:constants);
 
 my $P = $0;
-$P =~ s@.*/@@g;
 my $D = dirname(abs_path($P));
 
 my $V = '0.32';
@@ -25,12 +26,17 @@ my $chk_patch = 1;
 my $tst_only;
 my $emacs = 0;
 my $terse = 0;
+my $showfile = 0;
 my $file = 0;
+my $git = 0;
+my %git_commits = ();
 my $check = 0;
+my $check_orig = 0;
 my $summary = 1;
 my $mailback = 0;
 my $summary_file = 0;
 my $show_types = 0;
+my $list_types = 0;
 my $fix = 0;
 my $fix_inplace = 0;
 my $root;
@@ -45,9 +51,14 @@ my $configuration_file = ".checkpatch.conf";
 my $max_line_length = 80;
 my $ignore_perl_version = 0;
 my $minimum_perl_version = 5.10.0;
+my $min_conf_desc_length = 4;
 my $spelling_file = "$D/spelling.txt";
 my $codespell = 0;
 my $codespellfile = "/usr/share/codespell/dictionary.txt";
+my $conststructsfile = "$D/const_structs.checkpatch";
+my $typedefsfile = "";
+my $color = "auto";
+my $allow_c99_comments = 1;
 
 sub help {
 	my ($exitcode) = @_;
@@ -63,12 +74,25 @@ Options:
   --patch                    treat FILE as patchfile (default)
   --emacs                    emacs compile window format
   --terse                    one line per report
+  --showfile                 emit diffed file position, not input file position
+  -g, --git                  treat FILE as a single commit or git revision range
+                             single git commit with:
+                               <rev>
+                               <rev>^
+                               <rev>~n
+                             multiple git commits with:
+                               <rev1>..<rev2>
+                               <rev1>...<rev2>
+                               <rev>-<count>
+                             git merges are ignored
   -f, --file                 treat FILE as regular source file
   --subjective, --strict     enable more subjective tests
+  --list-types               list the possible message types
   --types TYPE(,TYPE2...)    show only these comma separated message types
   --ignore TYPE(,TYPE2...)   ignore various comma separated message types
+  --show-types               show the specific message type in the output
   --max-line-length=n        set the maximum line length, if exceeded, warn
-  --show-types               show the message "types" in the output
+  --min-conf-desc-length=n   set the min description length, if shorter, warn
   --root=PATH                PATH to the kernel tree root
   --no-summary               suppress the per-file summary
   --mailback                 only produce a report in case of warnings/errors
@@ -89,8 +113,11 @@ Options:
   --ignore-perl-version      override checking of perl version.  expect
                              runtime errors.
   --codespell                Use the codespell dictionary for spelling/typos
-                             (default:/usr/local/share/codespell/dictionary.txt)
+                             (default:/usr/share/codespell/dictionary.txt)
   --codespellfile            Use this codespell dictionary
+  --typedefsfile             Read additional types from this file
+  --color[=WHEN]             Use colors 'always', 'never', or only when output
+                             is a terminal ('auto'). Default is 'auto'.
   -h, --help, --version      display this help and exit
 
 When FILE is - read standard input.
@@ -99,6 +126,37 @@ EOM
 	exit($exitcode);
 }
 
+sub uniq {
+	my %seen;
+	return grep { !$seen{$_}++ } @_;
+}
+
+sub list_types {
+	my ($exitcode) = @_;
+
+	my $count = 0;
+
+	local $/ = undef;
+
+	open(my $script, '<', abs_path($P)) or
+	    die "$P: Can't read '$P' $!\n";
+
+	my $text = <$script>;
+	close($script);
+
+	my @types = ();
+	for ($text =~ /\b(?:(?:CHK|WARN|ERROR)\s*\(\s*"([^"]+)")/g) {
+		push (@types, $_);
+	}
+	@types = sort(uniq(@types));
+	print("#\tMessage type\n\n");
+	foreach my $type (@types) {
+		print(++$count . "\t" . $type . "\n");
+	}
+
+	exit($exitcode);
+}
+
 my $conf = which_conf($configuration_file);
 if (-f $conf) {
 	my @conf_args;
@@ -125,6 +183,14 @@ if (-f $conf) {
 	unshift(@ARGV, @conf_args) if @conf_args;
 }
 
+# Perl's Getopt::Long allows options to take optional arguments after a space.
+# Prevent --color by itself from consuming other arguments
+foreach (@ARGV) {
+	if ($_ eq "--color" || $_ eq "-color") {
+		$_ = "--color=$color";
+	}
+}
+
 GetOptions(
 	'q|quiet+'	=> \$quiet,
 	'tree!'		=> \$tree,
@@ -132,13 +198,17 @@ GetOptions(
 	'patch!'	=> \$chk_patch,
 	'emacs!'	=> \$emacs,
 	'terse!'	=> \$terse,
+	'showfile!'	=> \$showfile,
 	'f|file!'	=> \$file,
+	'g|git!'	=> \$git,
 	'subjective!'	=> \$check,
 	'strict!'	=> \$check,
 	'ignore=s'	=> \@ignore,
 	'types=s'	=> \@use,
 	'show-types!'	=> \$show_types,
+	'list-types!'	=> \$list_types,
 	'max-line-length=i' => \$max_line_length,
+	'min-conf-desc-length=i' => \$min_conf_desc_length,
 	'root=s'	=> \$root,
 	'summary!'	=> \$summary,
 	'mailback!'	=> \$mailback,
@@ -148,15 +218,22 @@ GetOptions(
 	'ignore-perl-version!' => \$ignore_perl_version,
 	'debug=s'	=> \%debug,
 	'test-only=s'	=> \$tst_only,
-	'codespell!'    => \$codespell,
-	'codespellfile=s' => \$codespellfile,
+	'codespell!'	=> \$codespell,
+	'codespellfile=s'	=> \$codespellfile,
+	'typedefsfile=s'	=> \$typedefsfile,
+	'color=s'	=> \$color,
+	'no-color'	=> \$color,	#keep old behaviors of -nocolor
+	'nocolor'	=> \$color,	#keep old behaviors of -nocolor
 	'h|help'	=> \$help,
 	'version'	=> \$help
 ) or help(1);
 
 help(0) if ($help);
 
+list_types(0) if ($list_types);
+
 $fix = 1 if ($fix_inplace);
+$check_orig = $check;
 
 my $exit = 0;
 
@@ -167,9 +244,21 @@ if ($^V && $^V lt $minimum_perl_version) {
 	}
 }
 
+#if no filenames are given, push '-' to read patch from stdin
 if ($#ARGV < 0) {
-	print "$P: no input files\n";
-	exit(1);
+	push(@ARGV, '-');
+}
+
+if ($color =~ /^[01]$/) {
+	$color = !$color;
+} elsif ($color =~ /^always$/i) {
+	$color = 1;
+} elsif ($color =~ /^never$/i) {
+	$color = 0;
+} elsif ($color =~ /^auto$/i) {
+	$color = (-t STDOUT);
+} else {
+	die "Invalid color mode: $color\n";
 }
 
 sub hash_save_array_words {
@@ -192,12 +281,12 @@ sub hash_save_array_words {
 sub hash_show_words {
 	my ($hashRef, $prefix) = @_;
 
-	if ($quiet == 0 && keys %$hashRef) {
-		print "NOTE: $prefix message types:";
+	if (keys %$hashRef) {
+		print "\nNOTE: $prefix message types:";
 		foreach my $word (sort keys %$hashRef) {
 			print " $word";
 		}
-		print "\n\n";
+		print "\n";
 	}
 }
 
@@ -257,7 +346,8 @@ our $Sparse	= qr{
 			__init_refok|
 			__kprobes|
 			__ref|
-			__rcu
+			__rcu|
+			__private
 		}x;
 our $InitAttributePrefix = qr{__(?:mem|cpu|dev|net_|)};
 our $InitAttributeData = qr{$InitAttributePrefix(?:initdata\b)};
@@ -272,7 +362,7 @@ our $Attribute	= qr{
 			__percpu|
 			__nocast|
 			__safe|
-			__bitwise__|
+			__bitwise|
 			__packed__|
 			__packed2__|
 			__naked|
@@ -281,6 +371,7 @@ our $Attribute	= qr{
 			__noreturn|
 			__used|
 			__cold|
+			__pure|
 			__noclone|
 			__deprecated|
 			__read_mostly|
@@ -292,7 +383,7 @@ our $Attribute	= qr{
 			__weak
 		  }x;
 our $Modifier;
-our $Inline	= qr{inline|__always_inline|noinline};
+our $Inline	= qr{inline|__always_inline|noinline|__inline|__inline__};
 our $Member	= qr{->$Ident|\.$Ident|\[[^]]*\]};
 our $Lval	= qr{$Ident(?:$Member)*};
 
@@ -300,13 +391,15 @@ our $Int_type	= qr{(?i)llu|ull|ll|lu|ul|l|u};
 our $Binary	= qr{(?i)0b[01]+$Int_type?};
 our $Hex	= qr{(?i)0x[0-9a-f]+$Int_type?};
 our $Int	= qr{[0-9]+$Int_type?};
+our $Octal	= qr{0[0-7]+$Int_type?};
+our $String	= qr{(?:\bL)?"[X\t]*"};
 our $Float_hex	= qr{(?i)0x[0-9a-f]+p-?[0-9]+[fl]?};
 our $Float_dec	= qr{(?i)(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)(?:e-?[0-9]+)?[fl]?};
 our $Float_int	= qr{(?i)[0-9]+e-?[0-9]+[fl]?};
 our $Float	= qr{$Float_hex|$Float_dec|$Float_int};
-our $Constant	= qr{$Float|$Binary|$Hex|$Int};
+our $Constant	= qr{$Float|$Binary|$Octal|$Hex|$Int};
 our $Assignment	= qr{\*\=|/=|%=|\+=|-=|<<=|>>=|&=|\^=|\|=|=};
-our $Compare    = qr{<=|>=|==|!=|<|>};
+our $Compare    = qr{<=|>=|==|!=|<|(?<!-)>};
 our $Arithmetic = qr{\+|-|\*|\/|%};
 our $Operators	= qr{
 			<=|>=|==|!=|
@@ -314,10 +407,16 @@ our $Operators	= qr{
 			&&|\|\||,|\^|\+\+|--|&|\||$Arithmetic
 		  }x;
 
+our $c90_Keywords = qr{do|for|while|if|else|return|goto|continue|switch|default|case|break}x;
+
+our $BasicType;
 our $NonptrType;
+our $NonptrTypeMisordered;
 our $NonptrTypeWithAttr;
 our $Type;
+our $TypeMisordered;
 our $Declare;
+our $DeclareMisordered;
 
 our $NON_ASCII_UTF8	= qr{
 	[\xC2-\xDF][\x80-\xBF]               # non-overlong 2-byte
@@ -334,19 +433,28 @@ our $UTF8	= qr{
 	| $NON_ASCII_UTF8
 }x;
 
-our $typeTypedefs = qr{(?x:
+our $typeC99Typedefs = qr{(?:__)?(?:[us]_?)?int_?(?:8|16|32|64)_t};
+our $typeOtherOSTypedefs = qr{(?x:
+	u_(?:char|short|int|long) |          # bsd
+	u(?:nchar|short|int|long)            # sysv
+)};
+our $typeKernelTypedefs = qr{(?x:
 	(?:__)?(?:u|s|be|le)(?:8|16|32|64)|
 	atomic_t
 )};
+our $typeTypedefs = qr{(?x:
+	$typeC99Typedefs\b|
+	$typeOtherOSTypedefs\b|
+	$typeKernelTypedefs\b
+)};
+
+our $zero_initializer = qr{(?:(?:0[xX])?0+$Int_type?|NULL|false)\b};
 
 our $logFunctions = qr{(?x:
-	printk(?:_ratelimited|_once|)|
+	printk(?:_ratelimited|_once|_deferred_once|_deferred|)|
 	(?:[a-z0-9]+_){1,2}(?:printk|emerg|alert|crit|err|warning|warn|notice|info|debug|dbg|vdbg|devel|cont|WARN)(?:_ratelimited|_once|)|
 	WARN(?:_RATELIMIT|_ONCE|)|
 	panic|
-	debug|
-	printf|
-	puts|
 	MODULE_[A-Z_]+|
 	seq_vprintf|seq_printf|seq_puts
 )};
@@ -362,16 +470,36 @@ our $signature_tags = qr{(?xi:
 	Cc:
 )};
 
+our @typeListMisordered = (
+	qr{char\s+(?:un)?signed},
+	qr{int\s+(?:(?:un)?signed\s+)?short\s},
+	qr{int\s+short(?:\s+(?:un)?signed)},
+	qr{short\s+int(?:\s+(?:un)?signed)},
+	qr{(?:un)?signed\s+int\s+short},
+	qr{short\s+(?:un)?signed},
+	qr{long\s+int\s+(?:un)?signed},
+	qr{int\s+long\s+(?:un)?signed},
+	qr{long\s+(?:un)?signed\s+int},
+	qr{int\s+(?:un)?signed\s+long},
+	qr{int\s+(?:un)?signed},
+	qr{int\s+long\s+long\s+(?:un)?signed},
+	qr{long\s+long\s+int\s+(?:un)?signed},
+	qr{long\s+long\s+(?:un)?signed\s+int},
+	qr{long\s+long\s+(?:un)?signed},
+	qr{long\s+(?:un)?signed},
+);
+
 our @typeList = (
 	qr{void},
-	qr{(?:unsigned\s+)?char},
-	qr{(?:unsigned\s+)?short},
-	qr{(?:unsigned\s+)?int},
-	qr{(?:unsigned\s+)?long},
-	qr{(?:unsigned\s+)?long\s+int},
-	qr{(?:unsigned\s+)?long\s+long},
-	qr{(?:unsigned\s+)?long\s+long\s+int},
-	qr{unsigned},
+	qr{(?:(?:un)?signed\s+)?char},
+	qr{(?:(?:un)?signed\s+)?short\s+int},
+	qr{(?:(?:un)?signed\s+)?short},
+	qr{(?:(?:un)?signed\s+)?int},
+	qr{(?:(?:un)?signed\s+)?long\s+int},
+	qr{(?:(?:un)?signed\s+)?long\s+long\s+int},
+	qr{(?:(?:un)?signed\s+)?long\s+long},
+	qr{(?:(?:un)?signed\s+)?long},
+	qr{(?:un)?signed},
 	qr{float},
 	qr{double},
 	qr{bool},
@@ -381,7 +509,31 @@ our @typeList = (
 	qr{${Ident}_t},
 	qr{${Ident}_handler},
 	qr{${Ident}_handler_fn},
+	@typeListMisordered,
 );
+
+our $C90_int_types = qr{(?x:
+	long\s+long\s+int\s+(?:un)?signed|
+	long\s+long\s+(?:un)?signed\s+int|
+	long\s+long\s+(?:un)?signed|
+	(?:(?:un)?signed\s+)?long\s+long\s+int|
+	(?:(?:un)?signed\s+)?long\s+long|
+	int\s+long\s+long\s+(?:un)?signed|
+	int\s+(?:(?:un)?signed\s+)?long\s+long|
+
+	long\s+int\s+(?:un)?signed|
+	long\s+(?:un)?signed\s+int|
+	long\s+(?:un)?signed|
+	(?:(?:un)?signed\s+)?long\s+int|
+	(?:(?:un)?signed\s+)?long|
+	int\s+long\s+(?:un)?signed|
+	int\s+(?:(?:un)?signed\s+)?long|
+
+	int\s+(?:un)?signed|
+	(?:(?:un)?signed\s+)?int
+)};
+
+our @typeListFile = ();
 our @typeListWithAttr = (
 	@typeList,
 	qr{struct\s+$InitAttribute\s+$Ident},
@@ -391,10 +543,67 @@ our @typeListWithAttr = (
 our @modifierList = (
 	qr{fastcall},
 );
+our @modifierListFile = ();
+
+our @mode_permission_funcs = (
+	["module_param", 3],
+	["module_param_(?:array|named|string)", 4],
+	["module_param_array_named", 5],
+	["debugfs_create_(?:file|u8|u16|u32|u64|x8|x16|x32|x64|size_t|atomic_t|bool|blob|regset32|u32_array)", 2],
+	["proc_create(?:_data|)", 2],
+	["(?:CLASS|DEVICE|SENSOR|SENSOR_DEVICE|IIO_DEVICE)_ATTR", 2],
+	["IIO_DEV_ATTR_[A-Z_]+", 1],
+	["SENSOR_(?:DEVICE_|)ATTR_2", 2],
+	["SENSOR_TEMPLATE(?:_2|)", 3],
+	["__ATTR", 2],
+);
+
+#Create a search pattern for all these functions to speed up a loop below
+our $mode_perms_search = "";
+foreach my $entry (@mode_permission_funcs) {
+	$mode_perms_search .= '|' if ($mode_perms_search ne "");
+	$mode_perms_search .= $entry->[0];
+}
+
+our $mode_perms_world_writable = qr{
+	S_IWUGO		|
+	S_IWOTH		|
+	S_IRWXUGO	|
+	S_IALLUGO	|
+	0[0-7][0-7][2367]
+}x;
+
+our %mode_permission_string_types = (
+	"S_IRWXU" => 0700,
+	"S_IRUSR" => 0400,
+	"S_IWUSR" => 0200,
+	"S_IXUSR" => 0100,
+	"S_IRWXG" => 0070,
+	"S_IRGRP" => 0040,
+	"S_IWGRP" => 0020,
+	"S_IXGRP" => 0010,
+	"S_IRWXO" => 0007,
+	"S_IROTH" => 0004,
+	"S_IWOTH" => 0002,
+	"S_IXOTH" => 0001,
+	"S_IRWXUGO" => 0777,
+	"S_IRUGO" => 0444,
+	"S_IWUGO" => 0222,
+	"S_IXUGO" => 0111,
+);
+
+#Create a search pattern for all these strings to speed up a loop below
+our $mode_perms_string_search = "";
+foreach my $entry (keys %mode_permission_string_types) {
+	$mode_perms_string_search .= '|' if ($mode_perms_string_search ne "");
+	$mode_perms_string_search .= $entry;
+}
 
 our $allowed_asm_includes = qr{(?x:
 	irq|
-	memory
+	memory|
+	time|
+	reboot
 )};
 # memory.h: ARM has a custom one
 
@@ -447,12 +656,54 @@ if ($codespell) {
 
 $misspellings = join("|", sort keys %spelling_fix) if keys %spelling_fix;
 
+sub read_words {
+	my ($wordsRef, $file) = @_;
+
+	if (open(my $words, '<', $file)) {
+		while (<$words>) {
+			my $line = $_;
+
+			$line =~ s/\s*\n?$//g;
+			$line =~ s/^\s*//g;
+
+			next if ($line =~ m/^\s*#/);
+			next if ($line =~ m/^\s*$/);
+			if ($line =~ /\s/) {
+				print("$file: '$line' invalid - ignored\n");
+				next;
+			}
+
+			$$wordsRef .= '|' if ($$wordsRef ne "");
+			$$wordsRef .= $line;
+		}
+		close($file);
+		return 1;
+	}
+
+	return 0;
+}
+
+my $const_structs = "";
+read_words(\$const_structs, $conststructsfile)
+    or warn "No structs that should be const will be found - file '$conststructsfile': $!\n";
+
+my $typeOtherTypedefs = "";
+if (length($typedefsfile)) {
+	read_words(\$typeOtherTypedefs, $typedefsfile)
+	    or warn "No additional types will be considered - file '$typedefsfile': $!\n";
+}
+$typeTypedefs .= '|' . $typeOtherTypedefs if ($typeOtherTypedefs ne "");
 
 sub build_types {
-	my $mods = "(?x:  \n" . join("|\n  ", @modifierList) . "\n)";
-	my $all = "(?x:  \n" . join("|\n  ", @typeList) . "\n)";
+	my $mods = "(?x:  \n" . join("|\n  ", (@modifierList, @modifierListFile)) . "\n)";
+	my $all = "(?x:  \n" . join("|\n  ", (@typeList, @typeListFile)) . "\n)";
+	my $Misordered = "(?x:  \n" . join("|\n  ", @typeListMisordered) . "\n)";
 	my $allWithAttr = "(?x:  \n" . join("|\n  ", @typeListWithAttr) . "\n)";
 	$Modifier	= qr{(?:$Attribute|$Sparse|$mods)};
+	$BasicType	= qr{
+				(?:$typeTypedefs\b)|
+				(?:${all}\b)
+		}x;
 	$NonptrType	= qr{
 			(?:$Modifier\s+|const\s+)*
 			(?:
@@ -462,6 +713,13 @@ sub build_types {
 			)
 			(?:\s+$Modifier|\s+const)*
 		  }x;
+	$NonptrTypeMisordered	= qr{
+			(?:$Modifier\s+|const\s+)*
+			(?:
+				(?:${Misordered}\b)
+			)
+			(?:\s+$Modifier|\s+const)*
+		  }x;
 	$NonptrTypeWithAttr	= qr{
 			(?:$Modifier\s+|const\s+)*
 			(?:
@@ -473,10 +731,16 @@ sub build_types {
 		  }x;
 	$Type	= qr{
 			$NonptrType
-			(?:(?:\s|\*|\[\])+\s*const|(?:\s|\*|\[\])+|(?:\s*\[\s*\])+)?
+			(?:(?:\s|\*|\[\])+\s*const|(?:\s|\*\s*(?:const\s*)?|\[\])+|(?:\s*\[\s*\])+)?
+			(?:\s+$Inline|\s+$Modifier)*
+		  }x;
+	$TypeMisordered	= qr{
+			$NonptrTypeMisordered
+			(?:(?:\s|\*|\[\])+\s*const|(?:\s|\*\s*(?:const\s*)?|\[\])+|(?:\s*\[\s*\])+)?
 			(?:\s+$Inline|\s+$Modifier)*
 		  }x;
-	$Declare	= qr{(?:$Storage\s+)?$Type};
+	$Declare	= qr{(?:$Storage\s+(?:$Inline\s+)?)?$Type};
+	$DeclareMisordered	= qr{(?:$Storage\s+(?:$Inline\s+)?)?$TypeMisordered};
 }
 build_types();
 
@@ -487,15 +751,26 @@ our $Typecast	= qr{\s*(\(\s*$NonptrType\s*\)){0,1}\s*};
 # Any use must be runtime checked with $^V
 
 our $balanced_parens = qr/(\((?:[^\(\)]++|(?-1))*\))/;
-our $LvalOrFunc	= qr{($Lval)\s*($balanced_parens{0,1})\s*};
-our $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant)};
+our $LvalOrFunc	= qr{((?:[\&\*]\s*)?$Lval)\s*($balanced_parens{0,1})\s*};
+our $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant|$String)};
+
+our $declaration_macros = qr{(?x:
+	(?:$Storage\s+)?(?:[A-Z_][A-Z0-9]*_){0,2}(?:DEFINE|DECLARE)(?:_[A-Z0-9]+){1,6}\s*\(|
+	(?:$Storage\s+)?[HLP]?LIST_HEAD\s*\(|
+	(?:$Storage\s+)?${Type}\s+uninitialized_var\s*\(
+)};
 
 sub deparenthesize {
 	my ($string) = @_;
 	return "" if (!defined($string));
-	$string =~ s@^\s*\(\s*@@g;
-	$string =~ s@\s*\)\s*$@@g;
+
+	while ($string =~ /^\s*\(.*\)\s*$/) {
+		$string =~ s@^\s*\(\s*@@;
+		$string =~ s@\s*\)\s*$@@;
+	}
+
 	$string =~ s@\s+@ @g;
+
 	return $string;
 }
 
@@ -525,6 +800,16 @@ sub seed_camelcase_file {
 	}
 }
 
+sub is_maintained_obsolete {
+	my ($filename) = @_;
+
+	return 0 if (!$tree || !(-e "$root/scripts/get_maintainer.pl"));
+
+	my $status = `perl $root/scripts/get_maintainer.pl --status --nom --nol --nogit --nogit-fallback -f $filename 2>&1`;
+
+	return $status =~ /obsolete/i;
+}
+
 my $camelcase_seeded = 0;
 sub seed_camelcase_includes {
 	return if ($camelcase_seeded);
@@ -583,17 +868,82 @@ sub seed_camelcase_includes {
 	}
 }
 
+sub git_commit_info {
+	my ($commit, $id, $desc) = @_;
+
+	return ($id, $desc) if ((which("git") eq "") || !(-e ".git"));
+
+	my $output = `git log --no-color --format='%H %s' -1 $commit 2>&1`;
+	$output =~ s/^\s*//gm;
+	my @lines = split("\n", $output);
+
+	return ($id, $desc) if ($#lines < 0);
+
+	if ($lines[0] =~ /^error: short SHA1 $commit is ambiguous\./) {
+# Maybe one day convert this block of bash into something that returns
+# all matching commit ids, but it's very slow...
+#
+#		echo "checking commits $1..."
+#		git rev-list --remotes | grep -i "^$1" |
+#		while read line ; do
+#		    git log --format='%H %s' -1 $line |
+#		    echo "commit $(cut -c 1-12,41-)"
+#		done
+	} elsif ($lines[0] =~ /^fatal: ambiguous argument '$commit': unknown revision or path not in the working tree\./) {
+		$id = undef;
+	} else {
+		$id = substr($lines[0], 0, 12);
+		$desc = substr($lines[0], 41);
+	}
+
+	return ($id, $desc);
+}
+
 $chk_signoff = 0 if ($file);
 
 my @rawlines = ();
 my @lines = ();
 my @fixed = ();
-my $vname;
+my @fixed_inserted = ();
+my @fixed_deleted = ();
 my $fixlinenr = -1;
 
+# If input is git commits, extract all commits from the commit expressions.
+# For example, HEAD-3 means we need check 'HEAD, HEAD~1, HEAD~2'.
+die "$P: No git repository found\n" if ($git && !-e ".git");
+
+if ($git) {
+	my @commits = ();
+	foreach my $commit_expr (@ARGV) {
+		my $git_range;
+		if ($commit_expr =~ m/^(.*)-(\d+)$/) {
+			$git_range = "-$2 $1";
+		} elsif ($commit_expr =~ m/\.\./) {
+			$git_range = "$commit_expr";
+		} else {
+			$git_range = "-1 $commit_expr";
+		}
+		my $lines = `git log --no-color --no-merges --pretty=format:'%H %s' $git_range`;
+		foreach my $line (split(/\n/, $lines)) {
+			$line =~ /^([0-9a-fA-F]{40,40}) (.*)$/;
+			next if (!defined($1) || !defined($2));
+			my $sha1 = $1;
+			my $subject = $2;
+			unshift(@commits, $sha1);
+			$git_commits{$sha1} = $subject;
+		}
+	}
+	die "$P: no git commits after extraction!\n" if (@commits == 0);
+	@ARGV = @commits;
+}
+
+my $vname;
 for my $filename (@ARGV) {
 	my $FILE;
-	if ($file) {
+	if ($git) {
+		open($FILE, '-|', "git format-patch -M --stdout -1 $filename") ||
+			die "$P: $filename: git format-patch failed - $!\n";
+	} elsif ($file) {
 		open($FILE, '-|', "diff -u /dev/null $filename") ||
 			die "$P: $filename: diff failed - $!\n";
 	} elsif ($filename eq '-') {
@@ -604,6 +954,8 @@ for my $filename (@ARGV) {
 	}
 	if ($filename eq '-') {
 		$vname = 'Your patch';
+	} elsif ($git) {
+		$vname = "Commit " . substr($filename, 0, 12) . ' ("' . $git_commits{$filename} . '")';
 	} else {
 		$vname = $filename;
 	}
@@ -612,12 +964,45 @@ for my $filename (@ARGV) {
 		push(@rawlines, $_);
 	}
 	close($FILE);
+
+	if ($#ARGV > 0 && $quiet == 0) {
+		print '-' x length($vname) . "\n";
+		print "$vname\n";
+		print '-' x length($vname) . "\n";
+	}
+
 	if (!process($filename)) {
 		$exit = 1;
 	}
 	@rawlines = ();
 	@lines = ();
 	@fixed = ();
+	@fixed_inserted = ();
+	@fixed_deleted = ();
+	$fixlinenr = -1;
+	@modifierListFile = ();
+	@typeListFile = ();
+	build_types();
+}
+
+if (!$quiet) {
+	hash_show_words(\%use_type, "Used");
+	hash_show_words(\%ignore_type, "Ignored");
+
+	if ($^V lt 5.10.0) {
+		print << "EOM"
+
+NOTE: perl $^V is not modern enough to detect all possible issues.
+      An upgrade to at least perl v5.10.0 is suggested.
+EOM
+	}
+	if ($exit) {
+		print << "EOM"
+
+NOTE: If any of the errors are false positives, please report
+      them to the maintainer, see CHECKPATCH in MAINTAINERS.
+EOM
+	}
 }
 
 exit($exit);
@@ -709,6 +1094,18 @@ sub format_email {
 	return $formatted_email;
 }
 
+sub which {
+	my ($bin) = @_;
+
+	foreach my $path (split(/:/, $ENV{PATH})) {
+		if (-e "$path/$bin") {
+			return "$path/$bin";
+		}
+	}
+
+	return "";
+}
+
 sub which_conf {
 	my ($conf) = @_;
 
@@ -855,13 +1252,18 @@ sub sanitise_line {
 		$res =~ s@(\#\s*(?:error|warning)\s+).*@$1$clean@;
 	}
 
+	if ($allow_c99_comments && $res =~ m@(//.*$)@) {
+		my $match = $1;
+		$res =~ s/\Q$match\E/"$;" x length($match)/e;
+	}
+
 	return $res;
 }
 
 sub get_quoted_string {
 	my ($line, $rawline) = @_;
 
-	return "" if ($line !~ m/(\"[X]+\")/g);
+	return "" if ($line !~ m/($String)/g);
 	return substr($rawline, $-[0], $+[0] - $-[0]);
 }
 
@@ -1470,13 +1872,13 @@ sub possible {
 			for my $modifier (split(' ', $possible)) {
 				if ($modifier !~ $notPermitted) {
 					warn "MODIFIER: $modifier ($possible) ($line)\n" if ($dbg_possible);
-					push(@modifierList, $modifier);
+					push(@modifierListFile, $modifier);
 				}
 			}
 
 		} else {
 			warn "POSSIBLE: $possible ($line)\n" if ($dbg_possible);
-			push(@typeList, $possible);
+			push(@typeListFile, $possible);
 		}
 		build_types();
 	} else {
@@ -1487,34 +1889,144 @@ sub possible {
 my $prefix = '';
 
 sub show_type {
-	return defined $use_type{$_[0]} if (scalar keys %use_type > 0);
+	my ($type) = @_;
+
+	$type =~ tr/[a-z]/[A-Z]/;
 
-	return !defined $ignore_type{$_[0]};
+	return defined $use_type{$type} if (scalar keys %use_type > 0);
+
+	return !defined $ignore_type{$type};
 }
 
 sub report {
-	if (!show_type($_[1]) ||
-	    (defined $tst_only && $_[2] !~ /\Q$tst_only\E/)) {
+	my ($level, $type, $msg) = @_;
+
+	if (!show_type($type) ||
+	    (defined $tst_only && $msg !~ /\Q$tst_only\E/)) {
 		return 0;
 	}
-	my $line;
+	my $output = '';
+	if ($color) {
+		if ($level eq 'ERROR') {
+			$output .= RED;
+		} elsif ($level eq 'WARNING') {
+			$output .= YELLOW;
+		} else {
+			$output .= GREEN;
+		}
+	}
+	$output .= $prefix . $level . ':';
 	if ($show_types) {
-		$line = "$prefix$_[0]:$_[1]: $_[2]\n";
-	} else {
-		$line = "$prefix$_[0]: $_[2]\n";
+		$output .= BLUE if ($color);
+		$output .= "$type:";
+	}
+	$output .= RESET if ($color);
+	$output .= ' ' . $msg . "\n";
+
+	if ($showfile) {
+		my @lines = split("\n", $output, -1);
+		splice(@lines, 1, 1);
+		$output = join("\n", @lines);
 	}
-	$line = (split('\n', $line))[0] . "\n" if ($terse);
+	$output = (split('\n', $output))[0] . "\n" if ($terse);
 
-	push(our @report, $line);
+	push(our @report, $output);
 
 	return 1;
 }
+
 sub report_dump {
 	our @report;
 }
 
+sub fixup_current_range {
+	my ($lineRef, $offset, $length) = @_;
+
+	if ($$lineRef =~ /^\@\@ -\d+,\d+ \+(\d+),(\d+) \@\@/) {
+		my $o = $1;
+		my $l = $2;
+		my $no = $o + $offset;
+		my $nl = $l + $length;
+		$$lineRef =~ s/\+$o,$l \@\@/\+$no,$nl \@\@/;
+	}
+}
+
+sub fix_inserted_deleted_lines {
+	my ($linesRef, $insertedRef, $deletedRef) = @_;
+
+	my $range_last_linenr = 0;
+	my $delta_offset = 0;
+
+	my $old_linenr = 0;
+	my $new_linenr = 0;
+
+	my $next_insert = 0;
+	my $next_delete = 0;
+
+	my @lines = ();
+
+	my $inserted = @{$insertedRef}[$next_insert++];
+	my $deleted = @{$deletedRef}[$next_delete++];
+
+	foreach my $old_line (@{$linesRef}) {
+		my $save_line = 1;
+		my $line = $old_line;	#don't modify the array
+		if ($line =~ /^(?:\+\+\+|\-\-\-)\s+\S+/) {	#new filename
+			$delta_offset = 0;
+		} elsif ($line =~ /^\@\@ -\d+,\d+ \+\d+,\d+ \@\@/) {	#new hunk
+			$range_last_linenr = $new_linenr;
+			fixup_current_range(\$line, $delta_offset, 0);
+		}
+
+		while (defined($deleted) && ${$deleted}{'LINENR'} == $old_linenr) {
+			$deleted = @{$deletedRef}[$next_delete++];
+			$save_line = 0;
+			fixup_current_range(\$lines[$range_last_linenr], $delta_offset--, -1);
+		}
+
+		while (defined($inserted) && ${$inserted}{'LINENR'} == $old_linenr) {
+			push(@lines, ${$inserted}{'LINE'});
+			$inserted = @{$insertedRef}[$next_insert++];
+			$new_linenr++;
+			fixup_current_range(\$lines[$range_last_linenr], $delta_offset++, 1);
+		}
+
+		if ($save_line) {
+			push(@lines, $line);
+			$new_linenr++;
+		}
+
+		$old_linenr++;
+	}
+
+	return @lines;
+}
+
+sub fix_insert_line {
+	my ($linenr, $line) = @_;
+
+	my $inserted = {
+		LINENR => $linenr,
+		LINE => $line,
+	};
+	push(@fixed_inserted, $inserted);
+}
+
+sub fix_delete_line {
+	my ($linenr, $line) = @_;
+
+	my $deleted = {
+		LINENR => $linenr,
+		LINE => $line,
+	};
+
+	push(@fixed_deleted, $deleted);
+}
+
 sub ERROR {
-	if (report("ERROR", $_[0], $_[1])) {
+	my ($type, $msg) = @_;
+
+	if (report("ERROR", $type, $msg)) {
 		our $clean = 0;
 		our $cnt_error++;
 		return 1;
@@ -1522,7 +2034,9 @@ sub ERROR {
 	return 0;
 }
 sub WARN {
-	if (report("WARNING", $_[0], $_[1])) {
+	my ($type, $msg) = @_;
+
+	if (report("WARNING", $type, $msg)) {
 		our $clean = 0;
 		our $cnt_warn++;
 		return 1;
@@ -1530,7 +2044,9 @@ sub WARN {
 	return 0;
 }
 sub CHK {
-	if ($check && report("CHECK", $_[0], $_[1])) {
+	my ($type, $msg) = @_;
+
+	if ($check && report("CHECK", $type, $msg)) {
 		our $clean = 0;
 		our $cnt_chk++;
 		return 1;
@@ -1640,7 +2156,7 @@ sub pos_last_openparen {
 		}
 	}
 
-	return $last_openparen + 1;
+	return length(expand_tabs(substr($line, 0, $last_openparen))) + 1;
 }
 
 sub process {
@@ -1660,12 +2176,18 @@ sub process {
 	our $clean = 1;
 	my $signoff = 0;
 	my $is_patch = 0;
-
-	my $in_header_lines = 1;
+	my $in_header_lines = $file ? 0 : 1;
 	my $in_commit_log = 0;		#Scanning lines before patch
-
+	my $has_commit_log = 0;		#Encountered lines before patch
+	my $commit_log_possible_stack_dump = 0;
+	my $commit_log_long_line = 0;
+	my $commit_log_has_diff = 0;
+	my $reported_maintainer_file = 0;
 	my $non_utf8_charset = 0;
 
+	my $last_blank_line = 0;
+	my $last_coalesced_string_linenr = -1;
+
 	our @report = ();
 	our $cnt_lines = 0;
 	our $cnt_error = 0;
@@ -1677,6 +2199,7 @@ sub process {
 	my $realline = 0;
 	my $realcnt = 0;
 	my $here = '';
+	my $context_function;		#undef'd unless there's a known function
 	my $in_comment = 0;
 	my $comment_edge = 0;
 	my $first_line = 0;
@@ -1710,12 +2233,12 @@ sub process {
 
 		if ($rawline=~/^\+\+\+\s+(\S+)/) {
 			$setup_docs = 0;
-			if ($1 =~ m@Documentation/kernel-parameters.txt$@) {
+			if ($1 =~ m@Documentation/admin-guide/kernel-parameters.rst$@) {
 				$setup_docs = 1;
 			}
 			#next;
 		}
-		if ($rawline=~/^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@/) {
+		if ($rawline =~ /^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@/) {
 			$realline=$1-1;
 			if (defined $2) {
 				$realcnt=$3+1;
@@ -1783,15 +2306,19 @@ sub process {
 
 	$realcnt = 0;
 	$linenr = 0;
+	$fixlinenr = -1;
 	foreach my $line (@lines) {
 		$linenr++;
+		$fixlinenr++;
 		my $sline = $line;	#copy of $line
 		$sline =~ s/$;/ /g;	#with comments as spaces
 
 		my $rawline = $rawlines[$linenr - 1];
 
 #extract the line range in the file after the patch is applied
-		if ($line=~/^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@/) {
+		if (!$in_commit_log &&
+		    $line =~ /^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@(.*)/) {
+			my $context = $4;
 			$is_patch = 1;
 			$first_line = $linenr + 1;
 			$realline=$1-1;
@@ -1807,6 +2334,11 @@ sub process {
 			%suppress_whiletrailers = ();
 			%suppress_export = ();
 			$suppress_statement = 0;
+			if ($context =~ /\b(\w+)\s*\(/) {
+				$context_function = $1;
+			} else {
+				undef $context_function;
+			}
 			next;
 
 # track the line number as we move through the hunk, note that
@@ -1832,18 +2364,16 @@ sub process {
 
 		my $hunk_line = ($realcnt != 0);
 
-#make up the handle for any error we report on this line
-		$prefix = "$filename:$realline: " if ($emacs && $file);
-		$prefix = "$filename:$linenr: " if ($emacs && !$file);
-
 		$here = "#$linenr: " if (!$file);
 		$here = "#$realline: " if ($file);
 
+		my $found_file = 0;
 		# extract the filename as it passes
 		if ($line =~ /^diff --git.*?(\S+)$/) {
 			$realfile = $1;
 			$realfile =~ s@^([^/]*)/@@ if (!$file);
 			$in_commit_log = 0;
+			$found_file = 1;
 		} elsif ($line =~ /^\+\+\+\s+(\S+)/) {
 			$realfile = $1;
 			$realfile =~ s@^([^/]*)/@@ if (!$file);
@@ -1860,6 +2390,30 @@ sub process {
 				ERROR("MODIFIED_INCLUDE_ASM",
 				      "do not modify files in include/asm, change architecture specific files in include/asm-<architecture>\n" . "$here$rawline\n");
 			}
+			$found_file = 1;
+		}
+
+#make up the handle for any error we report on this line
+		if ($showfile) {
+			$prefix = "$realfile:$realline: "
+		} elsif ($emacs) {
+			if ($file) {
+				$prefix = "$filename:$realline: ";
+			} else {
+				$prefix = "$filename:$linenr: ";
+			}
+		}
+
+		if ($found_file) {
+			if (is_maintained_obsolete($realfile)) {
+				WARN("OBSOLETE",
+				     "$realfile is marked as 'obsolete' in the MAINTAINERS hierarchy.  No unnecessary modifications please.\n");
+			}
+			if ($realfile =~ m@^(?:drivers/net/|net/|drivers/staging/)@) {
+				$check = 1;
+			} else {
+				$check = $check_orig;
+			}
 			next;
 		}
 
@@ -1871,6 +2425,17 @@ sub process {
 
 		$cnt_lines++ if ($realcnt != 0);
 
+# Check if the commit log has what seems like a diff which can confuse patch
+		if ($in_commit_log && !$commit_log_has_diff &&
+		    (($line =~ m@^\s+diff\b.*a/[\w/]+@ &&
+		      $line =~ m@^\s+diff\b.*a/([\w/]+)\s+b/$1\b@) ||
+		     $line =~ m@^\s*(?:\-\-\-\s+a/|\+\+\+\s+b/)@ ||
+		     $line =~ m/^\s*\@\@ \-\d+,\d+ \+\d+,\d+ \@\@/)) {
+			ERROR("DIFF_IN_COMMIT_MSG",
+			      "Avoid using diff content in the commit message - patch(1) might not work\n" . $herecurr);
+			$commit_log_has_diff = 1;
+		}
+
 # Check for incorrect file permissions
 		if ($line =~ /^new (file )?mode.*[7531]\d{0,2}$/) {
 			my $permhere = $here . "FILE: $realfile\n";
@@ -1887,6 +2452,12 @@ sub process {
 			$in_commit_log = 0;
 		}
 
+# Check if MAINTAINERS is being updated.  If so, there's probably no need to
+# emit the "does MAINTAINERS need updating?" message on file add/move/delete
+		if ($line =~ /^\s*MAINTAINERS\s*\|/) {
+			$reported_maintainer_file = 1;
+		}
+
 # Check signature styles
 		if (!$in_header_lines &&
 		    $line =~ /^(\s*)([a-z0-9_-]+by:|$signature_tags)(\s*)(.*)/i) {
@@ -1904,7 +2475,7 @@ sub process {
 				if (WARN("BAD_SIGN_OFF",
 					 "Do not use whitespace before $ucfirst_sign_off\n" . $herecurr) &&
 				    $fix) {
-					$fixed[$linenr - 1] =
+					$fixed[$fixlinenr] =
 					    "$ucfirst_sign_off $email";
 				}
 			}
@@ -1912,7 +2483,7 @@ sub process {
 				if (WARN("BAD_SIGN_OFF",
 					 "'$ucfirst_sign_off' is the preferred signature form\n" . $herecurr) &&
 				    $fix) {
-					$fixed[$linenr - 1] =
+					$fixed[$fixlinenr] =
 					    "$ucfirst_sign_off $email";
 				}
 
@@ -1921,7 +2492,7 @@ sub process {
 				if (WARN("BAD_SIGN_OFF",
 					 "Use a single space after $ucfirst_sign_off\n" . $herecurr) &&
 				    $fix) {
-					$fixed[$linenr - 1] =
+					$fixed[$fixlinenr] =
 					    "$ucfirst_sign_off $email";
 				}
 			}
@@ -1957,6 +2528,127 @@ sub process {
 			}
 		}
 
+# Check email subject for common tools that don't need to be mentioned
+		if ($in_header_lines &&
+		    $line =~ /^Subject:.*\b(?:checkpatch|sparse|smatch)\b[^:]/i) {
+			WARN("EMAIL_SUBJECT",
+			     "A patch subject line should describe the change not the tool that found it\n" . $herecurr);
+		}
+
+# Check for old stable address
+		if ($line =~ /^\s*cc:\s*.*<?\bstable\@kernel\.org\b>?.*$/i) {
+			ERROR("STABLE_ADDRESS",
+			      "The 'stable' address should be 'stable\@vger.kernel.org'\n" . $herecurr);
+		}
+
+# Check for unwanted Gerrit info
+		if ($in_commit_log && $line =~ /^\s*change-id:/i) {
+			ERROR("GERRIT_CHANGE_ID",
+			      "Remove Gerrit Change-Id's before submitting upstream.\n" . $herecurr);
+		}
+
+# Check if the commit log is in a possible stack dump
+		if ($in_commit_log && !$commit_log_possible_stack_dump &&
+		    ($line =~ /^\s*(?:WARNING:|BUG:)/ ||
+		     $line =~ /^\s*\[\s*\d+\.\d{6,6}\s*\]/ ||
+					# timestamp
+		     $line =~ /^\s*\[\<[0-9a-fA-F]{8,}\>\]/)) {
+					# stack dump address
+			$commit_log_possible_stack_dump = 1;
+		}
+
+# Check for line lengths > 75 in commit log, warn once
+		if ($in_commit_log && !$commit_log_long_line &&
+		    length($line) > 75 &&
+		    !($line =~ /^\s*[a-zA-Z0-9_\/\.]+\s+\|\s+\d+/ ||
+					# file delta changes
+		      $line =~ /^\s*(?:[\w\.\-]+\/)++[\w\.\-]+:/ ||
+					# filename then :
+		      $line =~ /^\s*(?:Fixes:|Link:)/i ||
+					# A Fixes: or Link: line
+		      $commit_log_possible_stack_dump)) {
+			WARN("COMMIT_LOG_LONG_LINE",
+			     "Possible unwrapped commit description (prefer a maximum 75 chars per line)\n" . $herecurr);
+			$commit_log_long_line = 1;
+		}
+
+# Reset possible stack dump if a blank line is found
+		if ($in_commit_log && $commit_log_possible_stack_dump &&
+		    $line =~ /^\s*$/) {
+			$commit_log_possible_stack_dump = 0;
+		}
+
+# Check for git id commit length and improperly formed commit descriptions
+		if ($in_commit_log && !$commit_log_possible_stack_dump &&
+		    $line !~ /^\s*(?:Link|Patchwork|http|https|BugLink):/i &&
+		    $line !~ /^This reverts commit [0-9a-f]{7,40}/ &&
+		    ($line =~ /\bcommit\s+[0-9a-f]{5,}\b/i ||
+		     ($line =~ /(?:\s|^)[0-9a-f]{12,40}(?:[\s"'\(\[]|$)/i &&
+		      $line !~ /[\<\[][0-9a-f]{12,40}[\>\]]/i &&
+		      $line !~ /\bfixes:\s*[0-9a-f]{12,40}/i))) {
+			my $init_char = "c";
+			my $orig_commit = "";
+			my $short = 1;
+			my $long = 0;
+			my $case = 1;
+			my $space = 1;
+			my $hasdesc = 0;
+			my $hasparens = 0;
+			my $id = '0123456789ab';
+			my $orig_desc = "commit description";
+			my $description = "";
+
+			if ($line =~ /\b(c)ommit\s+([0-9a-f]{5,})\b/i) {
+				$init_char = $1;
+				$orig_commit = lc($2);
+			} elsif ($line =~ /\b([0-9a-f]{12,40})\b/i) {
+				$orig_commit = lc($1);
+			}
+
+			$short = 0 if ($line =~ /\bcommit\s+[0-9a-f]{12,40}/i);
+			$long = 1 if ($line =~ /\bcommit\s+[0-9a-f]{41,}/i);
+			$space = 0 if ($line =~ /\bcommit [0-9a-f]/i);
+			$case = 0 if ($line =~ /\b[Cc]ommit\s+[0-9a-f]{5,40}[^A-F]/);
+			if ($line =~ /\bcommit\s+[0-9a-f]{5,}\s+\("([^"]+)"\)/i) {
+				$orig_desc = $1;
+				$hasparens = 1;
+			} elsif ($line =~ /\bcommit\s+[0-9a-f]{5,}\s*$/i &&
+				 defined $rawlines[$linenr] &&
+				 $rawlines[$linenr] =~ /^\s*\("([^"]+)"\)/) {
+				$orig_desc = $1;
+				$hasparens = 1;
+			} elsif ($line =~ /\bcommit\s+[0-9a-f]{5,}\s+\("[^"]+$/i &&
+				 defined $rawlines[$linenr] &&
+				 $rawlines[$linenr] =~ /^\s*[^"]+"\)/) {
+				$line =~ /\bcommit\s+[0-9a-f]{5,}\s+\("([^"]+)$/i;
+				$orig_desc = $1;
+				$rawlines[$linenr] =~ /^\s*([^"]+)"\)/;
+				$orig_desc .= " " . $1;
+				$hasparens = 1;
+			}
+
+			($id, $description) = git_commit_info($orig_commit,
+							      $id, $orig_desc);
+
+			if (defined($id) &&
+			   ($short || $long || $space || $case || ($orig_desc ne $description) || !$hasparens)) {
+				ERROR("GIT_COMMIT_ID",
+				      "Please use git commit description style 'commit <12+ chars of sha1> (\"<title line>\")' - ie: '${init_char}ommit $id (\"$description\")'\n" . $herecurr);
+			}
+		}
+
+# Check for added, moved or deleted files
+		if (!$reported_maintainer_file && !$in_commit_log &&
+		    ($line =~ /^(?:new|deleted) file mode\s*\d+\s*$/ ||
+		     $line =~ /^rename (?:from|to) [\w\/\.\-]+\s*$/ ||
+		     ($line =~ /\{\s*([\w\/\.\-]*)\s*\=\>\s*([\w\/\.\-]*)\s*\}/ &&
+		      (defined($1) || defined($2))))) {
+			$is_patch = 1;
+			$reported_maintainer_file = 1;
+			WARN("FILE_PATH_CHANGES",
+			     "added, moved or deleted file(s), does MAINTAINERS need updating?\n" . $herecurr);
+		}
+
 # Check for wrappage within a valid hunk of the file
 		if ($realcnt != 0 && $line !~ m{^(?:\+|-| |\\ No newline|$)}) {
 			ERROR("CORRUPTED_PATCH",
@@ -1964,20 +2656,6 @@ sub process {
 				$herecurr) if (!$emitted_corrupt++);
 		}
 
-# Check for absolute kernel paths.
-		if ($tree) {
-			while ($line =~ m{(?:^|\s)(/\S*)}g) {
-				my $file = $1;
-
-				if ($file =~ m{^(.*?)(?::\d+)+:?$} &&
-				    check_absolute_file($1, $herecurr)) {
-					#
-				} else {
-					check_absolute_file($file, $herecurr);
-				}
-			}
-		}
-
 # UTF-8 regex found at http://www.w3.org/International/questions/qa-forms-utf-8.en.php
 		if (($realfile =~ /^$/ || $line =~ /^\+/) &&
 		    $rawline !~ m/^$UTF8*$/) {
@@ -1994,9 +2672,11 @@ sub process {
 # Check if it's the start of a commit log
 # (not a header line and we haven't seen the patch filename)
 		if ($in_header_lines && $realfile =~ /^$/ &&
-		    $rawline !~ /^(commit\b|from\b|[\w-]+:).+$/i) {
+		    !($rawline =~ /^\s+(?:\S|$)/ ||
+		      $rawline =~ /^(?:commit\b|from\b|[\w-]+:)/i)) {
 			$in_header_lines = 0;
 			$in_commit_log = 1;
+			$has_commit_log = 1;
 		}
 
 # Check if there is UTF-8 in a commit log when a mail header has explicitly
@@ -2013,6 +2693,20 @@ sub process {
 			    "8-bit UTF-8 used in possible commit log\n" . $herecurr);
 		}
 
+# Check for absolute kernel paths in commit message
+		if ($tree && $in_commit_log) {
+			while ($line =~ m{(?:^|\s)(/\S*)}g) {
+				my $file = $1;
+
+				if ($file =~ m{^(.*?)(?::\d+)+:?$} &&
+				    check_absolute_file($1, $herecurr)) {
+					#
+				} else {
+					check_absolute_file($file, $herecurr);
+				}
+			}
+		}
+
 # Check for various typo / spelling mistakes
 		if (defined($misspellings) &&
 		    ($in_commit_log || $line =~ /^(?:\+|Subject:)/i)) {
@@ -2040,14 +2734,14 @@ sub process {
 			if (ERROR("DOS_LINE_ENDINGS",
 				  "DOS line endings\n" . $herevet) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/[\s\015]+$//;
+				$fixed[$fixlinenr] =~ s/[\s\015]+$//;
 			}
 		} elsif ($rawline =~ /^\+.*\S\s+$/ || $rawline =~ /^\+\s+$/) {
 			my $herevet = "$here\n" . cat_vet($rawline) . "\n";
 			if (ERROR("TRAILING_WHITESPACE",
 				  "trailing whitespace\n" . $herevet) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\s+$//;
+				$fixed[$fixlinenr] =~ s/\s+$//;
 			}
 
 			$rpt_cleaners = 1;
@@ -2055,6 +2749,7 @@ sub process {
 
 # Check for FSF mailing addresses.
 		if ($rawline =~ /\bwrite to the Free/i ||
+		    $rawline =~ /\b675\s+Mass\s+Ave/i ||
 		    $rawline =~ /\b59\s+Temple\s+Pl/i ||
 		    $rawline =~ /\b51\s+Franklin\s+St/i) {
 			my $herevet = "$here\n" . cat_vet($rawline) . "\n";
@@ -2068,7 +2763,7 @@ sub process {
 # Only applies when adding the entry originally, after that we do not have
 # sufficient context to determine whether it is indeed long enough.
 		if ($realfile =~ /Kconfig/ &&
-		    $line =~ /.\s*config\s+/) {
+		    $line =~ /^\+\s*config\s+/) {
 			my $length = 0;
 			my $cnt = $realcnt;
 			my $ln = $linenr + 1;
@@ -2081,10 +2776,11 @@ sub process {
 				$is_end = $lines[$ln - 1] =~ /^\+/;
 
 				next if ($f =~ /^-/);
+				last if (!$file && $f =~ /^\@\@/);
 
-				if ($lines[$ln - 1] =~ /.\s*(?:bool|tristate)\s*\"/) {
+				if ($lines[$ln - 1] =~ /^\+\s*(?:bool|tristate)\s*\"/) {
 					$is_start = 1;
-				} elsif ($lines[$ln - 1] =~ /.\s*(?:---)?help(?:---)?$/) {
+				} elsif ($lines[$ln - 1] =~ /^\+\s*(?:---)?help(?:---)?$/) {
 					$length = -1;
 				}
 
@@ -2098,16 +2794,29 @@ sub process {
 				}
 				$length++;
 			}
-			WARN("CONFIG_DESCRIPTION",
-			     "please write a paragraph that describes the config symbol fully\n" . $herecurr) if ($is_start && $is_end && $length < 4);
+			if ($is_start && $is_end && $length < $min_conf_desc_length) {
+				WARN("CONFIG_DESCRIPTION",
+				     "please write a paragraph that describes the config symbol fully\n" . $herecurr);
+			}
 			#print "is_start<$is_start> is_end<$is_end> length<$length>\n";
 		}
 
-# discourage the addition of CONFIG_EXPERIMENTAL in Kconfig.
+# check for MAINTAINERS entries that don't have the right form
+		if ($realfile =~ /^MAINTAINERS$/ &&
+		    $rawline =~ /^\+[A-Z]:/ &&
+		    $rawline !~ /^\+[A-Z]:\t\S/) {
+			if (WARN("MAINTAINERS_STYLE",
+				 "MAINTAINERS entries use one tab after TYPE:\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/^(\+[A-Z]):\s*/$1:\t/;
+			}
+		}
+
+# discourage the use of boolean for type definition attributes of Kconfig options
 		if ($realfile =~ /Kconfig/ &&
-		    $line =~ /.\s*depends on\s+.*\bEXPERIMENTAL\b/) {
-			WARN("CONFIG_EXPERIMENTAL",
-			     "Use of CONFIG_EXPERIMENTAL is deprecated. For alternatives, see https://lkml.org/lkml/2012/10/23/580\n");
+		    $line =~ /^\+\s*\bboolean\b/) {
+			WARN("CONFIG_TYPE_BOOLEAN",
+			     "Use of boolean is deprecated, please use bool instead.\n" . $herecurr);
 		}
 
 		if (($realfile =~ /Makefile.*/ || $realfile =~ /Kbuild.*/) &&
@@ -2125,65 +2834,93 @@ sub process {
 		}
 
 # check for DT compatible documentation
-		if (defined $root && $realfile =~ /\.dts/ &&
-		    $rawline =~ /^\+\s*compatible\s*=/) {
+		if (defined $root &&
+			(($realfile =~ /\.dtsi?$/ && $line =~ /^\+\s*compatible\s*=\s*\"/) ||
+			 ($realfile =~ /\.[ch]$/ && $line =~ /^\+.*\.compatible\s*=\s*\"/))) {
+
 			my @compats = $rawline =~ /\"([a-zA-Z0-9\-\,\.\+_]+)\"/g;
 
+			my $dt_path = $root . "/Documentation/devicetree/bindings/";
+			my $vp_file = $dt_path . "vendor-prefixes.txt";
+
 			foreach my $compat (@compats) {
 				my $compat2 = $compat;
-				my $dt_path =  $root . "/Documentation/devicetree/bindings/";
-				$compat2 =~ s/\,[a-z]*\-/\,<\.\*>\-/;
-				`grep -Erq "$compat|$compat2" $dt_path`;
+				$compat2 =~ s/\,[a-zA-Z0-9]*\-/\,<\.\*>\-/;
+				my $compat3 = $compat;
+				$compat3 =~ s/\,([a-z]*)[0-9]*\-/\,$1<\.\*>\-/;
+				`grep -Erq "$compat|$compat2|$compat3" $dt_path`;
 				if ( $? >> 8 ) {
 					WARN("UNDOCUMENTED_DT_STRING",
 					     "DT compatible string \"$compat\" appears un-documented -- check $dt_path\n" . $herecurr);
 				}
 
-				my $vendor = $compat;
-				my $vendor_path = $dt_path . "vendor-prefixes.txt";
-				next if (! -f $vendor_path);
-				$vendor =~ s/^([a-zA-Z0-9]+)\,.*/$1/;
-				`grep -Eq "$vendor" $vendor_path`;
+				next if $compat !~ /^([a-zA-Z0-9\-]+)\,/;
+				my $vendor = $1;
+				`grep -Eq "^$vendor\\b" $vp_file`;
 				if ( $? >> 8 ) {
 					WARN("UNDOCUMENTED_DT_STRING",
-					     "DT compatible string vendor \"$vendor\" appears un-documented -- check $vendor_path\n" . $herecurr);
+					     "DT compatible string vendor \"$vendor\" appears un-documented -- check $vp_file\n" . $herecurr);
 				}
 			}
 		}
 
 # check we are in a valid source file if not then ignore this hunk
-		next if ($realfile !~ /\.(h|c|s|S|pl|sh)$/);
-
-#line length limit
-		if ($line =~ /^\+/ && $prevrawline !~ /\/\*\*/ &&
-		    $rawline !~ /^.\s*\*\s*\@$Ident\s/ &&
-		    !($line =~ /^\+\s*$logFunctions\s*\(\s*(?:(KERN_\S+\s*|[^"]*))?"[X\t]*"\s*(?:|,|\)\s*;)\s*$/ ||
-		    $line =~ /^\+\s*"[^"]*"\s*(?:\s*|,|\)\s*;)\s*$/) &&
-		    $length > $max_line_length)
-		{
-			WARN("LONG_LINE",
-			     "line over $max_line_length characters\n" . $herecurr);
-		}
+		next if ($realfile !~ /\.(h|c|s|S|sh|dtsi|dts)$/);
 
-# Check for user-visible strings broken across lines, which breaks the ability
-# to grep for the string.  Make exceptions when the previous string ends in a
-# newline (multiple lines in one string constant) or '\t', '\r', ';', or '{'
-# (common in inline assembly) or is a octal \123 or hexadecimal \xaf value
-		if ($line =~ /^\+\s*"/ &&
-		    $prevline =~ /"\s*$/ &&
-		    $prevrawline !~ /(?:\\(?:[ntr]|[0-7]{1,3}|x[0-9a-fA-F]{1,2})|;\s*|\{\s*)"\s*$/) {
-			WARN("SPLIT_STRING",
-			     "quoted string split across lines\n" . $hereprev);
-		}
+# line length limit (with some exclusions)
+#
+# There are a few types of lines that may extend beyond $max_line_length:
+#	logging functions like pr_info that end in a string
+#	lines with a single string
+#	#defines that are a single string
+#
+# There are 3 different line length message types:
+# LONG_LINE_COMMENT	a comment starts before but extends beyond $max_linelength
+# LONG_LINE_STRING	a string starts before but extends beyond $max_line_length
+# LONG_LINE		all other lines longer than $max_line_length
+#
+# if LONG_LINE is ignored, the other 2 types are also ignored
+#
 
-# check for spaces before a quoted newline
-		if ($rawline =~ /^.*\".*\s\\n/) {
-			if (WARN("QUOTED_WHITESPACE_BEFORE_NEWLINE",
-				 "unnecessary whitespace before a quoted newline\n" . $herecurr) &&
-			    $fix) {
-				$fixed[$linenr - 1] =~ s/^(\+.*\".*)\s+\\n/$1\\n/;
+		if ($line =~ /^\+/ && $length > $max_line_length) {
+			my $msg_type = "LONG_LINE";
+
+			# Check the allowed long line types first
+
+			# logging functions that end in a string that starts
+			# before $max_line_length
+			if ($line =~ /^\+\s*$logFunctions\s*\(\s*(?:(?:KERN_\S+\s*|[^"]*))?($String\s*(?:|,|\)\s*;)\s*)$/ &&
+			    length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {
+				$msg_type = "";
+
+			# lines with only strings (w/ possible termination)
+			# #defines with only strings
+			} elsif ($line =~ /^\+\s*$String\s*(?:\s*|,|\)\s*;)\s*$/ ||
+				 $line =~ /^\+\s*#\s*define\s+\w+\s+$String$/) {
+				$msg_type = "";
+
+			# EFI_GUID is another special case
+			} elsif ($line =~ /^\+.*\bEFI_GUID\s*\(/) {
+				$msg_type = "";
+
+			# Otherwise set the alternate message types
+
+			# a comment starts before $max_line_length
+			} elsif ($line =~ /($;[\s$;]*)$/ &&
+				 length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {
+				$msg_type = "LONG_LINE_COMMENT"
+
+			# a quoted string starts before $max_line_length
+			} elsif ($sline =~ /\s*($String(?:\s*(?:\\|,\s*|\)\s*;\s*))?)$/ &&
+				 length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {
+				$msg_type = "LONG_LINE_STRING"
 			}
 
+			if ($msg_type ne "" &&
+			    (show_type("LONG_LINE") || show_type($msg_type))) {
+				WARN($msg_type,
+				     "line over $max_line_length characters\n" . $herecurr);
+			}
 		}
 
 # check for adding lines without a newline.
@@ -2207,7 +2944,7 @@ sub process {
 		}
 
 # check we are in a valid source file C or perl if not then ignore this hunk
-		next if ($realfile !~ /\.(h|c|pl)$/);
+		next if ($realfile !~ /\.(h|c|pl|dtsi|dts)$/);
 
 # at the beginning of a line any tabs must come first and anything
 # more than 8 must use tabs.
@@ -2218,7 +2955,7 @@ sub process {
 			if (ERROR("CODE_INDENT",
 				  "code indent should use tabs where possible\n" . $herevet) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/^\+([ \t]+)/"\+" . tabify($1)/e;
+				$fixed[$fixlinenr] =~ s/^\+([ \t]+)/"\+" . tabify($1)/e;
 			}
 		}
 
@@ -2228,9 +2965,9 @@ sub process {
 			if (WARN("SPACE_BEFORE_TAB",
 				"please, no space before tabs\n" . $herevet) &&
 			    $fix) {
-				while ($fixed[$linenr - 1] =~
+				while ($fixed[$fixlinenr] =~
 					   s/(^\+.*) {8,8}\t/$1\t\t/) {}
-				while ($fixed[$linenr - 1] =~
+				while ($fixed[$fixlinenr] =~
 					   s/(^\+.*) +\t/$1\t/) {}
 			}
 		}
@@ -2241,9 +2978,22 @@ sub process {
 			    "Logical continuations should be on the previous line\n" . $hereprev);
 		}
 
+# check indentation starts on a tab stop
+		if ($^V && $^V ge 5.10.0 &&
+		    $sline =~ /^\+\t+( +)(?:$c90_Keywords\b|\{\s*$|\}\s*(?:else\b|while\b|\s*$))/) {
+			my $indent = length($1);
+			if ($indent % 8) {
+				if (WARN("TABSTOP",
+					 "Statements should start on a tabstop\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s@(^\+\t+) +@$1 . "\t" x ($indent/8)@e;
+				}
+			}
+		}
+
 # check multi-line statement indentation matches previous line
 		if ($^V && $^V ge 5.10.0 &&
-		    $prevline =~ /^\+(\t*)(if \(|$Ident\().*(\&\&|\|\||,)\s*$/) {
+		    $prevline =~ /^\+([ \t]*)((?:$c90_Keywords(?:\s+if)\s*)|(?:$Declare\s*)?(?:$Ident|\(\s*\*\s*$Ident\s*\))\s*|(?:\*\s*)*$Lval\s*=\s*$Ident\s*)\(.*(\&\&|\|\||,)\s*$/) {
 			$prevline =~ /^\+(\t*)(.*)$/;
 			my $oldindent = $1;
 			my $rest = $2;
@@ -2264,45 +3014,154 @@ sub process {
 					if (CHK("PARENTHESIS_ALIGNMENT",
 						"Alignment should match open parenthesis\n" . $hereprev) &&
 					    $fix && $line =~ /^\+/) {
-						$fixed[$linenr - 1] =~
+						$fixed[$fixlinenr] =~
 						    s/^\+[ \t]*/\+$goodtabindent/;
 					}
 				}
 			}
 		}
 
-		if ($line =~ /^\+.*\*[ \t]*\)[ \t]+(?!$Assignment|$Arithmetic)/) {
+# check for space after cast like "(int) foo" or "(struct foo) bar"
+# avoid checking a few false positives:
+#   "sizeof(<type>)" or "__alignof__(<type>)"
+#   function pointer declarations like "(*foo)(int) = bar;"
+#   structure definitions like "(struct foo) { 0 };"
+#   multiline macros that define functions
+#   known attributes or the __attribute__ keyword
+		if ($line =~ /^\+(.*)\(\s*$Type\s*\)([ \t]++)((?![={]|\\$|$Attribute|__attribute__))/ &&
+		    (!defined($1) || $1 !~ /\b(?:sizeof|__alignof__)\s*$/)) {
 			if (CHK("SPACING",
-				"No space is necessary after a cast\n" . $hereprev) &&
+				"No space is necessary after a cast\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
-				    s/^(\+.*\*[ \t]*\))[ \t]+/$1/;
+				$fixed[$fixlinenr] =~
+				    s/(\(\s*$Type\s*\))[ \t]+/$1/;
 			}
 		}
 
+# Block comment styles
+# Networking with an initial /*
 		if ($realfile =~ m@^(drivers/net/|net/)@ &&
 		    $prevrawline =~ /^\+[ \t]*\/\*[ \t]*$/ &&
-		    $rawline =~ /^\+[ \t]*\*/) {
+		    $rawline =~ /^\+[ \t]*\*/ &&
+		    $realline > 2) {
 			WARN("NETWORKING_BLOCK_COMMENT_STYLE",
 			     "networking block comments don't use an empty /* line, use /* Comment...\n" . $hereprev);
 		}
 
-		if ($realfile =~ m@^(drivers/net/|net/)@ &&
-		    $prevrawline =~ /^\+[ \t]*\/\*/ &&		#starting /*
+# Block comments use * on subsequent lines
+		if ($prevline =~ /$;[ \t]*$/ &&			#ends in comment
+		    $prevrawline =~ /^\+.*?\/\*/ &&		#starting /*
 		    $prevrawline !~ /\*\/[ \t]*$/ &&		#no trailing */
 		    $rawline =~ /^\+/ &&			#line is new
 		    $rawline !~ /^\+[ \t]*\*/) {		#no leading *
-			WARN("NETWORKING_BLOCK_COMMENT_STYLE",
-			     "networking block comments start with * on subsequent lines\n" . $hereprev);
+			WARN("BLOCK_COMMENT_STYLE",
+			     "Block comments use * on subsequent lines\n" . $hereprev);
 		}
 
-		if ($realfile =~ m@^(drivers/net/|net/)@ &&
-		    $rawline !~ m@^\+[ \t]*\*/[ \t]*$@ &&	#trailing */
+# Block comments use */ on trailing lines
+		if ($rawline !~ m@^\+[ \t]*\*/[ \t]*$@ &&	#trailing */
 		    $rawline !~ m@^\+.*/\*.*\*/[ \t]*$@ &&	#inline /*...*/
 		    $rawline !~ m@^\+.*\*{2,}/[ \t]*$@ &&	#trailing **/
 		    $rawline =~ m@^\+[ \t]*.+\*\/[ \t]*$@) {	#non blank */
-			WARN("NETWORKING_BLOCK_COMMENT_STYLE",
-			     "networking block comments put the trailing */ on a separate line\n" . $herecurr);
+			WARN("BLOCK_COMMENT_STYLE",
+			     "Block comments use a trailing */ on a separate line\n" . $herecurr);
+		}
+
+# Block comment * alignment
+		if ($prevline =~ /$;[ \t]*$/ &&			#ends in comment
+		    $line =~ /^\+[ \t]*$;/ &&			#leading comment
+		    $rawline =~ /^\+[ \t]*\*/ &&		#leading *
+		    (($prevrawline =~ /^\+.*?\/\*/ &&		#leading /*
+		      $prevrawline !~ /\*\/[ \t]*$/) ||		#no trailing */
+		     $prevrawline =~ /^\+[ \t]*\*/)) {		#leading *
+			my $oldindent;
+			$prevrawline =~ m@^\+([ \t]*/?)\*@;
+			if (defined($1)) {
+				$oldindent = expand_tabs($1);
+			} else {
+				$prevrawline =~ m@^\+(.*/?)\*@;
+				$oldindent = expand_tabs($1);
+			}
+			$rawline =~ m@^\+([ \t]*)\*@;
+			my $newindent = $1;
+			$newindent = expand_tabs($newindent);
+			if (length($oldindent) ne length($newindent)) {
+				WARN("BLOCK_COMMENT_STYLE",
+				     "Block comments should align the * on each line\n" . $hereprev);
+			}
+		}
+
+# check for missing blank lines after struct/union declarations
+# with exceptions for various attributes and macros
+		if ($prevline =~ /^[\+ ]};?\s*$/ &&
+		    $line =~ /^\+/ &&
+		    !($line =~ /^\+\s*$/ ||
+		      $line =~ /^\+\s*EXPORT_SYMBOL/ ||
+		      $line =~ /^\+\s*MODULE_/i ||
+		      $line =~ /^\+\s*\#\s*(?:end|elif|else)/ ||
+		      $line =~ /^\+[a-z_]*init/ ||
+		      $line =~ /^\+\s*(?:static\s+)?[A-Z_]*ATTR/ ||
+		      $line =~ /^\+\s*DECLARE/ ||
+		      $line =~ /^\+\s*__setup/)) {
+			if (CHK("LINE_SPACING",
+				"Please use a blank line after function/struct/union/enum declarations\n" . $hereprev) &&
+			    $fix) {
+				fix_insert_line($fixlinenr, "\+");
+			}
+		}
+
+# check for multiple consecutive blank lines
+		if ($prevline =~ /^[\+ ]\s*$/ &&
+		    $line =~ /^\+\s*$/ &&
+		    $last_blank_line != ($linenr - 1)) {
+			if (CHK("LINE_SPACING",
+				"Please don't use multiple blank lines\n" . $hereprev) &&
+			    $fix) {
+				fix_delete_line($fixlinenr, $rawline);
+			}
+
+			$last_blank_line = $linenr;
+		}
+
+# check for missing blank lines after declarations
+		if ($sline =~ /^\+\s+\S/ &&			#Not at char 1
+			# actual declarations
+		    ($prevline =~ /^\+\s+$Declare\s*$Ident\s*[=,;:\[]/ ||
+			# function pointer declarations
+		     $prevline =~ /^\+\s+$Declare\s*\(\s*\*\s*$Ident\s*\)\s*[=,;:\[\(]/ ||
+			# foo bar; where foo is some local typedef or #define
+		     $prevline =~ /^\+\s+$Ident(?:\s+|\s*\*\s*)$Ident\s*[=,;\[]/ ||
+			# known declaration macros
+		     $prevline =~ /^\+\s+$declaration_macros/) &&
+			# for "else if" which can look like "$Ident $Ident"
+		    !($prevline =~ /^\+\s+$c90_Keywords\b/ ||
+			# other possible extensions of declaration lines
+		      $prevline =~ /(?:$Compare|$Assignment|$Operators)\s*$/ ||
+			# not starting a section or a macro "\" extended line
+		      $prevline =~ /(?:\{\s*|\\)$/) &&
+			# looks like a declaration
+		    !($sline =~ /^\+\s+$Declare\s*$Ident\s*[=,;:\[]/ ||
+			# function pointer declarations
+		      $sline =~ /^\+\s+$Declare\s*\(\s*\*\s*$Ident\s*\)\s*[=,;:\[\(]/ ||
+			# foo bar; where foo is some local typedef or #define
+		      $sline =~ /^\+\s+$Ident(?:\s+|\s*\*\s*)$Ident\s*[=,;\[]/ ||
+			# known declaration macros
+		      $sline =~ /^\+\s+$declaration_macros/ ||
+			# start of struct or union or enum
+		      $sline =~ /^\+\s+(?:union|struct|enum|typedef)\b/ ||
+			# start or end of block or continuation of declaration
+		      $sline =~ /^\+\s+(?:$|[\{\}\.\#\"\?\:\(\[])/ ||
+			# bitfield continuation
+		      $sline =~ /^\+\s+$Ident\s*:\s*\d+\s*[,;]/ ||
+			# other possible extensions of declaration lines
+		      $sline =~ /^\+\s+\(?\s*(?:$Compare|$Assignment|$Operators)/) &&
+			# indentation of previous and current line are the same
+		    (($prevline =~ /\+(\s+)\S/) && $sline =~ /^\+$1\S/)) {
+			if (WARN("LINE_SPACING",
+				 "Missing a blank line after declarations\n" . $hereprev) &&
+			    $fix) {
+				fix_insert_line($fixlinenr, "\+");
+			}
 		}
 
 # check for spaces at the beginning of a line.
@@ -2315,17 +3174,46 @@ sub process {
 			if (WARN("LEADING_SPACE",
 				 "please, no spaces at the start of a line\n" . $herevet) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/^\+([ \t]+)/"\+" . tabify($1)/e;
+				$fixed[$fixlinenr] =~ s/^\+([ \t]+)/"\+" . tabify($1)/e;
 			}
 		}
 
 # check we are in a valid C source file if not then ignore this hunk
 		next if ($realfile !~ /\.(h|c)$/);
 
-# discourage the addition of CONFIG_EXPERIMENTAL in #if(def).
-		if ($line =~ /^\+\s*\#\s*if.*\bCONFIG_EXPERIMENTAL\b/) {
-			WARN("CONFIG_EXPERIMENTAL",
-			     "Use of CONFIG_EXPERIMENTAL is deprecated. For alternatives, see https://lkml.org/lkml/2012/10/23/580\n");
+# check if this appears to be the start function declaration, save the name
+		if ($sline =~ /^\+\{\s*$/ &&
+		    $prevline =~ /^\+(?:(?:(?:$Storage|$Inline)\s*)*\s*$Type\s*)?($Ident)\(/) {
+			$context_function = $1;
+		}
+
+# check if this appears to be the end of function declaration
+		if ($sline =~ /^\+\}\s*$/) {
+			undef $context_function;
+		}
+
+# check indentation of any line with a bare else
+# (but not if it is a multiple line "if (foo) return bar; else return baz;")
+# if the previous line is a break or return and is indented 1 tab more...
+		if ($sline =~ /^\+([\t]+)(?:}[ \t]*)?else(?:[ \t]*{)?\s*$/) {
+			my $tabs = length($1) + 1;
+			if ($prevline =~ /^\+\t{$tabs,$tabs}break\b/ ||
+			    ($prevline =~ /^\+\t{$tabs,$tabs}return\b/ &&
+			     defined $lines[$linenr] &&
+			     $lines[$linenr] !~ /^[ \+]\t{$tabs,$tabs}return/)) {
+				WARN("UNNECESSARY_ELSE",
+				     "else is not generally useful after a break or return\n" . $hereprev);
+			}
+		}
+
+# check indentation of a line with a break;
+# if the previous line is a goto or return and is indented the same # of tabs
+		if ($sline =~ /^\+([\t]+)break\s*;\s*$/) {
+			my $tabs = $1;
+			if ($prevline =~ /^\+$tabs(?:goto|return)\b/) {
+				WARN("UNNECESSARY_BREAK",
+				     "break is not useful after a goto or return\n" . $hereprev);
+			}
 		}
 
 # check for RCS/CVS revision markers
@@ -2356,7 +3244,7 @@ sub process {
 		my ($stat, $cond, $line_nr_next, $remain_next, $off_next,
 		    $realline_next);
 #print "LINE<$line>\n";
-		if ($linenr >= $suppress_statement &&
+		if ($linenr > $suppress_statement &&
 		    $realcnt && $sline =~ /.\s*\S/) {
 			($stat, $cond, $line_nr_next, $remain_next, $off_next) =
 				ctx_statement_block($linenr, $realcnt, 0);
@@ -2457,7 +3345,7 @@ sub process {
 
 # if/while/etc brace do not go on next line, unless defining a do while loop,
 # or if that brace on the next line is for something else
-		if ($line =~ /(.*)\b((?:if|while|for|switch)\s*\(|do\b|else\b)/ && $line !~ /^.\s*\#/) {
+		if ($line =~ /(.*)\b((?:if|while|for|switch|(?:[a-z_]+|)for_each[a-z_]+)\s*\(|do\b|else\b)/ && $line !~ /^.\s*\#/) {
 			my $pre_ctx = "$1$2";
 
 			my ($level, @ctx) = ctx_statement_level($linenr, $realcnt, 0);
@@ -2484,7 +3372,7 @@ sub process {
 			#print "realcnt<$realcnt> ctx_cnt<$ctx_cnt>\n";
 			#print "pre<$pre_ctx>\nline<$line>\nctx<$ctx>\nnext<$lines[$ctx_ln - 1]>\n";
 
-			if ($ctx !~ /{\s*/ && defined($lines[$ctx_ln -1]) && $lines[$ctx_ln - 1] =~ /^\+\s*{/) {
+			if ($ctx !~ /{\s*/ && defined($lines[$ctx_ln - 1]) && $lines[$ctx_ln - 1] =~ /^\+\s*{/) {
 				ERROR("OPEN_BRACE",
 				      "that open brace { should be on the previous line\n" .
 					"$here\n$ctx\n$rawlines[$ctx_ln - 1]\n");
@@ -2503,7 +3391,7 @@ sub process {
 		}
 
 # Check relative indent for conditionals and blocks.
-		if ($line =~ /\b(?:(?:if|while|for)\s*\(|do\b)/ && $line !~ /^.\s*#/ && $line !~ /\}\s*while\s*/) {
+		if ($line =~ /\b(?:(?:if|while|for|(?:[a-z_]+|)for_each[a-z_]+)\s*\(|(?:do|else)\b)/ && $line !~ /^.\s*#/ && $line !~ /\}\s*while\s*/) {
 			($stat, $cond, $line_nr_next, $remain_next, $off_next) =
 				ctx_statement_block($linenr, $realcnt, 0)
 					if (!defined $stat);
@@ -2511,15 +3399,22 @@ sub process {
 
 			substr($s, 0, length($c), '');
 
-			# Make sure we remove the line prefixes as we have
-			# none on the first line, and are going to readd them
-			# where necessary.
-			$s =~ s/\n./\n/gs;
+			# remove inline comments
+			$s =~ s/$;/ /g;
+			$c =~ s/$;/ /g;
 
 			# Find out how long the conditional actually is.
 			my @newlines = ($c =~ /\n/gs);
 			my $cond_lines = 1 + $#newlines;
 
+			# Make sure we remove the line prefixes as we have
+			# none on the first line, and are going to readd them
+			# where necessary.
+			$s =~ s/\n./\n/gs;
+			while ($s =~ /\n\s+\\\n/) {
+				$cond_lines += $s =~ s/\n\s+\\\n/\n/g;
+			}
+
 			# We want to check the first line inside the block
 			# starting at the end of the conditional, so remove:
 			#  1) any blank line termination
@@ -2585,8 +3480,12 @@ sub process {
 
 			#print "line<$line> prevline<$prevline> indent<$indent> sindent<$sindent> check<$check> continuation<$continuation> s<$s> cond_lines<$cond_lines> stat_real<$stat_real> stat<$stat>\n";
 
-			if ($check && (($sindent % 8) != 0 ||
-			    ($sindent <= $indent && $s ne ''))) {
+			if ($check && $s ne '' &&
+			    (($sindent % 8) != 0 ||
+			     ($sindent < $indent) ||
+			     ($sindent == $indent &&
+			      ($s !~ /^\s*(?:\}|\{|else\b)/)) ||
+			     ($sindent > $indent + 8))) {
 				WARN("SUSPECT_CODE_INDENT",
 				     "suspect code indent for conditional statements ($indent, $sindent)\n" . $herecurr . "$stat_real\n");
 			}
@@ -2608,6 +3507,42 @@ sub process {
 #ignore lines not being added
 		next if ($line =~ /^[^\+]/);
 
+# check for dereferences that span multiple lines
+		if ($prevline =~ /^\+.*$Lval\s*(?:\.|->)\s*$/ &&
+		    $line =~ /^\+\s*(?!\#\s*(?!define\s+|if))\s*$Lval/) {
+			$prevline =~ /($Lval\s*(?:\.|->))\s*$/;
+			my $ref = $1;
+			$line =~ /^.\s*($Lval)/;
+			$ref .= $1;
+			$ref =~ s/\s//g;
+			WARN("MULTILINE_DEREFERENCE",
+			     "Avoid multiple line dereference - prefer '$ref'\n" . $hereprev);
+		}
+
+# check for declarations of signed or unsigned without int
+		while ($line =~ m{\b($Declare)\s*(?!char\b|short\b|int\b|long\b)\s*($Ident)?\s*[=,;\[\)\(]}g) {
+			my $type = $1;
+			my $var = $2;
+			$var = "" if (!defined $var);
+			if ($type =~ /^(?:(?:$Storage|$Inline|$Attribute)\s+)*((?:un)?signed)((?:\s*\*)*)\s*$/) {
+				my $sign = $1;
+				my $pointer = $2;
+
+				$pointer = "" if (!defined $pointer);
+
+				if (WARN("UNSPECIFIED_INT",
+					 "Prefer '" . trim($sign) . " int" . rtrim($pointer) . "' to bare use of '$sign" . rtrim($pointer) . "'\n" . $herecurr) &&
+				    $fix) {
+					my $decl = trim($sign) . " int ";
+					my $comp_pointer = $pointer;
+					$comp_pointer =~ s/\s//g;
+					$decl .= $comp_pointer;
+					$decl = rtrim($decl) if ($var eq "");
+					$fixed[$fixlinenr] =~ s@\b$sign\s*\Q$pointer\E\s*$var\b@$decl$var@;
+				}
+			}
+		}
+
 # TEST: allow direct testing of the type matcher.
 		if ($dbg_type) {
 			if ($line =~ /^.\s*$Declare\s*$/) {
@@ -2634,8 +3569,18 @@ sub process {
 # check for initialisation to aggregates open brace on the next line
 		if ($line =~ /^.\s*{/ &&
 		    $prevline =~ /(?:^|[^=])=\s*$/) {
-			ERROR("OPEN_BRACE",
-			      "that open brace { should be on the previous line\n" . $hereprev);
+			if (ERROR("OPEN_BRACE",
+				  "that open brace { should be on the previous line\n" . $hereprev) &&
+			    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {
+				fix_delete_line($fixlinenr - 1, $prevrawline);
+				fix_delete_line($fixlinenr, $rawline);
+				my $fixedline = $prevrawline;
+				$fixedline =~ s/\s*=\s*$/ = {/;
+				fix_insert_line($fixlinenr, $fixedline);
+				$fixedline = $line;
+				$fixedline =~ s/^(.\s*)\{\s*/$1/;
+				fix_insert_line($fixlinenr, $fixedline);
+			}
 		}
 
 #
@@ -2660,10 +3605,10 @@ sub process {
 			if (ERROR("C99_COMMENTS",
 				  "do not use C99 // comments\n" . $herecurr) &&
 			    $fix) {
-				my $line = $fixed[$linenr - 1];
+				my $line = $fixed[$fixlinenr];
 				if ($line =~ /\/\/(.*)$/) {
 					my $comment = trim($1);
-					$fixed[$linenr - 1] =~ s@\/\/(.*)$@/\* $comment \*/@;
+					$fixed[$fixlinenr] =~ s@\/\/(.*)$@/\* $comment \*/@;
 				}
 			}
 		}
@@ -2717,24 +3662,30 @@ sub process {
 		}
 
 # check for global initialisers.
-		if ($line =~ /^\+(\s*$Type\s*$Ident\s*(?:\s+$Modifier))*\s*=\s*(0|NULL|false)\s*;/) {
+		if ($line =~ /^\+$Type\s*$Ident(?:\s+$Modifier)*\s*=\s*($zero_initializer)\s*;/) {
 			if (ERROR("GLOBAL_INITIALISERS",
-				  "do not initialise globals to 0 or NULL\n" .
-				      $herecurr) &&
+				  "do not initialise globals to $1\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/($Type\s*$Ident\s*(?:\s+$Modifier))*\s*=\s*(0|NULL|false)\s*;/$1;/;
+				$fixed[$fixlinenr] =~ s/(^.$Type\s*$Ident(?:\s+$Modifier)*)\s*=\s*$zero_initializer\s*;/$1;/;
 			}
 		}
 # check for static initialisers.
-		if ($line =~ /^\+.*\bstatic\s.*=\s*(0|NULL|false)\s*;/) {
+		if ($line =~ /^\+.*\bstatic\s.*=\s*($zero_initializer)\s*;/) {
 			if (ERROR("INITIALISED_STATIC",
-				  "do not initialise statics to 0 or NULL\n" .
+				  "do not initialise statics to $1\n" .
 				      $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/(\bstatic\s.*?)\s*=\s*(0|NULL|false)\s*;/$1;/;
+				$fixed[$fixlinenr] =~ s/(\bstatic\s.*?)\s*=\s*$zero_initializer\s*;/$1;/;
 			}
 		}
 
+# check for misordered declarations of char/short/int/long with signed/unsigned
+		while ($sline =~ m{(\b$TypeMisordered\b)}g) {
+			my $tmp = trim($1);
+			WARN("MISORDERED_TYPE",
+			     "type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\n" . $herecurr);
+		}
+
 # check for static const char * arrays.
 		if ($line =~ /\bstatic\s+const\s+char\s*\*\s*(\w+)\s*\[\s*\]\s*=\s*/) {
 			WARN("STATIC_CONST_CHAR_ARRAY",
@@ -2749,21 +3700,44 @@ sub process {
 				$herecurr);
                }
 
+# check for const <foo> const where <foo> is not a pointer or array type
+		if ($sline =~ /\bconst\s+($BasicType)\s+const\b/) {
+			my $found = $1;
+			if ($sline =~ /\bconst\s+\Q$found\E\s+const\b\s*\*/) {
+				WARN("CONST_CONST",
+				     "'const $found const *' should probably be 'const $found * const'\n" . $herecurr);
+			} elsif ($sline !~ /\bconst\s+\Q$found\E\s+const\s+\w+\s*\[/) {
+				WARN("CONST_CONST",
+				     "'const $found const' should probably be 'const $found'\n" . $herecurr);
+			}
+		}
+
+# check for non-global char *foo[] = {"bar", ...} declarations.
+		if ($line =~ /^.\s+(?:static\s+|const\s+)?char\s+\*\s*\w+\s*\[\s*\]\s*=\s*\{/) {
+			WARN("STATIC_CONST_CHAR_ARRAY",
+			     "char * array declaration might be better as static const\n" .
+				$herecurr);
+               }
+
+# check for sizeof(foo)/sizeof(foo[0]) that could be ARRAY_SIZE(foo)
+		if ($line =~ m@\bsizeof\s*\(\s*($Lval)\s*\)@) {
+			my $array = $1;
+			if ($line =~ m@\b(sizeof\s*\(\s*\Q$array\E\s*\)\s*/\s*sizeof\s*\(\s*\Q$array\E\s*\[\s*0\s*\]\s*\))@) {
+				my $array_div = $1;
+				if (WARN("ARRAY_SIZE",
+					 "Prefer ARRAY_SIZE($array)\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\Q$array_div\E/ARRAY_SIZE($array)/;
+				}
+			}
+		}
+
 # check for function declarations without arguments like "int foo()"
 		if ($line =~ /(\b$Type\s+$Ident)\s*\(\s*\)/) {
 			if (ERROR("FUNCTION_WITHOUT_ARGS",
 				  "Bad function definition - $1() should probably be $1(void)\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/(\b($Type)\s+($Ident))\s*\(\s*\)/$2 $3(void)/;
-			}
-		}
-
-# check for uses of DEFINE_PCI_DEVICE_TABLE
-		if ($line =~ /\bDEFINE_PCI_DEVICE_TABLE\s*\(\s*(\w+)\s*\)\s*=/) {
-			if (WARN("DEFINE_PCI_DEVICE_TABLE",
-				 "Prefer struct pci_device_id over deprecated DEFINE_PCI_DEVICE_TABLE\n" . $herecurr) &&
-			    $fix) {
-				$fixed[$linenr - 1] =~ s/\b(?:static\s+|)DEFINE_PCI_DEVICE_TABLE\s*\(\s*(\w+)\s*\)\s*=\s*/static const struct pci_device_id $1\[\] = /;
+				$fixed[$fixlinenr] =~ s/(\b($Type)\s+($Ident))\s*\(\s*\)/$2 $3(void)/;
 			}
 		}
 
@@ -2773,7 +3747,7 @@ sub process {
 		    $line !~ /\btypedef\s+$Type\s*\(\s*\*?$Ident\s*\)\s*\(/ &&
 		    $line !~ /\btypedef\s+$Type\s+$Ident\s*\(/ &&
 		    $line !~ /\b$typeTypedefs\b/ &&
-		    $line !~ /\b__bitwise(?:__|)\b/) {
+		    $line !~ /\b__bitwise\b/) {
 			WARN("NEW_TYPEDEFS",
 			     "do not add new typedefs\n" . $herecurr);
 		}
@@ -2800,7 +3774,7 @@ sub process {
 					my $sub_from = $ident;
 					my $sub_to = $ident;
 					$sub_to =~ s/\Q$from\E/$to/;
-					$fixed[$linenr - 1] =~
+					$fixed[$fixlinenr] =~
 					    s@\Q$sub_from\E@$sub_to@;
 				}
 			}
@@ -2828,19 +3802,21 @@ sub process {
 					my $sub_from = $match;
 					my $sub_to = $match;
 					$sub_to =~ s/\Q$from\E/$to/;
-					$fixed[$linenr - 1] =~
+					$fixed[$fixlinenr] =~
 					    s@\Q$sub_from\E@$sub_to@;
 				}
 			}
 		}
 
-# # no BUG() or BUG_ON()
-# 		if ($line =~ /\b(BUG|BUG_ON)\b/) {
-# 			print "Try to use WARN_ON & Recovery code rather than BUG() or BUG_ON()\n";
-# 			print "$herecurr";
-# 			$clean = 0;
-# 		}
+# avoid BUG() or BUG_ON()
+		if ($line =~ /\b(?:BUG|BUG_ON)\b/) {
+			my $msg_type = \&WARN;
+			$msg_type = \&CHK if ($file);
+			&{$msg_type}("AVOID_BUG",
+				     "Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()\n" . $herecurr);
+		}
 
+# avoid LINUX_VERSION_CODE
 		if ($line =~ /\bLINUX_VERSION_CODE\b/) {
 			WARN("LINUX_VERSION_CODE",
 			     "LINUX_VERSION_CODE should be avoided, code should be for the version to which it is merged\n" . $herecurr);
@@ -2849,7 +3825,7 @@ sub process {
 # check for uses of printk_ratelimit
 		if ($line =~ /\bprintk_ratelimit\s*\(/) {
 			WARN("PRINTK_RATELIMITED",
-"Prefer printk_ratelimited or pr_<level>_ratelimited to printk_ratelimit\n" . $herecurr);
+			     "Prefer printk_ratelimited or pr_<level>_ratelimited to printk_ratelimit\n" . $herecurr);
 		}
 
 # printk should use KERN_* levels.  Note that follow on printk's on the
@@ -2883,14 +3859,14 @@ sub process {
 			my $level2 = $level;
 			$level2 = "dbg" if ($level eq "debug");
 			WARN("PREFER_PR_LEVEL",
-			     "Prefer netdev_$level2(netdev, ... then dev_$level2(dev, ... then pr_$level(...  to printk(KERN_$orig ...\n" . $herecurr);
+			     "Prefer [subsystem eg: netdev]_$level2([subsystem]dev, ... then dev_$level2(dev, ... then pr_$level(...  to printk(KERN_$orig ...\n" . $herecurr);
 		}
 
 		if ($line =~ /\bpr_warning\s*\(/) {
 			if (WARN("PREFER_PR_LEVEL",
 				 "Prefer pr_warn(... to pr_warning(...\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/\bpr_warning\b/pr_warn/;
 			}
 		}
@@ -2904,19 +3880,50 @@ sub process {
 			     "Prefer dev_$level(... to dev_printk(KERN_$orig, ...\n" . $herecurr);
 		}
 
+# ENOSYS means "bad syscall nr" and nothing else.  This will have a small
+# number of false positives, but assembly files are not checked, so at
+# least the arch entry code will not trigger this warning.
+		if ($line =~ /\bENOSYS\b/) {
+			WARN("ENOSYS",
+			     "ENOSYS means 'invalid syscall nr' and nothing else\n" . $herecurr);
+		}
+
 # function brace can't be on same line, except for #defines of do while,
 # or if closed on same line
-		if (($line=~/$Type\s*$Ident\(.*\).*\s\{/) and
+		if (($line=~/$Type\s*$Ident\(.*\).*\s*{/) and
 		    !($line=~/\#\s*define.*do\s\{/) and !($line=~/}/)) {
-			ERROR("OPEN_BRACE",
-			      "open brace '{' following function declarations go on the next line\n" . $herecurr);
+			if (ERROR("OPEN_BRACE",
+				  "open brace '{' following function declarations go on the next line\n" . $herecurr) &&
+			    $fix) {
+				fix_delete_line($fixlinenr, $rawline);
+				my $fixed_line = $rawline;
+				$fixed_line =~ /(^..*$Type\s*$Ident\(.*\)\s*){(.*)$/;
+				my $line1 = $1;
+				my $line2 = $2;
+				fix_insert_line($fixlinenr, ltrim($line1));
+				fix_insert_line($fixlinenr, "\+{");
+				if ($line2 !~ /^\s*$/) {
+					fix_insert_line($fixlinenr, "\+\t" . trim($line2));
+				}
+			}
 		}
 
 # open braces for enum, union and struct go on the same line.
 		if ($line =~ /^.\s*{/ &&
 		    $prevline =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?\s*$/) {
-			ERROR("OPEN_BRACE",
-			      "open brace '{' following $1 go on the same line\n" . $hereprev);
+			if (ERROR("OPEN_BRACE",
+				  "open brace '{' following $1 go on the same line\n" . $hereprev) &&
+			    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {
+				fix_delete_line($fixlinenr - 1, $prevrawline);
+				fix_delete_line($fixlinenr, $rawline);
+				my $fixedline = rtrim($prevrawline) . " {";
+				fix_insert_line($fixlinenr, $fixedline);
+				$fixedline = $rawline;
+				$fixedline =~ s/^(.\s*)\{\s*/$1\t/;
+				if ($fixedline !~ /^\+\s*$/) {
+					fix_insert_line($fixlinenr, $fixedline);
+				}
+			}
 		}
 
 # missing space after union, struct or enum definition
@@ -2924,7 +3931,7 @@ sub process {
 			if (WARN("SPACING",
 				 "missing space after $1 definition\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/^(.\s*(?:typedef\s+)?(?:enum|union|struct)(?:\s+$Ident){1,2})([=\{])/$1 $2/;
 			}
 		}
@@ -2932,10 +3939,7 @@ sub process {
 # Function pointer declarations
 # check spacing between type, funcptr, and args
 # canonical declaration is "type (*funcptr)(args...)"
-#
-# the $Declare variable will capture all spaces after the type
-# so check it for trailing missing spaces or multiple spaces
-		if ($line =~ /^.\s*($Declare)\((\s*)\*(\s*)$Ident(\s*)\)(\s*)\(/) {
+		if ($line =~ /^.\s*($Declare)\((\s*)\*(\s*)($Ident)(\s*)\)(\s*)\(/) {
 			my $declare = $1;
 			my $pre_pointer_space = $2;
 			my $post_pointer_space = $3;
@@ -2943,16 +3947,30 @@ sub process {
 			my $post_funcname_space = $5;
 			my $pre_args_space = $6;
 
-			if ($declare !~ /\s$/) {
+# the $Declare variable will capture all spaces after the type
+# so check it for a missing trailing missing space but pointer return types
+# don't need a space so don't warn for those.
+			my $post_declare_space = "";
+			if ($declare =~ /(\s+)$/) {
+				$post_declare_space = $1;
+				$declare = rtrim($declare);
+			}
+			if ($declare !~ /\*$/ && $post_declare_space =~ /^$/) {
 				WARN("SPACING",
 				     "missing space after return type\n" . $herecurr);
+				$post_declare_space = " ";
 			}
 
 # unnecessary space "type  (*funcptr)(args...)"
-			elsif ($declare =~ /\s{2,}$/) {
-				WARN("SPACING",
-				     "Multiple spaces after return type\n" . $herecurr);
-			}
+# This test is not currently implemented because these declarations are
+# equivalent to
+#	int  foo(int bar, ...)
+# and this is form shouldn't/doesn't generate a checkpatch warning.
+#
+#			elsif ($declare =~ /\s{2,}$/) {
+#				WARN("SPACING",
+#				     "Multiple spaces after return type\n" . $herecurr);
+#			}
 
 # unnecessary space "type ( *funcptr)(args...)"
 			if (defined $pre_pointer_space &&
@@ -2983,8 +4001,8 @@ sub process {
 			}
 
 			if (show_type("SPACING") && $fix) {
-				$fixed[$linenr - 1] =~
-				    s/^(.\s*$Declare)\(\s*\*\s*($Ident)\s*\)\s*\(/rtrim($1) . " " . "\(\*$2\)\("/ex;
+				$fixed[$fixlinenr] =~
+				    s/^(.\s*)$Declare\s*\(\s*\*\s*$Ident\s*\)\s*\(/$1 . $declare . $post_declare_space . '(*' . $funcname . ')('/ex;
 			}
 		}
 
@@ -3000,7 +4018,7 @@ sub process {
 				if (ERROR("BRACKET_SPACE",
 					  "space prohibited before open square bracket '['\n" . $herecurr) &&
 				    $fix) {
-				    $fixed[$linenr - 1] =~
+				    $fixed[$fixlinenr] =~
 					s/^(\+.*?)\s+\[/$1\[/;
 				}
 			}
@@ -3035,7 +4053,7 @@ sub process {
 				if (WARN("SPACING",
 					 "space prohibited between function name and open parenthesis '('\n" . $herecurr) &&
 					     $fix) {
-					$fixed[$linenr - 1] =~
+					$fixed[$fixlinenr] =~
 					    s/\b$name\s+\(/$name\(/;
 				}
 			}
@@ -3126,7 +4144,7 @@ sub process {
 
 				# Ignore operators passed as parameters.
 				if ($op_type ne 'V' &&
-				    $ca =~ /\s$/ && $cc =~ /^\s*,/) {
+				    $ca =~ /\s$/ && $cc =~ /^\s*[,\)]/) {
 
 #				# Ignore comments
 #				} elsif ($op =~ /^$;+$/) {
@@ -3145,10 +4163,13 @@ sub process {
 				# // is a comment
 				} elsif ($op eq '//') {
 
+				#   :   when part of a bitfield
+				} elsif ($opv eq ':B') {
+					# skip the bitfield test for now
+
 				# No spaces for:
 				#   ->
-				#   :   when part of a bitfield
-				} elsif ($op eq '->' || $opv eq ':B') {
+				} elsif ($op eq '->') {
 					if ($ctx =~ /Wx.|.xW/) {
 						if (ERROR("SPACING",
 							  "spaces prohibited around that '$op' $at\n" . $hereptr)) {
@@ -3160,14 +4181,33 @@ sub process {
 						}
 					}
 
-				# , must have a space on the right.
+				# , must not have a space before and must have a space on the right.
 				} elsif ($op eq ',') {
+					my $rtrim_before = 0;
+					my $space_after = 0;
+					if ($ctx =~ /Wx./) {
+						if (ERROR("SPACING",
+							  "space prohibited before that '$op' $at\n" . $hereptr)) {
+							$line_fixed = 1;
+							$rtrim_before = 1;
+						}
+					}
 					if ($ctx !~ /.x[WEC]/ && $cc !~ /^}/) {
 						if (ERROR("SPACING",
 							  "space required after that '$op' $at\n" . $hereptr)) {
-							$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . " ";
 							$line_fixed = 1;
 							$last_after = $n;
+							$space_after = 1;
+						}
+					}
+					if ($rtrim_before || $space_after) {
+						if ($rtrim_before) {
+							$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);
+						} else {
+							$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);
+						}
+						if ($space_after) {
+							$good .= " ";
 						}
 					}
 
@@ -3239,7 +4279,22 @@ sub process {
 					 $op eq '*' or $op eq '/' or
 					 $op eq '%')
 				{
-					if ($ctx =~ /Wx[^WCE]|[^WCE]xW/) {
+					if ($check) {
+						if (defined $fix_elements[$n + 2] && $ctx !~ /[EW]x[EW]/) {
+							if (CHK("SPACING",
+								"spaces preferred around that '$op' $at\n" . $hereptr)) {
+								$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]) . " ";
+								$fix_elements[$n + 2] =~ s/^\s+//;
+								$line_fixed = 1;
+							}
+						} elsif (!defined $fix_elements[$n + 2] && $ctx !~ /Wx[OE]/) {
+							if (CHK("SPACING",
+								"space preferred before that '$op' $at\n" . $hereptr)) {
+								$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]);
+								$line_fixed = 1;
+							}
+						}
+					} elsif ($ctx =~ /Wx[^WCE]|[^WCE]xW/) {
 						if (ERROR("SPACING",
 							  "need consistent spacing around '$op' $at\n" . $hereptr)) {
 							$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]) . " ";
@@ -3274,6 +4329,14 @@ sub process {
 					    	$ok = 1;
 					}
 
+					# for asm volatile statements
+					# ignore a colon with another
+					# colon immediately before or after
+					if (($op eq ':') &&
+					    ($ca =~ /:$/ || $cc =~ /^:/)) {
+						$ok = 1;
+					}
+
 					# messages are ERROR, but ?: are CHK
 					if ($ok == 0) {
 						my $msg_type = \&ERROR;
@@ -3300,8 +4363,8 @@ sub process {
 				$fixed_line = $fixed_line . $fix_elements[$#elements];
 			}
 
-			if ($fix && $line_fixed && $fixed_line ne $fixed[$linenr - 1]) {
-				$fixed[$linenr - 1] = $fixed_line;
+			if ($fix && $line_fixed && $fixed_line ne $fixed[$fixlinenr]) {
+				$fixed[$fixlinenr] = $fixed_line;
 			}
 
 
@@ -3312,7 +4375,7 @@ sub process {
 			if (WARN("SPACING",
 				 "space prohibited before semicolon\n" . $herecurr) &&
 			    $fix) {
-				1 while $fixed[$linenr - 1] =~
+				1 while $fixed[$fixlinenr] =~
 				    s/^(\+.*\S)\s+;/$1;/;
 			}
 		}
@@ -3340,12 +4403,12 @@ sub process {
 ## 		}
 
 #need space before brace following if, while, etc
-		if (($line =~ /\(.*\)\{/ && $line !~ /\($Type\){/) ||
+		if (($line =~ /\(.*\)\{/ && $line !~ /\($Type\)\{/) ||
 		    $line =~ /do\{/) {
 			if (ERROR("SPACING",
 				  "space required before the open brace '{'\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/^(\+.*(?:do|\))){/$1 {/;
+				$fixed[$fixlinenr] =~ s/^(\+.*(?:do|\)))\{/$1 {/;
 			}
 		}
 
@@ -3363,7 +4426,7 @@ sub process {
 			if (ERROR("SPACING",
 				  "space required after that close brace '}'\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/}((?!(?:,|;|\)))\S)/} $1/;
 			}
 		}
@@ -3373,7 +4436,7 @@ sub process {
 			if (ERROR("SPACING",
 				  "space prohibited after that open square bracket '['\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/\[\s+/\[/;
 			}
 		}
@@ -3381,7 +4444,7 @@ sub process {
 			if (ERROR("SPACING",
 				  "space prohibited before that close square bracket ']'\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/\s+\]/\]/;
 			}
 		}
@@ -3392,7 +4455,7 @@ sub process {
 			if (ERROR("SPACING",
 				  "space prohibited after that open parenthesis '('\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/\(\s+/\(/;
 			}
 		}
@@ -3402,36 +4465,77 @@ sub process {
 			if (ERROR("SPACING",
 				  "space prohibited before that close parenthesis ')'\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/\s+\)/\)/;
 			}
 		}
 
+# check unnecessary parentheses around addressof/dereference single $Lvals
+# ie: &(foo->bar) should be &foo->bar and *(foo->bar) should be *foo->bar
+
+		while ($line =~ /(?:[^&]&\s*|\*)\(\s*($Ident\s*(?:$Member\s*)+)\s*\)/g) {
+			my $var = $1;
+			if (CHK("UNNECESSARY_PARENTHESES",
+				"Unnecessary parentheses around $var\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\(\s*\Q$var\E\s*\)/$var/;
+			}
+		}
+
+# check for unnecessary parentheses around function pointer uses
+# ie: (foo->bar)(); should be foo->bar();
+# but not "if (foo->bar) (" to avoid some false positives
+		if ($line =~ /(\bif\s*|)(\(\s*$Ident\s*(?:$Member\s*)+\))[ \t]*\(/ && $1 !~ /^if/) {
+			my $var = $2;
+			if (CHK("UNNECESSARY_PARENTHESES",
+				"Unnecessary parentheses around function pointer $var\n" . $herecurr) &&
+			    $fix) {
+				my $var2 = deparenthesize($var);
+				$var2 =~ s/\s//g;
+				$fixed[$fixlinenr] =~ s/\Q$var\E/$var2/;
+			}
+		}
+
 #goto labels aren't indented, allow a single space however
 		if ($line=~/^.\s+[A-Za-z\d_]+:(?![0-9]+)/ and
 		   !($line=~/^. [A-Za-z\d_]+:/) and !($line=~/^.\s+default:/)) {
 			if (WARN("INDENTED_LABEL",
 				 "labels should not be indented\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/^(.)\s+/$1/;
 			}
 		}
 
-# Return is not a function.
+# return is not a function
 		if (defined($stat) && $stat =~ /^.\s*return(\s*)\(/s) {
 			my $spacing = $1;
 			if ($^V && $^V ge 5.10.0 &&
-			    $stat =~ /^.\s*return\s*$balanced_parens\s*;\s*$/) {
-				ERROR("RETURN_PARENTHESES",
-				      "return is not a function, parentheses are not required\n" . $herecurr);
-
+			    $stat =~ /^.\s*return\s*($balanced_parens)\s*;\s*$/) {
+				my $value = $1;
+				$value = deparenthesize($value);
+				if ($value =~ m/^\s*$FuncArg\s*(?:\?|$)/) {
+					ERROR("RETURN_PARENTHESES",
+					      "return is not a function, parentheses are not required\n" . $herecurr);
+				}
 			} elsif ($spacing !~ /\s+/) {
 				ERROR("SPACING",
 				      "space required before the open parenthesis '('\n" . $herecurr);
 			}
 		}
 
+# unnecessary return in a void function
+# at end-of-function, with the previous line a single leading tab, then return;
+# and the line before that not a goto label target like "out:"
+		if ($sline =~ /^[ \+]}\s*$/ &&
+		    $prevline =~ /^\+\treturn\s*;\s*$/ &&
+		    $linenr >= 3 &&
+		    $lines[$linenr - 3] =~ /^[ +]/ &&
+		    $lines[$linenr - 3] !~ /^[ +]\s*$Ident\s*:/) {
+			WARN("RETURN_VOID",
+			     "void function return statements are not generally useful\n" . $hereprev);
+               }
+
 # if statements using unnecessary parentheses - ie: if ((foo == bar))
 		if ($^V && $^V ge 5.10.0 &&
 		    $line =~ /\bif\s*((?:\(\s*){2,})/) {
@@ -3446,12 +4550,41 @@ sub process {
 			}
 		}
 
-# Return of what appears to be an errno should normally be -'ve
-		if ($line =~ /^.\s*return\s*(E[A-Z]*)\s*;/) {
+# comparisons with a constant or upper case identifier on the left
+#	avoid cases like "foo + BAR < baz"
+#	only fix matches surrounded by parentheses to avoid incorrect
+#	conversions like "FOO < baz() + 5" being "misfixed" to "baz() > FOO + 5"
+		if ($^V && $^V ge 5.10.0 &&
+		    $line =~ /^\+(.*)\b($Constant|[A-Z_][A-Z0-9_]*)\s*($Compare)\s*($LvalOrFunc)/) {
+			my $lead = $1;
+			my $const = $2;
+			my $comp = $3;
+			my $to = $4;
+			my $newcomp = $comp;
+			if ($lead !~ /(?:$Operators|\.)\s*$/ &&
+			    $to !~ /^(?:Constant|[A-Z_][A-Z0-9_]*)$/ &&
+			    WARN("CONSTANT_COMPARISON",
+				 "Comparisons should place the constant on the right side of the test\n" . $herecurr) &&
+			    $fix) {
+				if ($comp eq "<") {
+					$newcomp = ">";
+				} elsif ($comp eq "<=") {
+					$newcomp = ">=";
+				} elsif ($comp eq ">") {
+					$newcomp = "<";
+				} elsif ($comp eq ">=") {
+					$newcomp = "<=";
+				}
+				$fixed[$fixlinenr] =~ s/\(\s*\Q$const\E\s*$Compare\s*\Q$to\E\s*\)/($to $newcomp $const)/;
+			}
+		}
+
+# Return of what appears to be an errno should normally be negative
+		if ($sline =~ /\breturn(?:\s*\(+\s*|\s+)(E[A-Z]+)(?:\s*\)+\s*|\s*)[;:,]/) {
 			my $name = $1;
 			if ($name ne 'EOF' && $name ne 'ERROR') {
 				WARN("USE_NEGATIVE_ERRNO",
-				     "return of an errno should typically be -ve (return -$1)\n" . $herecurr);
+				     "return of an errno should typically be negative (ie: return -$1)\n" . $herecurr);
 			}
 		}
 
@@ -3460,7 +4593,7 @@ sub process {
 			if (ERROR("SPACING",
 				  "space required before the open parenthesis '('\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/\b(if|while|for|switch)\(/$1 \(/;
 			}
 		}
@@ -3550,7 +4683,7 @@ sub process {
 # if should not continue a brace
 		if ($line =~ /}\s*if\b/) {
 			ERROR("TRAILING_STATEMENTS",
-			      "trailing statements should be on next line\n" .
+			      "trailing statements should be on next line (or did you mean 'else if'?)\n" .
 				$herecurr);
 		}
 # case and default should not have general statements after them
@@ -3566,14 +4699,26 @@ sub process {
 
 		# Check for }<nl>else {, these must be at the same
 		# indent level to be relevant to each other.
-		if ($prevline=~/}\s*$/ and $line=~/^.\s*else\s*/ and
-						$previndent == $indent) {
-			ERROR("ELSE_AFTER_BRACE",
-			      "else should follow close brace '}'\n" . $hereprev);
+		if ($prevline=~/}\s*$/ and $line=~/^.\s*else\s*/ &&
+		    $previndent == $indent) {
+			if (ERROR("ELSE_AFTER_BRACE",
+				  "else should follow close brace '}'\n" . $hereprev) &&
+			    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {
+				fix_delete_line($fixlinenr - 1, $prevrawline);
+				fix_delete_line($fixlinenr, $rawline);
+				my $fixedline = $prevrawline;
+				$fixedline =~ s/}\s*$//;
+				if ($fixedline !~ /^\+\s*$/) {
+					fix_insert_line($fixlinenr, $fixedline);
+				}
+				$fixedline = $rawline;
+				$fixedline =~ s/^(.\s*)else/$1} else/;
+				fix_insert_line($fixlinenr, $fixedline);
+			}
 		}
 
-		if ($prevline=~/}\s*$/ and $line=~/^.\s*while\s*/ and
-						$previndent == $indent) {
+		if ($prevline=~/}\s*$/ and $line=~/^.\s*while\s*/ &&
+		    $previndent == $indent) {
 			my ($s, $c) = ctx_statement_block($linenr, $realcnt, 0);
 
 			# Find out what is on the end of the line after the
@@ -3582,8 +4727,18 @@ sub process {
 			$s =~ s/\n.*//g;
 
 			if ($s =~ /^\s*;/) {
-				ERROR("WHILE_AFTER_BRACE",
-				      "while should follow close brace '}'\n" . $hereprev);
+				if (ERROR("WHILE_AFTER_BRACE",
+					  "while should follow close brace '}'\n" . $hereprev) &&
+				    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {
+					fix_delete_line($fixlinenr - 1, $prevrawline);
+					fix_delete_line($fixlinenr, $rawline);
+					my $fixedline = $prevrawline;
+					my $trailing = $rawline;
+					$trailing =~ s/^\+//;
+					$trailing = trim($trailing);
+					$fixedline =~ s/}\s*$/} $trailing/;
+					fix_insert_line($fixlinenr, $fixedline);
+				}
 			}
 		}
 
@@ -3597,7 +4752,7 @@ sub process {
 					 "Avoid gcc v4.3+ binary constant extension: <$var>\n" . $herecurr) &&
 				    $fix) {
 					my $hexval = sprintf("0x%x", oct($var));
-					$fixed[$linenr - 1] =~
+					$fixed[$fixlinenr] =~
 					    s/\b$var\b/$hexval/;
 				}
 			}
@@ -3608,7 +4763,9 @@ sub process {
 #Ignore Page<foo> variants
 			    $var !~ /^(?:Clear|Set|TestClear|TestSet|)Page[A-Z]/ &&
 #Ignore SI style variants like nS, mV and dB (ie: max_uV, regulator_min_uA_show)
-			    $var !~ /^(?:[a-z_]*?)_?[a-z][A-Z](?:_[a-z_]+)?$/) {
+			    $var !~ /^(?:[a-z_]*?)_?[a-z][A-Z](?:_[a-z_]+)?$/ &&
+#Ignore some three character SI units explicitly, like MiB and KHz
+			    $var !~ /^(?:[a-z_]*?)_?(?:[KMGT]iB|[KMGT]?Hz)(?:_[a-z_]+)?$/) {
 				while ($var =~ m{($Ident)}g) {
 					my $word = $1;
 					next if ($word !~ /[A-Z][a-z]|[a-z][A-Z]/);
@@ -3633,11 +4790,12 @@ sub process {
 			if (WARN("WHITESPACE_AFTER_LINE_CONTINUATION",
 				 "Whitespace after \\ makes next lines useless\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\s+$//;
+				$fixed[$fixlinenr] =~ s/\s+$//;
 			}
 		}
 
-#warn if <asm/foo.h> is #included and <linux/foo.h> is available (uses RAW line)
+# warn if <asm/foo.h> is #included and <linux/foo.h> is available and includes
+# itself <asm/foo.h> (uses RAW line)
 		if ($tree && $rawline =~ m{^.\s*\#\s*include\s*\<asm\/(.*)\.h\>}) {
 			my $file = "$1.h";
 			my $checkfile = "include/linux/$file";
@@ -3645,12 +4803,15 @@ sub process {
 			    $realfile ne $checkfile &&
 			    $1 !~ /$allowed_asm_includes/)
 			{
-				if ($realfile =~ m{^arch/}) {
-					CHK("ARCH_INCLUDE_LINUX",
-					    "Consider using #include <linux/$file> instead of <asm/$file>\n" . $herecurr);
-				} else {
-					WARN("INCLUDE_LINUX",
-					     "Use #include <linux/$file> instead of <asm/$file>\n" . $herecurr);
+				my $asminclude = `grep -Ec "#include\\s+<asm/$file>" $root/$checkfile`;
+				if ($asminclude > 0) {
+					if ($realfile =~ m{^arch/}) {
+						CHK("ARCH_INCLUDE_LINUX",
+						    "Consider using #include <linux/$file> instead of <asm/$file>\n" . $herecurr);
+					} else {
+						WARN("INCLUDE_LINUX",
+						     "Use #include <linux/$file> instead of <asm/$file>\n" . $herecurr);
+					}
 				}
 			}
 		}
@@ -3664,13 +4825,28 @@ sub process {
 			my $cnt = $realcnt;
 			my ($off, $dstat, $dcond, $rest);
 			my $ctx = '';
+			my $has_flow_statement = 0;
+			my $has_arg_concat = 0;
 			($dstat, $dcond, $ln, $cnt, $off) =
 				ctx_statement_block($linenr, $realcnt, 0);
 			$ctx = $dstat;
 			#print "dstat<$dstat> dcond<$dcond> cnt<$cnt> off<$off>\n";
 			#print "LINE<$lines[$ln-1]> len<" . length($lines[$ln-1]) . "\n";
 
-			$dstat =~ s/^.\s*\#\s*define\s+$Ident(?:\([^\)]*\))?\s*//;
+			$has_flow_statement = 1 if ($ctx =~ /\b(goto|return)\b/);
+			$has_arg_concat = 1 if ($ctx =~ /\#\#/ && $ctx !~ /\#\#\s*(?:__VA_ARGS__|args)\b/);
+
+			$dstat =~ s/^.\s*\#\s*define\s+$Ident(\([^\)]*\))?\s*//;
+			my $define_args = $1;
+			my $define_stmt = $dstat;
+			my @def_args = ();
+
+			if (defined $define_args && $define_args ne "") {
+				$define_args = substr($define_args, 1, length($define_args) - 2);
+				$define_args =~ s/\s*//g;
+				@def_args = split(",", $define_args);
+			}
+
 			$dstat =~ s/$;//g;
 			$dstat =~ s/\\\n.//g;
 			$dstat =~ s/^\s*//s;
@@ -3679,16 +4855,19 @@ sub process {
 			# Flatten any parentheses and braces
 			while ($dstat =~ s/\([^\(\)]*\)/1/ ||
 			       $dstat =~ s/\{[^\{\}]*\}/1/ ||
-			       $dstat =~ s/\[[^\[\]]*\]/1/)
+			       $dstat =~ s/.\[[^\[\]]*\]/1/)
 			{
 			}
 
 			# Flatten any obvious string concatentation.
-			while ($dstat =~ s/("X*")\s*$Ident/$1/ ||
-			       $dstat =~ s/$Ident\s*("X*")/$1/)
+			while ($dstat =~ s/($String)\s*$Ident/$1/ ||
+			       $dstat =~ s/$Ident\s*($String)/$1/)
 			{
 			}
 
+			# Make asm volatile uses seem like a generic function
+			$dstat =~ s/\b_*asm_*\s+_*volatile_*\b/asm_volatile/g;
+
 			my $exceptions = qr{
 				$Declare|
 				module_param_named|
@@ -3699,14 +4878,24 @@ sub process {
 				union|
 				struct|
 				\.$Ident\s*=\s*|
-				^\"|\"$
+				^\"|\"$|
+				^\[
 			}x;
 			#print "REST<$rest> dstat<$dstat> ctx<$ctx>\n";
+
+			$ctx =~ s/\n*$//;
+			my $herectx = $here . "\n";
+			my $stmt_cnt = statement_rawlines($ctx);
+
+			for (my $n = 0; $n < $stmt_cnt; $n++) {
+				$herectx .= raw_line($linenr, $n) . "\n";
+			}
+
 			if ($dstat ne '' &&
 			    $dstat !~ /^(?:$Ident|-?$Constant),$/ &&			# 10, // foo(),
 			    $dstat !~ /^(?:$Ident|-?$Constant);$/ &&			# foo();
 			    $dstat !~ /^[!~-]?(?:$Lval|$Constant)$/ &&		# 10 // foo() // !foo // ~foo // -foo // foo->bar // foo.bar->baz
-			    $dstat !~ /^'X'$/ &&					# character constants
+			    $dstat !~ /^'X'$/ && $dstat !~ /^'XX'$/ &&			# character constants
 			    $dstat !~ /$exceptions/ &&
 			    $dstat !~ /^\.$Ident\s*=/ &&				# .foo =
 			    $dstat !~ /^(?:\#\s*$Ident|\#\s*$Constant)\s*$/ &&		# stringification #foo
@@ -3717,21 +4906,69 @@ sub process {
 			    $dstat !~ /^\(\{/ &&						# ({...
 			    $ctx !~ /^.\s*#\s*define\s+TRACE_(?:SYSTEM|INCLUDE_FILE|INCLUDE_PATH)\b/)
 			{
-				$ctx =~ s/\n*$//;
+				if ($dstat =~ /^\s*if\b/) {
+					ERROR("MULTISTATEMENT_MACRO_USE_DO_WHILE",
+					      "Macros starting with if should be enclosed by a do - while loop to avoid possible if/else logic defects\n" . "$herectx");
+				} elsif ($dstat =~ /;/) {
+					ERROR("MULTISTATEMENT_MACRO_USE_DO_WHILE",
+					      "Macros with multiple statements should be enclosed in a do - while loop\n" . "$herectx");
+				} else {
+					ERROR("COMPLEX_MACRO",
+					      "Macros with complex values should be enclosed in parentheses\n" . "$herectx");
+				}
+
+			}
+
+			# Make $define_stmt single line, comment-free, etc
+			my @stmt_array = split('\n', $define_stmt);
+			my $first = 1;
+			$define_stmt = "";
+			foreach my $l (@stmt_array) {
+				$l =~ s/\\$//;
+				if ($first) {
+					$define_stmt = $l;
+					$first = 0;
+				} elsif ($l =~ /^[\+ ]/) {
+					$define_stmt .= substr($l, 1);
+				}
+			}
+			$define_stmt =~ s/$;//g;
+			$define_stmt =~ s/\s+/ /g;
+			$define_stmt = trim($define_stmt);
+
+# check if any macro arguments are reused (ignore '...' and 'type')
+			foreach my $arg (@def_args) {
+			        next if ($arg =~ /\.\.\./);
+			        next if ($arg =~ /^type$/i);
+				my $tmp_stmt = $define_stmt;
+				$tmp_stmt =~ s/\b(typeof|__typeof__|__builtin\w+|typecheck\s*\(\s*$Type\s*,|\#+)\s*\(*\s*$arg\s*\)*\b//g;
+				$tmp_stmt =~ s/\#+\s*$arg\b//g;
+				$tmp_stmt =~ s/\b$arg\s*\#\#//g;
+				my $use_cnt = $tmp_stmt =~ s/\b$arg\b//g;
+				if ($use_cnt > 1) {
+					CHK("MACRO_ARG_REUSE",
+					    "Macro argument reuse '$arg' - possible side-effects?\n" . "$herectx");
+				    }
+# check if any macro arguments may have other precedence issues
+				if ($tmp_stmt =~ m/($Operators)?\s*\b$arg\b\s*($Operators)?/m &&
+				    ((defined($1) && $1 ne ',') ||
+				     (defined($2) && $2 ne ','))) {
+					CHK("MACRO_ARG_PRECEDENCE",
+					    "Macro argument '$arg' may be better as '($arg)' to avoid precedence issues\n" . "$herectx");
+				}
+			}
+
+# check for macros with flow control, but without ## concatenation
+# ## concatenation is commonly a macro that defines a function so ignore those
+			if ($has_flow_statement && !$has_arg_concat) {
 				my $herectx = $here . "\n";
 				my $cnt = statement_rawlines($ctx);
 
 				for (my $n = 0; $n < $cnt; $n++) {
 					$herectx .= raw_line($linenr, $n) . "\n";
 				}
-
-				if ($dstat =~ /;/) {
-					ERROR("MULTISTATEMENT_MACRO_USE_DO_WHILE",
-					      "Macros with multiple statements should be enclosed in a do - while loop\n" . "$herectx");
-				} else {
-					ERROR("COMPLEX_MACRO",
-					      "Macros with complex values should be enclosed in parenthesis\n" . "$herectx");
-				}
+				WARN("MACRO_WITH_FLOW_CONTROL",
+				     "Macros with flow control statements should be avoided\n" . "$herectx");
 			}
 
 # check for line continuations outside of #defines, preprocessor #, and asm
@@ -3761,6 +4998,7 @@ sub process {
 			$ctx = $dstat;
 
 			$dstat =~ s/\\\n.//g;
+			$dstat =~ s/$;/ /g;
 
 			if ($dstat =~ /^\+\s*#\s*define\s+$Ident\s*${balanced_parens}\s*do\s*{(.*)\s*}\s*while\s*\(\s*0\s*\)\s*([;\s]*)\s*$/) {
 				my $stmts = $2;
@@ -3783,6 +5021,17 @@ sub process {
 					WARN("DO_WHILE_MACRO_WITH_TRAILING_SEMICOLON",
 					     "do {} while (0) macros should not be semicolon terminated\n" . "$herectx");
 				}
+			} elsif ($dstat =~ /^\+\s*#\s*define\s+$Ident.*;\s*$/) {
+				$ctx =~ s/\n*$//;
+				my $cnt = statement_rawlines($ctx);
+				my $herectx = $here . "\n";
+
+				for (my $n = 0; $n < $cnt; $n++) {
+					$herectx .= raw_line($linenr, $n) . "\n";
+				}
+
+				WARN("TRAILING_SEMICOLON",
+				     "macros should not use a trailing semicolon\n" . "$herectx");
 			}
 		}
 
@@ -3914,21 +5163,138 @@ sub process {
 			}
 		}
 
+# check for single line unbalanced braces
+		if ($sline =~ /^.\s*\}\s*else\s*$/ ||
+		    $sline =~ /^.\s*else\s*\{\s*$/) {
+			CHK("BRACES", "Unbalanced braces around else statement\n" . $herecurr);
+		}
+
 # check for unnecessary blank lines around braces
 		if (($line =~ /^.\s*}\s*$/ && $prevrawline =~ /^.\s*$/)) {
-			CHK("BRACES",
-			    "Blank lines aren't necessary before a close brace '}'\n" . $hereprev);
+			if (CHK("BRACES",
+				"Blank lines aren't necessary before a close brace '}'\n" . $hereprev) &&
+			    $fix && $prevrawline =~ /^\+/) {
+				fix_delete_line($fixlinenr - 1, $prevrawline);
+			}
 		}
 		if (($rawline =~ /^.\s*$/ && $prevline =~ /^..*{\s*$/)) {
-			CHK("BRACES",
-			    "Blank lines aren't necessary after an open brace '{'\n" . $hereprev);
+			if (CHK("BRACES",
+				"Blank lines aren't necessary after an open brace '{'\n" . $hereprev) &&
+			    $fix) {
+				fix_delete_line($fixlinenr, $rawline);
+			}
 		}
 
 # no volatiles please
 		my $asm_volatile = qr{\b(__asm__|asm)\s+(__volatile__|volatile)\b};
 		if ($line =~ /\bvolatile\b/ && $line !~ /$asm_volatile/) {
 			WARN("VOLATILE",
-			     "Use of volatile is usually wrong: see Documentation/volatile-considered-harmful.txt\n" . $herecurr);
+			     "Use of volatile is usually wrong: see Documentation/process/volatile-considered-harmful.rst\n" . $herecurr);
+		}
+
+# Check for user-visible strings broken across lines, which breaks the ability
+# to grep for the string.  Make exceptions when the previous string ends in a
+# newline (multiple lines in one string constant) or '\t', '\r', ';', or '{'
+# (common in inline assembly) or is a octal \123 or hexadecimal \xaf value
+		if ($line =~ /^\+\s*$String/ &&
+		    $prevline =~ /"\s*$/ &&
+		    $prevrawline !~ /(?:\\(?:[ntr]|[0-7]{1,3}|x[0-9a-fA-F]{1,2})|;\s*|\{\s*)"\s*$/) {
+			if (WARN("SPLIT_STRING",
+				 "quoted string split across lines\n" . $hereprev) &&
+				     $fix &&
+				     $prevrawline =~ /^\+.*"\s*$/ &&
+				     $last_coalesced_string_linenr != $linenr - 1) {
+				my $extracted_string = get_quoted_string($line, $rawline);
+				my $comma_close = "";
+				if ($rawline =~ /\Q$extracted_string\E(\s*\)\s*;\s*$|\s*,\s*)/) {
+					$comma_close = $1;
+				}
+
+				fix_delete_line($fixlinenr - 1, $prevrawline);
+				fix_delete_line($fixlinenr, $rawline);
+				my $fixedline = $prevrawline;
+				$fixedline =~ s/"\s*$//;
+				$fixedline .= substr($extracted_string, 1) . trim($comma_close);
+				fix_insert_line($fixlinenr - 1, $fixedline);
+				$fixedline = $rawline;
+				$fixedline =~ s/\Q$extracted_string\E\Q$comma_close\E//;
+				if ($fixedline !~ /\+\s*$/) {
+					fix_insert_line($fixlinenr, $fixedline);
+				}
+				$last_coalesced_string_linenr = $linenr;
+			}
+		}
+
+# check for missing a space in a string concatenation
+		if ($prevrawline =~ /[^\\]\w"$/ && $rawline =~ /^\+[\t ]+"\w/) {
+			WARN('MISSING_SPACE',
+			     "break quoted strings at a space character\n" . $hereprev);
+		}
+
+# check for an embedded function name in a string when the function is known
+# This does not work very well for -f --file checking as it depends on patch
+# context providing the function name or a single line form for in-file
+# function declarations
+		if ($line =~ /^\+.*$String/ &&
+		    defined($context_function) &&
+		    get_quoted_string($line, $rawline) =~ /\b$context_function\b/ &&
+		    length(get_quoted_string($line, $rawline)) != (length($context_function) + 2)) {
+			WARN("EMBEDDED_FUNCTION_NAME",
+			     "Prefer using '\"%s...\", __func__' to using '$context_function', this function's name, in a string\n" . $herecurr);
+		}
+
+# check for spaces before a quoted newline
+		if ($rawline =~ /^.*\".*\s\\n/) {
+			if (WARN("QUOTED_WHITESPACE_BEFORE_NEWLINE",
+				 "unnecessary whitespace before a quoted newline\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/^(\+.*\".*)\s+\\n/$1\\n/;
+			}
+
+		}
+
+# concatenated string without spaces between elements
+		if ($line =~ /$String[A-Z_]/ ||
+		    ($line =~ /([A-Za-z0-9_]+)$String/ && $1 !~ /^L$/)) {
+			CHK("CONCATENATED_STRING",
+			    "Concatenated strings should use spaces between elements\n" . $herecurr);
+		}
+
+# uncoalesced string fragments
+		if ($line =~ /$String\s*L?"/) {
+			WARN("STRING_FRAGMENTS",
+			     "Consecutive strings are generally better as a single string\n" . $herecurr);
+		}
+
+# check for non-standard and hex prefixed decimal printf formats
+		my $show_L = 1;	#don't show the same defect twice
+		my $show_Z = 1;
+		while ($line =~ /(?:^|")([X\t]*)(?:"|$)/g) {
+			my $string = substr($rawline, $-[1], $+[1] - $-[1]);
+			$string =~ s/%%/__/g;
+			# check for %L
+			if ($show_L && $string =~ /%[\*\d\.\$]*L([diouxX])/) {
+				WARN("PRINTF_L",
+				     "\%L$1 is non-standard C, use %ll$1\n" . $herecurr);
+				$show_L = 0;
+			}
+			# check for %Z
+			if ($show_Z && $string =~ /%[\*\d\.\$]*Z([diouxX])/) {
+				WARN("PRINTF_Z",
+				     "%Z$1 is non-standard C, use %z$1\n" . $herecurr);
+				$show_Z = 0;
+			}
+			# check for 0x<decimal>
+			if ($string =~ /0x%[\*\d\.\$\Llzth]*[diou]/) {
+				ERROR("PRINTF_0XDECIMAL",
+				      "Prefixing 0x with decimal output is defective\n" . $herecurr);
+			}
+		}
+
+# check for line continuations in quoted strings with odd counts of "
+		if ($rawline =~ /\\$/ && $rawline =~ tr/"/"/ % 2) {
+			WARN("LINE_CONTINUATIONS",
+			     "Avoid line continuations in quoted strings\n" . $herecurr);
 		}
 
 # warn about #if 0
@@ -3940,10 +5306,90 @@ sub process {
 
 # check for needless "if (<foo>) fn(<foo>)" uses
 		if ($prevline =~ /\bif\s*\(\s*($Lval)\s*\)/) {
-			my $expr = '\s*\(\s*' . quotemeta($1) . '\s*\)\s*;';
-			if ($line =~ /\b(kfree|usb_free_urb|debugfs_remove(?:_recursive)?)$expr/) {
-				WARN('NEEDLESS_IF',
-				     "$1(NULL) is safe this check is probably not required\n" . $hereprev);
+			my $tested = quotemeta($1);
+			my $expr = '\s*\(\s*' . $tested . '\s*\)\s*;';
+			if ($line =~ /\b(kfree|usb_free_urb|debugfs_remove(?:_recursive)?|(?:kmem_cache|mempool|dma_pool)_destroy)$expr/) {
+				my $func = $1;
+				if (WARN('NEEDLESS_IF',
+					 "$func(NULL) is safe and this check is probably not required\n" . $hereprev) &&
+				    $fix) {
+					my $do_fix = 1;
+					my $leading_tabs = "";
+					my $new_leading_tabs = "";
+					if ($lines[$linenr - 2] =~ /^\+(\t*)if\s*\(\s*$tested\s*\)\s*$/) {
+						$leading_tabs = $1;
+					} else {
+						$do_fix = 0;
+					}
+					if ($lines[$linenr - 1] =~ /^\+(\t+)$func\s*\(\s*$tested\s*\)\s*;\s*$/) {
+						$new_leading_tabs = $1;
+						if (length($leading_tabs) + 1 ne length($new_leading_tabs)) {
+							$do_fix = 0;
+						}
+					} else {
+						$do_fix = 0;
+					}
+					if ($do_fix) {
+						fix_delete_line($fixlinenr - 1, $prevrawline);
+						$fixed[$fixlinenr] =~ s/^\+$new_leading_tabs/\+$leading_tabs/;
+					}
+				}
+			}
+		}
+
+# check for unnecessary "Out of Memory" messages
+		if ($line =~ /^\+.*\b$logFunctions\s*\(/ &&
+		    $prevline =~ /^[ \+]\s*if\s*\(\s*(\!\s*|NULL\s*==\s*)?($Lval)(\s*==\s*NULL\s*)?\s*\)/ &&
+		    (defined $1 || defined $3) &&
+		    $linenr > 3) {
+			my $testval = $2;
+			my $testline = $lines[$linenr - 3];
+
+			my ($s, $c) = ctx_statement_block($linenr - 3, $realcnt, 0);
+#			print("line: <$line>\nprevline: <$prevline>\ns: <$s>\nc: <$c>\n\n\n");
+
+			if ($s =~ /(?:^|\n)[ \+]\s*(?:$Type\s*)?\Q$testval\E\s*=\s*(?:\([^\)]*\)\s*)?\s*(?:devm_)?(?:[kv][czm]alloc(?:_node|_array)?\b|kstrdup|kmemdup|(?:dev_)?alloc_skb)/) {
+				WARN("OOM_MESSAGE",
+				     "Possible unnecessary 'out of memory' message\n" . $hereprev);
+			}
+		}
+
+# check for logging functions with KERN_<LEVEL>
+		if ($line !~ /printk(?:_ratelimited|_once)?\s*\(/ &&
+		    $line =~ /\b$logFunctions\s*\(.*\b(KERN_[A-Z]+)\b/) {
+			my $level = $1;
+			if (WARN("UNNECESSARY_KERN_LEVEL",
+				 "Possible unnecessary $level\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\s*$level\s*//;
+			}
+		}
+
+# check for logging continuations
+		if ($line =~ /\bprintk\s*\(\s*KERN_CONT\b|\bpr_cont\s*\(/) {
+			WARN("LOGGING_CONTINUATION",
+			     "Avoid logging continuation uses where feasible\n" . $herecurr);
+		}
+
+# check for mask then right shift without a parentheses
+		if ($^V && $^V ge 5.10.0 &&
+		    $line =~ /$LvalOrFunc\s*\&\s*($LvalOrFunc)\s*>>/ &&
+		    $4 !~ /^\&/) { # $LvalOrFunc may be &foo, ignore if so
+			WARN("MASK_THEN_SHIFT",
+			     "Possible precedence defect with mask then right shift - may need parentheses\n" . $herecurr);
+		}
+
+# check for pointer comparisons to NULL
+		if ($^V && $^V ge 5.10.0) {
+			while ($line =~ /\b$LvalOrFunc\s*(==|\!=)\s*NULL\b/g) {
+				my $val = $1;
+				my $equal = "!";
+				$equal = "" if ($4 eq "!=");
+				if (CHK("COMPARISON_TO_NULL",
+					"Comparison to NULL could be written \"${equal}${val}\"\n" . $herecurr) &&
+					    $fix) {
+					$fixed[$fixlinenr] =~ s/\b\Q$val\E\s*(?:==|\!=)\s*NULL\b/$equal$val/;
+				}
 			}
 		}
 
@@ -3960,7 +5406,7 @@ sub process {
 				      WARN("MISPLACED_INIT",
 					   "$attr should be placed after $var\n" . $herecurr))) &&
 				    $fix) {
-					$fixed[$linenr - 1] =~ s/(\bstatic\s+(?:const\s+)?)(?:$attr\s+)?($NonptrTypeWithAttr)\s+(?:$attr\s+)?($Ident(?:\[[^]]*\])?)\s*([=;])\s*/"$1" . trim(string_find_replace($2, "\\s*$attr\\s*", " ")) . " " . trim(string_find_replace($3, "\\s*$attr\\s*", "")) . " $attr" . ("$4" eq ";" ? ";" : " = ")/e;
+					$fixed[$fixlinenr] =~ s/(\bstatic\s+(?:const\s+)?)(?:$attr\s+)?($NonptrTypeWithAttr)\s+(?:$attr\s+)?($Ident(?:\[[^]]*\])?)\s*([=;])\s*/"$1" . trim(string_find_replace($2, "\\s*$attr\\s*", " ")) . " " . trim(string_find_replace($3, "\\s*$attr\\s*", "")) . " $attr" . ("$4" eq ";" ? ";" : " = ")/e;
 				}
 			}
 		}
@@ -3974,7 +5420,7 @@ sub process {
 			if (ERROR("INIT_ATTRIBUTE",
 				  "Use of const init definition must use ${attr_prefix}initconst\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/$InitAttributeData/${attr_prefix}initconst/;
 			}
 		}
@@ -3985,21 +5431,49 @@ sub process {
 			if (ERROR("INIT_ATTRIBUTE",
 				  "Use of $attr requires a separate use of const\n" . $herecurr) &&
 			    $fix) {
-				my $lead = $fixed[$linenr - 1] =~
+				my $lead = $fixed[$fixlinenr] =~
 				    /(^\+\s*(?:static\s+))/;
 				$lead = rtrim($1);
 				$lead = "$lead " if ($lead !~ /^\+$/);
 				$lead = "${lead}const ";
-				$fixed[$linenr - 1] =~ s/(^\+\s*(?:static\s+))/$lead/;
+				$fixed[$fixlinenr] =~ s/(^\+\s*(?:static\s+))/$lead/;
+			}
+		}
+
+# check for __read_mostly with const non-pointer (should just be const)
+		if ($line =~ /\b__read_mostly\b/ &&
+		    $line =~ /($Type)\s*$Ident/ && $1 !~ /\*\s*$/ && $1 =~ /\bconst\b/) {
+			if (ERROR("CONST_READ_MOSTLY",
+				  "Invalid use of __read_mostly with const type\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\s+__read_mostly\b//;
+			}
+		}
+
+# don't use __constant_<foo> functions outside of include/uapi/
+		if ($realfile !~ m@^include/uapi/@ &&
+		    $line =~ /(__constant_(?:htons|ntohs|[bl]e(?:16|32|64)_to_cpu|cpu_to_[bl]e(?:16|32|64)))\s*\(/) {
+			my $constant_func = $1;
+			my $func = $constant_func;
+			$func =~ s/^__constant_//;
+			if (WARN("CONSTANT_CONVERSION",
+				 "$constant_func should be $func\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\b$constant_func\b/$func/g;
 			}
 		}
 
 # prefer usleep_range over udelay
 		if ($line =~ /\budelay\s*\(\s*(\d+)\s*\)/) {
+			my $delay = $1;
 			# ignore udelay's < 10, however
-			if (! ($1 < 10) ) {
+			if (! ($delay < 10) ) {
 				CHK("USLEEP_RANGE",
-				    "usleep_range is preferred over udelay; see Documentation/timers/timers-howto.txt\n" . $line);
+				    "usleep_range is preferred over udelay; see Documentation/timers/timers-howto.txt\n" . $herecurr);
+			}
+			if ($delay > 2000) {
+				WARN("LONG_UDELAY",
+				     "long udelay - prefer mdelay; see arch/arm/include/asm/delay.h\n" . $herecurr);
 			}
 		}
 
@@ -4007,7 +5481,7 @@ sub process {
 		if ($line =~ /\bmsleep\s*\((\d+)\);/) {
 			if ($1 < 20) {
 				WARN("MSLEEP",
-				     "msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt\n" . $line);
+				     "msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt\n" . $herecurr);
 			}
 		}
 
@@ -4035,7 +5509,7 @@ sub process {
 			if (ERROR("SPACING",
 				  "exactly one space required after that #$1\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~
+				$fixed[$fixlinenr] =~
 				    s/^(.\s*\#\s*(ifdef|ifndef|elif))\s{2,}/$1 /;
 			}
 
@@ -4051,22 +5525,70 @@ sub process {
 			}
 		}
 # check for memory barriers without a comment.
-		if ($line =~ /\b(mb|rmb|wmb|read_barrier_depends|smp_mb|smp_rmb|smp_wmb|smp_read_barrier_depends)\(/) {
+
+		my $barriers = qr{
+			mb|
+			rmb|
+			wmb|
+			read_barrier_depends
+		}x;
+		my $barrier_stems = qr{
+			mb__before_atomic|
+			mb__after_atomic|
+			store_release|
+			load_acquire|
+			store_mb|
+			(?:$barriers)
+		}x;
+		my $all_barriers = qr{
+			(?:$barriers)|
+			smp_(?:$barrier_stems)|
+			virt_(?:$barrier_stems)
+		}x;
+
+		if ($line =~ /\b(?:$all_barriers)\s*\(/) {
 			if (!ctx_has_comment($first_line, $linenr)) {
 				WARN("MEMORY_BARRIER",
 				     "memory barrier without comment\n" . $herecurr);
 			}
 		}
+
+		my $underscore_smp_barriers = qr{__smp_(?:$barrier_stems)}x;
+
+		if ($realfile !~ m@^include/asm-generic/@ &&
+		    $realfile !~ m@/barrier\.h$@ &&
+		    $line =~ m/\b(?:$underscore_smp_barriers)\s*\(/ &&
+		    $line !~ m/^.\s*\#\s*define\s+(?:$underscore_smp_barriers)\s*\(/) {
+			WARN("MEMORY_BARRIER",
+			     "__smp memory barriers shouldn't be used outside barrier.h and asm-generic\n" . $herecurr);
+		}
+
+# check for waitqueue_active without a comment.
+		if ($line =~ /\bwaitqueue_active\s*\(/) {
+			if (!ctx_has_comment($first_line, $linenr)) {
+				WARN("WAITQUEUE_ACTIVE",
+				     "waitqueue_active without comment\n" . $herecurr);
+			}
+		}
+
 # check of hardware specific defines
 		if ($line =~ m@^.\s*\#\s*if.*\b(__i386__|__powerpc64__|__sun__|__s390x__)\b@ && $realfile !~ m@include/asm-@) {
 			CHK("ARCH_DEFINES",
 			    "architecture specific defines should be avoided\n" .  $herecurr);
 		}
 
+# check that the storage class is not after a type
+		if ($line =~ /\b($Type)\s+($Storage)\b/) {
+			WARN("STORAGE_CLASS",
+			     "storage class '$2' should be located before type '$1'\n" . $herecurr);
+		}
 # Check that the storage class is at the beginning of a declaration
-		if ($line =~ /\b$Storage\b/ && $line !~ /^.\s*$Storage\b/) {
+		if ($line =~ /\b$Storage\b/ &&
+		    $line !~ /^.\s*$Storage/ &&
+		    $line =~ /^.\s*(.+?)\$Storage\s/ &&
+		    $1 !~ /[\,\)]\s*$/) {
 			WARN("STORAGE_CLASS",
-			     "storage class should be at the beginning of the declaration\n" . $herecurr)
+			     "storage class should be at the beginning of the declaration\n" . $herecurr);
 		}
 
 # check the location of the inline attribute, that it is between
@@ -4083,7 +5605,7 @@ sub process {
 			if (WARN("INLINE",
 				 "plain inline is preferred over $1\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\b(__inline__|__inline)\b/inline/;
+				$fixed[$fixlinenr] =~ s/\b(__inline__|__inline)\b/inline/;
 
 			}
 		}
@@ -4094,8 +5616,10 @@ sub process {
 			WARN("PREFER_PACKED",
 			     "__packed is preferred over __attribute__((packed))\n" . $herecurr);
 		}
+
 # Check for new packed members, warn to use care
-		if ($line =~ /\b(__attribute__\s*\(\s*\(.*\bpacked|__packed)\b/) {
+		if ($realfile !~ m@\binclude/uapi/@ &&
+		    $line =~ /\b(__attribute__\s*\(\s*\(.*\bpacked|__packed)\b/) {
 			WARN("NEW_PACKED",
 			     "Adding new packed members is to be done with care\n" . $herecurr);
 		}
@@ -4113,7 +5637,7 @@ sub process {
 			if (WARN("PREFER_PRINTF",
 				 "__printf(string-index, first-to-check) is preferred over __attribute__((format(printf, string-index, first-to-check)))\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*printf\s*,\s*(.*)\)\s*\)\s*\)/"__printf(" . trim($1) . ")"/ex;
+				$fixed[$fixlinenr] =~ s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*printf\s*,\s*(.*)\)\s*\)\s*\)/"__printf(" . trim($1) . ")"/ex;
 
 			}
 		}
@@ -4124,7 +5648,55 @@ sub process {
 			if (WARN("PREFER_SCANF",
 				 "__scanf(string-index, first-to-check) is preferred over __attribute__((format(scanf, string-index, first-to-check)))\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*scanf\s*,\s*(.*)\)\s*\)\s*\)/"__scanf(" . trim($1) . ")"/ex;
+				$fixed[$fixlinenr] =~ s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*scanf\s*,\s*(.*)\)\s*\)\s*\)/"__scanf(" . trim($1) . ")"/ex;
+			}
+		}
+
+# Check for __attribute__ weak, or __weak declarations (may have link issues)
+		if ($^V && $^V ge 5.10.0 &&
+		    $line =~ /(?:$Declare|$DeclareMisordered)\s*$Ident\s*$balanced_parens\s*(?:$Attribute)?\s*;/ &&
+		    ($line =~ /\b__attribute__\s*\(\s*\(.*\bweak\b/ ||
+		     $line =~ /\b__weak\b/)) {
+			ERROR("WEAK_DECLARATION",
+			      "Using weak declarations can have unintended link defects\n" . $herecurr);
+		}
+
+# check for c99 types like uint8_t used outside of uapi/ and tools/
+		if ($realfile !~ m@\binclude/uapi/@ &&
+		    $realfile !~ m@\btools/@ &&
+		    $line =~ /\b($Declare)\s*$Ident\s*[=;,\[]/) {
+			my $type = $1;
+			if ($type =~ /\b($typeC99Typedefs)\b/) {
+				$type = $1;
+				my $kernel_type = 'u';
+				$kernel_type = 's' if ($type =~ /^_*[si]/);
+				$type =~ /(\d+)/;
+				$kernel_type .= $1;
+				if (CHK("PREFER_KERNEL_TYPES",
+					"Prefer kernel type '$kernel_type' over '$type'\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\b$type\b/$kernel_type/;
+				}
+			}
+		}
+
+# check for cast of C90 native int or longer types constants
+		if ($line =~ /(\(\s*$C90_int_types\s*\)\s*)($Constant)\b/) {
+			my $cast = $1;
+			my $const = $2;
+			if (WARN("TYPECAST_INT_CONSTANT",
+				 "Unnecessary typecast of c90 int constant\n" . $herecurr) &&
+			    $fix) {
+				my $suffix = "";
+				my $newconst = $const;
+				$newconst =~ s/${Int_type}$//;
+				$suffix .= 'U' if ($cast =~ /\bunsigned\b/);
+				if ($cast =~ /\blong\s+long\b/) {
+					$suffix .= 'LL';
+				} elsif ($cast =~ /\blong\b/) {
+					$suffix .= 'L';
+				}
+				$fixed[$fixlinenr] =~ s/\Q$cast\E$const\b/$newconst$suffix/;
 			}
 		}
 
@@ -4139,16 +5711,10 @@ sub process {
 			if (WARN("SIZEOF_PARENTHESIS",
 				 "sizeof $1 should be sizeof($1)\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\bsizeof\s+((?:\*\s*|)$Lval|$Type(?:\s+$Lval|))/"sizeof(" . trim($1) . ")"/ex;
+				$fixed[$fixlinenr] =~ s/\bsizeof\s+((?:\*\s*|)$Lval|$Type(?:\s+$Lval|))/"sizeof(" . trim($1) . ")"/ex;
 			}
 		}
 
-# check for line continuations in quoted strings with odd counts of "
-		if ($rawline =~ /\\$/ && $rawline =~ tr/"/"/ % 2) {
-			WARN("LINE_CONTINUATIONS",
-			     "Avoid line continuations in quoted strings\n" . $herecurr);
-		}
-
 # check for struct spinlock declarations
 		if ($line =~ /^.\s*\bstruct\s+spinlock\s+\w+\s*;/) {
 			WARN("USE_SPINLOCK_T",
@@ -4158,19 +5724,46 @@ sub process {
 # check for seq_printf uses that could be seq_puts
 		if ($sline =~ /\bseq_printf\s*\(.*"\s*\)\s*;\s*$/) {
 			my $fmt = get_quoted_string($line, $rawline);
-			if ($fmt ne "" && $fmt !~ /[^\\]\%/) {
+			$fmt =~ s/%%//g;
+			if ($fmt !~ /%/) {
 				if (WARN("PREFER_SEQ_PUTS",
 					 "Prefer seq_puts to seq_printf\n" . $herecurr) &&
 				    $fix) {
-					$fixed[$linenr - 1] =~ s/\bseq_printf\b/seq_puts/;
+					$fixed[$fixlinenr] =~ s/\bseq_printf\b/seq_puts/;
+				}
+			}
+		}
+
+		# check for vsprintf extension %p<foo> misuses
+		if ($^V && $^V ge 5.10.0 &&
+		    defined $stat &&
+		    $stat =~ /^\+(?![^\{]*\{\s*).*\b(\w+)\s*\(.*$String\s*,/s &&
+		    $1 !~ /^_*volatile_*$/) {
+			my $bad_extension = "";
+			my $lc = $stat =~ tr@\n@@;
+			$lc = $lc + $linenr;
+		        for (my $count = $linenr; $count <= $lc; $count++) {
+				my $fmt = get_quoted_string($lines[$count - 1], raw_line($count, 0));
+				$fmt =~ s/%%//g;
+				if ($fmt =~ /(\%[\*\d\.]*p(?![\WFfSsBKRraEhMmIiUDdgVCbGNO]).)/) {
+					$bad_extension = $1;
+					last;
 				}
 			}
+			if ($bad_extension ne "") {
+				my $stat_real = raw_line($linenr, 0);
+				for (my $count = $linenr + 1; $count <= $lc; $count++) {
+					$stat_real = $stat_real . "\n" . raw_line($count, 0);
+				}
+				WARN("VSPRINTF_POINTER_EXTENSION",
+				     "Invalid vsprintf pointer extension '$bad_extension'\n" . "$here\n$stat_real\n");
+			}
 		}
 
 # Check for misused memsets
 		if ($^V && $^V ge 5.10.0 &&
 		    defined $stat &&
-		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*$FuncArg\s*\)/s) {
+		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*$FuncArg\s*\)/) {
 
 			my $ms_addr = $2;
 			my $ms_val = $7;
@@ -4186,14 +5779,46 @@ sub process {
 		}
 
 # Check for memcpy(foo, bar, ETH_ALEN) that could be ether_addr_copy(foo, bar)
-		if ($^V && $^V ge 5.10.0 &&
-		    $line =~ /^\+(?:.*?)\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/s) {
-			if (WARN("PREFER_ETHER_ADDR_COPY",
-				 "Prefer ether_addr_copy() over memcpy() if the Ethernet addresses are __aligned(2)\n" . $herecurr) &&
-			    $fix) {
-				$fixed[$linenr - 1] =~ s/\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/ether_addr_copy($2, $7)/;
-			}
-		}
+#		if ($^V && $^V ge 5.10.0 &&
+#		    defined $stat &&
+#		    $stat =~ /^\+(?:.*?)\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
+#			if (WARN("PREFER_ETHER_ADDR_COPY",
+#				 "Prefer ether_addr_copy() over memcpy() if the Ethernet addresses are __aligned(2)\n" . "$here\n$stat\n") &&
+#			    $fix) {
+#				$fixed[$fixlinenr] =~ s/\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/ether_addr_copy($2, $7)/;
+#			}
+#		}
+
+# Check for memcmp(foo, bar, ETH_ALEN) that could be ether_addr_equal*(foo, bar)
+#		if ($^V && $^V ge 5.10.0 &&
+#		    defined $stat &&
+#		    $stat =~ /^\+(?:.*?)\bmemcmp\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
+#			WARN("PREFER_ETHER_ADDR_EQUAL",
+#			     "Prefer ether_addr_equal() or ether_addr_equal_unaligned() over memcmp()\n" . "$here\n$stat\n")
+#		}
+
+# check for memset(foo, 0x0, ETH_ALEN) that could be eth_zero_addr
+# check for memset(foo, 0xFF, ETH_ALEN) that could be eth_broadcast_addr
+#		if ($^V && $^V ge 5.10.0 &&
+#		    defined $stat &&
+#		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
+#
+#			my $ms_val = $7;
+#
+#			if ($ms_val =~ /^(?:0x|)0+$/i) {
+#				if (WARN("PREFER_ETH_ZERO_ADDR",
+#					 "Prefer eth_zero_addr over memset()\n" . "$here\n$stat\n") &&
+#				    $fix) {
+#					$fixed[$fixlinenr] =~ s/\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*,\s*ETH_ALEN\s*\)/eth_zero_addr($2)/;
+#				}
+#			} elsif ($ms_val =~ /^(?:0xff|255)$/i) {
+#				if (WARN("PREFER_ETH_BROADCAST_ADDR",
+#					 "Prefer eth_broadcast_addr() over memset()\n" . "$here\n$stat\n") &&
+#				    $fix) {
+#					$fixed[$fixlinenr] =~ s/\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*,\s*ETH_ALEN\s*\)/eth_broadcast_addr($2)/;
+#				}
+#			}
+#		}
 
 # typecasts on min/max could be min_t/max_t
 		if ($^V && $^V ge 5.10.0 &&
@@ -4238,7 +5863,7 @@ sub process {
 # check for naked sscanf
 		if ($^V && $^V ge 5.10.0 &&
 		    defined $stat &&
-		    $stat =~ /\bsscanf\b/ &&
+		    $line =~ /\bsscanf\b/ &&
 		    ($stat !~ /$Ident\s*=\s*sscanf\s*$balanced_parens/ &&
 		     $stat !~ /\bsscanf\s*$balanced_parens\s*(?:$Compare)/ &&
 		     $stat !~ /(?:$Compare)\s*\bsscanf\s*$balanced_parens/)) {
@@ -4252,13 +5877,34 @@ sub process {
 			     "unchecked sscanf return value\n" . "$here\n$stat_real\n");
 		}
 
+# check for simple sscanf that should be kstrto<foo>
+		if ($^V && $^V ge 5.10.0 &&
+		    defined $stat &&
+		    $line =~ /\bsscanf\b/) {
+			my $lc = $stat =~ tr@\n@@;
+			$lc = $lc + $linenr;
+			my $stat_real = raw_line($linenr, 0);
+		        for (my $count = $linenr + 1; $count <= $lc; $count++) {
+				$stat_real = $stat_real . "\n" . raw_line($count, 0);
+			}
+			if ($stat_real =~ /\bsscanf\b\s*\(\s*$FuncArg\s*,\s*("[^"]+")/) {
+				my $format = $6;
+				my $count = $format =~ tr@%@%@;
+				if ($count == 1 &&
+				    $format =~ /^"\%(?i:ll[udxi]|[udxi]ll|ll|[hl]h?[udxi]|[udxi][hl]h?|[hl]h?|[udxi])"$/) {
+					WARN("SSCANF_TO_KSTRTO",
+					     "Prefer kstrto<type> to single variable sscanf\n" . "$here\n$stat_real\n");
+				}
+			}
+		}
+
 # check for new externs in .h files.
 		if ($realfile =~ /\.h$/ &&
 		    $line =~ /^\+\s*(extern\s+)$Type\s*$Ident\s*\(/s) {
 			if (CHK("AVOID_EXTERNS",
 				"extern prototypes should be avoided in .h files\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/(.*)\bextern\b\s*(.*)/$1$2/;
+				$fixed[$fixlinenr] =~ s/(.*)\bextern\b\s*(.*)/$1$2/;
 			}
 		}
 
@@ -4292,13 +5938,50 @@ sub process {
 			     "externs should be avoided in .c files\n" .  $herecurr);
 		}
 
+# check for function declarations that have arguments without identifier names
+		if (defined $stat &&
+		    $stat =~ /^.\s*(?:extern\s+)?$Type\s*$Ident\s*\(\s*([^{]+)\s*\)\s*;/s &&
+		    $1 ne "void") {
+			my $args = trim($1);
+			while ($args =~ m/\s*($Type\s*(?:$Ident|\(\s*\*\s*$Ident?\s*\)\s*$balanced_parens)?)/g) {
+				my $arg = trim($1);
+				if ($arg =~ /^$Type$/ && $arg !~ /enum\s+$Ident$/) {
+					WARN("FUNCTION_ARGUMENTS",
+					     "function definition argument '$arg' should also have an identifier name\n" . $herecurr);
+				}
+			}
+		}
+
+# check for function definitions
+		if ($^V && $^V ge 5.10.0 &&
+		    defined $stat &&
+		    $stat =~ /^.\s*(?:$Storage\s+)?$Type\s*($Ident)\s*$balanced_parens\s*{/s) {
+			$context_function = $1;
+
+# check for multiline function definition with misplaced open brace
+			my $ok = 0;
+			my $cnt = statement_rawlines($stat);
+			my $herectx = $here . "\n";
+			for (my $n = 0; $n < $cnt; $n++) {
+				my $rl = raw_line($linenr, $n);
+				$herectx .=  $rl . "\n";
+				$ok = 1 if ($rl =~ /^[ \+]\{/);
+				$ok = 1 if ($rl =~ /\{/ && $n == 0);
+				last if $rl =~ /^[ \+].*\{/;
+			}
+			if (!$ok) {
+				ERROR("OPEN_BRACE",
+				      "open brace '{' following function definitions go on the next line\n" . $herectx);
+			}
+		}
+
 # checks for new __setup's
 		if ($rawline =~ /\b__setup\("([^"]*)"/) {
 			my $name = $1;
 
 			if (!grep(/$name/, @setup_docs)) {
 				CHK("UNDOCUMENTED_SETUP",
-				    "__setup appears un-documented -- check Documentation/kernel-parameters.txt\n" . $herecurr);
+				    "__setup appears un-documented -- check Documentation/admin-guide/kernel-parameters.rst\n" . $herecurr);
 			}
 		}
 
@@ -4316,6 +5999,38 @@ sub process {
 			    "Prefer $3(sizeof(*$1)...) over $3($4...)\n" . $herecurr);
 		}
 
+# check for k[mz]alloc with multiplies that could be kmalloc_array/kcalloc
+		if ($^V && $^V ge 5.10.0 &&
+		    defined $stat &&
+		    $stat =~ /^\+\s*($Lval)\s*\=\s*(?:$balanced_parens)?\s*(k[mz]alloc)\s*\(\s*($FuncArg)\s*\*\s*($FuncArg)\s*,/) {
+			my $oldfunc = $3;
+			my $a1 = $4;
+			my $a2 = $10;
+			my $newfunc = "kmalloc_array";
+			$newfunc = "kcalloc" if ($oldfunc eq "kzalloc");
+			my $r1 = $a1;
+			my $r2 = $a2;
+			if ($a1 =~ /^sizeof\s*\S/) {
+				$r1 = $a2;
+				$r2 = $a1;
+			}
+			if ($r1 !~ /^sizeof\b/ && $r2 =~ /^sizeof\s*\S/ &&
+			    !($r1 =~ /^$Constant$/ || $r1 =~ /^[A-Z_][A-Z0-9_]*$/)) {
+				my $ctx = '';
+				my $herectx = $here . "\n";
+				my $cnt = statement_rawlines($stat);
+				for (my $n = 0; $n < $cnt; $n++) {
+					$herectx .= raw_line($linenr, $n) . "\n";
+				}
+				if (WARN("ALLOC_WITH_MULTIPLY",
+					 "Prefer $newfunc over $oldfunc with multiply\n" . $herectx) &&
+				    $cnt == 1 &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*(k[mz]alloc)\s*\(\s*($FuncArg)\s*\*\s*($FuncArg)/$1 . ' = ' . "$newfunc(" . trim($r1) . ', ' . trim($r2)/e;
+				}
+			}
+		}
+
 # check for krealloc arg reuse
 		if ($^V && $^V ge 5.10.0 &&
 		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*krealloc\s*\(\s*\1\s*,/) {
@@ -4329,18 +6044,34 @@ sub process {
 			     "$1 uses number as first arg, sizeof is generally wrong\n" . $herecurr);
 		}
 
-# check for GFP_NOWAIT use
-		if ($line =~ /\b__GFP_NOFAIL\b/) {
-			WARN("__GFP_NOFAIL",
-			     "Use of __GFP_NOFAIL is deprecated, no new users should be added\n" . $herecurr);
-		}
-
 # check for multiple semicolons
 		if ($line =~ /;\s*;\s*$/) {
 			if (WARN("ONE_SEMICOLON",
 				 "Statements terminations use 1 semicolon\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/(\s*;\s*){2,}$/;/g;
+				$fixed[$fixlinenr] =~ s/(\s*;\s*){2,}$/;/g;
+			}
+		}
+
+# check for #defines like: 1 << <digit> that could be BIT(digit), it is not exported to uapi
+		if ($realfile !~ m@^include/uapi/@ &&
+		    $line =~ /#\s*define\s+\w+\s+\(?\s*1\s*([ulUL]*)\s*\<\<\s*(?:\d+|$Ident)\s*\)?/) {
+			my $ull = "";
+			$ull = "_ULL" if (defined($1) && $1 =~ /ll/i);
+			if (CHK("BIT_MACRO",
+				"Prefer using the BIT$ull macro\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\(?\s*1\s*[ulUL]*\s*<<\s*(\d+|$Ident)\s*\)?/BIT${ull}($1)/;
+			}
+		}
+
+# check for #if defined CONFIG_<FOO> || defined CONFIG_<FOO>_MODULE
+		if ($line =~ /^\+\s*#\s*if\s+defined(?:\s*\(?\s*|\s+)(CONFIG_[A-Z_]+)\s*\)?\s*\|\|\s*defined(?:\s*\(?\s*|\s+)\1_MODULE\s*\)?\s*$/) {
+			my $config = $1;
+			if (WARN("PREFER_IS_ENABLED",
+				 "Prefer IS_ENABLED(<FOO>) to CONFIG_<FOO> || CONFIG_<FOO>_MODULE\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] = "\+#if IS_ENABLED($config)";
 			}
 		}
 
@@ -4350,7 +6081,7 @@ sub process {
 			my $has_statement = 0;
 			my $count = 0;
 			my $prevline = $linenr;
-			while ($prevline > 1 && $count < 3 && !$has_break) {
+			while ($prevline > 1 && ($file || $count < 3) && !$has_break) {
 				$prevline--;
 				my $rline = $rawlines[$prevline - 1];
 				my $fline = $lines[$prevline - 1];
@@ -4388,10 +6119,16 @@ sub process {
 			if (WARN("USE_FUNC",
 				 "__func__ should be used instead of gcc specific __FUNCTION__\n"  . $herecurr) &&
 			    $fix) {
-				$fixed[$linenr - 1] =~ s/\b__FUNCTION__\b/__func__/g;
+				$fixed[$fixlinenr] =~ s/\b__FUNCTION__\b/__func__/g;
 			}
 		}
 
+# check for uses of __DATE__, __TIME__, __TIMESTAMP__
+		while ($line =~ /\b(__(?:DATE|TIME|TIMESTAMP)__)\b/g) {
+			ERROR("DATE_TIME",
+			      "Use of the '$1' macro makes the build non-deterministic\n" . $herecurr);
+		}
+
 # check for use of yield()
 		if ($line =~ /\byield\s*\(\s*\)/) {
 			WARN("YIELD",
@@ -4437,55 +6174,18 @@ sub process {
 			     "$1 is obsolete, use k$3 instead\n" . $herecurr);
 		}
 
-# check for __initcall(), use device_initcall() explicitly please
+# check for __initcall(), use device_initcall() explicitly or more appropriate function please
 		if ($line =~ /^.\s*__initcall\s*\(/) {
 			WARN("USE_DEVICE_INITCALL",
-			     "please use device_initcall() instead of __initcall()\n" . $herecurr);
-		}
-
-# check for various ops structs, ensure they are const.
-		my $struct_ops = qr{acpi_dock_ops|
-				address_space_operations|
-				backlight_ops|
-				block_device_operations|
-				dentry_operations|
-				dev_pm_ops|
-				dma_map_ops|
-				extent_io_ops|
-				file_lock_operations|
-				file_operations|
-				hv_ops|
-				ide_dma_ops|
-				intel_dvo_dev_ops|
-				item_operations|
-				iwl_ops|
-				kgdb_arch|
-				kgdb_io|
-				kset_uevent_ops|
-				lock_manager_operations|
-				microcode_ops|
-				mtrr_ops|
-				neigh_ops|
-				nlmsvc_binding|
-				pci_raw_ops|
-				pipe_buf_operations|
-				platform_hibernation_ops|
-				platform_suspend_ops|
-				proto_ops|
-				rpc_pipe_ops|
-				seq_operations|
-				snd_ac97_build_ops|
-				soc_pcmcia_socket_ops|
-				stacktrace_ops|
-				sysfs_ops|
-				tty_operations|
-				usb_mon_operations|
-				wd_ops}x;
+			     "please use device_initcall() or more appropriate function instead of __initcall() (see include/linux/init.h)\n" . $herecurr);
+		}
+
+# check for various structs that are normally const (ops, kgdb, device_tree)
+# and avoid what seem like struct definitions 'struct foo {'
 		if ($line !~ /\bconst\b/ &&
-		    $line =~ /\bstruct\s+($struct_ops)\b/) {
+		    $line =~ /\bstruct\s+($const_structs)\b(?!\s*\{)/) {
 			WARN("CONST_STRUCT",
-			     "struct $1 should normally be const\n" .
-				$herecurr);
+			     "struct $1 should normally be const\n" . $herecurr);
 		}
 
 # use of NR_CPUS is usually wrong
@@ -4507,16 +6207,11 @@ sub process {
 			      "#define of '$1' is wrong - use Kconfig variables or standard guards instead\n" . $herecurr);
 		}
 
-# check for %L{u,d,i} in strings
-		my $string;
-		while ($line =~ /(?:^|")([X\t]*)(?:"|$)/g) {
-			$string = substr($rawline, $-[1], $+[1] - $-[1]);
-			$string =~ s/%%/__/g;
-			if ($string =~ /(?<!%)%L[udi]/) {
-				WARN("PRINTF_L",
-				     "\%Ld/%Lu are not-standard C, use %lld/%llu\n" . $herecurr);
-				last;
-			}
+# likely/unlikely comparisons similar to "(likely(foo) > 0)"
+		if ($^V && $^V ge 5.10.0 &&
+		    $line =~ /\b((?:un)?likely)\s*\(\s*$FuncArg\s*\)\s*$Compare/) {
+			WARN("LIKELY_MISUSE",
+			     "Using $1 should generally have parentheses around the comparison\n" . $herecurr);
 		}
 
 # whine mightly about in_atomic
@@ -4530,6 +6225,34 @@ sub process {
 			}
 		}
 
+# whine about ACCESS_ONCE
+		if ($^V && $^V ge 5.10.0 &&
+		    $line =~ /\bACCESS_ONCE\s*$balanced_parens\s*(=(?!=))?\s*($FuncArg)?/) {
+			my $par = $1;
+			my $eq = $2;
+			my $fun = $3;
+			$par =~ s/^\(\s*(.*)\s*\)$/$1/;
+			if (defined($eq)) {
+				if (WARN("PREFER_WRITE_ONCE",
+					 "Prefer WRITE_ONCE(<FOO>, <BAR>) over ACCESS_ONCE(<FOO>) = <BAR>\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\bACCESS_ONCE\s*\(\s*\Q$par\E\s*\)\s*$eq\s*\Q$fun\E/WRITE_ONCE($par, $fun)/;
+				}
+			} else {
+				if (WARN("PREFER_READ_ONCE",
+					 "Prefer READ_ONCE(<FOO>) over ACCESS_ONCE(<FOO>)\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\bACCESS_ONCE\s*\(\s*\Q$par\E\s*\)/READ_ONCE($par)/;
+				}
+			}
+		}
+
+# check for mutex_trylock_recursive usage
+		if ($line =~ /mutex_trylock_recursive/) {
+			ERROR("LOCKING",
+			      "recursive locking is bad, do not use this ever.\n" . $herecurr);
+		}
+
 # check for lockdep_set_novalidate_class
 		if ($line =~ /^.\s*lockdep_set_novalidate_class\s*\(/ ||
 		    $line =~ /__lockdep_no_validate__\s*\)/ ) {
@@ -4541,11 +6264,95 @@ sub process {
 			}
 		}
 
-		if ($line =~ /debugfs_create_file.*S_IWUGO/ ||
-		    $line =~ /DEVICE_ATTR.*S_IWUGO/ ) {
+		if ($line =~ /debugfs_create_\w+.*\b$mode_perms_world_writable\b/ ||
+		    $line =~ /DEVICE_ATTR.*\b$mode_perms_world_writable\b/) {
 			WARN("EXPORTED_WORLD_WRITABLE",
 			     "Exporting world writable files is usually an error. Consider more restrictive permissions.\n" . $herecurr);
 		}
+
+# Mode permission misuses where it seems decimal should be octal
+# This uses a shortcut match to avoid unnecessary uses of a slow foreach loop
+		if ($^V && $^V ge 5.10.0 &&
+		    defined $stat &&
+		    $line =~ /$mode_perms_search/) {
+			foreach my $entry (@mode_permission_funcs) {
+				my $func = $entry->[0];
+				my $arg_pos = $entry->[1];
+
+				my $lc = $stat =~ tr@\n@@;
+				$lc = $lc + $linenr;
+				my $stat_real = raw_line($linenr, 0);
+				for (my $count = $linenr + 1; $count <= $lc; $count++) {
+					$stat_real = $stat_real . "\n" . raw_line($count, 0);
+				}
+
+				my $skip_args = "";
+				if ($arg_pos > 1) {
+					$arg_pos--;
+					$skip_args = "(?:\\s*$FuncArg\\s*,\\s*){$arg_pos,$arg_pos}";
+				}
+				my $test = "\\b$func\\s*\\(${skip_args}($FuncArg(?:\\|\\s*$FuncArg)*)\\s*[,\\)]";
+				if ($stat =~ /$test/) {
+					my $val = $1;
+					$val = $6 if ($skip_args ne "");
+					if (($val =~ /^$Int$/ && $val !~ /^$Octal$/) ||
+					    ($val =~ /^$Octal$/ && length($val) ne 4)) {
+						ERROR("NON_OCTAL_PERMISSIONS",
+						      "Use 4 digit octal (0777) not decimal permissions\n" . "$here\n" . $stat_real);
+					}
+					if ($val =~ /^$Octal$/ && (oct($val) & 02)) {
+						ERROR("EXPORTED_WORLD_WRITABLE",
+						      "Exporting writable files is usually an error. Consider more restrictive permissions.\n" . "$here\n" . $stat_real);
+					}
+				}
+			}
+		}
+
+# check for uses of S_<PERMS> that could be octal for readability
+		if ($line =~ /\b$mode_perms_string_search\b/) {
+			my $val = "";
+			my $oval = "";
+			my $to = 0;
+			my $curpos = 0;
+			my $lastpos = 0;
+			while ($line =~ /\b(($mode_perms_string_search)\b(?:\s*\|\s*)?\s*)/g) {
+				$curpos = pos($line);
+				my $match = $2;
+				my $omatch = $1;
+				last if ($lastpos > 0 && ($curpos - length($omatch) != $lastpos));
+				$lastpos = $curpos;
+				$to |= $mode_permission_string_types{$match};
+				$val .= '\s*\|\s*' if ($val ne "");
+				$val .= $match;
+				$oval .= $omatch;
+			}
+			$oval =~ s/^\s*\|\s*//;
+			$oval =~ s/\s*\|\s*$//;
+			my $octal = sprintf("%04o", $to);
+			if (WARN("SYMBOLIC_PERMS",
+				 "Symbolic permissions '$oval' are not preferred. Consider using octal permissions '$octal'.\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/$val/$octal/;
+			}
+		}
+
+# validate content of MODULE_LICENSE against list from include/linux/module.h
+		if ($line =~ /\bMODULE_LICENSE\s*\(\s*($String)\s*\)/) {
+			my $extracted_string = get_quoted_string($line, $rawline);
+			my $valid_licenses = qr{
+						GPL|
+						GPL\ v2|
+						GPL\ and\ additional\ rights|
+						Dual\ BSD/GPL|
+						Dual\ MIT/GPL|
+						Dual\ MPL/GPL|
+						Proprietary
+					}x;
+			if ($extracted_string !~ /^"(?:$valid_licenses)"$/x) {
+				WARN("MODULE_LICENSE",
+				     "unknown module license " . $extracted_string . "\n" . $herecurr);
+			}
+		}
 	}
 
 	# If we have no input at all, then there is nothing to report on
@@ -4566,11 +6373,11 @@ sub process {
 		exit(0);
 	}
 
-	if (!$is_patch) {
+	if (!$is_patch && $file !~ /cover-letter\.patch$/) {
 		ERROR("NOT_UNIFIED_DIFF",
 		      "Does not appear to be a unified-diff format patch\n");
 	}
-	if ($is_patch && $chk_signoff && $signoff == 0) {
+	if ($is_patch && $has_commit_log && $chk_signoff && $signoff == 0) {
 		ERROR("MISSING_SIGN_OFF",
 		      "Missing Signed-off-by: line(s)\n");
 	}
@@ -4581,34 +6388,39 @@ sub process {
 		print "total: $cnt_error errors, $cnt_warn warnings, " .
 			(($check)? "$cnt_chk checks, " : "") .
 			"$cnt_lines lines checked\n";
-		print "\n" if ($quiet == 0);
 	}
 
 	if ($quiet == 0) {
+		# If there were any defects found and not already fixing them
+		if (!$clean and !$fix) {
+			print << "EOM"
 
-		if ($^V lt 5.10.0) {
-			print("NOTE: perl $^V is not modern enough to detect all possible issues.\n");
-			print("An upgrade to at least perl v5.10.0 is suggested.\n\n");
+NOTE: For some of the reported defects, checkpatch may be able to
+      mechanically convert to the typical style using --fix or --fix-inplace.
+EOM
 		}
-
 		# If there were whitespace errors which cleanpatch can fix
 		# then suggest that.
 		if ($rpt_cleaners) {
-			print "NOTE: whitespace errors detected, you may wish to use scripts/cleanpatch or\n";
-			print "      scripts/cleanfile\n\n";
 			$rpt_cleaners = 0;
+			print << "EOM"
+
+NOTE: Whitespace errors detected.
+      You may wish to use scripts/cleanpatch or scripts/cleanfile
+EOM
 		}
 	}
 
-	hash_show_words(\%use_type, "Used");
-	hash_show_words(\%ignore_type, "Ignored");
-
-	if ($clean == 0 && $fix && "@rawlines" ne "@fixed") {
+	if ($clean == 0 && $fix &&
+	    ("@rawlines" ne "@fixed" ||
+	     $#fixed_inserted >= 0 || $#fixed_deleted >= 0)) {
 		my $newfile = $filename;
 		$newfile .= ".EXPERIMENTAL-checkpatch-fixes" if (!$fix_inplace);
 		my $linecount = 0;
 		my $f;
 
+		@fixed = fix_inserted_deleted_lines(\@fixed, \@fixed_inserted, \@fixed_deleted);
+
 		open($f, '>', $newfile)
 		    or die "$P: Can't open $newfile for write\n";
 		foreach my $fixed_line (@fixed) {
@@ -4616,7 +6428,7 @@ sub process {
 			if ($file) {
 				if ($linecount > 3) {
 					$fixed_line =~ s/^\+//;
-					print $f $fixed_line. "\n";
+					print $f $fixed_line . "\n";
 				}
 			} else {
 				print $f $fixed_line . "\n";
@@ -4626,6 +6438,7 @@ sub process {
 
 		if (!$quiet) {
 			print << "EOM";
+
 Wrote EXPERIMENTAL --fix correction(s) to '$newfile'
 
 Do _NOT_ trust the results written to this file.
@@ -4633,22 +6446,17 @@ Do _NOT_ submit these changes without inspecting them for correctness.
 
 This EXPERIMENTAL file is simply a convenience to help rewrite patches.
 No warranties, expressed or implied...
-
 EOM
 		}
 	}
 
-	if ($clean == 1 && $quiet == 0) {
-		print "$vname has no obvious style problems and is ready for submission.\n"
-	}
-	if ($clean == 0 && $quiet == 0) {
-		print << "EOM";
-$vname has style problems, please review.
-
-If any of these errors are false positives, please report
-them to the maintainer, see CHECKPATCH in MAINTAINERS.
-EOM
+	if ($quiet == 0) {
+		print "\n";
+		if ($clean == 1) {
+			print "$vname has no obvious style problems and is ready for submission.\n";
+		} else {
+			print "$vname has style problems, please review.\n";
+		}
 	}
-
 	return $clean;
 }
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index 9ce0c3f039..25e82db3e3 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -37,10 +37,6 @@ CONFIG_AM437X_USB2PHY2_HOST
 CONFIG_AMCORE
 CONFIG_ANDES_PCU
 CONFIG_ANDES_PCU_BASE
-CONFIG_AP325RXA
-CONFIG_APBH_DMA
-CONFIG_APBH_DMA_BURST
-CONFIG_APBH_DMA_BURST8
 CONFIG_APER_0_BASE
 CONFIG_APER_1_BASE
 CONFIG_APER_SIZE
@@ -264,7 +260,6 @@ CONFIG_CFG_DATA_SECTOR
 CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
 CONFIG_CF_DSPI
 CONFIG_CF_SBF
-CONFIG_CF_SPI
 CONFIG_CF_V2
 CONFIG_CF_V3
 CONFIG_CF_V4
@@ -384,7 +379,6 @@ CONFIG_DA850_AM18X_EVM
 CONFIG_DA850_EVM_MAX_CPU_CLK
 CONFIG_DA850_LOWLEVEL
 CONFIG_DA8XX_GPIO
-CONFIG_DAVINCI_SPI
 CONFIG_DBAU1000
 CONFIG_DBAU1X00
 CONFIG_DBGU
@@ -877,7 +871,6 @@ CONFIG_G_DNL_UMS_VENDOR_NUM
 CONFIG_H264_FREQ
 CONFIG_H8300
 CONFIG_HARD_SPI
-CONFIG_HAS_DATAFLASH
 CONFIG_HAS_ETH0
 CONFIG_HAS_ETH1
 CONFIG_HAS_ETH2
@@ -1154,7 +1147,6 @@ CONFIG_KIRKWOOD_EGIGA_INIT
 CONFIG_KIRKWOOD_GPIO
 CONFIG_KIRKWOOD_PCIE_INIT
 CONFIG_KIRKWOOD_RGMII_PAD_1V8
-CONFIG_KIRKWOOD_SPI
 CONFIG_KIRQ_EN
 CONFIG_KM8321
 CONFIG_KMCOGE4
@@ -1294,7 +1286,6 @@ CONFIG_LMS283GF05
 CONFIG_LOADADDR
 CONFIG_LOADCMD
 CONFIG_LOADS_ECHO
-CONFIG_LOGBUFFER
 CONFIG_LOWPOWER_ADDR
 CONFIG_LOWPOWER_FLAG
 CONFIG_LOW_MCFCLK
@@ -1318,7 +1309,6 @@ CONFIG_LPC32XX_NAND_SLC_WSETUP
 CONFIG_LPC32XX_NAND_SLC_WWIDTH
 CONFIG_LPC32XX_SDRAM_
 CONFIG_LPC32XX_SPL
-CONFIG_LPC32XX_SSP
 CONFIG_LPC32XX_SSP_TIMEOUT
 CONFIG_LPC_BASE
 CONFIG_LPC_IO_BASE
@@ -1461,7 +1451,6 @@ CONFIG_MPC83XX_PCI2
 CONFIG_MPC85XX_FEC
 CONFIG_MPC85XX_FEC_NAME
 CONFIG_MPC85XX_PCI2
-CONFIG_MPC8XXX_SPI
 CONFIG_MPC8xxx_DISABLE_BPTR
 CONFIG_MPLL_FREQ
 CONFIG_MPR2
@@ -1473,17 +1462,11 @@ CONFIG_MSHC_FREQ
 CONFIG_MTDMAP
 CONFIG_MTDPARTS
 CONFIG_MTD_CONCAT
-CONFIG_MTD_DEBUG
-CONFIG_MTD_DEBUG_VERBOSE
-CONFIG_MTD_DEVICE
 CONFIG_MTD_ECC_SOFT
-CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR
-CONFIG_MTD_NAND_ECC_SMC
 CONFIG_MTD_NAND_MUSEUM_IDS
 CONFIG_MTD_NAND_VERIFY_WRITE
 CONFIG_MTD_ONENAND_VERIFY_WRITE
 CONFIG_MTD_PARTITION
-CONFIG_MTD_PARTITIONS
 CONFIG_MTD_UBI_BEB_RESERVE
 CONFIG_MTD_UBI_BLOCK
 CONFIG_MTD_UBI_DEBUG
@@ -1545,17 +1528,13 @@ CONFIG_MXS_AUART
 CONFIG_MXS_AUART_BASE
 CONFIG_MXS_GPIO
 CONFIG_MXS_OCOTP
-CONFIG_MXS_SPI
 CONFIG_MX_CYCLIC
 CONFIG_MY_OPTION
 CONFIG_NANDFLASH_SIZE
 CONFIG_NAND_6BYTES_OOB_FREE_10BYTES_ECC
 CONFIG_NAND_ACTL
-CONFIG_NAND_ATMEL
 CONFIG_NAND_CS_INIT
 CONFIG_NAND_DATA_REG
-CONFIG_NAND_DAVINCI
-CONFIG_NAND_DENALI_ECC_SIZE
 CONFIG_NAND_ECC_BCH
 CONFIG_NAND_ENV_DST
 CONFIG_NAND_FSL_ELBC
@@ -1565,15 +1544,9 @@ CONFIG_NAND_FSMC
 CONFIG_NAND_KIRKWOOD
 CONFIG_NAND_KMETER1
 CONFIG_NAND_LPC32XX_MLC
-CONFIG_NAND_LPC32XX_SLC
 CONFIG_NAND_MODE_REG
-CONFIG_NAND_MXC
 CONFIG_NAND_MXC_V1_1
-CONFIG_NAND_NDFC
 CONFIG_NAND_OMAP_ECCSCHEME
-CONFIG_NAND_OMAP_ELM
-CONFIG_NAND_OMAP_GPMC
-CONFIG_NAND_OMAP_GPMC_PREFETCH
 CONFIG_NAND_OMAP_GPMC_WSCFG
 CONFIG_NAND_SECBOOT
 CONFIG_NAND_SPL
@@ -1619,7 +1592,6 @@ CONFIG_NUM_PAMU
 CONFIG_ODROID_REV_AIN
 CONFIG_OFF_PADCONF
 CONFIG_OF_
-CONFIG_OF_SPI
 CONFIG_OF_SPI_FLASH
 CONFIG_OF_STDOUT_PATH
 CONFIG_OMAP_EHCI_PHY1_RESET_GPIO
@@ -1701,6 +1673,8 @@ CONFIG_PERIF1_FREQ
 CONFIG_PERIF2_FREQ
 CONFIG_PERIF3_FREQ
 CONFIG_PERIF4_FREQ
+CONFIG_PERIPH_DEVICE_END_ADDR
+CONFIG_PERIPH_DEVICE_START_ADDR
 CONFIG_PHYSMEM
 CONFIG_PHY_ADDR
 CONFIG_PHY_BASE_ADR
@@ -1745,9 +1719,6 @@ CONFIG_PM9263
 CONFIG_PM9G45
 CONFIG_PMC_BR_PRELIM
 CONFIG_PMC_OR_PRELIM
-CONFIG_PMECC_CAP
-CONFIG_PMECC_INDEX_TABLE_OFFSET
-CONFIG_PMECC_SECTOR_SIZE
 CONFIG_PME_PLAT_CLK_DIV
 CONFIG_PMU
 CONFIG_PMW_BASE
@@ -1852,7 +1823,6 @@ CONFIG_RAMDISK_ADDR
 CONFIG_RAMDISK_BOOT
 CONFIG_RAM_BOOT
 CONFIG_RAM_BOOT_PHYS
-CONFIG_RANDOM_UUID
 CONFIG_RCAR_BOARD_STRING
 CONFIG_RD_LVL
 CONFIG_REALMODE_DEBUG
@@ -1900,6 +1870,7 @@ CONFIG_ROCKCHIP_CHIP_TAG
 CONFIG_ROCKCHIP_MAX_INIT_SIZE
 CONFIG_ROCKCHIP_SDHCI_MAX_FREQ
 CONFIG_ROCKCHIP_USB2_PHY
+CONFIG_ROCKUSB_G_DNL_PID
 CONFIG_ROM_STUBS
 CONFIG_ROOTFS_OFFSET
 CONFIG_ROOTPATH
@@ -2051,12 +2022,10 @@ CONFIG_SH_I2C_DATA_LOW
 CONFIG_SH_MMCIF
 CONFIG_SH_MMCIF_ADDR
 CONFIG_SH_MMCIF_CLK
-CONFIG_SH_QSPI
 CONFIG_SH_QSPI_BASE
 CONFIG_SH_SCIF_CLK_FREQ
 CONFIG_SH_SDHI_FREQ
 CONFIG_SH_SDRAM_OFFSET
-CONFIG_SH_SPI
 CONFIG_SH_SPI_BASE
 CONFIG_SH_TMU_CLK_FREQ
 CONFIG_SIEMENS_DRACO
@@ -2152,7 +2121,6 @@ CONFIG_SPEAR_UART48M
 CONFIG_SPEAR_UARTCLKMSK
 CONFIG_SPEAR_USBBOOT
 CONFIG_SPEAR_USBTTY
-CONFIG_SPI
 CONFIG_SPI_ADDR
 CONFIG_SPI_BOOTING
 CONFIG_SPI_CS_IS_VALID
@@ -2189,7 +2157,6 @@ CONFIG_SPL_FS_LOAD_ARGS_NAME
 CONFIG_SPL_FS_LOAD_KERNEL_NAME
 CONFIG_SPL_FS_LOAD_PAYLOAD_NAME
 CONFIG_SPL_GD_ADDR
-CONFIG_SPL_GENERATE_ATMEL_PMECC_HEADER
 CONFIG_SPL_INIT_MINIMAL
 CONFIG_SPL_JR0_LIODN_NS
 CONFIG_SPL_JR0_LIODN_S
@@ -2202,16 +2169,15 @@ CONFIG_SPL_MMC_LOAD
 CONFIG_SPL_MMC_MINIMAL
 CONFIG_SPL_MPC83XX_WAIT_FOR_NAND
 CONFIG_SPL_MXS_PSWITCH_WAIT
-CONFIG_SPL_NAND_AM33XX_BCH
 CONFIG_SPL_NAND_BASE
 CONFIG_SPL_NAND_BOOT
 CONFIG_SPL_NAND_DRIVERS
 CONFIG_SPL_NAND_ECC
+CONFIG_SPL_NAND_IDENT
 CONFIG_SPL_NAND_INIT
 CONFIG_SPL_NAND_LOAD
 CONFIG_SPL_NAND_MINIMAL
 CONFIG_SPL_NAND_RAW_ONLY
-CONFIG_SPL_NAND_SIMPLE
 CONFIG_SPL_NAND_SOFTECC
 CONFIG_SPL_NAND_WORKSPACE
 CONFIG_SPL_NO_CPU_SUPPORT_CODE
@@ -2619,9 +2585,6 @@ CONFIG_SYS_DA850_PLL1_PLLDIV3
 CONFIG_SYS_DA850_PLL1_PLLM
 CONFIG_SYS_DA850_PLL1_POSTDIV
 CONFIG_SYS_DA850_SYSCFG_SUSPSRC
-CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS1
-CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS2
-CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS3
 CONFIG_SYS_DAVINCI_EMAC_PHY_COUNT
 CONFIG_SYS_DAVINCI_I2C_SLAVE
 CONFIG_SYS_DAVINCI_I2C_SLAVE1
@@ -3731,7 +3694,6 @@ CONFIG_SYS_MATRIX_EBI0CSA_VAL
 CONFIG_SYS_MATRIX_EBICSA_VAL
 CONFIG_SYS_MATRIX_MCFG_REMAP
 CONFIG_SYS_MAXARGS
-CONFIG_SYS_MAX_DATAFLASH_BANKS
 CONFIG_SYS_MAX_DDR_BAT_SIZE
 CONFIG_SYS_MAX_FLASH_BANKS
 CONFIG_SYS_MAX_FLASH_BANKS_DETECT
@@ -4421,7 +4383,6 @@ CONFIG_SYS_PSDPAR
 CONFIG_SYS_PSSR_VAL
 CONFIG_SYS_PTCPAR
 CONFIG_SYS_PTDPAR
-CONFIG_SYS_PTL2_BITS
 CONFIG_SYS_PTV
 CONFIG_SYS_PUAPAR
 CONFIG_SYS_QE_FMAN_FW_IN_MMC
@@ -4796,7 +4757,6 @@ CONFIG_SYS_USE_SERIALFLASH
 CONFIG_SYS_USE_SPIFLASH
 CONFIG_SYS_USR_EXCEP
 CONFIG_SYS_U_BOOT_OFFS
-CONFIG_SYS_VA_BITS
 CONFIG_SYS_VCXK_ACKNOWLEDGE_DDR
 CONFIG_SYS_VCXK_ACKNOWLEDGE_PIN
 CONFIG_SYS_VCXK_ACKNOWLEDGE_PORT
@@ -4880,6 +4840,7 @@ CONFIG_TI_KSNAV
 CONFIG_TI_SPI_MMAP
 CONFIG_TMU_TIMER
 CONFIG_TPL_PAD_TO
+CONFIG_TPL_TINY_FRAMEWORK
 CONFIG_TPM_TIS_BASE_ADDRESS
 CONFIG_TPS6586X_POWER
 CONFIG_TQM834X
@@ -4928,7 +4889,6 @@ CONFIG_UBIBLOCK
 CONFIG_UBIFS_SILENCE_MSG
 CONFIG_UBIFS_VOLUME
 CONFIG_UBI_PART
-CONFIG_UBI_SILENCE_MSG
 CONFIG_UBI_SIZE
 CONFIG_UBOOT1_ENV_ADDR
 CONFIG_UBOOT2_ENV_ADDR
@@ -4983,8 +4943,6 @@ CONFIG_USBD_SERIAL_OUT_PKTSIZE
 CONFIG_USBD_VENDORID
 CONFIG_USBID_ADDR
 CONFIG_USBNET_DEV_ADDR
-CONFIG_USBNET_HOST_ADDR
-CONFIG_USBNET_MANUFACTURER
 CONFIG_USBTTY
 CONFIG_USB_AM35X
 CONFIG_USB_ATMEL
@@ -5009,15 +4967,10 @@ CONFIG_USB_EHCI_MXC
 CONFIG_USB_EHCI_MXS
 CONFIG_USB_EHCI_RMOBILE
 CONFIG_USB_EHCI_SPEAR
-CONFIG_USB_EHCI_SUNXI
 CONFIG_USB_EHCI_TEGRA
 CONFIG_USB_EHCI_TXFIFO_THRESH
 CONFIG_USB_EHCI_VCT
-CONFIG_USB_EHCI_VF
-CONFIG_USB_ETHER
-CONFIG_USB_ETH_CDC
 CONFIG_USB_ETH_QMULT
-CONFIG_USB_ETH_RNDIS
 CONFIG_USB_ETH_SUBSET
 CONFIG_USB_EXT2_BOOT
 CONFIG_USB_FAT_BOOT
@@ -5062,8 +5015,6 @@ CONFIG_USB_OHCI
 CONFIG_USB_OHCI_EP93XX
 CONFIG_USB_OHCI_LPC32XX
 CONFIG_USB_OHCI_NEW
-CONFIG_USB_OHCI_SUNXI
-CONFIG_USB_OMAP3
 CONFIG_USB_OTG
 CONFIG_USB_OTG_BLACKLIST_HUB
 CONFIG_USB_PHY_CFG_BASE
@@ -5175,7 +5126,6 @@ CONFIG_ZLIB
 CONFIG_ZLT
 CONFIG_ZM7300
 CONFIG_ZYNQMP_EEPROM
-CONFIG_ZYNQMP_XHCI_LIST
 CONFIG_ZYNQ_EEPROM
 CONFIG_ZYNQ_EEPROM_BUS
 CONFIG_ZYNQ_GEM_EEPROM_ADDR
diff --git a/scripts/dtc-version.sh b/scripts/dtc-version.sh
index e8c94d390b..0744c39eb0 100755
--- a/scripts/dtc-version.sh
+++ b/scripts/dtc-version.sh
@@ -2,8 +2,8 @@
 #
 # dtc-version dtc-command
 #
-# Prints the dtc version of `dtc-command' in a canonical 4-digit form
-# such as `0222' for binutils 2.22
+# Prints the dtc version of `dtc-command' in a canonical 6-digit form
+# such as `010404'  for dtc 1.4.4
 #
 
 dtc="$*"
@@ -16,5 +16,6 @@ fi
 
 MAJOR=$($dtc -v | head -1 | awk '{print $NF}' | cut -d . -f 1)
 MINOR=$($dtc -v | head -1 | awk '{print $NF}' | cut -d . -f 2)
+PATCH=$($dtc -v | head -1 | awk '{print $NF}' | cut -d . -f 3 | cut -d - -f 1)
 
-printf "%02d%02d\\n" $MAJOR $MINOR
+printf "%02d%02d%02d\\n" $MAJOR $MINOR $PATCH
diff --git a/scripts/get_maintainer.pl b/scripts/get_maintainer.pl
index 83a4e5bad2..07800e62d1 100755
--- a/scripts/get_maintainer.pl
+++ b/scripts/get_maintainer.pl
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl
 # (c) 2007, Joe Perches <joe@perches.com>
 #           created from checkpatch.pl
 #
@@ -10,18 +10,22 @@
 #
 # Licensed under the terms of the GNU GPL License version 2
 
+use warnings;
 use strict;
 
 my $P = $0;
 my $V = '0.26';
 
 use Getopt::Long qw(:config no_auto_abbrev);
+use Cwd;
 use File::Find;
 
+my $cur_path = fastgetcwd() . '/';
 my $lk_path = "./";
 my $email = 1;
 my $email_usename = 1;
 my $email_maintainer = 1;
+my $email_reviewer = 1;
 my $email_list = 1;
 my $email_subscriber_list = 0;
 my $email_git_penguin_chiefs = 0;
@@ -42,10 +46,12 @@ my $output_multiline = 1;
 my $output_separator = ", ";
 my $output_roles = 0;
 my $output_rolestats = 1;
+my $output_section_maxlen = 50;
 my $scm = 0;
 my $web = 0;
 my $subsystem = 0;
 my $status = 0;
+my $letters = "";
 my $keywords = 1;
 my $sections = 0;
 my $file_emails = 0;
@@ -53,6 +59,7 @@ my $from_filename = 0;
 my $pattern_depth = 0;
 my $version = 0;
 my $help = 0;
+my $find_maintainer_files = 1;
 
 my $vcs_used = 0;
 
@@ -128,6 +135,7 @@ my %VCS_cmds_git = (
     "author_pattern" => "^GitAuthor: (.*)",
     "subject_pattern" => "^GitSubject: (.*)",
     "stat_pattern" => "^(\\d+)\\t(\\d+)\\t\$file\$",
+    "file_exists_cmd" => "git ls-files \$file",
 );
 
 my %VCS_cmds_hg = (
@@ -156,6 +164,7 @@ my %VCS_cmds_hg = (
     "author_pattern" => "^HgAuthor: (.*)",
     "subject_pattern" => "^HgSubject: (.*)",
     "stat_pattern" => "^(\\d+)\t(\\d+)\t\$file\$",
+    "file_exists_cmd" => "hg files \$file",
 );
 
 my $conf = which_conf(".get_maintainer.conf");
@@ -184,6 +193,27 @@ if (-f $conf) {
     unshift(@ARGV, @conf_args) if @conf_args;
 }
 
+my @ignore_emails = ();
+my $ignore_file = which_conf(".get_maintainer.ignore");
+if (-f $ignore_file) {
+    open(my $ignore, '<', "$ignore_file")
+	or warn "$P: Can't find a readable .get_maintainer.ignore file $!\n";
+    while (<$ignore>) {
+	my $line = $_;
+
+	$line =~ s/\s*\n?$//;
+	$line =~ s/^\s*//;
+	$line =~ s/\s+$//;
+	$line =~ s/#.*$//;
+
+	next if ($line =~ m/^\s*$/);
+	if (rfc822_valid($line)) {
+	    push(@ignore_emails, $line);
+	}
+    }
+    close($ignore);
+}
+
 if (!GetOptions(
 		'email!' => \$email,
 		'git!' => \$email_git,
@@ -201,6 +231,7 @@ if (!GetOptions(
 		'remove-duplicates!' => \$email_remove_duplicates,
 		'mailmap!' => \$email_use_mailmap,
 		'm!' => \$email_maintainer,
+		'r!' => \$email_reviewer,
 		'n!' => \$email_usename,
 		'l!' => \$email_list,
 		's!' => \$email_subscriber_list,
@@ -212,11 +243,13 @@ if (!GetOptions(
 		'status!' => \$status,
 		'scm!' => \$scm,
 		'web!' => \$web,
+		'letters=s' => \$letters,
 		'pattern-depth=i' => \$pattern_depth,
 		'k|keywords!' => \$keywords,
 		'sections!' => \$sections,
 		'fe|file-emails!' => \$file_emails,
 		'f|file' => \$from_filename,
+		'find-maintainer-files' => \$find_maintainer_files,
 		'v|version' => \$version,
 		'h|help|usage' => \$help,
 		)) {
@@ -242,7 +275,8 @@ $output_multiline = 0 if ($output_separator ne ", ");
 $output_rolestats = 1 if ($interactive);
 $output_roles = 1 if ($output_rolestats);
 
-if ($sections) {
+if ($sections || $letters ne "") {
+    $sections = 1;
     $email = 0;
     $email_list = 0;
     $scm = 0;
@@ -259,42 +293,28 @@ if ($sections) {
 }
 
 if ($email &&
-    ($email_maintainer + $email_list + $email_subscriber_list +
+    ($email_maintainer + $email_reviewer +
+     $email_list + $email_subscriber_list +
      $email_git + $email_git_penguin_chiefs + $email_git_blame) == 0) {
     die "$P: Please select at least 1 email option\n";
 }
 
 if (!top_of_kernel_tree($lk_path)) {
     die "$P: The current directory does not appear to be "
-	. "a linux kernel source tree.\n";
+	. "a U-Boot source tree.\n";
 }
 
 ## Read MAINTAINERS for type/value pairs
 
 my @typevalue = ();
 my %keyword_hash;
+my @mfiles = ();
 
-my @maint_files = ();
-push(@maint_files, "${lk_path}MAINTAINERS");
-
-sub maint_wanted {
-    return unless $_ =~ /^MAINTAINERS/;
-    push(@maint_files, "$File::Find::name");
-}
-
-File::Find::find(\&maint_wanted, "${lk_path}board");
-
-foreach my $maint_file (@maint_files) {
-    my $maint;
-    open ($maint, '<', "$maint_file")
-	or die "$P: Can't open $maint_file: $!\n";
-    read_maintainers($maint);
-    close($maint);
-}
-
-sub read_maintainers {
-    my ($maint) = @_;
+sub read_maintainer_file {
+    my ($file) = @_;
 
+    open (my $maint, '<', "$file")
+	or die "$P: Can't open MAINTAINERS file '$file': $!\n";
     while (<$maint>) {
 	my $line = $_;
 
@@ -315,13 +335,47 @@ sub read_maintainers {
 		$keyword_hash{@typevalue} = $value;
 	    }
 	    push(@typevalue, "$type:$value");
-	} elsif (!/^(\s)*$/) {
+	} elsif (!(/^\s*$/ || /^\s*\#/)) {
 	    $line =~ s/\n$//g;
 	    push(@typevalue, $line);
 	}
     }
+    close($maint);
+}
+
+sub find_is_maintainer_file {
+    my ($file) = $_;
+    return if ($file !~ m@/MAINTAINERS$@);
+    $file = $File::Find::name;
+    return if (! -f $file);
+    push(@mfiles, $file);
+}
+
+sub find_ignore_git {
+    return grep { $_ !~ /^\.git$/; } @_;
+}
+
+if (-d "${lk_path}MAINTAINERS") {
+    opendir(DIR, "${lk_path}MAINTAINERS") or die $!;
+    my @files = readdir(DIR);
+    closedir(DIR);
+    foreach my $file (@files) {
+	push(@mfiles, "${lk_path}MAINTAINERS/$file") if ($file !~ /^\./);
+    }
 }
 
+if ($find_maintainer_files) {
+    find( { wanted => \&find_is_maintainer_file,
+	    preprocess => \&find_ignore_git,
+	    no_chdir => 1,
+	}, "${lk_path}");
+} else {
+    push(@mfiles, "${lk_path}MAINTAINERS") if -f "${lk_path}MAINTAINERS";
+}
+
+foreach my $file (@mfiles) {
+    read_maintainer_file("$file");
+}
 
 #
 # Read mail address map
@@ -421,7 +475,9 @@ foreach my $file (@ARGV) {
 	    die "$P: file '${file}' not found\n";
 	}
     }
-    if ($from_filename) {
+    if ($from_filename || ($file ne "&STDIN" && vcs_file_exists($file))) {
+	$file =~ s/^\Q${cur_path}\E//;	#strip any absolute path
+	$file =~ s/^\Q${lk_path}\E//;	#or the path to the lk tree
 	push(@files, $file);
 	if ($file ne "MAINTAINERS" && -f $file && ($keywords || $file_emails)) {
 	    open(my $f, '<', $file)
@@ -528,6 +584,16 @@ if ($web) {
 
 exit($exit);
 
+sub ignore_email_address {
+    my ($address) = @_;
+
+    foreach my $ignore (@ignore_emails) {
+	return 1 if ($ignore eq $address);
+    }
+
+    return 0;
+}
+
 sub range_is_maintained {
     my ($start, $end) = @_;
 
@@ -659,8 +725,10 @@ sub get_maintainers {
 			$line =~ s/\\\./\./g;       	##Convert \. to .
 			$line =~ s/\.\*/\*/g;       	##Convert .* to *
 		    }
-		    $line =~ s/^([A-Z]):/$1:\t/g;
-		    print("$line\n");
+		    my $count = $line =~ s/^([A-Z]):/$1:\t/g;
+		    if ($letters eq "" || (!$count || $letters =~ /$1/i)) {
+			print("$line\n");
+		    }
 		}
 		print("\n");
 	    }
@@ -764,10 +832,12 @@ MAINTAINER field selection options:
     --git-max-maintainers => maximum maintainers to add (default: $email_git_max_maintainers)
     --git-min-percent => minimum percentage of commits required (default: $email_git_min_percent)
     --git-blame => use git blame to find modified commits for patch or file
+    --git-blame-signatures => when used with --git-blame, also include all commit signers
     --git-since => git history to use (default: $email_git_since)
     --hg-since => hg history to use (default: $email_hg_since)
     --interactive => display a menu (mostly useful if used with the --git option)
     --m => include maintainer(s) if any
+    --r => include reviewer(s) if any
     --n => include name 'Full Name <addr\@domain.tld>'
     --l => include list(s) if any
     --s => include subscriber only list(s) if any
@@ -789,12 +859,13 @@ Other options:
   --pattern-depth => Number of pattern directory traversals (default: 0 (all))
   --keywords => scan patch for keywords (default: $keywords)
   --sections => print all of the subsystem sections with pattern matches
+  --letters => print all matching 'letter' types from all matching sections
   --mailmap => use .mailmap file (default: $email_use_mailmap)
   --version => show version
   --help => show this help information
 
 Default options:
-  [--email --nogit --git-fallback --m --n --l --multiline -pattern-depth=0
+  [--email --nogit --git-fallback --m --r --n --l --multiline --pattern-depth=0
    --remove-duplicates --rolestats]
 
 Notes:
@@ -826,6 +897,9 @@ Notes:
       Entries in this file can be any command line argument.
       This file is prepended to any additional command line arguments.
       Multiple lines and # comments are allowed.
+  Most options have both positive and negative forms.
+      The negative forms for --<foo> are --no<foo> and --no-<foo>.
+
 EOT
 }
 
@@ -836,7 +910,7 @@ sub top_of_kernel_tree {
 	$lk_path .= "/";
     }
     if (   (-f "${lk_path}Kbuild")
-	&& (-f "${lk_path}MAINTAINERS")
+	&& (-e "${lk_path}MAINTAINERS")
 	&& (-f "${lk_path}Makefile")
 	&& (-f "${lk_path}README")
 	&& (-d "${lk_path}arch")
@@ -954,20 +1028,29 @@ sub find_ending_index {
     return $index;
 }
 
-sub get_maintainer_role {
+sub get_subsystem_name {
     my ($index) = @_;
 
-    my $i;
     my $start = find_starting_index($index);
-    my $end = find_ending_index($index);
 
-    my $role = "unknown";
     my $subsystem = $typevalue[$start];
-    if (length($subsystem) > 20) {
-	$subsystem = substr($subsystem, 0, 17);
+    if ($output_section_maxlen && length($subsystem) > $output_section_maxlen) {
+	$subsystem = substr($subsystem, 0, $output_section_maxlen - 3);
 	$subsystem =~ s/\s*$//;
 	$subsystem = $subsystem . "...";
     }
+    return $subsystem;
+}
+
+sub get_maintainer_role {
+    my ($index) = @_;
+
+    my $i;
+    my $start = find_starting_index($index);
+    my $end = find_ending_index($index);
+
+    my $role = "unknown";
+    my $subsystem = get_subsystem_name($index);
 
     for ($i = $start + 1; $i < $end; $i++) {
 	my $tv = $typevalue[$i];
@@ -1001,16 +1084,7 @@ sub get_maintainer_role {
 sub get_list_role {
     my ($index) = @_;
 
-    my $i;
-    my $start = find_starting_index($index);
-    my $end = find_ending_index($index);
-
-    my $subsystem = $typevalue[$start];
-    if (length($subsystem) > 20) {
-	$subsystem = substr($subsystem, 0, 17);
-	$subsystem =~ s/\s*$//;
-	$subsystem = $subsystem . "...";
-    }
+    my $subsystem = get_subsystem_name($index);
 
     if ($subsystem eq "THE REST") {
 	$subsystem = "";
@@ -1084,6 +1158,23 @@ sub add_categories {
 		    my $role = get_maintainer_role($i);
 		    push_email_addresses($pvalue, $role);
 		}
+	    } elsif ($ptype eq "R") {
+		my ($name, $address) = parse_email($pvalue);
+		if ($name eq "") {
+		    if ($i > 0) {
+			my $tv = $typevalue[$i - 1];
+			if ($tv =~ m/^([A-Z]):\s*(.*)/) {
+			    if ($1 eq "P") {
+				$name = $2;
+				$pvalue = format_email($name, $address, $email_usename);
+			    }
+			}
+		    }
+		}
+		if ($email_reviewer) {
+		    my $subsystem = get_subsystem_name($i);
+		    push_email_addresses($pvalue, "reviewer:$subsystem");
+		}
 	    } elsif ($ptype eq "T") {
 		push(@scm, $pvalue);
 	    } elsif ($ptype eq "W") {
@@ -1868,6 +1959,7 @@ sub vcs_assign {
 	my $percent = $sign_offs * 100 / $divisor;
 
 	$percent = 100 if ($percent > 100);
+	next if (ignore_email_address($line));
 	$count++;
 	last if ($sign_offs < $email_git_min_signatures ||
 		 $count > $email_git_max_maintainers ||
@@ -2082,6 +2174,24 @@ sub vcs_file_blame {
     }
 }
 
+sub vcs_file_exists {
+    my ($file) = @_;
+
+    my $exists;
+
+    my $vcs_used = vcs_exists();
+    return 0 if (!$vcs_used);
+
+    my $cmd = $VCS_cmds{"file_exists_cmd"};
+    $cmd =~ s/(\$\w+)/$1/eeg;		# interpolate $cmd
+    $cmd .= " 2>&1";
+    $exists = &{$VCS_cmds{"execute_cmd"}}($cmd);
+
+    return 0 if ($? != 0);
+
+    return $exists;
+}
+
 sub uniq {
     my (@parms) = @_;
 
diff --git a/scripts/mailmapper b/scripts/mailmapper
index 922ada6f5f..78b23d152d 100755
--- a/scripts/mailmapper
+++ b/scripts/mailmapper
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2
 #
 # Copyright (C) 2014, Masahiro Yamada <yamada.m@jp.panasonic.com>
 #
diff --git a/scripts/setlocalversion b/scripts/setlocalversion
index 8564bedd1a..9593b873ba 100755
--- a/scripts/setlocalversion
+++ b/scripts/setlocalversion
@@ -59,7 +59,9 @@ scm_version()
 			# If we are past a tagged commit (like
 			# "v2.6.30-rc5-302-g72357d5"), we pretty print it.
 			if atag="`git describe 2>/dev/null`"; then
-				echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'
+				echo "$atag" | awk -F- '{printf("-%s", $(NF))}'
+				date=`git log -1 --author='@rock-chips' --date=format:%y%m%d | sed -n '/Date:/p' | awk '{ print "-"$2 }'`
+				printf '%s' $date
 
 			# If we don't have a tag at all we print -g{commitish}.
 			else
@@ -77,6 +79,8 @@ scm_version()
 			printf '%s' -dirty
 		fi
 
+		printf ' \#%s' $USER
+
 		# All done with git
 		return
 	fi
@@ -157,8 +161,13 @@ if test ! "$srctree" -ef .; then
 	res="$res$(collect_files "$srctree"/localversion*)"
 fi
 
+LINUX_COMMIT=$(git log -1 | grep "commit" | awk -F ' ' '{print $2}')
+
+XML_PATH=`readlink -f ../.repo/manifest.xml`
+XML_NAME=${XML_PATH##*/}
+
 # CONFIG_LOCALVERSION and LOCALVERSION (if set)
-res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"
+res="${res}${CONFIG_LOCALVERSION}\(u-boot commit id: ${LINUX_COMMIT}\)\(sdk version: ${XML_NAME}\)${LOCALVERSION}"
 
 # scm version string if not at a tagged commit
 if test "$CONFIG_LOCALVERSION_AUTO" = "y"; then
diff --git a/test/Kconfig b/test/Kconfig
index 3643761bc6..9a22d50255 100644
--- a/test/Kconfig
+++ b/test/Kconfig
@@ -15,6 +15,18 @@ config UT_TIME
 	  problems. But if you are having problems with udelay() and the like,
 	  this is a good place to start.
 
+config TEST_ROCKCHIP
+	bool "test Rockchip board modules"
+	depends on ARCH_ROCKCHIP
+	help
+	  This enables the test function for rockchip board modules.
+
+config LAVA_INFO
+	bool "Display test info need by LAVA system"
+	depends on TEST_ROCKCHIP
+	help
+	  This enable the print info need by LAVA system
+
 source "test/dm/Kconfig"
 source "test/env/Kconfig"
 source "test/overlay/Kconfig"
diff --git a/test/Makefile b/test/Makefile
index 6305afb211..382a0fff4d 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -10,3 +10,5 @@ obj-$(CONFIG_SANDBOX) += command_ut.o
 obj-$(CONFIG_SANDBOX) += compression.o
 obj-$(CONFIG_SANDBOX) += print_ut.o
 obj-$(CONFIG_UT_TIME) += time_ut.o
+obj-$(CONFIG_TEST_ROCKCHIP) += rockchip/
+obj-$(CONFIG_$(SPL_)LOG) += log/
diff --git a/test/dm/Makefile b/test/dm/Makefile
index 513c4561ad..c5a0022b09 100644
--- a/test/dm/Makefile
+++ b/test/dm/Makefile
@@ -6,6 +6,7 @@
 
 obj-$(CONFIG_CMD_DM) += cmd_dm.o
 obj-$(CONFIG_UT_DM) += bus.o
+obj-$(CONFIG_UT_DM) += nop.o
 obj-$(CONFIG_UT_DM) += test-driver.o
 obj-$(CONFIG_UT_DM) += test-fdt.o
 obj-$(CONFIG_UT_DM) += test-main.o
@@ -44,4 +45,5 @@ obj-$(CONFIG_DM_VIDEO) += video.o
 obj-$(CONFIG_ADC) += adc.o
 obj-$(CONFIG_SPMI) += spmi.o
 obj-$(CONFIG_WDT) += wdt.o
+obj-$(CONFIG_SCMI_FIRMWARE) += scmi.o
 endif
diff --git a/test/dm/clk.c b/test/dm/clk.c
index 712a1e674a..344e2555f0 100644
--- a/test/dm/clk.c
+++ b/test/dm/clk.c
@@ -29,6 +29,7 @@ static int dm_test_clk(struct unit_test_state *uts)
 	ut_assertok(uclass_get_device_by_name(UCLASS_MISC, "clk-test",
 					      &dev_test));
 	ut_assertok(sandbox_clk_test_get(dev_test));
+	ut_assertok(sandbox_clk_test_valid(dev_test));
 
 	ut_asserteq(1234,
 		    sandbox_clk_test_get_rate(dev_test,
@@ -101,3 +102,40 @@ static int dm_test_clk(struct unit_test_state *uts)
 	return 0;
 }
 DM_TEST(dm_test_clk, DM_TESTF_SCAN_FDT);
+
+static int dm_test_clk_bulk(struct unit_test_state *uts)
+{
+	struct udevice *dev_clk, *dev_test;
+
+	ut_assertok(uclass_get_device_by_name(UCLASS_CLK, "clk-sbox",
+					      &dev_clk));
+	ut_assertok(uclass_get_device_by_name(UCLASS_MISC, "clk-test",
+					      &dev_test));
+	ut_assertok(sandbox_clk_test_get_bulk(dev_test));
+
+	ut_asserteq(0, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_SPI));
+	ut_asserteq(0, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_I2C));
+
+	/* Fixed clock does not support enable, thus should not fail */
+	ut_assertok(sandbox_clk_test_enable_bulk(dev_test));
+	ut_asserteq(1, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_SPI));
+	ut_asserteq(1, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_I2C));
+
+	/* Fixed clock does not support disable, thus should not fail */
+	ut_assertok(sandbox_clk_test_disable_bulk(dev_test));
+	ut_asserteq(0, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_SPI));
+	ut_asserteq(0, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_I2C));
+
+	/* Fixed clock does not support enable, thus should not fail */
+	ut_assertok(sandbox_clk_test_enable_bulk(dev_test));
+	ut_asserteq(1, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_SPI));
+	ut_asserteq(1, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_I2C));
+
+	/* Fixed clock does not support disable, thus should not fail */
+	ut_assertok(sandbox_clk_test_release_bulk(dev_test));
+	ut_asserteq(0, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_SPI));
+	ut_asserteq(0, sandbox_clk_query_enable(dev_clk, SANDBOX_CLK_ID_I2C));
+
+	return 0;
+}
+DM_TEST(dm_test_clk_bulk, DM_TESTF_SCAN_FDT);
diff --git a/test/dm/cmd_dm.c b/test/dm/cmd_dm.c
index a3c5971a8b..a4f2165b64 100644
--- a/test/dm/cmd_dm.c
+++ b/test/dm/cmd_dm.c
@@ -14,6 +14,7 @@
 #include <mapmem.h>
 #include <errno.h>
 #include <asm/io.h>
+#include <dm/of_access.h>
 #include <dm/root.h>
 #include <dm/util.h>
 
@@ -41,10 +42,20 @@ static int do_dm_dump_devres(cmd_tbl_t *cmdtp, int flag, int argc,
 	return 0;
 }
 
+static int do_dm_dump_aliases(cmd_tbl_t *cmdtp, int flag, int argc,
+			      char * const argv[])
+{
+#ifdef CONFIG_OF_LIVE
+	of_alias_dump();
+#endif
+	return 0;
+}
+
 static cmd_tbl_t test_commands[] = {
 	U_BOOT_CMD_MKENT(tree, 0, 1, do_dm_dump_all, "", ""),
 	U_BOOT_CMD_MKENT(uclass, 1, 1, do_dm_dump_uclass, "", ""),
 	U_BOOT_CMD_MKENT(devres, 1, 1, do_dm_dump_devres, "", ""),
+	U_BOOT_CMD_MKENT(aliases, 0, 1, do_dm_dump_aliases, "", ""),
 };
 
 static __maybe_unused void dm_reloc(void)
@@ -85,5 +96,6 @@ U_BOOT_CMD(
 	"Driver model low level access",
 	"tree         Dump driver model tree ('*' = activated)\n"
 	"dm uclass        Dump list of instances for each uclass\n"
-	"dm devres        Dump list of device resources for each device"
+	"dm devres        Dump list of device resources for each device\n"
+	"dm aliases       Dump list of aliases"
 );
diff --git a/test/dm/core.c b/test/dm/core.c
index 50ee41b9e2..052bf8fffb 100644
--- a/test/dm/core.c
+++ b/test/dm/core.c
@@ -862,3 +862,12 @@ static int dm_test_device_get_uclass_id(struct unit_test_state *uts)
 	return 0;
 }
 DM_TEST(dm_test_device_get_uclass_id, DM_TESTF_SCAN_PDATA);
+
+static int dm_test_uclass_names(struct unit_test_state *uts)
+{
+	ut_asserteq_str("test", uclass_get_name(UCLASS_TEST));
+	ut_asserteq(UCLASS_TEST, uclass_get_by_name("test"));
+
+	return 0;
+}
+DM_TEST(dm_test_uclass_names, DM_TESTF_SCAN_PDATA);
diff --git a/test/dm/regulator.c b/test/dm/regulator.c
index 3d0056f2dc..395381d4bd 100644
--- a/test/dm/regulator.c
+++ b/test/dm/regulator.c
@@ -27,6 +27,7 @@ DECLARE_GLOBAL_DATA_PTR;
 enum {
 	BUCK1,
 	BUCK2,
+	BUCK3,
 	LDO1,
 	LDO2,
 	OUTPUT_COUNT,
@@ -42,6 +43,7 @@ static const char *regulator_names[OUTPUT_COUNT][OUTPUT_NAME_COUNT] = {
 	/* devname, platname */
 	{ SANDBOX_BUCK1_DEVNAME, SANDBOX_BUCK1_PLATNAME },
 	{ SANDBOX_BUCK2_DEVNAME, SANDBOX_BUCK2_PLATNAME },
+	{ SANDBOX_BUCK3_DEVNAME, SANDBOX_BUCK3_PLATNAME },
 	{ SANDBOX_LDO1_DEVNAME, SANDBOX_LDO1_PLATNAME},
 	{ SANDBOX_LDO2_DEVNAME, SANDBOX_LDO2_PLATNAME},
 };
diff --git a/test/dm/reset.c b/test/dm/reset.c
index 0ae8031540..8dc0023c08 100644
--- a/test/dm/reset.c
+++ b/test/dm/reset.c
@@ -13,6 +13,9 @@
 /* This must match the specifier for mbox-names="test" in the DT node */
 #define TEST_RESET_ID 2
 
+/* This is the other reset phandle specifier handled by bulk */
+#define OTHER_RESET_ID 2
+
 static int dm_test_reset(struct unit_test_state *uts)
 {
 	struct udevice *dev_reset;
@@ -37,3 +40,33 @@ static int dm_test_reset(struct unit_test_state *uts)
 	return 0;
 }
 DM_TEST(dm_test_reset, DM_TESTF_SCAN_FDT);
+
+static int dm_test_reset_bulk(struct unit_test_state *uts)
+{
+	struct udevice *dev_reset;
+	struct udevice *dev_test;
+
+	ut_assertok(uclass_get_device_by_name(UCLASS_RESET, "reset-ctl",
+					      &dev_reset));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(uclass_get_device_by_name(UCLASS_MISC, "reset-ctl-test",
+					      &dev_test));
+	ut_assertok(sandbox_reset_test_get_bulk(dev_test));
+
+	ut_assertok(sandbox_reset_test_assert_bulk(dev_test));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(sandbox_reset_test_deassert_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(sandbox_reset_test_release_bulk(dev_test));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	return 0;
+}
+DM_TEST(dm_test_reset_bulk, DM_TESTF_SCAN_FDT);
diff --git a/test/dm/sf.c b/test/dm/sf.c
index b0844629f9..7571d2481e 100644
--- a/test/dm/sf.c
+++ b/test/dm/sf.c
@@ -10,12 +10,70 @@
 #include <spi.h>
 #include <spi_flash.h>
 #include <asm/state.h>
+#include <asm/test.h>
 #include <dm/test.h>
 #include <dm/util.h>
 #include <test/ut.h>
 
 /* Test that sandbox SPI flash works correctly */
 static int dm_test_spi_flash(struct unit_test_state *uts)
+{
+	struct udevice *dev, *emul;
+	int full_size = 0x200000;
+	int size = 0x10000;
+	u8 *src, *dst;
+	uint map_size;
+	ulong map_base;
+	uint offset;
+	int i;
+
+	src = map_sysmem(0x20000, full_size);
+	ut_assertok(os_write_file("spi.bin", src, full_size));
+	ut_assertok(uclass_first_device_err(UCLASS_SPI_FLASH, &dev));
+
+	dst = map_sysmem(0x20000 + full_size, full_size);
+	ut_assertok(spi_flash_read_dm(dev, 0, size, dst));
+	ut_assertok(memcmp(src, dst, size));
+
+	/* Erase */
+	ut_assertok(spi_flash_erase_dm(dev, 0, size));
+	ut_assertok(spi_flash_read_dm(dev, 0, size, dst));
+	for (i = 0; i < size; i++)
+		ut_asserteq(dst[i], 0xff);
+
+	/* Write some new data */
+	for (i = 0; i < size; i++)
+		src[i] = i;
+	ut_assertok(spi_flash_write_dm(dev, 0, size, src));
+	ut_assertok(spi_flash_read_dm(dev, 0, size, dst));
+	ut_assertok(memcmp(src, dst, size));
+
+	/* Try the write-protect stuff */
+	ut_assertok(uclass_first_device_err(UCLASS_SPI_EMUL, &emul));
+	ut_asserteq(0, spl_flash_get_sw_write_prot(dev));
+	sandbox_sf_set_block_protect(emul, 1);
+	ut_asserteq(1, spl_flash_get_sw_write_prot(dev));
+	sandbox_sf_set_block_protect(emul, 0);
+	ut_asserteq(0, spl_flash_get_sw_write_prot(dev));
+
+	/* Check mapping */
+	ut_assertok(dm_spi_get_mmap(dev, &map_base, &map_size, &offset));
+	ut_asserteq(0x1000, map_base);
+	ut_asserteq(0x2000, map_size);
+	ut_asserteq(0x100, offset);
+
+	/*
+	 * Since we are about to destroy all devices, we must tell sandbox
+	 * to forget the emulation device
+	 */
+	sandbox_sf_unbind_emul(state_get_current(), 0, 0);
+
+	return 0;
+}
+DM_TEST(dm_test_spi_flash, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+/* Functional test that sandbox SPI flash works correctly */
+static int dm_test_spi_flash_func(struct unit_test_state *uts)
 {
 	/*
 	 * Create an empty test file and run the SPI flash tests. This is a
diff --git a/test/dm/spi.c b/test/dm/spi.c
index 24fa2a48ae..b3b87286bd 100644
--- a/test/dm/spi.c
+++ b/test/dm/spi.c
@@ -24,7 +24,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	struct udevice *bus, *dev;
 	const int busnum = 0, cs = 0, mode = 0, speed = 1000000, cs_b = 1;
 	struct spi_cs_info info;
-	int of_offset;
+	ofnode node;
 
 	ut_asserteq(-ENODEV, uclass_find_device_by_seq(UCLASS_SPI, busnum,
 						       false, &bus));
@@ -35,7 +35,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	 */
 	ut_asserteq(0, uclass_get_device_by_seq(UCLASS_SPI, busnum, &bus));
 	ut_assertok(spi_cs_info(bus, cs, &info));
-	of_offset = dev_of_offset(info.dev);
+	node = dev_ofnode(info.dev);
 	device_remove(info.dev, DM_REMOVE_NORMAL);
 	device_unbind(info.dev);
 
@@ -66,7 +66,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	ut_asserteq_ptr(NULL, info.dev);
 
 	/* Add the emulation and try again */
-	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs, bus, of_offset,
+	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs, bus, node,
 					 "name"));
 	ut_assertok(spi_find_bus_and_cs(busnum, cs, &bus, &dev));
 	ut_assertok(spi_get_bus_and_cs(busnum, cs, speed, mode,
@@ -76,7 +76,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	ut_asserteq_ptr(info.dev, slave->dev);
 
 	/* We should be able to add something to another chip select */
-	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs_b, bus, of_offset,
+	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs_b, bus, node,
 					 "name"));
 	ut_assertok(spi_get_bus_and_cs(busnum, cs_b, speed, mode,
 				       "spi_flash_std", "name", &bus, &slave));
diff --git a/test/dm/syscon.c b/test/dm/syscon.c
index c40f5fc09d..f2ac2e06c8 100644
--- a/test/dm/syscon.c
+++ b/test/dm/syscon.c
@@ -7,6 +7,7 @@
 #include <common.h>
 #include <dm.h>
 #include <syscon.h>
+#include <regmap.h>
 #include <asm/test.h>
 #include <dm/test.h>
 #include <test/ut.h>
@@ -46,3 +47,31 @@ static int dm_test_syscon_by_driver_data(struct unit_test_state *uts)
 	return 0;
 }
 DM_TEST(dm_test_syscon_by_driver_data, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+/* Test system controller by phandle */
+static int dm_test_syscon_by_phandle(struct unit_test_state *uts)
+{
+	struct udevice *dev;
+	struct regmap *map;
+
+	ut_assertok(uclass_get_device_by_name(UCLASS_TEST_PROBE, "test4",
+					      &dev));
+
+	ut_assertok_ptr(syscon_regmap_lookup_by_phandle(dev, "first-syscon"));
+	map = syscon_regmap_lookup_by_phandle(dev, "first-syscon");
+	ut_assert(map);
+	ut_assert(!IS_ERR(map));
+	ut_asserteq(1, map->range_count);
+
+	ut_assertok_ptr(syscon_regmap_lookup_by_phandle(dev,
+							"second-sys-ctrl"));
+	map = syscon_regmap_lookup_by_phandle(dev, "second-sys-ctrl");
+	ut_assert(map);
+	ut_assert(!IS_ERR(map));
+	ut_asserteq(4, map->range_count);
+
+	ut_assert(IS_ERR(syscon_regmap_lookup_by_phandle(dev, "not-present")));
+
+	return 0;
+}
+DM_TEST(dm_test_syscon_by_phandle, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
diff --git a/test/dm/test-main.c b/test/dm/test-main.c
index 9d88d31467..4478e6b8fc 100644
--- a/test/dm/test-main.c
+++ b/test/dm/test-main.c
@@ -92,7 +92,7 @@ static int dm_do_test(struct unit_test_state *uts, struct unit_test *test,
 	if (test->flags & DM_TESTF_PROBE_TEST)
 		ut_assertok(do_autoprobe(uts));
 	if (test->flags & DM_TESTF_SCAN_FDT)
-		ut_assertok(dm_scan_fdt(gd->fdt_blob, false));
+		ut_assertok(dm_extended_scan_fdt(gd->fdt_blob, false));
 
 	/*
 	 * Silence the console and rely on console reocrding to get
diff --git a/test/overlay/Makefile b/test/overlay/Makefile
index 907f085446..416645c884 100644
--- a/test/overlay/Makefile
+++ b/test/overlay/Makefile
@@ -13,3 +13,4 @@ DTC_FLAGS += -@
 # DT overlays
 obj-y += test-fdt-base.dtb.o
 obj-y += test-fdt-overlay.dtb.o
+obj-y += test-fdt-overlay-stacked.dtb.o
diff --git a/test/overlay/cmd_ut_overlay.c b/test/overlay/cmd_ut_overlay.c
index cbef720b4c..24891ee829 100644
--- a/test/overlay/cmd_ut_overlay.c
+++ b/test/overlay/cmd_ut_overlay.c
@@ -20,8 +20,9 @@
 
 extern u32 __dtb_test_fdt_base_begin;
 extern u32 __dtb_test_fdt_overlay_begin;
+extern u32 __dtb_test_fdt_overlay_stacked_begin;
 
-static int fdt_getprop_u32_by_index(void *fdt, const char *path,
+static int ut_fdt_getprop_u32_by_index(void *fdt, const char *path,
 				    const char *name, int index,
 				    u32 *out)
 {
@@ -42,10 +43,10 @@ static int fdt_getprop_u32_by_index(void *fdt, const char *path,
 	return 0;
 }
 
-static int fdt_getprop_u32(void *fdt, const char *path, const char *name,
+static int ut_fdt_getprop_u32(void *fdt, const char *path, const char *name,
 			   u32 *out)
 {
-	return fdt_getprop_u32_by_index(fdt, path, name, 0, out);
+	return ut_fdt_getprop_u32_by_index(fdt, path, name, 0, out);
 }
 
 static int fdt_getprop_str(void *fdt, const char *path, const char *name,
@@ -68,7 +69,7 @@ static int fdt_overlay_change_int_property(struct unit_test_state *uts)
 	void *fdt = uts->priv;
 	u32 val = 0;
 
-	ut_assertok(fdt_getprop_u32(fdt, "/test-node", "test-int-property",
+	ut_assertok(ut_fdt_getprop_u32(fdt, "/test-node", "test-int-property",
 				    &val));
 	ut_asserteq(43, val);
 
@@ -158,11 +159,11 @@ static int fdt_overlay_local_phandle(struct unit_test_state *uts)
 	local_phandle = fdt_get_phandle(fdt, off);
 	ut_assert(local_phandle);
 
-	ut_assertok(fdt_getprop_u32_by_index(fdt, "/", "test-several-phandle",
+	ut_assertok(ut_fdt_getprop_u32_by_index(fdt, "/", "test-several-phandle",
 					     0, &val));
 	ut_asserteq(local_phandle, val);
 
-	ut_assertok(fdt_getprop_u32_by_index(fdt, "/", "test-several-phandle",
+	ut_assertok(ut_fdt_getprop_u32_by_index(fdt, "/", "test-several-phandle",
 					     1, &val));
 	ut_asserteq(local_phandle, val);
 
@@ -189,11 +190,11 @@ static int fdt_overlay_local_phandles(struct unit_test_state *uts)
 	test_phandle = fdt_get_phandle(fdt, off);
 	ut_assert(test_phandle);
 
-	ut_assertok(fdt_getprop_u32_by_index(fdt, "/", "test-phandle", 0,
+	ut_assertok(ut_fdt_getprop_u32_by_index(fdt, "/", "test-phandle", 0,
 					     &val));
 	ut_asserteq(test_phandle, val);
 
-	ut_assertok(fdt_getprop_u32_by_index(fdt, "/", "test-phandle", 1,
+	ut_assertok(ut_fdt_getprop_u32_by_index(fdt, "/", "test-phandle", 1,
 					     &val));
 	ut_asserteq(local_phandle, val);
 
@@ -201,6 +202,19 @@ static int fdt_overlay_local_phandles(struct unit_test_state *uts)
 }
 OVERLAY_TEST(fdt_overlay_local_phandles, 0);
 
+static int fdt_overlay_stacked(struct unit_test_state *uts)
+{
+	void *fdt = uts->priv;
+	u32 val = 0;
+
+	ut_assertok(ut_fdt_getprop_u32(fdt, "/new-local-node",
+				       "stacked-test-int-property", &val));
+	ut_asserteq(43, val);
+
+	return CMD_RET_SUCCESS;
+}
+OVERLAY_TEST(fdt_overlay_stacked, 0);
+
 int do_ut_overlay(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	struct unit_test *tests = ll_entry_start(struct unit_test,
@@ -210,7 +224,8 @@ int do_ut_overlay(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	struct unit_test *test;
 	void *fdt_base = &__dtb_test_fdt_base_begin;
 	void *fdt_overlay = &__dtb_test_fdt_overlay_begin;
-	void *fdt_base_copy, *fdt_overlay_copy;
+	void *fdt_overlay_stacked = &__dtb_test_fdt_overlay_stacked_begin;
+	void *fdt_base_copy, *fdt_overlay_copy, *fdt_overlay_stacked_copy;
 
 	uts = calloc(1, sizeof(*uts));
 	if (!uts)
@@ -228,6 +243,10 @@ int do_ut_overlay(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (!fdt_overlay_copy)
 		return -ENOMEM;
 
+	fdt_overlay_stacked_copy = malloc(FDT_COPY_SIZE);
+	if (!fdt_overlay_stacked_copy)
+		return -ENOMEM;
+
 	/*
 	 * Resize the FDT to 4k so that we have room to operate on
 	 *
@@ -245,9 +264,21 @@ int do_ut_overlay(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	ut_assertok(fdt_open_into(fdt_overlay, fdt_overlay_copy,
 				  FDT_COPY_SIZE));
 
+	/*
+	 * Resize the stacked overlay to 4k so that we have room to operate on
+	 *
+	 * (and relocate it since the memory might be mapped
+	 * read-only)
+	 */
+	ut_assertok(fdt_open_into(fdt_overlay_stacked, fdt_overlay_stacked_copy,
+				  FDT_COPY_SIZE));
+
 	/* Apply the overlay */
 	ut_assertok(fdt_overlay_apply(fdt_base_copy, fdt_overlay_copy));
 
+	/* Apply the stacked overlay */
+	ut_assertok(fdt_overlay_apply(fdt_base_copy, fdt_overlay_stacked_copy));
+
 	if (argc == 1)
 		printf("Running %d environment tests\n", n_ents);
 
@@ -263,6 +294,7 @@ int do_ut_overlay(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	printf("Failures: %d\n", uts->fail_count);
 
+	free(fdt_overlay_stacked_copy);
 	free(fdt_overlay_copy);
 	free(fdt_base_copy);
 	free(uts);
diff --git a/test/py/multiplexed_log.css b/test/py/multiplexed_log.css
index f135b10a24..9b7c44fe4d 100644
--- a/test/py/multiplexed_log.css
+++ b/test/py/multiplexed_log.css
@@ -62,6 +62,10 @@ pre {
     color: #8080ff
 }
 
+.timestamp {
+    color: #8080ff
+}
+
 .status-pass {
     color: #00ff00
 }
diff --git a/test/py/multiplexed_log.py b/test/py/multiplexed_log.py
index bf926c3e77..6afc41dcaf 100644
--- a/test/py/multiplexed_log.py
+++ b/test/py/multiplexed_log.py
@@ -7,6 +7,7 @@
 # each represented in a well-delineated/-structured fashion.
 
 import cgi
+import datetime
 import os.path
 import shutil
 import subprocess
@@ -164,6 +165,7 @@ class RunAndLog(object):
         self.logfile.write(self, output)
         if self.chained_file:
             self.chained_file.write(output)
+        self.logfile.timestamp()
 
         # Store the output so it can be accessed if we raise an exception.
         self.output = output
@@ -219,6 +221,9 @@ class Logfile(object):
         self.blocks = []
         self.cur_evt = 1
         self.anchor = 0
+        self.timestamp_start = self._get_time()
+        self.timestamp_prev = self.timestamp_start
+        self.timestamp_blocks = []
 
         shutil.copy(mod_dir + '/multiplexed_log.css', os.path.dirname(fn))
         self.f.write('''\
@@ -388,6 +393,7 @@ $(document).ready(function () {
 
         self._terminate_stream()
         self.blocks.append(marker)
+        self.timestamp_blocks.append(self._get_time())
         if not anchor:
             self.anchor += 1
             anchor = str(self.anchor)
@@ -396,6 +402,7 @@ $(document).ready(function () {
         self.f.write('<div class="section-header block-header">Section: ' +
                      blk_path + '</div>\n')
         self.f.write('<div class="section-content block-content">\n')
+        self.timestamp()
 
         return anchor
 
@@ -416,6 +423,11 @@ $(document).ready(function () {
             raise Exception('Block nesting mismatch: "%s" "%s"' %
                             (marker, '/'.join(self.blocks)))
         self._terminate_stream()
+        timestamp_now = self._get_time()
+        timestamp_section_start = self.timestamp_blocks.pop()
+        delta_section = timestamp_now - timestamp_section_start
+        self._note("timestamp",
+            "TIME: SINCE-SECTION: " + str(delta_section))
         blk_path = '/'.join(self.blocks)
         self.f.write('<div class="section-trailer block-trailer">' +
                      'End section: ' + blk_path + '</div>\n')
@@ -492,6 +504,31 @@ $(document).ready(function () {
 
         self._note("action", msg)
 
+    def _get_time(self):
+        return datetime.datetime.now()
+
+    def timestamp(self):
+        """Write a timestamp to the log file.
+
+        Args:
+            None
+
+        Returns:
+            Nothing.
+        """
+
+        timestamp_now = self._get_time()
+        delta_prev = timestamp_now - self.timestamp_prev
+        delta_start = timestamp_now - self.timestamp_start
+        self.timestamp_prev = timestamp_now
+
+        self._note("timestamp",
+            "TIME: NOW: " + timestamp_now.strftime("%Y/%m/%d %H:%M:%S.%f"))
+        self._note("timestamp",
+            "TIME: SINCE-PREV: " + str(delta_prev))
+        self._note("timestamp",
+            "TIME: SINCE-START: " + str(delta_start))
+
     def status_pass(self, msg, anchor=None):
         """Write a note to the log file describing test(s) which passed.
 
diff --git a/test/py/test.py b/test/py/test.py
index 74e560a4d3..4695079ef7 100755
--- a/test/py/test.py
+++ b/test/py/test.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2
 
 # Copyright (c) 2015 Stephen Warren
 # Copyright (c) 2015-2016, NVIDIA CORPORATION. All rights reserved.
diff --git a/test/py/tests/test_env.py b/test/py/tests/test_env.py
index b7f960c755..f8694017b4 100644
--- a/test/py/tests/test_env.py
+++ b/test/py/tests/test_env.py
@@ -125,7 +125,16 @@ def set_var(state_test_env, var, value):
         Nothing.
     """
 
-    state_test_env.u_boot_console.run_command('setenv %s "%s"' % (var, value))
+    bc = state_test_env.u_boot_console.config.buildconfig
+    if bc.get('config_hush_parser', None):
+        quote = '"'
+    else:
+        quote = ''
+        if ' ' in value:
+            pytest.skip('Space in variable value on non-Hush shell')
+
+    state_test_env.u_boot_console.run_command(
+        'setenv %s %s%s%s' % (var, quote, value, quote))
     state_test_env.env[var] = value
 
 def validate_empty(state_test_env, var):
diff --git a/test/py/u_boot_console_base.py b/test/py/u_boot_console_base.py
index b1f474236e..4bccd72050 100644
--- a/test/py/u_boot_console_base.py
+++ b/test/py/u_boot_console_base.py
@@ -160,7 +160,7 @@ class ConsoleBase(object):
 
         Args:
             cmd: The command to send.
-            wait_for_each: Boolean indicating whether to wait for U-Boot to
+            wait_for_echo: Boolean indicating whether to wait for U-Boot to
                 echo the command text back to its output.
             send_nl: Boolean indicating whether to send a newline character
                 after the command string.
@@ -215,6 +215,8 @@ class ConsoleBase(object):
             self.log.error(str(ex))
             self.cleanup_spawn()
             raise
+        finally:
+            self.log.timestamp()
 
     def run_command_list(self, cmds):
         """Run a list of commands.
@@ -370,6 +372,7 @@ class ConsoleBase(object):
             self.cleanup_spawn()
             raise
         finally:
+            self.log.timestamp()
             self.log.end_section('Starting U-Boot')
 
     def cleanup_spawn(self):
diff --git a/tools/.gitignore b/tools/.gitignore
index 5293d44697..6653c58a1f 100644
--- a/tools/.gitignore
+++ b/tools/.gitignore
@@ -1,4 +1,3 @@
-/_libfdt.so
 /atmel_pmecc_params
 /bin2header
 /bmp_logo
@@ -17,9 +16,6 @@
 /img2srec
 /kwboot
 /lib/
-/libfdt.py
-/libfdt.pyc
-/libfdt_wrap.c
 /mips-relocs
 /mkenvimage
 /mkexynosspl
@@ -32,3 +28,9 @@
 /sunxi-spl-image-builder
 /ubsha1
 /xway-swap-bytes
+/trust_merger
+/boot_merger
+/loaderimage
+/checksum
+/resource_tool
+/bmp2gray16
diff --git a/tools/Makefile b/tools/Makefile
index a0db19d6b0..2bc097f57e 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -21,7 +21,6 @@ subdir-$(HOST_TOOLS_ALL) += gdb
 
 # Merge all the different vars for envcrc into one
 ENVCRC-$(CONFIG_ENV_IS_EMBEDDED) = y
-ENVCRC-$(CONFIG_ENV_IS_IN_DATAFLASH) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_EEPROM) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_FLASH) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_ONENAND) = y
@@ -58,28 +57,39 @@ mkenvimage-objs := mkenvimage.o os_support.o lib/crc32.o
 hostprogs-y += dumpimage mkimage
 hostprogs-$(CONFIG_FIT_SIGNATURE) += fit_info fit_check_sign
 
+# Rockchip pack tools
+ifdef CONFIG_ARCH_ROCKCHIP
+hostprogs-y += boot_merger
+hostprogs-y += trust_merger
+hostprogs-y += loaderimage
+hostprogs-y += resource_tool
+hostprogs-y += bmp2gray16
+
+boot_merger-objs := rockchip/boot_merger.o rockchip/sha2.o lib/sha256.o
+trust_merger-objs := rockchip/trust_merger.o rockchip/sha2.o lib/sha256.o
+loaderimage-objs := rockchip/loaderimage.o rockchip/sha.o lib/sha256.o rockchip/crc32_rk.o
+resource_tool-objs := rockchip/resource_tool.o
+bmp2gray16-objs := rockchip/bmp2gray16.o
+endif
+
 FIT_SIG_OBJS-$(CONFIG_FIT_SIGNATURE) := common/image-sig.o
-# Flattened device tree objects
-LIBFDT_CSRCS := fdt.c fdt_ro.c fdt_wip.c fdt_sw.c fdt_rw.c fdt_strerror.c  \
-			fdt_empty_tree.c fdt_addresses.c fdt_overlay.c \
-			fdt_region.c
-
-# Unfortunately setup.py below cannot handle srctree being ".." which it often
-# is. It fails with an error like:
-# Fatal error: can't create build/temp.linux-x86_64-2.7/../lib/libfdt/fdt.o:
-#    No such file or directory
-# To fix this, use an absolute path.
-libfdt_tree := $(shell readlink -f $(srctree)/lib/libfdt)
-
-LIBFDT_SRCS := $(addprefix $(libfdt_tree)/, $(LIBFDT_CSRCS))
-LIBFDT_SWIG := $(addprefix $(libfdt_tree)/, pylibfdt/libfdt.i)
-LIBFDT_OBJS := $(addprefix lib/libfdt/, $(patsubst %.c, %.o, $(LIBFDT_CSRCS)))
+
+# The following files are synced with upstream DTC.
+# Use synced versions from scripts/dtc/libfdt/.
+LIBFDT_SRCS_SYNCED := fdt.c fdt_wip.c fdt_sw.c fdt_rw.c \
+		fdt_strerror.c fdt_empty_tree.c fdt_addresses.c fdt_overlay.c
+# The following files are locally modified for U-Boot (unfotunately).
+# Use U-Boot own versions from lib/libfdt/.
+LIBFDT_SRCS_UNSYNCED := fdt_ro.c fdt_region.c
+
+LIBFDT_OBJS := $(addprefix libfdt/, $(patsubst %.c, %.o, $(LIBFDT_SRCS_SYNCED))) \
+	       $(addprefix lib/libfdt/, $(patsubst %.c, %.o, $(LIBFDT_SRCS_UNSYNCED)))
 
 RSA_OBJS-$(CONFIG_FIT_SIGNATURE) := $(addprefix lib/rsa/, \
 					rsa-sign.o rsa-verify.o rsa-checksum.o \
 					rsa-mod-exp.o)
 
-ROCKCHIP_OBS = lib/rc4.o rkcommon.o rkimage.o rksd.o rkspi.o
+ROCKCHIP_OBS = lib/rc4.o rkcommon.o rkimage.o rknand.o rksd.o rkspi.o
 
 # common objs for dumpimage and mkimage
 dumpimage-mkimage-objs := aisimage.o \
@@ -124,23 +134,6 @@ mkimage-objs   := $(dumpimage-mkimage-objs) mkimage.o
 fit_info-objs   := $(dumpimage-mkimage-objs) fit_info.o
 fit_check_sign-objs   := $(dumpimage-mkimage-objs) fit_check_sign.o
 
-# Unfortunately setup.py (or actually the Python distutil implementation)
-# puts files into the same directory as the .i file. We cannot touch the source
-# directory, so we copy the .i file into the tools/ build subdirectory before
-# calling setup. This directory is safe to write to. This ensures that we get
-# all three files in $(obj)/tools: _libfdt.so, libfdt.py and libfdt_wrap.c
-# The latter is a temporary file which we could actually remove.
-tools/_libfdt.so: $(LIBFDT_SRCS) $(LIBFDT_SWIG)
-	$(Q)cp $(LIBFDT_SWIG) tools/.
-	$(Q)unset CC; \
-	unset CROSS_COMPILE; \
-	LDFLAGS="$(HOSTLDFLAGS)" CFLAGS= VERSION="u-boot-$(UBOOTVERSION)" \
-		CPPFLAGS="$(_hostc_flags)" OBJDIR=tools \
-		SOURCES="$(LIBFDT_SRCS) tools/libfdt.i" \
-		SWIG_OPTS="-I$(srctree)/lib/libfdt -I$(srctree)/lib" \
-		$(PYTHON) $(libfdt_tree)/pylibfdt/setup.py --quiet build_ext \
-			--build-lib tools
-
 ifneq ($(CONFIG_MX23)$(CONFIG_MX28),)
 # Add CONFIG_MXS into host CFLAGS, so we can check whether or not register
 # the mxsimage support within tools/mxsimage.c .
@@ -175,7 +168,7 @@ HOSTCFLAGS_rsa-sign.o += -Wno-deprecated-declarations
 endif
 endif
 
-HOSTCFLAGS_fit_image.o += -DMKIMAGE_DTC=\"$(DTC)\"
+HOSTCFLAGS_fit_image.o += -DMKIMAGE_DTC=\"$(CONFIG_MKIMAGE_DTC_PATH)\"
 
 HOSTLOADLIBES_dumpimage := $(HOSTLOADLIBES_mkimage)
 HOSTLOADLIBES_fit_info := $(HOSTLOADLIBES_mkimage)
@@ -232,10 +225,6 @@ clean-dirs := lib common
 
 always := $(hostprogs-y)
 
-# Build a libfdt Python module if swig is available
-# Use 'sudo apt-get install swig libpython-dev' to enable this
-always += $(if $(shell which swig 2> /dev/null),_libfdt.so)
-
 # Generated LCD/video logo
 LOGO_H = $(objtree)/include/bmp_logo.h
 LOGO_DATA_H = $(objtree)/include/bmp_logo_data.h
@@ -264,9 +253,9 @@ endif # !LOGO_BMP
 # Define __KERNEL_STRICT_NAMES to prevent typedef overlaps
 # Define _GNU_SOURCE to obtain the getline prototype from stdio.h
 #
-HOST_EXTRACFLAGS += -include $(srctree)/include/libfdt_env.h \
+HOST_EXTRACFLAGS += -include $(srctree)/include/compiler.h \
 		$(patsubst -I%,-idirafter%, $(filter -I%, $(UBOOTINCLUDE))) \
-		-I$(srctree)/lib/libfdt \
+		-I$(srctree)/scripts/dtc/libfdt \
 		-I$(srctree)/tools \
 		-DUSE_HOSTCC \
 		-D__KERNEL_STRICT_NAMES \
diff --git a/tools/binman/binman.py b/tools/binman/binman.py
index 09dc36a3f7..e75a59d951 100755
--- a/tools/binman/binman.py
+++ b/tools/binman/binman.py
@@ -21,7 +21,7 @@ for dirname in ['../patman', '../dtoc', '..']:
     sys.path.insert(0, os.path.join(our_path, dirname))
 
 # Bring in the libfdt module
-sys.path.insert(0, 'tools')
+sys.path.insert(0, 'scripts/dtc/pylibfdt')
 
 # Also allow entry-type modules to be brought in from the etype directory.
 sys.path.insert(0, os.path.join(our_path, 'etype'))
diff --git a/tools/buildman/buildman.py b/tools/buildman/buildman.py
index 607429df7b..f5c4b047d0 100755
--- a/tools/buildman/buildman.py
+++ b/tools/buildman/buildman.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2
 #
 # Copyright (c) 2012 The Chromium OS Authors.
 #
diff --git a/tools/buildman/kconfiglib.py b/tools/buildman/kconfiglib.py
index d28bbf0b49..352ad438ee 100644
--- a/tools/buildman/kconfiglib.py
+++ b/tools/buildman/kconfiglib.py
@@ -204,6 +204,7 @@ class Config(object):
 
         self.print_warnings = print_warnings
         self.print_undef_assign = print_undef_assign
+        self._warnings = []
 
         # For parsing routines that stop when finding a line belonging to a
         # different construct, these holds that line and the tokenized version
@@ -398,8 +399,12 @@ class Config(object):
           need to refer to the top-level kernel directory with "$srctree".
 
         replace (default: True): True if the configuration should replace the
-           old configuration; False if it should add to it."""
+           old configuration; False if it should add to it.
 
+        Returns a list or warnings (hopefully empty)
+        """
+
+        self._warnings = []
         # Put this first so that a missing file doesn't screw up our state
         filename = os.path.expandvars(filename)
         line_feeder = _FileFeed(filename)
@@ -449,7 +454,7 @@ class Config(object):
         while 1:
             line = line_feeder.get_next()
             if line is None:
-                return
+                return self._warnings
 
             line = line.rstrip()
 
@@ -1763,8 +1768,10 @@ class Config(object):
 
     def _warn(self, msg, filename=None, linenr=None):
         """For printing warnings to stderr."""
+        msg = _build_msg("warning: " + msg, filename, linenr)
         if self.print_warnings:
-            _stderr_msg("warning: " + msg, filename, linenr)
+            sys.stderr.write(msg + "\n")
+        self._warnings.append(msg)
 
 class Item(object):
 
@@ -3369,10 +3376,13 @@ def _clean_up_path(path):
         path = path[2:]
     return path.rstrip("/")
 
-def _stderr_msg(msg, filename, linenr):
+def _build_msg(msg, filename, linenr):
     if filename is not None:
-        sys.stderr.write("{0}:{1}: ".format(_clean_up_path(filename), linenr))
-    sys.stderr.write(msg + "\n")
+        msg = "{0}:{1}: ".format(_clean_up_path(filename), linenr) + msg
+    return msg
+
+def _stderr_msg(msg, filename, linenr):
+    sys.stderr.write(_build_msg(msg, filename, linenr) + "\n")
 
 def _tokenization_error(s, filename, linenr):
     loc = "" if filename is None else "{0}:{1}: ".format(filename, linenr)
diff --git a/tools/dtoc/dtb_platdata.py b/tools/dtoc/dtb_platdata.py
index 041a33188f..c5767e5fb4 100644
--- a/tools/dtoc/dtb_platdata.py
+++ b/tools/dtoc/dtb_platdata.py
@@ -12,6 +12,7 @@ This supports converting device tree data to C structures definitions and
 static data.
 """
 
+import collections
 import copy
 import sys
 
@@ -38,11 +39,20 @@ TYPE_NAMES = {
     fdt.TYPE_BYTE: 'unsigned char',
     fdt.TYPE_STRING: 'const char *',
     fdt.TYPE_BOOL: 'bool',
+    fdt.TYPE_INT64: 'fdt64_t',
 }
 
 STRUCT_PREFIX = 'dtd_'
 VAL_PREFIX = 'dtv_'
 
+# This holds information about a property which includes phandles.
+#
+# max_args: integer: Maximum number or arguments that any phandle uses (int).
+# args: Number of args for each phandle in the property. The total number of
+#     phandles is len(args). This is a list of integers.
+PhandleInfo = collections.namedtuple('PhandleInfo', ['max_args', 'args'])
+
+
 def conv_name_to_c(name):
     """Convert a device-tree name to a C identifier
 
@@ -95,6 +105,8 @@ def get_value(ftype, value):
         return '"%s"' % value
     elif ftype == fdt.TYPE_BOOL:
         return 'true'
+    elif ftype == fdt.TYPE_INT64:
+        return '%#x' % value
 
 def get_compat_name(node):
     """Get a node's first compatible string as a C identifier
@@ -113,21 +125,6 @@ def get_compat_name(node):
         compat, aliases = compat[0], compat[1:]
     return conv_name_to_c(compat), [conv_name_to_c(a) for a in aliases]
 
-def is_phandle(prop):
-    """Check if a node contains phandles
-
-    We have no reliable way of detecting whether a node uses a phandle
-    or not. As an interim measure, use a list of known property names.
-
-    Args:
-        prop: Prop object to check
-    Return:
-        True if the object value contains phandles, else False
-    """
-    if prop.name in ['clocks']:
-        return True
-    return False
-
 
 class DtbPlatdata(object):
     """Provide a means to convert device tree binary data to platform data
@@ -141,17 +138,14 @@ class DtbPlatdata(object):
         _dtb_fname: Filename of the input device tree binary file
         _valid_nodes: A list of Node object with compatible strings
         _include_disabled: true to include nodes marked status = "disabled"
-        _phandle_nodes: A dict of nodes indexed by phandle number (1, 2...)
         _outfile: The current output file (sys.stdout or a real file)
         _lines: Stashed list of output lines for outputting in the future
-        _phandle_nodes: A dict of Nodes indexed by phandle (an integer)
     """
     def __init__(self, dtb_fname, include_disabled):
         self._fdt = None
         self._dtb_fname = dtb_fname
         self._valid_nodes = None
         self._include_disabled = include_disabled
-        self._phandle_nodes = {}
         self._outfile = None
         self._lines = []
         self._aliases = {}
@@ -196,6 +190,53 @@ class DtbPlatdata(object):
         self._lines = []
         return lines
 
+    def out_header(self):
+        """Output a message indicating that this is an auto-generated file"""
+        self.out('''/*
+ * DO NOT MODIFY
+ *
+ * This file was generated by dtoc from a .dtb (device tree binary) file.
+ */
+
+''')
+
+    def get_phandle_argc(self, prop, node_name):
+        """Check if a node contains phandles
+
+        We have no reliable way of detecting whether a node uses a phandle
+        or not. As an interim measure, use a list of known property names.
+
+        Args:
+            prop: Prop object to check
+        Return:
+            Number of argument cells is this is a phandle, else None
+        """
+        if prop.name in ['clocks']:
+            val = prop.value
+            if not isinstance(val, list):
+                val = [val]
+            i = 0
+
+            max_args = 0
+            args = []
+            while i < len(val):
+                phandle = fdt_util.fdt32_to_cpu(val[i])
+                target = self._fdt.phandle_to_node.get(phandle)
+                if not target:
+                    raise ValueError("Cannot parse '%s' in node '%s'" %
+                                     (prop.name, node_name))
+                prop_name = '#clock-cells'
+                cells = target.props.get(prop_name)
+                if not cells:
+                    raise ValueError("Node '%s' has no '%s' property" %
+                            (target.name, prop_name))
+                num_args = fdt_util.fdt32_to_cpu(cells.value)
+                max_args = max(max_args, num_args)
+                args.append(num_args)
+                i += 1 + num_args
+            return PhandleInfo(max_args, args)
+        return None
+
     def scan_dtb(self):
         """Scan the device tree to obtain a tree of nodes and properties
 
@@ -207,8 +248,7 @@ class DtbPlatdata(object):
     def scan_node(self, root):
         """Scan a node and subnodes to build a tree of node and phandle info
 
-        This adds each node to self._valid_nodes and each phandle to
-        self._phandle_nodes.
+        This adds each node to self._valid_nodes.
 
         Args:
             root: Root node for scan
@@ -219,10 +259,6 @@ class DtbPlatdata(object):
                 if (not self._include_disabled and not status or
                         status.value != 'disabled'):
                     self._valid_nodes.append(node)
-                    phandle_prop = node.props.get('phandle')
-                    if phandle_prop:
-                        phandle = phandle_prop.GetPhandle()
-                        self._phandle_nodes[phandle] = node
 
             # recurse to handle any subnodes
             self.scan_node(node)
@@ -231,14 +267,72 @@ class DtbPlatdata(object):
         """Scan the device tree for useful information
 
         This fills in the following properties:
-            _phandle_nodes: A dict of Nodes indexed by phandle (an integer)
             _valid_nodes: A list of nodes we wish to consider include in the
                 platform data
         """
-        self._phandle_nodes = {}
         self._valid_nodes = []
         return self.scan_node(self._fdt.GetRoot())
 
+    @staticmethod
+    def get_num_cells(node):
+        """Get the number of cells in addresses and sizes for this node
+
+        Args:
+            node: Node to check
+
+        Returns:
+            Tuple:
+                Number of address cells for this node
+                Number of size cells for this node
+        """
+        parent = node.parent
+        na, ns = 2, 2
+        if parent:
+            na_prop = parent.props.get('#address-cells')
+            ns_prop = parent.props.get('#size-cells')
+            if na_prop:
+                na = fdt_util.fdt32_to_cpu(na_prop.value)
+            if ns_prop:
+                ns = fdt_util.fdt32_to_cpu(ns_prop.value)
+        return na, ns
+
+    def scan_reg_sizes(self):
+        """Scan for 64-bit 'reg' properties and update the values
+
+        This finds 'reg' properties with 64-bit data and converts the value to
+        an array of 64-values. This allows it to be output in a way that the
+        C code can read.
+        """
+        for node in self._valid_nodes:
+            reg = node.props.get('reg')
+            if not reg:
+                continue
+            na, ns = self.get_num_cells(node)
+            total = na + ns
+
+            if reg.type != fdt.TYPE_INT:
+                raise ValueError("Node '%s' reg property is not an int")
+            if len(reg.value) % total:
+                raise ValueError("Node '%s' reg property has %d cells "
+                        'which is not a multiple of na + ns = %d + %d)' %
+                        (node.name, len(reg.value), na, ns))
+            reg.na = na
+            reg.ns = ns
+            if na != 1 or ns != 1:
+                reg.type = fdt.TYPE_INT64
+                i = 0
+                new_value = []
+                val = reg.value
+                if not isinstance(val, list):
+                    val = [val]
+                while i < len(val):
+                    addr = fdt_util.fdt_cells_to_cpu(val[i:], reg.na)
+                    i += na
+                    size = fdt_util.fdt_cells_to_cpu(val[i:], reg.ns)
+                    i += ns
+                    new_value += [addr, size]
+                reg.value = new_value
+
     def scan_structs(self):
         """Scan the device tree building up the C structures we will use.
 
@@ -305,14 +399,18 @@ class DtbPlatdata(object):
             for pname, prop in node.props.items():
                 if pname in PROP_IGNORE_LIST or pname[0] == '#':
                     continue
-                if isinstance(prop.value, list):
-                    if is_phandle(prop):
-                        # Process the list as pairs of (phandle, id)
-                        value_it = iter(prop.value)
-                        for phandle_cell, _ in zip(value_it, value_it):
-                            phandle = fdt_util.fdt32_to_cpu(phandle_cell)
-                            target_node = self._phandle_nodes[phandle]
-                            node.phandles.add(target_node)
+                info = self.get_phandle_argc(prop, node.name)
+                if info:
+                    if not isinstance(prop.value, list):
+                        prop.value = [prop.value]
+                    # Process the list as pairs of (phandle, id)
+                    pos = 0
+                    for args in info.args:
+                        phandle_cell = prop.value[pos]
+                        phandle = fdt_util.fdt32_to_cpu(phandle_cell)
+                        target_node = self._fdt.phandle_to_node[phandle]
+                        node.phandles.add(target_node)
+                        pos += 1 + args
 
 
     def generate_structs(self, structs):
@@ -322,19 +420,22 @@ class DtbPlatdata(object):
         definitions for node in self._valid_nodes. See the documentation in
         README.of-plat for more information.
         """
+        self.out_header()
         self.out('#include <stdbool.h>\n')
-        self.out('#include <libfdt.h>\n')
+        self.out('#include <linux/libfdt.h>\n')
 
         # Output the struct definition
         for name in sorted(structs):
             self.out('struct %s%s {\n' % (STRUCT_PREFIX, name))
             for pname in sorted(structs[name]):
                 prop = structs[name][pname]
-                if is_phandle(prop):
+                info = self.get_phandle_argc(prop, structs[name])
+                if info:
                     # For phandles, include a reference to the target
-                    self.out('\t%s%s[%d]' % (tab_to(2, 'struct phandle_2_cell'),
+                    struct_name = 'struct phandle_%d_arg' % info.max_args
+                    self.out('\t%s%s[%d]' % (tab_to(2, struct_name),
                                              conv_name_to_c(prop.name),
-                                             len(prop.value) / 2))
+                                             len(info.args)))
                 else:
                     ptype = TYPE_NAMES[prop.type]
                     self.out('\t%s%s' % (tab_to(2, ptype),
@@ -370,19 +471,32 @@ class DtbPlatdata(object):
                 vals = []
                 # For phandles, output a reference to the platform data
                 # of the target node.
-                if is_phandle(prop):
+                info = self.get_phandle_argc(prop, node.name)
+                if info:
                     # Process the list as pairs of (phandle, id)
-                    value_it = iter(prop.value)
-                    for phandle_cell, id_cell in zip(value_it, value_it):
+                    pos = 0
+                    for args in info.args:
+                        phandle_cell = prop.value[pos]
                         phandle = fdt_util.fdt32_to_cpu(phandle_cell)
-                        id_num = fdt_util.fdt32_to_cpu(id_cell)
-                        target_node = self._phandle_nodes[phandle]
+                        target_node = self._fdt.phandle_to_node[phandle]
                         name = conv_name_to_c(target_node.name)
-                        vals.append('{&%s%s, %d}' % (VAL_PREFIX, name, id_num))
+                        arg_values = []
+                        for i in range(args):
+                            arg_values.append(str(fdt_util.fdt32_to_cpu(prop.value[pos + 1 + i])))
+                        pos += 1 + args
+                        vals.append('\t{&%s%s, {%s}}' % (VAL_PREFIX, name,
+                                                     ', '.join(arg_values)))
+                    for val in vals:
+                        self.buf('\n\t\t%s,' % val)
                 else:
                     for val in prop.value:
                         vals.append(get_value(prop.type, val))
-                self.buf(', '.join(vals))
+
+                    # Put 8 values per line to avoid very long lines.
+                    for i in xrange(0, len(vals), 8):
+                        if i:
+                            self.buf(',\n\t\t')
+                        self.buf(', '.join(vals[i:i + 8]))
                 self.buf('}')
             else:
                 self.buf(get_value(prop.type, prop.value))
@@ -409,6 +523,7 @@ class DtbPlatdata(object):
         See the documentation in doc/driver-model/of-plat.txt for more
         information.
         """
+        self.out_header()
         self.out('#include <common.h>\n')
         self.out('#include <dm.h>\n')
         self.out('#include <dt-structs.h>\n')
@@ -442,6 +557,7 @@ def run_steps(args, dtb_file, include_disabled, output):
     plat = DtbPlatdata(dtb_file, include_disabled)
     plat.scan_dtb()
     plat.scan_tree()
+    plat.scan_reg_sizes()
     plat.setup_output(output)
     structs = plat.scan_structs()
     plat.scan_phandles()
diff --git a/tools/dtoc/dtoc.py b/tools/dtoc/dtoc.py
index ce7bc054e5..6eacfc90a0 100755
--- a/tools/dtoc/dtoc.py
+++ b/tools/dtoc/dtoc.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python2
 #
 # Copyright (C) 2016 Google, Inc
 # Written by Simon Glass <sjg@chromium.org>
diff --git a/tools/dtoc/dtoc_test_phandle.dts b/tools/dtoc/dtoc_test_phandle.dts
index e9828a695b..ba12b0fe65 100644
--- a/tools/dtoc/dtoc_test_phandle.dts
+++ b/tools/dtoc/dtoc_test_phandle.dts
@@ -10,14 +10,28 @@
 
 / {
 	phandle: phandle-target {
+		u-boot,dm-pre-reloc;
+		compatible = "target";
+		intval = <0>;
+                #clock-cells = <0>;
+	};
+
+	phandle_1: phandle2-target {
 		u-boot,dm-pre-reloc;
 		compatible = "target";
 		intval = <1>;
+		#clock-cells = <1>;
+	};
+	phandle_2: phandle3-target {
+		u-boot,dm-pre-reloc;
+		compatible = "target";
+		intval = <2>;
+		#clock-cells = <2>;
 	};
 
 	phandle-source {
 		u-boot,dm-pre-reloc;
 		compatible = "source";
-		clocks = <&phandle 1>;
+		clocks = <&phandle &phandle_1 11 &phandle_2 12 13 &phandle>;
 	};
 };
diff --git a/tools/dtoc/dtoc_test_simple.dts b/tools/dtoc/dtoc_test_simple.dts
index c736686263..6afe674b1f 100644
--- a/tools/dtoc/dtoc_test_simple.dts
+++ b/tools/dtoc/dtoc_test_simple.dts
@@ -9,6 +9,8 @@
  /dts-v1/;
 
 / {
+	#address-cells = <1>;
+	#size-cells = <1>;
 	spl-test {
 		u-boot,dm-pre-reloc;
 		compatible = "sandbox,spl-test";
@@ -45,4 +47,16 @@
 		compatible = "sandbox,spl-test.2";
 	};
 
+	i2c@0 {
+		compatible = "sandbox,i2c-test";
+		u-boot,dm-pre-reloc;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pmic@9 {
+			compatible = "sandbox,pmic-test";
+			u-boot,dm-pre-reloc;
+			reg = <9>;
+			low-power;
+		};
+	};
 };
diff --git a/tools/dtoc/fdt.py b/tools/dtoc/fdt.py
index 63a32ea2d7..dbc338653b 100644
--- a/tools/dtoc/fdt.py
+++ b/tools/dtoc/fdt.py
@@ -21,7 +21,7 @@ import libfdt
 # so it is fairly efficient.
 
 # A list of types we support
-(TYPE_BYTE, TYPE_INT, TYPE_STRING, TYPE_BOOL) = range(4)
+(TYPE_BYTE, TYPE_INT, TYPE_STRING, TYPE_BOOL, TYPE_INT64) = range(5)
 
 def CheckErr(errnum, msg):
     if errnum:
@@ -174,8 +174,9 @@ class Node:
         props: A dict of properties for this node, each a Prop object.
             Keyed by property name
     """
-    def __init__(self, fdt, offset, name, path):
+    def __init__(self, fdt, parent, offset, name, path):
         self._fdt = fdt
+        self.parent = parent
         self._offset = offset
         self.name = name
         self.path = path
@@ -211,13 +212,17 @@ class Node:
         searching into subnodes so that the entire tree is built.
         """
         self.props = self._fdt.GetProps(self)
+        phandle = self.props.get('phandle')
+        if phandle:
+            val = fdt_util.fdt32_to_cpu(phandle.value)
+            self._fdt.phandle_to_node[val] = self
 
         offset = libfdt.fdt_first_subnode(self._fdt.GetFdt(), self.Offset())
         while offset >= 0:
             sep = '' if self.path[-1] == '/' else '/'
             name = self._fdt._fdt_obj.get_name(offset)
             path = self.path + sep + name
-            node = Node(self._fdt, offset, name, path)
+            node = Node(self._fdt, self, offset, name, path)
             self.subnodes.append(node)
 
             node.Scan()
@@ -262,6 +267,7 @@ class Fdt:
     def __init__(self, fname):
         self._fname = fname
         self._cached_offsets = False
+        self.phandle_to_node = {}
         if self._fname:
             self._fname = fdt_util.EnsureCompiled(self._fname)
 
@@ -279,7 +285,7 @@ class Fdt:
 
         TODO(sjg@chromium.org): Implement the 'root' parameter
         """
-        self._root = self.Node(self, 0, '/', '/')
+        self._root = self.Node(self, None, 0, '/', '/')
         self._root.Scan()
 
     def GetRoot(self):
@@ -386,7 +392,7 @@ class Fdt:
         return libfdt.fdt_off_dt_struct(self._fdt) + offset
 
     @classmethod
-    def Node(self, fdt, offset, name, path):
+    def Node(self, fdt, parent, offset, name, path):
         """Create a new node
 
         This is used by Fdt.Scan() to create a new node using the correct
@@ -394,11 +400,12 @@ class Fdt:
 
         Args:
             fdt: Fdt object
+            parent: Parent node, or None if this is the root node
             offset: Offset of node
             name: Node name
             path: Full path to node
         """
-        node = Node(fdt, offset, name, path)
+        node = Node(fdt, parent, offset, name, path)
         return node
 
 def FdtScan(fname):
diff --git a/tools/dtoc/fdt_util.py b/tools/dtoc/fdt_util.py
index b9dfae8d0e..338d47a5e1 100644
--- a/tools/dtoc/fdt_util.py
+++ b/tools/dtoc/fdt_util.py
@@ -29,6 +29,22 @@ def fdt32_to_cpu(val):
         val = val.encode('raw_unicode_escape')
     return struct.unpack('>I', val)[0]
 
+def fdt_cells_to_cpu(val, cells):
+    """Convert one or two cells to a long integer
+
+    Args:
+        Value to convert (array of one or more 4-character strings)
+
+    Return:
+        A native-endian long value
+    """
+    if not cells:
+        return 0
+    out = long(fdt32_to_cpu(val[0]))
+    if cells == 2:
+        out = out << 32 | fdt32_to_cpu(val[1])
+    return out
+
 def EnsureCompiled(fname):
     """Compile an fdt .dts source file into a .dtb binary blob if needed.
 
diff --git a/tools/dtoc/test_dtoc.py b/tools/dtoc/test_dtoc.py
index 8b95c4124f..0553b5cdf9 100644
--- a/tools/dtoc/test_dtoc.py
+++ b/tools/dtoc/test_dtoc.py
@@ -26,6 +26,27 @@ import tools
 our_path = os.path.dirname(os.path.realpath(__file__))
 
 
+HEADER = '''/*
+ * DO NOT MODIFY
+ *
+ * This file was generated by dtoc from a .dtb (device tree binary) file.
+ */
+
+#include <stdbool.h>
+#include <linux/libfdt.h>'''
+
+C_HEADER = '''/*
+ * DO NOT MODIFY
+ *
+ * This file was generated by dtoc from a .dtb (device tree binary) file.
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dt-structs.h>
+'''
+
+
 def get_dtb_file(dts_fname):
     """Compile a .dts file to a .dtb
 
@@ -104,13 +125,12 @@ class TestDtoc(unittest.TestCase):
         dtb_platdata.run_steps(['struct'], dtb_file, False, output)
         with open(output) as infile:
             lines = infile.read().splitlines()
-        self.assertEqual(['#include <stdbool.h>', '#include <libfdt.h>'], lines)
+        self.assertEqual(HEADER.splitlines(), lines)
 
         dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
         with open(output) as infile:
             lines = infile.read().splitlines()
-        self.assertEqual(['#include <common.h>', '#include <dm.h>',
-                          '#include <dt-structs.h>', ''], lines)
+        self.assertEqual(C_HEADER.splitlines() + [''], lines)
 
     def test_simple(self):
         """Test output from some simple nodes with various types of data"""
@@ -119,8 +139,13 @@ class TestDtoc(unittest.TestCase):
         dtb_platdata.run_steps(['struct'], dtb_file, False, output)
         with open(output) as infile:
             data = infile.read()
-        self.assertEqual('''#include <stdbool.h>
-#include <libfdt.h>
+        self.assertEqual(HEADER + '''
+struct dtd_sandbox_i2c_test {
+};
+struct dtd_sandbox_pmic_test {
+\tbool\t\tlow_power;
+\tfdt64_t\t\treg[2];
+};
 struct dtd_sandbox_spl_test {
 \tbool\t\tboolval;
 \tunsigned char\tbytearray[3];
@@ -138,15 +163,13 @@ struct dtd_sandbox_spl_test_2 {
         dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
         with open(output) as infile:
             data = infile.read()
-        self.assertEqual('''#include <common.h>
-#include <dm.h>
-#include <dt-structs.h>
-
+        self.assertEqual(C_HEADER + '''
 static struct dtd_sandbox_spl_test dtv_spl_test = {
 \t.bytearray\t\t= {0x6, 0x0, 0x0},
 \t.byteval\t\t= 0x5,
 \t.intval\t\t\t= 0x1,
-\t.longbytearray\t\t= {0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
+\t.longbytearray\t\t= {0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10,
+\t\t0x11},
 \t.stringval\t\t= "message",
 \t.boolval\t\t= true,
 \t.intarray\t\t= {0x2, 0x3, 0x4, 0x0},
@@ -162,7 +185,8 @@ static struct dtd_sandbox_spl_test dtv_spl_test2 = {
 \t.bytearray\t\t= {0x1, 0x23, 0x34},
 \t.byteval\t\t= 0x8,
 \t.intval\t\t\t= 0x3,
-\t.longbytearray\t\t= {0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
+\t.longbytearray\t\t= {0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+\t\t0x0},
 \t.stringval\t\t= "message2",
 \t.intarray\t\t= {0x5, 0x0, 0x0, 0x0},
 \t.stringarray\t\t= {"another", "multi-word", "message"},
@@ -190,6 +214,24 @@ U_BOOT_DEVICE(spl_test4) = {
 \t.platdata_size\t= sizeof(dtv_spl_test4),
 };
 
+static struct dtd_sandbox_i2c_test dtv_i2c_at_0 = {
+};
+U_BOOT_DEVICE(i2c_at_0) = {
+\t.name\t\t= "sandbox_i2c_test",
+\t.platdata\t= &dtv_i2c_at_0,
+\t.platdata_size\t= sizeof(dtv_i2c_at_0),
+};
+
+static struct dtd_sandbox_pmic_test dtv_pmic_at_9 = {
+\t.low_power\t\t= true,
+\t.reg\t\t\t= {0x9, 0x0},
+};
+U_BOOT_DEVICE(pmic_at_9) = {
+\t.name\t\t= "sandbox_pmic_test",
+\t.platdata\t= &dtv_pmic_at_9,
+\t.platdata_size\t= sizeof(dtv_pmic_at_9),
+};
+
 ''', data)
 
     def test_phandle(self):
@@ -199,10 +241,9 @@ U_BOOT_DEVICE(spl_test4) = {
         dtb_platdata.run_steps(['struct'], dtb_file, False, output)
         with open(output) as infile:
             data = infile.read()
-        self.assertEqual('''#include <stdbool.h>
-#include <libfdt.h>
+        self.assertEqual(HEADER + '''
 struct dtd_source {
-\tstruct phandle_2_cell clocks[1];
+\tstruct phandle_2_arg clocks[4];
 };
 struct dtd_target {
 \tfdt32_t\t\tintval;
@@ -212,12 +253,9 @@ struct dtd_target {
         dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
         with open(output) as infile:
             data = infile.read()
-        self.assertEqual('''#include <common.h>
-#include <dm.h>
-#include <dt-structs.h>
-
+        self.assertEqual(C_HEADER + '''
 static struct dtd_target dtv_phandle_target = {
-\t.intval\t\t\t= 0x1,
+\t.intval\t\t\t= 0x0,
 };
 U_BOOT_DEVICE(phandle_target) = {
 \t.name\t\t= "target",
@@ -225,8 +263,30 @@ U_BOOT_DEVICE(phandle_target) = {
 \t.platdata_size\t= sizeof(dtv_phandle_target),
 };
 
+static struct dtd_target dtv_phandle2_target = {
+\t.intval\t\t\t= 0x1,
+};
+U_BOOT_DEVICE(phandle2_target) = {
+\t.name\t\t= "target",
+\t.platdata\t= &dtv_phandle2_target,
+\t.platdata_size\t= sizeof(dtv_phandle2_target),
+};
+
+static struct dtd_target dtv_phandle3_target = {
+\t.intval\t\t\t= 0x2,
+};
+U_BOOT_DEVICE(phandle3_target) = {
+\t.name\t\t= "target",
+\t.platdata\t= &dtv_phandle3_target,
+\t.platdata_size\t= sizeof(dtv_phandle3_target),
+};
+
 static struct dtd_source dtv_phandle_source = {
-\t.clocks\t\t\t= {{&dtv_phandle_target, 1}},
+\t.clocks\t\t\t= {
+\t\t\t{&dtv_phandle_target, {}},
+\t\t\t{&dtv_phandle2_target, {11}},
+\t\t\t{&dtv_phandle3_target, {12, 13}},
+\t\t\t{&dtv_phandle_target, {}},},
 };
 U_BOOT_DEVICE(phandle_source) = {
 \t.name\t\t= "source",
@@ -243,8 +303,7 @@ U_BOOT_DEVICE(phandle_source) = {
         dtb_platdata.run_steps(['struct'], dtb_file, False, output)
         with open(output) as infile:
             data = infile.read()
-        self.assertEqual('''#include <stdbool.h>
-#include <libfdt.h>
+        self.assertEqual(HEADER + '''
 struct dtd_compat1 {
 \tfdt32_t\t\tintval;
 };
@@ -255,10 +314,7 @@ struct dtd_compat1 {
         dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
         with open(output) as infile:
             data = infile.read()
-        self.assertEqual('''#include <common.h>
-#include <dm.h>
-#include <dt-structs.h>
-
+        self.assertEqual(C_HEADER + '''
 static struct dtd_compat1 dtv_spl_test = {
 \t.intval\t\t\t= 0x1,
 };
@@ -268,4 +324,200 @@ U_BOOT_DEVICE(spl_test) = {
 \t.platdata_size\t= sizeof(dtv_spl_test),
 };
 
+''', data)
+
+    def test_addresses64(self):
+        """Test output from a node with a 'reg' property with na=2, ns=2"""
+        dtb_file = get_dtb_file('dtoc_test_addr64.dts')
+        output = tools.GetOutputFilename('output')
+        dtb_platdata.run_steps(['struct'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(HEADER + '''
+struct dtd_test1 {
+\tfdt64_t\t\treg[2];
+};
+struct dtd_test2 {
+\tfdt64_t\t\treg[2];
+};
+struct dtd_test3 {
+\tfdt64_t\t\treg[4];
+};
+''', data)
+
+        dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(C_HEADER + '''
+static struct dtd_test1 dtv_test1 = {
+\t.reg\t\t\t= {0x1234, 0x5678},
+};
+U_BOOT_DEVICE(test1) = {
+\t.name\t\t= "test1",
+\t.platdata\t= &dtv_test1,
+\t.platdata_size\t= sizeof(dtv_test1),
+};
+
+static struct dtd_test2 dtv_test2 = {
+\t.reg\t\t\t= {0x1234567890123456, 0x9876543210987654},
+};
+U_BOOT_DEVICE(test2) = {
+\t.name\t\t= "test2",
+\t.platdata\t= &dtv_test2,
+\t.platdata_size\t= sizeof(dtv_test2),
+};
+
+static struct dtd_test3 dtv_test3 = {
+\t.reg\t\t\t= {0x1234567890123456, 0x9876543210987654, 0x2, 0x3},
+};
+U_BOOT_DEVICE(test3) = {
+\t.name\t\t= "test3",
+\t.platdata\t= &dtv_test3,
+\t.platdata_size\t= sizeof(dtv_test3),
+};
+
+''', data)
+
+    def test_addresses32(self):
+        """Test output from a node with a 'reg' property with na=1, ns=1"""
+        dtb_file = get_dtb_file('dtoc_test_addr32.dts')
+        output = tools.GetOutputFilename('output')
+        dtb_platdata.run_steps(['struct'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(HEADER + '''
+struct dtd_test1 {
+\tfdt32_t\t\treg[2];
+};
+struct dtd_test2 {
+\tfdt32_t\t\treg[4];
+};
+''', data)
+
+        dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(C_HEADER + '''
+static struct dtd_test1 dtv_test1 = {
+\t.reg\t\t\t= {0x1234, 0x5678},
+};
+U_BOOT_DEVICE(test1) = {
+\t.name\t\t= "test1",
+\t.platdata\t= &dtv_test1,
+\t.platdata_size\t= sizeof(dtv_test1),
+};
+
+static struct dtd_test2 dtv_test2 = {
+\t.reg\t\t\t= {0x12345678, 0x98765432, 0x2, 0x3},
+};
+U_BOOT_DEVICE(test2) = {
+\t.name\t\t= "test2",
+\t.platdata\t= &dtv_test2,
+\t.platdata_size\t= sizeof(dtv_test2),
+};
+
+''', data)
+
+    def test_addresses64_32(self):
+        """Test output from a node with a 'reg' property with na=2, ns=1"""
+        dtb_file = get_dtb_file('dtoc_test_addr64_32.dts')
+        output = tools.GetOutputFilename('output')
+        dtb_platdata.run_steps(['struct'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(HEADER + '''
+struct dtd_test1 {
+\tfdt64_t\t\treg[2];
+};
+struct dtd_test2 {
+\tfdt64_t\t\treg[2];
+};
+struct dtd_test3 {
+\tfdt64_t\t\treg[4];
+};
+''', data)
+
+        dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(C_HEADER + '''
+static struct dtd_test1 dtv_test1 = {
+\t.reg\t\t\t= {0x123400000000, 0x5678},
+};
+U_BOOT_DEVICE(test1) = {
+\t.name\t\t= "test1",
+\t.platdata\t= &dtv_test1,
+\t.platdata_size\t= sizeof(dtv_test1),
+};
+
+static struct dtd_test2 dtv_test2 = {
+\t.reg\t\t\t= {0x1234567890123456, 0x98765432},
+};
+U_BOOT_DEVICE(test2) = {
+\t.name\t\t= "test2",
+\t.platdata\t= &dtv_test2,
+\t.platdata_size\t= sizeof(dtv_test2),
+};
+
+static struct dtd_test3 dtv_test3 = {
+\t.reg\t\t\t= {0x1234567890123456, 0x98765432, 0x2, 0x3},
+};
+U_BOOT_DEVICE(test3) = {
+\t.name\t\t= "test3",
+\t.platdata\t= &dtv_test3,
+\t.platdata_size\t= sizeof(dtv_test3),
+};
+
+''', data)
+
+    def test_addresses32_64(self):
+        """Test output from a node with a 'reg' property with na=1, ns=2"""
+        dtb_file = get_dtb_file('dtoc_test_addr32_64.dts')
+        output = tools.GetOutputFilename('output')
+        dtb_platdata.run_steps(['struct'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(HEADER + '''
+struct dtd_test1 {
+\tfdt64_t\t\treg[2];
+};
+struct dtd_test2 {
+\tfdt64_t\t\treg[2];
+};
+struct dtd_test3 {
+\tfdt64_t\t\treg[4];
+};
+''', data)
+
+        dtb_platdata.run_steps(['platdata'], dtb_file, False, output)
+        with open(output) as infile:
+            data = infile.read()
+        self.assertEqual(C_HEADER + '''
+static struct dtd_test1 dtv_test1 = {
+\t.reg\t\t\t= {0x1234, 0x567800000000},
+};
+U_BOOT_DEVICE(test1) = {
+\t.name\t\t= "test1",
+\t.platdata\t= &dtv_test1,
+\t.platdata_size\t= sizeof(dtv_test1),
+};
+
+static struct dtd_test2 dtv_test2 = {
+\t.reg\t\t\t= {0x12345678, 0x9876543210987654},
+};
+U_BOOT_DEVICE(test2) = {
+\t.name\t\t= "test2",
+\t.platdata\t= &dtv_test2,
+\t.platdata_size\t= sizeof(dtv_test2),
+};
+
+static struct dtd_test3 dtv_test3 = {
+\t.reg\t\t\t= {0x12345678, 0x9876543210987654, 0x2, 0x3},
+};
+U_BOOT_DEVICE(test3) = {
+\t.name\t\t= "test3",
+\t.platdata\t= &dtv_test3,
+\t.platdata_size\t= sizeof(dtv_test3),
+};
+
 ''', data)
diff --git a/tools/env/.gitignore b/tools/env/.gitignore
index 804abacc6e..8d28b2b70b 100644
--- a/tools/env/.gitignore
+++ b/tools/env/.gitignore
@@ -1,2 +1,3 @@
+embedded.c
 fw_printenv
 fw_printenv_unstripped
diff --git a/tools/env/Makefile b/tools/env/Makefile
index 95b28c0b3a..6a61bfaba4 100644
--- a/tools/env/Makefile
+++ b/tools/env/Makefile
@@ -16,6 +16,8 @@ HOST_EXTRACFLAGS  = $(patsubst -I%,-idirafter%, $(filter -I%, $(UBOOTINCLUDE)))
 		-DUSE_HOSTCC \
 		-DTEXT_BASE=$(TEXT_BASE)
 
+HOSTLDFLAGS = -static
+
 ifeq ($(MTD_VERSION),old)
 HOST_EXTRACFLAGS += -DMTD_OLD
 endif
diff --git a/tools/env/fw_env_main.c b/tools/env/fw_env_main.c
index 6e278ca80b..0b9063742c 100644
--- a/tools/env/fw_env_main.c
+++ b/tools/env/fw_env_main.c
@@ -34,6 +34,7 @@
 #include <stdlib.h>
 #include <sys/file.h>
 #include <unistd.h>
+#include <version.h>
 #include "fw_env_private.h"
 #include "fw_env.h"
 
@@ -48,6 +49,7 @@ static struct option long_options[] = {
 	{"script", required_argument, NULL, 's'},
 	{"noheader", required_argument, NULL, 'n'},
 	{"lock", required_argument, NULL, 'l'},
+	{"version", no_argument, NULL, 'v'},
 	{NULL, 0, NULL, 0}
 };
 
@@ -67,6 +69,7 @@ void usage_printenv(void)
 		"Print variables from U-Boot environment\n"
 		"\n"
 		" -h, --help           print this help.\n"
+		" -v, --version        display version\n"
 #ifdef CONFIG_ENV_AES
 		" -a, --aes            aes key to access environment\n"
 #endif
@@ -85,6 +88,7 @@ void usage_env_set(void)
 		"Modify variables in U-Boot environment\n"
 		"\n"
 		" -h, --help           print this help.\n"
+		" -v, --version        display version\n"
 #ifdef CONFIG_ENV_AES
 		" -a, --aes            aes key to access environment\n"
 #endif
@@ -123,7 +127,7 @@ static void parse_common_args(int argc, char *argv[])
 	env_opts.config_file = CONFIG_FILE;
 #endif
 
-	while ((c = getopt_long(argc, argv, ":a:c:l:h", long_options, NULL)) !=
+	while ((c = getopt_long(argc, argv, ":a:c:l:h:v", long_options, NULL)) !=
 	       EOF) {
 		switch (c) {
 		case 'a':
@@ -145,6 +149,10 @@ static void parse_common_args(int argc, char *argv[])
 			do_printenv ? usage_printenv() : usage_env_set();
 			exit(EXIT_SUCCESS);
 			break;
+		case 'v':
+			fprintf(stderr, "Compiled with " U_BOOT_VERSION "\n");
+			exit(EXIT_SUCCESS);
+			break;
 		default:
 			/* ignore unknown options */
 			break;
@@ -162,7 +170,7 @@ int parse_printenv_args(int argc, char *argv[])
 
 	parse_common_args(argc, argv);
 
-	while ((c = getopt_long(argc, argv, "a:c:ns:l:h", long_options, NULL))
+	while ((c = getopt_long(argc, argv, "a:c:ns:l:h:v", long_options, NULL))
 		!= EOF) {
 		switch (c) {
 		case 'n':
@@ -189,7 +197,7 @@ int parse_setenv_args(int argc, char *argv[])
 
 	parse_common_args(argc, argv);
 
-	while ((c = getopt_long(argc, argv, "a:c:ns:l:h", long_options, NULL))
+	while ((c = getopt_long(argc, argv, "a:c:ns:l:h:v", long_options, NULL))
 		!= EOF) {
 		switch (c) {
 		case 's':
diff --git a/tools/fdt_host.h b/tools/fdt_host.h
index 134d965713..d962368c12 100644
--- a/tools/fdt_host.h
+++ b/tools/fdt_host.h
@@ -8,9 +8,26 @@
 #define __FDT_HOST_H__
 
 /* Make sure to include u-boot version of libfdt include files */
-#include "../include/libfdt.h"
+#include "../include/linux/libfdt.h"
 #include "../include/fdt_support.h"
 
-int fit_check_sign(const void *working_fdt, const void *key);
+/**
+ * fdt_remove_unused_strings() - Remove any unused strings from an FDT
+ *
+ * This creates a new device tree in @new with unused strings removed. The
+ * called can then use fdt_pack() to minimise the space consumed.
+ *
+ * @old:	Old device tree blog
+ * @new:	Place to put new device tree blob, which must be as large as
+ *		@old
+ * @return
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, corrupt device tree
+ *	-FDT_ERR_NOSPACE, out of space, which should not happen unless there
+ *		is something very wrong with the device tree input
+ */
+int fdt_remove_unused_strings(const void *old, void *new);
+
+int fit_check_sign(const void *working_fdt, const void *key, int is_spl);
 
 #endif /* __FDT_HOST_H__ */
diff --git a/tools/fdtgrep.c b/tools/fdtgrep.c
index f51f5f15f5..8d33205ea2 100644
--- a/tools/fdtgrep.c
+++ b/tools/fdtgrep.c
@@ -10,14 +10,17 @@
 
 #include <assert.h>
 #include <ctype.h>
+#include <errno.h>
 #include <getopt.h>
+#include <fcntl.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 
-#include <../include/libfdt.h>
-#include <libfdt_internal.h>
+#include "fdt_host.h"
+#include "libfdt_internal.h"
 
 /* Define DEBUG to get some debugging output on stderr */
 #ifdef DEBUG
diff --git a/tools/fit_check_sign.c b/tools/fit_check_sign.c
index d9361b0095..06d3f08b3e 100644
--- a/tools/fit_check_sign.c
+++ b/tools/fit_check_sign.c
@@ -46,10 +46,11 @@ int main(int argc, char **argv)
 	int ret;
 	void *key_blob;
 	int c;
+	int is_spl = 0;
 
 	strncpy(cmdname, *argv, sizeof(cmdname) - 1);
 	cmdname[sizeof(cmdname) - 1] = '\0';
-	while ((c = getopt(argc, argv, "f:k:")) != -1)
+	while ((c = getopt(argc, argv, "f:k:s")) != -1)
 		switch (c) {
 		case 'f':
 			fdtfile = optarg;
@@ -57,6 +58,9 @@ int main(int argc, char **argv)
 		case 'k':
 			keyfile = optarg;
 			break;
+		case 's':
+			is_spl = 1;
+			break;
 		default:
 			usage(cmdname);
 			break;
@@ -79,7 +83,7 @@ int main(int argc, char **argv)
 		return EXIT_FAILURE;
 
 	image_set_host_blob(key_blob);
-	ret = fit_check_sign(fit_blob, key_blob);
+	ret = fit_check_sign(fit_blob, key_blob, is_spl);
 	if (!ret) {
 		ret = EXIT_SUCCESS;
 		fprintf(stderr, "Signature check OK\n");
diff --git a/tools/fit_image.c b/tools/fit_image.c
index 4dc8bd8862..d1ce07209b 100644
--- a/tools/fit_image.c
+++ b/tools/fit_image.c
@@ -24,6 +24,52 @@
 
 static image_header_t header;
 
+#define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
+
+/* Resize the fdt to its actual size + a bit of padding */
+static int fdt_shrink_to_minimum(void *blob, uint extrasize)
+{
+	uint64_t addr, size;
+	uint actualsize;
+	int total, ret;
+	int i;
+
+	if (!blob)
+		return 0;
+
+	total = fdt_num_mem_rsv(blob);
+	for (i = 0; i < total; i++) {
+		fdt_get_mem_rsv(blob, i, &addr, &size);
+		if (addr == (uintptr_t)blob) {
+			fdt_del_mem_rsv(blob, i);
+			break;
+		}
+	}
+
+	/*
+	 * Calculate the actual size of the fdt
+	 * plus the size needed for 5 fdt_add_mem_rsv, one
+	 * for the fdt itself and 4 for a possible initrd
+	 * ((initrd-start + initrd-end) * 2 (name & value))
+	 */
+	actualsize = fdt_off_dt_strings(blob) +
+		fdt_size_dt_strings(blob) + 5 * sizeof(struct fdt_reserve_entry);
+
+	actualsize += extrasize;
+	actualsize = ALIGN(actualsize + ((uintptr_t)blob & 0xfff), 0x200);
+	actualsize = actualsize - ((uintptr_t)blob & 0xfff);
+
+	/* Change the fdt header to reflect the correct size */
+	fdt_set_totalsize(blob, actualsize);
+
+	/* Add the new reservation */
+	ret = fdt_add_mem_rsv(blob, (uintptr_t)blob, actualsize);
+	if (ret < 0)
+		return ret;
+
+	return actualsize;
+}
+
 static int fit_add_file_data(struct image_tool_params *params, size_t size_inc,
 			     const char *tmpfile)
 {
@@ -53,7 +99,12 @@ static int fit_add_file_data(struct image_tool_params *params, size_t size_inc,
 	/* for first image creation, add a timestamp at offset 0 i.e., root  */
 	if (params->datafile) {
 		time_t time = imagetool_get_source_date(params, sbuf.st_mtime);
-		ret = fit_set_timestamp(ptr, 0, time);
+		ret  = fit_set_timestamp(ptr, 0, time);
+		ret |= fit_set_totalsize(ptr, 0, sbuf.st_size);
+		if (params->vflag > 0)
+			ret |= fit_set_version(ptr, 0, params->vflag);
+		else
+			ret |= fit_set_version(ptr, 0, 0);
 	}
 
 	if (!ret) {
@@ -63,6 +114,16 @@ static int fit_add_file_data(struct image_tool_params *params, size_t size_inc,
 						params->engine_id);
 	}
 
+	/* Remove external data size from fdt totalsize */
+	if (params->external_offset) {
+		fdt_shrink_to_minimum(ptr, 0);
+		if (params->external_offset < fdt_totalsize(ptr)) {
+			ret = -EINVAL;
+			printf("Failed: external offset 0x%x overlaps FIT length 0x%x\n",
+			       params->external_offset, fdt_totalsize(ptr));
+		}
+	}
+
 	if (dest_blob) {
 		munmap(dest_blob, destfd_size);
 		close(destfd);
@@ -372,7 +433,7 @@ static int fit_build(struct image_tool_params *params, const char *fname)
 	if (fd < 0) {
 		fprintf(stderr, "%s: Can't open %s: %s\n",
 			params->cmdname, fname, strerror(errno));
-		goto err;
+		goto err_buf;
 	}
 	ret = write(fd, buf, size);
 	if (ret != size) {
@@ -414,7 +475,7 @@ static int fit_extract_data(struct image_tool_params *params, const char *fname)
 	int images;
 	int node;
 
-	fd = mmap_fdt(params->cmdname, fname, 0, &fdt, &sbuf, false);
+	fd = mmap_fdt(params->cmdname, fname, 0x400, &fdt, &sbuf, false);
 	if (fd < 0)
 		return -EIO;
 	fit_size = fdt_totalsize(fdt);
@@ -460,7 +521,7 @@ static int fit_extract_data(struct image_tool_params *params, const char *fname)
 		}
 		fdt_setprop_u32(fdt, node, "data-size", len);
 
-		buf_ptr += (len + 3) & ~3;
+		buf_ptr += FIT_ALIGN(len);
 	}
 
 	/* Pack the FDT and place the data after it */
@@ -469,7 +530,7 @@ static int fit_extract_data(struct image_tool_params *params, const char *fname)
 	debug("Size reduced from %x to %x\n", fit_size, fdt_totalsize(fdt));
 	debug("External data size %x\n", buf_ptr);
 	new_size = fdt_totalsize(fdt);
-	new_size = (new_size + 3) & ~3;
+	new_size = FIT_ALIGN(new_size);
 	munmap(fdt, sbuf.st_size);
 
 	if (ftruncate(fd, new_size)) {
@@ -482,8 +543,8 @@ static int fit_extract_data(struct image_tool_params *params, const char *fname)
 	/* Check if an offset for the external data was set. */
 	if (params->external_offset > 0) {
 		if (params->external_offset < new_size) {
-			debug("External offset %x overlaps FIT length %x",
-			      params->external_offset, new_size);
+			printf("Failed: external offset 0x%x overlaps FIT length 0x%x\n",
+			       params->external_offset, new_size);
 			ret = -EINVAL;
 			goto err;
 		}
@@ -501,6 +562,7 @@ static int fit_extract_data(struct image_tool_params *params, const char *fname)
 		ret = -EIO;
 		goto err;
 	}
+	free(buf);
 	close(fd);
 	return 0;
 
@@ -527,7 +589,7 @@ static int fit_import_data(struct image_tool_params *params, const char *fname)
 	if (fd < 0)
 		return -EIO;
 	fit_size = fdt_totalsize(old_fdt);
-	data_base = (fit_size + 3) & ~3;
+	data_base = FIT_ALIGN(fit_size);
 
 	/* Allocate space to hold the new FIT */
 	size = sbuf.st_size + 16384;
@@ -536,21 +598,21 @@ static int fit_import_data(struct image_tool_params *params, const char *fname)
 		fprintf(stderr, "%s: Failed to allocate memory (%d bytes)\n",
 			__func__, size);
 		ret = -ENOMEM;
-		goto err;
+		goto err_has_fd;
 	}
 	ret = fdt_open_into(old_fdt, fdt, size);
 	if (ret) {
 		debug("%s: Failed to expand FIT: %s\n", __func__,
 		      fdt_strerror(errno));
 		ret = -EINVAL;
-		goto err;
+		goto err_has_fd;
 	}
 
 	images = fdt_path_offset(fdt, FIT_IMAGES_PATH);
 	if (images < 0) {
 		debug("%s: Cannot find /images node: %d\n", __func__, images);
 		ret = -EINVAL;
-		goto err;
+		goto err_has_fd;
 	}
 
 	for (node = fdt_first_subnode(fdt, images);
@@ -571,11 +633,11 @@ static int fit_import_data(struct image_tool_params *params, const char *fname)
 			debug("%s: Failed to write property: %s\n", __func__,
 			      fdt_strerror(ret));
 			ret = -EINVAL;
-			goto err;
+			goto err_has_fd;
 		}
 	}
 
-	munmap(old_fdt, sbuf.st_size);
+	/* Close the old fd so we can re-use it. */
 	close(fd);
 
 	/* Pack the FDT and place the data after it */
@@ -588,21 +650,23 @@ static int fit_import_data(struct image_tool_params *params, const char *fname)
 	if (fd < 0) {
 		fprintf(stderr, "%s: Can't open %s: %s\n",
 			params->cmdname, fname, strerror(errno));
-		free(fdt);
-		return -EIO;
+		ret = -EIO;
+		goto err_no_fd;
 	}
 	if (write(fd, fdt, new_size) != new_size) {
 		debug("%s: Failed to write external data to file %s\n",
 		      __func__, strerror(errno));
 		ret = -EIO;
-		goto err;
+		goto err_has_fd;
 	}
 
 	ret = 0;
 
-err:
-	free(fdt);
+err_has_fd:
 	close(fd);
+err_no_fd:
+	munmap(old_fdt, sbuf.st_size);
+	free(fdt);
 	return ret;
 }
 
@@ -648,11 +712,11 @@ static int fit_handle_file(struct image_tool_params *params)
 		*cmd = '\0';
 	} else if (params->datafile) {
 		/* dtc -I dts -O dtb -p 500 datafile > tmpfile */
-		snprintf(cmd, sizeof(cmd), "%s %s %s > %s",
+		snprintf(cmd, sizeof(cmd), "%s %s \"%s\" > \"%s\"",
 			 MKIMAGE_DTC, params->dtc, params->datafile, tmpfile);
 		debug("Trying to execute \"%s\"\n", cmd);
 	} else {
-		snprintf(cmd, sizeof(cmd), "cp %s %s",
+		snprintf(cmd, sizeof(cmd), "cp \"%s\" \"%s\"",
 			 params->imagefile, tmpfile);
 	}
 	if (*cmd && system(cmd) == -1) {
@@ -666,6 +730,13 @@ static int fit_handle_file(struct image_tool_params *params)
 	if (ret)
 		goto err_system;
 
+	/* Args "-E -p": move the data so it is external to the FIT, if requested */
+	if (params->external_data && params->external_offset) {
+		ret = fit_extract_data(params, tmpfile);
+		if (ret)
+			goto err_system;
+	}
+
 	/*
 	 * Set hashes for images in the blob. Unfortunately we may need more
 	 * space in either FDT, so keep trying until we succeed.
@@ -688,8 +759,8 @@ static int fit_handle_file(struct image_tool_params *params)
 		goto err_system;
 	}
 
-	/* Move the data so it is external to the FIT, if requested */
-	if (params->external_data) {
+	/* Args "-E": move the data so it is external to the FIT, if requested */
+	if (params->external_data && !params->external_offset) {
 		ret = fit_extract_data(params, tmpfile);
 		if (ret)
 			goto err_system;
diff --git a/tools/fit_info.c b/tools/fit_info.c
index 652abcd2bd..82a1a9f4c4 100644
--- a/tools/fit_info.c
+++ b/tools/fit_info.c
@@ -102,6 +102,7 @@ int main(int argc, char **argv)
 	printf("NAME: %s\n", fit_get_name(fit_blob, nodeoffset, NULL));
 	printf("LEN: %d\n", len);
 	printf("OFF: %d\n", (int)(nodep - fit_blob));
+	printf("END: %d\n", (int)(nodep + len - fit_blob));
 	(void) munmap((void *)fit_blob, fsbuf.st_size);
 
 	close(ffd);
diff --git a/tools/gen_ethaddr_crc.c b/tools/gen_ethaddr_crc.c
index fe9896dca9..8cf86f4835 100644
--- a/tools/gen_ethaddr_crc.c
+++ b/tools/gen_ethaddr_crc.c
@@ -6,6 +6,7 @@
  */
 
 #include <ctype.h>
+#include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/tools/genboardscfg.py b/tools/genboardscfg.py
index 2e871feaf4..2345a19798 100755
--- a/tools/genboardscfg.py
+++ b/tools/genboardscfg.py
@@ -124,7 +124,7 @@ class KconfigScanner:
         os.environ['srctree'] = os.getcwd()
         os.environ['UBOOTVERSION'] = 'dummy'
         os.environ['KCONFIG_OBJDIR'] = ''
-        self._conf = kconfiglib.Config()
+        self._conf = kconfiglib.Config(print_warnings=False)
 
     def __del__(self):
         """Delete a leftover temporary file before exit.
@@ -166,7 +166,10 @@ class KconfigScanner:
                 else:
                     f.write(line[colon + 1:])
 
-        self._conf.load_config(self._tmpfile)
+        warnings = self._conf.load_config(self._tmpfile)
+        if warnings:
+            for warning in warnings:
+                print '%s: %s' % (defconfig, warning)
 
         try_remove(self._tmpfile)
         self._tmpfile = None
diff --git a/tools/ifdtool.c b/tools/ifdtool.c
index 195b1533ab..e4c2f82c4a 100644
--- a/tools/ifdtool.c
+++ b/tools/ifdtool.c
@@ -12,13 +12,14 @@
 #include <assert.h>
 #include <fcntl.h>
 #include <getopt.h>
+#include <stdbool.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <libfdt.h>
+#include <linux/libfdt.h>
 #include "ifdtool.h"
 
 #undef DEBUG
diff --git a/tools/image-host.c b/tools/image-host.c
index 5e4d690714..e8e53baa77 100644
--- a/tools/image-host.c
+++ b/tools/image-host.c
@@ -153,6 +153,7 @@ static int fit_image_setup_sig(struct image_sign_info *info,
 {
 	const char *node_name;
 	char *algo_name;
+	const char *padding_name;
 
 	node_name = fit_get_name(fit, noffset, NULL);
 	if (fit_image_hash_get_algo(fit, noffset, &algo_name)) {
@@ -161,6 +162,9 @@ static int fit_image_setup_sig(struct image_sign_info *info,
 		return -1;
 	}
 
+	padding_name = fdt_getprop(fit, noffset, "padding", NULL);
+	if (!padding_name)
+		padding_name = "pkcs-1.5";
 	memset(info, '\0', sizeof(*info));
 	info->keydir = keydir;
 	info->keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
@@ -169,6 +173,7 @@ static int fit_image_setup_sig(struct image_sign_info *info,
 	info->name = algo_name;
 	info->checksum = image_get_checksum_algo(algo_name);
 	info->crypto = image_get_crypto_algo(algo_name);
+	info->padding = image_get_padding_algo(padding_name);
 	info->require_keys = require_keys;
 	info->engine_id = engine_id;
 	if (!info->checksum || !info->crypto) {
@@ -415,6 +420,7 @@ static int fit_config_get_hash_list(void *fit, int conf_noffset,
 	strlist_init(node_inc);
 	snprintf(name, sizeof(name), "%s/%s", FIT_CONFS_PATH, conf_name);
 	if (strlist_add(node_inc, "/") ||
+	    strlist_add(node_inc, FIT_CONFS_PATH) ||
 	    strlist_add(node_inc, name))
 		goto err_mem;
 
@@ -431,52 +437,61 @@ static int fit_config_get_hash_list(void *fit, int conf_noffset,
 		int noffset;
 		int image_noffset;
 		int hash_count;
+		int i, max_index;
 
-		image_noffset = fit_conf_get_prop_node(fit, conf_noffset,
-						       iname);
-		if (image_noffset < 0) {
-			printf("Failed to find image '%s' in  configuration '%s/%s'\n",
-			       iname, conf_name, sig_name);
-			if (allow_missing)
-				continue;
+		max_index = fdt_stringlist_count(fit, conf_noffset, iname);
 
-			return -ENOENT;
-		}
+		for (i = 0; i < max_index; i++) {
+			image_noffset =
+				fit_conf_get_prop_node_index(fit, conf_noffset,
+							     iname, i);
+			if (image_noffset < 0) {
+				if (i > 0)
+					break;
+
+				printf("Failed to find image '%s' in  configuration '%s/%s'\n",
+				       iname, conf_name, sig_name);
+				if (allow_missing)
+					continue;
+
+				return -ENOENT;
+			}
 
-		ret = fdt_get_path(fit, image_noffset, path, sizeof(path));
-		if (ret < 0)
-			goto err_path;
-		if (strlist_add(node_inc, path))
-			goto err_mem;
-
-		snprintf(name, sizeof(name), "%s/%s", FIT_CONFS_PATH,
-			 conf_name);
-
-		/* Add all this image's hashes */
-		hash_count = 0;
-		for (noffset = fdt_first_subnode(fit, image_noffset);
-		     noffset >= 0;
-		     noffset = fdt_next_subnode(fit, noffset)) {
-			const char *name = fit_get_name(fit, noffset, NULL);
-
-			if (strncmp(name, FIT_HASH_NODENAME,
-				    strlen(FIT_HASH_NODENAME)))
-				continue;
-			ret = fdt_get_path(fit, noffset, path, sizeof(path));
+			ret = fdt_get_path(fit, image_noffset, path, sizeof(path));
 			if (ret < 0)
 				goto err_path;
 			if (strlist_add(node_inc, path))
 				goto err_mem;
-			hash_count++;
-		}
 
-		if (!hash_count) {
-			printf("Failed to find any hash nodes in configuration '%s/%s' image '%s' - without these it is not possible to verify this image\n",
-			       conf_name, sig_name, iname);
-			return -ENOMSG;
+			snprintf(name, sizeof(name), "%s/%s", FIT_CONFS_PATH,
+				 conf_name);
+
+			/* Add all this image's hashes */
+			hash_count = 0;
+			for (noffset = fdt_first_subnode(fit, image_noffset);
+			     noffset >= 0;
+			     noffset = fdt_next_subnode(fit, noffset)) {
+				const char *name = fit_get_name(fit, noffset, NULL);
+
+				if (strncmp(name, FIT_HASH_NODENAME,
+					    strlen(FIT_HASH_NODENAME)))
+					continue;
+				ret = fdt_get_path(fit, noffset, path, sizeof(path));
+				if (ret < 0)
+					goto err_path;
+				if (strlist_add(node_inc, path))
+					goto err_mem;
+				hash_count++;
+			}
+
+			if (!hash_count) {
+				printf("Failed to find any hash nodes in configuration '%s/%s' image '%s' - without these it is not possible to verify this image\n",
+				       conf_name, sig_name, iname);
+				return -ENOMSG;
+			}
+
+			image_count++;
 		}
-
-		image_count++;
 	}
 
 	if (!image_count) {
@@ -513,7 +528,7 @@ static int fit_config_get_data(void *fit, int conf_noffset, int noffset,
 	int ret, len;
 
 	conf_name = fit_get_name(fit, conf_noffset, NULL);
-	sig_name = fit_get_name(fit, conf_noffset, NULL);
+	sig_name = fit_get_name(fit, noffset, NULL);
 	debug("%s: conf='%s', sig='%s'\n", __func__, conf_name, sig_name);
 
 	/* Get a list of nodes we want to hash */
@@ -600,10 +615,6 @@ static int fit_config_process_sig(const char *keydir, void *keydest,
 	if (ret) {
 		printf("Failed to sign '%s' signature node in '%s' conf node\n",
 		       node_name, conf_name);
-
-		/* We allow keys to be missing */
-		if (ret == -ENOENT)
-			return 0;
 		return -1;
 	}
 
@@ -725,7 +736,7 @@ int fit_add_verification_data(const char *keydir, void *keydest, void *fit,
 }
 
 #ifdef CONFIG_FIT_SIGNATURE
-int fit_check_sign(const void *fit, const void *key)
+int fit_check_sign(const void *fit, const void *key, int is_spl)
 {
 	int cfg_noffset;
 	int ret;
@@ -738,7 +749,7 @@ int fit_check_sign(const void *fit, const void *key)
 	ret = fit_config_verify(fit, cfg_noffset);
 	if (ret)
 		return ret;
-	ret = bootm_host_load_images(fit, cfg_noffset);
+	ret = bootm_host_load_images(fit, cfg_noffset, is_spl);
 
 	return ret;
 }
diff --git a/tools/imagetool.h b/tools/imagetool.h
index a8d505423b..e4765af490 100644
--- a/tools/imagetool.h
+++ b/tools/imagetool.h
@@ -12,6 +12,7 @@
 #include "os_support.h"
 #include <errno.h>
 #include <fcntl.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -77,6 +78,7 @@ struct image_tool_params {
 	bool quiet;		/* Don't output text in normal operation */
 	unsigned int external_offset;	/* Add padding to external data */
 	const char *engine_id;	/* Engine to use for signing */
+	char *extraparams;	/* Extra parameters for img creation (-X) */
 };
 
 /*
@@ -231,6 +233,7 @@ time_t imagetool_get_source_date(
 
 
 void pbl_load_uboot(int fd, struct image_tool_params *mparams);
+int rockchip_copy_image(int fd, struct image_tool_params *mparams);
 
 #define ___cat(a, b) a ## b
 #define __cat(a, b) ___cat(a, b)
diff --git a/tools/microcode-tool.py b/tools/microcode-tool.py
index 790c27e459..069d961d80 100755
--- a/tools/microcode-tool.py
+++ b/tools/microcode-tool.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2
 #
 # Copyright (c) 2014 Google, Inc
 #
diff --git a/tools/mips-relocs.c b/tools/mips-relocs.c
index 8be69d320f..27d47308e0 100644
--- a/tools/mips-relocs.c
+++ b/tools/mips-relocs.c
@@ -11,6 +11,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/mman.h>
diff --git a/tools/mkimage.c b/tools/mkimage.c
index 28ff35e670..10c1d33950 100644
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -95,7 +95,9 @@ static void usage(const char *msg)
 	fprintf(stderr,
 		"          -D => set all options for device tree compiler\n"
 		"          -f => input filename for FIT source\n"
-		"          -i => input filename for ramdisk file\n");
+		"          -i => input filename for ramdisk file\n"
+		"          -v => set FIT image version in decimal\n");
+
 #ifdef CONFIG_FIT_SIGNATURE
 	fprintf(stderr,
 		"Signing / verified boot options: [-E] [-k keydir] [-K dtb] [ -c <comment>] [-p addr] [-r] [-N engine]\n"
@@ -144,7 +146,7 @@ static void process_args(int argc, char **argv)
 	int opt;
 
 	while ((opt = getopt(argc, argv,
-			     "a:A:b:c:C:d:D:e:Ef:Fk:i:K:ln:N:p:O:rR:qsT:vVx")) != -1) {
+			     "a:A:b:c:C:d:D:e:Ef:Fk:i:K:ln:N:p:O:rR:qsT:v:VxX:")) != -1) {
 		switch (opt) {
 		case 'a':
 			params.addr = strtoull(optarg, &ptr, 16);
@@ -271,7 +273,12 @@ static void process_args(int argc, char **argv)
 			}
 			break;
 		case 'v':
-			params.vflag++;
+			params.vflag = strtoull(optarg, &ptr, 10);
+			if (*ptr) {
+				fprintf(stderr, "%s: invalid version length %s\n",
+					params.cmdname, optarg);
+				exit(EXIT_FAILURE);
+			}
 			break;
 		case 'V':
 			printf("mkimage version %s\n", PLAIN_VERSION);
@@ -279,6 +286,9 @@ static void process_args(int argc, char **argv)
 		case 'x':
 			params.xflag++;
 			break;
+		case 'X':
+			params.extraparams = optarg;
+			break;
 		default:
 			usage("Invalid option");
 		}
@@ -416,7 +426,8 @@ int main(int argc, char **argv)
 		exit (retval);
 	}
 
-	if ((params.type != IH_TYPE_MULTI) && (params.type != IH_TYPE_SCRIPT)) {
+	if ((params.type != IH_TYPE_MULTI) && (params.type != IH_TYPE_SCRIPT) &&
+	    (params.type != IH_TYPE_RKNAND)) {
 		dfd = open(params.datafile, O_RDONLY | O_BINARY);
 		if (dfd < 0) {
 			fprintf(stderr, "%s: Can't open %s: %s\n",
@@ -475,7 +486,7 @@ int main(int argc, char **argv)
 					}
 					size = cpu_to_uimage (sbuf.st_size);
 				} else {
-					size = 0;
+					size = IMAGE_PARAM_INVAL;
 				}
 
 				if (write(ifd, (char *)&size, sizeof(size)) != sizeof(size)) {
@@ -514,6 +525,15 @@ int main(int argc, char **argv)
 		} else if (params.type == IH_TYPE_PBLIMAGE) {
 			/* PBL has special Image format, implements its' own */
 			pbl_load_uboot(ifd, &params);
+		} else if ((params.type == IH_TYPE_RKSD) ||
+				(params.type == IH_TYPE_RKSPI) ||
+				(params.type == IH_TYPE_RKNAND)) {
+			/* Rockchip has special Image format */
+			int ret;
+
+			ret = rockchip_copy_image(ifd, &params);
+			if (ret)
+				return ret;
 		} else {
 			copy_file(ifd, params.datafile, pad_len);
 		}
@@ -646,6 +666,11 @@ copy_file (int ifd, const char *datafile, int pad)
 		exit (EXIT_FAILURE);
 	}
 
+	if (sbuf.st_size == 0) {
+		(void) close (dfd);
+		return;
+	}
+
 	ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, dfd, 0);
 	if (ptr == MAP_FAILED) {
 		fprintf (stderr, "%s: Can't read %s: %s\n",
diff --git a/tools/moveconfig.py b/tools/moveconfig.py
index 8a03850192..6f549a51c1 100755
--- a/tools/moveconfig.py
+++ b/tools/moveconfig.py
@@ -1877,10 +1877,10 @@ def main():
     if options.build_db:
         with open(CONFIG_DATABASE, 'w') as fd:
             for defconfig, configs in config_db.iteritems():
-                print >>fd, '%s' % defconfig
+                fd.write('%s\n' % defconfig)
                 for config in sorted(configs.keys()):
-                    print >>fd, '   %s=%s' % (config, configs[config])
-                print >>fd
+                    fd.write('   %s=%s\n' % (config, configs[config]))
+                fd.write('\n')
 
 if __name__ == '__main__':
     main()
diff --git a/tools/patman/README b/tools/patman/README
index e36857dede..8582ed6ba1 100644
--- a/tools/patman/README
+++ b/tools/patman/README
@@ -84,6 +84,18 @@ Aliases are recursive.
 The checkpatch.pl in the U-Boot tools/ subdirectory will be located and
 used. Failing that you can put it into your path or ~/bin/checkpatch.pl
 
+If you want to avoid sending patches to email addresses that are picked up
+by patman but are known to bounce you can add a [bounces] section to your
+.patman file. Unlike the [alias] section these are simple key: value pairs
+that are not recursive.
+
+>>>
+
+[bounces]
+gonefishing: Fred Bloggs <f.bloggs@napier.net>
+
+<<<
+
 
 If you want to change the defaults for patman's command-line arguments,
 you can add a [settings] section to your .patman file.  This can be used
diff --git a/tools/patman/patman.py b/tools/patman/patman.py
index 4b3bc78745..7647440be5 100755
--- a/tools/patman/patman.py
+++ b/tools/patman/patman.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2
 #
 # Copyright (c) 2011 The Chromium OS Authors.
 #
diff --git a/tools/patman/series.py b/tools/patman/series.py
index d3947a7c2a..73ee394486 100644
--- a/tools/patman/series.py
+++ b/tools/patman/series.py
@@ -10,6 +10,7 @@ import os
 
 import get_maintainer
 import gitutil
+import settings
 import terminal
 
 # Series-xxx tags that we understand
@@ -218,6 +219,7 @@ class Series(dict):
         Return:
             Filename of temp file created
         """
+        col = terminal.Color()
         # Look for commit tags (of the form 'xxx:' at the start of the subject)
         fname = '/tmp/patman.%d' % os.getpid()
         fd = open(fname, 'w')
@@ -233,6 +235,9 @@ class Series(dict):
                 cc += add_maintainers
             elif add_maintainers:
                 cc += get_maintainer.GetMaintainer(commit.patch)
+            for x in set(cc) & set(settings.bounces):
+                print(col.Color(col.YELLOW, 'Skipping "%s"' % x))
+            cc = set(cc) - set(settings.bounces)
             cc = [m.encode('utf-8') if type(m) != str else m for m in cc]
             all_ccs += cc
             print(commit.patch, ', '.join(set(cc)), file=fd)
diff --git a/tools/patman/settings.py b/tools/patman/settings.py
index 5f207f5ef1..92379b72e7 100644
--- a/tools/patman/settings.py
+++ b/tools/patman/settings.py
@@ -212,7 +212,12 @@ def CreatePatmanConfigFile(config_fname):
         print("Couldn't create patman config file\n")
         raise
 
-    print("[alias]\nme: %s <%s>" % (name, email), file=f)
+    print('''[alias]
+me: %s <%s>
+
+[bounces]
+nxp = Zhikang Zhang <zhikang.zhang@nxp.com>
+''' % (name, email), file=f)
     f.close();
 
 def _UpdateDefaults(parser, config):
@@ -269,6 +274,36 @@ def _ReadAliasFile(fname):
         if bad_line:
             print(bad_line)
 
+def _ReadBouncesFile(fname):
+    """Read in the bounces file if it exists
+
+    Args:
+        fname: Filename to read.
+    """
+    if os.path.exists(fname):
+        with open(fname) as fd:
+            for line in fd:
+                if line.startswith('#'):
+                    continue
+                bounces.add(line.strip())
+
+def GetItems(config, section):
+    """Get the items from a section of the config.
+
+    Args:
+        config: _ProjectConfigParser object containing settings
+        section: name of section to retrieve
+
+    Returns:
+        List of (name, value) tuples for the section
+    """
+    try:
+        return config.items(section)
+    except ConfigParser.NoSectionError as e:
+        return []
+    except:
+        raise
+
 def Setup(parser, project_name, config_fname=''):
     """Set up the settings module by reading config files.
 
@@ -290,13 +325,18 @@ def Setup(parser, project_name, config_fname=''):
 
     config.read(config_fname)
 
-    for name, value in config.items('alias'):
+    for name, value in GetItems(config, 'alias'):
         alias[name] = value.split(',')
 
+    _ReadBouncesFile('doc/bounces')
+    for name, value in GetItems(config, 'bounces'):
+        bounces.add(value)
+
     _UpdateDefaults(parser, config)
 
 # These are the aliases we understand, indexed by alias. Each member is a list.
 alias = {}
+bounces = set()
 
 if __name__ == "__main__":
     import doctest
diff --git a/tools/patman/test.py b/tools/patman/test.py
index 20dc9c1e0d..51145e8390 100644
--- a/tools/patman/test.py
+++ b/tools/patman/test.py
@@ -88,8 +88,7 @@ Signed-off-by: Simon Glass <sjg@chromium.org>
         os.remove(expname)
 
     def GetData(self, data_type):
-        data='''
-From 4924887af52713cabea78420eff03badea8f0035 Mon Sep 17 00:00:00 2001
+        data='''From 4924887af52713cabea78420eff03badea8f0035 Mon Sep 17 00:00:00 2001
 From: Simon Glass <sjg@chromium.org>
 Date: Thu, 7 Apr 2011 10:14:41 -0700
 Subject: [PATCH 1/4] Add microsecond boot time measurement
@@ -101,6 +100,7 @@ an available microsecond counter.
 %s
 ---
  README              |   11 ++++++++
+ MAINTAINERS         |    3 ++
  common/bootstage.c  |   50 ++++++++++++++++++++++++++++++++++++
  include/bootstage.h |   71 +++++++++++++++++++++++++++++++++++++++++++++++++++
  include/common.h    |    8 ++++++
@@ -130,19 +130,31 @@ index 6f3748d..f9e4e65 100644
  - Standalone program support:
  		CONFIG_STANDALONE_LOAD_ADDR
 
+diff --git a/MAINTAINERS b/MAINTAINERS
+index b167b028ec..beb7dc634f 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -474,3 +474,8 @@ S:	Maintained
+ T:	git git://git.denx.de/u-boot.git
+ F:	*
+ F:	*/
++
++BOOTSTAGE
++M:	Simon Glass <sjg@chromium.org>
++L:	u-boot@lists.denx.de
++F:	common/bootstage.c
 diff --git a/common/bootstage.c b/common/bootstage.c
 new file mode 100644
 index 0000000..2234c87
 --- /dev/null
 +++ b/common/bootstage.c
-@@ -0,0 +1,39 @@
+@@ -0,0 +1,37 @@
 +/*
 + * Copyright (c) 2011, Google Inc. All rights reserved.
 + *
 + * SPDX-License-Identifier:	GPL-2.0+
 + */
 +
-+
 +/*
 + * This module records the progress of boot and arbitrary commands, and
 + * permits accurate timestamping of each. The records can optionally be
@@ -151,26 +163,25 @@ index 0000000..2234c87
 +
 +#include <common.h>
 +
-+
 +struct bootstage_record {
-+	uint32_t time_us;
++	u32 time_us;
 +	const char *name;
 +};
 +
 +static struct bootstage_record record[BOOTSTAGE_COUNT];
 +
-+uint32_t bootstage_mark(enum bootstage_id id, const char *name)
++u32 bootstage_mark(enum bootstage_id id, const char *name)
 +{
 +	struct bootstage_record *rec = &record[id];
 +
 +	/* Only record the first event for each */
 +%sif (!rec->name) {
-+		rec->time_us = (uint32_t)timer_get_us();
++		rec->time_us = (u32)timer_get_us();
 +		rec->name = name;
 +	}
 +	if (!rec->name &&
 +	%ssomething_else) {
-+		rec->time_us = (uint32_t)timer_get_us();
++		rec->time_us = (u32)timer_get_us();
 +		rec->name = name;
 +	}
 +%sreturn rec->time_us;
@@ -210,7 +221,7 @@ index 0000000..2234c87
         self.assertEqual(result.errors, 0)
         self.assertEqual(result.warnings, 0)
         self.assertEqual(result.checks, 0)
-        self.assertEqual(result.lines, 56)
+        self.assertEqual(result.lines, 62)
         os.remove(inf)
 
     def testNoSignoff(self):
@@ -221,18 +232,18 @@ index 0000000..2234c87
         self.assertEqual(result.errors, 1)
         self.assertEqual(result.warnings, 0)
         self.assertEqual(result.checks, 0)
-        self.assertEqual(result.lines, 56)
+        self.assertEqual(result.lines, 62)
         os.remove(inf)
 
     def testSpaces(self):
         inf = self.SetupData('spaces')
         result = checkpatch.CheckPatch(inf)
         self.assertEqual(result.ok, False)
-        self.assertEqual(len(result.problems), 2)
+        self.assertEqual(len(result.problems), 3)
         self.assertEqual(result.errors, 0)
-        self.assertEqual(result.warnings, 2)
+        self.assertEqual(result.warnings, 3)
         self.assertEqual(result.checks, 0)
-        self.assertEqual(result.lines, 56)
+        self.assertEqual(result.lines, 62)
         os.remove(inf)
 
     def testIndent(self):
@@ -243,7 +254,7 @@ index 0000000..2234c87
         self.assertEqual(result.errors, 0)
         self.assertEqual(result.warnings, 0)
         self.assertEqual(result.checks, 1)
-        self.assertEqual(result.lines, 56)
+        self.assertEqual(result.lines, 62)
         os.remove(inf)
 
 
diff --git a/tools/rkcommon.c b/tools/rkcommon.c
index 04e8272fd5..b61f609582 100644
--- a/tools/rkcommon.c
+++ b/tools/rkcommon.c
@@ -11,14 +11,67 @@
 
 #include "imagetool.h"
 #include <image.h>
+#include <u-boot/sha256.h>
 #include <rc4.h>
 #include "mkimage.h"
 #include "rkcommon.h"
 
-#define DIV_ROUND_UP(n, d)	(((n) + (d) - 1) / (d))
+enum {
+	RK_MAGIC		= 0x0ff0aa55,
+	RK_MAGIC_V2		= 0x534E4B52, // RKNS
+};
 
 enum {
-	RK_SIGNATURE		= 0x0ff0aa55,
+	RK_HEADER_V1	= 1,
+	RK_HEADER_V2	= 2,
+};
+
+enum hash_type {
+	HASH_NONE	= 0,
+	HASH_SHA256	= 1,
+	HASH_SHA512	= 2,
+};
+
+/**
+ * struct image_entry
+ *
+ * @size_and_off:	[31:16]image size;[15:0]image offset
+ * @address:	default as 0xFFFFFFFF
+ * @flag:	no use
+ * @counter:	no use
+ * @hash:	hash of image
+ *
+ */
+struct image_entry {
+	uint32_t size_and_off;
+	uint32_t address;
+	uint32_t flag;
+	uint32_t counter;
+	uint8_t reserved[8];
+	uint8_t hash[64];
+};
+
+/**
+ * struct header0_info_v2 - from rk35 on boot rom using the new header block
+ *
+ * This is stored at SD card block 64 (where each block is 512 bytes)
+ *
+ * @magic:	Magic (must be RK_MAGIC_V2)
+ * @size_and_nimage:	[31:16]number of images;[15:0]
+ *			offset to hash field of header(unit as 4Byte)
+ * @boot_flag:	[3:0]hash type(0:none,1:sha256,2:sha512)
+ * @signature:	hash or signature for header info
+ *
+ */
+struct header0_info_v2 {
+	uint32_t magic;
+	uint8_t reserved[4];
+	uint32_t size_and_nimage;
+	uint32_t boot_flag;
+	uint8_t reserved1[104];
+	struct image_entry images[4];
+	uint8_t reserved2[1064];
+	uint8_t hash[512];
 };
 
 /**
@@ -27,14 +80,14 @@ enum {
  * This is stored at SD card block 64 (where each block is 512 bytes, or at
  * the start of SPI flash. It is encoded with RC4.
  *
- * @signature:		Signature (must be RKSD_SIGNATURE)
+ * @magic:		Magic (must be RK_MAGIC)
  * @disable_rc4:	0 to use rc4 for boot image,  1 to use plain binary
  * @init_offset:	Offset in blocks of the SPL code from this header
  *			block. E.g. 4 means 2KB after the start of this header.
  * Other fields are not used by U-Boot
  */
 struct header0_info {
-	uint32_t signature;
+	uint32_t magic;
 	uint8_t reserved[4];
 	uint32_t disable_rc4;
 	uint16_t init_offset;
@@ -45,7 +98,7 @@ struct header0_info {
 };
 
 /**
- * struct header1_info
+ * struct header1 info
  */
 struct header1_info {
 	uint32_t magic;
@@ -58,30 +111,55 @@ struct header1_info {
  * @spl_hdr:		Boot ROM requires a 4-bytes spl header
  * @spl_size:		Spl size(include extra 4-bytes spl header)
  * @spl_rc4:		RC4 encode the SPL binary (same key as header)
- * @spl_boot0:          A new-style (ARM_SOC_BOOT0_HOOK) image that should
- *                      have the boot magic (e.g. 'RK33') written to its first
- *                      word.
+ * @header_ver:		header block version
  */
-
 struct spl_info {
 	const char *imagename;
 	const char *spl_hdr;
 	const uint32_t spl_size;
 	const bool spl_rc4;
-	const bool spl_boot0;
+	const uint32_t header_ver;
 };
 
 static struct spl_info spl_infos[] = {
-	{ "rk3036", "RK30", 0x1000, false, false },
-	{ "rk3188", "RK31", 0x8000 - 0x800, true, false },
-	{ "rk322x", "RK32", 0x8000 - 0x1000, false, false },
-	{ "rk3288", "RK32", 0x8000, false, false },
-	{ "rk3328", "RK32", 0x8000 - 0x1000, false, false },
-	{ "rk3368", "RK33", 0x8000 - 0x1000, false, true },
-	{ "rk3399", "RK33", 0x30000 - 0x2000, false, true },
-	{ "rv1108", "RK11", 0x1800, false, false},
+	{ "rk3036", "RK30", 0x1000, false, RK_HEADER_V1 },
+	{ "rk3066", "RK30", 0x8000, true, RK_HEADER_V1 },
+	{ "rk3128", "RK31", 0x2000 - 0x800, false, RK_HEADER_V1 },
+	{ "px3se", "RK31", 0x2000 - 0x800, false, RK_HEADER_V1 },
+	{ "rk3188", "RK31", 0x8000 - 0x800, true, RK_HEADER_V1 },
+	{ "rk322x", "RK32", 0x8000 - 0x1000, false, RK_HEADER_V1 },
+	{ "rk3288", "RK32", 0x8000, false, RK_HEADER_V1 },
+	{ "rk3308", "RK33", 0x40000 - 0x1000, false, RK_HEADER_V1 },
+	{ "rk3328", "RK32", 0x8000 - 0x800, false, RK_HEADER_V1 },
+	{ "rk3368", "RK33", 0x8000 - 0x1000, false, RK_HEADER_V1 },
+	{ "rk3399", "RK33", 0x30000 - 0x2000, false, RK_HEADER_V1 },
+	{ "rk3326", "RK33", 0x4000 - 0x1000, false, RK_HEADER_V1 },
+	{ "px30", "RK33", 0x4000 - 0x1000, false, RK_HEADER_V1 },
+	{ "rv1108", "RK11", 0x1800, false, RK_HEADER_V1 },
+	{ "rv1126", "110B", 0x10000 - 0x1000, false, RK_HEADER_V1 },
+	{ "rk1808", "RK18", 0x200000 - 0x2000, false, RK_HEADER_V1 },
+	{ "rk3568", "RK35", 0x10000 - 0x1000, false, RK_HEADER_V2 },
+	{ "rk3588", "RK35", 0x100000 - 0x1000, false, RK_HEADER_V2 },
 };
 
+/**
+ * struct spl_params - spl params parsed in check_params()
+ *
+ * @init_file:		Init data file path
+ * @init_size:		Aligned size of init data in bytes
+ * @boot_file:		Boot data file path
+ * @boot_size:		Aligned size of boot data in bytes
+ */
+
+struct spl_params {
+	char *init_file;
+	uint32_t init_size;
+	char *boot_file;
+	uint32_t boot_size;
+};
+
+static struct spl_params spl_params = { 0 };
+
 static unsigned char rc4_key[16] = {
 	124, 78, 3, 4, 85, 5, 9, 7,
 	45, 44, 123, 56, 23, 13, 23, 17
@@ -101,13 +179,26 @@ static struct spl_info *rkcommon_get_spl_info(char *imagename)
 	return NULL;
 }
 
+static int rkcommon_get_aligned_size(struct image_tool_params *params,
+				     const char *fname)
+{
+	int size;
+
+	size = imagetool_get_filesize(params, fname);
+	if (size < 0)
+		return -1;
+
+	/*
+	 * Pad to a 2KB alignment, as required for init/boot size by the ROM
+	 * (see https://lists.denx.de/pipermail/u-boot/2017-May/293268.html)
+	 */
+	return ROUND(size, RK_SIZE_ALIGN);
+}
+
 int rkcommon_check_params(struct image_tool_params *params)
 {
 	int i;
 
-	if (rkcommon_get_spl_info(params->imagename) != NULL)
-		return EXIT_SUCCESS;
-
 	/*
 	 * If this is a operation (list or extract), the don't require
 	 * imagename to be set.
@@ -115,6 +206,40 @@ int rkcommon_check_params(struct image_tool_params *params)
 	if (params->lflag || params->iflag)
 		return EXIT_SUCCESS;
 
+	if (!rkcommon_get_spl_info(params->imagename))
+		goto err_spl_info;
+
+	spl_params.init_file = params->datafile;
+
+	spl_params.boot_file = strchr(spl_params.init_file, ':');
+	if (spl_params.boot_file) {
+		*spl_params.boot_file = '\0';
+		spl_params.boot_file += 1;
+	}
+
+	spl_params.init_size =
+		rkcommon_get_aligned_size(params, spl_params.init_file);
+	if (spl_params.init_size < 0)
+		return EXIT_FAILURE;
+
+	/* Boot file is optional, and only for back-to-bootrom functionality. */
+	if (spl_params.boot_file) {
+		spl_params.boot_size =
+			rkcommon_get_aligned_size(params, spl_params.boot_file);
+		if (spl_params.boot_size < 0)
+			return EXIT_FAILURE;
+	}
+
+	if (spl_params.init_size > rkcommon_get_spl_size(params)) {
+		fprintf(stderr,
+			"Error: SPL image is too large (size %#x than %#x)\n",
+			spl_params.init_size, rkcommon_get_spl_size(params));
+		return EXIT_FAILURE;
+	}
+
+	return EXIT_SUCCESS;
+
+err_spl_info:
 	fprintf(stderr, "ERROR: imagename (%s) is not supported!\n",
 		params->imagename ? params->imagename : "NULL");
 
@@ -136,7 +261,6 @@ const char *rkcommon_get_spl_hdr(struct image_tool_params *params)
 	return info->spl_hdr;
 }
 
-
 int rkcommon_get_spl_size(struct image_tool_params *params)
 {
 	struct spl_info *info = rkcommon_get_spl_info(params->imagename);
@@ -157,35 +281,35 @@ bool rkcommon_need_rc4_spl(struct image_tool_params *params)
 	return info->spl_rc4;
 }
 
-bool rkcommon_spl_is_boot0(struct image_tool_params *params)
+bool rkcommon_is_header_v2(struct image_tool_params *params)
 {
 	struct spl_info *info = rkcommon_get_spl_info(params->imagename);
 
 	/*
 	 * info would not be NULL, because of we checked params before.
 	 */
-	return info->spl_boot0;
+	return (info->header_ver == RK_HEADER_V2);
+}
+
+static void do_sha256_hash(uint8_t *buf, uint32_t size, uint8_t *out)
+{
+	sha256_context ctx;
+
+	sha256_starts(&ctx);
+	sha256_update(&ctx, buf, size);
+	sha256_finish(&ctx, out);
 }
 
-static void rkcommon_set_header0(void *buf, uint file_size,
-				 struct image_tool_params *params)
+static void rkcommon_set_header0(void *buf, struct image_tool_params *params)
 {
 	struct header0_info *hdr = buf;
 
 	memset(buf, '\0', RK_INIT_OFFSET * RK_BLK_SIZE);
-	hdr->signature = RK_SIGNATURE;
+	hdr->magic = RK_MAGIC;
 	hdr->disable_rc4 = !rkcommon_need_rc4_spl(params);
 	hdr->init_offset = RK_INIT_OFFSET;
+	hdr->init_size = spl_params.init_size / RK_BLK_SIZE;
 
-	hdr->init_size = DIV_ROUND_UP(file_size, RK_BLK_SIZE);
-	/*
-	 * The init_size has to be a multiple of 4 blocks (i.e. of 2K)
-	 * or the BootROM will not boot the image.
-	 *
-	 * Note: To verify that this is not a legacy constraint, we
-	 *       rechecked this against the RK3399 BootROM.
-	 */
-	hdr->init_size = ROUND(hdr->init_size, 4);
 	/*
 	 * init_boot_size needs to be set, as it is read by the BootROM
 	 * to determine the size of the next-stage bootloader (e.g. U-Boot
@@ -194,32 +318,74 @@ static void rkcommon_set_header0(void *buf, uint file_size,
 	 * see https://lists.denx.de/pipermail/u-boot/2017-May/293267.html
 	 * for a more detailed explanation by Andy Yan
 	 */
-	hdr->init_boot_size = hdr->init_size + RK_MAX_BOOT_SIZE / RK_BLK_SIZE;
+	if (spl_params.boot_file)
+		hdr->init_boot_size =
+			hdr->init_size + spl_params.boot_size / RK_BLK_SIZE;
+	else
+		hdr->init_boot_size =
+			hdr->init_size + RK_MAX_BOOT_SIZE / RK_BLK_SIZE;
 
 	rc4_encode(buf, RK_BLK_SIZE, rc4_key);
 }
 
-int rkcommon_set_header(void *buf, uint file_size,
-			struct image_tool_params *params)
+static void rkcommon_set_header0_v2(void *buf, struct image_tool_params *params)
 {
-	struct header1_info *hdr = buf + RK_SPL_HDR_START;
+	struct header0_info_v2 *hdr = buf;
+	uint32_t sector_offset, image_sector_count;
+	uint32_t image_size_array[2];
+	uint8_t *image_ptr = NULL;
+	int i;
+
+	printf("Image Type:   Rockchip %s boot image\n", rkcommon_get_spl_hdr(params));
+	memset(buf, '\0', RK_INIT_OFFSET * RK_BLK_SIZE);
+	hdr->magic   = cpu_to_le32(RK_MAGIC_V2);
+	hdr->size_and_nimage = cpu_to_le32((2 << 16) + 384);
+	hdr->boot_flag = cpu_to_le32(HASH_SHA256);
+	sector_offset = 4;
+	image_size_array[0] = spl_params.init_size;
+	image_size_array[1] = spl_params.boot_size;
+
+	for (i = 0; i < 2; i++) {
+		image_sector_count = image_size_array[i] / RK_BLK_SIZE;
+		hdr->images[i].size_and_off = cpu_to_le32((image_sector_count << 16) + sector_offset);
+		hdr->images[i].address = 0xFFFFFFFF;
+		hdr->images[i].counter = cpu_to_le32(i + 1);
+		image_ptr = buf + sector_offset * RK_BLK_SIZE;
+		do_sha256_hash(image_ptr, image_size_array[i], hdr->images[i].hash);
+		sector_offset = sector_offset + image_sector_count;
+	}
 
-	if (file_size > rkcommon_get_spl_size(params))
-		return -ENOSPC;
+	do_sha256_hash(buf, (void *)hdr->hash - buf, hdr->hash);
+}
 
-	rkcommon_set_header0(buf, file_size, params);
+void rkcommon_set_header(void *buf,  struct stat *sbuf,  int ifd,
+			 struct image_tool_params *params)
+{
+	struct header1_info *hdr = buf + RK_SPL_HDR_START;
 
-	/* Set up the SPL name (i.e. copy spl_hdr over) */
-	memcpy(&hdr->magic, rkcommon_get_spl_hdr(params), RK_SPL_HDR_SIZE);
+	if (rkcommon_is_header_v2(params)) {
+		rkcommon_set_header0_v2(buf, params);
+	} else {
+		rkcommon_set_header0(buf, params);
 
-	if (rkcommon_need_rc4_spl(params))
-		rkcommon_rc4_encode_spl(buf, RK_SPL_HDR_START,
-					params->file_size - RK_SPL_HDR_START);
+		/* Set up the SPL name (i.e. copy spl_hdr over) */
+		if (memcmp(&hdr->magic, "RSAK", 4))
+			memcpy(&hdr->magic, rkcommon_get_spl_hdr(params), RK_SPL_HDR_SIZE);
 
-	return 0;
+		if (rkcommon_need_rc4_spl(params))
+			rkcommon_rc4_encode_spl(buf, RK_SPL_HDR_START,
+						spl_params.init_size);
+
+		if (spl_params.boot_file) {
+			if (rkcommon_need_rc4_spl(params))
+				rkcommon_rc4_encode_spl(buf + RK_SPL_HDR_START,
+							spl_params.init_size,
+							spl_params.boot_size);
+		}
+	}
 }
 
-static inline unsigned rkcommon_offset_to_spi(unsigned offset)
+static inline unsigned int rkcommon_offset_to_spi(unsigned int offset)
 {
 	/*
 	 * While SD/MMC images use a flat addressing, SPI images are padded
@@ -231,7 +397,7 @@ static inline unsigned rkcommon_offset_to_spi(unsigned offset)
 static int rkcommon_parse_header(const void *buf, struct header0_info *header0,
 				 struct spl_info **spl_info)
 {
-	unsigned hdr1_offset;
+	unsigned int hdr1_offset;
 	struct header1_info *hdr1_sdmmc, *hdr1_spi;
 	int i;
 
@@ -245,7 +411,7 @@ static int rkcommon_parse_header(const void *buf, struct header0_info *header0,
 	memcpy((void *)header0, buf, sizeof(struct header0_info));
 	rc4_encode((void *)header0, sizeof(struct header0_info), rc4_key);
 
-	if (header0->signature != RK_SIGNATURE)
+	if (header0->magic != RK_MAGIC)
 		return -EPROTO;
 
 	/* We don't support RC4 encoded image payloads here, yet... */
@@ -272,6 +438,16 @@ static int rkcommon_parse_header(const void *buf, struct header0_info *header0,
 	return -1;
 }
 
+static int rkcommon_parse_header_v2(const void *buf, struct header0_info_v2 *header)
+{
+	memcpy((void *)header, buf, sizeof(struct header0_info_v2));
+
+	if (le32_to_cpu(header->magic) != RK_MAGIC_V2)
+		return -EPROTO;
+
+	return 0;
+}
+
 int rkcommon_verify_header(unsigned char *buf, int size,
 			   struct image_tool_params *params)
 {
@@ -279,6 +455,10 @@ int rkcommon_verify_header(unsigned char *buf, int size,
 	struct spl_info *img_spl_info, *spl_info;
 	int ret;
 
+	/* spl_hdr is abandon on header_v2 */
+	if ((*(uint32_t *)buf) == RK_MAGIC_V2)
+		return 0;
+
 	ret = rkcommon_parse_header(buf, &header0, &img_spl_info);
 
 	/* If this is the (unimplemented) RC4 case, then rewrite the result */
@@ -306,27 +486,47 @@ int rkcommon_verify_header(unsigned char *buf, int size,
 void rkcommon_print_header(const void *buf)
 {
 	struct header0_info header0;
+	struct header0_info_v2 header0_v2;
 	struct spl_info *spl_info;
 	uint8_t image_type;
-	int ret;
+	int ret, boot_size, init_size;
 
-	ret = rkcommon_parse_header(buf, &header0, &spl_info);
+	if ((*(uint32_t *)buf) == RK_MAGIC_V2) {
+		ret = rkcommon_parse_header_v2(buf, &header0_v2);
 
-	/* If this is the (unimplemented) RC4 case, then fail silently */
-	if (ret == -ENOSYS)
-		return;
+		if (ret < 0) {
+			fprintf(stderr, "Error: image verification failed\n");
+			return;
+		}
+
+		init_size = header0_v2.images[0].size_and_off >> 16;
+		init_size = init_size * RK_BLK_SIZE;
+		boot_size = header0_v2.images[1].size_and_off >> 16;
+		boot_size = boot_size * RK_BLK_SIZE;
+	} else {
+		ret = rkcommon_parse_header(buf, &header0, &spl_info);
+
+		/* If this is the (unimplemented) RC4 case, then fail silently */
+		if (ret == -ENOSYS)
+			return;
+
+		if (ret < 0) {
+			fprintf(stderr, "Error: image verification failed\n");
+			return;
+		}
 
-	if (ret < 0) {
-		fprintf(stderr, "Error: image verification failed\n");
-		return;
+		image_type = ret;
+		init_size = header0.init_size * RK_BLK_SIZE;
+		boot_size = header0.init_boot_size * RK_BLK_SIZE - init_size;
+		printf("Image Type:   Rockchip %s (%s) boot image\n",
+		       spl_info->spl_hdr,
+		       (image_type == IH_TYPE_RKSD) ? "SD/MMC" : "SPI");
 	}
 
-	image_type = ret;
+	printf("Init Data Size: %d bytes\n", init_size);
 
-	printf("Image Type:   Rockchip %s (%s) boot image\n",
-	       spl_info->spl_hdr,
-	       (image_type == IH_TYPE_RKSD) ? "SD/MMC" : "SPI");
-	printf("Data Size:    %d bytes\n", header0.init_size * RK_BLK_SIZE);
+	if (boot_size != RK_MAX_BOOT_SIZE)
+		printf("Boot Data Size: %d bytes\n", boot_size);
 }
 
 void rkcommon_rc4_encode_spl(void *buf, unsigned int offset, unsigned int size)
@@ -343,12 +543,8 @@ void rkcommon_rc4_encode_spl(void *buf, unsigned int offset, unsigned int size)
 }
 
 int rkcommon_vrec_header(struct image_tool_params *params,
-			 struct image_type_params *tparams,
-			 unsigned int alignment)
+			 struct image_type_params *tparams)
 {
-	unsigned int  unpadded_size;
-	unsigned int  padded_size;
-
 	/*
 	 * The SPL image looks as follows:
 	 *
@@ -365,31 +561,127 @@ int rkcommon_vrec_header(struct image_tool_params *params,
 	 * have the first 4 bytes reserved for the spl_name).  Reserving
 	 * these 4 bytes is done using the BOOT0_HOOK infrastructure.
 	 *
-	 * Depending on this, the header is either 0x800 (if this is a
-	 * 'boot0'-style payload, which has reserved 4 bytes at the
-	 * beginning for the 'spl_name' and expects us to overwrite
-	 * its first 4 bytes) or 0x804 bytes in length.
+	 * The header is always at 0x800 (as we now use a payload
+	 * prepadded using the boot0 hook for all targets): the first
+	 * 4 bytes of these images can safely be overwritten using the
+	 * boot magic.
 	 */
-	if (rkcommon_spl_is_boot0(params))
-		tparams->header_size = RK_SPL_HDR_START;
-	else
-		tparams->header_size = RK_SPL_HDR_START + 4;
+	tparams->header_size = RK_SPL_HDR_START;
 
 	/* Allocate, clear and install the header */
 	tparams->hdr = malloc(tparams->header_size);
-	if (!tparams->hdr)
-		return -ENOMEM;
+	if (!tparams->hdr) {
+		fprintf(stderr, "%s: Can't alloc header: %s\n",
+			params->cmdname, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
 	memset(tparams->hdr, 0, tparams->header_size);
 
 	/*
-	 * If someone passed in 0 for the alignment, we'd better handle
-	 * it correctly...
+	 * We need to store the original file-size (i.e. before padding), as
+	 * imagetool does not set this during its adjustment of file_size.
 	 */
-	if (!alignment)
-		alignment = 1;
+	params->orig_file_size = tparams->header_size +
+		spl_params.init_size + spl_params.boot_size;
+
+	params->file_size = ROUND(params->orig_file_size, RK_SIZE_ALIGN);
+
+	/* Ignoring pad len, since we are using our own copy_image() */
+	return 0;
+}
 
-	unpadded_size = tparams->header_size + params->file_size;
-	padded_size = ROUND(unpadded_size, alignment);
+static int pad_file(struct image_tool_params *params, int ifd, int pad)
+{
+	uint8_t zeros[4096];
+
+	memset(zeros, 0, sizeof(zeros));
+
+	while (pad > 0) {
+		int todo = sizeof(zeros);
+
+		if (todo > pad)
+			todo = pad;
+		if (write(ifd, (char *)&zeros, todo) != todo) {
+			fprintf(stderr, "%s: Write error on %s: %s\n",
+				params->cmdname, params->imagefile,
+				strerror(errno));
+			return -1;
+		}
+		pad -= todo;
+	}
+
+	return 0;
+}
+
+static int copy_file(struct image_tool_params *params, int ifd,
+		     const char *file, int padded_size)
+{
+	int dfd;
+	struct stat sbuf;
+	unsigned char *ptr;
+	int size;
+
+	if (params->vflag)
+		fprintf(stderr, "Adding Image %s\n", file);
+
+	dfd = open(file, O_RDONLY | O_BINARY);
+	if (dfd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			params->cmdname, file, strerror(errno));
+		return -1;
+	}
+
+	if (fstat(dfd, &sbuf) < 0) {
+		fprintf(stderr, "%s: Can't stat %s: %s\n",
+			params->cmdname, file, strerror(errno));
+		goto err_close;
+	}
+
+	if (params->vflag)
+		fprintf(stderr, "Size %u(pad to %u)\n",
+			(int)sbuf.st_size, padded_size);
+
+	ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, dfd, 0);
+	if (ptr == MAP_FAILED) {
+		fprintf(stderr, "%s: Can't read %s: %s\n",
+			params->cmdname, file, strerror(errno));
+		goto err_munmap;
+	}
+
+	size = sbuf.st_size;
+	if (write(ifd, ptr, size) != size) {
+		fprintf(stderr, "%s: Write error on %s: %s\n",
+			params->cmdname, params->imagefile, strerror(errno));
+		goto err_munmap;
+	}
+
+	munmap((void *)ptr, sbuf.st_size);
+	close(dfd);
+	return pad_file(params, ifd, padded_size - size);
+
+err_munmap:
+	munmap((void *)ptr, sbuf.st_size);
+err_close:
+	close(dfd);
+	return -1;
+}
+
+int rockchip_copy_image(int ifd, struct image_tool_params *params)
+{
+	int ret;
+
+	ret = copy_file(params, ifd, spl_params.init_file,
+			spl_params.init_size);
+	if (ret)
+		return ret;
+
+	if (spl_params.boot_file) {
+		ret = copy_file(params, ifd, spl_params.boot_file,
+				spl_params.boot_size);
+		if (ret)
+			return ret;
+	}
 
-	return padded_size - unpadded_size;
+	return pad_file(params, ifd,
+			params->file_size - params->orig_file_size);
 }
diff --git a/tools/rkcommon.h b/tools/rkcommon.h
index 8790f1ceab..97019c01b2 100644
--- a/tools/rkcommon.h
+++ b/tools/rkcommon.h
@@ -10,13 +10,11 @@
 
 enum {
 	RK_BLK_SIZE		= 512,
-	RK_INIT_SIZE_ALIGN      = 2048,
+	RK_SIZE_ALIGN		= 2048,
 	RK_INIT_OFFSET		= 4,
 	RK_MAX_BOOT_SIZE	= 512 << 10,
 	RK_SPL_HDR_START	= RK_INIT_OFFSET * RK_BLK_SIZE,
 	RK_SPL_HDR_SIZE		= 4,
-	RK_SPL_START		= RK_SPL_HDR_START + RK_SPL_HDR_SIZE,
-	RK_IMAGE_HEADER_LEN	= RK_SPL_START,
 };
 
 /**
@@ -50,11 +48,9 @@ int rkcommon_get_spl_size(struct image_tool_params *params);
  * This sets up a 2KB header which can be interpreted by the Rockchip boot ROM.
  *
  * @buf:	Pointer to header place (must be at least 2KB in size)
- * @file_size:	Size of the file we want the boot ROM to load, in bytes
- * @return 0 if OK, -ENOSPC if too large
  */
-int rkcommon_set_header(void *buf, uint file_size,
-			struct image_tool_params *params);
+void rkcommon_set_header(void *buf,  struct stat *sbuf,  int ifd,
+			 struct image_tool_params *params);
 
 /**
  * rkcommon_verify_header() - verify the header for a Rockchip boot image
@@ -103,14 +99,10 @@ void rkcommon_rc4_encode_spl(void *buf, unsigned int offset, unsigned int size);
  * @params:     Pointer to the tool params structure
  * @tparams:    Pointer tot the image type structure (for setting
  *              the header and header_size)
- * @alignment:  Alignment (a power of two) that the image should be
- *              padded to (e.g. 512 if we want to align with SD/MMC
- *              blocksizes or 2048 for the SPI format)
  *
- * @return bytes of padding required/added (does not include the header_size)
+ * @return 0 (always)
  */
 int rkcommon_vrec_header(struct image_tool_params *params,
-			 struct image_type_params *tparams,
-			 unsigned int alignment);
+			 struct image_type_params *tparams);
 
 #endif
diff --git a/tools/rkmux.py b/tools/rkmux.py
index 39173359ca..11c192a073 100755
--- a/tools/rkmux.py
+++ b/tools/rkmux.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python2
 
 # Script to create enums from datasheet register tables
 #
diff --git a/tools/rksd.c b/tools/rksd.c
index c56153d2ca..25119b22c6 100644
--- a/tools/rksd.c
+++ b/tools/rksd.c
@@ -13,27 +13,6 @@
 #include "mkimage.h"
 #include "rkcommon.h"
 
-static void rksd_set_header(void *buf,  struct stat *sbuf,  int ifd,
-			    struct image_tool_params *params)
-{
-	unsigned int size;
-	int ret;
-
-	/*
-	 * We need to calculate this using 'RK_SPL_HDR_START' and not using
-	 * 'tparams->header_size', as the additional byte inserted when
-	 * 'is_boot0' is true counts towards the payload (and not towards the
-	 * header).
-	 */
-	size = params->file_size - RK_SPL_HDR_START;
-	ret = rkcommon_set_header(buf, size, params);
-	if (ret) {
-		/* TODO(sjg@chromium.org): This method should return an error */
-		printf("Warning: SPL image is too large (size %#x) and will "
-		       "not boot\n", size);
-	}
-}
-
 static int rksd_check_image_type(uint8_t type)
 {
 	if (type == IH_TYPE_RKSD)
@@ -42,16 +21,6 @@ static int rksd_check_image_type(uint8_t type)
 		return EXIT_FAILURE;
 }
 
-static int rksd_vrec_header(struct image_tool_params *params,
-			    struct image_type_params *tparams)
-{
-	/*
-	 * Pad to a 2KB alignment, as required for init_size by the ROM
-	 * (see https://lists.denx.de/pipermail/u-boot/2017-May/293268.html)
-	 */
-	return rkcommon_vrec_header(params, tparams, RK_INIT_SIZE_ALIGN);
-}
-
 /*
  * rk_sd parameters
  */
@@ -63,9 +32,9 @@ U_BOOT_IMAGE_TYPE(
 	rkcommon_check_params,
 	rkcommon_verify_header,
 	rkcommon_print_header,
-	rksd_set_header,
+	rkcommon_set_header,
 	NULL,
 	rksd_check_image_type,
 	NULL,
-	rksd_vrec_header
+	rkcommon_vrec_header
 );
diff --git a/tools/rkspi.c b/tools/rkspi.c
index 4332ce1765..15e283851e 100644
--- a/tools/rkspi.c
+++ b/tools/rkspi.c
@@ -22,22 +22,20 @@ static void rkspi_set_header(void *buf, struct stat *sbuf, int ifd,
 {
 	int sector;
 	unsigned int size;
-	int ret;
 
 	size = params->orig_file_size;
-	ret = rkcommon_set_header(buf, size, params);
-	debug("size %x\n", size);
-	if (ret) {
-		/* TODO(sjg@chromium.org): This method should return an error */
-		printf("Warning: SPL image is too large (size %#x) and will "
-		       "not boot\n", size);
-	}
+
+	rkcommon_set_header(buf, sbuf, ifd, params);
 
 	/*
 	 * Spread the image out so we only use the first 2KB of each 4KB
 	 * region. This is a feature of the SPI format required by the Rockchip
 	 * boot ROM. Its rationale is unknown.
 	 */
+	if (params->vflag)
+		fprintf(stderr, "Spreading spi image from %u to %u\n",
+			size, params->file_size);
+
 	for (sector = size / RKSPI_SECT_LEN - 1; sector >= 0; sector--) {
 		debug("sector %u\n", sector);
 		memmove(buf + sector * RKSPI_SECT_LEN * 2,
@@ -57,35 +55,23 @@ static int rkspi_check_image_type(uint8_t type)
 }
 
 /*
- * The SPI payload needs to be padded out to make space for odd half-sector
- * layout used in flash (i.e. only the first 2K of each 4K sector is used).
+ * The SPI payload needs to make space for odd half-sector layout used in flash
+ * (i.e. only the first 2K of each 4K sector is used).
  */
 static int rkspi_vrec_header(struct image_tool_params *params,
 			     struct image_type_params *tparams)
 {
-	int padding = rkcommon_vrec_header(params, tparams, RK_INIT_SIZE_ALIGN);
-	/*
-	 * The file size has not been adjusted at this point (our caller will
-	 * eventually add the header/padding to the file_size), so we need to
-	 * add up the header_size, file_size and padding ourselves.
-	 */
-	int padded_size = tparams->header_size + params->file_size + padding;
-
-	/*
-	 * We need to store the original file-size (i.e. before padding), as
-	 * imagetool does not set this during its adjustment of file_size.
-	 */
-	params->orig_file_size = padded_size;
+	rkcommon_vrec_header(params, tparams);
 
 	/*
 	 * Converting to the SPI format (i.e. splitting each 4K page into two
 	 * 2K subpages and then padding these 2K pages up to take a complete
-	 * 4K sector again) will will double the image size.
-	 *
-	 * Thus we return the padded_size as an additional padding requirement
-	 * (be sure to add this to the padding returned from the common code).
+	 * 4K sector again) which will double the image size.
 	 */
-	return padded_size + padding;
+	params->file_size = ROUND(params->file_size, RKSPI_SECT_LEN) << 1;
+
+	/* Ignoring pad len, since we are using our own copy_image() */
+	return 0;
 }
 
 /*
diff --git a/tools/zynqmpimage.c b/tools/zynqmpimage.c
index 0c9a3daddd..74bd5f5ccc 100644
--- a/tools/zynqmpimage.c
+++ b/tools/zynqmpimage.c
@@ -99,6 +99,8 @@ struct zynqmp_header {
 };
 
 static struct zynqmp_header zynqmpimage_header;
+static void *dynamic_header;
+static FILE *fpmu;
 
 static uint32_t zynqmpimage_checksum(struct zynqmp_header *ptr)
 {
@@ -181,6 +183,13 @@ static void zynqmpimage_print_header(const void *ptr)
 	printf("Image Size   : %lu bytes (%lu bytes packed)\n",
 	       (unsigned long)le32_to_cpu(zynqhdr->image_size),
 	       (unsigned long)le32_to_cpu(zynqhdr->image_stored_size));
+
+	if (zynqhdr->pfw_image_length)
+		printf("PMUFW Size   : %lu bytes (%lu bytes packed)\n",
+		       (unsigned long)le32_to_cpu(zynqhdr->pfw_image_length),
+		       (unsigned long)le32_to_cpu(
+				zynqhdr->total_pfw_image_length));
+
 	printf("Image Load   : 0x%08x\n", le32_to_cpu(zynqhdr->image_load));
 	printf("Checksum     : 0x%08x\n", le32_to_cpu(zynqhdr->checksum));
 
@@ -203,6 +212,8 @@ static void zynqmpimage_print_header(const void *ptr)
 		       le32_to_cpu(zynqhdr->register_init[i].address),
 		       le32_to_cpu(zynqhdr->register_init[i].data));
 	}
+
+	free(dynamic_header);
 }
 
 static int zynqmpimage_check_params(struct image_tool_params *params)
@@ -234,6 +245,44 @@ static int zynqmpimage_check_image_types(uint8_t type)
 	return EXIT_FAILURE;
 }
 
+static int fsize(FILE *fp)
+{
+	int size;
+	int origin = ftell(fp);
+
+	fseek(fp, 0L, SEEK_END);
+	size = ftell(fp);
+
+	/* going back */
+	fseek(fp, origin, SEEK_SET);
+
+	return size;
+}
+
+static void zynqmpimage_pmufw(struct zynqmp_header *zynqhdr,
+			      const char *filename)
+{
+	uint32_t size;
+
+	/* Setup PMU fw size */
+	zynqhdr->pfw_image_length = fsize(fpmu);
+	zynqhdr->total_pfw_image_length = zynqhdr->pfw_image_length;
+
+	zynqhdr->image_size -= zynqhdr->pfw_image_length;
+	zynqhdr->image_stored_size -= zynqhdr->total_pfw_image_length;
+
+	/* Read the whole PMUFW to the header */
+	size = fread(&zynqhdr->__reserved4[66], 1,
+		     zynqhdr->pfw_image_length, fpmu);
+	if (size != zynqhdr->pfw_image_length) {
+		fprintf(stderr, "Cannot read PMUFW file: %s\n", filename);
+		fclose(fpmu);
+		exit(1);
+	}
+
+	fclose(fpmu);
+}
+
 static void zynqmpimage_parse_initparams(struct zynqmp_header *zynqhdr,
 	const char *filename)
 {
@@ -288,6 +337,10 @@ static void zynqmpimage_set_header(void *ptr, struct stat *sbuf, int ifd,
 	if (params->eflag)
 		zynqhdr->image_load = cpu_to_le32((uint32_t)params->ep);
 
+	/* PMUFW */
+	if (fpmu)
+		zynqmpimage_pmufw(zynqhdr, params->imagename);
+
 	/* User can pass in text file with init list */
 	if (strlen(params->imagename2))
 		zynqmpimage_parse_initparams(zynqhdr, params->imagename2);
@@ -295,6 +348,50 @@ static void zynqmpimage_set_header(void *ptr, struct stat *sbuf, int ifd,
 	zynqhdr->checksum = zynqmpimage_checksum(zynqhdr);
 }
 
+static int zynqmpimage_vrec_header(struct image_tool_params *params,
+				   struct image_type_params *tparams)
+{
+	struct stat path_stat;
+	char *filename = params->imagename;
+	int err;
+
+	/* Handle static case without PMUFW */
+	tparams->header_size = sizeof(struct zynqmp_header);
+	tparams->hdr = (void *)&zynqmpimage_header;
+
+	/* PMUFW name is passed via params->imagename */
+	if (strlen(filename) == 0)
+		return EXIT_SUCCESS;
+
+	fpmu = fopen(filename, "r");
+	if (!fpmu) {
+		fprintf(stderr, "Cannot open PMUFW file: %s\n", filename);
+		return EXIT_FAILURE;
+	}
+
+	err = fstat(fileno(fpmu), &path_stat);
+	if (err) {
+		fclose(fpmu);
+		fpmu = NULL;
+		return EXIT_FAILURE;
+	}
+
+	if (!S_ISREG(path_stat.st_mode)) {
+		fclose(fpmu);
+		fpmu = NULL;
+		return EXIT_FAILURE;
+	}
+
+	/* Increase header size by PMUFW file size */
+	tparams->header_size += fsize(fpmu);
+
+	/* Allocate buffer with space for PMUFW */
+	dynamic_header = calloc(1, tparams->header_size);
+	tparams->hdr = dynamic_header;
+
+	return EXIT_SUCCESS;
+}
+
 U_BOOT_IMAGE_TYPE(
 	zynqmpimage,
 	"Xilinx ZynqMP Boot Image support",
@@ -307,5 +404,5 @@ U_BOOT_IMAGE_TYPE(
 	NULL,
 	zynqmpimage_check_image_types,
 	NULL,
-	NULL
+	zynqmpimage_vrec_header
 );
-- 
2.31.0

